[
    "PIC18F6390/6490/8390/8490 Data Sheet\n64/80-Pin Flash Microcontrollers with LCD Driver and nanoWatt Technology",
    "Note the following details of the code protection feature on Microchip devices:\nGLYPH<149> Microchip products meet the specification contained in their particular Microchip Data Sheet.\nGLYPH<149> Microchip believes that its family of products is one of the most secure families of its kind on the market today, when used in the intended manner and under normal conditions.\nGLYPH<149> There are dishonest and possibly illegal methods used to breach the code protection feature. All of these methods, to our knowledge, require using the Microchip products in a manner outside the operating specifications contained in MicrochipGLYPH<146>s Data Sheets. Most likely, the person doing so is engaged in theft of intellectual property.\nGLYPH<149> Microchip is willing to work with the customer who is concerned about the integrity of their code.\nGLYPH<149> Neither Microchip nor any other semiconductor manufacturer can guarantee the security of their code. Code protection does not mean that we are guaranteeing the product as GLYPH<147>unbreakable.GLYPH<148>",
    "Note the following details of the code protection feature on Microchip devices:\nCode protection is constantly evolving. We at Microchip are committed to continuously improving the code protection features of our products. Attempts to break MicrochipGLYPH<146>s code protection feature may be a violation of the Digital Millennium Copyright Act. If such acts allow unauthorized access to your software or other copyrighted work, you may have a right to sue for relief under that Act.",
    "Note the following details of the code protection feature on Microchip devices:\nInformation  contained  in  this  publication  regarding  device applications and the like is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure  that  your  application  meets  with  your  specifications. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES  OF  ANY  KIND  WHETHER  EXPRESS  OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION, INCLUDING  BUT  NOT  LIMITED  TO  ITS CONDITION, QUALITY, PERFORMANCE, MERCHANTABILITY OR FITNESS  FOR  PURPOSE . Microchip  disclaims  all  liability arising  from  this  information  and  its  use.  Use  of  Microchip devices in life support and/or safety applications is entirely at the buyerGLYPH<146>s risk, and the buyer agrees to defend, indemnify and hold  harmless  Microchip  from  any  and  all  damages,  claims, suits,  or  expenses  resulting  from  such  use.  No  licenses  are conveyed, implicitly or otherwise, under any Microchip intellectual property rights.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, Accuron, dsPIC, KEELOQ, KEELOQ logo, micro ID , MPLAB, PIC, PICmicro, PICSTART, PRO MATE, rfPIC and SmartShunt are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nAmpLab, FilterLab, Linear Active Thermistor, Migratable Memory, MXDEV, MXLAB, SEEVAL, SmartSensor and The Embedded Control Solutions Company are registered trademarks of Microchip Technology Incorporated in the U.S.A.",
    "Trademarks\nAnalog-for-the-Digital Age, Application Maestro, CodeGuard, dsPICDEM, dsPICDEM.net, dsPICworks, dsSPEAK, ECAN, ECONOMONITOR, FanSense, FlexROM, fuzzyLAB, In-Circuit Serial Programming, ICSP, ICEPIC, Mindi, MiWi, MPASM, MPLAB Certified logo, MPLIB, MPLINK, PICkit, PICDEM, PICDEM.net, PICLAB, PICtail, PowerCal, PowerInfo, PowerMate, PowerTool, REAL ICE, rfLAB, Select Mode, Smart Serial, SmartTel, Total Endurance, UNI/O, WiperLock and ZENA are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nAll other trademarks mentioned herein are property of their respective companies.\n' 2007, Microchip Technology Incorporated, Printed in the U.S.A., All Rights Reserved.\nPrinted on recycled paper.",
    "Trademarks\nMicrochip received ISO/TS-16949:2002 certification for its worldwide headquarters, design and wafer fabrication facilities in Chandler and Tempe, Arizona; Gresham, Oregon and design centers in California and India. The CompanyGLYPH<146>s quality system processes and procedures are for its PIC fi MCUs and dsPIC fi  DSCs, KEELOQ fi  code hopping devices, Serial EEPROMs, microperipherals, nonvolatile memory and analog products. In addition, MicrochipGLYPH<146>s quality system for the design and manufacture of development systems is ISO 9001:2000 certified.\nQUALITY MANAGEMENT SYSTEM CERTIFIED BY DNV",
    "Peripheral Highlights:\nGLYPH<149> Direct Driving of LCD Panel\nGLYPH<149> Up to 48 Segments: Software Selectable\nGLYPH<149> Programmable LCD Timing module:\n-Multiple LCD timing sources available\n-Up to 4 commons: Static, 1/2, 1/3 or 1/4 multiplex\n-Static, 1/2 or 1/3 bias configuration\nGLYPH<149> Can drive LCD Panel while in Sleep mode",
    "Power-Managed Modes:\nGLYPH<149> Run: CPU On, Peripherals On\nGLYPH<149> Idle: CPU Off, Peripherals On\nGLYPH<149> Sleep: CPU Off, Peripherals Off\nGLYPH<149> Run mode Currents Down to 14.0 \u03bc A Typical\nGLYPH<149> Idle mode Currents Down to 5.8 \u03bc A Typical\nGLYPH<149> Sleep Current Down to 0.1 \u03bc A Typical\nGLYPH<149> Timer1 Oscillator: 1.8 \u03bc A, 32 kHz, 2V\nGLYPH<149> Watchdog Timer: 2.1 \u03bc A\nGLYPH<149> Two-Speed Oscillator Start-up",
    "Flexible Oscillator Structure:\nGLYPH<149> Four Crystal modes:\n-LP: up to 200 kHz\n-XT: up to 4 MHz\n-HS: up to 40 MHz\n-HSPLL: 4-10 MHz (16-40 MHz internal)\nGLYPH<149> 4x Phase Lock Loop (available for crystal and internal oscillators)\nGLYPH<149> Two External RC modes, up to 4 MHz\nGLYPH<149> Two External Clock modes, up to 40 MHz\nGLYPH<149> Internal Oscillator Block:\n-8 user-selectable frequencies, from 31 kHz to 8 MHz\n-Provides a complete range of clock speeds from 31 kHz to 32 MHz when used with PLL\n-User-tunable to compensate for frequency drift\nGLYPH<149> Secondary Oscillator using Timer1 @ 32 kHz\nGLYPH<149> Fail-Safe Clock Monitor:\nGLYPH<149> High-Current Sink/Source 25 mA/25 mA\nGLYPH<149> Four External Interrupts\nGLYPH<149> Four Input Change Interrupts\nGLYPH<149> Four 8-Bit/16-Bit Timer/Counter modules",
    "Flexible Oscillator Structure:\nGLYPH<149> Real-Time Clock (RTC) Software module:\n-Configurable 24-hour clock, calendar, automatic 100-year or 12800-year, day-of-week calculator\n-Uses Timer1\nGLYPH<149> Up to 2 Capture/Compare/PWM (CCP) modules\nGLYPH<149> Master Synchronous Serial Port (MSSP) module supporting 3-Wire SPI (all 4 modes) and I 2 CGLYPH<153> Master and Slave modes\nGLYPH<149> Addressable USART module:\n-Supports RS-485 and RS-232\nGLYPH<149> Enhanced Addressable USART module:\n-Supports RS-485, RS-232 and LIN 1.2\n-Auto-wake-up on Start bit\n-Auto-Baud Detect\nGLYPH<149> 10-Bit, up to 12-Channel Analog-to-Digital (A/D) Converter module:\n-Auto-acquisition capability\n-Conversion available during Sleep\nGLYPH<149> Dual Analog Comparators with Input Multiplexing",
    "Special Microcontroller Features:\nGLYPH<149> C Compiler Optimized Architecture:\n-Optional extended instruction set designed to optimize re-entrant code\nGLYPH<149> 1000 Erase/Write Cycle Flash Program Memory Typical\nGLYPH<149> Flash Retention: 100 Years Typical\nGLYPH<149> Priority Levels for Interrupts\nGLYPH<149> 8 x 8 Single-Cycle Hardware Multiplier\nGLYPH<149> Extended Watchdog Timer (WDT):\n-Programmable period from 4 ms to 132s\n-2% stability over VDD and temperature\nGLYPH<149> In-Circuit Serial ProgrammingGLYPH<153> (ICSPGLYPH<153>) via Two Pins\nGLYPH<149> In-Circuit Debug (ICD) via Two Pins\nGLYPH<149> Wide Operating Voltage Range: 2.0V to 5.5V\n-Allows for safe shut down of device if primary or secondary clock fails",
    "Special Microcontroller Features:\nPIC18F6390, Program Memory.Flash (bytes) = 8K. PIC18F6390, Program Memory.# Single-Word Instructions = 4096. PIC18F6390, Data Memory.SRAM (bytes) = 768. PIC18F6390, I/O.I/O = 50. PIC18F6390, LCD (pixel).LCD (pixel) = 128. PIC18F6390, 10-Bit A/D (ch).10-Bit A/D (ch) = 12. PIC18F6390, CCP (PWM).CCP (PWM) = 2. PIC18F6390, MSSP.SPI = Y. PIC18F6390, MSSP.Master I 2 CGLYPH<153> = Y. PIC18F6390, EUSART/ AUSART.EUSART/ AUSART = 1/1. PIC18F6390, Comparators.Comparators = 2. PIC18F6390, Timers 8/16-Bit.Timers 8/16-Bit =",
    "Special Microcontroller Features:\n1/3. PIC18F6490, Program Memory.Flash (bytes) = 16K. PIC18F6490, Program Memory.# Single-Word Instructions = 8192. PIC18F6490, Data Memory.SRAM (bytes) = 768. PIC18F6490, I/O.I/O = 50. PIC18F6490, LCD (pixel).LCD (pixel) = 128. PIC18F6490, 10-Bit A/D (ch).10-Bit A/D (ch) = 12. PIC18F6490, CCP (PWM).CCP (PWM) = 2. PIC18F6490, MSSP.SPI = Y. PIC18F6490, MSSP.Master I 2 CGLYPH<153> = Y. PIC18F6490, EUSART/ AUSART.EUSART/ AUSART = 1/1. PIC18F6490, Comparators.Comparators = 2. PIC18F6490, Timers 8/16-Bit.Timers 8/16-Bit = 1/3.",
    "Special Microcontroller Features:\nPIC18F8390, Program Memory.Flash (bytes) = 8K. PIC18F8390, Program Memory.# Single-Word Instructions = 4096. PIC18F8390, Data Memory.SRAM (bytes) = 768. PIC18F8390, I/O.I/O = 66. PIC18F8390, LCD (pixel).LCD (pixel) = 192. PIC18F8390, 10-Bit A/D (ch).10-Bit A/D (ch) = 12. PIC18F8390, CCP (PWM).CCP (PWM) = 2. PIC18F8390, MSSP.SPI = Y. PIC18F8390, MSSP.Master I 2 CGLYPH<153> = Y. PIC18F8390, EUSART/ AUSART.EUSART/ AUSART = 1/1. PIC18F8390, Comparators.Comparators = 2. PIC18F8390, Timers 8/16-Bit.Timers 8/16-Bit =",
    "Special Microcontroller Features:\n1/3. PIC18F8490, Program Memory.Flash (bytes) = 16K. PIC18F8490, Program Memory.# Single-Word Instructions = 8192. PIC18F8490, Data Memory.SRAM (bytes) = 768. PIC18F8490, I/O.I/O = 66. PIC18F8490, LCD (pixel).LCD (pixel) = 192. PIC18F8490, 10-Bit A/D (ch).10-Bit A/D (ch) = 12. PIC18F8490, CCP (PWM).CCP (PWM) = 2. PIC18F8490, MSSP.SPI = Y. PIC18F8490, MSSP.Master I 2 CGLYPH<153> = Y. PIC18F8490, EUSART/ AUSART.EUSART/ AUSART = 1/1. PIC18F8490, Comparators.Comparators = 2. PIC18F8490, Timers 8/16-Bit.Timers",
    "Special Microcontroller Features:\n8/16-Bit = 1/3",
    "Table of Contents\n1.0, 1 = Device Overview ........................................................................................................................................................................... 1.0, 2 = 7. 2.0, 1 = Oscillator Configurations",
    "Table of Contents\n............................................................................................................................................................. 2.0, 2 = 31. 3.0, 1 = Power-Managed Modes",
    "Table of Contents\n.............................................................................................................................................................. 3.0, 2 = 41. 4.0, 1 =",
    "Table of Contents\nReset........................................................................................................................................................................................... 4.0, 2 = 51. 5.0, 1 = Memory",
    "Table of Contents\nOrganization.................................................................................................................................................................. 5.0, 2 = 65. 6.0, 1 = Flash Program",
    "Table of Contents\nMemory............................................................................................................................................................... 6.0, 2 = 87. 7.0, 1 = 8 x 8 Hardware",
    "Table of Contents\nMultiplier............................................................................................................................................................. 7.0, 2 = 91. 8.0, 1 = Interrupts",
    "Table of Contents\n..................................................................................................................................................................................... 8.0, 2 = 93. 9.0, 1 = I/O Ports",
    "Table of Contents\n.................................................................................................................................................................................... 9.0, 2 = 109. 10.0, 1 = Timer0 Module",
    "Table of Contents\n.......................................................................................................................................................................... 10.0, 2 = 131. 11.0, 1 = Timer1 Module",
    "Table of Contents\n.......................................................................................................................................................................... 11.0, 2 = 135. 12.0, 1 = Timer2 Module",
    "Table of Contents\n.......................................................................................................................................................................... 12.0, 2 = 141. 13.0, 1 = Timer3 Module",
    "Table of Contents\n.......................................................................................................................................................................... 13.0, 2 = 143. 14.0, 1 = Capture/Compare/PWM (CCP) Modules",
    "Table of Contents\n.................................................................................................................................. 14.0, 2 = 147. 15.0, 1 = Master Synchronous Serial Port (MSSP) Module",
    "Table of Contents\n..................................................................................................................... 15.0, 2 = 157. 16.0, 1 = Enhanced Universal Synchronous Asynchronous Receiver Transmitter (EUSART)................................................................ 16.0, 2 = 197. 17.0, 1 = Addressable Universal Synchronous Asynchronous Receiver Transmitter (AUSART)",
    "Table of Contents\n............................................................ 17.0, 2 = 217. 18.0, 1 = 10-Bit Analog-to-Digital Converter (A/D) Module ...................................................................................................................... 18.0, 2 = 231. 19.0, 1 = Comparator",
    "Table of Contents\nModule................................................................................................................................................................... 19.0, 2 = 241. 20.0, 1 = Comparator Voltage Reference",
    "Table of Contents\nModule.................................................................................................................................... 20.0, 2 = 247. 21.0, 1 = High/Low-Voltage Detect",
    "Table of Contents\n(HLVD).............................................................................................................................................. 21.0, 2 = 251. 22.0, 1 = Liquid Crystal Display (LCD) Driver",
    "Table of Contents\nModule.............................................................................................................................. 22.0, 2 = 257. 23.0, 1 = Special Features of the",
    "Table of Contents\nCPU..................................................................................................................................................... 23.0, 2 = 281. 24.0, 1 = Instruction Set",
    "Table of Contents\nSummary........................................................................................................................................................... 24.0, 2 = 295. 25.0, 1 = Development",
    "Table of Contents\nSupport................................................................................................................................................................ 25.0, 2 = 345. 26.0, 1 = Electrical Characteristics",
    "Table of Contents\n........................................................................................................................................................... 26.0, 2 = 349. 27.0, 1 = DC and AC Characteristics Graphs and",
    "Table of Contents\nTables........................................................................................................................ 27.0, 2 = 387. 28.0, 1 = Packaging",
    "Table of Contents\nInformation............................................................................................................................................................... 28.0, 2 = 389. Appendix A: Revision",
    "Table of Contents\nHistory............................................................................................................................................................., 1 = Appendix A: Revision",
    "Table of Contents\nHistory.............................................................................................................................................................. Appendix A: Revision",
    "Table of Contents\nHistory............................................................................................................................................................., 2 = 395. Appendix B: Device",
    "Table of Contents\nDifferences......................................................................................................................................................... Appendix C: Conversion Considerations",
    "Table of Contents\n..........................................................................................................................................., 1 = Appendix B: Device",
    "Table of Contents\nDifferences......................................................................................................................................................... Appendix C: Conversion Considerations",
    "Table of Contents\n............................................................................................................................................ Appendix B: Device",
    "Table of Contents\nDifferences......................................................................................................................................................... Appendix C: Conversion Considerations",
    "Table of Contents\n..........................................................................................................................................., 2 = 395. , 1 = . , 2 = 396. Appendix D: Migration from Baseline to Enhanced",
    "Table of Contents\nDevices.............................................................................................................., 1 = Appendix D: Migration from Baseline to Enhanced Devices............................................................................................................... Appendix D: Migration from Baseline to Enhanced",
    "Table of Contents\nDevices.............................................................................................................., 2 = 396. Appendix E: migration from Mid-Range to Enhanced Devices .........................................................................................................., 1 = Appendix E: migration from Mid-Range to Enhanced Devices",
    "Table of Contents\n........................................................................................................... Appendix E: migration from Mid-Range to Enhanced Devices .........................................................................................................., 2 = 397. Appendix F: Migration from High-End to Enhanced",
    "Table of Contents\nDevices............................................................................................................., 1 = Appendix F: Migration from High-End to Enhanced Devices.............................................................................................................. Appendix F: Migration from High-End to Enhanced",
    "Table of Contents\nDevices............................................................................................................., 2 = 397. Index",
    "Table of Contents\n.................................................................................................................................................................................................., 1 = Index",
    "Table of Contents\n................................................................................................................................................................................................... Index",
    "Table of Contents\n.................................................................................................................................................................................................., 2 = 399. The Microchip Web",
    "Table of Contents\nSite....................................................................................................................................................................., 1 = The Microchip Web",
    "Table of Contents\nSite...................................................................................................................................................................... The Microchip Web",
    "Table of Contents\nSite....................................................................................................................................................................., 2 = 409. Customer Change Notification Service",
    "Table of Contents\n.............................................................................................................................................., 1 = Customer Change Notification Service",
    "Table of Contents\n............................................................................................................................................... Customer Change Notification Service",
    "Table of Contents\n.............................................................................................................................................., 2 = 409. Customer",
    "Table of Contents\nSupport.............................................................................................................................................................................., 1 = Customer",
    "Table of Contents\nSupport............................................................................................................................................................................... Customer",
    "Table of Contents\nSupport.............................................................................................................................................................................., 2 = 409. Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................., 1 = Reader",
    "Table of Contents\nResponse............................................................................................................................................................................... Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................., 2 = 410. PIC18F6390/6490/8390/8490 Product Identification System",
    "Table of Contents\n............................................................................................................, 1 = PIC18F6390/6490/8390/8490 Product Identification System ............................................................................................................. PIC18F6390/6490/8390/8490",
    "Table of Contents\nProduct Identification System ............................................................................................................, 2 = 411",
    "TO OUR VALUED CUSTOMERS\nIt is our intention to provide our valued customers with the best documentation possible to ensure successful use of your Microchip products. To this end, we will continue to improve our publications to better suit your needs. Our publications will be refined and enhanced as new volumes and updates are introduced.\nIf you have any questions or comments regarding this publication, please contact the Marketing Communications Department via E-mail at docerrors@mail.microchip.com or fax the Reader Response Form in the back of this data sheet to (480) 792-4150. We welcome your feedback.",
    "Most Current Data Sheet\nTo obtain the most up-to-date version of this data sheet, please register at our Worldwide Web site at:\nhttp://www.microchip.com\nYou can determine the version of a data sheet by examining its literature number found on the bottom outside corner of any page. The last character of the literature number is the version number, (e.g., DS30000A is version A of document DS30000).",
    "Errata\nAn errata sheet, describing minor operational differences from the data sheet and recommended workarounds, may exist for current devices. As device/documentation issues become known to us, we will publish an errata sheet. The errata will specify the revision of silicon and revision of document to which it applies.\nTo determine if an errata sheet exists for a particular device, please check with one of the following:\nGLYPH<149> MicrochipGLYPH<146>s Worldwide Web site; http://www.microchip.com\nGLYPH<149> Your local Microchip sales office (see last page)\nGLYPH<149> The Microchip Corporate Literature Center; U.S. FAX: (480) 792-7277\nWhen contacting a sales office or the literature center, please specify which device, revision of silicon and data sheet (include literature number) you are using.",
    "Customer Notification System\nRegister on our web site at www.microchip.com/cn to receive the most current information on all of our products.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "1.0 DEVICE OVERVIEW\nThis document contains device-specific information for the following devices:\nGLYPH<149> PIC18F6390\nGLYPH<149> PIC18F8390\nGLYPH<149> PIC18F6490\nGLYPH<149> PIC18F8490\nThis family offers the advantages of all PIC18 microcontrollers GLYPH<150> namely, high computational performance  at  an  economical  price.  In  addition  to these features, the PIC18F6390/6490/8390/8490 family  introduces  design  enhancements  that  make these microcontrollers a logical choice for many high-performance, power-sensitive applications.",
    "1.1.1 nanoWatt TECHNOLOGY\nAll of the devices in the PIC18F6390/6490/8390/8490 family incorporate a range of features that can significantly reduce power consumption during operation. Key items include:\nGLYPH<149> Alternate Run Modes: By clocking the controller from the Timer1 source or the internal oscillator block, power consumption during code execution can be reduced by as much as 90%.\nGLYPH<149> Multiple Idle Modes: The controller can also run with its CPU core disabled, but the peripherals still active. In these states, power consumption can be reduced even further GLYPH<150> to as little as 4% of normal operation requirements.\nGLYPH<149> On-the-Fly Mode Switching: The power-managed modes are invoked by user code during operation, allowing the user to incorporate power-saving ideas into their applicationGLYPH<146>s software design.\nGLYPH<149> Lower Consumption in Key Modules: The power requirements for both Timer1 and the Watchdog Timer have been reduced by up to 80%, with typical values of 1.1 \u03bc A and 2.1 \u03bc A, respectively.",
    "1.1.2 MULTIPLE OSCILLATOR OPTIONS AND FEATURES\nAll of the devices in the PIC18F6390/6490/8390/8490 family  offer  ten  different  oscillator  options,  allowing users a wide range of choices in developing application hardware. These include:\nGLYPH<149> Four Crystal modes using crystals or ceramic resonators.\nGLYPH<149> Two External Clock modes offering the option of using two pins (oscillator input and a divide-by-4 clock output) or one pin (oscillator input, with the second pin reassigned as general I/O).\nGLYPH<149> Two External RC Oscillator modes with the same pin options as the External Clock modes.\nGLYPH<149> An internal oscillator block which provides an 8 MHz clock (-2% accuracy) and an INTRC source (approximately 31 kHz, stable over temperature and VDD), as well as a range of six user-selectable clock frequencies between 125 kHz to 4 MHz for a total of eight clock frequencies. This option frees the two oscillator pins for use as additional general purpose I/O.",
    "1.1.2 MULTIPLE OSCILLATOR OPTIONS AND FEATURES\nGLYPH<149> A Phase Lock Loop (PLL) frequency multiplier, available to both the High-Speed Crystal and Internal Oscillator modes, which allows clock speeds of up to 40 MHz. Used with the internal oscillator, the PLL gives users a complete selection of clock speeds from 31 kHz to 32 MHz GLYPH<150> all without using an external crystal or clock circuit.\nBesides its availability as a clock source, the internal oscillator block provides a stable reference source that gives the family additional features for robust operation:\nGLYPH<149> Fail-Safe Clock Monitor: This option constantly monitors the main clock source against a reference signal provided by the internal oscillator. If a clock failure occurs, the controller is switched to the internal oscillator block, allowing for continued low-speed operation or a safe application shutdown.\nGLYPH<149> Two-Speed Start-up: This option allows the internal oscillator to serve as the clock source from Power-on Reset or wake-up from Sleep mode until the primary clock source is available.",
    "1.2 Other Special Features\n- GLYPH<149> Memory Endurance: The Flash cells for program memory are rated to last for approximately a thousand erase/write cycles. Data retention without refresh is conservatively estimated to be greater than 100 years.",
    "1.3 Details on Individual Family Members\nGLYPH<149> Extended Instruction Set: The PIC18F6390/6490/8390/8490 family introduces an optional extension to the PIC18 instruction set, which adds 8 new instructions and an Indexed Addressing mode. This extension, enabled as a device configuration option, has been specifically designed to optimize re-entrant application code originally developed in high-level languages such as C.\nGLYPH<149> Enhanced Addressable USART: This serial communication module is capable of standard RS-232 operation and provides support for the LIN bus protocol. Other enhancements include Automatic Baud Rate Detection and a 16-bit Baud Rate Generator for improved resolution. When the microcontroller is using the internal oscillator block, the EUSART provides stable operation for applications that talk to the outside world, without using an external crystal (or its accompanying power requirement).\nGLYPH<149> 10-Bit A/D Converter: This module incorporates programmable acquisition time, allowing for a channel to be selected and a conversion to be initiated without waiting for a sampling period and thus, reduces code overhead.",
    "1.3 Details on Individual Family Members\nGLYPH<149> Extended Watchdog Timer (WDT): This enhanced version incorporates a 16-bit prescaler, allowing a time-out range from 4 ms to over 10 minutes that is stable across operating voltage and temperature.\nDevices in the PIC18F6390/6490/8390/8490 family are available in 64-pin (PIC18F6X90) and 80-pin (PIC18F8X90) packages. Block diagrams for the two groups are shown  in Figure 1-1 and Figure 1-2, respectively.\nThe devices are differentiated from each other in three ways:\n1. I/O Ports: 7 bidirectional ports on 64-pin devices; 9 bidirectional ports on 80-pin devices.\n2. LCD Pixels: 128 (32 SEGs x 4 COMs) pixels can be  driven  by  64-pin  devices;  192  (48  SEGs  x 4 COMs) pixels can be driven by 80-pin devices.\n3. Flash Program Memory: 8 Kbytes for PIC18FX390 devices; 16 Kbytes for PIC18FX490.",
    "1.3 Details on Individual Family Members\nAll other features for devices in this family are identical. These are summarized in Table 1-1.\nThe pinouts for all devices are listed in Table 1-2 and Table 1-3.\nLike  all  Microchip  PIC18  devices,  members  of  the PIC18F6390/6490/8390/8490  family  are  available  as both standard and  low-voltage devices. Standard devices with Flash memory, designated with an GLYPH<147>FGLYPH<148> in the part number (such as PIC18F6390), accommodate an operating VDD range of 4.2V to 5.5V. Low-voltage parts,  designated  by  GLYPH<147>LFGLYPH<148> (such  as  PIC18LF6490), function over an extended VDD range of 2.0V to 5.5V.",
    "TABLE 1-1: DEVICE FEATURES\nOperating Frequency, PIC18F6390 = DC GLYPH<150> 40 MHz. Operating Frequency, PIC18F6490 = DC GLYPH<150> 40 MHz. Operating Frequency, PIC18F8390 = DC GLYPH<150> 40 MHz. Operating Frequency, PIC18F8490 = DC GLYPH<150> 40 MHz. Program Memory (Bytes), PIC18F6390 = 8K. Program Memory (Bytes), PIC18F6490 = 16K. Program Memory (Bytes), PIC18F8390 = 8K. Program Memory (Bytes), PIC18F8490 = 16K. Program Memory (Instructions), PIC18F6390 = 4096. Program Memory (Instructions), PIC18F6490 = 8192. Program Memory (Instructions), PIC18F8390 = 4096. Program Memory (Instructions), PIC18F8490 = 8192. Data Memory (Bytes), PIC18F6390 = 768. Data Memory (Bytes), PIC18F6490 = 768. Data Memory (Bytes),",
    "TABLE 1-1: DEVICE FEATURES\nPIC18F8390 = 768. Data Memory (Bytes), PIC18F8490 = 768. Interrupt Sources, PIC18F6390 = 22. Interrupt Sources, PIC18F6490 = 22. Interrupt Sources, PIC18F8390 = 22. Interrupt Sources, PIC18F8490 = 22. I/O Ports, PIC18F6390 = Ports A, B, C, D, E, F, G. I/O Ports, PIC18F6490 = Ports A, B, C, D, E, F, G. I/O Ports, PIC18F8390 = Ports A, B, C, D, E, F, G, H, J. I/O Ports, PIC18F8490 = Ports A, B, C, D, E, F, G, H, J. Number of Pixels the LCD Driver can Drive, PIC18F6390 = 128 (32 SEGs x 4 COMs). Number of Pixels the LCD Driver can Drive, PIC18F6490 = 128 (32 SEGs x 4 COMs). Number of Pixels the LCD Driver can",
    "TABLE 1-1: DEVICE FEATURES\nDrive, PIC18F8390 = 192 (48 SEGs x 4 COMs). Number of Pixels the LCD Driver can Drive, PIC18F8490 = 192 (48 SEGs x 4 COMs). Timers, PIC18F6390 = 4. Timers, PIC18F6490 = 4. Timers, PIC18F8390 = 4. Timers, PIC18F8490 = 4. Capture/Compare/PWM Modules, PIC18F6390 = 2. Capture/Compare/PWM Modules, PIC18F6490 = 2. Capture/Compare/PWM Modules, PIC18F8390 = 2. Capture/Compare/PWM Modules, PIC18F8490 = 2. Serial Communications, PIC18F6390 = MSSP, AUSART Enhanced USART. Serial Communications, PIC18F6490 = MSSP, AUSART Enhanced USART. Serial Communications, PIC18F8390 = MSSP, AUSART Enhanced USART. Serial Communications, PIC18F8490 = MSSP, AUSART Enhanced USART. 10-Bit Analog-to-Digital",
    "TABLE 1-1: DEVICE FEATURES\nModule, PIC18F6390 = 12 Input Channels. 10-Bit Analog-to-Digital Module, PIC18F6490 = 12 Input Channels. 10-Bit Analog-to-Digital Module, PIC18F8390 = 12 Input Channels. 10-Bit Analog-to-Digital Module, PIC18F8490 = 12 Input Channels. Resets (and Delays), PIC18F6390 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR (optional), WDT. Resets (and Delays), PIC18F6490 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR (optional), WDT. Resets (and Delays), PIC18F8390 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR (optional), WDT. Resets (and Delays), PIC18F8490 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST),",
    "TABLE 1-1: DEVICE FEATURES\nMCLR (optional), WDT. Programmable Low-Voltage Detect, PIC18F6390 = Yes. Programmable Low-Voltage Detect, PIC18F6490 = Yes. Programmable Low-Voltage Detect, PIC18F8390 = Yes. Programmable Low-Voltage Detect, PIC18F8490 = Yes. Programmable Brown-out Reset, PIC18F6390 = Yes. Programmable Brown-out Reset, PIC18F6490 = Yes. Programmable Brown-out Reset, PIC18F8390 = Yes. Programmable Brown-out Reset, PIC18F8490 = Yes. Instruction Set, PIC18F6390 = 75 Instructions; 83 with Extended Instruction Set Enabled. Instruction Set, PIC18F6490 = 75 Instructions; 83 with Extended Instruction Set Enabled. Instruction Set, PIC18F8390 = 75 Instructions; 83 with Extended Instruction Set Enabled. Instruction Set, PIC18F8490 = 75 Instructions; 83 with Extended Instruction Set Enabled. Packages, PIC18F6390 = 64-Pin TQFP. Packages, PIC18F6490 = 64-Pin TQFP. Packages,",
    "TABLE 1-1: DEVICE FEATURES\nPIC18F8390 = 80-Pin TQFP. Packages, PIC18F8490 = 80-Pin TQFP",
    "PIC18F6X90 (64-PIN) BLOCK DIAGRAM\nNote 1: CCP2 is multiplexed with RC1 when Configuration bit, CCP2MX, is set, or RE7 when CCP2MX is not set.\n2: RG5 is only available when MCLR functionality is disabled.\n3: OSC1/CLKI and OSC2/CLKO are only available in select oscillator modes and when these pins are not being used as digital I/O. Refer to Section 2.0 GLYPH<147>Oscillator ConfigurationsGLYPH<148> for additional information.",
    "PIC18F8X90 (80-PIN) BLOCK DIAGRAM\nNote 1: CCP2 is multiplexed with RC1 when Configuration bit, CCP2MX, is set and RE7 when CCP2MX is not set.\n2: RG5 is only available when MCLR functionality is disabled.\n3: OSC1/CLKI and OSC2/CLKO are only available in select oscillator modes and when these pins are not being used as digital I/O. Refer to Section 2.0 GLYPH<147>Oscillator ConfigurationsGLYPH<148> for additional information.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS\nMCLR/VPP/RG5, Pin Number.TQFP = 7. MCLR/VPP/RG5, Pin Type. = . MCLR/VPP/RG5, Buffer Type. = . MCLR/VPP/RG5, Description. = Master Clear (input) or programming voltage (input).. MCLR, Pin Number.TQFP = . MCLR, Pin Type. = I. MCLR, Buffer Type. = ST. MCLR, Description. = Master Clear (Reset) input. This pin is an active-low Reset to the device.. VPP, Pin Number.TQFP = . VPP, Pin Type. = P. VPP, Buffer Type. = . VPP, Description. = Programming voltage input.. RG5, Pin Number.TQFP = . RG5, Pin Type. = I. RG5, Buffer Type. = ST. RG5, Description. = Digital input.. OSC1/CLKI/RA7, Pin Number.TQFP = 39. OSC1/CLKI/RA7, Pin Type.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS\n= . OSC1/CLKI/RA7, Buffer Type. = . OSC1/CLKI/RA7, Description. = Oscillator crystal or external clock input.. OSC1, Pin Number.TQFP = . OSC1, Pin Type. = I. OSC1, Buffer Type. = ST. OSC1, Description. = Oscillator crystal input or external clock source input. ST buffer when configured in RC mode, CMOS otherwise.. CLKI, Pin Number.TQFP = . CLKI, Pin Type. = I. CLKI, Buffer Type. = CMOS. CLKI, Description. = External clock source input. Always associated with pin function OSC1. (See related OSC1/CLKI, OSC2/CLKO pins.). RA7, Pin Number.TQFP = . RA7, Pin Type. = I/O. RA7, Buffer Type. = TTL. RA7, Description. = General purpose I/O pin.. OSC2/CLKO/RA6, Pin Number.TQFP = 40.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS\nOSC2/CLKO/RA6, Pin Type. = . OSC2/CLKO/RA6, Buffer Type. = . OSC2/CLKO/RA6, Description. = Oscillator crystal or clock output.. OSC2, Pin Number.TQFP = . OSC2, Pin Type. = O. OSC2, Buffer Type. = GLYPH<151>. OSC2, Description. = Oscillator crystal output. Connects to crystal or resonator in Crystal Oscillator mode.. CLKO, Pin Number.TQFP = . CLKO, Pin Type. = O. CLKO, Buffer Type. = GLYPH<151>. CLKO, Description. = In RC mode, OSC2 pin outputs CLKO, which has 1/4 the frequency of OSC1 and denotes the instruction cycle rate.. RA6, Pin Number.TQFP = . RA6, Pin Type. = I/O. RA6, Buffer Type. = TTL. RA6, Description. = General purpose I/O pin.\nLegend:",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS\nTTL =  TTL compatible input\nST =  Schmitt Trigger input with CMOS levels\nI =  Input\nP =  Power\nNote 1: Default assignment for CCP2 when Configuration bit, CCP2MX, is set.\n2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.\nCMOS\n=  CMOS compatible input or output\nAnalog\n=  Analog input\nO\n=  Output\nOD\n=  Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRA0/AN0, Pin Number.TQFP = 24. RA0/AN0, Pin Type. = . RA0/AN0, Buffer Type. = . RA0/AN0, Description. = . RA0, Pin Number.TQFP = . RA0, Pin Type. = I/O. RA0, Buffer Type. = TTL. RA0, Description. = Digital I/O.. AN0, Pin Number.TQFP = . AN0, Pin Type. = I. AN0, Buffer Type. = Analog. AN0, Description. = Analog input 0.. RA1/AN1, Pin Number.TQFP = 23. RA1/AN1, Pin Type. = . RA1/AN1, Buffer Type. = . RA1/AN1, Description. = . RA1, Pin Number.TQFP = . RA1, Pin Type. = I/O. RA1, Buffer Type. = TTL. RA1, Description. = Digital I/O.. AN1, Pin Number.TQFP = . AN1, Pin Type. = I.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nAN1, Buffer Type. = Analog. AN1, Description. = Analog input 1.. RA2/AN2/VREF-/SEG16, Pin Number.TQFP = 22. RA2/AN2/VREF-/SEG16, Pin Type. = . RA2/AN2/VREF-/SEG16, Buffer Type. = . RA2/AN2/VREF-/SEG16, Description. = . RA2, Pin Number.TQFP = . RA2, Pin Type. = I/O. RA2, Buffer Type. = TTL. RA2, Description. = Digital I/O.. AN2, Pin Number.TQFP = . AN2, Pin Type. = I. AN2, Buffer Type. = Analog. AN2, Description. = Analog input 2.. VREF-, Pin Number.TQFP = . VREF-, Pin Type. = I. VREF-, Buffer Type. = Analog. VREF-, Description. = A/D reference voltage (Low) input.. SEG16, Pin",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.TQFP = . SEG16, Pin Type. = O. SEG16, Buffer Type. = Analog. SEG16, Description. = SEG16 output for LCD.. RA3/AN3/VREF+/SEG17, Pin Number.TQFP = 21. RA3/AN3/VREF+/SEG17, Pin Type. = . RA3/AN3/VREF+/SEG17, Buffer Type. = . RA3/AN3/VREF+/SEG17, Description. = . RA3, Pin Number.TQFP = . RA3, Pin Type. = I/O. RA3, Buffer Type. = TTL. RA3, Description. = Digital I/O.. AN3, Pin Number.TQFP = . AN3, Pin Type. = I. AN3, Buffer Type. = Analog. AN3, Description. = Analog input 3.. VREF+, Pin Number.TQFP = . VREF+, Pin Type. = I. VREF+, Buffer Type. = Analog. VREF+,",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nDescription. = A/D reference voltage (High) input.. SEG17, Pin Number.TQFP = . SEG17, Pin Type. = O. SEG17, Buffer Type. = Analog. SEG17, Description. = SEG17 output for LCD.. RA4/T0CKI/SEG14, Pin Number.TQFP = 28. RA4/T0CKI/SEG14, Pin Type. = . RA4/T0CKI/SEG14, Buffer Type. = . RA4/T0CKI/SEG14, Description. = . RA4, Pin Number.TQFP = . RA4, Pin Type. = I/O. RA4, Buffer Type. = ST/OD. RA4, Description. = Digital I/O. Open-drain when configured as output.. T0CKI, Pin Number.TQFP = . T0CKI, Pin Type. = I. T0CKI, Buffer Type. = ST. T0CKI, Description. = Timer0 external clock input.. SEG14, Pin Number.TQFP = .",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nSEG14, Pin Type. = O. SEG14, Buffer Type. = Analog. SEG14, Description. = SEG14 output for LCD.. RA5/AN4/HLVDIN/SEG15, Pin Number.TQFP = 27. RA5/AN4/HLVDIN/SEG15, Pin Type. = . RA5/AN4/HLVDIN/SEG15, Buffer Type. = . RA5/AN4/HLVDIN/SEG15, Description. = . RA5, Pin Number.TQFP = . RA5, Pin Type. = I/O. RA5, Buffer Type. = TTL. RA5, Description. = Digital I/O.. AN4, Pin Number.TQFP = . AN4, Pin Type. = I. AN4, Buffer Type. = Analog. AN4, Description. = Analog input 4.. HLVDIN, Pin Number.TQFP = . HLVDIN, Pin Type. = I. HLVDIN, Buffer Type. = Analog.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nHLVDIN, Description. = Low-Voltage Detect input.. SEG15, Pin Number.TQFP = . SEG15, Pin Type. = O. SEG15, Buffer Type. = Analog. SEG15, Description. = SEG15 output for LCD.. RA6, Pin Number.TQFP = . RA6, Pin Type. = . RA6, Buffer Type. = . RA6, Description. = See the OSC2/CLKO/RA6 pin.. RA7, Pin Number.TQFP = . RA7, Pin Type. = . RA7, Buffer Type. = . RA7, Description. = See the OSC1/CLKI/RA7 pin.\nLegend:\nTTL =  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI =  Input\nO\n=  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1:\nDefault assignment for CCP2 when Configuration bit, CCP2MX, is set.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\n2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB0/INT0, Pin Number.TQFP = 48. RB0/INT0, Pin Type. = . RB0/INT0, Buffer Type. = . RB0/INT0, Description. = . RB0, Pin Number.TQFP = . RB0, Pin Type. = I/O. RB0, Buffer Type. = TTL. RB0, Description. = Digital I/O.. INT0, Pin Number.TQFP = . INT0, Pin Type. = I. INT0, Buffer Type. = ST. INT0, Description. = External interrupt 0.. RB1/INT1/SEG8, Pin Number.TQFP = 47. RB1/INT1/SEG8, Pin Type. = . RB1/INT1/SEG8, Buffer Type. = . RB1/INT1/SEG8, Description. = . RB1, Pin Number.TQFP = . RB1, Pin Type. = I/O. RB1, Buffer Type. = TTL. RB1, Description. = Digital I/O.. INT1,",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin Number.TQFP = . INT1, Pin Type. = I. INT1, Buffer Type. = ST. INT1, Description. = External interrupt 1.. SEG8, Pin Number.TQFP = . SEG8, Pin Type. = O. SEG8, Buffer Type. = Analog. SEG8, Description. = SEG8 output for LCD.. RB2/INT2/SEG9, Pin Number.TQFP = 46. RB2/INT2/SEG9, Pin Type. = . RB2/INT2/SEG9, Buffer Type. = . RB2/INT2/SEG9, Description. = . RB2, Pin Number.TQFP = . RB2, Pin Type. = I/O. RB2, Buffer Type. = TTL. RB2, Description. = Digital I/O.. INT2, Pin Number.TQFP = . INT2, Pin Type. = I. INT2, Buffer Type. = ST. INT2, Description. = External interrupt 2.. SEG9, Pin Number.TQFP =",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. SEG9, Pin Type. = O. SEG9, Buffer Type. = Analog. SEG9, Description. = SEG9 output for LCD.. RB3/INT3/SEG10, Pin Number.TQFP = 45. RB3/INT3/SEG10, Pin Type. = . RB3/INT3/SEG10, Buffer Type. = . RB3/INT3/SEG10, Description. = . RB3, Pin Number.TQFP = . RB3, Pin Type. = I/O. RB3, Buffer Type. = TTL. RB3, Description. = Digital I/O.. INT3, Pin Number.TQFP = . INT3, Pin Type. = I. INT3, Buffer Type. = ST. INT3, Description. = External interrupt 3.. SEG10, Pin Number.TQFP = . SEG10, Pin Type. = O. SEG10, Buffer Type. = Analog. SEG10, Description. = SEG10 output for LCD..",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB4/KBI0/SEG11, Pin Number.TQFP = 44. RB4/KBI0/SEG11, Pin Type. = . RB4/KBI0/SEG11, Buffer Type. = . RB4/KBI0/SEG11, Description. = . RB4, Pin Number.TQFP = . RB4, Pin Type. = I/O. RB4, Buffer Type. = TTL. RB4, Description. = Digital I/O.. KBI0, Pin Number.TQFP = . KBI0, Pin Type. = I. KBI0, Buffer Type. = TTL. KBI0, Description. = Interrupt-on-change pin.. SEG11, Pin Number.TQFP = . SEG11, Pin Type. = O. SEG11, Buffer Type. = Analog. SEG11, Description. = SEG11 output for LCD.. RB5/KBI1, Pin Number.TQFP = 43. RB5/KBI1, Pin Type. = . RB5/KBI1,",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer Type. = . RB5/KBI1, Description. = . RB5, Pin Number.TQFP = . RB5, Pin Type. = I/O. RB5, Buffer Type. = TTL. RB5, Description. = Digital I/O.. KBI1, Pin Number.TQFP = . KBI1, Pin Type. = I. KBI1, Buffer Type. = TTL. KBI1, Description. = Interrupt-on-change pin.. RB6/KBI2/PGC, Pin Number.TQFP = 42. RB6/KBI2/PGC, Pin Type. = . RB6/KBI2/PGC, Buffer Type. = . RB6/KBI2/PGC, Description. = . RB6, Pin Number.TQFP = . RB6, Pin Type. = I/O. RB6, Buffer Type. = TTL. RB6, Description. = Digital I/O.. KBI2, Pin Number.TQFP = . KBI2, Pin Type. = I. KBI2,",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer Type. = TTL. KBI2, Description. = Interrupt-on-change pin.. PGC, Pin Number.TQFP = . PGC, Pin Type. = I/O. PGC, Buffer Type. = ST. PGC, Description. = In-Circuit Debugger and ICSPGLYPH<153> programming clock pin.. RB7/KBI3/PGD, Pin Number.TQFP = 37. RB7/KBI3/PGD, Pin Type. = . RB7/KBI3/PGD, Buffer Type. = . RB7/KBI3/PGD, Description. = . RB7, Pin Number.TQFP = . RB7, Pin Type. = I/O. RB7, Buffer Type. = TTL. RB7, Description. = Digital I/O.. KBI3, Pin Number.TQFP = . KBI3, Pin Type. = I. KBI3, Buffer Type. = TTL. KBI3, Description. = Interrupt-on-change pin.. PGD, Pin",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.TQFP = . PGD, Pin Type. = I/O. PGD, Buffer Type. = ST. PGD, Description. = In-Circuit Debugger and ICSP programming data pin.\nLegend:\nTTL\n=  TTL compatible input\nCMOS =  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1:\nDefault assignment for CCP2 when Configuration bit, CCP2MX, is set.\n- 2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC0/T1OSO/T13CKI, Pin Number.TQFP = 30. RC0/T1OSO/T13CKI, Pin Type. = . RC0/T1OSO/T13CKI, Buffer Type. = . RC0/T1OSO/T13CKI, Description. = . RC0, Pin Number.TQFP = . RC0, Pin Type. = I/O. RC0, Buffer Type. = ST. RC0, Description. = Digital I/O.. T1OSO, Pin Number.TQFP = . T1OSO, Pin Type. = O. T1OSO, Buffer Type. = GLYPH<151>. T1OSO, Description. = Timer1 oscillator output.. T13CKI, Pin Number.TQFP = . T13CKI, Pin Type. = I. T13CKI, Buffer Type. = ST. T13CKI, Description. = Timer1/Timer3 external clock input.. RC1/T1OSI/CCP2, Pin Number.TQFP = 29.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC1/T1OSI/CCP2, Pin Type. = . RC1/T1OSI/CCP2, Buffer Type. = . RC1/T1OSI/CCP2, Description. = . RC1, Pin Number.TQFP = . RC1, Pin Type. = I/O. RC1, Buffer Type. = ST. RC1, Description. = Digital I/O.. T1OSI, Pin Number.TQFP = . T1OSI, Pin Type. = I. T1OSI, Buffer Type. = CMOS. T1OSI, Description. = Timer1 oscillator input.. CCP2 (1), Pin Number.TQFP = . CCP2 (1), Pin Type. = I/O. CCP2 (1), Buffer Type. = ST. CCP2 (1), Description. = Capture 2 input/Compare 2 output/PWM2 output.. RC2/CCP1/SEG13, Pin Number.TQFP = 33. RC2/CCP1/SEG13, Pin",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nType. = . RC2/CCP1/SEG13, Buffer Type. = . RC2/CCP1/SEG13, Description. = . RC2, Pin Number.TQFP = . RC2, Pin Type. = I/O. RC2, Buffer Type. = ST. RC2, Description. = Digital I/O.. CCP1, Pin Number.TQFP = . CCP1, Pin Type. = I/O. CCP1, Buffer Type. = ST. CCP1, Description. = Capture 1 input/Compare 1 output/PWM1 output.. SEG13, Pin Number.TQFP = . SEG13, Pin Type. = O. SEG13, Buffer Type. = Analog. SEG13, Description. = SEG13 output for LCD.. RC3/SCK/SCL, Pin Number.TQFP = 34. RC3/SCK/SCL, Pin Type. = . RC3/SCK/SCL, Buffer Type. = . RC3/SCK/SCL, Description. = .",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC3, Pin Number.TQFP = . RC3, Pin Type. = I/O. RC3, Buffer Type. = ST. RC3, Description. = Digital I/O.. SCK, Pin Number.TQFP = . SCK, Pin Type. = I/O. SCK, Buffer Type. = ST. SCK, Description. = Synchronous serial clock input/output for SPI mode.. SCL, Pin Number.TQFP = . SCL, Pin Type. = I/O. SCL, Buffer Type. = ST. SCL, Description. = Synchronous serial clock input/output for I 2 CGLYPH<153> mode.. RC4/SDI/SDA, Pin Number.TQFP = 35. RC4/SDI/SDA, Pin Type. = . RC4/SDI/SDA, Buffer Type. = . RC4/SDI/SDA, Description. = . RC4, Pin Number.TQFP = . RC4, Pin Type. = I/O. RC4, Buffer Type. =",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nST. RC4, Description. = Digital I/O.. SDI, Pin Number.TQFP = . SDI, Pin Type. = I. SDI, Buffer Type. = ST. SDI, Description. = SPI data in.. SDA, Pin Number.TQFP = . SDA, Pin Type. = I/O. SDA, Buffer Type. = ST. SDA, Description. = I 2 C data I/O.. RC5/SDO/SEG12, Pin Number.TQFP = 36. RC5/SDO/SEG12, Pin Type. = . RC5/SDO/SEG12, Buffer Type. = . RC5/SDO/SEG12, Description. = . RC5, Pin Number.TQFP = . RC5, Pin Type. = I/O. RC5, Buffer Type. = ST. RC5, Description. = Digital I/O.. SDO, Pin Number.TQFP = . SDO, Pin Type. = O. SDO, Buffer Type. = GLYPH<151>.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nSDO, Description. = SPI data out.. SEG12, Pin Number.TQFP = . SEG12, Pin Type. = O. SEG12, Buffer Type. = Analog. SEG12, Description. = SEG12 output for LCD.. RC6/TX1/CK1, Pin Number.TQFP = 31. RC6/TX1/CK1, Pin Type. = . RC6/TX1/CK1, Buffer Type. = . RC6/TX1/CK1, Description. = . RC6, Pin Number.TQFP = . RC6, Pin Type. = I/O. RC6, Buffer Type. = ST. RC6, Description. = Digital I/O.. TX1, Pin Number.TQFP = . TX1, Pin Type. = O. TX1, Buffer Type. = GLYPH<151>. TX1, Description. = EUSART1 asynchronous transmit.. CK1, Pin Number.TQFP = . CK1, Pin Type. = I/O. CK1, Buffer Type.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= ST. CK1, Description. = EUSART1 synchronous clock (see related RX1/DT1).. RC7/RX1/DT1, Pin Number.TQFP = 32. RC7/RX1/DT1, Pin Type. = . RC7/RX1/DT1, Buffer Type. = . RC7/RX1/DT1, Description. = . RC7, Pin Number.TQFP = . RC7, Pin Type. = I/O. RC7, Buffer Type. = ST. RC7, Description. = Digital I/O.. RX1, Pin Number.TQFP = . RX1, Pin Type. = I. RX1, Buffer Type. = ST. RX1, Description. = EUSART1 asynchronous receive.. DT1, Pin Number.TQFP = . DT1, Pin Type. = I/O. DT1, Buffer Type. = ST. DT1, Description. = EUSART1 synchronous data (see related",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nTX1/CK1).\nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI =  Input\nO =  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1: Default assignment for CCP2 when Configuration bit, CCP2MX, is set.\n2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD0/SEG0 RD0 SEG0 RD1/SEG1 RD1 SEG1 RD2/SEG2 RD2 SEG2 RD3/SEG3 RD3 SEG3 RD4/SEG4 RD4 SEG4, Pin Number.TQFP = 58. RD0/SEG0 RD0 SEG0 RD1/SEG1 RD1 SEG1 RD2/SEG2 RD2 SEG2 RD3/SEG3 RD3 SEG3 RD4/SEG4 RD4 SEG4, Pin Type. = I/O O I/O O. RD0/SEG0 RD0 SEG0 RD1/SEG1 RD1 SEG1 RD2/SEG2 RD2 SEG2 RD3/SEG3 RD3 SEG3 RD4/SEG4 RD4 SEG4, Buffer Type. = ST Analog ST ST Analog ST ST Analog. RD0/SEG0 RD0 SEG0 RD1/SEG1 RD1 SEG1 RD2/SEG2 RD2 SEG2",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD3/SEG3 RD3 SEG3 RD4/SEG4 RD4 SEG4, Description. = PORTD is a bidirectional I/O port. Digital I/O. SEG0 output for LCD.. , Pin Number.TQFP = 54. , Pin Type. = I/O O. , Buffer Type. = Analog. , Description. = SEG1 output for LCD. Digital I/O.. , Pin Number.TQFP = 53. , Pin Type. = I/O O. , Buffer Type. = Analog. , Description. = Digital I/O. SEG3 output for LCD.. , Pin Number.TQFP = 52. , Pin Type. = . , Buffer Type. = . , Description. = . RD5/SEG5 RD5, Pin Number.TQFP = . RD5/SEG5 RD5, Pin Type. = I/O O. RD5/SEG5 RD5, Buffer Type. = ST. RD5/SEG5 RD5, Description. = Digital I/O. SEG4 output for",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nLCD.. SEG5, Pin Number.TQFP = 51. SEG5, Pin Type. = I/O O I/O. SEG5, Buffer Type. = Analog. SEG5, Description. = Digital I/O.. RD6/SEG6 RD6 SEG6, Pin Number.TQFP = 50. RD6/SEG6 RD6 SEG6, Pin Type. = O I/O. RD6/SEG6 RD6 SEG6, Buffer Type. = ST. RD6/SEG6 RD6 SEG6, Description. = SEG5 output for LCD.. RD7/SEG7, Pin Number.TQFP = 49. RD7/SEG7, Pin Type. = . RD7/SEG7, Buffer Type. = Analog. RD7/SEG7, Description. = Digital I/O. SEG6 output for LCD.. RD7, Pin Number.TQFP = . RD7, Pin Type. = . RD7, Buffer Type. = ST. RD7, Description. = Digital",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O.. , Pin Number.TQFP = . , Pin Type. = O. , Buffer Type. = . , Description. = . , Pin Number.TQFP = . , Pin Type. = . , Buffer Type. = . , Description. = SEG7 output for LCD.. SEG7, Pin Number.TQFP = . SEG7, Pin Type. = . SEG7, Buffer Type. = Analog. SEG7, Description. = \nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP\n=  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1: Default assignment for CCP2 when Configuration bit, CCP2MX, is set.\n2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nLCDBIAS1 LCDBIAS1, Pin Number.TQFP = 2. LCDBIAS1 LCDBIAS1, Pin Type. = I. LCDBIAS1 LCDBIAS1, Buffer Type. = Analog. LCDBIAS1 LCDBIAS1, Description. = BIAS1 input for LCD.. LCDBIAS2 LCDBIAS2, Pin Number.TQFP = 1. LCDBIAS2 LCDBIAS2, Pin Type. = I. LCDBIAS2 LCDBIAS2, Buffer Type. = Analog. LCDBIAS2 LCDBIAS2, Description. = BIAS2 input for LCD.. LCDBIAS3 LCDBIAS3, Pin Number.TQFP = 64. LCDBIAS3 LCDBIAS3, Pin Type. = I. LCDBIAS3 LCDBIAS3, Buffer Type. = Analog. LCDBIAS3 LCDBIAS3, Description. = BIAS3 input for LCD.. COM0 COM0, Pin Number.TQFP = 63. COM0 COM0, Pin Type. = O. COM0 COM0, Buffer Type. = Analog. COM0",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nCOM0, Description. = COM0 output for LCD.. RE4/COM1 RE4, Pin Number.TQFP = 62. RE4/COM1 RE4, Pin Type. = I/O. RE4/COM1 RE4, Buffer Type. = ST Analog. RE4/COM1 RE4, Description. = Digital I/O. COM1 output for LCD.. RE5/COM2 RE5, Pin Number.TQFP = 61. RE5/COM2 RE5, Pin Type. = I/O. RE5/COM2 RE5, Buffer Type. = ST. RE5/COM2 RE5, Description. = Digital I/O. COM2 output for LCD.. RE6/COM3, Pin Number.TQFP = 60. RE6/COM3, Pin Type. = . RE6/COM3, Buffer Type. = ST. RE6/COM3, Description. = Digital I/O.. RE6 COM3, Pin Number.TQFP = . RE6 COM3, Pin Type. = I/O O. RE6 COM3, Buffer",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nType. = Analog. RE6 COM3, Description. = COM3 output for LCD.. RE7/CCP2/SEG31 RE7 CCP2 (2), Pin Number.TQFP = 59. RE7/CCP2/SEG31 RE7 CCP2 (2), Pin Type. = I/O I/O. RE7/CCP2/SEG31 RE7 CCP2 (2), Buffer Type. = ST ST. RE7/CCP2/SEG31 RE7 CCP2 (2), Description. = Digital I/O. Capture 2 input/Compare 2 output/PWM2 output.. SEG31, Pin Number.TQFP = . SEG31, Pin Type. = O. SEG31, Buffer Type. = Analog. SEG31, Description. = SEG31 output for LCD.\nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI =  Input\nO\n=  Output\nP =  Power\nOD",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\n=  Open-Drain (no P diode to VDD)\nNote 1: Default assignment for CCP2 when Configuration bit, CCP2MX, is set.\n- 2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRF0/AN5/SEG18, Pin Number.TQFP = 18. RF0/AN5/SEG18, Pin.Type = . RF0/AN5/SEG18, Buffer Type. = . RF0/AN5/SEG18, Description. = . RF0, Pin Number.TQFP = . RF0, Pin.Type = I/O. RF0, Buffer Type. = ST. RF0, Description. = Digital I/O.. AN5, Pin Number.TQFP = . AN5, Pin.Type = I. AN5, Buffer Type. = Analog. AN5, Description. = Analog input 5.. SEG18, Pin Number.TQFP = . SEG18, Pin.Type = O. SEG18, Buffer Type. = Analog. SEG18, Description. = SEG18 output for LCD.. RF1/AN6/C2OUT/SEG19, Pin Number.TQFP = 17. RF1/AN6/C2OUT/SEG19, Pin.Type = .",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRF1/AN6/C2OUT/SEG19, Buffer Type. = . RF1/AN6/C2OUT/SEG19, Description. = . RF1, Pin Number.TQFP = . RF1, Pin.Type = I/O. RF1, Buffer Type. = ST. RF1, Description. = Digital I/O.. AN6, Pin Number.TQFP = . AN6, Pin.Type = I. AN6, Buffer Type. = Analog. AN6, Description. = Analog input 6.. C2OUT, Pin Number.TQFP = . C2OUT, Pin.Type = O. C2OUT, Buffer Type. = GLYPH<151>. C2OUT, Description. = Comparator 2 output.. SEG19, Pin Number.TQFP = . SEG19, Pin.Type = O. SEG19, Buffer Type. = Analog. SEG19, Description. = SEG19 output for LCD.. RF2/AN7/C1OUT/SEG20, Pin Number.TQFP = 16.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRF2/AN7/C1OUT/SEG20, Pin.Type = . RF2/AN7/C1OUT/SEG20, Buffer Type. = . RF2/AN7/C1OUT/SEG20, Description. = . RF2, Pin Number.TQFP = . RF2, Pin.Type = I/O. RF2, Buffer Type. = ST. RF2, Description. = Digital I/O.. AN7, Pin Number.TQFP = . AN7, Pin.Type = I. AN7, Buffer Type. = Analog. AN7, Description. = Analog input 7.. C1OUT, Pin Number.TQFP = . C1OUT, Pin.Type = O. C1OUT, Buffer Type. = GLYPH<151>. C1OUT, Description. = Comparator 1 output.. SEG20, Pin Number.TQFP = . SEG20, Pin.Type = O. SEG20, Buffer Type. = Analog. SEG20, Description. = SEG20 output for LCD.. RF3/AN8/SEG21,",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin Number.TQFP = 15. RF3/AN8/SEG21, Pin.Type = . RF3/AN8/SEG21, Buffer Type. = . RF3/AN8/SEG21, Description. = . RF3, Pin Number.TQFP = . RF3, Pin.Type = I/O. RF3, Buffer Type. = ST. RF3, Description. = Digital I/O.. AN8, Pin Number.TQFP = . AN8, Pin.Type = I. AN8, Buffer Type. = Analog. AN8, Description. = Analog input 8.. SEG21, Pin Number.TQFP = . SEG21, Pin.Type = O. SEG21, Buffer Type. = Analog. SEG21, Description. = SEG21 output for LCD.. RF4/AN9/SEG22, Pin Number.TQFP = 14. RF4/AN9/SEG22, Pin.Type = . RF4/AN9/SEG22, Buffer Type. = .",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRF4/AN9/SEG22, Description. = . RF4, Pin Number.TQFP = . RF4, Pin.Type = I/O. RF4, Buffer Type. = ST. RF4, Description. = Digital I/O.. AN9, Pin Number.TQFP = . AN9, Pin.Type = I. AN9, Buffer Type. = Analog. AN9, Description. = Analog input 9.. SEG22, Pin Number.TQFP = . SEG22, Pin.Type = O. SEG22, Buffer Type. = Analog. SEG22, Description. = SEG22 output for LCD.. RF5/AN10/CVREF/SEG23, Pin Number.TQFP = 13. RF5/AN10/CVREF/SEG23, Pin.Type = . RF5/AN10/CVREF/SEG23, Buffer Type. = . RF5/AN10/CVREF/SEG23, Description. = . RF5, Pin Number.TQFP = . RF5, Pin.Type =",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. RF5, Buffer Type. = ST. RF5, Description. = Digital I/O.. AN10, Pin Number.TQFP = . AN10, Pin.Type = I. AN10, Buffer Type. = Analog. AN10, Description. = Analog input 10.. CVREF, Pin Number.TQFP = . CVREF, Pin.Type = O. CVREF, Buffer Type. = Analog. CVREF, Description. = Comparator reference voltage output.. SEG23, Pin Number.TQFP = . SEG23, Pin.Type = O. SEG23, Buffer Type. = Analog. SEG23, Description. = SEG23 output for LCD.. RF6/AN11/SEG24, Pin Number.TQFP = 12. RF6/AN11/SEG24, Pin.Type = . RF6/AN11/SEG24, Buffer Type. = . RF6/AN11/SEG24, Description. = . RF6, Pin Number.TQFP = . RF6, Pin.Type =",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. RF6, Buffer Type. = ST. RF6, Description. = Digital I/O.. AN11, Pin Number.TQFP = . AN11, Pin.Type = I. AN11, Buffer Type. = Analog. AN11, Description. = Analog input 11.. SEG24, Pin Number.TQFP = . SEG24, Pin.Type = O. SEG24, Buffer Type. = Analog. SEG24, Description. = SEG24 output for LCD.. RF7/SS/SEG25, Pin Number.TQFP = 11. RF7/SS/SEG25, Pin.Type = . RF7/SS/SEG25, Buffer Type. = . RF7/SS/SEG25, Description. = . RF7, Pin Number.TQFP = . RF7, Pin.Type = I/O. RF7, Buffer Type. = ST. RF7, Description. = Digital I/O.. SS, Pin Number.TQFP = . SS, Pin.Type = I. SS, Buffer Type. = TTL.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nSS, Description. = SPI slave select input.. SEG25, Pin Number.TQFP = . SEG25, Pin.Type = O. SEG25, Buffer Type. = Analog. SEG25, Description. = SEG25 output for LCD.\nLegend:\nTTL =  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI =  Input\nO\n=  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1: Default assignment for CCP2 when Configuration bit, CCP2MX, is set.\n- 2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRG0/SEG30 RG0 SEG30 RG1/TX2/CK2/SEG29 RG1 TX2 CK2 SEG29 RG2/RX2/DT2/SEG28 RG2 RX2 DT2 SEG28 RG3/SEG27 RG3 SEG27 RG4/SEG26 RG4 SEG26, Pin Number.TQFP = 3 4 5 6. RG0/SEG30 RG0 SEG30 RG1/TX2/CK2/SEG29 RG1 TX2 CK2 SEG29 RG2/RX2/DT2/SEG28 RG2 RX2 DT2 SEG28 RG3/SEG27 RG3 SEG27 RG4/SEG26 RG4 SEG26, Pin Type. = I/O O I/O O I/O O I/O I I/O O I/O O I/O O. RG0/SEG30 RG0 SEG30",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRG1/TX2/CK2/SEG29 RG1 TX2 CK2 SEG29 RG2/RX2/DT2/SEG28 RG2 RX2 DT2 SEG28 RG3/SEG27 RG3 SEG27 RG4/SEG26 RG4 SEG26, Buffer Type. = ST Analog ST GLYPH<151> ST Analog ST ST ST Analog ST Analog ST. RG0/SEG30 RG0 SEG30 RG1/TX2/CK2/SEG29 RG1 TX2 CK2 SEG29 RG2/RX2/DT2/SEG28 RG2 RX2 DT2 SEG28 RG3/SEG27 RG3 SEG27 RG4/SEG26 RG4 SEG26, Description. = PORTG is a bidirectional I/O port. Digital I/O. SEG30 output for LCD. Digital I/O. AUSART2 asynchronous transmit. AUSART2 synchronous",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nclock (see related RX2/DT2). SEG29 output for LCD. Digital I/O. AUSART2 asynchronous receive.. , Pin Number.TQFP = 9, 25, 41, 56. , Pin Type. = P. , Buffer Type. = GLYPH<151>. , Description. = Ground reference for logic and I/O pins.. VSS, Pin Number.TQFP = . VSS, Pin Type. = . VSS, Buffer Type. = . VSS, Description. = . VDD, Pin Number.TQFP = 10, 26, 38, 57. VDD, Pin Type. = P. VDD, Buffer Type. = . VDD, Description. = . , Pin Number.TQFP = . , Pin Type. = . , Buffer Type. = GLYPH<151>. , Description. = Positive supply for logic and I/O pins.. AVSS AVDD, Pin Number.TQFP = 20 19. AVSS AVDD, Pin Type. = P P. AVSS AVDD, Buffer Type. =",
    "TABLE 1-2: PIC18F6X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nGLYPH<151>. AVSS AVDD, Description. = Ground reference for analog modules.. , Pin Number.TQFP = . , Pin Type. = . , Buffer Type. = GLYPH<151>. , Description. = Positive supply for analog modules.\nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog =  Analog input\nI\n=  Input\nO\n=  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1:\nDefault assignment for CCP2 when Configuration bit, CCP2MX, is set.\n2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS\nMCLR/VPP/RG5, Pin Number.TQFP = 9. MCLR/VPP/RG5, Pin Type. = . MCLR/VPP/RG5, Buffer Type. = . MCLR/VPP/RG5, Description. = Master Clear (input) or programming voltage (input).. MCLR, Pin Number.TQFP = . MCLR, Pin Type. = I. MCLR, Buffer Type. = ST. MCLR, Description. = Master Clear (Reset) input. This pin is an active-low Reset to the device.. VPP, Pin Number.TQFP = . VPP, Pin Type. = P. VPP, Buffer Type. = . VPP, Description. = Programming voltage input.. RG5, Pin Number.TQFP = . RG5, Pin Type. = I. RG5, Buffer Type. = ST. RG5, Description. = Digital input.. OSC1/CLKI/RA7, Pin Number.TQFP = 49. OSC1/CLKI/RA7, Pin Type.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS\n= . OSC1/CLKI/RA7, Buffer Type. = . OSC1/CLKI/RA7, Description. = Oscillator crystal or external clock input.. OSC1, Pin Number.TQFP = . OSC1, Pin Type. = I. OSC1, Buffer Type. = ST. OSC1, Description. = Oscillator crystal input or external clock source input. ST buffer when configured in RC mode, CMOS otherwise.. CLKI, Pin Number.TQFP = . CLKI, Pin Type. = I. CLKI, Buffer Type. = CMOS. CLKI, Description. = External clock source input. Always associated with pin function OSC1. (See related OSC1/CLKI, OSC2/CLKO pins.). RA7, Pin Number.TQFP = . RA7, Pin Type. = I/O. RA7, Buffer Type. = TTL. RA7, Description. = General purpose I/O pin.. OSC2/CLKO/RA6, Pin Number.TQFP = 50.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS\nOSC2/CLKO/RA6, Pin Type. = . OSC2/CLKO/RA6, Buffer Type. = . OSC2/CLKO/RA6, Description. = Oscillator crystal or clock output.. OSC2, Pin Number.TQFP = . OSC2, Pin Type. = O. OSC2, Buffer Type. = GLYPH<151>. OSC2, Description. = Oscillator crystal output. Connects to crystal or resonator in Crystal Oscillator mode.. CLKO, Pin Number.TQFP = . CLKO, Pin Type. = O. CLKO, Buffer Type. = GLYPH<151>. CLKO, Description. = In RC mode, OSC2 pin outputs CLKO, which has 1/4 the frequency of OSC1 and denotes the instruction cycle rate.. RA6, Pin Number.TQFP = . RA6, Pin Type. = I/O. RA6, Buffer Type. = TTL. RA6, Description. = General purpose I/O pin.\nLegend:",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS\nTTL =  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI =  Input\nO =  Output\nP\n=  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote\n1: Default assignment for CCP2 when Configuration bit, CCP2MX, is set.\n2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRA0/AN0, Pin Number.TQFP = 30. RA0/AN0, Pin Type. = . RA0/AN0, Buffer Type. = . RA0/AN0, Description. = . RA0, Pin Number.TQFP = . RA0, Pin Type. = I/O. RA0, Buffer Type. = TTL. RA0, Description. = Digital I/O.. AN0, Pin Number.TQFP = . AN0, Pin Type. = I. AN0, Buffer Type. = Analog. AN0, Description. = Analog input 0.. RA1/AN1, Pin Number.TQFP = 29. RA1/AN1, Pin Type. = . RA1/AN1, Buffer Type. = . RA1/AN1, Description. = . RA1, Pin Number.TQFP = . RA1, Pin Type. = I/O. RA1, Buffer Type. = TTL. RA1, Description. = Digital I/O.. AN1, Pin Number.TQFP = . AN1, Pin Type. = I.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nAN1, Buffer Type. = Analog. AN1, Description. = Analog input 1.. RA2/AN2/VREF-/SEG16, Pin Number.TQFP = 28. RA2/AN2/VREF-/SEG16, Pin Type. = . RA2/AN2/VREF-/SEG16, Buffer Type. = . RA2/AN2/VREF-/SEG16, Description. = . RA2, Pin Number.TQFP = . RA2, Pin Type. = I/O. RA2, Buffer Type. = TTL. RA2, Description. = Digital I/O.. AN2, Pin Number.TQFP = . AN2, Pin Type. = I. AN2, Buffer Type. = Analog. AN2, Description. = Analog input 2.. VREF-, Pin Number.TQFP = . VREF-, Pin Type. = I. VREF-, Buffer Type. = Analog. VREF-, Description. = A/D reference voltage (Low) input.. SEG16, Pin",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.TQFP = . SEG16, Pin Type. = O. SEG16, Buffer Type. = Analog. SEG16, Description. = SEG16 output for LCD.. RA3/AN3/VREF+/SEG17, Pin Number.TQFP = 27. RA3/AN3/VREF+/SEG17, Pin Type. = . RA3/AN3/VREF+/SEG17, Buffer Type. = . RA3/AN3/VREF+/SEG17, Description. = . RA3, Pin Number.TQFP = . RA3, Pin Type. = I/O. RA3, Buffer Type. = TTL. RA3, Description. = Digital I/O.. AN3, Pin Number.TQFP = . AN3, Pin Type. = I. AN3, Buffer Type. = Analog. AN3, Description. = Analog input 3.. VREF+, Pin Number.TQFP = . VREF+, Pin Type. = I. VREF+, Buffer Type. = Analog. VREF+,",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nDescription. = A/D reference voltage (High) input.. SEG17, Pin Number.TQFP = . SEG17, Pin Type. = O. SEG17, Buffer Type. = Analog. SEG17, Description. = SEG17 output for LCD.. RA4/T0CKI/SEG14, Pin Number.TQFP = 34. RA4/T0CKI/SEG14, Pin Type. = . RA4/T0CKI/SEG14, Buffer Type. = . RA4/T0CKI/SEG14, Description. = . RA4, Pin Number.TQFP = . RA4, Pin Type. = I/O. RA4, Buffer Type. = ST/OD. RA4, Description. = Digital I/O. Open-drain when configured as output.. T0CKI, Pin Number.TQFP = . T0CKI, Pin Type. = I. T0CKI, Buffer Type. = ST. T0CKI, Description. = Timer0 external clock input.. SEG14, Pin Number.TQFP = .",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nSEG14, Pin Type. = O. SEG14, Buffer Type. = Analog. SEG14, Description. = SEG14 output for LCD.. RA5/AN4/HLVDIN/SEG15, Pin Number.TQFP = 33. RA5/AN4/HLVDIN/SEG15, Pin Type. = . RA5/AN4/HLVDIN/SEG15, Buffer Type. = . RA5/AN4/HLVDIN/SEG15, Description. = . RA5, Pin Number.TQFP = . RA5, Pin Type. = I/O. RA5, Buffer Type. = TTL. RA5, Description. = Digital I/O.. AN4, Pin Number.TQFP = . AN4, Pin Type. = I. AN4, Buffer Type. = Analog. AN4, Description. = Analog input 4.. HLVDIN, Pin Number.TQFP = . HLVDIN, Pin Type. = I. HLVDIN, Buffer Type. = Analog.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nHLVDIN, Description. = Low-Voltage Detect input.. SEG15, Pin Number.TQFP = . SEG15, Pin Type. = O. SEG15, Buffer Type. = Analog. SEG15, Description. = SEG15 output for LCD.. RA6, Pin Number.TQFP = . RA6, Pin Type. = . RA6, Buffer Type. = . RA6, Description. = See the OSC2/CLKO/RA6 pin.. RA7, Pin Number.TQFP = . RA7, Pin Type. = . RA7, Buffer Type. = . RA7, Description. = See the OSC1/CLKI/RA7 pin.\nLegend:\nTTL =  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI =  Input\nO\n=  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1:\nDefault assignment for CCP2 when Configuration bit, CCP2MX, is set.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\n2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB0/INT0, Pin Number.TQFP = 58. RB0/INT0, Pin.Type = . RB0/INT0, Buffer Type. = . RB0/INT0, Description. = . RB0, Pin Number.TQFP = . RB0, Pin.Type = I/O. RB0, Buffer Type. = TTL. RB0, Description. = Digital I/O.. INT0, Pin Number.TQFP = . INT0, Pin.Type = I. INT0, Buffer Type. = ST. INT0, Description. = External interrupt 0.. RB1/INT1/SEG8, Pin Number.TQFP = 57. RB1/INT1/SEG8, Pin.Type = . RB1/INT1/SEG8, Buffer Type. = . RB1/INT1/SEG8, Description. = . RB1, Pin Number.TQFP = . RB1, Pin.Type = I/O. RB1, Buffer Type. = TTL. RB1, Description. = Digital I/O.. INT1,",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin Number.TQFP = . INT1, Pin.Type = I. INT1, Buffer Type. = ST. INT1, Description. = External interrupt 1.. SEG8, Pin Number.TQFP = . SEG8, Pin.Type = O. SEG8, Buffer Type. = Analog. SEG8, Description. = SEG8 output for LCD.. RB2/INT2/SEG9, Pin Number.TQFP = 56. RB2/INT2/SEG9, Pin.Type = . RB2/INT2/SEG9, Buffer Type. = . RB2/INT2/SEG9, Description. = . RB2, Pin Number.TQFP = . RB2, Pin.Type = I/O. RB2, Buffer Type. = TTL. RB2, Description. = Digital I/O.. INT2, Pin Number.TQFP = . INT2, Pin.Type = I. INT2, Buffer Type. = ST. INT2, Description. = External interrupt 2.. SEG9, Pin Number.TQFP =",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. SEG9, Pin.Type = O. SEG9, Buffer Type. = Analog. SEG9, Description. = SEG9 output for LCD.. RB3/INT3/SEG10, Pin Number.TQFP = 55. RB3/INT3/SEG10, Pin.Type = . RB3/INT3/SEG10, Buffer Type. = . RB3/INT3/SEG10, Description. = . RB3, Pin Number.TQFP = . RB3, Pin.Type = I/O. RB3, Buffer Type. = TTL. RB3, Description. = Digital I/O.. INT3, Pin Number.TQFP = . INT3, Pin.Type = I. INT3, Buffer Type. = ST. INT3, Description. = External interrupt 3.. SEG10, Pin Number.TQFP = . SEG10, Pin.Type = O. SEG10, Buffer Type. = Analog. SEG10, Description. = SEG10 output for LCD..",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB4/KBI0/SEG11, Pin Number.TQFP = 54. RB4/KBI0/SEG11, Pin.Type = . RB4/KBI0/SEG11, Buffer Type. = . RB4/KBI0/SEG11, Description. = . RB4, Pin Number.TQFP = . RB4, Pin.Type = I/O. RB4, Buffer Type. = TTL. RB4, Description. = Digital I/O.. KBI0, Pin Number.TQFP = . KBI0, Pin.Type = I. KBI0, Buffer Type. = TTL. KBI0, Description. = Interrupt-on-change pin.. SEG11, Pin Number.TQFP = . SEG11, Pin.Type = O. SEG11, Buffer Type. = Analog. SEG11, Description. = SEG11 output for LCD.. RB5/KBI1, Pin Number.TQFP = 53. RB5/KBI1, Pin.Type = . RB5/KBI1,",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer Type. = . RB5/KBI1, Description. = . RB5, Pin Number.TQFP = . RB5, Pin.Type = I/O. RB5, Buffer Type. = TTL. RB5, Description. = Digital I/O.. KBI1, Pin Number.TQFP = . KBI1, Pin.Type = I. KBI1, Buffer Type. = TTL. KBI1, Description. = Interrupt-on-change pin.. RB6/KBI2/PGC, Pin Number.TQFP = 52. RB6/KBI2/PGC, Pin.Type = . RB6/KBI2/PGC, Buffer Type. = . RB6/KBI2/PGC, Description. = . RB6, Pin Number.TQFP = . RB6, Pin.Type = I/O. RB6, Buffer Type. = TTL. RB6, Description. = Digital I/O.. KBI2, Pin Number.TQFP = . KBI2, Pin.Type = I. KBI2,",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer Type. = TTL. KBI2, Description. = Interrupt-on-change pin.. PGC, Pin Number.TQFP = . PGC, Pin.Type = I/O. PGC, Buffer Type. = ST. PGC, Description. = In-Circuit Debugger and ICSPGLYPH<153> programming clock pin.. RB7/KBI3/PGD, Pin Number.TQFP = 47. RB7/KBI3/PGD, Pin.Type = . RB7/KBI3/PGD, Buffer Type. = . RB7/KBI3/PGD, Description. = . RB7, Pin Number.TQFP = . RB7, Pin.Type = I/O. RB7, Buffer Type. = TTL. RB7, Description. = Digital I/O.. KBI3, Pin Number.TQFP = . KBI3, Pin.Type = I. KBI3, Buffer Type. = TTL. KBI3, Description. = Interrupt-on-change pin.. PGD, Pin",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.TQFP = . PGD, Pin.Type = I/O. PGD, Buffer Type. = ST. PGD, Description. = In-Circuit Debugger and ICSP programming data pin.\nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1:\nDefault assignment for CCP2 when Configuration bit, CCP2MX, is set.\n- 2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC0/T1OSO/T13CKI, Pin Number.TQFP = 36. RC0/T1OSO/T13CKI, Pin Type. = . RC0/T1OSO/T13CKI, Buffer Type. = . RC0/T1OSO/T13CKI, Description. = . RC0, Pin Number.TQFP = . RC0, Pin Type. = I/O. RC0, Buffer Type. = ST. RC0, Description. = Digital I/O.. T1OSO, Pin Number.TQFP = . T1OSO, Pin Type. = O. T1OSO, Buffer Type. = GLYPH<151>. T1OSO, Description. = Timer1 oscillator output.. T13CKI, Pin Number.TQFP = . T13CKI, Pin Type. = I. T13CKI, Buffer Type. = ST. T13CKI, Description. = Timer1/Timer3 external clock input.. RC1/T1OSI/CCP2, Pin Number.TQFP = 35.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC1/T1OSI/CCP2, Pin Type. = . RC1/T1OSI/CCP2, Buffer Type. = . RC1/T1OSI/CCP2, Description. = . RC1, Pin Number.TQFP = . RC1, Pin Type. = I/O. RC1, Buffer Type. = ST. RC1, Description. = Digital I/O.. T1OSI, Pin Number.TQFP = . T1OSI, Pin Type. = I. T1OSI, Buffer Type. = CMOS. T1OSI, Description. = Timer1 oscillator input.. CCP2 (1), Pin Number.TQFP = . CCP2 (1), Pin Type. = I/O. CCP2 (1), Buffer Type. = ST. CCP2 (1), Description. = Capture 2 input/Compare 2 output/PWM2 output.. RC2/CCP1/SEG13, Pin Number.TQFP = 43. RC2/CCP1/SEG13, Pin",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nType. = . RC2/CCP1/SEG13, Buffer Type. = . RC2/CCP1/SEG13, Description. = . RC2, Pin Number.TQFP = . RC2, Pin Type. = I/O. RC2, Buffer Type. = ST. RC2, Description. = Digital I/O.. CCP1, Pin Number.TQFP = . CCP1, Pin Type. = I/O. CCP1, Buffer Type. = ST. CCP1, Description. = Capture 1 input/Compare 1 output/PWM1 output.. SEG13, Pin Number.TQFP = . SEG13, Pin Type. = O. SEG13, Buffer Type. = Analog. SEG13, Description. = SEG13 output for LCD.. RC3/SCK/SCL, Pin Number.TQFP = 44. RC3/SCK/SCL, Pin Type. = . RC3/SCK/SCL, Buffer Type. = . RC3/SCK/SCL, Description. = .",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC3, Pin Number.TQFP = . RC3, Pin Type. = I/O. RC3, Buffer Type. = ST. RC3, Description. = Digital I/O.. SCK, Pin Number.TQFP = . SCK, Pin Type. = I/O. SCK, Buffer Type. = ST. SCK, Description. = Synchronous serial clock input/output for SPI mode.. SCL, Pin Number.TQFP = . SCL, Pin Type. = I/O. SCL, Buffer Type. = ST. SCL, Description. = Synchronous serial clock input/output for I 2 CGLYPH<153> mode.. RC4/SDI/SDA, Pin Number.TQFP = 45. RC4/SDI/SDA, Pin Type. = . RC4/SDI/SDA, Buffer Type. = . RC4/SDI/SDA, Description. = . RC4, Pin Number.TQFP = . RC4, Pin Type. = I/O. RC4, Buffer Type. =",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nST. RC4, Description. = Digital I/O.. SDI, Pin Number.TQFP = . SDI, Pin Type. = I. SDI, Buffer Type. = ST. SDI, Description. = SPI data in.. SDA, Pin Number.TQFP = . SDA, Pin Type. = I/O. SDA, Buffer Type. = ST. SDA, Description. = I 2 C data I/O.. RC5/SDO/SEG12, Pin Number.TQFP = 46. RC5/SDO/SEG12, Pin Type. = . RC5/SDO/SEG12, Buffer Type. = . RC5/SDO/SEG12, Description. = . RC5, Pin Number.TQFP = . RC5, Pin Type. = I/O. RC5, Buffer Type. = ST. RC5, Description. = Digital I/O.. SDO, Pin Number.TQFP = . SDO, Pin Type. = O. SDO, Buffer Type. = GLYPH<151>.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nSDO, Description. = SPI data out.. SEG12, Pin Number.TQFP = . SEG12, Pin Type. = O. SEG12, Buffer Type. = Analog. SEG12, Description. = SEG12 output for LCD.. RC6/TX1/CK1, Pin Number.TQFP = 37. RC6/TX1/CK1, Pin Type. = . RC6/TX1/CK1, Buffer Type. = . RC6/TX1/CK1, Description. = . RC6, Pin Number.TQFP = . RC6, Pin Type. = I/O. RC6, Buffer Type. = ST. RC6, Description. = Digital I/O.. TX1, Pin Number.TQFP = . TX1, Pin Type. = O. TX1, Buffer Type. = GLYPH<151>. TX1, Description. = EUSART1 asynchronous transmit.. CK1, Pin Number.TQFP = . CK1, Pin Type. = I/O. CK1, Buffer Type.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= ST. CK1, Description. = EUSART1 synchronous clock (see related RX1/DT1).. RC7/RX1/DT1, Pin Number.TQFP = 38. RC7/RX1/DT1, Pin Type. = . RC7/RX1/DT1, Buffer Type. = . RC7/RX1/DT1, Description. = . RC7, Pin Number.TQFP = . RC7, Pin Type. = I/O. RC7, Buffer Type. = ST. RC7, Description. = Digital I/O.. RX1, Pin Number.TQFP = . RX1, Pin Type. = I. RX1, Buffer Type. = ST. RX1, Description. = EUSART1 asynchronous receive.. DT1, Pin Number.TQFP = . DT1, Pin Type. = I/O. DT1, Buffer Type. = ST. DT1, Description. = EUSART1 synchronous data (see related",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nTX1/CK1).\nLegend:\nTTL =  TTL compatible input\nCMOS =  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI =  Input\nO =  Output\nP\n=  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1:\nDefault assignment for CCP2 when Configuration bit, CCP2MX, is set.\n2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD0/SEG0 RD0 SEG0, Pin Number.TQFP = 72. RD0/SEG0 RD0 SEG0, Pin Type. = I/O. RD0/SEG0 RD0 SEG0, Buffer Type. = ST Analog ST. RD0/SEG0 RD0 SEG0, Description. = Digital I/O. SEG0 output for LCD.. RD1/SEG1 RD1 SEG1 RD2/SEG2 RD2, Pin Number.TQFP = 69 68. RD1/SEG1 RD1 SEG1 RD2/SEG2 RD2, Pin Type. = I/O O I/O O. RD1/SEG1 RD1 SEG1 RD2/SEG2 RD2, Buffer Type. = Analog ST. RD1/SEG1 RD1 SEG1 RD2/SEG2 RD2, Description. = Digital I/O. SEG1 output for LCD. Digital I/O.. RD3/SEG3 RD3 SEG3, Pin Number.TQFP =",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\n67. RD3/SEG3 RD3 SEG3, Pin Type. = O. RD3/SEG3 RD3 SEG3, Buffer Type. = ST. RD3/SEG3 RD3 SEG3, Description. = Digital I/O. SEG3 output for LCD.. RD4/SEG4 RD4, Pin Number.TQFP = . RD4/SEG4 RD4, Pin Type. = I/O. RD4/SEG4 RD4, Buffer Type. = Analog. RD4/SEG4 RD4, Description. = . SEG4 RD5/SEG5, Pin Number.TQFP = 66. SEG4 RD5/SEG5, Pin Type. = I/O O. SEG4 RD5/SEG5, Buffer Type. = ST Analog. SEG4 RD5/SEG5, Description. = Digital I/O.. RD5, Pin Number.TQFP = 65. RD5, Pin Type. = I/O O. RD5, Buffer Type. = ST Analog. RD5,",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nDescription. = SEG4 output for LCD.. SEG5 RD6/SEG6 RD6, Pin Number.TQFP = . SEG5 RD6/SEG6 RD6, Pin Type. = I/O O. SEG5 RD6/SEG6 RD6, Buffer Type. = ST Analog. SEG5 RD6/SEG6 RD6, Description. = Digital I/O. SEG5 output for LCD.. SEG6, Pin Number.TQFP = 64. SEG6, Pin Type. = I/O. SEG6, Buffer Type. = . SEG6, Description. = Digital I/O. SEG6 output for LCD.. RD7/SEG7, Pin Number.TQFP = 63. RD7/SEG7, Pin Type. = . RD7/SEG7, Buffer Type. = ST. RD7/SEG7, Description. = . RD7, Pin Number.TQFP = . RD7, Pin Type. = . RD7, Buffer Type. = . RD7, Description. = Digital",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O.. , Pin Number.TQFP = . , Pin Type. = O. , Buffer Type. = . , Description. = . , Pin Number.TQFP = . , Pin Type. = . , Buffer Type. = . , Description. = SEG7 output for LCD.. SEG7, Pin Number.TQFP = . SEG7, Pin Type. = . SEG7, Buffer Type. = Analog. SEG7, Description. = \nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP\n=  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1: Default assignment for CCP2 when Configuration bit, CCP2MX, is set.\n2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nLCDBIAS1 LCDBIAS1, Pin Number.TQFP = 4. LCDBIAS1 LCDBIAS1, Pin Type. = I. LCDBIAS1 LCDBIAS1, Buffer Type. = Analog. LCDBIAS1 LCDBIAS1, Description. = BIAS1 input for LCD.. LCDBIAS2 LCDBIAS2, Pin Number.TQFP = 3. LCDBIAS2 LCDBIAS2, Pin Type. = I. LCDBIAS2 LCDBIAS2, Buffer Type. = Analog. LCDBIAS2 LCDBIAS2, Description. = BIAS2 input for LCD.. LCDBIAS3 LCDBIAS3, Pin Number.TQFP = 78. LCDBIAS3 LCDBIAS3, Pin Type. = I. LCDBIAS3 LCDBIAS3, Buffer Type. = Analog. LCDBIAS3 LCDBIAS3, Description. = BIAS3 input for LCD.. COM0 COM0, Pin Number.TQFP = 77. COM0 COM0, Pin Type. = O. COM0 COM0, Buffer Type. = Analog. COM0",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nCOM0, Description. = COM0 output for LCD.. RE4/COM1 RE4, Pin Number.TQFP = 76. RE4/COM1 RE4, Pin Type. = I/O. RE4/COM1 RE4, Buffer Type. = ST Analog. RE4/COM1 RE4, Description. = Digital I/O. COM1 output for LCD.. RE5/COM2 RE5, Pin Number.TQFP = 75. RE5/COM2 RE5, Pin Type. = I/O. RE5/COM2 RE5, Buffer Type. = ST Analog. RE5/COM2 RE5, Description. = Digital I/O. COM2 output for LCD.. RE6/COM3 RE6, Pin Number.TQFP = 74. RE6/COM3 RE6, Pin Type. = I/O. RE6/COM3 RE6, Buffer Type. = ST. RE6/COM3 RE6, Description. = Digital I/O. COM3 output for LCD.. COM3, Pin Number.TQFP = . COM3, Pin",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nType. = O. COM3, Buffer Type. = Analog. COM3, Description. = . RE7/CCP2/SEG31 RE7 CCP2 (2), Pin Number.TQFP = 73. RE7/CCP2/SEG31 RE7 CCP2 (2), Pin Type. = I/O I/O. RE7/CCP2/SEG31 RE7 CCP2 (2), Buffer Type. = ST ST. RE7/CCP2/SEG31 RE7 CCP2 (2), Description. = Digital I/O. Capture 2 input/Compare 2 output/PWM2 output.. SEG31, Pin Number.TQFP = . SEG31, Pin Type. = O. SEG31, Buffer Type. = Analog. SEG31, Description. = SEG31 output for LCD.\nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP =  Power\nOD",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\n=  Open-Drain (no P diode to VDD)\nNote 1: Default assignment for CCP2 when Configuration bit, CCP2MX, is set.\n2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRF0/AN5/SEG18, Pin Number.TQFP = 24. RF0/AN5/SEG18, Pin.Type = . RF0/AN5/SEG18, Buffer Type. = . RF0/AN5/SEG18, Description. = . RF0, Pin Number.TQFP = . RF0, Pin.Type = I/O. RF0, Buffer Type. = ST. RF0, Description. = Digital I/O.. AN5, Pin Number.TQFP = . AN5, Pin.Type = I. AN5, Buffer Type. = Analog. AN5, Description. = Analog input 5.. SEG18, Pin Number.TQFP = . SEG18, Pin.Type = O. SEG18, Buffer Type. = Analog. SEG18, Description. = SEG18 output for LCD.. RF1/AN6/C2OUT/SEG19, Pin Number.TQFP = 23. RF1/AN6/C2OUT/SEG19, Pin.Type = .",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRF1/AN6/C2OUT/SEG19, Buffer Type. = . RF1/AN6/C2OUT/SEG19, Description. = . RF1, Pin Number.TQFP = . RF1, Pin.Type = I/O. RF1, Buffer Type. = ST. RF1, Description. = Digital I/O.. AN6, Pin Number.TQFP = . AN6, Pin.Type = I. AN6, Buffer Type. = Analog. AN6, Description. = Analog input 6.. C2OUT, Pin Number.TQFP = . C2OUT, Pin.Type = O. C2OUT, Buffer Type. = GLYPH<151>. C2OUT, Description. = Comparator 2 output.. SEG19, Pin Number.TQFP = . SEG19, Pin.Type = O. SEG19, Buffer Type. = Analog. SEG19, Description. = SEG19 output for LCD.. RF2/AN7/C1OUT/SEG20, Pin Number.TQFP = 18.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRF2/AN7/C1OUT/SEG20, Pin.Type = . RF2/AN7/C1OUT/SEG20, Buffer Type. = . RF2/AN7/C1OUT/SEG20, Description. = . RF2, Pin Number.TQFP = . RF2, Pin.Type = I/O. RF2, Buffer Type. = ST. RF2, Description. = Digital I/O.. AN7, Pin Number.TQFP = . AN7, Pin.Type = I. AN7, Buffer Type. = Analog. AN7, Description. = Analog input 7.. C1OUT, Pin Number.TQFP = . C1OUT, Pin.Type = O. C1OUT, Buffer Type. = GLYPH<151>. C1OUT, Description. = Comparator 1 output.. SEG20, Pin Number.TQFP = . SEG20, Pin.Type = O. SEG20, Buffer Type. = Analog. SEG20, Description. = SEG20 output for LCD.. RF3/AN8/SEG21,",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin Number.TQFP = 17. RF3/AN8/SEG21, Pin.Type = . RF3/AN8/SEG21, Buffer Type. = . RF3/AN8/SEG21, Description. = . RF3, Pin Number.TQFP = . RF3, Pin.Type = I/O. RF3, Buffer Type. = ST. RF3, Description. = Digital I/O.. AN8, Pin Number.TQFP = . AN8, Pin.Type = I. AN8, Buffer Type. = Analog. AN8, Description. = Analog input 8.. SEG21, Pin Number.TQFP = . SEG21, Pin.Type = O. SEG21, Buffer Type. = Analog. SEG21, Description. = SEG21 output for LCD.. RF4/AN9/SEG22, Pin Number.TQFP = 16. RF4/AN9/SEG22, Pin.Type = . RF4/AN9/SEG22, Buffer Type. = .",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRF4/AN9/SEG22, Description. = . RF4, Pin Number.TQFP = . RF4, Pin.Type = I/O. RF4, Buffer Type. = ST. RF4, Description. = Digital I/O.. AN9, Pin Number.TQFP = . AN9, Pin.Type = I. AN9, Buffer Type. = Analog. AN9, Description. = Analog input 9.. SEG22, Pin Number.TQFP = . SEG22, Pin.Type = O. SEG22, Buffer Type. = Analog. SEG22, Description. = SEG22 output for LCD.. RF5/AN10/CVREF/SEG23, Pin Number.TQFP = 15. RF5/AN10/CVREF/SEG23, Pin.Type = . RF5/AN10/CVREF/SEG23, Buffer Type. = . RF5/AN10/CVREF/SEG23, Description. = . RF5, Pin Number.TQFP = . RF5, Pin.Type =",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. RF5, Buffer Type. = ST. RF5, Description. = Digital I/O.. AN10, Pin Number.TQFP = . AN10, Pin.Type = I. AN10, Buffer Type. = Analog. AN10, Description. = Analog input 10.. CVREF, Pin Number.TQFP = . CVREF, Pin.Type = O. CVREF, Buffer Type. = Analog. CVREF, Description. = Comparator reference voltage output.. SEG23, Pin Number.TQFP = . SEG23, Pin.Type = O. SEG23, Buffer Type. = Analog. SEG23, Description. = SEG23 output for LCD.. RF6/AN11/SEG24, Pin Number.TQFP = 14. RF6/AN11/SEG24, Pin.Type = . RF6/AN11/SEG24, Buffer Type. = . RF6/AN11/SEG24, Description. = . RF6, Pin Number.TQFP = . RF6, Pin.Type =",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. RF6, Buffer Type. = ST. RF6, Description. = Digital I/O.. AN11, Pin Number.TQFP = . AN11, Pin.Type = I. AN11, Buffer Type. = Analog. AN11, Description. = Analog input 11.. SEG24, Pin Number.TQFP = . SEG24, Pin.Type = O. SEG24, Buffer Type. = Analog. SEG24, Description. = SEG24 output for LCD.. RF7/SS/SEG25, Pin Number.TQFP = 13. RF7/SS/SEG25, Pin.Type = . RF7/SS/SEG25, Buffer Type. = . RF7/SS/SEG25, Description. = . RF7, Pin Number.TQFP = . RF7, Pin.Type = I/O. RF7, Buffer Type. = ST. RF7, Description. = Digital I/O.. SS, Pin Number.TQFP = . SS, Pin.Type = I. SS, Buffer Type. = TTL.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nSS, Description. = SPI slave select input.. SEG25, Pin Number.TQFP = . SEG25, Pin.Type = O. SEG25, Buffer Type. = Analog. SEG25, Description. = SEG25 output for LCD.\nLegend:\nTTL =  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI =  Input\nO\n=  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1: Default assignment for CCP2 when Configuration bit, CCP2MX, is set.\n- 2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRG0/SEG30 RG0 SEG30 RG1 TX2 CK2 SEG29 RG2 RX2 DT2 SEG28 RG3/SEG27 RG3 SEG27, Pin Number.TQFP = 5 6 7. RG0/SEG30 RG0 SEG30 RG1 TX2 CK2 SEG29 RG2 RX2 DT2 SEG28 RG3/SEG27 RG3 SEG27, Pin Type. = I/O O I/O O I/O O I/O I O. RG0/SEG30 RG0 SEG30 RG1 TX2 CK2 SEG29 RG2 RX2 DT2 SEG28 RG3/SEG27 RG3 SEG27, Buffer Type. = ST Analog ST GLYPH<151> ST ST ST ST. RG0/SEG30 RG0 SEG30 RG1 TX2 CK2 SEG29 RG2 RX2 DT2 SEG28 RG3/SEG27",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRG3 SEG27, Description. = PORTG is a bidirectional I/O port. Digital I/O. SEG30 output for LCD. Digital I/O. AUSART2 asynchronous transmit. AUSART2 synchronous clock (see related SEG29 output for LCD. Digital I/O. AUSART2 asynchronous receive.. RG1/TX2/CK2/SEG29, Pin Number.TQFP = . RG1/TX2/CK2/SEG29, Pin Type. = . RG1/TX2/CK2/SEG29, Buffer Type. = Analog. RG1/TX2/CK2/SEG29, Description. = RX2/DT2).. RG2/RX2/DT2/SEG28, Pin Number.TQFP = . RG2/RX2/DT2/SEG28, Pin Type. = . RG2/RX2/DT2/SEG28, Buffer Type. = .",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRG2/RX2/DT2/SEG28, Description. = AUSART2 synchronous data (see related TX2/CK2). SEG28 output for LCD.. , Pin Number.TQFP = . , Pin Type. = I/O. , Buffer Type. = Analog. , Description. = . , Pin Number.TQFP = 8. , Pin Type. = I/O O. , Buffer Type. = ST. , Description. = . RG4, Pin Number.TQFP = 10. RG4, Pin Type. = I/O. RG4, Buffer Type. = Analog ST. RG4, Description. = Digital I/O. SEG27 output for LCD.. RG4/SEG26, Pin Number.TQFP = . RG4/SEG26, Pin Type. = . RG4/SEG26, Buffer Type. = . RG4/SEG26, Description. = Digital I/O.. SEG26, Pin Number.TQFP = . SEG26, Pin Type. =",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. SEG26, Buffer Type. = . SEG26, Description. = . , Pin Number.TQFP = . , Pin Type. = O. , Buffer Type. = . , Description. = SEG26 output for. , Pin Number.TQFP = . , Pin Type. = . , Buffer Type. = Analog. , Description. = . , Pin Number.TQFP = . , Pin Type. = . , Buffer Type. = . , Description. = LCD.\nLegend:\nTTL =  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog =  Analog input\nI =  Input\nO\n=  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1:\nDefault assignment for CCP2 when Configuration bit, CCP2MX, is set.\n2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRH0/SEG47 RH0, Pin Number.TQFP = 79. RH0/SEG47 RH0, Pin Type. = I/O. RH0/SEG47 RH0, Buffer Type. = ST Analog. RH0/SEG47 RH0, Description. = Digital I/O. SEG47 output for LCD.. RH1/SEG46 RH1 SEG46 RH2/SEG45 RH2, Pin Number.TQFP = 80 1. RH1/SEG46 RH1 SEG46 RH2/SEG45 RH2, Pin Type. = I/O O I/O O. RH1/SEG46 RH1 SEG46 RH2/SEG45 RH2, Buffer Type. = ST Analog ST. RH1/SEG46 RH1 SEG46 RH2/SEG45 RH2, Description. = Digital I/O. SEG46 output for LCD. Digital I/O..",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRH3/SEG44 RH3 SEG44, Pin Number.TQFP = 2. RH3/SEG44 RH3 SEG44, Pin Type. = I/O O. RH3/SEG44 RH3 SEG44, Buffer Type. = ST. RH3/SEG44 RH3 SEG44, Description. = Digital I/O. SEG44 output for LCD.. RH4/SEG40 RH4, Pin Number.TQFP = 22. RH4/SEG40 RH4, Pin Type. = . RH4/SEG40 RH4, Buffer Type. = Analog. RH4/SEG40 RH4, Description. = . SEG40 RH5/SEG41, Pin Number.TQFP = . SEG40 RH5/SEG41, Pin Type. = I/O O. SEG40 RH5/SEG41, Buffer Type. = ST Analog. SEG40 RH5/SEG41, Description. = Digital",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. SEG40 output for LCD.. RH5 SEG41, Pin Number.TQFP = 21. RH5 SEG41, Pin Type. = I/O O. RH5 SEG41, Buffer Type. = ST Analog. RH5 SEG41, Description. = . RH6/SEG42 RH6, Pin Number.TQFP = 20. RH6/SEG42 RH6, Pin Type. = I/O O. RH6/SEG42 RH6, Buffer Type. = ST. RH6/SEG42 RH6, Description. = Digital I/O. SEG41 output for LCD.. SEG42, Pin Number.TQFP = 19. SEG42, Pin Type. = I/O. SEG42, Buffer Type. = Analog. SEG42, Description. = Digital I/O. SEG42 output for LCD.. RH7/SEG43, Pin Number.TQFP = . RH7/SEG43, Pin Type. = .",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRH7/SEG43, Buffer Type. = ST. RH7/SEG43, Description. = . RH7, Pin Number.TQFP = . RH7, Pin Type. = . RH7, Buffer Type. = . RH7, Description. = Digital I/O.. , Pin Number.TQFP = . , Pin Type. = O. , Buffer Type. = . , Description. = . SEG43, Pin Number.TQFP = . SEG43, Pin Type. = . SEG43, Buffer Type. = Analog. SEG43, Description. = SEG43 output for LCD.\nLegend:\nTTL =  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP\n=  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1: Default assignment for CCP2 when Configuration bit, CCP2MX, is set.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\n- 2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRJ0/SEG32 RJ0 SEG32, Pin Number.TQFP = 62. RJ0/SEG32 RJ0 SEG32, Pin Type. = I/O O. RJ0/SEG32 RJ0 SEG32, Buffer Type. = ST Analog. RJ0/SEG32 RJ0 SEG32, Description. = Digital I/O. SEG32 output for LCD.. RJ1/SEG33 RJ1 SEG33, Pin Number.TQFP = 61. RJ1/SEG33 RJ1 SEG33, Pin Type. = I/O O. RJ1/SEG33 RJ1 SEG33, Buffer Type. = ST Analog. RJ1/SEG33 RJ1 SEG33, Description. = Digital I/O. SEG33 output for LCD.. RJ2/SEG34 RJ2 SEG34, Pin Number.TQFP = 60. RJ2/SEG34 RJ2 SEG34, Pin Type. = I/O",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nO. RJ2/SEG34 RJ2 SEG34, Buffer Type. = ST Analog. RJ2/SEG34 RJ2 SEG34, Description. = Digital I/O. SEG34 output for LCD.. RJ3/SEG35 RJ3 SEG35, Pin Number.TQFP = 59. RJ3/SEG35 RJ3 SEG35, Pin Type. = I/O O. RJ3/SEG35 RJ3 SEG35, Buffer Type. = ST Analog. RJ3/SEG35 RJ3 SEG35, Description. = Digital I/O. SEG35 output for LCD.. RJ4/SEG39 RJ4 SEG39, Pin Number.TQFP = 39. RJ4/SEG39 RJ4 SEG39, Pin Type. = I/O O. RJ4/SEG39 RJ4 SEG39, Buffer Type. = ST Analog. RJ4/SEG39 RJ4 SEG39, Description. = Digital",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. SEG39 output for LCD.. RJ5/SEG38 RJ5 SEG38, Pin Number.TQFP = 40. RJ5/SEG38 RJ5 SEG38, Pin Type. = I/O O. RJ5/SEG38 RJ5 SEG38, Buffer Type. = ST Analog. RJ5/SEG38 RJ5 SEG38, Description. = Digital I/O SEG38 output for LCD.. RJ6/SEG37 RJ6 SEG37, Pin Number.TQFP = 41. RJ6/SEG37 RJ6 SEG37, Pin Type. = I/O O. RJ6/SEG37 RJ6 SEG37, Buffer Type. = ST Analog. RJ6/SEG37 RJ6 SEG37, Description. = Digital I/O. SEG37 output for LCD.. SEG36 VSS, Pin Number.TQFP = . SEG36 VSS, Pin Type. = O. SEG36 VSS, Buffer",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nType. = Analog. SEG36 VSS, Description. = SEG36 output for LCD.. , Pin Number.TQFP = 11, 31, 51, 70. , Pin Type. = P. , Buffer Type. = GLYPH<151>. , Description. = Ground reference for logic and I/O pins.. VDD, Pin Number.TQFP = 12, 32, 48, 71. VDD, Pin Type. = P P. VDD, Buffer Type. = GLYPH<151>. VDD, Description. = Positive supply for logic and I/O pins.. AVSS AVDD, Pin Number.TQFP = 26 25. AVSS AVDD, Pin Type. = P. AVSS AVDD, Buffer Type. = GLYPH<151> GLYPH<151>. AVSS AVDD, Description. = Ground reference for analog modules. Positive supply for analog modules.\nLegend:\nTTL =  TTL compatible input\nST\n- =  Schmitt Trigger input with CMOS levels\nI\n=  Input\nP =  Power\nCMOS\n=  CMOS compatible input or output\nAnalog =  Analog input",
    "TABLE 1-3: PIC18F8X90 PINOUT I/O DESCRIPTIONS (CONTINUED)\nO\n=  Output\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1:\nDefault assignment for CCP2 when Configuration bit, CCP2MX, is set.\n2: Alternate assignment for CCP2 when Configuration bit, CCP2MX, is cleared.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "2.1 Oscillator Types\nPIC18F6390/6490/8390/8490 devices can be operated in ten different oscillator modes. The user can program the Configuration bits, FOSC3:FOSC0, in Configuration Register 1H to select one of these ten modes:\n1. LP\nLow-Power Crystal\n2. XT\nCrystal/Resonator\n3. HS\nHigh-Speed Crystal/Resonator\n4. HSPLL\nHigh-Speed Crystal/Resonator\nwith PLL Enabled\n5. RC\nExternal Resistor/Capacitor with FOSC/4 Output on RA6\n6. RCIO\nExternal Resistor/Capacitor with I/O on RA6\n7. INTIO1\nInternal Oscillator with FOSC/4 Output on RA6 and I/O on RA7\n8. INTIO2\nInternal Oscillator with I/O on RA6 and RA7\n9. EC\nExternal Clock with FOSC/4 Output\n10. ECIO\nExternal Clock with I/O on RA6",
    "2.2 Crystal Oscillator/Ceramic Resonators\nIn XT, LP, HS or HSPLL Oscillator modes, a crystal or ceramic  resonator  is  connected  to  the  OSC1  and OSC2 pins to establish  oscillation.  Figure 2-1  shows the pin connections.\nThe oscillator design requires the use of a parallel cut crystal.\nNote:, 1 = Use of a series cut crystal may give a fre- quency out of the crystal manufacturerGLYPH<146>s specifications.",
    "FIGURE 2-1:\nCRYSTAL/CERAMIC RESONATOR OPERATION (XT, LP, HS OR HSPLL CONFIGURATION)\nNote 1: See Table 2-1 and Table 2-2 for initial values of C1 and C2.\n2: A series resistor (RS) may be required for AT strip cut crystals.\n3: RF varies with the oscillator mode chosen.",
    "Typical Capacitor Values Used:\nXT, Freq = 455 kHz. XT, OSC1 = 56 pF. XT, OSC2 = 56 pF. , Freq = 2.0 MHz. , OSC1 = 47 pF. , OSC2 = 47 pF. , Freq = 4.0 MHz. , OSC1 = 33 pF. , OSC2 = 33 pF. HS, Freq = 8.0 MHz. HS, OSC1 = 27 pF. HS, OSC2 = 27 pF. , Freq = 16.0 MHz. , OSC1 = 22 pF. , OSC2 = 22 pF",
    "Capacitor values are for design guidance only.\nThese  capacitors  were  tested  with  the  resonators listed below for basic start-up and operation. These values are not optimized .\nDifferent capacitor values may be required to produce acceptable oscillator operation. The user should test the performance of the oscillator over the expected VDD and temperature range for the application.\nSee  the  notes  following Table 2-2 for additional information.\n455 kHz, Resonators Used: = 4.0 MHz. 2.0 MHz, Resonators Used: = 8.0 MHz. 16.0 MHz, Resonators Used: = 16.0 MHz",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nAn external clock source may also be connected to the OSC1 pin in the HS mode, as shown in Figure 2-2.",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nLP, Crystal Freq.Crystal Freq = 32 kHz. LP, Typical Capacitor Values Tested:.C1 = 33 pF. LP, Typical Capacitor Values Tested:.C2 = 33 pF. LP, Crystal Freq.Crystal Freq = 200 kHz. LP, Typical Capacitor Values Tested:.C1 = 15 pF. LP, Typical Capacitor Values Tested:.C2 = 15 pF. XT, Crystal Freq.Crystal Freq = 1 MHz. XT, Typical Capacitor Values Tested:.C1 = 33 pF. XT, Typical Capacitor Values Tested:.C2 = 33 pF. XT, Crystal Freq.Crystal Freq = 4 MHz. XT, Typical Capacitor Values Tested:.C1 = 27 pF. XT, Typical Capacitor Values Tested:.C2 = 27 pF. HS, Crystal Freq.Crystal Freq = 4 MHz. HS, Typical Capacitor Values Tested:.C1 = 27 pF. HS, Typical Capacitor Values Tested:.C2 = 27 pF.",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nHS, Crystal Freq.Crystal Freq = 8 MHz. HS, Typical Capacitor Values Tested:.C1 = 22 pF. HS, Typical Capacitor Values Tested:.C2 = 22 pF. HS, Crystal Freq.Crystal Freq = 20 MHz. HS, Typical Capacitor Values Tested:.C1 = 15 pF. HS, Typical Capacitor Values Tested:.C2 = 15 pF\nCapacitor values are for design guidance only.\nThese capacitors were tested with the crystals listed below for basic start-up and operation. These values are not optimized.\nDifferent capacitor values may be required to produce acceptable oscillator operation. The user should test the performance of the oscillator over the expected VDD and temperature range for the application.\nSee  the  notes  following  this  table  for  additional information.\n32 kHz, Crystals Used: = 4 MHz. 200 kHz, Crystals Used: = 8 MHz. 1 MHz, Crystals Used: = 20 MHz",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nNote 1: Higher capacitance increases the stability of oscillator, but also increases the start-up time.\n2: When operating below 3V VDD, or when using certain  ceramic  resonators  at  any voltage, it may be necessary to use the HS mode or switch to a crystal oscillator.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer for appropriate values of external components.\n4: Rs may be required to avoid overdriving crystals with low drive level specification.\n5: Always verify oscillator performance over the  VDD  and  temperature  range  that  is expected for the application.",
    "2.3 External Clock Input\nThe EC and ECIO Oscillator modes require an external clock source to be connected to the OSC1 pin. There is no  oscillator  start-up  time  required  after  a  Power-on Reset or after an exit from Sleep mode.\nIn  the  EC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic. Figure 2-3 shows the pin connections for the EC Oscillator mode.",
    "EXTERNAL CLOCK INPUT OPERATION (EC CONFIGURATION)\nThe ECIO Oscillator mode functions like the EC mode, except that the OSC2 pin becomes an additional general  purpose  I/O  pin.  The  I/O  pin  becomes  bit  6  of PORTA (RA6). Figure 2-4 shows the pin connections for the ECIO Oscillator mode.",
    "2.4 RC Oscillator\nFor timing insensitive applications, the GLYPH<147>RCGLYPH<148> and GLYPH<147>RCIOGLYPH<148> device  options  offer  additional  cost  savings. The actual oscillator frequency is a function of several factors:\nGLYPH<149> Supply voltage\nGLYPH<149> Values of the external resistor (REXT) and capacitor (CEXT)\nGLYPH<149> Operating temperature\nGiven the same device, operating voltage and temperature and component values, there will also be unit-to-unit  frequency  variations.  These  are  due  to factors such as:\nGLYPH<149> Normal manufacturing variation\nGLYPH<149> Difference in lead frame capacitance between package types (especially for low CEXT values)\nGLYPH<149> Variations within the tolerance of limits of REXT and CEXT\nIn  the  RC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic.  Figure 2-5  shows  how  the  R/C  combination  is connected.",
    "FIGURE 2-5: RC OSCILLATOR MODE\nThe RCIO Oscillator mode (Figure 2-6) functions like the RC mode, except that the OSC2 pin becomes an additional general purpose I/O pin. The I/O pin becomes bit 6 of PORTA (RA6).",
    "2.5 PLL Frequency Multiplier\nA Phase Locked Loop (PLL) circuit is provided as an option  for  users  who  want  to  use  a  lower  frequency oscillator circuit, or to clock the device up to its highest rated frequency from a crystal oscillator. This may be useful for customers who are concerned with EMI due to high-frequency crystals, or users who require higher clock speeds from an internal oscillator.",
    "2.5.1 HSPLL OSCILLATOR MODE\nThe HSPLL mode makes use of the HS mode oscillator for frequencies up to 10 MHz. A PLL then multiplies the oscillator output frequency by 4 to produce an internal clock frequency up to 40 MHz.\nThe PLL is only available to the crystal oscillator when the FOSC3:FOSC0 Configuration bits are programmed for HSPLL mode (= 0110 ).",
    "2.5.2 PLL AND INTOSC\nThe PLL is also available to the internal oscillator block in selected oscillator modes. In this configuration, the PLL  is  enabled  in  software  and  generates  a  clock output of up to 32 MHz. The operation of INTOSC with the PLL is described in Section 2.6.4 GLYPH<147>PLL in INTOSC ModesGLYPH<148> .",
    "2.6 Internal Oscillator Block\nThe PIC18F6390/6490/8390/8490 devices include an internal oscillator block, which generates two different clock signals; either can  be  used  as  the  microcontrollerGLYPH<146>s clock source. This may eliminate the need for  external  oscillator  circuits  on  the  OSC1  and/or OSC2 pins.\nWhen the OSCTUNE register is modified, the INTOSC and INTRC frequencies will begin shifting to the new frequency. The  INTRC  clock  will reach the new frequency within 8 clock cycles (approximately 8 * 32 \u03bc s = 256 \u03bc s).  The  INTOSC  clock  will  stabilize within 1 ms. Code execution continues during this shift. There is no indication that the shift has occurred.\nThe main output (INTOSC) is an 8 MHz clock source, which can be used to directly drive the device clock. It also drives a postscaler, which can provide a range of clock frequencies from 31 kHz to 4 MHz. The INTOSC output is enabled when a clock frequency from 125 kHz to 8 MHz is selected.",
    "2.6 Internal Oscillator Block\nThe  other  clock  source  is  the  internal  RC  oscillator (INTRC),  which  provides  a  nominal  31 kHz  output. INTRC is enabled if it is selected as the device clock source; it is also enabled automatically when any of the following are enabled:\nGLYPH<149> Power-up Timer\nGLYPH<149> Fail-Safe Clock Monitor\nGLYPH<149> Watchdog Timer\nGLYPH<149> Two-Speed Start-up\nGLYPH<149> LCD with INTRC as its clock source\nThese  features  are  discussed  in  greater  detail  in Section 23.0 GLYPH<147>Special Features of the CPUGLYPH<148> .\nThe  clock  source  frequency  (INTOSC  direct,  INTRC direct or INTOSC postscaler) is selected by configuring the IRCF bits of the OSCCON register (Register 2-2).",
    "2.6.1 INTIO MODES\nUsing the internal oscillator as the clock source eliminates the need for up to two external oscillator pins, which  can  then  be  used  for  digital  I/O.  Two  distinct configurations are available:\nGLYPH<149> In INTIO1 mode, the OSC2 pin outputs FOSC/4, while OSC1 functions as RA7 for digital input and output.\nGLYPH<149> In INTIO2 mode, OSC1 functions as RA7 and OSC2 functions as RA6, both for digital input and output.",
    "2.6.2 INTOSC OUTPUT FREQUENCY\nThe internal oscillator block is calibrated at the factory to produce an INTOSC output frequency of 8.0 MHz.\nThe  INTRC  oscillator  operates  independently  of  the INTOSC  source.  Any  changes  in  INTOSC  across voltage and temperature are not necessarily reflected by changes in INTRC and vice versa.",
    "2.6.3 OSCTUNE REGISTER\nThe internal oscillatorGLYPH<146>s output has been calibrated at the factory, but can be adjusted in the userGLYPH<146>s application. This is done by writing to the OSCTUNE register (Register 2-1). The tuning sensitivity is constant throughout the tuning range.\nThe OSCTUNE register also implements the INTSRC and PLLEN bits, which control certain features of the internal oscillator block. The INTSRC bit allows users to  select  which  internal  oscillator  provides  the  clock source when the 31 kHz frequency option is selected. This  is  covered  in  greater  detail  in Section 2.7.1 GLYPH<147>Oscillator Control RegisterGLYPH<148> .\nThe PLLEN bit controls the operation of the frequency multiplier, PLL, in internal oscillator modes.",
    "2.6.4 PLL IN INTOSC MODES\nThe 4x frequency multiplier can be used with the internal  oscillator  block  to  produce  faster  device  clock speeds  than  are  normally  possible  with  an  internal oscillator.  When  enabled,  the  PLL  produces  a  clock speed of up to 32 MHz.\nUnlike  HSPLL  mode,  the  PLL  is  controlled  through software. The control bit,  PLLEN (OSCTUNE<6>), is used to enable or disable its operation.\nThe PLL is available when the device is configured to use the internal oscillator block as its primary clock source (FOSC3:FOSC0 = 1001 or 1000 ). Additionally, the PLL will only function when the selected output frequency is either 4 MHz or 8 MHz (OSCCON<6:4> = 111 or 110 ). If both of these conditions are not met, the PLL is disabled.\nThe PLLEN control bit is only functional in those internal oscillator modes where the PLL is available. In all other  modes,  it  is  forced  to  GLYPH<145> 0 GLYPH<146> and  is  effectively unavailable.",
    "2.6.5 INTOSC FREQUENCY DRIFT\nThe  factory  calibrates  the  internal  oscillator  block output (INTOSC) for 8 MHz. However, this frequency may drift as VDD or temperature changes, which can affect the controller operation in a variety of ways. It is possible to adjust the INTOSC frequency by modifying the value in the OSTUNE register. This has no effect on the INTRC clock source frequency.\nTuning the INTOSC source requires knowing when to make the adjustment, in which direction it  should  be made  and  in  some  cases,  how  large  a  change  is needed. Three compensation techniques are discussed  in Section 2.6.5.1  GLYPH<147>Compensating  with the AUSARTGLYPH<148> , Section 2.6.5.2 GLYPH<147>Compensating with the  TimersGLYPH<148> and Section 2.6.5.3  GLYPH<147>Compensating with the TimersGLYPH<148> , but other techniques may be used.",
    "2.6.5.1 Compensating with the AUSART\nAn  adjustment  may  be  required  when  the  AUSART begins to generate framing errors or receives data with errors  while  in  Asynchronous  mode.  Framing  errors indicate that the device clock frequency is too high. To adjust  for  this,  decrement  the  value  in  OSTUNE  to reduce the clock frequency. On the other hand, errors in data may suggest that the clock speed is too low. To compensate, increment OSTUNE to increase the clock frequency.",
    "2.6.5.2 Compensating with the Timers\nThis technique compares device clock speed to some reference clock. Two timers may be used; one timer is clocked  by  the  peripheral  clock,  while  the  other  is clocked  by  a  fixed  reference  source,  such  as  the Timer1 oscillator.\nis  greater  than  expected,  then  the  internal  oscillator block is running too fast. To adjust for this, decrement the OSCTUNE register.",
    "2.6.5.3 Compensating with the Timers\nA  CCP  module  can  use  free-running  Timer1  (or Timer3), clocked by the internal oscillator block and an external  event  with  a  known  period  (i.e.,  AC  power frequency). The time of the first event is captured in the CCPRxH:CCPRxL registers and is recorded. When the second event  causes a  capture,  the  time  of  the  first event is subtracted from the time of the second event. Since the period of the external  event  is  known,  the time difference between events can be calculated.\nBoth timers are cleared, but the timer clocked by the reference  generates  interrupts.  When  an  interrupt occurs,  the  internally  clocked  timer  is  read  and  both timers are cleared. If the internally clocked timer value\nIf the measured  time  is much  greater than the calculated  time,  then  the  internal  oscillator  block  is running too fast. To compensate,  decrement  the OSTUNE register. If the measured time is much less than  the  calculated  time,  then  the  internal  oscillator block is running too slow. To compensate, increment the OSTUNE register.",
    "REGISTER 2-1: OSCTUNE: OSCILLATOR TUNING REGISTER\nINTSRC, R/W-0 (1) = PLLEN (1). INTSRC, U-0 = GLYPH<151>. INTSRC, R/W-0 = TUN4. INTSRC, R/W-0 = TUN3. INTSRC, R/W-0 = TUN2. INTSRC, R/W-0 = TUN1. INTSRC, R/W-0 = TUN0. bit 7 bit 0, R/W-0 (1) = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 2-1: OSCTUNE: OSCILLATOR TUNING REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nINTSRC: Internal Oscillator Low-Frequency Source Select bit\n1 = 31.25 kHz device clock derived from 8 MHz INTOSC source (divide-by-256 enabled)\n0 =\n31 kHz device clock derived directly from INTRC internal oscillator\nbit 6",
    "REGISTER 2-1: OSCTUNE: OSCILLATOR TUNING REGISTER\nPLLEN: Frequency Multiplier PLL for INTOSC Enable bit (1)\n1 = PLL enabled for INTOSC (4 MHz and 8 MHz only)\n0 = PLL disabled\nbit 5 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 4-0 TUN4:TUN0: Frequency Tuning bits\n01111 = Maximum frequency\nGLYPH<149>\nGLYPH<149>\nGLYPH<149>\nGLYPH<149>\n00001\n00000 = Center frequency. Oscillator module is running at the calibrated frequency.\n11111\nGLYPH<149>\nGLYPH<149>\nGLYPH<149>\nGLYPH<149>\n10000 = Minimum frequency\nNote 1: Available only in certain oscillator configurations; otherwise, this bit is unavailable and read as GLYPH<145> 0 GLYPH<146>. See Section 2.6.4 GLYPH<147>PLL in INTOSC ModesGLYPH<148> for details.",
    "2.7 Clock Sources and Oscillator Switching\nLike previous PIC18 devices, the PIC18F6390/6490/8390/8490 family includes a feature that allows the device clock source to be switched from the main oscillator to an alternate low-frequency clock source. PIC18F6390/6490/8390/8490  devices  offer two alternate clock sources. When an alternate clock source is enabled, the various power-managed operating modes are available.\nEssentially,  there  are  three  clock  sources  for  these devices:\nGLYPH<149> Primary oscillators\nGLYPH<149> Secondary oscillators\nGLYPH<149> Internal oscillator block\nThe primary oscillators include the External Crystal and  Resonator  modes,  the  External  RC  modes,  the External Clock modes and the internal oscillator block. The particular mode is defined by the FOSC3:FOSC0 Configuration  bits.  The  details  of  these  modes  are covered earlier in this chapter.\nThe secondary oscillators are those external sources not  connected  to  the  OSC1  or  OSC2  pins.  These sources  may  continue  to  operate  even  after the controller is placed in a power-managed mode.",
    "2.7 Clock Sources and Oscillator Switching\nPIC18F6390/6490/8390/8490 devices offer the Timer1 oscillator as a secondary oscillator. This oscillator, in all power-managed  modes,  is  often  the  time  base  for functions such as a Real-Time Clock.\nMost often, a 32.768 kHz watch crystal is connected between  the  RC0/T1OSO/T13CKI  and  RC1/T1OSI pins.  Like  the  LP  Oscillator  mode  circuit,  loading capacitors are also connected from each pin to ground.\nThe Timer1 oscillator is discussed in greater detail in Section 11.3 GLYPH<147>Timer1 OscillatorGLYPH<148> .\nIn addition to being a primary clock source, the internal oscillator  block is  available  as  a  power-managed mode clock source. The INTRC source is also used as the clock source for several special features, such as the WDT and Fail-Safe Clock Monitor.",
    "2.7 Clock Sources and Oscillator Switching\nThe clock sources for the PIC18F6390/6490/8390/8490 devices  are  shown  in  Figure 2-8.  See Section 23.0 GLYPH<147> Special Features of the CPUGLYPH<148> for Configuration register details.",
    "2.7.1 OSCILLATOR CONTROL REGISTER\nThe OSCCON register (Register 2-2) controls several aspects of the device clockGLYPH<146>s operation, both in full-power operation and in power-managed modes.\nThe IDLEN bit determines if the device goes into Sleep mode  or  one  of  the  Idle  modes  when  the SLEEP instruction is executed.\nThe System Clock Select bits, SCS1:SCS0, select the clock source. The available clock sources are the primary clock (defined by the FOSC:FOSC0 Configuration bits),  the  secondary  clock  (Timer1  oscillator)  and  the internal  oscillator  block.  The  clock  source  changes immediately after one or more of the bits is written to, following a brief clock transition interval. The SCS bits are cleared on all forms of Reset.",
    "2.7.1 OSCILLATOR CONTROL REGISTER\nThe Internal Oscillator Frequency Select bits, IRCF2:IRCF0,  select  the  frequency  output  of  the internal oscillator block to drive the device clock. The choices  are  the  INTRC  source,  the  INTOSC  source (8 MHz)  or  one  of  the  frequencies  derived  from  the INTOSC  postscaler (31.25 kHz to 4 MHz). If the internal oscillator block is supplying the device clock, changing the states of these bits will have an immediate change on the internal oscillatorGLYPH<146>s output.\nWhen  an  output  frequency  of  31 kHz  is  selected (IRCF2:IRCF0 = 000 ), users may choose which internal oscillator acts as the source. This is done with the INTSRC bit in the OSCTUNE register (OSCTUNE<7>). Setting this bit selects INTOSC as a 31.25 kHz clock source  by  enabling  the  divide-by-256  output  of  the INTOSC postscaler. Clearing INTSRC selects INTRC (nominally 31 kHz) as the clock source.",
    "2.7.1 OSCILLATOR CONTROL REGISTER\nThis option allows users to select the tunable and more precise INTOSC as a clock source, while maintaining power savings with a very low clock speed. Regardless of the setting of INTSRC, INTRC always remains the clock source for features such as the Watchdog Timer and the Fail-Safe Clock Monitor.\nThe OSTS, IOFS and T1RUN bits indicate which clock source  is  currently  providing  the  device  clock.  The OSTS bit indicates  that  the  Oscillator  Start-up  Timer has timed out and the primary clock is providing the device  clock  in  primary  clock  modes.  The  IOFS  bit indicates when the internal oscillator block has stabilized and is providing the device clock in RC Clock modes. The T1RUN bit (T1CON<6>) indicates when the  Timer1  oscillator  is  providing  the  device  clock  in secondary  clock  modes.  In  power-managed  modes, only one of these three bits will be set at any time. If none of these bits are set, the INTRC is providing the clock,  or  the  internal  oscillator  block  has  just  started and is not yet stable.",
    "2.7.1 OSCILLATOR CONTROL REGISTER\nThe use of the flag and control bits in the OSCCON register  is  discussed  in  more  detail  in Section 3.0 GLYPH<147>Power-Managed ModesGLYPH<148> .\nNote 1: The Timer1 oscillator must be enabled to select  the  secondary  clock  source.  The Timer1 oscillator is enabled by setting the T1OSCEN bit in the Timer1 Control register (T1CON<3>). If the Timer1 oscillator is not enabled, then any attempt to select a secondary clock source when executing a SLEEP instruction will be ignored.\n2: It is recommended that the Timer1 oscillator be operating and stable before executing the SLEEP instruction, or a very long  delay  may  occur  while  the  Timer1 oscillator starts.",
    "2.7.2 OSCILLATOR TRANSITIONS\nPIC18F6390/6490/8390/8490 devices contain circuitry to  prevent  clock  GLYPH<147>glitchesGLYPH<148> when  switching  between clock sources. A short pause in the device clock occurs during the clock switch. The length of this pause is the sum of two cycles of the old clock source and three to four  cycles  of  the  new  clock  source.  This  formula assumes that the new clock source is stable.\nClock  transitions  are  discussed  in  greater  detail  in Section 3.1.2 GLYPH<147>Entering Power-Managed ModesGLYPH<148> .",
    "OSCCON: OSCILLATOR CONTROL REGISTER\nIDLEN, R/W-1 = IRCF2. IDLEN, R/W-0 = IRCF1. IDLEN, R/W-0 = IRCF0. IDLEN, R (1) = OSTS. IDLEN, R-0 = IOFS. IDLEN, R/W-0 = SCS1. IDLEN, R/W-0 = SCS0. bit 7, R/W-1 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R (1) = bit 7. bit 7, R-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "OSCCON: OSCILLATOR CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 IDLEN: Idle Enable bit\n1 = Device enters Idle mode on SLEEP instruction\n0 = Device enters Sleep mode on SLEEP instruction\nbit 6-4\nIRCF2:IRCF0: Internal Oscillator Frequency Select bits\n111 = 8 MHz (INTOSC drives clock directly)\n110 = 4 MHz\n101 = 2 MHz\n100 = 1 MHz (3)\n011 = 500 kHz\n010 = 250 kHz\n001 = 125 kHz\n000 = 31 kHz (from either INTOSC/256 or INTRC directly) (2)\nbit 3 OSTS:\nOscillator Start-up Timer Time-out Status bit (1)\n1 = Oscillator Start-up Timer time-out has expired; primary oscillator is running\n0 = Oscillator Start-up Timer time-out is running; primary oscillator is not ready",
    "bit 2 IOFS: INTOSC Frequency Stable bit\n1 = INTOSC frequency is stable\n0 = INTOSC frequency is not stable",
    "bit 1-0 SCS1:SCS0: System Clock Select bits\n1x = Internal oscillator block\n01 = Timer1 oscillator\n00 = Primary oscillator\nNote 1: Depends on state of the IESO Configuration bit.\n2: Source selected by the INTSRC bit (OSCTUNE<7>), see Section 2.6.3 GLYPH<147>OSCTUNE RegisterGLYPH<148> .\n3: Default output frequency of INTOSC on Reset.",
    "2.8 Effects of Power-Managed Modes on the Various Clock Sources\nWhen PRI_IDLE mode is selected, the designated primary  oscillator  continues  to  run  without  interruption. For  all  other  power-managed  modes,  the  oscillator using the OSC1 pin is disabled. The OSC1 pin (and OSC2 pin, if used by the oscillator) will stop oscillating.\nIn secondary clock modes (SEC_RUN and SEC_IDLE),  the  Timer1  oscillator  is  operating  and providing the device clock. The Timer1 oscillator may also  run  in  all  power-managed  modes  if  required  to clock Timer1 or Timer3.",
    "2.8 Effects of Power-Managed Modes on the Various Clock Sources\nIn  internal  oscillator  modes (RC_RUN and RC_IDLE), the  internal  oscillator  block  provides  the  device  clock source. The 31 kHz INTRC output can be used directly to provide the clock and may be enabled to support various special features, regardless of the power-managed mode  (see Section 23.2  GLYPH<147>Watchdog  Timer  (WDT)GLYPH<148> through Section 23.4  GLYPH<147>Fail-Safe  Clock  MonitorGLYPH<148> for more information on WDT, Fail-Safe Clock Monitor and Two-Speed Start-up). The INTOSC output at 8 MHz may be used directly to clock the device, or may be divided down by the postscaler. The INTOSC output is disabled if the clock is provided directly from the INTRC output.\nIf  the  Sleep  mode  is  selected,  all  clock  sources  are stopped.  Since  all  the  transistor  switching  currents have been stopped, Sleep mode achieves the lowest current consumption  of  the device (only leakage currents).",
    "2.9 Power-up Delays\nPower-up delays are controlled by two timers, so that no external Reset circuitry is required for most applications. The delays ensure that the device is kept in Reset until the device power supply is stable under normal circumstances and the primary clock is operating and stable. For  additional  information  on  power-up  delays,  see Section 4.5 GLYPH<147>Device Reset TimersGLYPH<148> .\nThe first timer is the Power-up Timer (PWRT), which provides  a  fixed  delay  on  power-up  (parameter  33, Table 26-10).  It is enabled  by  clearing  (= 0 ) the PWRTEN Configuration bit.\nThe  second  timer  is  the  Oscillator  Start-up  Timer (OST),  intended  to  keep  the  chip  in  Reset  until  the crystal oscillator is stable (LP , XT and HS modes). The OST  does  this  by  counting  1024  oscillator  cycles before allowing the oscillator to clock the device.\nWhen  the  HSPLL  Oscillator  mode  is  selected,  the device is kept in Reset for an additional 2 ms, following the HS mode OST delay, so the PLL can lock to the incoming clock frequency.",
    "2.9 Power-up Delays\nThere  is  a  delay  of  interval  TCSD  (parameter  38, Table 26-10) following POR while the controller becomes ready to execute instructions. This delay runs concurrently  with  any  other  delays.  This  may  be  the only delay that occurs when any of the EC, RC or INTIO modes are used as the primary clock source.\nEnabling any on-chip feature that will  operate during Sleep will increase the current consumed during Sleep. The INTRC is required to support WDT operation. The Timer1  oscillator may  be  operating  to support a Real-Time Clock. Other features may be operating that do not require a device clock source (i.e., MSSP slave, INTx pins and others). Peripherals that may add significant  current  consumption  are  listed  in Section 26.2 GLYPH<147>DC Characteristics: Power-Down  and Supply CurrentGLYPH<148> .",
    "TABLE 2-3: OSC1 AND OSC2 PIN STATES IN SLEEP MODE\nRC, INTIO1, OSC1 Pin = Floating, external resistor should pull high. RC, INTIO1, OSC2 Pin = At logic low (clock/4 output). RCIO, INTIO2, OSC1 Pin = Floating, external resistor should pull high. RCIO, INTIO2, OSC2 Pin = Configured as PORTA, bit 6. ECIO, OSC1 Pin = Floating, pulled by external clock. ECIO, OSC2 Pin = Configured as PORTA, bit 6. EC, OSC1 Pin = Floating, pulled by external clock. EC, OSC2 Pin = At logic low (clock/4 output). LP, XT and HS, OSC1 Pin = Feedback inverter disabled at quiescent voltage level. LP, XT and HS, OSC2 Pin = Feedback inverter disabled at quiescent voltage level\nNote: See Table 4-2 in Section 4.0 GLYPH<147>ResetGLYPH<148> for time-outs due to Sleep and MCLR Reset.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "3.0 POWER-MANAGED MODES\nPIC18F6390/6490/8390/8490  devices  offer  a  total  of seven  operating modes  for more  efficient power management.  These  modes  provide  a  variety  of options for selective power conservation in applications where resources may be limited (i.e., battery-powered devices).\nThere are three categories of power-managed modes:\nGLYPH<149> Sleep mode\nGLYPH<149> Idle modes\nGLYPH<149> Run modes\nThese categories define which portions of the device are clocked and sometimes, what speed. The Run and Idle modes may use any of the three available clock sources (primary, secondary or INTOSC multiplexer); the Sleep mode does not use a clock source.\nThe power-managed modes include several power-saving  features.  One  of  these  is  the  clock switching  feature,  offered  in  other  PIC18  devices, allowing the controller to use the Timer1 oscillator in place  of  the  primary  oscillator.  Also  included  is  the Sleep  mode,  offered  by  all  PIC fi devices,  where  all device clocks are stopped.",
    "3.1 Selecting Power-Managed Modes\nSelecting a power-managed mode requires deciding if the CPU is to be clocked or not and selecting a clock source. The IDLEN bit controls CPU clocking, while the SCS1:SCS0 bits select a clock source. The individual modes, bit settings, clock sources and affected modules are summarized in Table 3-1.",
    "3.1.1 CLOCK SOURCES\nThe SCS1:SCS0 bits allow the selection of one of three clock sources for power-managed modes. They are:\nGLYPH<149> the primary clock, as defined by the FOSC3:FOSC0 Configuration bits\nGLYPH<149> the secondary clock (the Timer1 oscillator)\nGLYPH<149> the internal oscillator block (for RC modes)",
    "3.1.2 ENTERING POWER-MANAGED MODES\nEntering power-managed Run mode, or switching from one  power-managed  mode  to  another,  begins  by loading  the  OSCCON  register.  The  SCS1:SCS0  bits select  the  clock  source  and  determine  which  Run or Idle mode is being used. Changing these bits causes an immediate switch to the new clock source, assuming that it  is  running.  The  switch  may  also  be subject to clock transition delays. These are discussed in Section 3.1.3 GLYPH<147>Clock Transitions and  Status IndicatorsGLYPH<148> and subsequent sections.\nEntry  to  the  power-managed  Idle  or  Sleep  modes  is triggered by the execution of a SLEEP instruction. The actual mode that results depends on the status of the IDLEN bit.\nDepending on the current mode and the mode being switched to, a change to a power-managed mode does not always require setting all of these bits. Many transitions  may  be  done  by  changing  the  oscillator  select bits, or changing the IDLEN bit prior to issuing a SLEEP instruction.  If the  IDLEN  bit  is  already  configured correctly, it may only be necessary to perform a SLEEP instruction to switch to the desired mode.\n\nTABLE 3-1: POWER-MANAGED MODES",
    "3.1.2 ENTERING POWER-MANAGED MODES\nSleep, OSCCON<7,1:0>.IDLEN (1) = 0. Sleep, OSCCON<7,1:0>.SCS1:SCS0 = N/A. Sleep, Module Clocking.CPU = Off. Sleep, Module Clocking.Peripherals = Off. Sleep, Available Clock and Oscillator Source.Available Clock and Oscillator Source = None GLYPH<150> All clocks are disabled. PRI_RUN, OSCCON<7,1:0>.IDLEN (1) = N/A. PRI_RUN, OSCCON<7,1:0>.SCS1:SCS0 = 00. PRI_RUN, Module Clocking.CPU = Clocked. PRI_RUN, Module Clocking.Peripherals = Clocked. PRI_RUN, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Primary GLYPH<150> LP, XT, HS, HSPLL, RC, EC, INTRC (2) This is the normal, full-power execution mode.. SEC_RUN,",
    "3.1.2 ENTERING POWER-MANAGED MODES\nOSCCON<7,1:0>.IDLEN (1) = N/A. SEC_RUN, OSCCON<7,1:0>.SCS1:SCS0 = 01. SEC_RUN, Module Clocking.CPU = Clocked. SEC_RUN, Module Clocking.Peripherals = Clocked. SEC_RUN, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Secondary GLYPH<150> Timer1 Oscillator. RC_RUN, OSCCON<7,1:0>.IDLEN (1) = N/A. RC_RUN, OSCCON<7,1:0>.SCS1:SCS0 = 1x. RC_RUN, Module Clocking.CPU = Clocked. RC_RUN, Module Clocking.Peripherals = Clocked. RC_RUN, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Internal Oscillator Block (2). PRI_IDLE, OSCCON<7,1:0>.IDLEN (1) = 1. PRI_IDLE,",
    "3.1.2 ENTERING POWER-MANAGED MODES\nOSCCON<7,1:0>.SCS1:SCS0 = 00. PRI_IDLE, Module Clocking.CPU = Off. PRI_IDLE, Module Clocking.Peripherals = Clocked. PRI_IDLE, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Primary GLYPH<150> LP, XT, HS, HSPLL, RC, EC. SEC_IDLE, OSCCON<7,1:0>.IDLEN (1) = 1. SEC_IDLE, OSCCON<7,1:0>.SCS1:SCS0 = 01. SEC_IDLE, Module Clocking.CPU = Off. SEC_IDLE, Module Clocking.Peripherals = Clocked. SEC_IDLE, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Secondary GLYPH<150> Timer1 Oscillator. RC_IDLE, OSCCON<7,1:0>.IDLEN (1) = 1. RC_IDLE, OSCCON<7,1:0>.SCS1:SCS0",
    "3.1.2 ENTERING POWER-MANAGED MODES\n= 1x. RC_IDLE, Module Clocking.CPU = Off. RC_IDLE, Module Clocking.Peripherals = Clocked. RC_IDLE, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Internal Oscillator Block (2)\nNote\n1: IDLEN reflects its value when the SLEEP instruction is executed.\n2: Includes INTOSC and INTOSC postscaler, as well as the INTRC source.",
    "3.2 Run Modes\nThe length of the transition between clock sources is the sum of two cycles of the old clock source and three to  four  cycles  of  the  new  clock  source.  This  formula assumes that the new clock source is stable.\nThree  bits  indicate  the  current  clock  source  and  its status. They are:\nGLYPH<149> OSTS (OSCCON<3>)\nGLYPH<149> IOFS (OSCCON<2>)\nGLYPH<149> T1RUN (T1CON<6>)\nIn general, only one of these bits will be set while in a given  power-managed  mode.  When  the  OSTS  bit  is set,  the  primary  clock  is  providing  the  device  clock. When the IOFS bit is set, the INTOSC output provides a stable, 8 MHz clock source to a divider that actually drives the device clock. When the T1RUN bit is set, the Timer1 oscillator provides the clock. If none of these bits are set, then either the INTRC clock source clocks the device, or the INTOSC source is not yet stable.",
    "3.2 Run Modes\nIf the  internal  oscillator  block  is  configured  as  the primary clock source by the FOSC3:FOSC0 Configuration bits, then both the OSTS and IOFS bits may be set when in PRI_RUN or PRI_IDLE modes. This indicates that the primary clock (INTOSC output) is generating a stable 8 MHz output. Entering another power-managed  RC  mode  at  the  same  frequency would clear the OSTS bit.\nNote 1: Caution should be used when modifying a single IRCF bit. If VDD is less than 3V, it is possible  to  select  a  higher  clock  speed than is supported by the low VDD. Improper  device  operation  may  result  if the VDD/FOSC specifications are violated.\n2: Executing a SLEEP instruction  does  not necessarily  place  the  device  into  Sleep mode. It acts as the trigger to place the controller  into  either  the  Sleep  mode  or one of the Idle modes, depending on the setting of the IDLEN bit.",
    "3.1.4 MULTIPLE SLEEP COMMANDS\nThe  power-managed  mode  that  is  invoked  with  the SLEEP instruction is determined by the setting of the IDLEN  bit  at  the  time  the  instruction  is  executed.  If another SLEEP instruction is executed, the device will enter the power-managed mode specified by IDLEN at that time. If IDLEN has changed, the device will enter the new power-managed mode specified by the new setting.\nIn the  Run  modes,  clocks  to  both  the  core  and peripherals are active. The difference between these modes is the clock source.",
    "3.2.1 PRI_RUN MODE\nThe PRI_RUN mode is the normal, full-power execution mode of the microcontroller. This is also the default mode upon a device Reset unless Two-Speed Start-up  is  enabled  (see Section 23.3  GLYPH<147>Two-Speed Start-upGLYPH<148> for details). In this mode, the OSTS bit is set. The IOFS bit may be set if the internal oscillator block is the primary clock source (see Section 2.7.1 GLYPH<147>Oscillator Control RegisterGLYPH<148> ).",
    "3.2.2 SEC_RUN MODE\nThe SEC_RUN mode is the compatible mode to the GLYPH<147>clock switchingGLYPH<148> feature offered in other PIC18 devices.  In  this  mode,  the  CPU  and  peripherals  are clocked from the Timer1 oscillator. This gives users the option of lower power consumption while still using a high-accuracy clock source.\nSEC_RUN mode is entered by setting the SCS1:SCS0 bits to GLYPH<145> 01 GLYPH<146>. The device clock source is switched to the Timer1 oscillator (see Figure 3-1), the primary oscillator is shut down, the T1RUN bit (T1CON<6>) is set and the OSTS bit is cleared.",
    "Note:\nThe  Timer1  oscillator  should  already  be running prior to entering SEC_RUN mode. If  the  T1OSCEN  bit  is  not  set  when  the SCS1:SCS0 bits are set to GLYPH<145> 01 GLYPH<146>, entry to SEC_RUN  mode  will  not  occur.  If  the Timer1  oscillator  is  enabled,  but  not  yet running, peripheral clocks will be delayed until  the  oscillator  has  started.  In  such situations, initial oscillator operation is far from  stable  and  unpredictable  operation may result.\nOn transitions from SEC_RUN mode to PRI_RUN, the peripherals and CPU continue to be clocked from the Timer1  oscillator  while  the  primary  clock  is  started. When the primary clock becomes ready, a clock switch back  to  the  primary  clock  occurs  (see  Figure 3-2). When the clock switch is complete, the T1RUN bit is cleared,  the  OSTS  bit  is  set  and  the  primary  clock provides the clock. The IDLEN and SCS bits are not affected by the wake-up; the Timer1 oscillator continues to run.",
    "3.2.3 RC_RUN MODE\nIn RC_RUN  mode,  the  CPU  and  peripherals  are clocked  from  the  internal  oscillator  block  using  the INTOSC  multiplexer  and  the  primary  clock  is  shut down.  When  using  the  INTRC  source,  this  mode provides  the  best  power  conservation  of  all  the  Run modes, while still executing code. It works well for user applications which are not highly timing-sensitive, or do not require high-speed clocks at all times.\nIf  the IRCF bits and the INTSRC bit are all clear, the INTOSC output is not  enabled  and  the  IOFS  bit  will remain clear; there will be no indication of the current clock source. The INTRC source provides the device clocks.\nIf the primary clock source is the internal oscillator block (either INTRC or INTOSC), there are no distinguishable differences  between  PRI_RUN  and  RC_RUN  modes during execution. However, a clock switch delay will occur during entry to and exit from RC_RUN mode. Therefore, if the primary clock source is the internal oscillator block, the use of RC_RUN mode is not recommended.",
    "3.2.3 RC_RUN MODE\nThis  mode is  entered  by  setting  the  SCS1  bit  to  GLYPH<145> 1 GLYPH<146>. Although it is ignored, it is recommended that the SCS0 bit also be  cleared; this is to maintain software compatibility with future devices.  When  the  clock source  is  switched  to  the  INTOSC  multiplexer  (see Figure 3-3), the primary oscillator is shut down and the OSTS bit is cleared. The IRCF bits may be modified at any time to immediately change the clock speed.\nNote:\nIf the  IRCF  bits  are  changed  from  all  clear  (thus enabling the INTOSC output), or if INTSRC is set, the IOFS  bit becomes  set  after the INTOSC  output becomes stable. Clocks to the device continue while the  INTOSC  source  stabilizes  after  an  interval  of TIOBST.\nIf the IRCF bits were previously at a non-zero value, or if INTSRC  was  set  before  setting  SCS1  and  the INTOSC source was already stable, the IOFS bit will remain set.",
    "3.2.3 RC_RUN MODE\nOn transitions from RC_RUN mode to PRI_RUN, the device  continues  to  be  clocked  from  the  INTOSC multiplexer while the primary clock is started. When the primary  clock  becomes  ready,  a  clock  switch  to  the primary clock occurs (see Figure 3-4). When the clock switch is complete, the IOFS bit is cleared, the OSTS bit  is  set  and  the  primary  clock  provides  the  device clock. The IDLEN and SCS bits are not affected by the switch. The INTRC source will continue to run if either the WDT or the Fail-Safe Clock Monitor is enabled.\nCaution should be used when modifying a single IRCF bit. If VDD is less than 3V, it is possible  to  select  a  higher  clock  speed than is supported by the low VDD. Improper  device  operation  may  result  if the VDD/FOSC specifications are violated.",
    "3.3 Sleep Mode\nThe power-managed Sleep mode in the PIC18F6390/6490/8390/8490  devices  is  identical  to the legacy Sleep mode offered in all other PIC devices. It is entered by clearing the IDLEN bit (the default state on device Reset) and executing the SLEEP instruction. This shuts down the selected oscillator (see Figure 3-5). All clock source status bits are cleared.\nEntering the Sleep mode from any other mode does not require a clock switch. This is because no clocks are needed once the controller has entered Sleep. If the WDT is selected,  the  INTRC  source  will  continue  to operate. If the Timer1 oscillator is enabled, it will also continue to run.",
    "3.3 Sleep Mode\nWhen a wake event occurs in Sleep mode (by interrupt, Reset or WDT time-out), the device will not be clocked until  the  primary  clock  source  becomes  ready  (see Figure 3-6), or it will be clocked from the internal oscillator  block  if  either  the  Two-Speed  Start-up  or  the Fail-Safe Clock Monitor are enabled (see Section 23.0 GLYPH<147>Special  Features  of the CPUGLYPH<148> ).  In  either  case,  the OSTS bit is set when the primary clock provides the device  clocks.  The  IDLEN  and  SCS  bits  are  not affected by the wake-up.",
    "3.4 Idle Modes\nThe  Idle  modes  allow  the  controllerGLYPH<146>s CPU  to  be selectively shut down while the peripherals continue to operate. Selecting a particular Idle mode allows users to further manage power consumption.\nIf the IDLEN bit is set to a GLYPH<145> 1 GLYPH<146>  when a SLEEP instruction is  executed,  the  peripherals  will  be  clocked  from  the clock  source  selected  using  the  SCS1:SCS0  bits; however, the CPU will not be clocked. The clock source status bits are not affected. Setting IDLEN and executing SLEEP provides a quick method of switching from a given Run mode to its corresponding Idle mode.\nIf the WDT is selected, the INTRC source will continue to operate. If the Timer1 oscillator is enabled, it will also continue to run.",
    "3.4 Idle Modes\nSince the CPU is not executing instructions, the only exits from any of the Idle modes are by interrupt, WDT time-out or a Reset. When a wake event occurs, CPU execution is delayed by an interval of TCSD (parameter 38, Table 26-10) while it becomes ready to execute code. When the CPU begins executing code, it resumes with the same clock source for the current Idle mode. For example, when waking from RC_IDLE mode, the internal oscillator block will clock the CPU and peripherals (in other words, RC_RUN mode). The IDLEN and SCS bits are not affected by the wake-up.\nWhile  in  any  Idle  mode  or  the  Sleep  mode,  a  WDT time-out will result in a WDT wake-up to the Run mode currently specified by the SCS1:SCS0 bits.",
    "FIGURE 3-5: TRANSITION TIMING FOR ENTRY TO SLEEP MODE\nQ4 Q3 Q2 Q1 Q1, 1 = . Q4 Q3 Q2 Q1 Q1, 2 = . OSC1, 1 = . OSC1, 2 = . CPU, 1 = . CPU, 2 = . Clock, 1 = . Clock, 2 = . Peripheral, 1 = . Peripheral, 2 = . Clock, 1 = . Clock, 2 = . Sleep, 1 = . Sleep, 2 = . Program Counter PC, 1 = . Program Counter PC, 2 = . , 1 = PC. , 2 = . , 1 = . , 2 = + 2\nFIGURE 3-6:",
    "3.4.1 PRI_IDLE MODE\nThis mode is unique among the three low-power Idle modes, in that it does not disable the primary device clock. For timing-sensitive applications, this allows for the fastest resumption of device operation with its more accurate primary clock source, since the clock source does not have to GLYPH<147>warm upGLYPH<148> or transition from another oscillator.\nWhen a wake event occurs, the CPU is clocked from the primary  clock  source.  A  delay  of  interval  TCSD  is required  between  the  wake  event  and  when  code execution starts. This is required to allow the CPU to become ready to execute instructions. After the wake-up,  the  OSTS  bit  remains  set.  The  IDLEN  and SCS  bits are not affected by the wake-up  (see Figure 3-8).",
    "3.4.1 PRI_IDLE MODE\nPRI_IDLE mode is entered from PRI_RUN mode by setting the IDLEN bit and executing a SLEEP instruction. If the device is in another Run mode, set IDLEN first, then  clear  the  SCS  bits  and  execute SLEEP . Although the CPU is disabled, the peripherals continue to be clocked from the primary clock source specified by the FOSC3:FOSC0 Configuration bits. The OSTS bit remains set (see Figure 3-7).",
    "3.4.3 RC_IDLE MODE\nIn  SEC_IDLE  mode,  the  CPU  is  disabled  but  the peripherals  continue  to  be  clocked  from  the  Timer1 oscillator. This mode is entered from SEC_RUN by setting the IDLEN bit and executing a SLEEP instruction. If the device is in another Run mode, set IDLEN first, then set SCS1:SCS0 to GLYPH<145> 01 GLYPH<146>  and execute SLEEP . When the clock source is switched to the Timer1 oscillator, the primary oscillator is shut down, the OSTS bit is cleared and the T1RUN bit is set.\nWhen a wake event occurs, the peripherals continue to be clocked from the Timer1 oscillator. After an interval of  TCSD  following  the  wake  event,  the  CPU  begins executing code being clocked by the Timer1 oscillator. The  IDLEN  and  SCS  bits  are  not  affected  by  the wake-up; the Timer1 oscillator  continues  to  run  (see Figure 3-8).",
    "Note:\nThe  Timer1  oscillator  should  already  be running prior to entering SEC_IDLE mode. If  the  T1OSCEN  bit  is  not  set  when  the SLEEP instruction is executed, the SLEEP instruction  will  be  ignored  and  entry  to SEC_IDLE  mode  will  not  occur.  If  the Timer1  oscillator  is  enabled,  but  not  yet running, peripheral clocks will be delayed until  the  oscillator  has  started.  In  such situations, initial oscillator operation is far from  stable  and  unpredictable  operation may result.\nIn RC_IDLE mode, the CPU is disabled but the peripherals continue to be clocked from the internal oscillator block using the INTOSC multiplexer. This mode allows for controllable power conservation during Idle periods.",
    "Note:\nFrom  RC_RUN,  this  mode  is  entered  by  setting  the IDLEN  bit  and  executing  a SLEEP instruction.  If  the device is in another Run mode, first set IDLEN, then set the SCS1 bit and execute SLEEP . Although its value is ignored, it is recommended that SCS0 also be cleared; this  is  to  maintain  software  compatibility  with  future devices.  The  INTOSC  multiplexer  may  be  used  to select a higher clock frequency by modifying the IRCF bits before executing the SLEEP instruction. When the clock source is switched to the INTOSC multiplexer, the primary  oscillator  is  shut  down  and  the  OSTS  bit  is cleared.",
    "Note:\nIf the IRCF bits are set to any non-zero value, or the INTSRC bit is set, the INTOSC output is enabled. The IOFS  bit becomes  set  after the INTOSC  output becomes stable after an interval of TIOBST (parameter 39, Table 26-10). Clocks to the peripherals continue  while  the  INTOSC  source  stabilizes.  If  the IRCF  bits  were  previously  at  a  non-zero  value,  or INTSRC  was  set  before  the SLEEP instruction  was executed and the INTOSC source was already stable, the  IOFS  bit  will  remain  set.  If  the  IRCF  bits  and INTSRC are all clear, the INTOSC output will not be enabled; the IOFS bit will remain clear and there will be no indication of the current clock source.\nWhen a wake event occurs, the peripherals continue to be clocked from the INTOSC multiplexer. After a delay of  TCSD  following  the  wake  event,  the  CPU  begins executing  code  being  clocked  by  the  INTOSC  multiplexer. The IDLEN and SCS bits are not affected by the wake-up.  The  INTRC  source  will  continue  to  run  if either  the  WDT  or  the  Fail-Safe  Clock  Monitor  is enabled.",
    "3.5.3 EXIT BY RESET\nAn exit from Sleep mode or any of the Idle modes is triggered by an interrupt, a Reset or a WDT time-out. This  section  discusses  the  triggers  that  cause  exits from power-managed modes. The clocking subsystem actions are discussed in each of the power-managed modes (see Section 3.2 GLYPH<147>Run ModesGLYPH<148> through Section 3.4 GLYPH<147>Idle ModesGLYPH<148> ).",
    "3.5.1 EXIT BY INTERRUPT\nAny of the available interrupt sources can cause the device  to  exit  from  an  Idle  or  Sleep  mode  to  a  Run mode. To enable this functionality, an interrupt source must be enabled by setting its enable bit in one of the INTCON or PIE registers. The exit sequence is initiated when the corresponding interrupt flag bit is set.\nOn all exits from Idle or Sleep modes by interrupt, code execution branches  to  the interrupt vector if the GIE/GIEH  bit  (INTCON<7>)  is  set.  Otherwise,  code execution  continues  or  resumes  without  branching (see Section 8.0 GLYPH<147>InterruptsGLYPH<148> ).\nA  fixed  delay  of  interval,  TCSD,  following  the  wake event, is required when leaving Sleep and Idle modes. This  delay  is  required  for  the  CPU  to  prepare  for execution.  Instruction  execution  resumes  on  the  first clock cycle following this delay.",
    "3.5.2 EXIT BY WDT TIME-OUT\nA WDT time-out will cause different actions depending on which power-managed mode the device is in when the time-out occurs.\nIf the device is not executing code (all Idle modes and Sleep mode), the time-out will result in an exit from the power-managed mode (see Section 3.2 GLYPH<147> Run ModesGLYPH<148> and Section 3.3 GLYPH<147>Sleep ModeGLYPH<148> ). If the device is  executing  code  (all  Run  modes),  the  time-out  will result in a WDT Reset (see Section 23.2 GLYPH<147>Watchdog Timer (WDT)GLYPH<148> ).\nThe WDT timer and postscaler are cleared by executing a SLEEP or CLRWDT instruction, losing a currently selected clock source (if the Fail-Safe Clock Monitor is enabled) and modifying the IRCF bits in the OSCCON register if the internal oscillator block is the device clock source.",
    "3.5.2 EXIT BY WDT TIME-OUT\nNormally, the device is held in Reset by the Oscillator Start-up Timer (OST) until the primary clock becomes ready. At that time, the OSTS bit is set and the device begins executing code. If the internal oscillator block is the new clock source, the IOFS bit is set instead.\nThe  exit  delay  time  from  Reset  to  the  start  of  code execution depends on both the clock sources before and after the wake-up and the type of oscillator if the new clock source is the primary clock. Exit delays are summarized in Table 3-2.",
    "3.5.2 EXIT BY WDT TIME-OUT\nCode  execution  can  begin  before  the  primary  clock becomes ready. If either the Two-Speed Start-up (see Section 23.3  GLYPH<147>Two-Speed Start-upGLYPH<148> ) or Fail-Safe Clock  Monitor  (see Section 23.4  GLYPH<147>Fail-Safe  Clock MonitorGLYPH<148> ) is enabled, the device may begin execution as soon as the Reset source has cleared. Execution is clocked  by  the  INTOSC  multiplexer  driven  by  the internal  oscillator  block.  Execution  is  clocked  by  the internal  oscillator  block  until  either  the  primary  clock becomes ready, or a power-managed mode is entered before the primary clock becomes ready; the primary clock is then shut down.",
    "3.5.4 EXIT WITHOUT AN OSCILLATOR START-UP DELAY\nCertain  exits  from  power-managed  modes  do  not invoke the OST at all. There are two cases:\nGLYPH<149> PRI_IDLE mode, where the primary clock source is not stopped; and\nGLYPH<149> the primary clock source is not any of the LP, XT, HS or HSPLL modes.\nIn  these  instances,  the  primary  clock  source  either does not require an oscillator start-up delay since it is already  running  (PRI_IDLE),  or  normally  does  not require an oscillator start-up delay (RC, EC and INTIO Oscillator modes). However, a fixed delay of interval, TCSD, following the wake event, is still required when leaving  Sleep  and  Idle  modes  to  allow  the  CPU  to prepare for  execution.  Instruction  execution  resumes on the first clock cycle following this delay.",
    "TABLE 3-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nPrimary Device Clock (PRI_IDLE mode), Clock Source after Wake-up = LP, XT, HS. Primary Device Clock (PRI_IDLE mode), Exit Delay = TCSD (2). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = OSTS. Primary Device Clock (PRI_IDLE mode), Clock Source after Wake-up = HSPLL. Primary Device Clock (PRI_IDLE mode), Exit Delay = TCSD (2). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = OSTS. Primary Device Clock (PRI_IDLE mode), Clock Source after Wake-up = EC, RC, INTRC (1). Primary Device Clock (PRI_IDLE mode), Exit Delay = TCSD (2). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = GLYPH<151>. Primary Device Clock (PRI_IDLE mode), Clock Source after Wake-up = INTOSC (3). Primary Device Clock",
    "TABLE 3-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\n(PRI_IDLE mode), Exit Delay = TCSD (2). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = IOFS. T1OSC or INTRC (1), Clock Source after Wake-up = LP, XT, HS. T1OSC or INTRC (1), Exit Delay = TOST (4). T1OSC or INTRC (1), Clock Ready Status Bit (OSCCON) = OSTS. T1OSC or INTRC (1), Clock Source after Wake-up = HSPLL. T1OSC or INTRC (1), Exit Delay = TOST + t rc (4). T1OSC or INTRC (1), Clock Ready Status Bit (OSCCON) = OSTS. T1OSC or INTRC (1), Clock Source after Wake-up = EC, RC, INTRC (1). T1OSC or INTRC (1), Exit Delay = TCSD (2). T1OSC or",
    "TABLE 3-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nINTRC (1), Clock Ready Status Bit (OSCCON) = GLYPH<151>. T1OSC or INTRC (1), Clock Source after Wake-up = INTOSC (3). T1OSC or INTRC (1), Exit Delay = TIOBST (5). T1OSC or INTRC (1), Clock Ready Status Bit (OSCCON) = IOFS. INTOSC (3), Clock Source after Wake-up = LP, XT, HS. INTOSC (3), Exit Delay = TOST (5). INTOSC (3), Clock Ready Status Bit (OSCCON) = OSTS. INTOSC (3), Clock Source after Wake-up = HSPLL. INTOSC (3), Exit Delay = TOST + t rc (4). INTOSC (3), Clock Ready Status Bit (OSCCON) = OSTS. INTOSC (3), Clock Source after Wake-up = EC, RC, INTRC (1). INTOSC (3), Exit Delay",
    "TABLE 3-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\n= TCSD (2). INTOSC (3), Clock Ready Status Bit (OSCCON) = GLYPH<151>. INTOSC (3), Clock Source after Wake-up = INTOSC (3). INTOSC (3), Exit Delay = None. INTOSC (3), Clock Ready Status Bit (OSCCON) = IOFS. None (Sleep mode), Clock Source after Wake-up = LP, XT, HS. None (Sleep mode), Exit Delay = TOST (4). None (Sleep mode), Clock Ready Status Bit (OSCCON) = OSTS. None (Sleep mode), Clock Source after Wake-up = HSPLL. None (Sleep mode), Exit Delay = TOST + t rc (4). None (Sleep mode), Clock Ready Status Bit (OSCCON) = OSTS. None (Sleep mode), Clock Source after Wake-up = EC, RC, INTRC (1). None (Sleep mode), Exit Delay = TCSD (2). None (Sleep mode),",
    "TABLE 3-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nClock Ready Status Bit (OSCCON) = GLYPH<151>. None (Sleep mode), Clock Source after Wake-up = INTOSC (3). None (Sleep mode), Exit Delay = TIOBST (5). None (Sleep mode), Clock Ready Status Bit (OSCCON) = IOFS\nNote 1: In this instance, refers specifically to the 31 kHz INTRC clock source.\n2: TCSD (parameter 38) is a required delay when waking from Sleep and all Idle modes and runs concurrently with any other required delays (see Section 3.4 GLYPH<147>Idle ModesGLYPH<148> ).\n3: Includes both the INTOSC 8 MHz source and postscaler derived frequencies.\n4: TOST is the Oscillator Start-up Timer (parameter 32). t rc  is the PLL Lock-out Timer (parameter F12); it is also designated as TPLL.\n5: Execution continues during TIOBST (parameter 39), the INTOSC stabilization period.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "4.0 RESET\nThe PIC18F6390/6490/8390/8490 devices differentiate between various kinds of Reset:\na) Power-on Reset (POR)\nb) MCLR Reset during normal operation\nc) MCLR Reset during power-managed modes\nd) Watchdog Timer (WDT) Reset (during execution)\ne) Programmable Brown-out Reset (BOR)\nf) RESET Instruction\ng) Stack Full Reset\nh) Stack Underflow Reset\nThis  section  discusses  Resets  generated  by  MCLR, POR and BOR and covers the operation of the various start-up  timers.  Stack  Reset  events  are  covered  in Section 5.1.2.4 GLYPH<147>Stack Full and Underflow ResetsGLYPH<148> . WDT Resets are covered in Section 23.2 GLYPH<147>Watchdog Timer (WDT)GLYPH<148> .",
    "4.1 RCON Register\nDevice Reset events are tracked through the RCON register (Register 4-1). The  lower  five  bits  of the register indicate that a specific Reset  event  has occurred. In most cases, these bits can only be set by the event and must be cleared by the application after the event. The state of these flag bits, taken together, can  be  read  to  indicate  the  type  of  Reset  that  just occurred. This is described in more detail in Section 4.6 GLYPH<147>Reset State of RegistersGLYPH<148> .\nThe  RCON  register  also  has  control  bits  for  setting interrupt  priority  (IPEN)  and  software  control  of  the BOR  (SBOREN).  Interrupt  priority  is  discussed  in Section 8.0 GLYPH<147>InterruptsGLYPH<148> . BOR is covered in Section 4.4 GLYPH<147>Brown-out Reset (BOR)GLYPH<148> .\nA simplified block diagram of the on-chip Reset circuit is shown in Figure 4-1.",
    "FIGURE 4-1: SIMPLIFIED BLOCK DIAGRAM OF ON-CHIP RESET CIRCUIT\nNote 1: This is the INTRC source from the internal oscillator block and is separate from the RC oscillator of the CLKI pin.\n- 2: See Table 4-2 for time-out situations.",
    "REGISTER 4-1: RCON: RESET CONTROL REGISTER\nIPEN, R/W-1 (1) = SBOREN. IPEN, U-0 = GLYPH<151>. IPEN, R/W-1 = RI. IPEN, R-1 = TO. IPEN, R-1 = PD. IPEN, R/W-0 = POR. IPEN, R/W-0 = BOR. bit 7, R/W-1 (1) = . bit 7, U-0 = . bit 7, R/W-1 = . bit 7, R-1 = . bit 7, R-1 = . bit 7, R/W-0 = . bit 7, R/W-0 = bit 0",
    "REGISTER 4-1: RCON: RESET CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145>1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 IPEN:\nInterrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16CXXX Compatibility mode)\nbit 6\nSBOREN: BOR Software Enable bit (1)\nIf BOREN1:BOREN0 = 01 :\n1 = BOR is enabled\n0 = BOR is disabled\nIf BOREN1:BOREN0 = 00 10 , or 11 :\nBit is disabled and read as GLYPH<145> 0 GLYPH<146>.",
    "bit 5 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 4\nRI: RESET Instruction Flag bit\n1 = The RESET instruction was not executed (set by firmware only)\n0 = The RESET instruction was executed causing a device Reset (must be set in software after a Brown-out Reset occurs)",
    "bit 3 TO:\nWatchdog Time-out Flag bit\n1 = Set by power-up, CLRWDT instruction or SLEEP instruction\n0 = A WDT time-out occurred",
    "bit 2 PD:\nPower-Down Detection Flag bit\n1 = Set by power-up or by the CLRWDT instruction\n0 = Set by execution of the SLEEP instruction",
    "bit 1 POR: Power-on Reset Status bit\n1 = A Power-on Reset has not occurred (set by firmware only)\n0 = A Power-on Reset occurred (must be set in software after a Power-on Reset occurs)\nbit 0\nBOR: Brown-out Reset Status bit\n1 = A Brown-out Reset has not occurred (set by firmware only)\n0 = A Brown-out Reset occurred (must be set in software after a Brown-out Reset occurs)",
    "Note 1: If SBOREN is enabled, its Reset state is GLYPH<145> 1 GLYPH<146>; otherwise, it is GLYPH<145> 0 GLYPH<146>.\nNote 1: It is recommended that the POR bit be set after a Power-on Reset has been detected, so that subsequent Power-on Resets may be detected.\n2: Brown-out Reset is said to have occurred when BOR is GLYPH<145> 0 GLYPH<146> and POR is GLYPH<145> 1 GLYPH<146>  (assuming that POR was set to GLYPH<145> 1 GLYPH<146>  by software immediately after a Power-on Reset).",
    "4.2 Master Clear (MCLR)\nThe MCLR pin provides a method for triggering a hard external Reset of the device. A Reset is generated by holding  the  pin  low.  PIC18  Extended  MCU  devices have  a  noise  filter  in  the  MCLR  Reset  path  which detects and ignores small pulses.\nThe MCLR pin is not driven low by any internal Resets, including the WDT.\nIn  PIC18F6390/6490/8390/8490  devices,  the  MCLR input can be disabled with the MCLRE Configuration bit. When MCLR is disabled, the pin becomes a digital input.  See Section 9.7  GLYPH<147>PORTG,  TRISG  and  LATG RegistersGLYPH<148> for more information.",
    "4.3 Power-on Reset (POR)\nA Power-on Reset pulse is generated on-chip whenever  VDD  rises  above  a  certain  threshold.  This allows the device to start in the initialized state when VDD is adequate for operation.\nTo take advantage of the POR circuitry, tie the MCLR pin through a resistor (1 k \u03a9 to 10 k \u03a9 ) to VDD. This will eliminate external RC components usually needed to create a Power-on Reset delay. A minimum rise rate for VDD  is  specified  (parameter  D004).  For  a  slow  rise time, see Figure 4-2.\nWhen the device starts normal operation (i.e., exits the Reset condition), device operating parameters (voltage, frequency, temperature, etc.) must be met to ensure operation. If these conditions are not met, the device  must  be  held  in  Reset  until  the  operating conditions are met.",
    "4.3 Power-on Reset (POR)\nPOR events are captured by the POR bit (RCON<1>). The state of the bit is set to GLYPH<145> 0 GLYPH<146> whenever a Power-on Reset occurs; it does not change for any other Reset event. POR is not reset to GLYPH<145> 1 GLYPH<146> by any hardware event. To capture multiple events, the  user  manually  resets the bit to GLYPH<145> 1 GLYPH<146>  in  software following any Power-on Reset.\nFIGURE 4-2:\nEXTERNAL POWER-ON RESET CIRCUIT (FOR SLOW VDD POWER-UP)",
    "4.3 Power-on Reset (POR)\nNote 1: External  Power-on  Reset  circuit  is  required only  if  the  VDD  power-up  slope is too  slow. The  diode  D  helps  discharge  the  capacitor quickly when VDD powers down.\n2: R < 40 k \u03a9 is recommended to make sure that the  voltage  drop  across  R  does  not  violate the deviceGLYPH<146>s electrical specification.\n3: R1 \u2265 1  k \u03a9 will  limit  any  current  flowing into MCLR from external capacitor C, in the event of MCLR/VPP pin breakdown, due to Electrostatic  Discharge  (ESD)  or  Electrical Overstress (EOS).",
    "4.4 Brown-out Reset (BOR)\nPIC18F6390/6490/8390/8490 devices implement a BOR  circuit  that  provides  the  user  with  a  number  of configuration  and  power-saving  options.  The  BOR  is controlled by the BORV1:BORV0 and BOREN1:BOREN0 Configuration bits. There are a total of  four  BOR  configurations,  which  are  summarized  in Table 4-1.\nPlacing the BOR under software control gives the user the additional flexibility of tailoring the application to its environment without having to reprogram the device to change the BOR configuration. It also allows the user to  tailor  device  power  consumption  in  software  by eliminating the incremental current that the BOR consumes.  While  the  BOR  current  is  typically  very small, it may have some impact in low-power applications.",
    "4.4 Brown-out Reset (BOR)\nThe BOR threshold is set by the BORV1:BORV0 bits. If BOR  is  enabled  (any  values  of  BOREN1:BOREN0 except GLYPH<145> 00 GLYPH<146>),  any drop of VDD below VBOR (parameter D005) for greater than TBOR (parameter 35) will reset the device. A Reset may or may not occur if VDD falls below VBOR for less than TBOR. The chip will remain in Brown-out Reset until VDD rises above VBOR.\nIf the Power-up Timer is enabled, it will be invoked after VDD  rises  above  VBOR;  it  then  will  keep  the  chip  in Reset for an additional time delay, TPWRT (parameter 33).  If  VDD  drops  below  VBOR  while  the Power-up Timer is running, the chip will go back into a Brown-out  Reset  and  the  Power-up  Timer  will  be initialized. Once VDD rises above VBOR, the Power-up Timer will execute the additional time delay.",
    "4.4 Brown-out Reset (BOR)\nBOR and the Power-up Timer (PWRT) are independently  configured.  Enabling  the  BOR  Reset does not automatically enable the PWRT.",
    "4.4.1 SOFTWARE ENABLED BOR\nWhen  BOREN1:BOREN0  = 01 , the  BOR  can  be enabled  or  disabled  by  the  user  in  software.  This  is done  with the control bit, SBOREN  (RCON<6>). Setting  SBOREN  enables  the  BOR  to  function  as previously described. Clearing SBOREN disables the BOR entirely.  The  SBOREN bit operates only in this mode; otherwise it is read as GLYPH<145> 0 GLYPH<146> .",
    "Note:\nEven when BOR is under software control, the BOR Reset voltage level is still set by the  BORV1:BORV0 Configuration bits.  It cannot be changed in software.",
    "4.4.2 DETECTING BOR\nWhen BOR is enabled, the BOR bit always resets to GLYPH<145> 0 GLYPH<146> on any BOR or POR event. This makes it difficult to determine if a BOR event has occurred just by reading the state of BOR alone. A more reliable method is to simultaneously check the state of both POR and BOR. This assumes that the POR bit is reset to GLYPH<145> 1 GLYPH<146> in software immediately after any POR event. IF BOR is GLYPH<145> 0 GLYPH<146> while POR is GLYPH<145> 1 GLYPH<146>,  it  can be reliably assumed that a BOR event has occurred.",
    "4.4.3 DISABLING BOR IN SLEEP MODE\nWhen  BOREN1:BOREN0  = 10 , the  BOR  remains under  hardware  control  and  operates  as  previously described. Whenever the device enters Sleep mode, however, the BOR is automatically disabled. When the device  returns  to  any  other  operating  mode,  BOR  is automatically re-enabled.\nThis  mode  allows  for  applications  to  recover  from brown-out  situations  while  actively  executing  code, when the device requires BOR protection the most. At the same time, it saves additional power in Sleep mode by eliminating the small incremental BOR current.",
    "4.4.3 DISABLING BOR IN SLEEP MODE\nTABLE 4-1: BOR CONFIGURATIONS\n\n0, BOR Configuration.BOREN0 = 0. 0, Status of SBOREN.(RCON<6>) = Unavailable. 0, BOR Operation = BOR is disabled; must be enabled by reprogramming the Configuration bits.. 0, BOR Configuration.BOREN0 = 1. 0, Status of SBOREN.(RCON<6>) = Available. 0, BOR Operation = BOR is enabled in software; operation controlled by SBOREN.. 1, BOR Configuration.BOREN0 = 0. 1, Status of SBOREN.(RCON<6>) = Unavailable. 1, BOR Operation = BOR is enabled in hardware and active during the Run and Idle modes, disabled during Sleep mode.. 1, BOR Configuration.BOREN0 = 1. 1, Status of SBOREN.(RCON<6>) = Unavailable. 1, BOR Operation = BOR is enabled in hardware; must be disabled by reprogramming the Configuration bits.",
    "4.5 Device Reset Timers\nPIC18F6390/6490/8390/8490 devices incorporate three  separate  on-chip  timers  that  help  regulate  the Power-on  Reset  process.  Their  main  function  is  to ensure that the device clock is stable before code is executed. These timers are:\nGLYPH<149> Power-up Timer (PWRT)\nGLYPH<149> Oscillator Start-up Timer (OST)\nGLYPH<149> PLL Lock Time-out",
    "4.5.1 POWER-UP TIMER (PWRT)\nThe Power-up Timer (PWRT) of PIC18F6390/6490/8390/8490 devices is an 11-bit counter  which  uses  the  INTRC  source  as  the  clock input.  This  yields  an  approximate  time  interval  of 2048 x 32 \u03bc s = 65.6 ms. While the PWRT is counting, the device is held in Reset.\nThe power-up time delay depends on the INTRC clock and will vary from chip-to-chip due to temperature and process variation. See DC parameter 33 for details.\nThe  PWRT  is  enabled  by  clearing  the  PWRTEN Configuration bit.",
    "4.5.2 OSCILLATOR START-UP TIMER (OST)\nThe Oscillator Start-up Timer (OST) provides a 1024 oscillator cycle (from OSC1 input) delay after the PWRT delay is over (parameter 33). This ensures that the  crystal  oscillator  or  resonator  has  started  and  is stabilized.\nThe OST time-out is invoked only for XT, LP, HS and HSPLL modes and only on Power-on Reset, or on exit from most power-managed modes.",
    "TABLE 4-2: TIME-OUT IN VARIOUS SITUATIONS\nHSPLL, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1) + 1024 TOSC + 2 ms (2). HSPLL, Power-up (2) and Brown-out.PWRTEN = 1 = 1024 TOSC + 2 ms (2). HSPLL, Exit from Power-Managed Mode. = 1024 TOSC + 2 ms (2). HS, XT, LP, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1) + 1024 TOSC. HS, XT, LP, Power-up (2) and Brown-out.PWRTEN = 1 = 1024 TOSC. HS, XT, LP, Exit from Power-Managed Mode. = 1024 TOSC. EC, ECIO, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1). EC, ECIO, Power-up (2) and Brown-out.PWRTEN = 1 = GLYPH<151>. EC, ECIO, Exit from Power-Managed",
    "TABLE 4-2: TIME-OUT IN VARIOUS SITUATIONS\nMode. = GLYPH<151>. RC, RCIO, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1). RC, RCIO, Power-up (2) and Brown-out.PWRTEN = 1 = GLYPH<151>. RC, RCIO, Exit from Power-Managed Mode. = GLYPH<151>. INTIO1, INTIO2, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1). INTIO1, INTIO2, Power-up (2) and Brown-out.PWRTEN = 1 = GLYPH<151>. INTIO1, INTIO2, Exit from Power-Managed Mode. = GLYPH<151>\nNote 1: 66 ms (65.5 ms) is the nominal Power-up Timer (PWRT) delay.\n- 2: 2 ms is the nominal time required for the PLL to lock.",
    "4.5.3 PLL LOCK TIME-OUT\nWith  the  PLL  enabled  in  its  PLL  mode,  the  time-out sequence  following a Power-on  Reset  is slightly different from other oscillator modes. A separate timer is used to provide a fixed time-out that is sufficient for the PLL to lock to the main oscillator frequency. This PLL lock time-out (TPLL) is typically 2 ms and follows the oscillator start-up time-out.",
    "4.5.4 TIME-OUT SEQUENCE\nOn power-up, the time-out sequence is as follows:\n1. After the POR  pulse has cleared, PWRT time-out is invoked (if enabled).\n2. Then, the OST is activated.\nThe total time-out will vary based on oscillator configuration and the status of the PWRT. Figure 4-3, Figure 4-4,  Figure 4-5,  Figure 4-6  and  Figure 4-7  all depict  time-out  sequences  on  power-up,  with  the Power-up Timer enabled and the device operating in HS Oscillator mode. Figures 4-3 through 4-6 also apply to devices operating in XT or LP modes. For devices in RC mode and with the PWRT disabled, on the other hand, there will be no time-out at all.\nSince the time-outs occur from the POR pulse, if MCLR is kept  low  long  enough,  all  time-outs  will  expire. Bringing MCLR high will begin execution immediately (Figure 4-5). This is useful for testing purposes, or to synchronize more  than one PIC18FXXXX  device operating in parallel.",
    "FIGURE 4-3: TIME-OUT SEQUENCE ON POWER-UP (MCLR TIED TO VDD, VDD RISE < TPWRT)\nTPWRT\nTOST\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET",
    "TIME-OUT SEQUENCE ON POR w/PLL ENABLED (MCLR TIED TO VDD)\nNote:\nTOST = 1024 clock cycles.\nTPLL \u2248 2 ms max. First three stages of the PWRT timer.",
    "4.6 Reset State of Registers\nMost registers are unaffected by a Reset. Their status is unknown  on  POR  and  unchanged  by  all  other Resets.  The  other  registers  are  forced  to  a  GLYPH<147>Reset stateGLYPH<148> depending on the type of Reset that occurred.\nTable 4-4  describes  the  Reset  states  for  all  of  the Special Function Registers. These are categorized by Power-on  and  Brown-out  Resets,  Master  Clear  and WDT Resets and WDT wake-ups.\nMost  registers  are  not  affected  by  a  WDT  wake-up, since  this  is  viewed  as  the  resumption  of  normal operation. Status bits from the RCON register, RI, TO, PD,  POR and  BOR,  are  set  or  cleared  differently  in different  Reset  situations,  as  indicated  in  Table 4-3. These bits are used in software to determine the nature of the Reset.",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nPower-on Reset, Program Counter.Program Counter = 0000h. Power-on Reset, RCON Register.SBOREN = 1. Power-on Reset, RCON Register.RI = 1. Power-on Reset, RCON Register.TO = 1. Power-on Reset, RCON Register.PD = 1. Power-on Reset, RCON Register.POR = 0. Power-on Reset, RCON Register.BOR = 0. Power-on Reset, STKPTR Register.STKFUL = 0. Power-on Reset, STKPTR Register.STKUNF = 0. RESET Instruction, Program Counter.Program Counter = 0000h. RESET Instruction, RCON Register.SBOREN = u (2). RESET Instruction, RCON Register.RI = 0. RESET Instruction, RCON Register.TO = u. RESET Instruction, RCON Register.PD = u. RESET Instruction, RCON Register.POR = u. RESET Instruction, RCON Register.BOR = u. RESET Instruction, STKPTR Register.STKFUL = u. RESET Instruction,",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nSTKPTR Register.STKUNF = u. Brown-out Reset, Program Counter.Program Counter = 0000h. Brown-out Reset, RCON Register.SBOREN = u (2). Brown-out Reset, RCON Register.RI = 1. Brown-out Reset, RCON Register.TO = 1. Brown-out Reset, RCON Register.PD = 1. Brown-out Reset, RCON Register.POR = u. Brown-out Reset, RCON Register.BOR = 0. Brown-out Reset, STKPTR Register.STKFUL = u. Brown-out Reset, STKPTR Register.STKUNF = u. MCLR Reset during power-managed Run modes, Program Counter.Program Counter = 0000h. MCLR Reset during power-managed Run modes, RCON Register.SBOREN = u (2). MCLR Reset during power-managed Run modes, RCON Register.RI = u. MCLR Reset during power-managed Run modes, RCON Register.TO = 1. MCLR Reset during power-managed Run modes,",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nRCON Register.PD = u. MCLR Reset during power-managed Run modes, RCON Register.POR = u. MCLR Reset during power-managed Run modes, RCON Register.BOR = u. MCLR Reset during power-managed Run modes, STKPTR Register.STKFUL = u. MCLR Reset during power-managed Run modes, STKPTR Register.STKUNF = u. MCLR Reset during power-managed Idle modes and Sleep, Program Counter.Program Counter = 0000h. MCLR Reset during power-managed Idle modes and Sleep, RCON Register.SBOREN = u (2). MCLR Reset during power-managed Idle modes and Sleep, RCON Register.RI = u. MCLR Reset during power-managed Idle modes and Sleep, RCON Register.TO = 1. MCLR Reset during power-managed Idle modes and Sleep, RCON Register.PD = 0. MCLR Reset during power-managed Idle modes and Sleep, RCON Register.POR = u. MCLR Reset during power-managed Idle modes and Sleep, RCON Register.BOR =",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nu. MCLR Reset during power-managed Idle modes and Sleep, STKPTR Register.STKFUL = u. MCLR Reset during power-managed Idle modes and Sleep, STKPTR Register.STKUNF = u. WDT time-out during full power or power-managed Run modes, Program Counter.Program Counter = 0000h. WDT time-out during full power or power-managed Run modes, RCON Register.SBOREN = u (2). WDT time-out during full power or power-managed Run modes, RCON Register.RI = u. WDT time-out during full power or power-managed Run modes, RCON Register.TO = 0. WDT time-out during full power or power-managed Run modes, RCON Register.PD = u. WDT time-out during full power or power-managed Run modes, RCON Register.POR = u. WDT time-out during full power or power-managed Run modes, RCON Register.BOR = u. WDT time-out during full power or power-managed Run modes,",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nSTKPTR Register.STKFUL = u. WDT time-out during full power or power-managed Run modes, STKPTR Register.STKUNF = u. MCLR during full-power execution, Program Counter.Program Counter = 0000h. MCLR during full-power execution, RCON Register.SBOREN = u (2). MCLR during full-power execution, RCON Register.RI = u. MCLR during full-power execution, RCON Register.TO = u. MCLR during full-power execution, RCON Register.PD = u. MCLR during full-power execution, RCON Register.POR = u. MCLR during full-power execution, RCON Register.BOR = u. MCLR during full-power execution, STKPTR Register.STKFUL = u. MCLR during full-power execution, STKPTR Register.STKUNF = u. Stack Full Reset (STVREN = 1 ), Program Counter.Program Counter = 0000h. Stack Full Reset (STVREN = 1 ), RCON",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nRegister.SBOREN = u (2). Stack Full Reset (STVREN = 1 ), RCON Register.RI = u. Stack Full Reset (STVREN = 1 ), RCON Register.TO = u. Stack Full Reset (STVREN = 1 ), RCON Register.PD = u. Stack Full Reset (STVREN = 1 ), RCON Register.POR = u. Stack Full Reset (STVREN = 1 ), RCON Register.BOR = u. Stack Full Reset (STVREN = 1 ), STKPTR Register.STKFUL = 1. Stack Full Reset (STVREN = 1 ), STKPTR Register.STKUNF = u. Stack Underflow Reset (STVREN = 1 ), Program Counter.Program Counter = 0000h. Stack Underflow Reset (STVREN = 1 ), RCON Register.SBOREN = u (2). Stack Underflow Reset (STVREN = 1 ), RCON Register.RI = u. Stack Underflow Reset (STVREN = 1 ), RCON",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nRegister.TO = u. Stack Underflow Reset (STVREN = 1 ), RCON Register.PD = u. Stack Underflow Reset (STVREN = 1 ), RCON Register.POR = u. Stack Underflow Reset (STVREN = 1 ), RCON Register.BOR = u. Stack Underflow Reset (STVREN = 1 ), STKPTR Register.STKFUL = u. Stack Underflow Reset (STVREN = 1 ), STKPTR Register.STKUNF = 1. Stack Underflow Error (not an actual Reset, STVREN = 0 ), Program Counter.Program Counter = 0000h. Stack Underflow Error (not an actual Reset, STVREN = 0 ), RCON Register.SBOREN = u (2). Stack Underflow Error (not an actual Reset, STVREN = 0 ), RCON Register.RI = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), RCON Register.TO = u. Stack Underflow Error (not an actual Reset, STVREN =",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n0 ), RCON Register.PD = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), RCON Register.POR = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), RCON Register.BOR = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), STKPTR Register.STKFUL = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), STKPTR Register.STKUNF = 1. WDT time-out during power-managed Idle or Sleep modes, Program Counter.Program Counter = PC + 2 (1). WDT time-out during power-managed Idle or Sleep modes, RCON Register.SBOREN = u (2). WDT time-out during power-managed Idle or Sleep modes, RCON Register.RI = u. WDT time-out during power-managed Idle or Sleep modes, RCON Register.TO = 0. WDT time-out during power-managed Idle or Sleep modes, RCON",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nRegister.PD = 0. WDT time-out during power-managed Idle or Sleep modes, RCON Register.POR = u. WDT time-out during power-managed Idle or Sleep modes, RCON Register.BOR = u. WDT time-out during power-managed Idle or Sleep modes, STKPTR Register.STKFUL = u. WDT time-out during power-managed Idle or Sleep modes, STKPTR Register.STKUNF = u. Interrupt exit from power-managed modes, Program Counter.Program Counter = PC + 2 (1). Interrupt exit from power-managed modes, RCON Register.SBOREN = u (2). Interrupt exit from power-managed modes, RCON Register.RI = u. Interrupt exit from power-managed modes, RCON Register.TO = u. Interrupt exit from power-managed modes, RCON Register.PD = 0. Interrupt exit from power-managed modes, RCON Register.POR = u. Interrupt exit from power-managed modes, RCON Register.BOR = u. Interrupt exit from power-managed modes,",
    "TABLE 4-3: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nSTKPTR Register.STKFUL = u. Interrupt exit from power-managed modes, STKPTR Register.STKUNF = u\nLegend:\nu = unchanged\nNote\n1: When the wake-up is due to an interrupt and the GIEH or GIEL bits are set, the PC is loaded with the interrupt vector (008h or 0018h).\n2: Reset state is GLYPH<145> 1 GLYPH<146>  for POR and unchanged for all other Resets when software BOR is enabled (BOREN1:BOREN0 Configuration bits = 01 and SBOREN = 1 ); otherwise, the Reset state is GLYPH<145> 0 GLYPH<146>.",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTOSU, Applicable Devices = 6X90 8X90. TOSU, Power-on Reset, Brown-out Reset = ---0 0000. TOSU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. TOSU, Wake-up via WDT or Interrupt = ---0 uuuu (3). TOSH, Applicable Devices = 6X90 8X90. TOSH, Power-on Reset, Brown-out Reset = 0000 0000. TOSH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSH, Wake-up via WDT or Interrupt = uuuu uuuu (3). TOSL, Applicable Devices = 6X90 8X90. TOSL, Power-on Reset, Brown-out Reset = 0000 0000. TOSL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSL, Wake-up via WDT or Interrupt = uuuu uuuu (3). STKPTR, Applicable Devices = 6X90 8X90.",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nSTKPTR, Power-on Reset, Brown-out Reset = 00-0 0000. STKPTR, MCLR Resets WDT Reset RESET Instruction Stack Resets = 00-0 0000. STKPTR, Wake-up via WDT or Interrupt = uu-u uuuu (3). PCLATU, Applicable Devices = 6X90 8X90. PCLATU, Power-on Reset, Brown-out Reset = ---0 0000. PCLATU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. PCLATU, Wake-up via WDT or Interrupt = ---u uuuu. PCLATH, Applicable Devices = 6X90 8X90. PCLATH, Power-on Reset, Brown-out Reset = 0000 0000. PCLATH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PCLATH, Wake-up via WDT or Interrupt = uuuu uuuu. PCL, Applicable Devices = 6X90 8X90. PCL, Power-on Reset,",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nBrown-out Reset = 0000 0000. PCL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PCL, Wake-up via WDT or Interrupt = PC + 2 (2). TBLPTRU, Applicable Devices = 6X90 8X90. TBLPTRU, Power-on Reset, Brown-out Reset = --00 0000. TBLPTRU, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. TBLPTRU, Wake-up via WDT or Interrupt = --uu uuuu. TBLPTRH, Applicable Devices = 6X90 8X90. TBLPTRH, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRH, Wake-up via WDT or Interrupt = uuuu uuuu. TBLPTRL, Applicable Devices = 6X90 8X90. TBLPTRL, Power-on Reset, Brown-out Reset = 0000 0000.",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTBLPTRL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRL, Wake-up via WDT or Interrupt = uuuu uuuu. TABLAT, Applicable Devices = 6X90 8X90. TABLAT, Power-on Reset, Brown-out Reset = 0000 0000. TABLAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TABLAT, Wake-up via WDT or Interrupt = uuuu uuuu. PRODH, Applicable Devices = 6X90 8X90. PRODH, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PRODH, Wake-up via WDT or Interrupt = uuuu uuuu. PRODL, Applicable Devices = 6X90 8X90. PRODL, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nuuuu. PRODL, Wake-up via WDT or Interrupt = uuuu uuuu. INTCON, Applicable Devices = 6X90 8X90. INTCON, Power-on Reset, Brown-out Reset = 0000 000x. INTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000u. INTCON, Wake-up via WDT or Interrupt = uuuu uuuu (1). INTCON2, Applicable Devices = 6X90 8X90. INTCON2, Power-on Reset, Brown-out Reset = 1111 1111. INTCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. INTCON2, Wake-up via WDT or Interrupt = uuuu uuuu (1). INTCON3, Applicable Devices = 6X90 8X90. INTCON3, Power-on Reset, Brown-out Reset = 1100 0000. INTCON3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1100 0000. INTCON3, Wake-up via WDT or Interrupt =",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nuuuu uuuu (1). INDF0, Applicable Devices = 6X90 8X90. INDF0, Power-on Reset, Brown-out Reset = N/A. INDF0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF0, Wake-up via WDT or Interrupt = N/A. POSTINC0, Applicable Devices = 6X90 8X90. POSTINC0, Power-on Reset, Brown-out Reset = N/A. POSTINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC0, Wake-up via WDT or Interrupt = N/A. POSTDEC0, Applicable Devices = 6X90 8X90. POSTDEC0, Power-on Reset, Brown-out Reset = N/A. POSTDEC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC0, Wake-up via WDT or Interrupt = N/A. PREINC0, Applicable Devices = 6X90 8X90. PREINC0,",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPower-on Reset, Brown-out Reset = N/A. PREINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC0, Wake-up via WDT or Interrupt = N/A. PLUSW0, Applicable Devices = 6X90 8X90. PLUSW0, Power-on Reset, Brown-out Reset = N/A. PLUSW0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW0, Wake-up via WDT or Interrupt = N/A. FSR0H, Applicable Devices = 6X90 8X90. FSR0H, Power-on Reset, Brown-out Reset = ---- xxxx. FSR0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR0H, Wake-up via WDT or Interrupt = ---- uuuu. FSR0L, Applicable Devices = 6X90 8X90. FSR0L, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nFSR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR0L, Wake-up via WDT or Interrupt = uuuu uuuu. WREG, Applicable Devices = 6X90 8X90. WREG, Power-on Reset, Brown-out Reset = xxxx xxxx. WREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. WREG, Wake-up via WDT or Interrupt = uuuu uuuu. INDF1, Applicable Devices = 6X90 8X90. INDF1, Power-on Reset, Brown-out Reset = N/A. INDF1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF1, Wake-up via WDT or Interrupt = N/A. POSTINC1, Applicable Devices = 6X90 8X90. POSTINC1, Power-on Reset, Brown-out Reset = N/A. POSTINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nN/A. POSTINC1, Wake-up via WDT or Interrupt = N/A. POSTDEC1, Applicable Devices = 6X90 8X90. POSTDEC1, Power-on Reset, Brown-out Reset = N/A. POSTDEC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC1, Wake-up via WDT or Interrupt = N/A. PREINC1, Applicable Devices = 6X90 8X90. PREINC1, Power-on Reset, Brown-out Reset = N/A. PREINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC1, Wake-up via WDT or Interrupt = N/A. PLUSW1, Applicable Devices = 6X90 8X90. PLUSW1, Power-on Reset, Brown-out Reset = N/A. PLUSW1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW1, Wake-up via WDT or Interrupt = N/A",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as GLYPH<145> 0 GLYPH<146>, q = value depends on condition.\nShaded cells indicate conditions do not apply for the designated device.\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).",
    "INITIALIZATION CONDITIONS FOR ALL REGISTERS\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read GLYPH<145> 0 GLYPH<146>.\n6: These registers are cleared on POR and unchanged on BOR.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFSR1H, Applicable Devices = 6X90 8X90. FSR1H, Power-on Reset, Brown-out Reset = ---- xxxx. FSR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR1H, Wake-up via WDT or Interrupt = ---- uuuu. FSR1L, Applicable Devices = 6X90 8X90. FSR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR1L, Wake-up via WDT or Interrupt = uuuu uuuu. BSR, Applicable Devices = 6X90 8X90. BSR, Power-on Reset, Brown-out Reset = ---- 0000. BSR, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. BSR, Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n---- uuuu. INDF2, Applicable Devices = 6X90 8X90. INDF2, Power-on Reset, Brown-out Reset = N/A. INDF2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF2, Wake-up via WDT or Interrupt = N/A. POSTINC2, Applicable Devices = 6X90 8X90. POSTINC2, Power-on Reset, Brown-out Reset = N/A. POSTINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC2, Wake-up via WDT or Interrupt = N/A. POSTDEC2, Applicable Devices = 6X90 8X90. POSTDEC2, Power-on Reset, Brown-out Reset = N/A. POSTDEC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC2, Wake-up via WDT or Interrupt = N/A. PREINC2, Applicable Devices = 6X90 8X90.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPREINC2, Power-on Reset, Brown-out Reset = N/A. PREINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC2, Wake-up via WDT or Interrupt = N/A. PLUSW2, Applicable Devices = 6X90 8X90. PLUSW2, Power-on Reset, Brown-out Reset = N/A. PLUSW2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW2, Wake-up via WDT or Interrupt = N/A. FSR2H, Applicable Devices = 6X90 8X90. FSR2H, Power-on Reset, Brown-out Reset = ---- xxxx. FSR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR2H, Wake-up via WDT or Interrupt = ---- uuuu. FSR2L, Applicable Devices = 6X90 8X90. FSR2L, Power-on Reset,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = xxxx xxxx. FSR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR2L, Wake-up via WDT or Interrupt = uuuu uuuu. STATUS, Applicable Devices = 6X90 8X90. STATUS, Power-on Reset, Brown-out Reset = ---x xxxx. STATUS, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---u uuuu. STATUS, Wake-up via WDT or Interrupt = ---u uuuu. TMR0H, Applicable Devices = 6X90 8X90. TMR0H, Power-on Reset, Brown-out Reset = 0000 0000. TMR0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TMR0H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR0L, Applicable Devices = 6X90 8X90. TMR0L,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = xxxx xxxx. TMR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR0L, Wake-up via WDT or Interrupt = uuuu uuuu. T0CON, Applicable Devices = 6X90 8X90. T0CON, Power-on Reset, Brown-out Reset = 1111 1111. T0CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. T0CON, Wake-up via WDT or Interrupt = uuuu uuuu. OSCCON, Applicable Devices = 6X90 8X90. OSCCON, Power-on Reset, Brown-out Reset = 0100 q000. OSCCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0100 00q0. OSCCON, Wake-up via WDT or Interrupt = uuuu uuqu. HLVDCON, Applicable Devices = 6X90 8X90. HLVDCON,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = 0-00 0101. HLVDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0-00 0101. HLVDCON, Wake-up via WDT or Interrupt = u-uu uuuu. WDTCON, Applicable Devices = 6X90 8X90. WDTCON, Power-on Reset, Brown-out Reset = ---- ---0. WDTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- ---0. WDTCON, Wake-up via WDT or Interrupt = ---- ---u. RCON (4), Applicable Devices = 6X90 8X90. RCON (4), Power-on Reset, Brown-out Reset = 0q-1 11q0. RCON (4), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0q-q qquu. RCON (4), Wake-up via WDT or Interrupt = uq-u qquu.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTMR1H, Applicable Devices = 6X90 8X90. TMR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR1L, Applicable Devices = 6X90 8X90. TMR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1L, Wake-up via WDT or Interrupt = uuuu uuuu. T1CON, Applicable Devices = 6X90 8X90. T1CON, Power-on Reset, Brown-out Reset = 0000 0000. T1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = u0uu uuuu. T1CON,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu uuuu. TMR2, Applicable Devices = 6X90 8X90. TMR2, Power-on Reset, Brown-out Reset = 0000 0000. TMR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TMR2, Wake-up via WDT or Interrupt = uuuu uuuu. PR2, Applicable Devices = 6X90 8X90. PR2, Power-on Reset, Brown-out Reset = 1111 1111. PR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. PR2, Wake-up via WDT or Interrupt = 1111 1111. T2CON, Applicable Devices = 6X90 8X90. T2CON, Power-on Reset, Brown-out Reset = -000 0000. T2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. T2CON, Wake-up via WDT or Interrupt = -uuu",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. SSPBUF, Applicable Devices = 6X90 8X90. SSPBUF, Power-on Reset, Brown-out Reset = xxxx xxxx. SSPBUF, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. SSPBUF, Wake-up via WDT or Interrupt = uuuu uuuu. SSPADD, Applicable Devices = 6X90 8X90. SSPADD, Power-on Reset, Brown-out Reset = 0000 0000. SSPADD, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPADD, Wake-up via WDT or Interrupt = uuuu uuuu. SSPSTAT, Applicable Devices = 6X90 8X90. SSPSTAT, Power-on Reset, Brown-out Reset = 0000 0000. SSPSTAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPSTAT, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. SSPCON1, Applicable Devices = 6X90 8X90. SSPCON1, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPCON1, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON2, Applicable Devices = 6X90 8X90. SSPCON2, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPCON2, Wake-up via WDT or Interrupt = uuuu uuuu\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as GLYPH<145> 0 GLYPH<146>, q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read GLYPH<145> 0 GLYPH<146>.\n6: These registers are cleared on POR and unchanged on BOR.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADRESH, Applicable Devices = 6X90. ADRESH, Applicable Devices = 8X90. ADRESH, Power-on Reset, Brown-out Reset = xxxx xxxx. ADRESH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. ADRESH, Wake-up via WDT or Interrupt = uuuu uuuu. ADRESL, Applicable Devices = 6X90. ADRESL, Applicable Devices = 8X90. ADRESL, Power-on Reset, Brown-out Reset = xxxx xxxx. ADRESL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. ADRESL, Wake-up via WDT or Interrupt = uuuu uuuu. ADCON0, Applicable Devices = 6X90. ADCON0, Applicable Devices = 8X90. ADCON0, Power-on Reset, Brown-out Reset = --00 0000. ADCON0, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. ADCON0,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = --uu uuuu. ADCON1, Applicable Devices = 6X90. ADCON1, Applicable Devices = 8X90. ADCON1, Power-on Reset, Brown-out Reset = --00 0000. ADCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. ADCON1, Wake-up via WDT or Interrupt = --uu uuuu. ADCON2, Applicable Devices = 6X90. ADCON2, Applicable Devices = 8X90. ADCON2, Power-on Reset, Brown-out Reset = 0-00 0000. ADCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0-00 0000. ADCON2, Wake-up via WDT or Interrupt = u-uu uuuu. CCPR1H, Applicable Devices = 6X90. CCPR1H, Applicable Devices = 8X90. CCPR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR1H,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR1H, Wake-up via WDT or Interrupt = uuuu uuuu. CCPR1L, Applicable Devices = 6X90. CCPR1L, Applicable Devices = 8X90. CCPR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR1L, Wake-up via WDT or Interrupt = uuuu uuuu. CCP1CON, Applicable Devices = 6X90. CCP1CON, Applicable Devices = 8X90. CCP1CON, Power-on Reset, Brown-out Reset = --00 0000. CCP1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. CCP1CON, Wake-up via WDT or Interrupt = --uu uuuu. CCPR2H, Applicable Devices =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n6X90. CCPR2H, Applicable Devices = 8X90. CCPR2H, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR2H, Wake-up via WDT or Interrupt = uuuu uuuu. CCPR2L, Applicable Devices = 6X90. CCPR2L, Applicable Devices = 8X90. CCPR2L, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR2L, Wake-up via WDT or Interrupt = uuuu uuuu. CCP2CON, Applicable Devices = 6X90. CCP2CON, Applicable Devices = 8X90. CCP2CON, Power-on Reset, Brown-out Reset = --00 0000. CCP2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= --00 0000. CCP2CON, Wake-up via WDT or Interrupt = --uu uuuu. CVRCON, Applicable Devices = 6X90. CVRCON, Applicable Devices = 8X90. CVRCON, Power-on Reset, Brown-out Reset = 000- 0000. CVRCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 000- 0000. CVRCON, Wake-up via WDT or Interrupt = uuu- uuuu. CMCON, Applicable Devices = 6X90. CMCON, Applicable Devices = 8X90. CMCON, Power-on Reset, Brown-out Reset = 0000 0111. CMCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0111. CMCON, Wake-up via WDT or Interrupt = uuuu uuuu. TMR3H, Applicable Devices = 6X90. TMR3H, Applicable Devices = 8X90. TMR3H, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTMR3H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR3H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR3L, Applicable Devices = 6X90. TMR3L, Applicable Devices = 8X90. TMR3L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR3L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR3L, Wake-up via WDT or Interrupt = uuuu uuuu. T3CON, Applicable Devices = 6X90. T3CON, Applicable Devices = 8X90. T3CON, Power-on Reset, Brown-out Reset = 0000 0000. T3CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. T3CON, Wake-up via WDT or Interrupt = uuuu uuuu.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nSPBRG1, Applicable Devices = 6X90. SPBRG1, Applicable Devices = 8X90. SPBRG1, Power-on Reset, Brown-out Reset = 0000 0000. SPBRG1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SPBRG1, Wake-up via WDT or Interrupt = uuuu uuuu. RCREG1, Applicable Devices = 6X90. RCREG1, Applicable Devices = 8X90. RCREG1, Power-on Reset, Brown-out Reset = 0000 0000. RCREG1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. RCREG1, Wake-up via WDT or Interrupt = uuuu uuuu. TXREG1, Applicable Devices = 6X90. TXREG1, Applicable Devices = 8X90. TXREG1, Power-on Reset, Brown-out Reset = 0000 0000. TXREG1, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000 0000. TXREG1, Wake-up via WDT or Interrupt = uuuu uuuu. TXSTA1, Applicable Devices = 6X90. TXSTA1, Applicable Devices = 8X90. TXSTA1, Power-on Reset, Brown-out Reset = 0000 0010. TXSTA1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0010. TXSTA1, Wake-up via WDT or Interrupt = uuuu uuuu. RCSTA1, Applicable Devices = 6X90. RCSTA1, Applicable Devices = 8X90. RCSTA1, Power-on Reset, Brown-out Reset = 0000 000x. RCSTA1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000x. RCSTA1, Wake-up via WDT or Interrupt = uuuu uuuu. IPR3, Applicable Devices = 6X90. IPR3, Applicable Devices = 8X90. IPR3, Power-on Reset, Brown-out Reset = -111 ----.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nIPR3, MCLR Resets WDT Reset RESET Instruction Stack Resets = -111 ----. IPR3, Wake-up via WDT or Interrupt = -uuu ----. PIR3, Applicable Devices = 6X90. PIR3, Applicable Devices = 8X90. PIR3, Power-on Reset, Brown-out Reset = -000 ----. PIR3, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 ----. PIR3, Wake-up via WDT or Interrupt = -uuu ---- (1). PIE3, Applicable Devices = 6X90. PIE3, Applicable Devices = 8X90. PIE3, Power-on Reset, Brown-out Reset = -000 ----. PIE3, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 ----. PIE3, Wake-up via WDT or Interrupt = -uuu ----. IPR2, Applicable Devices = 6X90. IPR2, Applicable Devices =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n8X90. IPR2, Power-on Reset, Brown-out Reset = 11-- 1111. IPR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 11-- 1111. IPR2, Wake-up via WDT or Interrupt = uu-- uuuu. PIR2, Applicable Devices = 6X90. PIR2, Applicable Devices = 8X90. PIR2, Power-on Reset, Brown-out Reset = 00-- 0000. PIR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 00-- 0000. PIR2, Wake-up via WDT or Interrupt = uu-- uuuu (1). PIE2, Applicable Devices = 6X90. PIE2, Applicable Devices = 8X90. PIE2, Power-on Reset, Brown-out Reset = 00-- 0000. PIE2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 00-- 0000. PIE2, Wake-up via WDT or Interrupt = uu-- uuuu.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nIPR1, Applicable Devices = 6X90. IPR1, Applicable Devices = 8X90. IPR1, Power-on Reset, Brown-out Reset = -111 1111. IPR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -111 1111. IPR1, Wake-up via WDT or Interrupt = -uuu uuuu. PIR1, Applicable Devices = 6X90. PIR1, Applicable Devices = 8X90. PIR1, Power-on Reset, Brown-out Reset = -000 0000. PIR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. PIR1, Wake-up via WDT or Interrupt = -uuu uuuu (1). PIE1, Applicable Devices = 6X90. PIE1, Applicable Devices = 8X90. PIE1, Power-on Reset, Brown-out Reset = -000 0000. PIE1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. PIE1, Wake-up via WDT or",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInterrupt = -uuu uuuu. OSCTUNE, Applicable Devices = 6X90. OSCTUNE, Applicable Devices = 8X90. OSCTUNE, Power-on Reset, Brown-out Reset = 00-0 0000. OSCTUNE, MCLR Resets WDT Reset RESET Instruction Stack Resets = 00-0 0000. OSCTUNE, Wake-up via WDT or Interrupt = uu-u uuuu\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as GLYPH<145> 0 GLYPH<146>, q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read GLYPH<145> 0 GLYPH<146>.\n6: These registers are cleared on POR and unchanged on BOR.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTRISJ, Applicable Devices = 6X90 8X90. TRISJ, Power-on Reset, Brown-out Reset = 1111 1111. TRISJ, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISJ, Wake-up via WDT or Interrupt = uuuu uuuu. TRISH, Applicable Devices = 6X90 8X90. TRISH, Power-on Reset, Brown-out Reset = 1111 1111. TRISH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISH, Wake-up via WDT or Interrupt = uuuu uuuu. TRISG, Applicable Devices = 6X90 8X90. TRISG, Power-on Reset, Brown-out Reset = ---1 1111. TRISG, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---1 1111. TRISG, Wake-up via WDT or Interrupt = ---u uuuu. TRISF, Applicable Devices = 6X90 8X90.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTRISF, Power-on Reset, Brown-out Reset = 1111 1111. TRISF, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISF, Wake-up via WDT or Interrupt = uuuu uuuu. TRISE, Applicable Devices = 6X90 8X90. TRISE, Power-on Reset, Brown-out Reset = 1111 ----. TRISE, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 ----. TRISE, Wake-up via WDT or Interrupt = uuuu ----. TRISD, Applicable Devices = 6X90 8X90. TRISD, Power-on Reset, Brown-out Reset = 1111 1111. TRISD, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISD, Wake-up via WDT or Interrupt = uuuu uuuu. TRISC, Applicable Devices = 6X90 8X90. TRISC, Power-on Reset, Brown-out Reset = 1111 1111.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTRISC, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISC, Wake-up via WDT or Interrupt = uuuu uuuu. TRISB, Applicable Devices = 6X90 8X90. TRISB, Power-on Reset, Brown-out Reset = 1111 1111. TRISB, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISB, Wake-up via WDT or Interrupt = uuuu uuuu. TRISA (5), Applicable Devices = 6X90 8X90. TRISA (5), Power-on Reset, Brown-out Reset = 1111 1111 (5). TRISA (5), MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111 (5). TRISA (5), Wake-up via WDT or Interrupt = uuuu uuuu (5). LATJ, Applicable Devices = 6X90 8X90. LATJ, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLATJ, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATJ, Wake-up via WDT or Interrupt = uuuu uuuu. LATH, Applicable Devices = 6X90 8X90. LATH, Power-on Reset, Brown-out Reset = xxxx xxxx. LATH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATH, Wake-up via WDT or Interrupt = uuuu uuuu. LATG, Applicable Devices = 6X90 8X90. LATG, Power-on Reset, Brown-out Reset = ---x xxxx. LATG, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---u uuuu. LATG, Wake-up via WDT or Interrupt = ---u uuuu. LATF, Applicable Devices = 6X90 8X90. LATF, Power-on Reset, Brown-out Reset = xxxx xxxx. LATF,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATF, Wake-up via WDT or Interrupt = uuuu uuuu. LATE, Applicable Devices = 6X90 8X90. LATE, Power-on Reset, Brown-out Reset = xxxx ----. LATE, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu ----. LATE, Wake-up via WDT or Interrupt = uuuu ----. LATD, Applicable Devices = 6X90 8X90. LATD, Power-on Reset, Brown-out Reset = xxxx xxxx. LATD, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATD, Wake-up via WDT or Interrupt = uuuu uuuu. LATC, Applicable Devices = 6X90 8X90. LATC, Power-on Reset, Brown-out Reset = xxxx xxxx. LATC, MCLR Resets WDT Reset RESET Instruction",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nStack Resets = uuuu uuuu. LATC, Wake-up via WDT or Interrupt = uuuu uuuu. LATB, Applicable Devices = 6X90 8X90. LATB, Power-on Reset, Brown-out Reset = xxxx xxxx. LATB, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATB, Wake-up via WDT or Interrupt = uuuu uuuu. LATA (5), Applicable Devices = 6X90 8X90. LATA (5), Power-on Reset, Brown-out Reset = xxxx xxxx (5). LATA (5), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu (5). LATA (5), Wake-up via WDT or Interrupt = uuuu uuuu (5). , Applicable Devices = 6X90 8X90. , Power-on Reset, Brown-out Reset = xxxx xxxx. ,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. , Wake-up via WDT or Interrupt = uuuu uuuu. PORTH, Applicable Devices = . PORTH, Power-on Reset, Brown-out Reset = . PORTH, MCLR Resets WDT Reset RESET Instruction Stack Resets = . PORTH, Wake-up via WDT or Interrupt = . PORTG, Applicable Devices = 6X90 8X90. PORTG, Power-on Reset, Brown-out Reset = --xx xxxx. PORTG, MCLR Resets WDT Reset RESET Instruction Stack Resets = --uu uuuu. PORTG, Wake-up via WDT or Interrupt = --uu uuuu. PORTF, Applicable Devices = 6X90 8X90. PORTF, Power-on Reset, Brown-out Reset = xxxx xxxx. PORTF, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PORTF, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. PORTE, Applicable Devices = 6X90 8X90. PORTE, Power-on Reset, Brown-out Reset = xxxx ----. PORTE, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu ----. PORTE, Wake-up via WDT or Interrupt = uuuu ----. PORTD, Applicable Devices = 6X90 8X90. PORTD, Power-on Reset, Brown-out Reset = xxxx xxxx. PORTD, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PORTD, Wake-up via WDT or Interrupt = uuuu uuuu. PORTC, Applicable Devices = 6X90 8X90. PORTC, Power-on Reset, Brown-out Reset = xxxx xxxx. PORTC, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PORTC, Wake-up via WDT or Interrupt = uuuu uuuu uuuu uuuu.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPORTB, Applicable Devices = 6X90 8X90. PORTB, Power-on Reset, Brown-out Reset = xxxx xxxx. PORTB, MCLR Resets WDT Reset RESET Instruction Stack Resets = . PORTB, Wake-up via WDT or Interrupt = . , Applicable Devices = . , Power-on Reset, Brown-out Reset = . , MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. , Wake-up via WDT or Interrupt = . PORTA (5), Applicable Devices = 6X90 8X90. PORTA (5), Power-on Reset, Brown-out Reset = xx0x 0000. PORTA (5), MCLR Resets WDT Reset RESET Instruction Stack Resets = uu0u 0000 (5). PORTA (5), Wake-up via WDT or Interrupt = uuuu uuuu (5). SPBRGH1, Applicable Devices = 6X90 8X90. SPBRGH1, Power-on Reset, Brown-out Reset = 0000 0000.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nSPBRGH1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SPBRGH1, Wake-up via WDT or Interrupt = uuuu uuuu. BAUDCON1, Applicable Devices = 6X90 8X90. BAUDCON1, Power-on Reset, Brown-out Reset = 01-0 0-00. BAUDCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 01-0 0-00. BAUDCON1, Wake-up via WDT or Interrupt = uu-u u-uu\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as GLYPH<145> 0 GLYPH<146>, q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read GLYPH<145> 0 GLYPH<146>.\n6: These registers are cleared on POR and unchanged on BOR.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLCDDATA23, Applicable Devices = 6X90 8X90. LCDDATA23, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA23, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA23, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA22, Applicable Devices = 6X90 8X90. LCDDATA22, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA22, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA22, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA21, Applicable Devices = 6X90 8X90. LCDDATA21, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA21, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA21, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. LCDDATA20, Applicable Devices = 6X90 8X90. LCDDATA20, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA20, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA20, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA19, Applicable Devices = 6X90 8X90. LCDDATA19, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA19, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA19, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA18, Applicable Devices = 6X90 8X90. LCDDATA18, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA18, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA18, Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. LCDDATA17, Applicable Devices = 6X90 8X90. LCDDATA17, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA17, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA17, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA16, Applicable Devices = 6X90 8X90. LCDDATA16, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA16, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA16, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA15, Applicable Devices = 6X90 8X90. LCDDATA15, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA15, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA15, Wake-up via WDT or Interrupt",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= uuuu uuuu. LCDDATA14, Applicable Devices = 6X90 8X90. LCDDATA14, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA14, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA14, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA13, Applicable Devices = 6X90 8X90. LCDDATA13, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA13, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA13, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA12, Applicable Devices = 6X90 8X90. LCDDATA12, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA12, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA12, Wake-up via WDT or",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInterrupt = uuuu uuuu. LCDDATA11, Applicable Devices = 6X90 8X90. LCDDATA11, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA11, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA11, Wake-up via WDT or Interrupt = uuuu uuuu. SPBRG2, Applicable Devices = 6X90 8X90. SPBRG2, Power-on Reset, Brown-out Reset = 0000 0000. SPBRG2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SPBRG2, Wake-up via WDT or Interrupt = uuuu uuuu. RCREG2, Applicable Devices = 6X90 8X90. RCREG2, Power-on Reset, Brown-out Reset = 0000 0000. RCREG2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. RCREG2, Wake-up via WDT",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nor Interrupt = uuuu uuuu. TXREG2, Applicable Devices = 6X90 8X90. TXREG2, Power-on Reset, Brown-out Reset = 0000 0000. TXREG2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TXREG2, Wake-up via WDT or Interrupt = uuuu uuuu. TXSTA2, Applicable Devices = 6X90 8X90. TXSTA2, Power-on Reset, Brown-out Reset = 0000 -010. TXSTA2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 -010. TXSTA2, Wake-up via WDT or Interrupt = uuuu -uuu. RCSTA2, Applicable Devices = 6X90 8X90. RCSTA2, Power-on Reset, Brown-out Reset = 0000 000x. RCSTA2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000x. RCSTA2, Wake-up via WDT or Interrupt =",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. LCDDATA10, Applicable Devices = 6X90 8X90. LCDDATA10, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA10, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA10, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA9, Applicable Devices = 6X90 8X90. LCDDATA9, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA9, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA9, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA8, Applicable Devices = 6X90 8X90. LCDDATA8, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA8, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA8, Wake-up via WDT or Interrupt",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= uuuu uuuu. LCDDATA7, Applicable Devices = 6X90 8X90. LCDDATA7, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA7, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA7, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA6, Applicable Devices = 6X90 8X90. LCDDATA6, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA6, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA6, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA5, Applicable Devices = 6X90 8X90. LCDDATA5, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA5, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA5, Wake-up via WDT or",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInterrupt = uuuu uuuu. LCDDATA4, Applicable Devices = 6X90. LCDDATA4, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA4, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA4, Wake-up via WDT or Interrupt = . , Applicable Devices = 8X90. , Power-on Reset, Brown-out Reset = . , MCLR Resets WDT Reset RESET Instruction Stack Resets = . , Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA3, Applicable Devices = 6X90 8X90. LCDDATA3, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA3, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA2, Applicable Devices = 6X90 8X90. LCDDATA2, Power-on Reset,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = xxxx xxxx. LCDDATA2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA2, Wake-up via WDT or Interrupt = uuuu uuuu. LCDDATA1, Applicable Devices = 6X90 8X90. LCDDATA1, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA1, Wake-up via WDT or Interrupt = uuuu uuuu uuuu. LCDDATA0, Applicable Devices = 6X90 8X90. LCDDATA0, Power-on Reset, Brown-out Reset = xxxx xxxx. LCDDATA0, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. LCDDATA0, Wake-up via WDT or Interrupt = \nLegend:",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nu = unchanged, x = unknown, -= unimplemented bit, read as GLYPH<145> 0 GLYPH<146>, q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read GLYPH<145> 0 GLYPH<146>.\n6: These registers are cleared on POR and unchanged on BOR.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLCDSE5, Applicable Devices = 6X90. LCDSE5, Applicable Devices = 8X90. LCDSE5, Power-on Reset, Brown-out Reset = 0000. LCDSE5, Power-on Reset, Brown-out Reset = 0000. LCDSE5, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. LCDSE5, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 (6). LCDSE5, Wake-up via WDT or Interrupt = uuuu. LCDSE5, Wake-up via WDT or Interrupt = uuuu. LCDSE4, Applicable Devices = 6X90. LCDSE4, Applicable Devices = 8X90. LCDSE4, Power-on Reset, Brown-out Reset = 0000. LCDSE4, Power-on Reset, Brown-out Reset = 0000. LCDSE4, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. LCDSE4, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 (6). LCDSE4, Wake-up via",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu. LCDSE4, Wake-up via WDT or Interrupt = uuuu. LCDSE3, Applicable Devices = 6X90. LCDSE3, Applicable Devices = 8X90. LCDSE3, Power-on Reset, Brown-out Reset = 0000. LCDSE3, Power-on Reset, Brown-out Reset = 0000. LCDSE3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. LCDSE3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 (6). LCDSE3, Wake-up via WDT or Interrupt = uuuu. LCDSE3, Wake-up via WDT or Interrupt = uuuu. LCDSE2, Applicable Devices = 6X90. LCDSE2, Applicable Devices = 8X90. LCDSE2, Power-on Reset, Brown-out Reset = 0000. LCDSE2, Power-on Reset, Brown-out Reset = 0000. LCDSE2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLCDSE2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 (6). LCDSE2, Wake-up via WDT or Interrupt = uuuu. LCDSE2, Wake-up via WDT or Interrupt = uuuu. LCDSE1, Applicable Devices = 6X90. LCDSE1, Applicable Devices = 8X90. LCDSE1, Power-on Reset, Brown-out Reset = 0000. LCDSE1, Power-on Reset, Brown-out Reset = 0000. LCDSE1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. LCDSE1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 (6). LCDSE1, Wake-up via WDT or Interrupt = uuuu. LCDSE1, Wake-up via WDT or Interrupt = uuuu. LCDSE0, Applicable Devices = 6X90. LCDSE0, Applicable Devices = 8X90. LCDSE0, Power-on Reset, Brown-out Reset = 0000. LCDSE0, Power-on Reset,",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = 0000. LCDSE0, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. LCDSE0, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 (6). LCDSE0, Wake-up via WDT or Interrupt = uuuu. LCDSE0, Wake-up via WDT or Interrupt = uuuu. LCDCON, Applicable Devices = 6X90. LCDCON, Applicable Devices = 8X90. LCDCON, Power-on Reset, Brown-out Reset = 000-. LCDCON, Power-on Reset, Brown-out Reset = 0000. LCDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 000-. LCDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. LCDCON, Wake-up via WDT or Interrupt = uuu-. LCDCON, Wake-up via WDT or Interrupt = uuuu. LCDPS, Applicable Devices = 6X90. LCDPS, Applicable Devices = 8X90. LCDPS, Power-on Reset, Brown-out",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset = 0000. LCDPS, Power-on Reset, Brown-out Reset = 0000. LCDPS, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. LCDPS, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. LCDPS, Wake-up via WDT or Interrupt = uuuu. LCDPS, Wake-up via WDT or Interrupt = uuuu\n= value depends on condition.\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as GLYPH<145> 0 GLYPH<146>, q Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 4-4: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 4-3 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read GLYPH<145> 0 GLYPH<146>.\n6: These registers are cleared on POR and unchanged on BOR.",
    "5.0 MEMORY ORGANIZATION\nThere  are  two  types  of  memory  in  PIC18  Flash microcontroller devices:\nGLYPH<149> Program Memory\nGLYPH<149> Data RAM\nAs Harvard architecture devices, the data and program memories use separate busses; this allows for concurrent access of the two memory spaces.\nAdditional detailed information on the operation of the Flash  program  memory  is  provided  in Section 6.0 GLYPH<147>Flash Program MemoryGLYPH<148> .",
    "5.1 Program Memory Organization\nPIC18  microcontrollers  implement  a  21-bit  program counter,  which  is  capable  of  addressing  a  2-Mbyte program memory space. Accessing a location between the  upper  boundary  of  the  physically  implemented memory and the 2-Mbyte address will return all GLYPH<145> 0 GLYPH<146> s  (a NOP instruction).\nThe PIC18FX390 have 8 Kbytes of Flash memory and can store up to 4,096 single-word instructions and the PIC18FX490 have 16 Kbytes of Flash memory and can store up to 8,192 single-word instructions.\nPIC18 devices have two interrupt vectors. The Reset vector  address  is  at  0000h  and  the  interrupt  vector addresses are at 0008h and 0018h.\nThe program memory maps for PIC18F6390/6490/8390/8490  devices  are  shown  in Figure 5-1.",
    "5.1.1 PROGRAM COUNTER\nThe Program Counter (PC) specifies the address of the instruction to fetch for execution. The PC is 21 bits wide and is contained in three separate 8-bit registers. The low byte, known as the PCL register, is both readable and writable. The high byte, or PCH register, contains the PC<15:8> bits; it is not directly readable or writable. Updates to the PCH register are performed through the PCLATH register. The upper byte is called PCU. This register  contains  the  PC<20:16>  bits;  it  is  also  not directly  readable  or  writable.  Updates  to  the  PCU register are performed through the PCLATU register.\nThe stack operates as a 31-word by 21-bit RAM and a 5-bit Stack Pointer. The stack space is not part of either program or data space. The Stack Pointer is readable and writable and the address on the top of the stack is readable and writable through the top-of-stack Special Function  Registers.  Data  can  also  be  pushed  to,  or popped from the stack using these registers.",
    "5.1.1 PROGRAM COUNTER\nThe contents of PCLATH and PCLATU are transferred to  the  program  counter  by  any  operation  that  writes PCL.  Similarly,  the  upper  two  bytes  of  the  program counter are transferred to PCLATH and PCLATU by an operation that reads PCL. This is useful for computed offsets  to  the  PC  (see Section 5.1.4.1  GLYPH<147>Computed GOTOGLYPH<148> ).\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the Least Significant bit of PCL is fixed to a  value  of  GLYPH<145> 0 GLYPH<146>. The  PC  increments  by  2  to  address sequential instructions in the program memory.\nThe CALL, RCALL, GOTO and  program  branch instructions write to the program counter directly. For these instructions, the contents of PCLATH  and PCLATU are not transferred to the program counter.",
    "5.1.2 RETURN ADDRESS STACK\nThe return address stack allows any combination of up to 31 program calls and interrupts to occur. The PC is pushed onto the stack when a CALL or RCALL instruction is executed, or an interrupt is Acknowledged. The PC value is pulled off the stack on a RETURN, RETLW or a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN or CALL instructions.\nA CALL type instruction causes a push onto the stack; the Stack Pointer is first incremented and the location pointed  to  by  the  Stack  Pointer  is  written  with  the contents of the PC (already pointing to the instruction following the CALL ). A RETURN type instruction causes a  pop  from  the  stack;  the  contents  of  the  location pointed to by the STKPTR register are transferred to the PC and then the Stack Pointer is decremented.",
    "5.1.2 RETURN ADDRESS STACK\nThe  Stack  Pointer  is  initialized  to  GLYPH<145> 00000 GLYPH<146> after  all Resets. There is no RAM associated with the location corresponding to a Stack Pointer value of GLYPH<145> 00000 GLYPH<146>; this is only a Reset value. Status bits indicate if the stack is full, has overflowed or has underflowed.",
    "5.1.2.1 Top-of-Stack Access\nOnly the top of the return address stack (TOS) is readable and writable. A set of three registers, TOSU:TOSH:TOSL,  hold  the  contents  of  the  stack location pointed to by the lower five bits of the STKPTR register (Figure 5-2). This allows users to implement a software stack if necessary. After a CALL, RCALL or interrupt, the software can read the pushed value by reading the TOSU:TOSH:TOSL registers. These values can be placed on a user-defined software stack. At return time, the software can return these values to TOSU:TOSH:TOSL and do a return.\nThe user must disable the global interrupt enable bits while accessing the stack to prevent inadvertent stack corruption.",
    "5.1.2.2 Return Stack Pointer (STKPTR)\nThe STKPTR register (Register 5-1) contains the Stack Pointer value, the STKFUL (Stack Full) status bit and the STKUNF (Stack Underflow) status bits. The value of  the  Stack Pointer can be 0 through 31. The Stack Pointer increments before values are pushed onto the stack and decrements after values are popped off the stack. On Reset, the Stack Pointer value will be zero. The user may read and write the Stack Pointer value. This  feature  can  be  used  by  a  Real-Time  Operating System (RTOS) for return stack maintenance.\nAfter the PC is pushed onto the stack 31 times (without popping any values off the stack), the STKFUL bit is set.  The  STKFUL  bit  is  cleared  by  software  or  by  a POR.",
    "5.1.2.2 Return Stack Pointer (STKPTR)\nThe action that takes place when the stack becomes full depends on the state of the STVREN (Stack Overflow Reset Enable) Configuration bit. (Refer to Section 23.1 GLYPH<147>Configuration BitsGLYPH<148> for a description of the device  Configuration  bits.) If STVREN  is  set (default),  the  31st push will  push the  (PC  + 2)  value onto  the  stack,  set  the  STKFUL  bit  and  reset  the device. The STKFUL bit will remain set and the Stack Pointer will be set to zero.\nWhen  the  stack  has  been  popped  enough  times  to unload the stack, the next pop will return a value of zero to  the  PC  and sets the STKUNF bit, while the Stack Pointer remains at zero. The STKUNF bit will remain set until cleared by software, or until a POR occurs.\nNote:\nReturning a value of zero to the PC on an underflow has the effect of vectoring the program  to  the  Reset  vector  where  the stack conditions can be verified and appropriate actions can be taken. This is not the same as a Reset, as the contents of the SFRs are not affected.",
    "5.1.2.3 PUSH and POP Instructions\nSince  the  Top-of-Stack  is  readable  and  writable,  the ability to push values onto the stack and pull values off the  stack,  without  disturbing  normal  program  execution, is a desirable feature. The PIC18 instruction set includes  two  instructions, PUSH and POP ,  that  permit the  TOS  to  be  manipulated  under  software  control. TOSU, TOSH and TOSL can be modified to place data or a return address on the stack.\nIf STVREN is cleared, the STKFUL bit will be set on the 31st push and the Stack Pointer will increment to 31. Any additional pushes will not overwrite the 31st push and STKPTR will remain at 31.\nThe PUSH instruction places the current PC value onto the stack. This increments the Stack Pointer and loads the current PC value onto the stack.\nThe POP instruction  discards  the  current  TOS  by decrementing  the  Stack  Pointer.  The  previous  value pushed onto the stack then becomes the TOS value.",
    "REGISTER 5-1: STKPTR: STACK POINTER REGISTER\nSTKFUL (1), R/C-0 = STKUNF (1). STKFUL (1), U-0 = GLYPH<151>. STKFUL (1), R/W-0 = SP4. STKFUL (1), R/W-0 = SP3. STKFUL (1), R/W-0 = SP2. STKFUL (1), R/W-0 = SP1. STKFUL (1), R/W-0 = SP0. bit 7 bit 0, R/C-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 5-1: STKPTR: STACK POINTER REGISTER\nLegend:, 1 = C = Clearable only bit. Legend:, 2 = C = Clearable only bit. Legend:, 3 = C = Clearable only bit. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nSTKFUL: Stack Full Flag bit (1)\n1 = Stack became full or overflowed\n0 = Stack has not become full or overflowed\nbit 6\nSTKUNF: Stack Underflow Flag bit (1)\n1 = Stack underflow occurred\n0 = Stack underflow did not occur",
    "REGISTER 5-1: STKPTR: STACK POINTER REGISTER\nbit 5\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 4-0\nSP4:SP0: Stack Pointer Location bits\nNote 1: Bit 7 and bit 6 are cleared by user software or by a POR.",
    "5.1.2.4 Stack Full and Underflow Resets\nDevice Resets on stack overflow and stack underflow conditions are enabled by setting the STVREN bit in Configuration Register 4L. When STVREN is set, a full or underflow  will set the appropriate  STKFUL  or STKUNF bit  and  then  cause  a  device  Reset.  When STVREN is cleared, a full or underflow condition will set the appropriate STKFUL or STKUNF bit, but not cause a  device  Reset.  The  STKFUL  or  STKUNF  bits  are cleared by the user software or a Power-on Reset.",
    "5.1.3 FAST REGISTER STACK\nA  Fast  Register  Stack  is  provided  for  the  STATUS, WREG and BSR registers, to provide a GLYPH<147>fast  returnGLYPH<148> option for interrupts. This stack is only one level deep and is neither readable nor writable. It is loaded with the current value of the corresponding register when the processor vectors for an interrupt. All interrupt sources will push values into the stack registers. The values in the  registers  are  then  loaded  back  into  the  working registers if the RETFIE, FAST instruction is  used to return from the interrupt.\nIf both low and high-priority interrupts are enabled, the stack registers cannot be used reliably to return from low-priority interrupts. If a high-priority interrupt occurs while servicing a low-priority interrupt, the Stack register values stored by the low-priority interrupt will be overwritten. In these cases, users must save the key registers in software during a low-priority interrupt.",
    "5.1.3 FAST REGISTER STACK\nIf interrupt priority is not used, all interrupts may use the Fast  Register  Stack  for  returns  from  interrupt.  If  no interrupts  are  used,  the  Fast  Register  Stack  can  be used to restore the STATUS, WREG and BSR registers at the end of a subroutine call. To use the Fast Register Stack  for  a  subroutine  call,  a CALL label, FAST instruction  must  be  executed  to  save  the  STATUS, WREG and BSR registers to the Fast Register Stack. A RETURN, FAST instruction is then executed to restore these registers from the Fast Register Stack.\nExample 5-1 shows a source code example that uses the  Fast  Register  Stack  during  a  subroutine  call  and return.",
    "EXAMPLE 5-1: FAST REGISTER STACK CODE EXAMPLE\nCALL, 1 = FAST ;STATUS, WREG, BSR ;SAVED IN FAST REGISTER ;STACK. SUB1 RETURN, 1 = FAST ;RESTORE VALUES SAVED ;IN FAST REGISTER STACK",
    "5.1.4 LOOK-UP TABLES IN PROGRAM MEMORY\nThere may be programming situations that require the creation of data structures, or look-up tables, in program memory. For PIC18 devices, look-up tables can be implemented in two ways:\nGLYPH<149> Computed GOTO\nGLYPH<149> Table Reads",
    "5.1.4.1 Computed GOTO\nA computed GOTO is accomplished by adding an offset to  the  program  counter.  An  example  is  shown  in Example 5-2.\nA look-up table can be formed  with an ADDWF  PCL instruction and a group of RETLW nn instructions. The W register is loaded with an offset into the table before executing a call to that table. The first instruction of the called routine is the ADDWF PCL instruction. The next instruction  executed  will  be  one  of  the RETLW  nn instructions  that  returns  the  value  GLYPH<145> nn GLYPH<146> to  the  calling function.\nThe offset  value  (in  WREG)  specifies  the  number  of bytes  that  the  program  counter  should  advance  and should be multiples of 2 (LSb = 0 ).\nIn  this  method,  only  one  data  byte  may  be  stored  in each  instruction  location  and  room  on  the  return address stack is required.",
    "EXAMPLE 5-2: COMPUTED GOTO USING AN OFFSET VALUE\n, 1 = MOVF CALL. , 2 = OFFSET, W TABLE. ORG, 1 = nn00h. ORG, 2 = . TABLE, 1 = ADDWF. TABLE, 2 = PCL. , 1 = RETLW. , 2 = nnh. , 1 = RETLW. , 2 = nnh. , 1 = RETLW. , 2 = nnh. , 1 = .. , 2 = . , 1 = .. , 2 = . , 1 = .. , 2 = ",
    "5.1.4.2 Table Reads\nA  better  method  of  storing  data  in  program  memory allows two bytes of data to be stored in each instruction location.\nLook-up  table  data  may  be  stored  two  bytes  per program word while programming. The Table Pointer register (TBLPTR) specifies the byte address and the Table Latch register (TABLAT) contains the data that is read  from  the  program  memory.  Data  is  transferred from program memory one byte at a time.\nTable read operation is discussed further in Section 6.1 GLYPH<147>Table ReadsGLYPH<148> .",
    "5.2.1 CLOCKING SCHEME\nThe  microcontroller clock input, whether  from  an internal or external source, is internally divided by four to  generate  four  non-overlapping  quadrature  clocks (Q1, Q2, Q3 and Q4). Internally, the program counter is incremented  on  every  Q1;  the  instruction  is  fetched from the program memory and latched into the Instruction Register (IR) during Q4. The instruction is decoded and executed during the following Q1 through Q4. The clocks  and  instruction  execution  flow  are  shown  in Figure 5-3.\nAn  GLYPH<147>Instruction  CycleGLYPH<148>  consists  of  four  Q  cycles,  Q1 through Q4. The instruction fetch and execute are pipelined in such a manner that a fetch takes one instruction cycle,  while  the  decode  and  execute  take  another instruction cycle. However, due to the pipelining, each instruction  effectively  executes  in  one  cycle.  If  an instruction causes the program counter to change (e.g., GOTO ),  then  two  cycles  are  required  to  complete  the instruction (Example 5-3).\nA fetch cycle begins with the Program Counter (PC) incrementing in Q1.",
    "5.2.1 CLOCKING SCHEME\nIn the execution cycle, the fetched instruction is latched into  the  Instruction  Register  (IR)  in  cycle  Q1.  This instruction  is  then  decoded  and  executed  during  the Q2, Q3 and Q4 cycles. Data memory is read during Q2 (operand  read)  and  written  during  Q4  (destination write).",
    "EXAMPLE 5-3: INSTRUCTION PIPELINE FLOW\n1. MOVLW 55h, TCY0 = Fetch 1. 1. MOVLW 55h, TCY1 = Execute 1. 1. MOVLW 55h, TCY2 = . 1. MOVLW 55h, TCY3 = . 1. MOVLW 55h, TCY4 = . 1. MOVLW 55h, TCY5 = . 2. MOVWF PORTB, TCY0 = . 2. MOVWF PORTB, TCY1 = Fetch 2. 2. MOVWF PORTB, TCY2 = Execute 2. 2. MOVWF PORTB, TCY3 = . 2. MOVWF PORTB, TCY4 = . 2. MOVWF PORTB, TCY5 = . 3. BRA, TCY0 = . 3. BRA, TCY1 = . 3. BRA, TCY2 = Fetch 3. 3. BRA, TCY3 = Execute 3. 3. BRA, TCY4 = . 3. BRA, TCY5 = . 4. BSF PORTA,, TCY0 = BIT3",
    "EXAMPLE 5-3: INSTRUCTION PIPELINE FLOW\n(Forced NOP). 4. BSF PORTA,, TCY1 = . 4. BSF PORTA,, TCY2 = . 4. BSF PORTA,, TCY3 = Fetch 4. 4. BSF PORTA,, TCY4 = Flush ( NOP ). 4. BSF PORTA,, TCY5 = . 5. Instruction, TCY0 = address SUB_1. 5. Instruction, TCY1 = . 5. Instruction, TCY2 = . 5. Instruction, TCY3 = . 5. Instruction, TCY4 = Fetch SUB_1. 5. Instruction, TCY5 = Execute SUB_1\nAll instructions are single cycle, except for any program branches. These take two cycles since the fetch instruction is GLYPH<147>flushedGLYPH<148> from the pipeline, while the new instruction is being fetched and then executed.",
    "5.2.3 INSTRUCTIONS IN PROGRAM MEMORY\nThe program memory is addressed in bytes. Instructions are stored as two bytes or four bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSB = 0 ). To maintain alignment with instruction boundaries, the PC increments in steps of 2 and the LSB will always read GLYPH<145> 0 GLYPH<146> (see Section 5.1.1 GLYPH<147>Program CounterGLYPH<148> ).\nFigure 5-4 shows an example of how instruction words are stored in the program memory.",
    "5.2.3 INSTRUCTIONS IN PROGRAM MEMORY\nThe CALL and GOTO instructions have the absolute program memory address embedded into the instruction. Since  instructions  are  always  stored  on  word  boundaries,  the  data  contained  in  the  instruction  is  a  word address.  The  word  address  is  written  to  PC<20:1>, which  accesses  the  desired  byte  address  in  program memory.  Instruction  #2  in  Figure 5-4  shows  how  the instruction, GOTO  0006h ,  is  encoded  in  the  program memory. Program branch instructions, which encode a relative address offset, operate in the same manner. The offset value stored in a branch instruction represents the number of single-word instructions that the PC will be offset  by. Section 24.0  GLYPH<147>Instruction  Set  SummaryGLYPH<148> provides further details of the instruction set.",
    "5.2.4 TWO-WORD INSTRUCTIONS\nThe standard PIC18 instruction set has four two-word instructions: CALL , MOVFF , GOTO and LSFR . In  all cases, the second word of the instructions always has GLYPH<145> 1111 GLYPH<146>  as its four Most Significant bits; the other 12 bits are literal data, usually a data memory address.\nThe  use  of  GLYPH<145> 1111 GLYPH<146> in  the  4  MSbs  of  an  instruction specifies  a  special  form  of NOP .  If  the  instruction  is executed in proper sequence GLYPH<150> immediately after the first  word GLYPH<150>  the  data  in  the  second  word  is  accessed and used by the instruction sequence. If the first word is  skipped  for  some  reason  and  the  second  word  is executed by itself, a NOP is executed instead. This is necessary for cases when the two-word instruction is preceded by a conditional instruction that changes the PC. Example 5-4 shows how this works.",
    "Note:\nSee Section 5.5 GLYPH<147>Program Memory and the Extended Instruction SetGLYPH<148> for information on two-word instructions in the extended instruction set.",
    "FIGURE 5-4: INSTRUCTIONS IN PROGRAM MEMORY\nProgram Memory\nByte Locations\n\u2192\nInstruction 1:\nInstruction 2:\nMOVLW\n055h\nGOTO\n0006h\nInstruction 3:\nLSB = 1, 1 = LSB = 0. LSB = 1, 2 = Word Address \u2193. , 1 = . , 2 = 000000h. , 1 = . , 2 = 000002h. , 1 = . , 2 = 000004h. , 1 = . , 2 = 000006h. 0Fh, 1 = 55h. 0Fh, 2 = 000008h. EFh, 1 = 03h. EFh, 2 = 00000Ah. F0h, 1 = 00h. F0h, 2 = 00000Ch. C1h, 1 = 23h. C1h, 2 = 00000Eh. F4h, 1 = 56h. F4h, 2 = 000010h. , 1 = . , 2 = 000012h. , 1 = . , 2 = 000014h\nMOVFF\n123h, 456h",
    "EXAMPLE 5-4: TWO-WORD INSTRUCTIONS\n0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:. = ; is RAM location. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE 1:. = ; No, skip this word. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:. = ; Execute this word as a NOP. 0010, CASE 1:.Object Code =",
    "EXAMPLE 5-4: TWO-WORD INSTRUCTIONS\n0100. 0010, CASE 1:.Object Code = 0000 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:. = ; continue code. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:. = . Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:. = . 0110, CASE 1:.Object Code = 0110. 0110, CASE",
    "EXAMPLE 5-4: TWO-WORD INSTRUCTIONS\n1:.Object Code = 0000 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:. = ; is RAM location. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE 1:. = ; Yes, execute this word. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:. = ; 2nd word of instruction. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000 0000. 0010, CASE",
    "EXAMPLE 5-4: TWO-WORD INSTRUCTIONS\n1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:. = ; continue code",
    "5.3.1 BANK SELECT REGISTER\nNote:\nThe  operation  of  some  aspects  of  data memory  are  changed  when  the  PIC18 extended instruction  set  is  enabled.  See Section 5.6 GLYPH<147>Data Memory and the Extended Instruction SetGLYPH<148> for more information.\nThe data memory in PIC18 devices is implemented as static RAM. Each register in the data memory has a 12-bit  address,  allowing  up  to  4096  bytes  of  data memory. The memory space is divided into as many as 16 banks that contain 256 bytes each; PIC18F6390/6490/8390/8490 devices implement only  4  banks.  Figure 5-5  shows  the  data  memory organization for the PIC18F6390/6490/8390/8490 devices.\nThe data memory contains Special Function Registers (SFRs) and General Purpose Registers (GPRs). The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratchpad operations in the userGLYPH<146>s application. Any read of an unimplemented location will read as GLYPH<145> 0 GLYPH<146> s.",
    "5.3.1 BANK SELECT REGISTER\nThe instruction  set  and  architecture  allow  operations across  all  banks.  The  entire  data  memory  may  be accessed  by  Direct,  Indirect  or  Indexed  Addressing modes. Addressing modes are discussed later in this section.\nTo  ensure  that  commonly  used  registers  (SFRs  and select GPRs) can be accessed in a single cycle, PIC18 devices implement an Access Bank. This is a 256-byte memory space that provides fast access to SFRs and the  lower  portion  of  GPR  Bank  0  without  using  the BSR. Section 5.3.2 GLYPH<147>Access BankGLYPH<148> provides a detailed description of the Access RAM.\nLarge  areas  of  data  memory  require  an  efficient addressing  scheme  to  make  rapid  access  to  any address  possible.  Ideally,  this  means  that  an  entire address does not need to be provided for each read or write  operation.  For  PIC18  devices,  this  is  accomplished with a RAM banking scheme. This divides the memory space into 16 contiguous banks of 256 bytes. Depending  on  the  instruction,  each  location  can  be addressed directly by its full 12-bit address, or an 8-bit low-order address and a 4-bit Bank Pointer.",
    "5.3.1 BANK SELECT REGISTER\nMost instructions in the PIC18 instruction set make use of the Bank Pointer, known as the Bank Select Register (BSR). This SFR holds the 4 Most Significant bits of a locationGLYPH<146>s  address;  the  instruction  itself  includes  the 8 Least Significant bits. Only the four lower bits of the BSR are implemented (BSR3:BSR0). The upper four bits are unused; they will always read GLYPH<145> 0 GLYPH<146> and cannot be written to. The BSR can be loaded directly by using the MOVLB instruction.\nThe  value  of  the  BSR  indicates  the  bank  in  data memory; the 8 bits in the instruction show the location in the bank and can be thought of as an offset from the bankGLYPH<146>s  lower  boundary.  The  relationship  between  the BSRGLYPH<146>s  value and the bank division in data memory is shown in Figure 5-6.",
    "5.3.1 BANK SELECT REGISTER\nSince up to 16 registers may share the same low-order address, the user must always be careful to ensure that the proper bank is selected before performing a data read  or  write.  For  example,  writing  what  should  be program data to an 8-bit address of F9h, while the BSR is 0Fh will end up resetting the program counter.\nWhile any bank can be selected, only those banks that are  actually  implemented  can  be  read  or  written  to. Writes  to  unimplemented  banks  are  ignored,  while reads from unimplemented banks will return GLYPH<145> 0 GLYPH<146> s. Even so, the STATUS register will still be affected as if the operation  was  successful.  The  data  memory  map  in Figure 5-5 indicates which banks are implemented.\nIn  the  core  PIC18  instruction  set,  only  the MOVFF instruction  fully  specifies  the  12-bit  address  of  the source and target registers. This instruction ignores the BSR completely when it executes. All other instructions include only the low-order address as an operand and must use either the BSR or the Access Bank to locate their target registers.",
    "USE OF THE BANK SELECT REGISTER (DIRECT ADDRESSING)\nNote 1: The Access RAM bit of the instruction can be used to force an override of the selected bank (BSR<3:0>) to the registers of the Access Bank.\n2: The MOVFF instruction embeds the entire 12-bit address in the instruction.",
    "5.3.2 ACCESS BANK\nWhile  the  use  of  the  BSR  with  an  embedded  8-bit address  allows  users  to  address  the  entire  range  of data memory, it also means that the user must always ensure  that  the  correct  bank  is  selected.  Otherwise, data may be read from or written to the wrong location. This can be disastrous if a GPR is the intended target of  an  operation  but  an  SFR  is  written  to  instead. Verifying  and/or  changing  the  BSR  for  each  read  or write to data memory can become very inefficient.\nUsing this GLYPH<147>forcedGLYPH<148> addressing allows the instruction to operate  on  a  data  address  in  a  single  cycle  without updating the BSR first. For 8-bit addresses of 80h and above, this means that users can evaluate and operate on SFRs more efficiently. The Access RAM below 60h is a good place for data values that the user might need to  access  rapidly,  such  as  immediate  computational results  or  common  program  variables.  Access  RAM also allows for faster and more code efficient context saving and switching of variables.",
    "5.3.2 ACCESS BANK\nTo streamline access for the most commonly used data memory locations, the data memory is configured with an  Access  Bank,  which  allows  users  to  access  a mapped block of memory without specifying  a  BSR. The  Access  Bank  consists  of  the  first  96  bytes  of memory (00h-5Fh) in Bank 0 and the last 160 bytes of memory (60h-FFh) in Block 15. The lower half is known as the GLYPH<147>Access RAMGLYPH<148> and is composed of GPRs. This upper  half  is  where  the  deviceGLYPH<146>s  SFRs  are  mapped. These  two  areas  are  mapped  contiguously  in  the Access Bank and can be addressed in a linear fashion by an 8-bit address (Figure 5-5).",
    "5.3.2 ACCESS BANK\nThe Access Bank is used by core PIC18 instructions that include the Access RAM bit (the GLYPH<145>aGLYPH<146> parameter in the instruction). When GLYPH<145>aGLYPH<146> is equal to GLYPH<145> 1 GLYPH<146> , the instruction uses  the  BSR  and  the  8-bit  address  included  in  the opcode for the data memory address. When GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, however,  the  instruction  is  forced  to  use  the  Access Bank  address  map;  the  current  value  of  the  BSR  is ignored entirely.\nThe mapping of the Access Bank is slightly different when the extended instruction set is enabled (XINST Configuration bit = 1 ). This is discussed in more detail in Section 5.6.3  GLYPH<147>Mapping the  Access  Bank  in Indexed Literal Offset ModeGLYPH<148> .",
    "5.3.3 GENERAL PURPOSE REGISTER FILE\nPIC18 devices may have banked memory in the GPR area. This is data RAM, which is available for use by all instructions.  GPRs  start  at  the  bottom  of  Bank  0 (address 000h) and grow upwards towards the bottom of the  SFR  area.  GPRs  are  not  initialized  by  a Power-on  Reset  and  are  unchanged  on  all  other Resets.",
    "5.3.4 SPECIAL FUNCTION REGISTERS\nThe Special Function  Registers (SFRs) are registers used by the CPU and peripheral modules for controlling the desired operation of the device. These registers are implemented as static RAM. SFRs start at the top of data memory (FFFh) and extend downward to occupy three-quarters of Bank 15 (from F40h to FFFh). A list of these registers is given in Table 5-1 and Table 5-2.\nThe  SFRs  can  be  classified  into  two  sets:  those associated  with  the  GLYPH<147>coreGLYPH<148>  device  functionality  (ALU, Resets and interrupts) and  those related to the peripheral functions. The Reset and Interrupt registers are  described  in  their  respective  chapters,  while  the ALUGLYPH<146>s STATUS  register  is  described  later  in  this section.  Registers  related  to  the  operation  of  the peripheral features are described in the chapter for that peripheral.\nThe SFRs are typically distributed among the peripherals whose functions they control. Unused SFR locations are unimplemented and read as GLYPH<145> 0 GLYPH<146> s.",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES\nFFFh, Name = TOSU. FFFh, Address = FDFh. FFFh, Name = INDF2 (1). FFEh, Name = TOSH. FFEh, Address = FDEh. FFEh, Name = POSTINC2 (1). FFDh, Name = TOSL. FFDh, Address = FDDh. FFDh, Name = POSTDEC2 (1). FFCh, Name = STKPTR. FFCh, Address = FDCh. FFCh, Name = PREINC2 (1). FFBh, Name = PCLATU. FFBh, Address = FDBh. FFBh, Name = PLUSW2 (1). FFAh, Name = PCLATH. FFAh, Address = FDAh. FFAh, Name = FSR2H. FF9h, Name = PCL. FF9h, Address = FD9h. FF9h, Name = FSR2L. FF8h, Name = TBLPTRU. FF8h, Address =",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES\nFD8h. FF8h, Name = STATUS. FF7h, Name = TBLPTRH. FF7h, Address = FD7h. FF7h, Name = TMR0H. FF6h, Name = TBLPTRL. FF6h, Address = FD6h. FF6h, Name = TMR0L. FF5h, Name = TABLAT. FF5h, Address = FD5h. FF5h, Name = T0CON. FF4h, Name = PRODH. FF4h, Address = FD4h. FF4h, Name = GLYPH<151> (2). FF3h, Name = PRODL. FF3h, Address = FD3h. FF3h, Name = OSCCON. FF2h, Name = INTCON. FF2h, Address = FD2h. FF2h, Name = HLVDCON. FF1h, Name = INTCON2. FF1h, Address = FD1h.",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES\nFF1h, Name = WDTCON. FF0h, Name = INTCON3. FF0h, Address = FD0h. FF0h, Name = RCON. FEFh, Name = INDF0 (1). FEFh, Address = FCFh. FEFh, Name = TMR1H. FEEh, Name = POSTINC0 (1). FEEh, Address = FCEh. FEEh, Name = TMR1L. FEDh, Name = POSTDEC0 (1). FEDh, Address = FCDh. FEDh, Name = T1CON. FECh, Name = PREINC0 (1). FECh, Address = FCCh. FECh, Name = TMR2. FEBh, Name = PLUSW0 (1). FEBh, Address = FCBh. FEBh, Name = PR2. FEAh, Name = FSR0H. FEAh, Address = FCAh. FEAh, Name = T2CON. FE9h, Name =",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES\nFSR0L. FE9h, Address = FC9h. FE9h, Name = SSPBUF. FE8h, Name = WREG. FE8h, Address = FC8h. FE8h, Name = SSPADD. FE7h, Name = INDF1 (1). FE7h, Address = FC7h. FE7h, Name = SSPSTAT. FE6h, Name = POSTINC1 (1). FE6h, Address = FC6h. FE6h, Name = SSPCON1. FE5h, Name = POSTDEC1 (1). FE5h, Address = FC5h. FE5h, Name = SSPCON2. FE4h, Name = PREINC1 (1). FE4h, Address = FC4h. FE4h, Name = ADRESH. FE3h, Name = PLUSW1 (1). FE3h, Address = FC3h. FE3h, Name = ADRESL. FE2h, Name =",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES\nFSR1H. FE2h, Address = FC2h. FE2h, Name = ADCON0. FE1h, Name = FSR1L. FE1h, Address = FC1h. FE1h, Name = ADCON1. FE0h, Name = BSR. FE0h, Address = FC0h. FE0h, Name = ADCON2",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES\nFBFh, Name = CCPR1H. FBEh, Name = CCPR1L. FBDh, Name = CCP1CON. FBCh, Name = CCPR2H. FBBh, Name = CCPR2L. FBAh, Name = CCP2CON. FB9h, Name = GLYPH<151> (2). FB8h, Name = GLYPH<151> (2). FB7h, Name = GLYPH<151> (2). FB6h, Name = GLYPH<151> (2). FB5h, Name = CVRCON. FB4h, Name = CMCON. FB3h, Name = TMR3H. FB2h, Name = TMR3L. FB1h, Name = T3CON. FB0h, Name = GLYPH<151> (2). FAFh, Name = SPBRG1. FAEh, Name = RCREG1.",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES\nFADh, Name = TXREG1. FACh, Name = TXSTA1. FABh, Name = RCSTA1. FAAh, Name = GLYPH<151> (2). FA9h, Name = GLYPH<151> (2). FA8h, Name = GLYPH<151> (2). FA7h, Name = GLYPH<151> (2). FA6h, Name = GLYPH<151> (2). FA5h, Name = IPR3. FA4h, Name = PIR3. FA3h, Name = PIE3. FA2h, Name = IPR2. FA1h, Name = PIR2. FA0h, Name = PIE2",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES\nAddress, 1 = Address. , 1 = F9Fh. , 1 = F9Eh. , 1 = F9Dh. , 1 = F9Ch. , 1 = F9Bh. , 1 = F9Ah. , 1 = F99h. , 1 = F98h. , 1 = F97h. , 1 = F96h. , 1 = F95h. , 1 = F94h. , 1 = F93h. , 1 = F92h. , 1 = F91h. , 1 = F90h. , 1 = F8Fh. , 1 = F8Eh. , 1 = F8Dh. , 1 = F8Ch. , 1 = F8Bh. , 1 = F8Ah. , 1 = F89h. , 1 = F88h. , 1 = F87h. , 1 = F86h. , 1 = F85h. , 1 = F84h. , 1 = F83h. , 1 =",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES\nF82h. , 1 = F81h. , 1 = F80h",
    "Note\n1: This is not a physical register.\n2: Unimplemented registers are read as GLYPH<145> 0 GLYPH<146>.\n3: This register is not available on 64-pin devices.\n4: This register is implemented but unused on 64-pin devices.",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES (CONTINUED)\n, Address = F7Fh. , Address = F7Eh. , Address = F7Dh. , Address = F7Ch. , Address = F7Bh. , Address = F7Ah. , Address = F79h. , Address = F78h. , Address = F77h. , Address = F76h. , Address = F75h. , Address = F74h. , Address = F73h. , Address = F72h. , Address = F71h. , Address = F70h",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES (CONTINUED)\nF6Fh, Name = SPBRG2. F6Eh, Name = RCREG2. F6Dh, Name = TXREG2. F6Ch, Name = TXSTA2. F6Bh, Name = RCSTA2. F6Ah, Name = LCDDATA10 (4). F69h, Name = LCDDATA9. F68h, Name = LCDDATA8. F67h, Name = LCDDATA7. F66h, Name = LCDDATA6. F65h, Name = LCDDATA5 (4). F64h, Name = LCDDATA4 (4). F63h, Name = LCDDATA3. F62h, Name = LCDDATA2. F61h, Name = LCDDATA1. F60h, Name = LCDDATA0",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES (CONTINUED)\nF5Fh, Name = LCDSE5 (3). F5Eh, Name = LCDSE4 (3). F5Dh, Name = LCDSE3. F5Ch, Name = LCDSE2. F5Bh, Name = LCDSE1. F5Ah, Name = LCDSE0. F59h, Name = LCDCON. F58h, Name = LCDPS. F57h, Name = GLYPH<151> (2). F56h, Name = GLYPH<151> (2). F55h, Name = GLYPH<151> (2). F54h, Name = GLYPH<151> (2). F53h, Name = GLYPH<151> (2). F52h, Name = GLYPH<151> (2). F51h, Name = GLYPH<151> (2). F50h, Name = GLYPH<151> (2)",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES (CONTINUED)\nF4Fh, Name = GLYPH<151> (2). F4Eh, Name = GLYPH<151> (2). F4Dh, Name = GLYPH<151> (2). F4Ch, Name = GLYPH<151> (2). F4Bh, Name = GLYPH<151> (2). F4Ah, Name = GLYPH<151> (2). F49h, Name = GLYPH<151> (2). F48h, Name = GLYPH<151> (2). F47h, Name = GLYPH<151> (2). F46h, Name = GLYPH<151> (2). F45h, Name = GLYPH<151> (2). F44h, Name = GLYPH<151> (2). F43h, Name = GLYPH<151> (2). F42h, Name = GLYPH<151> (2).",
    "TABLE 5-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F6390/6490/8390/8490 DEVICES (CONTINUED)\nF41h, Name = GLYPH<151> (2). F40h, Name = GLYPH<151> (2)\nNote 1: This is not a physical register.\n2: Unimplemented registers are read as GLYPH<145> 0 GLYPH<146>.\n3: This register is not available on 64-pin devices.\n4: This register is implemented but unused on 64-pin devices.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nTOSU, Bit 7 = GLYPH<151>. TOSU, Bit 6 = GLYPH<151>. TOSU, Bit 5 = GLYPH<151>. TOSU, Bit 4 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 3 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 2 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 1 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 0 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Value on POR, BOR = ---0. TOSU, Value on POR, BOR = 0000. TOSU, Details on page: = 59, 66. TOSH, Bit 7 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 6 = Top-of-Stack High Byte",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\n(TOS<15:8>). TOSH, Bit 5 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 4 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 3 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 2 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 1 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 0 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Value on POR, BOR = 0000. TOSH, Value on POR, BOR = 0000. TOSH, Details on page: = 59, 66. TOSL, Bit 7 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 6 = Top-of-Stack Low Byte (TOS<7:0>).",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nTOSL, Bit 5 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 4 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 3 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 2 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 1 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 0 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Value on POR, BOR = 0000. TOSL, Value on POR, BOR = 0000. TOSL, Details on page: = 59, 66. STKPTR, Bit 7 = STKFUL. STKPTR, Bit 6 = STKUNF. STKPTR, Bit 5 = GLYPH<151>. STKPTR, Bit 4 = Return Stack Pointer. STKPTR,",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nBit 3 = Return Stack Pointer. STKPTR, Bit 2 = Return Stack Pointer. STKPTR, Bit 1 = Return Stack Pointer. STKPTR, Bit 0 = Return Stack Pointer. STKPTR, Value on POR, BOR = 00-0. STKPTR, Value on POR, BOR = 0000. STKPTR, Details on page: = 59, 67. PCLATU, Bit 7 = GLYPH<151>. PCLATU, Bit 6 = GLYPH<151>. PCLATU, Bit 5 = GLYPH<151>. PCLATU, Bit 4 = Holding Register for PC<20:16>. PCLATU, Bit 3 = Holding Register for PC<20:16>. PCLATU, Bit 2 = Holding Register for PC<20:16>. PCLATU, Bit 1 = Holding Register for PC<20:16>. PCLATU, Bit 0 = Holding Register for PC<20:16>. PCLATU, Value on POR, BOR = ---0.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nPCLATU, Value on POR, BOR = 0000. PCLATU, Details on page: = 59, 66. PCLATH, Bit 7 = Holding Register for PC<15:8>. PCLATH, Bit 6 = Holding Register for PC<15:8>. PCLATH, Bit 5 = Holding Register for PC<15:8>. PCLATH, Bit 4 = Holding Register for PC<15:8>. PCLATH, Bit 3 = Holding Register for PC<15:8>. PCLATH, Bit 2 = Holding Register for PC<15:8>. PCLATH, Bit 1 = Holding Register for PC<15:8>. PCLATH, Bit 0 = Holding Register for PC<15:8>. PCLATH, Value on POR, BOR = 0000. PCLATH, Value on POR, BOR = 0000. PCLATH, Details on page: = 59, 66. PCL, Bit 7 = PC Low Byte (PC<7:0>). PCL, Bit 6 = PC Low Byte",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\n(PC<7:0>). PCL, Bit 5 = PC Low Byte (PC<7:0>). PCL, Bit 4 = PC Low Byte (PC<7:0>). PCL, Bit 3 = PC Low Byte (PC<7:0>). PCL, Bit 2 = PC Low Byte (PC<7:0>). PCL, Bit 1 = PC Low Byte (PC<7:0>). PCL, Bit 0 = PC Low Byte (PC<7:0>). PCL, Value on POR, BOR = 0000. PCL, Value on POR, BOR = 0000. PCL, Details on page: = 59, 66. TBLPTRU, Bit 7 = GLYPH<151>. TBLPTRU, Bit 6 = GLYPH<151>. TBLPTRU, Bit 5 = bit 21. TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nUpper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on POR, BOR = --00. TBLPTRU, Value on POR, BOR = 0000. TBLPTRU, Details on page: = 59, 88. TBLPTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>).",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nTBLPTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Value on POR, BOR = 0000. TBLPTRH, Value on POR, BOR = 0000. TBLPTRH, Details on page: = 59, 88. TBLPTRL, Bit 7 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer Low Byte",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\n(TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Value on POR, BOR = 0000. TBLPTRL, Value on POR, BOR = 0000. TBLPTRL, Details on page: = 59, 88. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nTABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on POR, BOR = 0000. TABLAT, Value on POR, BOR = 0000. TABLAT, Details on page: = 59, 88. PRODH, Bit 7 = Product Register High Byte. PRODH, Bit 6 = Product Register High Byte. PRODH, Bit 5 = Product Register High Byte. PRODH, Bit 4 = Product Register High Byte. PRODH, Bit 3 = Product Register High Byte. PRODH, Bit 2 = Product Register High Byte. PRODH, Bit 1 = Product Register High Byte. PRODH, Bit 0 = Product Register High Byte. PRODH, Value on POR, BOR = xxxx. PRODH, Value on POR, BOR = xxxx. PRODH, Details on page: = 59, 91. PRODL, Bit 7 = Product Register Low Byte. PRODL, Bit 6 = Product Register Low Byte. PRODL, Bit 5 = Product Register Low Byte. PRODL, Bit 4 = Product Register Low Byte. PRODL, Bit 3 = Product Register Low Byte. PRODL,",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nBit 2 = Product Register Low Byte. PRODL, Bit 1 = Product Register Low Byte. PRODL, Bit 0 = Product Register Low Byte. PRODL, Value on POR, BOR = xxxx xxxx. PRODL, Value on POR, BOR = . PRODL, Details on page: = 59, 91. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on POR, BOR = . INTCON, Details on page: = 59, 95. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nINTEDG2. INTCON2, Bit 3 = INTEDG3. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = INT3IP. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111 1111. INTCON2, Value on POR, BOR = . INTCON2, Details on page: = 59, 96. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = INT3IE. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = INT3IF. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 1100 0000. INTCON3, Value on POR, BOR = . INTCON3, Details on page: = 59, 97. INDF0, Bit 7 = Uses contents of FSR0",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nto address data memory GLYPH<150> value of FSR0 not changed (not a physical register). INDF0, Bit 6 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 not changed (not a physical register). INDF0, Bit 5 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 not changed (not a physical register). INDF0, Bit 4 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 not changed (not a physical register). INDF0, Bit 3 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 not changed (not a physical register). INDF0, Bit 2 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 not changed (not a physical register). INDF0, Bit 1 = Uses contents of FSR0 to address data memory GLYPH<150> value",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nof FSR0 not changed (not a physical register). INDF0, Bit 0 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 not changed (not a physical register). INDF0, Value on POR, BOR = N/A. INDF0, Value on POR, BOR = . INDF0, Details on page: = 59, 82. POSTINC0, Bit 7 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 6 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 5 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 4 = Uses contents of FSR0 to address data memory",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nGLYPH<150> value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 3 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 2 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 1 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 0 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-incremented (not a physical register). POSTINC0, Value on POR, BOR = N/A. POSTINC0, Value on POR, BOR = . POSTINC0, Details on page: = 59, 83.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nPOSTDEC0, Bit 7 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 6 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 5 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 4 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 3 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 2 = Uses contents of FSR0 to address data memory GLYPH<150> value of",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nFSR0 post-decremented (not a physical register). POSTDEC0, Bit 1 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 0 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 post-decremented (not a physical register). POSTDEC0, Value on POR, BOR = N/A. POSTDEC0, Value on POR, BOR = 59,. POSTDEC0, Details on page: = 83. PREINC0, Bit 7 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 6 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 5 = Uses contents of",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nFSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 4 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 3 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 2 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 1 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 0 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nregister). PREINC0, Value on POR, BOR = N/A. PREINC0, Value on POR, BOR = . PREINC0, Details on page: = 59, 83. PLUSW0, Bit 7 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Bit 6 = offset by W. PLUSW0, Bit 5 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Bit 4 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Bit 3 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nregister), value of FSR0. PLUSW0, Bit 2 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Bit 1 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Bit 0 = Uses contents of FSR0 to address data memory GLYPH<150> value of FSR0 pre-incremented (not a physical register), value of FSR0. PLUSW0, Value on POR, BOR = N/A. PLUSW0, Value on POR, BOR = 59,. PLUSW0, Details on page: = 83. FSR0H, Bit 7 = GLYPH<151>. FSR0H, Bit 6 = GLYPH<151>. FSR0H, Bit 5 = GLYPH<151>.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nFSR0H, Bit 4 = GLYPH<151>. FSR0H, Bit 3 = Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 2 = Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 1 = Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 0 = Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Value on POR, BOR = ---- xxxx. FSR0H, Value on POR, BOR = 59,. FSR0H, Details on page: = 82. FSR0L, Bit 7 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 6 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 5 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 4 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 3 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 2 = Indirect Data Memory Address Pointer 0 Low Byte.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nFSR0L, Bit 1 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 0 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Value on POR, BOR = xxxx. FSR0L, Value on POR, BOR = xxxx. FSR0L, Details on page: = 59, 82. WREG, Bit 7 = Working Register. WREG, Bit 6 = Working Register. WREG, Bit 5 = Working Register. WREG, Bit 4 = Working Register. WREG, Bit 3 = Working Register. WREG, Bit 2 = Working Register. WREG, Bit 1 = Working Register. WREG, Bit 0 = Working Register. WREG, Value on POR, BOR = xxxx xxxx. WREG, Value on POR, BOR = . WREG, Details on page: = 59. INDF1, Bit 7 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 not changed (not a physical register). INDF1, Bit 6 = Uses contents of",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nFSR1 to address data memory GLYPH<150> value of FSR1 not changed (not a physical register). INDF1, Bit 5 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 not changed (not a physical register). INDF1, Bit 4 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 not changed (not a physical register). INDF1, Bit 3 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 not changed (not a physical register). INDF1, Bit 2 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 not changed (not a physical register). INDF1, Bit 1 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 not changed (not a physical register). INDF1, Bit 0 = Uses contents of FSR1 to address data memory",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nGLYPH<150> value of FSR1 not changed (not a physical register). INDF1, Value on POR, BOR = N/A. INDF1, Value on POR, BOR = 59,. INDF1, Details on page: = 82. POSTINC1, Bit 7 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 6 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 5 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 4 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 3 = Uses",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\ncontents of FSR1 to address data memory GLYPH<150> value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 2 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 1 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 0 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-incremented (not a physical register). POSTINC1, Value on POR, BOR = N/A. POSTINC1, Value on POR, BOR = . POSTINC1, Details on page: = 59, 83. POSTDEC1, Bit 7 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-decremented",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\n(not a physical register). POSTDEC1, Bit 6 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 5 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 4 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 3 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 2 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 1 = Uses contents of FSR1 to address data memory",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nGLYPH<150> value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 0 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 post-decremented (not a physical register). POSTDEC1, Value on POR, BOR = N/A. POSTDEC1, Value on POR, BOR = 59,. POSTDEC1, Details on page: = 83. PREINC1, Bit 7 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 6 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 5 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register).",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nPREINC1, Bit 4 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 3 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 2 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 1 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 0 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register). PREINC1, Value on POR, BOR = N/A. PREINC1, Value on POR, BOR =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\n. PREINC1, Details on page: = 59, 83. PLUSW1, Bit 7 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 6 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 5 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 4 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 3 = Uses contents of FSR1 to address data memory",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nGLYPH<150> value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 2 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 1 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Bit 0 = Uses contents of FSR1 to address data memory GLYPH<150> value of FSR1 pre-incremented (not a physical register), value of FSR1 offset by W. PLUSW1, Value on POR, BOR = N/A. PLUSW1, Value on POR, BOR = . PLUSW1, Details on page: = 59, 83. FSR1H, Bit 7 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nGLYPH<151>. FSR1H, Bit 6 = GLYPH<151>. FSR1H, Bit 5 = GLYPH<151>. FSR1H, Bit 4 = GLYPH<151>. FSR1H, Bit 3 = Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 2 = Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 1 = Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 0 = Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Value on POR, BOR = ----. FSR1H, Value on POR, BOR = xxxx. FSR1H, Details on page: = 60, 82. FSR1L, Bit 7 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 6 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 5 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 4 = Indirect Data Memory Address Pointer 1 Low",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nByte. FSR1L, Bit 3 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 2 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 1 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 0 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Value on POR, BOR = xxxx xxxx. FSR1L, Value on POR, BOR = . FSR1L, Details on page: = 60, 82. BSR, Bit 7 = GLYPH<151>. BSR, Bit 6 = GLYPH<151>. BSR, Bit 5 = GLYPH<151>. BSR, Bit 4 = GLYPH<151>. BSR, Bit 3 = Bank Select Register. BSR, Bit 2 = Bank Select Register. BSR, Bit 1 = Bank Select Register. BSR, Bit 0 = Bank Select Register. BSR, Value on POR, BOR = ----. BSR, Value on POR, BOR =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\n0000. BSR, Details on page: = 60, 71. INDF2, Bit 7 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 not changed (not a physical register). INDF2, Bit 6 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 not changed (not a physical register). INDF2, Bit 5 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 not changed (not a physical register). INDF2, Bit 4 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 not changed (not a physical register). INDF2, Bit 3 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 not changed (not a physical register). INDF2, Bit 2 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 not changed (not a",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nphysical register). INDF2, Bit 1 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 not changed (not a physical register). INDF2, Bit 0 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 not changed (not a physical register). INDF2, Value on POR, BOR = N/A. INDF2, Value on POR, BOR = . INDF2, Details on page: = 60, 82. POSTINC2, Bit 7 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 6 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 5 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\npost-incremented (not a physical register). POSTINC2, Bit 4 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 3 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 2 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 1 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 0 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-incremented (not a physical register). POSTINC2, Value on POR, BOR = N/A.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nPOSTINC2, Value on POR, BOR = . POSTINC2, Details on page: = 60, 83 60, 83. POSTDEC2, Bit 7 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 6 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 5 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 4 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 3 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-decremented (not a physical",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nregister). POSTDEC2, Bit 2 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 1 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 0 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 post-decremented (not a physical register). POSTDEC2, Value on POR, BOR = N/A. POSTDEC2, Value on POR, BOR = . POSTDEC2, Details on page: = . PREINC2, Bit 7 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 6 = Uses contents of FSR2 to address data memory GLYPH<150> value of",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nFSR2 pre-incremented (not a physical register). PREINC2, Bit 5 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 4 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 3 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 2 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 1 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 0 = Uses contents of",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nFSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register). PREINC2, Value on POR, BOR = N/A. PREINC2, Value on POR, BOR = . PREINC2, Details on page: = 60, 83. PLUSW2, Bit 7 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register),. PLUSW2, Bit 6 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register),. PLUSW2, Bit 5 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register),. PLUSW2, Bit 4 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nregister),. PLUSW2, Bit 3 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register),. PLUSW2, Bit 2 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register),. PLUSW2, Bit 1 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register),. PLUSW2, Bit 0 = Uses contents of FSR2 to address data memory GLYPH<150> value of FSR2 pre-incremented (not a physical register),. PLUSW2, Value on POR, BOR = N/A. PLUSW2, Value on POR, BOR = . PLUSW2, Details on page: = 60, 83. FSR2H, Bit 7 = value of FSR2 offset by W GLYPH<151>",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nGLYPH<151> GLYPH<151> GLYPH<151> Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 6 = value of FSR2 offset by W GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 5 = value of FSR2 offset by W GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 4 = value of FSR2 offset by W GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 3 = value of FSR2 offset by W GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 2 = value of",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nFSR2 offset by W GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 1 = value of FSR2 offset by W GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 0 = value of FSR2 offset by W GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Value on POR, BOR = ----. FSR2H, Value on POR, BOR = xxxx. FSR2H, Details on page: = 60, 82. FSR2L, Bit 7 = Indirect Data GLYPH<151> GLYPH<151> GLYPH<151> N OV Z DC C. FSR2L, Bit 6 = Memory Address.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nFSR2L, Bit 5 = Pointer 2. FSR2L, Bit 4 = Low Byte. FSR2L, Bit 3 = Indirect Data GLYPH<151> GLYPH<151> GLYPH<151> N OV Z DC C. FSR2L, Bit 2 = Indirect Data GLYPH<151> GLYPH<151> GLYPH<151> N OV Z DC C. FSR2L, Bit 1 = Indirect Data GLYPH<151> GLYPH<151> GLYPH<151> N OV Z DC C. FSR2L, Bit 0 = Indirect Data GLYPH<151> GLYPH<151> GLYPH<151> N OV Z DC C. FSR2L, Value on POR, BOR = xxxx ---x. FSR2L, Value on POR, BOR = xxxx xxxx. FSR2L, Details on page: = 60, 82 60, 80. STATUS, Bit 7 = . STATUS, Bit 6 = . STATUS, Bit 5 = .",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\nSTATUS, Bit 4 = . STATUS, Bit 3 = . STATUS, Bit 2 = . STATUS, Bit 1 = . STATUS, Bit 0 = . STATUS, Value on POR, BOR = . STATUS, Value on POR, BOR = . STATUS, Details on page: = \nLegend:\n- x = unknown, u = unchanged, GLYPH<150> = unimplemented, q = value depends on condition\nNote",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\n1: The SBOREN bit is only available when the BOREN1:BOREN0 Configuration bits = 01 ; otherwise it is disabled and reads as GLYPH<145> 0 GLYPH<146>. See Section 4.4 GLYPH<147>Brown-out Reset (BOR)GLYPH<148> .\n2: These registers and/or bits are not implemented on 64-pin devices; read as GLYPH<145> 0 GLYPH<146>.\n3: The PLLEN bit is only available in specific oscillator configurations; otherwise, it is disabled and reads as GLYPH<145> 0 GLYPH<146>. See Section 2.6.4 GLYPH<147>PLL in INTOSC ModesGLYPH<148> .\n4: The RG5 bit is only available when Master Clear is disabled (MCLRE Configuration bit = 0 ); otherwise, RG5 reads as GLYPH<145> 0 GLYPH<146>. This bit is read-only.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY\n5: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as GLYPH<145> 0 GLYPH<146>.\n6: These registers are implemented but unused in 64-pin devices and may be used as general-purpose data RAM if required.",
    "TABLE 5-2:\nTMR0H, Bit 7 = Timer0 Register High Byte. TMR0H, Bit 6 = Timer0 Register High Byte. TMR0H, Bit 5 = Timer0 Register High Byte. TMR0H, Bit 4 = Timer0 Register High Byte. TMR0H, Bit 3 = Timer0 Register High Byte. TMR0H, Bit 2 = Timer0 Register High Byte. TMR0H, Bit 1 = Timer0 Register High Byte. TMR0H, Bit 0 = Timer0 Register High Byte. TMR0H, Value on POR, BOR = 0000 0000. TMR0H, Details on page: = 60, 132. TMR0L, Bit 7 = Timer0 Register Low Byte. TMR0L, Bit 6 = Timer0 Register Low Byte. TMR0L, Bit 5 = Timer0 Register Low Byte. TMR0L, Bit 4 = Timer0 Register Low Byte. TMR0L, Bit 3 = Timer0 Register Low Byte. TMR0L, Bit 2 = Timer0 Register Low Byte. TMR0L, Bit 1",
    "TABLE 5-2:\n= Timer0 Register Low Byte. TMR0L, Bit 0 = Timer0 Register Low Byte. TMR0L, Value on POR, BOR = xxxx xxxx. TMR0L, Details on page: = 60, 132. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = 1111 1111. T0CON, Details on page: = 60, 131. OSCCON, Bit 7 = IDLEN. OSCCON, Bit 6 = IRCF2. OSCCON, Bit 5 = IRCF1. OSCCON, Bit 4 = IRCF0. OSCCON, Bit 3 = OSTS. OSCCON, Bit 2 = IOFS. OSCCON, Bit 1 =",
    "TABLE 5-2:\nSCS1. OSCCON, Bit 0 = SCS0. OSCCON, Value on POR, BOR = 0100 q000. OSCCON, Details on page: = 38, 60. HLVDCON, Bit 7 = VDIRMAG. HLVDCON, Bit 6 = GLYPH<151>. HLVDCON, Bit 5 = IRVST. HLVDCON, Bit 4 = HLVDEN. HLVDCON, Bit 3 = HLVDL3. HLVDCON, Bit 2 = HLVDL2. HLVDCON, Bit 1 = HLVDL1. HLVDCON, Bit 0 = HLVDL0. HLVDCON, Value on POR, BOR = 0-00 0101. HLVDCON, Details on page: = 60, 251. WDTCON, Bit 7 = GLYPH<151>. WDTCON, Bit 6 = GLYPH<151>. WDTCON, Bit 5 = GLYPH<151>. WDTCON, Bit 4 = GLYPH<151>. WDTCON, Bit 3 =",
    "TABLE 5-2:\nGLYPH<151>. WDTCON, Bit 2 = GLYPH<151>. WDTCON, Bit 1 = GLYPH<151>. WDTCON, Bit 0 = SWDTEN. WDTCON, Value on POR, BOR = --- ---0. WDTCON, Details on page: = 60, 288. RCON, Bit 7 = IPEN. RCON, Bit 6 = SBOREN (1). RCON, Bit 5 = GLYPH<151>. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Value on POR, BOR = 0q-1 11q0. RCON, Details on page: = 52, 60, 107. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte.",
    "TABLE 5-2:\nTMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Value on POR, BOR = xxxx xxxx. TMR1H, Details on page: = 60, 137. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Value on POR, BOR = xxxx xxxx. TMR1L, Details on page: = 60, 137. T1CON, Bit",
    "TABLE 5-2:\n7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0000 0000. T1CON, Details on page: = 60, 135. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, Value on POR, BOR = 0000 0000. TMR2, Details on page: = 60, 141. PR2,",
    "TABLE 5-2:\nBit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111 1111. PR2, Details on page: = 60, 141. T2CON, Bit 7 = GLYPH<151>. T2CON, Bit 6 = T2OUTPS3. T2CON, Bit 5 = T2OUTPS2. T2CON, Bit 4 = T2OUTPS1. T2CON, Bit 3 = T2OUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000 0000. T2CON, Details on page: = 60, 141. SSPBUF,",
    "TABLE 5-2:\nBit 7 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 0 = MSSP Receive Buffer/Transmit Register. SSPBUF, Value on POR, BOR = xxxx xxxx. SSPBUF, Details on page: = 60, 158, 166. SSPADD, Bit 7 = MSSP Address Register in I 2 CGLYPH<153> Slave Mode. MSSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 6 = MSSP Address Register in I 2 CGLYPH<153> Slave Mode. MSSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 5 = MSSP Address Register in I 2",
    "TABLE 5-2:\nCGLYPH<153> Slave Mode. MSSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 4 = MSSP Address Register in I 2 CGLYPH<153> Slave Mode. MSSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 3 = MSSP Address Register in I 2 CGLYPH<153> Slave Mode. MSSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 2 = MSSP Address Register in I 2 CGLYPH<153> Slave Mode. MSSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 1 = MSSP Address Register in I 2 CGLYPH<153> Slave Mode. MSSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Bit 0 = MSSP Address Register in I 2 CGLYPH<153> Slave Mode. MSSP Baud Rate Reload Register in I 2 C Master Mode.. SSPADD, Value on POR, BOR = 0000 0000. SSPADD, Details on page: = 60, 166.",
    "TABLE 5-2:\nSSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Value on POR, BOR = 0000 0000. SSPSTAT, Details on page: = 60, 158, 167. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 = SSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3 = SSPM3. SSPCON1, Bit 2 = SSPM2. SSPCON1, Bit 1 = SSPM1. SSPCON1, Bit 0 = SSPM0. SSPCON1, Value on POR, BOR = 0000 0000. SSPCON1, Details on page: = 60, 159, 168. SSPCON2, Bit 7 = GCEN. SSPCON2,",
    "TABLE 5-2:\nBit 6 = ACKSTAT. SSPCON2, Bit 5 = ACKDT. SSPCON2, Bit 4 = ACKEN. SSPCON2, Bit 3 = RCEN. SSPCON2, Bit 2 = PEN. SSPCON2, Bit 1 = RSEN. SSPCON2, Bit 0 = SEN. SSPCON2, Value on POR, BOR = 0000 0000. SSPCON2, Details on page: = 60, 169. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte. ADRESH, Value on POR, BOR = xxxx xxxx. ADRESH, Details on page: = 61, 240. ADRESL, Bit 7 =",
    "TABLE 5-2:\nA/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Value on POR, BOR = xxxx xxxx. ADRESL, Details on page: = 61, 240. ADCON0, Bit 7 = GLYPH<151>. ADCON0, Bit 6 = GLYPH<151>. ADCON0, Bit 5 = CHS3. ADCON0, Bit 4 = CHS2. ADCON0, Bit 3 = CHS1. ADCON0, Bit 2 = CHS0. ADCON0, Bit 1 = GO/DONE. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR = --00",
    "TABLE 5-2:\n0000. ADCON0, Details on page: = 61, 231. ADCON1, Bit 7 = GLYPH<151>. ADCON1, Bit 6 = GLYPH<151>. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = --00 0000. ADCON1, Details on page: = 61, 232. ADCON2, Bit 7 = ADFM. ADCON2, Bit 6 = GLYPH<151>. ADCON2, Bit 5 = ACQT2. ADCON2, Bit 4 = ACQT1. ADCON2, Bit 3 = ACQT0. ADCON2, Bit 2 = ADCS2. ADCON2, Bit 1 = ADCS1. ADCON2, Bit 0 = ADCS0. ADCON2, Value on POR, BOR =",
    "TABLE 5-2:\n0-00 0000. ADCON2, Details on page: = 61, 233. CCPR1H, Bit 7 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Value on POR, BOR = xxxx xxxx. CCPR1H, Details on page: = 61, 152, 155. CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 Low",
    "TABLE 5-2:\nByte. CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Value on POR, BOR = xxxx xxxx. CCPR1L, Details on page: = 61, 152, 155. CCP1CON, Bit 7 = GLYPH<151>. CCP1CON, Bit 6 = GLYPH<151>. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 =",
    "TABLE 5-2:\nCCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = --00 0000. CCP1CON, Details on page: = 61, 147. CCPR2H, Bit 7 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 6 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 5 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 4 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 3 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 2 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 1 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 0 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Value on POR, BOR = xxxx xxxx. CCPR2H, Details on page: = 61, 152, 155. CCPR2L, Bit",
    "TABLE 5-2:\n7 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 6 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 5 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 4 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 3 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 2 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 1 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 0 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Value on POR, BOR = xxxx xxxx. CCPR2L, Details on page: = 61, 152, 155. CCP2CON, Bit 7 = GLYPH<151>. CCP2CON, Bit 6 = GLYPH<151>. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 =",
    "TABLE 5-2:\nCCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Value on POR, BOR = --00 0000. CCP2CON, Details on page: = 61, 147. CVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0. CVRCON, Value on POR, BOR = 0000 0000. CVRCON, Details on page: = 61, 247. CMCON, Bit 7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2.",
    "TABLE 5-2:\nCMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Value on POR, BOR = 0000 0111. CMCON, Details on page: = 61, 241. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit 2 = Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit 0 = Timer3 Register High Byte. TMR3H, Value on POR, BOR = xxxx xxxx. TMR3H, Details on page: = 61, 145. TMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte. TMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4",
    "TABLE 5-2:\n= Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register Low Byte. TMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = Timer3 Register Low Byte. TMR3L, Value on POR, BOR = xxxx xxxx. TMR3L, Details on page: = 61, 145. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000 0000. T3CON, Details on page: = 61, 143",
    "PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nLegend:\n- x = unknown, u = unchanged, GLYPH<150> = unimplemented, q = value depends on condition\nNote",
    "PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n1: The SBOREN bit is only available when the BOREN1:BOREN0 Configuration bits = 01 ; otherwise it is disabled and reads as GLYPH<145> 0 GLYPH<146>. See Section 4.4 GLYPH<147>Brown-out Reset (BOR)GLYPH<148> .\n2: These registers and/or bits are not implemented on 64-pin devices; read as GLYPH<145> 0 GLYPH<146>.\n3: The PLLEN bit is only available in specific oscillator configurations; otherwise, it is disabled and reads as GLYPH<145> 0 GLYPH<146>. See Section 2.6.4 GLYPH<147>PLL in INTOSC ModesGLYPH<148> .\n4: The RG5 bit is only available when Master Clear is disabled (MCLRE Configuration bit = 0 ); otherwise, RG5 reads as GLYPH<145> 0 GLYPH<146>. This bit is read-only.",
    "PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n5: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as GLYPH<145> 0 GLYPH<146>.\n6: These registers are implemented but unused in 64-pin devices and may be used as general-purpose data RAM if required.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nSPBRG1, Bit 7 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 6 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 5 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 4 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 3 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 2 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 1 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 0 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Value on POR, BOR = 0000. SPBRG1, Details = 0000. SPBRG1, on page: = 61, 201. RCREG1, Bit 7 = EUSART1 Receive Register. RCREG1, Bit 6 = EUSART1 Receive Register.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nRCREG1, Bit 5 = EUSART1 Receive Register. RCREG1, Bit 4 = EUSART1 Receive Register. RCREG1, Bit 3 = EUSART1 Receive Register. RCREG1, Bit 2 = EUSART1 Receive Register. RCREG1, Bit 1 = EUSART1 Receive Register. RCREG1, Bit 0 = EUSART1 Receive Register. RCREG1, Value on POR, BOR = 0000. RCREG1, Details = 0000. RCREG1, on page: = 61, 208. TXREG1, Bit 7 = EUSART1 Transmit Register. TXREG1, Bit 6 = EUSART1 Transmit Register. TXREG1, Bit 5 = EUSART1 Transmit Register. TXREG1, Bit 4 = EUSART1 Transmit Register. TXREG1, Bit 3 = EUSART1 Transmit Register. TXREG1, Bit 2 = EUSART1 Transmit Register. TXREG1, Bit 1 = EUSART1",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nTransmit Register. TXREG1, Bit 0 = EUSART1 Transmit Register. TXREG1, Value on POR, BOR = 0000. TXREG1, Details = 0000. TXREG1, on page: = 61, 206. TXSTA1, Bit 7 = CSRC. TXSTA1, Bit 6 = TX9. TXSTA1, Bit 5 = TXEN. TXSTA1, Bit 4 = SYNC. TXSTA1, Bit 3 = SENDB. TXSTA1, Bit 2 = BRGH. TXSTA1, Bit 1 = TRMT. TXSTA1, Bit 0 = TX9D. TXSTA1, Value on POR, BOR = 0000. TXSTA1, Details = 0010. TXSTA1, on page: = 61, 198. RCSTA1, Bit 7 = SPEN. RCSTA1, Bit 6 = RX9. RCSTA1, Bit 5 = SREN. RCSTA1, Bit 4 = CREN. RCSTA1, Bit 3 = ADDEN. RCSTA1, Bit 2 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nFERR. RCSTA1, Bit 1 = OERR. RCSTA1, Bit 0 = RX9D. RCSTA1, Value on POR, BOR = 0000. RCSTA1, Details = 000x. RCSTA1, on page: = 61, 199. IPR3, Bit 7 = GLYPH<151>. IPR3, Bit 6 = LCDIP. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = GLYPH<151>. IPR3, Bit 2 = GLYPH<151>. IPR3, Bit 1 = GLYPH<151>. IPR3, Bit 0 = GLYPH<151>. IPR3, Value on POR, BOR = -111. IPR3, Details = ----. IPR3, on page: = 61, 106. PIR3, Bit 7 = GLYPH<151>. PIR3, Bit 6 = LCDIF. PIR3, Bit 5",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n= RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = GLYPH<151>. PIR3, Bit 2 = GLYPH<151>. PIR3, Bit 1 = GLYPH<151>. PIR3, Bit 0 = GLYPH<151>. PIR3, Value on POR, BOR = -000. PIR3, Details = ----. PIR3, on page: = 61, 100. PIE3, Bit 7 = GLYPH<151>. PIE3, Bit 6 = LCDIE. PIE3, Bit 5 = RC2IE. PIE3, Bit 4 = TX2IE. PIE3, Bit 3 = GLYPH<151>. PIE3, Bit 2 = GLYPH<151>. PIE3, Bit 1 = GLYPH<151>. PIE3, Bit 0 = GLYPH<151>. PIE3, Value on POR, BOR = -000. PIE3, Details = ----. PIE3, on",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\npage: = 61, 103. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = GLYPH<151>. IPR2, Bit 4 = GLYPH<151>. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = 11--. IPR2, Details = 1111. IPR2, on page: = 61, 105. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = GLYPH<151>. PIR2, Bit 4 = GLYPH<151>. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2,",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nBit 0 = CCP2IF. PIR2, Value on POR, BOR = 00--. PIR2, Details = 0000. PIR2, on page: = 61, 99. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = GLYPH<151>. PIE2, Bit 4 = GLYPH<151>. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = 00--. PIE2, Details = 0000. PIE2, on page: = 61, 102. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111. IPR1, Details = 1111. IPR1, on page: = 61, 104. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000. PIR1, Details = 0000. PIR1, on page: = 61, 98. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nPIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = -000. PIE1, Details = 0000. PIE1, on page: = 61, 101. OSCTUNE, Bit 7 = INTSRC. OSCTUNE, Bit 6 = PLLEN (3). OSCTUNE, Bit 5 = GLYPH<151>. OSCTUNE, Bit 4 = TUN4. OSCTUNE, Bit 3 = TUN3. OSCTUNE, Bit 2 = TUN2. OSCTUNE, Bit 1 = TUN1. OSCTUNE, Bit 0 = TUN0. OSCTUNE, Value on POR, BOR = 00-0. OSCTUNE, Details = 0000. OSCTUNE, on page: = 35, 61. TRISJ (2), Bit 7 = PORTJ Data Direction Register. TRISJ",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n(2), Bit 6 = PORTJ Data Direction Register. TRISJ (2), Bit 5 = PORTJ Data Direction Register. TRISJ (2), Bit 4 = PORTJ Data Direction Register. TRISJ (2), Bit 3 = PORTJ Data Direction Register. TRISJ (2), Bit 2 = PORTJ Data Direction Register. TRISJ (2), Bit 1 = PORTJ Data Direction Register. TRISJ (2), Bit 0 = PORTJ Data Direction Register. TRISJ (2), Value on POR, BOR = 1111. TRISJ (2), Details = 1111. TRISJ (2), on page: = 62, 130. TRISH (2), Bit 7 = PORTH Data Direction Register. TRISH (2), Bit 6 = PORTH Data Direction Register. TRISH (2), Bit 5 = PORTH Data Direction Register. TRISH (2), Bit 4 = PORTH Data Direction Register. TRISH (2), Bit 3 = PORTH Data Direction Register. TRISH",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n(2), Bit 2 = PORTH Data Direction Register. TRISH (2), Bit 1 = PORTH Data Direction Register. TRISH (2), Bit 0 = PORTH Data Direction Register. TRISH (2), Value on POR, BOR = 1111. TRISH (2), Details = 1111. TRISH (2), on page: = 62, 128. TRISG, Bit 7 = GLYPH<151>. TRISG, Bit 6 = GLYPH<151>. TRISG, Bit 5 = GLYPH<151>. TRISG, Bit 4 = PORTG Data Direction Register. TRISG, Bit 3 = PORTG Data Direction Register. TRISG, Bit 2 = PORTG Data Direction Register. TRISG, Bit 1 = PORTG Data Direction Register. TRISG, Bit 0 = PORTG Data Direction Register. TRISG, Value on POR, BOR = ---1 1111. TRISG, Details = . TRISG, on page: = 62, 126. TRISF, Bit 7 = PORTF Data Direction Register.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nTRISF, Bit 6 = PORTF Data Direction Register. TRISF, Bit 5 = PORTF Data Direction Register. TRISF, Bit 4 = PORTF Data Direction Register. TRISF, Bit 3 = PORTF Data Direction Register. TRISF, Bit 2 = PORTF Data Direction Register. TRISF, Bit 1 = PORTF Data Direction Register. TRISF, Bit 0 = PORTF Data Direction Register. TRISF, Value on POR, BOR = 1111 1111. TRISF, Details = 62,. TRISF, on page: = 124. TRISE, Bit 7 = PORTE Data Direction Register. TRISE, Bit 6 = PORTE Data Direction Register. TRISE, Bit 5 = PORTE Data Direction Register. TRISE, Bit 4 = PORTE Data Direction Register. TRISE, Bit 3 = GLYPH<151>. TRISE, Bit 2 = GLYPH<151>. TRISE, Bit 1 = GLYPH<151>. TRISE, Bit 0 = GLYPH<151>. TRISE, Value on POR, BOR = 1111. TRISE, Details =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n----. TRISE, on page: = 62, 121. TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Value on POR, BOR = 1111 1111. TRISD, Details = 62,. TRISD, on page: = 119. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nTRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111 1111. TRISC, Details = 62,. TRISC, on page: = 117. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR = 1111 1111. TRISB, Details = . TRISB, on page: = 62, 114. TRISA, Bit 7 = TRISA7 (5). TRISA, Bit 6 = TRISA6 (5). TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nData Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = 1111 1111. TRISA, Details = 62,. TRISA, on page: = 111. LATJ (2), Bit 7 = LATJ Data Output Register. LATJ (2), Bit 6 = LATJ Data Output Register. LATJ (2), Bit 5 = LATJ Data Output Register. LATJ (2), Bit 4 = LATJ Data Output Register. LATJ (2), Bit 3 = LATJ Data Output Register. LATJ (2), Bit 2 = LATJ Data Output Register. LATJ (2), Bit 1 = LATJ Data Output Register. LATJ (2), Bit 0 = LATJ Data Output Register. LATJ (2), Value on POR, BOR = xxxx xxxx. LATJ",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n(2), Details = . LATJ (2), on page: = 62, 130. LATH (2), Bit 7 = LATH Data Output Register. LATH (2), Bit 6 = LATH Data Output Register. LATH (2), Bit 5 = LATH Data Output Register. LATH (2), Bit 4 = LATH Data Output Register. LATH (2), Bit 3 = LATH Data Output Register. LATH (2), Bit 2 = LATH Data Output Register. LATH (2), Bit 1 = LATH Data Output Register. LATH (2), Bit 0 = LATH Data Output Register. LATH (2), Value on POR, BOR = xxxx xxxx. LATH (2), Details = 62,. LATH (2), on page: = 128. LATG, Bit 7 = GLYPH<151>. LATG, Bit 6 = GLYPH<151>. LATG, Bit 5 = GLYPH<151>. LATG, Bit",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n4 = LATG Data Output Register. LATG, Bit 3 = LATG Data Output Register. LATG, Bit 2 = LATG Data Output Register. LATG, Bit 1 = LATG Data Output Register. LATG, Bit 0 = LATG Data Output Register. LATG, Value on POR, BOR = ---x xxxx. LATG, Details = 62,. LATG, on page: = 126. LATF, Bit 7 = LATF Data Output Register. LATF, Bit 6 = LATF Data Output Register. LATF, Bit 5 = LATF Data Output Register. LATF, Bit 4 = LATF Data Output Register. LATF, Bit 3 = LATF Data Output Register. LATF, Bit 2 = LATF Data Output Register. LATF, Bit 1 = LATF Data Output Register. LATF, Bit 0 = LATF Data Output Register. LATF, Value on POR, BOR = xxxx xxxx. LATF, Details = . LATF, on page: = 62, 124.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nLATE, Bit 7 = LATE Data Output Register. LATE, Bit 6 = LATE Data Output Register. LATE, Bit 5 = LATE Data Output Register. LATE, Bit 4 = LATE Data Output Register. LATE, Bit 3 = GLYPH<151>. LATE, Bit 2 = GLYPH<151>. LATE, Bit 1 = GLYPH<151>. LATE, Bit 0 = GLYPH<151>. LATE, Value on POR, BOR = xxxx ----. LATE, Details = 62,. LATE, on page: = 121. LATD, Bit 7 = LATD Data Output Register. LATD, Bit 6 = LATD Data Output Register. LATD, Bit 5 = LATD Data Output Register. LATD, Bit 4 = LATD Data Output Register. LATD, Bit 3 = LATD Data Output Register. LATD, Bit 2 = LATD Data Output Register. LATD, Bit 1 = LATD Data Output Register. LATD, Bit 0 = LATD Data Output",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nRegister. LATD, Value on POR, BOR = xxxx xxxx. LATD, Details = 62,. LATD, on page: = 119. LATC, Bit 7 = LATC Data Output Register. LATC, Bit 6 = LATC Data Output Register. LATC, Bit 5 = LATC Data Output Register. LATC, Bit 4 = LATC Data Output Register. LATC, Bit 3 = LATC Data Output Register. LATC, Bit 2 = LATC Data Output Register. LATC, Bit 1 = LATC Data Output Register. LATC, Bit 0 = LATC Data Output Register. LATC, Value on POR, BOR = xxxx xxxx. LATC, Details = . LATC, on page: = 62, 117. LATB, Bit 7 = LATB Data Output Register. LATB, Bit 6 = LATB Data Output Register. LATB, Bit 5 = LATB Data Output Register. LATB, Bit 4 = LATB Data Output Register. LATB, Bit 3 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nLATB Data Output Register. LATB, Bit 2 = LATB Data Output Register. LATB, Bit 1 = LATB Data Output Register. LATB, Bit 0 = LATB Data Output Register. LATB, Value on POR, BOR = xxxx xxxx. LATB, Details = 62,. LATB, on page: = 114. LATA, Bit 7 = LATA7 (5) LATA6 (5) LATA Data Output Register. LATA, Bit 6 = LATA7 (5) LATA6 (5) LATA Data Output Register. LATA, Bit 5 = LATA7 (5) LATA6 (5) LATA Data Output Register. LATA, Bit 4 = LATA7 (5) LATA6 (5) LATA Data Output Register. LATA, Bit 3 = LATA7 (5) LATA6 (5) LATA Data Output Register. LATA, Bit 2 = LATA7 (5) LATA6 (5) LATA Data Output Register.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nLATA, Bit 1 = LATA7 (5) LATA6 (5) LATA Data Output Register. LATA, Bit 0 = LATA7 (5) LATA6 (5) LATA Data Output Register. LATA, Value on POR, BOR = xxxx xxxx. LATA, Details = 62,. LATA, on page: = 111. PORTJ (2), Bit 7 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (2), Bit 6 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (2), Bit 5 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (2), Bit 4 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (2), Bit 3 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (2), Bit 2 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (2), Bit 1 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (2), Bit 0 = Read",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nPORTJ pins, Write PORTJ Data Latch. PORTJ (2), Value on POR, BOR = xxxx xxxx. PORTJ (2), Details = . PORTJ (2), on page: = 62, 130. PORTH (2), Bit 7 = Read PORTH pins, Write PORTH Data Latch. PORTH (2), Bit 6 = Read PORTH pins, Write PORTH Data Latch. PORTH (2), Bit 5 = Read PORTH pins, Write PORTH Data Latch. PORTH (2), Bit 4 = Read PORTH pins, Write PORTH Data Latch. PORTH (2), Bit 3 = Read PORTH pins, Write PORTH Data Latch. PORTH (2), Bit 2 = Read PORTH pins, Write PORTH Data Latch. PORTH (2), Bit 1 = Read PORTH pins, Write PORTH Data Latch. PORTH (2), Bit 0 = Read PORTH pins, Write PORTH Data Latch. PORTH (2), Value on POR, BOR = xxxx xxxx.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nPORTH (2), Details = . PORTH (2), on page: = 62, 128. PORTG, Bit 7 = GLYPH<151>. PORTG, Bit 6 = GLYPH<151>. PORTG, Bit 5 = RG5 (4). PORTG, Bit 4 = Read PORTG pins <4:0>, Write PORTG Data Latch <4:0>. PORTG, Bit 3 = Read PORTG pins <4:0>, Write PORTG Data Latch <4:0>. PORTG, Bit 2 = Read PORTG pins <4:0>, Write PORTG Data Latch <4:0>. PORTG, Bit 1 = Read PORTG pins <4:0>, Write PORTG Data Latch <4:0>. PORTG, Bit 0 = Read PORTG pins <4:0>, Write PORTG Data Latch <4:0>. PORTG, Value on POR, BOR = --xx xxxx. PORTG, Details = . PORTG, on page: = 62, 126.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nPORTF, Bit 7 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 6 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 5 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 4 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 3 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 2 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 1 = Read PORTF pins, Write PORTF Data Latch. PORTF, Bit 0 = Read PORTF pins, Write PORTF Data Latch. PORTF, Value on POR, BOR = xxxx. PORTF, Details = xxxx. PORTF, on page: = 62, 124. PORTE, Bit 7 = . PORTE, Bit 6 = . PORTE, Bit 5 = . PORTE, Bit 4 = . PORTE, Bit 3 = . PORTE, Bit 2 = . PORTE, Bit 1 = . PORTE, Bit 0 = . PORTE, Value on POR, BOR = xxxx. PORTE,",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nDetails = ----. PORTE, on page: = 62, 121. PORTD PORTC, Bit 7 = Read PORTE pins, Write PORTE Data Latch GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Read PORTD pins, Write PORTD Data Latch Read PORTC pins, Write PORTC Data Latch. PORTD PORTC, Bit 6 = Read PORTE pins, Write PORTE Data Latch GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Read PORTD pins, Write PORTD Data Latch Read PORTC pins, Write PORTC Data Latch. PORTD PORTC, Bit 5 = Read PORTE pins, Write PORTE Data Latch GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Read PORTD pins, Write PORTD Data Latch Read PORTC pins, Write PORTC Data Latch. PORTD PORTC, Bit 4 = Read PORTE pins, Write PORTE Data Latch GLYPH<151> GLYPH<151>",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nGLYPH<151> GLYPH<151> Read PORTD pins, Write PORTD Data Latch Read PORTC pins, Write PORTC Data Latch. PORTD PORTC, Bit 3 = Read PORTE pins, Write PORTE Data Latch GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Read PORTD pins, Write PORTD Data Latch Read PORTC pins, Write PORTC Data Latch. PORTD PORTC, Bit 2 = Read PORTE pins, Write PORTE Data Latch GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Read PORTD pins, Write PORTD Data Latch Read PORTC pins, Write PORTC Data Latch. PORTD PORTC, Bit 1 = Read PORTE pins, Write PORTE Data Latch GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Read PORTD pins, Write PORTD Data Latch Read PORTC pins, Write PORTC Data Latch. PORTD PORTC, Bit 0 = Read PORTE pins, Write PORTE",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nData Latch GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> Read PORTD pins, Write PORTD Data Latch Read PORTC pins, Write PORTC Data Latch. PORTD PORTC, Value on POR, BOR = xxxx. PORTD PORTC, Details = xxxx. PORTD PORTC, on page: = 62, 119 62, 117. PORTB, Bit 7 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 6 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 5 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 4 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 3 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 2 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 1 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 0 = Read PORTB pins, Write PORTB Data Latch. PORTB, Value on",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nPOR, BOR = xxxx. PORTB, Details = xxxx. PORTB, on page: = 62, 114. PORTA, Bit 7 = RA7 (5) RA6 (5) Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 6 = RA7 (5) RA6 (5) Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 5 = RA7 (5) RA6 (5) Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 4 = RA7 (5) RA6 (5) Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 3 = RA7 (5) RA6 (5) Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 2 = RA7 (5) RA6 (5) Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 1 = RA7 (5) RA6 (5) Read PORTA pins, Write PORTA Data Latch. PORTA, Bit 0 = RA7 (5) RA6",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n(5) Read PORTA pins, Write PORTA Data Latch. PORTA, Value on POR, BOR = xx0x. PORTA, Details = 0000. PORTA, on page: = 62, 111\nLegend: x = unknown, u = unchanged, GLYPH<150> = unimplemented, q = value depends on condition",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nNote 1: The SBOREN bit is only available when the BOREN1:BOREN0 Configuration bits = 01 ; otherwise it is disabled and reads as GLYPH<145> 0 GLYPH<146>. See Section 4.4 GLYPH<147>Brown-out Reset (BOR)GLYPH<148> .\n2: These registers and/or bits are not implemented on 64-pin devices; read as GLYPH<145> 0 GLYPH<146>.\n3: The PLLEN bit is only available in specific oscillator configurations; otherwise, it is disabled and reads as GLYPH<145> 0 GLYPH<146>. See Section 2.6.4 GLYPH<147>PLL in INTOSC ModesGLYPH<148> .\n4: The RG5 bit is only available when Master Clear is disabled (MCLRE Configuration bit = 0 ); otherwise, RG5 reads as GLYPH<145> 0 GLYPH<146>. This bit is read-only.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n5: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as GLYPH<145> 0 GLYPH<146>.\n6: These registers are implemented but unused in 64-pin devices and may be used as general-purpose data RAM if required.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n, Bit 7 = SPBRGH1 EUSART1 Baud Rate Generator Register High Byte. , Bit 6 = SPBRGH1 EUSART1 Baud Rate Generator Register High Byte. , Bit 5 = SPBRGH1 EUSART1 Baud Rate Generator Register High Byte. , Bit 4 = SPBRGH1 EUSART1 Baud Rate Generator Register High Byte. , Bit 3 = SPBRGH1 EUSART1 Baud Rate Generator Register High Byte. , Bit 2 = SPBRGH1 EUSART1 Baud Rate Generator Register High Byte. , Bit 1 = SPBRGH1 EUSART1 Baud Rate Generator Register High Byte. , Bit 0 = SPBRGH1 EUSART1 Baud Rate Generator Register High Byte. , Value on POR, BOR = 0000 0000. , Details on page: = 62, 201. BAUDCON1, Bit 7 = ABDOVF. BAUDCON1, Bit 6 = RCIDL. BAUDCON1, Bit 5 = GLYPH<151>. BAUDCON1, Bit 4 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nSCKP. BAUDCON1, Bit 3 = BRG16. BAUDCON1, Bit 2 = GLYPH<151>. BAUDCON1, Bit 1 = WUE. BAUDCON1, Bit 0 = ABDEN. BAUDCON1, Value on POR, BOR = 01-0 0-00. BAUDCON1, Details on page: = 62, 200. LCDDATA23 (6), Bit 7 = S47C3. LCDDATA23 (6), Bit 6 = S46C3. LCDDATA23 (6), Bit 5 = S45C3. LCDDATA23 (6), Bit 4 = S44C3. LCDDATA23 (6), Bit 3 = S43C3. LCDDATA23 (6), Bit 2 = S42C3. LCDDATA23 (6), Bit 1 = S41C3. LCDDATA23 (6), Bit 0 = S40C3. LCDDATA23 (6), Value on POR, BOR =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nxxxx xxxx. LCDDATA23 (6), Details on page: = 63, 261. LCDDATA22 (6), Bit 7 = S39C3. LCDDATA22 (6), Bit 6 = S38C3. LCDDATA22 (6), Bit 5 = S37C3. LCDDATA22 (6), Bit 4 = S36C3. LCDDATA22 (6), Bit 3 = S35C3. LCDDATA22 (6), Bit 2 = S34C3. LCDDATA22 (6), Bit 1 = S33C3. LCDDATA22 (6), Bit 0 = S32C3. LCDDATA22 (6), Value on POR, BOR = xxxx xxxx. LCDDATA22 (6), Details on page: = 63, 261. LCDDATA21, Bit 7 = S31C3. LCDDATA21, Bit 6 = S30C3. LCDDATA21, Bit 5 = S29C3.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nLCDDATA21, Bit 4 = S28C3. LCDDATA21, Bit 3 = S27C3. LCDDATA21, Bit 2 = S26C3. LCDDATA21, Bit 1 = S25C3. LCDDATA21, Bit 0 = S24C3. LCDDATA21, Value on POR, BOR = xxxx xxxx. LCDDATA21, Details on page: = 63, 261. LCDDATA20, Bit 7 = S23C3. LCDDATA20, Bit 6 = S22C3. LCDDATA20, Bit 5 = S21C3. LCDDATA20, Bit 4 = S20C3. LCDDATA20, Bit 3 = S19C3. LCDDATA20, Bit 2 = S18C3. LCDDATA20, Bit 1 = S17C3. LCDDATA20, Bit 0 = S16C3. LCDDATA20, Value on POR, BOR = xxxx xxxx. LCDDATA20, Details on page: = 63,",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n261. LCDDATA19, Bit 7 = S15C3. LCDDATA19, Bit 6 = S14C3. LCDDATA19, Bit 5 = S13C3. LCDDATA19, Bit 4 = S12C3. LCDDATA19, Bit 3 = S11C3. LCDDATA19, Bit 2 = S10C3. LCDDATA19, Bit 1 = S09C3. LCDDATA19, Bit 0 = S08C3. LCDDATA19, Value on POR, BOR = xxxx xxxx. LCDDATA19, Details on page: = 63, 261. LCDDATA18, Bit 7 = S07C3. LCDDATA18, Bit 6 = S06C3. LCDDATA18, Bit 5 = S05C3. LCDDATA18, Bit 4 = S04C3. LCDDATA18, Bit 3 = S03C3. LCDDATA18, Bit 2 = S02C3. LCDDATA18, Bit 1",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n= S01C3. LCDDATA18, Bit 0 = S00C3. LCDDATA18, Value on POR, BOR = xxxx xxxx. LCDDATA18, Details on page: = 63, 261. LCDDATA17 (6), Bit 7 = S47C2. LCDDATA17 (6), Bit 6 = S46C2. LCDDATA17 (6), Bit 5 = S45C2. LCDDATA17 (6), Bit 4 = S44C2. LCDDATA17 (6), Bit 3 = S43C2. LCDDATA17 (6), Bit 2 = S42C2. LCDDATA17 (6), Bit 1 = S41C2. LCDDATA17 (6), Bit 0 = S40C2. LCDDATA17 (6), Value on POR, BOR = xxxx xxxx. LCDDATA17 (6), Details on page: = 63, 261. LCDDATA16 (6), Bit 7 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nS39C2. LCDDATA16 (6), Bit 6 = S38C2. LCDDATA16 (6), Bit 5 = S37C2. LCDDATA16 (6), Bit 4 = S36C2. LCDDATA16 (6), Bit 3 = S35C2. LCDDATA16 (6), Bit 2 = S34C2. LCDDATA16 (6), Bit 1 = S33C2. LCDDATA16 (6), Bit 0 = S32C2. LCDDATA16 (6), Value on POR, BOR = xxxx xxxx. LCDDATA16 (6), Details on page: = 63, 261. LCDDATA15, Bit 7 = S31C2. LCDDATA15, Bit 6 = S30C2. LCDDATA15, Bit 5 = S29C2. LCDDATA15, Bit 4 = S28C2. LCDDATA15, Bit 3 = S27C2. LCDDATA15, Bit 2 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nS26C2. LCDDATA15, Bit 1 = S25C2. LCDDATA15, Bit 0 = S24C2. LCDDATA15, Value on POR, BOR = xxxx xxxx. LCDDATA15, Details on page: = 63, 261. LCDDATA14, Bit 7 = S23C2. LCDDATA14, Bit 6 = S22C2. LCDDATA14, Bit 5 = S21C2. LCDDATA14, Bit 4 = S20C2. LCDDATA14, Bit 3 = S19C2. LCDDATA14, Bit 2 = S18C2. LCDDATA14, Bit 1 = S17C2. LCDDATA14, Bit 0 = S16C2. LCDDATA14, Value on POR, BOR = xxxx xxxx. LCDDATA14, Details on page: = 63, 261. LCDDATA13, Bit 7 = S15C2. LCDDATA13, Bit 6 = S14C2. LCDDATA13, Bit 5",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n= S13C2. LCDDATA13, Bit 4 = S12C2. LCDDATA13, Bit 3 = S11C2. LCDDATA13, Bit 2 = S10C2. LCDDATA13, Bit 1 = S09C2. LCDDATA13, Bit 0 = S08C2. LCDDATA13, Value on POR, BOR = xxxx xxxx. LCDDATA13, Details on page: = 63, 261. LCDDATA12, Bit 7 = S07C2. LCDDATA12, Bit 6 = S06C2. LCDDATA12, Bit 5 = S05C2. LCDDATA12, Bit 4 = S04C2. LCDDATA12, Bit 3 = S03C2. LCDDATA12, Bit 2 = S02C2. LCDDATA12, Bit 1 = S01C2. LCDDATA12, Bit 0 = S00C2. LCDDATA12, Value on POR, BOR = xxxx",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nxxxx. LCDDATA12, Details on page: = 63, 261. LCDDATA11 (6), Bit 7 = S47C1. LCDDATA11 (6), Bit 6 = S46C1. LCDDATA11 (6), Bit 5 = S45C1. LCDDATA11 (6), Bit 4 = S44C1. LCDDATA11 (6), Bit 3 = S43C1. LCDDATA11 (6), Bit 2 = S42C1. LCDDATA11 (6), Bit 1 = S41C1. LCDDATA11 (6), Bit 0 = S40C1. LCDDATA11 (6), Value on POR, BOR = xxxx xxxx. LCDDATA11 (6), Details on page: = 63, 261. SPBRG2, Bit 7 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 6 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 5 = AUSART2 Baud Rate",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nGenerator Register. SPBRG2, Bit 4 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 3 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 2 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 1 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 0 = AUSART2 Baud Rate Generator Register. SPBRG2, Value on POR, BOR = 0000 0000. SPBRG2, Details on page: = 63, 220. RCREG2, Bit 7 = AUSART2 Receive Register. RCREG2, Bit 6 = AUSART2 Receive Register. RCREG2, Bit 5 = AUSART2 Receive Register. RCREG2, Bit 4 = AUSART2 Receive Register. RCREG2, Bit 3 = AUSART2 Receive Register. RCREG2, Bit 2 = AUSART2 Receive Register. RCREG2, Bit 1 = AUSART2 Receive Register. RCREG2, Bit 0 = AUSART2 Receive",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nRegister. RCREG2, Value on POR, BOR = 0000 0000. RCREG2, Details on page: = 63, 224. TXREG2, Bit 7 = AUSART2 Transmit Register. TXREG2, Bit 6 = AUSART2 Transmit Register. TXREG2, Bit 5 = AUSART2 Transmit Register. TXREG2, Bit 4 = AUSART2 Transmit Register. TXREG2, Bit 3 = AUSART2 Transmit Register. TXREG2, Bit 2 = AUSART2 Transmit Register. TXREG2, Bit 1 = AUSART2 Transmit Register. TXREG2, Bit 0 = AUSART2 Transmit Register. TXREG2, Value on POR, BOR = 0000 0000. TXREG2, Details on page: = 63, 222. TXSTA2, Bit 7 = CSRC. TXSTA2, Bit 6 = TX9. TXSTA2, Bit 5 = TXEN. TXSTA2, Bit 4 = SYNC. TXSTA2, Bit 3 = GLYPH<151>.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nTXSTA2, Bit 2 = BRGH. TXSTA2, Bit 1 = TRMT. TXSTA2, Bit 0 = TX9D. TXSTA2, Value on POR, BOR = 0000 -010. TXSTA2, Details on page: = 63, 218. RCSTA2, Bit 7 = SPEN. RCSTA2, Bit 6 = RX9. RCSTA2, Bit 5 = SREN. RCSTA2, Bit 4 = CREN. RCSTA2, Bit 3 = ADDEN. RCSTA2, Bit 2 = FERR. RCSTA2, Bit 1 = OERR. RCSTA2, Bit 0 = RX9D. RCSTA2, Value on POR, BOR = 0000 000x. RCSTA2, Details on page: = 63, 219. LCDDATA10 (6), Bit 7 = S39C1. LCDDATA10 (6), Bit 6 = S38C1. LCDDATA10 (6), Bit 5 = S37C1. LCDDATA10 (6),",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nBit 4 = S36C1. LCDDATA10 (6), Bit 3 = S35C1. LCDDATA10 (6), Bit 2 = S34C1. LCDDATA10 (6), Bit 1 = S33C1. LCDDATA10 (6), Bit 0 = S32C1. LCDDATA10 (6), Value on POR, BOR = xxxx xxxx. LCDDATA10 (6), Details on page: = 63, 261. LCDDATA9, Bit 7 = S31C1. LCDDATA9, Bit 6 = S30C1. LCDDATA9, Bit 5 = S29C1. LCDDATA9, Bit 4 = S28C1. LCDDATA9, Bit 3 = S27C1. LCDDATA9, Bit 2 = S26C1. LCDDATA9, Bit 1 = S25C1. LCDDATA9, Bit 0 = S24C1. LCDDATA9, Value on POR, BOR = xxxx xxxx.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nLCDDATA9, Details on page: = 63, 261. LCDDATA8, Bit 7 = S23C1. LCDDATA8, Bit 6 = S22C1. LCDDATA8, Bit 5 = S21C1. LCDDATA8, Bit 4 = S20C1. LCDDATA8, Bit 3 = S19C1. LCDDATA8, Bit 2 = S18C1. LCDDATA8, Bit 1 = S17C1. LCDDATA8, Bit 0 = S16C1. LCDDATA8, Value on POR, BOR = xxxx xxxx. LCDDATA8, Details on page: = 63, 261. LCDDATA7, Bit 7 = S15C1. LCDDATA7, Bit 6 = S14C1. LCDDATA7, Bit 5 = S13C1. LCDDATA7, Bit 4 = S12C1. LCDDATA7, Bit 3 = S11C1. LCDDATA7, Bit 2 = S10C1.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nLCDDATA7, Bit 1 = S09C1. LCDDATA7, Bit 0 = S08C1. LCDDATA7, Value on POR, BOR = xxxx xxxx. LCDDATA7, Details on page: = 63, 261. LCDDATA6, Bit 7 = S07C1. LCDDATA6, Bit 6 = S06C1. LCDDATA6, Bit 5 = S05C1. LCDDATA6, Bit 4 = S04C1. LCDDATA6, Bit 3 = S03C1. LCDDATA6, Bit 2 = S02C1. LCDDATA6, Bit 1 = S01C1. LCDDATA6, Bit 0 = S00C1. LCDDATA6, Value on POR, BOR = xxxx xxxx. LCDDATA6, Details on page: = 63, 261. LCDDATA5 (6), Bit 7 = S47C0. LCDDATA5 (6), Bit 6 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nS46C0. LCDDATA5 (6), Bit 5 = S45C0. LCDDATA5 (6), Bit 4 = S44C0. LCDDATA5 (6), Bit 3 = S43C0. LCDDATA5 (6), Bit 2 = S42C0. LCDDATA5 (6), Bit 1 = S41C0. LCDDATA5 (6), Bit 0 = S40C0. LCDDATA5 (6), Value on POR, BOR = xxxx xxxx. LCDDATA5 (6), Details on page: = 63, 261. LCDDATA4 (6), Bit 7 = S39C0. LCDDATA4 (6), Bit 6 = S38C0. LCDDATA4 (6), Bit 5 = S37C0. LCDDATA4 (6), Bit 4 = S36C0. LCDDATA4 (6), Bit 3 = S35C0. LCDDATA4 (6), Bit 2 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nS34C0. LCDDATA4 (6), Bit 1 = S33C0. LCDDATA4 (6), Bit 0 = S32C0. LCDDATA4 (6), Value on POR, BOR = xxxx xxxx. LCDDATA4 (6), Details on page: = 63, 261. LCDDATA3, Bit 7 = S31C0. LCDDATA3, Bit 6 = S30C0. LCDDATA3, Bit 5 = S29C0. LCDDATA3, Bit 4 = S28C0. LCDDATA3, Bit 3 = S27C0. LCDDATA3, Bit 2 = S26C0. LCDDATA3, Bit 1 = S25C0. LCDDATA3, Bit 0 = S24C0. LCDDATA3, Value on POR, BOR = xxxx xxxx. LCDDATA3, Details on page: = 63, 261. LCDDATA2, Bit 7 = S23C0. LCDDATA2, Bit 6 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nS22C0. LCDDATA2, Bit 5 = S21C0. LCDDATA2, Bit 4 = S20C0. LCDDATA2, Bit 3 = S19C0. LCDDATA2, Bit 2 = S18C0. LCDDATA2, Bit 1 = S17C0. LCDDATA2, Bit 0 = S16C0. LCDDATA2, Value on POR, BOR = xxxx xxxx. LCDDATA2, Details on page: = 63, 261. LCDDATA1, Bit 7 = S15C0. LCDDATA1, Bit 6 = S14C0. LCDDATA1, Bit 5 = S13C0. LCDDATA1, Bit 4 = S12C0. LCDDATA1, Bit 3 = S11C0. LCDDATA1, Bit 2 = S10C0. LCDDATA1, Bit 1 = S09C0. LCDDATA1, Bit 0 = S08C0. LCDDATA1, Value on POR,",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nBOR = xxxx xxxx. LCDDATA1, Details on page: = 63, 261. LCDDATA0, Bit 7 = S07C0. LCDDATA0, Bit 6 = S06C0. LCDDATA0, Bit 5 = S05C0. LCDDATA0, Bit 4 = S04C0. LCDDATA0, Bit 3 = S03C0. LCDDATA0, Bit 2 = S02C0. LCDDATA0, Bit 1 = S01C0. LCDDATA0, Bit 0 = S00C0. LCDDATA0, Value on POR, BOR = xxxx xxxx. LCDDATA0, Details on page: = 63, 261. LCDSE5 (2), Bit 7 = SE47. LCDSE5 (2), Bit 6 = SE46. LCDSE5 (2), Bit 5 = SE45. LCDSE5 (2), Bit 4 = SE44. LCDSE5 (2), Bit 3 = SE43.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nLCDSE5 (2), Bit 2 = SE42. LCDSE5 (2), Bit 1 = SE41. LCDSE5 (2), Bit 0 = SE40. LCDSE5 (2), Value on POR, BOR = 0000 0000. LCDSE5 (2), Details on page: = 64, 261. LCDSE4 (2), Bit 7 = SE39. LCDSE4 (2), Bit 6 = SE38. LCDSE4 (2), Bit 5 = SE37. LCDSE4 (2), Bit 4 = SE36. LCDSE4 (2), Bit 3 = SE35. LCDSE4 (2), Bit 2 = SE34. LCDSE4 (2), Bit 1 = SE33. LCDSE4 (2), Bit 0 = SE32. LCDSE4 (2), Value on POR, BOR = 0000 0000. LCDSE4 (2), Details on page: = 64, 260. LCDSE3, Bit 7 = SE31. LCDSE3, Bit 6 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nSE30. LCDSE3, Bit 5 = SE29. LCDSE3, Bit 4 = SE28. LCDSE3, Bit 3 = SE27. LCDSE3, Bit 2 = SE26. LCDSE3, Bit 1 = SE25. LCDSE3, Bit 0 = SE24. LCDSE3, Value on POR, BOR = 0000 0000. LCDSE3, Details on page: = 64, 260. LCDSE2, Bit 7 = SE23. LCDSE2, Bit 6 = SE22. LCDSE2, Bit 5 = SE21. LCDSE2, Bit 4 = SE20. LCDSE2, Bit 3 = SE19. LCDSE2, Bit 2 = SE18. LCDSE2, Bit 1 = SE17. LCDSE2, Bit 0 = SE16. LCDSE2, Value on POR, BOR = 0000 0000. LCDSE2, Details on page: = 64, 260. LCDSE1, Bit 7 = SE15. LCDSE1, Bit 6 = SE14. LCDSE1, Bit 5 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nSE13. LCDSE1, Bit 4 = SE12. LCDSE1, Bit 3 = SE11. LCDSE1, Bit 2 = SE10. LCDSE1, Bit 1 = SE9. LCDSE1, Bit 0 = SE8. LCDSE1, Value on POR, BOR = 0000 0000. LCDSE1, Details on page: = 64, 260. LCDSE0, Bit 7 = SE7. LCDSE0, Bit 6 = SE6. LCDSE0, Bit 5 = SE5. LCDSE0, Bit 4 = SE4. LCDSE0, Bit 3 = SE3. LCDSE0, Bit 2 = SE2. LCDSE0, Bit 1 = SE1. LCDSE0, Bit 0 = SE0. LCDSE0, Value on POR, BOR = 0000 0000. LCDSE0, Details on page: = 64, 260. LCDCON, Bit 7 = LCDEN. LCDCON, Bit 6 = SLPEN. LCDCON, Bit 5 = WERR. LCDCON, Bit 4 =",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\nGLYPH<151>. LCDCON, Bit 3 = CS1. LCDCON, Bit 2 = CS0. LCDCON, Bit 1 = LMUX1. LCDCON, Bit 0 = LMUX0. LCDCON, Value on POR, BOR = 000- 0000. LCDCON, Details on page: = 64, 258. LCDPS, Bit 7 = WFT. LCDPS, Bit 6 = BIASMD. LCDPS, Bit 5 = LCDA. LCDPS, Bit 4 = WA. LCDPS, Bit 3 = LP3. LCDPS, Bit 2 = LP2. LCDPS, Bit 1 = LP1. LCDPS, Bit 0 = LP0. LCDPS, Value on POR, BOR = 0000 0000. LCDPS, Details on page: = 64, 259\nLegend:\n- x = unknown, u = unchanged, GLYPH<150> = unimplemented, q = value depends on condition\nNote",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n1: The SBOREN bit is only available when the BOREN1:BOREN0 Configuration bits = 01 ; otherwise it is disabled and reads as GLYPH<145> 0 GLYPH<146>. See Section 4.4 GLYPH<147>Brown-out Reset (BOR)GLYPH<148> .\n2: These registers and/or bits are not implemented on 64-pin devices; read as GLYPH<145> 0 GLYPH<146>.\n3: The PLLEN bit is only available in specific oscillator configurations; otherwise, it is disabled and reads as GLYPH<145> 0 GLYPH<146>. See Section 2.6.4 GLYPH<147>PLL in INTOSC ModesGLYPH<148> .\n4: The RG5 bit is only available when Master Clear is disabled (MCLRE Configuration bit = 0 ); otherwise, RG5 reads as GLYPH<145> 0 GLYPH<146>. This bit is read-only.",
    "TABLE 5-2: PIC18F6390/6490/8390/8490 REGISTER FILE SUMMARY (CONTINUED)\n5: RA6/RA7 and their associated latch and direction bits are individually configured as port pins based on various primary oscillator modes. When disabled, these bits read as GLYPH<145> 0 GLYPH<146>.\n6: These registers are implemented but unused in 64-pin devices and may be used as general-purpose data RAM if required.",
    "5.3.5 STATUS REGISTER\nThe STATUS register, shown in Register 5-2, contains the arithmetic status of the ALU. As with any other SFR, it can be the operand for any instruction.\nIt is recommended that only BCF BSF SWAPF MOVFF , , , and MOVWF instructions are used to alter the STATUS register, because these instructions do not affect the Z, C, DC, OV or N bits in the STATUS register.\nIf the STATUS register is the destination for an instruction that affects the Z, DC, C, OV or N bits, the results of the  instruction  are  not  written;  instead,  the  status  is updated according to the instruction performed. Therefore, the result of an instruction with the STATUS register as its destination may be different than intended. As an example, CLRF STATUS will set the Z bit and leave the remaining Status bits unchanged (GLYPH<145> 000u u1uu GLYPH<146> ).\nFor other instructions that do not affect Status bits, see the instruction set summaries  in Table 24-2 and Table 24-3.\nNote:\nThe C and DC bits operate as a borrow and digit borrow bit respectively, in subtraction.",
    "REGISTER 5-2: STATUS REGISTER\nGLYPH<151>, U-0 = GLYPH<151>. GLYPH<151>, U-0 = GLYPH<151>. GLYPH<151>, R/W-x = N. GLYPH<151>, R/W-x = OV. GLYPH<151>, R/W-x = Z. GLYPH<151>, R/W-x = DC (1). GLYPH<151>, R/W-x = C (2). bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 5-2: STATUS REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 4\nN: Negative bit\nThis bit is used for signed arithmetic (2GLYPH<146>s complement). It indicates whether the result was negative (ALU MSB = 1 ).\n1 = Result was negative\n0 = Result was positive",
    "bit 3 OV: Overflow bit\nThis bit is used for signed arithmetic (2GLYPH<146>s complement). It indicates an overflow of the 7-bit magnitude which causes the sign bit (bit 7) to change state.\n1 = Overflow occurred for signed arithmetic (in this arithmetic operation)\n0 = No overflow occurred",
    "bit 2 Z: Zero bit\n1 = The result of an arithmetic or logic operation is zero\n0 = The result of an arithmetic or logic operation is not zero",
    "bit 1 DC: Digit carry/borrow bit (1)\nFor ADDWF, ADDLW, SUBLW and SUBWF instructions:\n1 = A carry-out from the 4th low-order bit of the result occurred\n0 = No carry-out from the 4th low-order bit of the result",
    "bit 0 C: Carry/borrow bit\n(2)\nFor ADDWF, ADDLW, SUBLW and SUBWF instructions:\n1 = A carry-out from the Most Significant bit of the result occurred\n0 = No carry-out from the Most Significant bit of the result occurred\nNote 1: For borrow, the polarity is reversed. A subtraction is executed by adding the 2GLYPH<146>s complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either bit 4 or bit 3 of the source register.\n2: For borrow, the polarity is reversed. A subtraction is executed by adding the 2GLYPH<146>s complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either the high or low-order bit of the source register.",
    "5.4 Data Addressing Modes\nNote:\nThe execution of some instructions in the core  PIC18  instruction  set  are  changed when the PIC18 extended instruction set is enabled. See Section 5.6 GLYPH<147>Data Memory and  the  Extended  Instruction  SetGLYPH<148> for more information.\nWhile the program memory can be addressed in only one way GLYPH<150> through the program counter GLYPH<150> information in the data memory space can be addressed in several ways. For most instructions, the addressing mode is fixed. Other instructions may use up to three modes, depending on which operands are used and whether or not the extended instruction set is enabled.\nThe addressing modes are:\nGLYPH<149> Inherent\nGLYPH<149> Literal\nGLYPH<149> Direct\nGLYPH<149> Indirect\nAn additional addressing mode, Indexed Literal Offset, is available  when  the  extended  instruction  set  is enabled (XINST Configuration bit = 1 ). Its operation is discussed in greater detail in Section 5.6.1 GLYPH<147>Indexed Addressing With Literal OffsetGLYPH<148> .",
    "5.4.1 INHERENT AND LITERAL ADDRESSING\nMany  PIC18  control  instructions  do  not  need  any argument at all; they either perform an operation that globally affects the device, or they operate implicitly on one  register. This  addressing  mode  is  known  as Inherent Addressing. Examples include SLEEP RESET , and DAW .\nOther instructions work in a similar way but require an additional  explicit  argument  in  the  opcode.  This  is known  as  Literal  Addressing  mode,  because  they require some literal value as an argument. Examples include ADDLW and MOVLW ,  which respectively add or move a literal value to the W register. Other examples include CALL and GOTO , which include a 20-bit program memory address.",
    "5.4.2 DIRECT ADDRESSING\nDirect  Addressing  specifies  all  or  part  of  the  source and/or destination address of the operation within the opcode itself. The options are specified by the arguments accompanying the instruction.\nIn  the  core  PIC18  instruction  set,  bit-oriented  and byte-oriented instructions use some version of Direct Addressing by default. All of these instructions include some  8-bit  literal  address  as  their  Least  Significant Byte. This address specifies either a register address in one of the banks of data RAM ( Section 5.3.3 GLYPH<147>General\nPurpose Register FileGLYPH<148> ), or a location in the Access Bank  ( Section 5.3.2  GLYPH<147>Access  BankGLYPH<148> ) as  the  data source for the instruction.",
    "5.4.2 DIRECT ADDRESSING\nThe Access RAM bit GLYPH<145>aGLYPH<146> determines how the address is interpreted.  When  GLYPH<145>aGLYPH<146>  is  GLYPH<145> 1 GLYPH<146>, the  contents  of  the  BSR ( Section 5.3.1 GLYPH<147>Bank Select RegisterGLYPH<148> ) are used with the address to determine the complete 12-bit address of the register. When GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the address is interpreted as being a register in the Access Bank. Addressing that uses  the  Access  RAM  is  sometimes  also  known  as Direct Forced Addressing mode.\nA few instructions, such as MOVFF ,  include the entire 12-bit  address  (either  source  or  destination)  in  their op codes. In those cases, the BSR is ignored entirely.",
    "5.4.2 DIRECT ADDRESSING\nThe destination of the operationGLYPH<146>s results is determined by the destination bit GLYPH<145>dGLYPH<146>. When GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the results are stored back in the source register, overwriting its original contents. When GLYPH<145>dGLYPH<146> is  GLYPH<145> 0 GLYPH<146> , the results are stored in the  W  register.  Instructions  without  the  GLYPH<145>dGLYPH<146>  argument have a destination that is implicit in the instruction; their destination is either the target register being operated on, or the W register.",
    "5.4.3 INDIRECT ADDRESSING\nIndirect Addressing allows the user to access a location in  data memory without giving a fixed address in the instruction. This is done by using File Select Registers (FSRs) as pointers to the locations to be read or written to. Since the FSRs are themselves located in RAM as Special Function Registers, they can also be directly manipulated under program control. This makes FSRs very  useful  in  implementing  data  structures,  such  as tables and arrays in data memory.\nThe registers for Indirect Addressing are also implemented with Indirect File Operands (INDFs) that permit automatic manipulation of the pointer value with auto-incrementing, auto-decrementing or offsetting with another value. This allows for efficient code using loops, such as the example of clearing an entire RAM bank in Example 5-5. It also enables users to perform Indexed Addressing and other Stack Pointer operations for program memory in data memory.",
    "EXAMPLE 5-5:\nHOW TO CLEAR RAM (BANK 1) USING INDIRECT ADDRESSING\nNEXT, 1 = LFSR CLRF. NEXT, 2 = FSR0, 100h POSTINC0. NEXT, 3 = ; ; Clear INDF ; register then ; inc pointer. , 1 = BTFSS. , 2 = FSR0H, 1. , 3 = ; All done with ; Bank1?. , 1 = BRA. , 2 = NEXT. , 3 = ; NO, clear next. CONTINUE, 1 = CONTINUE. CONTINUE, 2 = CONTINUE. CONTINUE, 3 = ; YES, continue",
    "5.4.3.1 FSR Registers and the INDF Operand\nAt  the  core  of  Indirect  Addressing  are  three  sets  of registers: FSR0, FSR1 and FSR2. Each represents a pair  of  8-bit  registers,  FSRnH  and  FSRnL.  The  four upper bits of the FSRnH register are not used, so each FSR pair holds a 12-bit value. This represents a value that can address the entire range of the data memory in a linear fashion. The FSR register pairs, then, serve as pointers to data memory locations.\nmapped  in  the  SFR  space  but  are  not  physically implemented. Reading or writing to a particular INDF register actually accesses  its corresponding FSR register pair. A  read from INDF1, for example, reads the data at the address indicated by FSR1H:FSR1L. Instructions that use the INDF registers as operands actually use the contents of their corresponding FSR as a pointer to the instructionGLYPH<146>s target. The INDF operand is just a convenient way of using the pointer.",
    "5.4.3.1 FSR Registers and the INDF Operand\nIndirect  Addressing  is  accomplished  with  a  set  of Indirect File Operands, INDF0 through INDF2. These can  be  thought  of  as  GLYPH<147>virtualGLYPH<148> registers:  they  are\nBecause Indirect Addressing uses a full 12-bit address, data RAM banking is not necessary. Thus, the current contents of the BSR and the Access RAM bit have no effect on determining the target address.",
    "5.4.3.3 Operations by FSRs on FSRs\nIn addition to the INDF operand, each FSR register pair also has four additional indirect operands. Like INDF, these  are  GLYPH<147>virtualGLYPH<148>  registers  that  cannot  be  indirectly read or written to. Accessing these registers actually accesses  the  associated  FSR  register  pair,  but  also performs a specific action on its stored value. They are:\nGLYPH<149> POSTDEC: accesses the FSR value, then automatically decrements it by GLYPH<145> 1 GLYPH<146> afterwards\nGLYPH<149> POSTINC: accesses the FSR value, then automatically increments it by GLYPH<145> 1 GLYPH<146> afterwards\nGLYPH<149> PREINC: increments the FSR value by GLYPH<145> 1 GLYPH<146>, then uses it in the operation\nGLYPH<149> PLUSW: adds the signed value of the W register (range of -127 to 128) to that of the FSR and uses the new value in the operation.",
    "5.4.3.3 Operations by FSRs on FSRs\nIn  this  context,  accessing  an  INDF  register  uses  the value  in  the  FSR  registers  without  changing  them. Similarly, accessing a PLUSW register gives the FSR value offset by the value in the W register; neither value is  actually  changed  in  the  operation.  Accessing  the other  virtual  registers  changes  the  value  of  the  FSR registers.\nOperations  on  the  FSRs  with  POSTDEC,  POSTINC and PREINC affect the entire register pair; that is, rollovers of the FSRnL register from FFh to 00h carry over to  the  FSRnH register. On the other hand, results of these operations do not change the value of any flags in the STATUS register (e.g., Z, N, OV, etc.).\nThe PLUSW register can be used to implement a form of Indexed Addressing in the data memory space. By manipulating  the  value  in  the  W  register,  users  can reach  addresses  that  are  fixed  offsets  from  pointer addresses. In some applications, this can be used to implement  some  powerful  program  control  structure, such as software stacks, inside of data memory.",
    "5.4.3.3 Operations by FSRs on FSRs\nIndirect Addressing operations that target other FSRs or virtual registers represent special cases. For example, using an FSR to point to one of the virtual registers will  not  result  in  successful  operations.  As  a  specific case, assume that FSR0H:FSR0L contains FE7h, the address of INDF1. Attempts to read the value of the INDF1,  using  INDF0  as  an  operand,  will  return  00h. Attempts  to  write  to  INDF1,  using  INDF0  as  the operand, will result in a NOP .\nOn the other hand, using the virtual registers to write to an FSR pair may not occur as planned. In these cases, the value will be written to the FSR pair, but without any incrementing or decrementing. Thus, writing to INDF2 or POSTDEC2  will  write  the  same  value  to  the FSR2H:FSR2L.\nSince the FSRs are physical registers mapped in the SFR space, they can be manipulated through all direct operations.  Users  should  proceed  cautiously  when working  on  these  registers,  particularly  if  their  code uses Indirect Addressing.",
    "5.4.3.3 Operations by FSRs on FSRs\nSimilarly, operations by Indirect Addressing are generally permitted on all other SFRs. Users should exercise the appropriate caution that they do not inadvertently change settings that might affect the operation of the device.",
    "5.5 Program Memory and the Extended Instruction Set\nWhen using the extended instruction set, this addressing mode requires the following:\nThe operation of program memory is unaffected by the use of the extended instruction set.\nEnabling the extended instruction set adds five additional two-word  commands  to  the  existing  PIC18 instruction  set: ADDFSR , CALLW , MOVSF , MOVSS and SUBFSR . These instructions are executed as described in Section 5.2.4 GLYPH<147>Two-Word InstructionsGLYPH<148> .",
    "5.6 Data Memory and the Extended Instruction Set\nEnabling  the  PIC18  extended  instruction  set  (XINST Configuration  bit  = 1 ) significantly  changes  certain aspects of data memory and its addressing. Specifically, the use of the Access Bank for many of the core PIC18 instructions is different; this is due to the introduction  of  a  new  addressing  mode  for  the  data memory space. This mode also alters the behavior of Indirect  Addressing  using  FSR2  and  its  associated operands.\nWhat does not change is just as important. The size of the data memory space is unchanged, as well as its linear  addressing.  The  SFR  map  remains  the  same. Core PIC18 instructions can still operate in both Direct and  Indirect  Addressing  mode;  inherent  and  literal instructions do not change at all. Indirect Addressing with FSR0 and FSR1 also remains unchanged.",
    "5.6.1 INDEXED ADDRESSING WITH LITERAL OFFSET\nEnabling the PIC18 extended instruction set changes the  behavior  of  Indirect  Addressing  using  the  FSR2 register pair and its associated file operands. Under the proper  conditions,  instructions  that  use  the  Access Bank  GLYPH<150> that  is,  most  bit-oriented  and  byte-oriented instructions GLYPH<150> can invoke a form of Indexed Addressing using an offset specified in the instruction. This special addressing mode is known as Indexed Addressing with Literal Offset, or Indexed Literal Offset mode.\nGLYPH<149> The use of the Access Bank is forced (GLYPH<145>aGLYPH<146> = 0 ); and\nGLYPH<149> The file address argument is less than or equal to 5Fh.\nUnder these conditions, the file address of the instruction  is  not  interpreted  as  the  lower  byte  of  an address (used with the BSR in Direct Addressing), or as an 8-bit address in the Access Bank. Instead, the value is interpreted as an offset value to an Address Pointer specified by FSR2. The offset and the contents of FSR2 are added to obtain the target address of the operation.",
    "5.6.2 INSTRUCTIONS AFFECTED BY INDEXED LITERAL OFFSET MODE\nAny of the core PIC18 instructions that can use Direct Addressing  are  potentially  affected  by  the  Indexed Literal Offset Addressing  mode.  This  includes  all byte-oriented  and  bit-oriented  instructions,  or  almost one-half of the standard PIC18 instruction set. Instructions  that  only  use  Inherent  or  Literal  Addressing modes are unaffected.\nAdditionally, byte-oriented and bit-oriented instructions are not affected if they use the Access Bank (Access RAM bit is GLYPH<145> 1 GLYPH<146> ),  or  include a file address of 60h or above. Instructions  meeting  these  criteria  will  continue  to execute  as  before.  A  comparison  of  the  different possible addressing modes when the extended instruction set is enabled is shown in Figure 5-8.\nThose who desire to use byte-oriented or bit-oriented instructions in the Indexed Literal Offset mode should note the changes to assembler syntax for this mode. This  is  described  in  more  detail  in Section 24.2.1 GLYPH<147>Extended Instruction SyntaxGLYPH<148> .\nFIGURE 5-8:",
    "COMPARING ADDRESSING OPTIONS FOR BIT-ORIENTED AND BYTE-ORIENTED INSTRUCTIONS (EXTENDED INSTRUCTION SET ENABLED)\nEXAMPLE INSTRUCTION: ADDWF, f, d, a (Opcode: 0010 01da ffff ffff )",
    "When a = 0 and f \u2265 60h:\nThe  instruction executes  in Direct Forced mode. GLYPH<145>f GLYPH<146> is interpreted as a location in the Access  RAM  between  060h and FFFh. This is the same as locations F60h to FFFh (Bank 15) of data memory.\nLocations below 060h are not available in this addressing mode.",
    "When a = 0 and f \u2264 5Fh:\nThe instruction executes in Indexed Literal Offset mode. GLYPH<145>fGLYPH<146> is interpreted as an offset to the address  value  in  FSR2.  The two are added together to obtain the address of the target register for the instruction. The address  can  be  anywhere  in the data memory space.\nNote  that  in  this mode,  the correct syntax is now:\nADDWF [k], d where GLYPH<145>kGLYPH<146> is the same as GLYPH<145>fGLYPH<146>.",
    "When a = 1 (all values of f):\nThe  instruction executes  in Direct  mode  (also  known  as Direct Long mode). GLYPH<145> f GLYPH<146> is interpreted  as  a  location  in one of the 16 banks of the data memory  space.  The  bank  is designated by the Bank Select Register  (BSR).  The  address can  be  in  any  implemented bank in the data memory space.",
    "5.6.3 MAPPING THE ACCESS BANK IN INDEXED LITERAL OFFSET MODE\nThe  use  of  Indexed  Literal  Offset  Addressing  mode effectively changes how the lower part of Access RAM (00h to 5Fh) is mapped. Rather than containing just the contents of the bottom part of Bank 0, this mode maps the contents from Bank 0 and a user-defined GLYPH<147>windowGLYPH<148> that  can  be  located  anywhere  in  the  data  memory space. The value of FSR2 establishes the lower boundary of the addresses mapped into the window, while the upper  boundary  is  defined  by  FSR2  plus  95  (5Fh). Addresses in the Access RAM above 5Fh are mapped as previously described (see Section 5.3.2 GLYPH<147>Access BankGLYPH<148> ). An example of Access Bank remapping in this addressing mode is shown in Figure 5-9.",
    "5.6.3 MAPPING THE ACCESS BANK IN INDEXED LITERAL OFFSET MODE\nRemapping of the Access Bank applies only to operations using the Indexed Literal Offset mode. Operations that use the BSR (Access RAM bit is GLYPH<145> 1 GLYPH<146>)  will continue to  use  Direct  Addressing  as  before.  Any  indirect  or indexed operation that explicitly uses any of the indirect file operands (including FSR2) will continue to operate as  standard  Indirect  Addressing.  Any  instruction  that uses the Access Bank, but includes a register address of  greater than 05Fh, will use Direct Addressing and the normal Access Bank map.",
    "5.6.4 BSR IN INDEXED LITERAL OFFSET MODE\nAlthough  the  Access  Bank  is  remapped  when  the extended instruction set is enabled, the operation of the BSR remains unchanged. Direct Addressing, using the BSR to select the data memory bank, operates in the same manner as previously described.",
    "6.0 FLASH PROGRAM MEMORY\nIn PIC18F6390/6490/8390/8490 devices, the program memory is implemented as read-only Flash memory. It is  readable  over  the  entire  VDD  range  during  normal operation. A read from program memory is executed on one byte at a time.",
    "6.1 Table Reads\nFor PIC18 devices, there are two operations that allow the  processor  to  move  bytes  between  the  program memory space and the data RAM: table read ( TBLRD ) and table write ( TBLWT ).\nTable  read  operations  retrieve  data  from  program memory  and  place  it  into  the  data  RAM  space. Figure 6-1  shows  the  operation  of  a  table  read  with program memory and data RAM.\nThe program memory space is 16 bits wide, while the data RAM space is 8 bits wide. Table reads and table writes move data between these two memory spaces through an 8-bit register, TABLAT.",
    "FIGURE 6-1: TABLE READ OPERATION\nTable  reads  work  with  byte  entities.  A  table  block containing data, rather than program instructions, is not required to be word-aligned. Therefore, a table block can start and end at any byte address.\nBecause the program memory cannot be written to or erased under normal operation, the TBLWT operation is not discussed here.\nNote 1: Although it cannot be used in PIC18F6390/6490/8390/8490 devices in normal operation, the TBLWT instruction is still implemented in the instruction set. Executing the instruction takes two instruction  cycles,  but  effectively  results in a NOP .\n2: The TBLWT instruction is available only in programming modes  and is  used  during In-Circuit Serial ProgrammingGLYPH<153> (ICSPGLYPH<153>).",
    "6.2 Control Registers\nTwo control registers are used in conjunction with the TBLRD instruction: the TABLAT  register and the TBLPTR register set.",
    "6.2.1 TABLE LATCH REGISTER (TABLAT)\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch register is used to hold 8-bit data during data transfers between program memory and data RAM.",
    "6.2.2 TABLE POINTER REGISTER (TBLPTR)\nThe Table Pointer register (TBLPTR) addresses a byte within  the  program  memory.  It  is  comprised  of  three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL).  Only  the  lower  six bits of TBLPTRU  are  used  with TBLPTRH  and TBLPTRL to form a 22-bit wide pointer.\nThe  contents  of TBLPTR  indicates  a  location in program memory space.  The low-order  21 bits  allow the  device  to  address  the  full  2  Mbytes  of  program memory  space.  The  22nd  bit  allows  access  to  the configuration space,  including  the device ID, user ID locations and the Configuration bits.\nThe TBLPTR register set is updated when executing a TBLRD in one of four ways, based on the instructionGLYPH<146>s arguments.  These  are  detailed  in  Table 6-1.  These operations  on  the  TBLPTR  only  affect  the  low-order 21 bits.",
    "TABLE POINTER OPERATIONS WITH TBLRD INSTRUCTIONS\nTBLRD*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+, Operation on Table Pointer = TBLPTR is incremented after the read. TBLRD*-, Operation on Table Pointer = TBLPTR is decremented after the read. TBLRD+*, Operation on Table Pointer = TBLPTR is incremented before the read",
    "6.3 Reading the Flash Program Memory\nThe TBLRD instruction  is  used  to  retrieve  data  from program memory and places it into data RAM. Table reads from program memory are performed one byte at a time.\nTBLPTR points to a byte address in program space. Executing TBLRD places  the  byte  pointed  to  into TABLAT. In addition, TBLPTR can be modified automatically for the next table read operation.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. Figure 6-2 shows  the  interface  between  the  internal  program memory and the TABLAT.\nA typical method for reading data from program memory is shown in Example 6-1.\nWhen a TBLRD is executed, all 22 bits of the TBLPTR determine  which  byte  is  read  from  program  memory into TABLAT.",
    "EXAMPLE 6-1: READING A FLASH PROGRAM MEMORY WORD\n, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF. , 2 = CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL. , 3 = ; ;. READ_WORD, 1 = . READ_WORD, 2 = . READ_WORD, 3 = . , 1 = TBLRD*+ MOVF MOVWF TBLRD*+ MOVF MOVWF. , 2 = TABLAT, W WORD_EVEN. , 3 = ; read into TABLAT and increment ; get data. , 1 = . , 2 = . , 3 = ; read into TABLAT and increment. , 1 = . , 2 = TABLAT, W WORD_ODD. , 3 = ; get data",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH READING PROGRAM FLASH MEMORY\nTBLPTRU, Bit 7 = GLYPH<151>. TBLPTRU, Bit 6 = GLYPH<151>. TBLPTRU, Bit 5 = bit 21. TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte. TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte. TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte. TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte. TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte. TBLPTRU, Reset Valueson Page = 59. TBLPTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 3 = Program Memory Table Pointer High Byte",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH READING PROGRAM FLASH MEMORY\n(TBLPTR<15:8>). TBLPTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Reset Valueson Page = 59. TBLPTRL, Bit 7 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer Low Byte",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH READING PROGRAM FLASH MEMORY\n(TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Reset Valueson Page = 59. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Reset Valueson Page = 59\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used during Flash access.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "7.1 Introduction\nAll PIC18 devices include an 8 x 8 hardware multiplier as part of the ALU. The multiplier performs an unsigned operation and yields a 16-bit result that is stored in the product register pair PRODH:PRODL. The multiplierGLYPH<146>s operation  does  not  affect  any  flags  in  the  STATUS register.\nMaking multiplication a hardware operation allows it to be completed in a single instruction cycle. This has the advantages  of  higher  computational  throughput  and reduced  code  size  for  multiplication  algorithms  and allows the PIC18 devices to be used in many applications previously reserved for digital signal processors.  A  comparison  of  various  hardware  and software multiply operations, along with the savings in memory and execution time, is shown in Table 7-1.",
    "7.2 Operation\nExample 7-1  shows  the  instruction  sequence  for  an 8 x 8  unsigned  multiplication.  Only  one  instruction  is required when one of the arguments is already loaded in the WREG register.\nExample 7-2 shows the sequence to do an 8 x 8 signed multiplication.  To  account  for  the  signed  bits  of  the arguments, each argumentGLYPH<146>s Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "7.2 Operation\n8 x 8 unsigned, Multiply Method = Without hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 13. 8 x 8 unsigned, Cycles (Max). = 69. 8 x 8 unsigned, Time.@40 MHz = 6.9 \u03bc s. 8 x 8 unsigned, Time.@10 MHz = 27.6 \u03bc s. 8 x 8 unsigned, Time.@4MHz = 69 \u03bc s. 8 x 8 unsigned, Multiply Method = Hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 1. 8 x 8 unsigned, Cycles (Max). = 1. 8 x 8 unsigned, Time.@40 MHz = 100 ns. 8 x 8 unsigned, Time.@10 MHz = 400 ns. 8 x 8 unsigned, Time.@4MHz = 1 \u03bc s. 8 x 8 signed, Multiply Method = Without hardware multiply. 8 x 8 signed, Program Memory (Words). = 33. 8 x 8 signed, Cycles (Max). = 91. 8 x 8 signed, Time.@40 MHz = 9.1 \u03bc s. 8 x 8 signed, Time.@10 MHz = 36.4 \u03bc s.",
    "7.2 Operation\n8 x 8 signed, Time.@4MHz = 91 \u03bc s. 8 x 8 signed, Multiply Method = Hardware multiply. 8 x 8 signed, Program Memory (Words). = 6. 8 x 8 signed, Cycles (Max). = 6. 8 x 8 signed, Time.@40 MHz = 600 ns. 8 x 8 signed, Time.@10 MHz = 2.4 \u03bc s. 8 x 8 signed, Time.@4MHz = 6 \u03bc s. 16 x 16 unsigned, Multiply Method = Without hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 21. 16 x 16 unsigned, Cycles (Max). = 242. 16 x 16 unsigned, Time.@40 MHz = 24.2 \u03bc s. 16 x 16 unsigned, Time.@10 MHz = 96.8 \u03bc s. 16 x 16 unsigned, Time.@4MHz = 242 \u03bc s. 16 x 16 unsigned, Multiply Method = Hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 28. 16 x 16 unsigned, Cycles (Max). = 28. 16 x 16 unsigned, Time.@40 MHz = 2.8 \u03bc",
    "7.2 Operation\ns. 16 x 16 unsigned, Time.@10 MHz = 11.2 \u03bc s. 16 x 16 unsigned, Time.@4MHz = 28 \u03bc s. 16 x 16 signed, Multiply Method = Without hardware multiply. 16 x 16 signed, Program Memory (Words). = 52. 16 x 16 signed, Cycles (Max). = 254. 16 x 16 signed, Time.@40 MHz = 25.4 \u03bc s. 16 x 16 signed, Time.@10 MHz = 102.6 \u03bc s. 16 x 16 signed, Time.@4MHz = 254 \u03bc s. 16 x 16 signed, Multiply Method = Hardware multiply. 16 x 16 signed, Program Memory (Words). = 35. 16 x 16 signed, Cycles (Max). = 40. 16 x 16 signed, Time.@40 MHz = 4.0 \u03bc s. 16 x 16 signed, Time.@10 MHz = 16.0 \u03bc s. 16 x 16 signed, Time.@4MHz = 40 \u03bc s",
    "7.2 Operation\nTABLE 7-1: PERFORMANCE COMPARISON FOR VARIOUS MULTIPLY OPERATIONS\n\nEXAMPLE 7-1:, 1 = 8 x 8 UNSIGNED MULTIPLY ROUTINE. MOVF ARG1, W MULWF ARG2, 1 = ; ; ARG1 * ARG2 -> ; PRODH:PRODL",
    "8 x 8 SIGNED MULTIPLY ROUTINE\nMOVF MULWF, 1 = ARG1, W ARG2. MOVF MULWF, 2 = ; ARG1 * ARG2 -> ; PRODH:PRODL. BTFSC SUBWF, 1 = ARG2, SB PRODH, F. BTFSC SUBWF, 2 = ; Test Sign Bit ; PRODH = PRODH. MOVF BTFSC SUBWF, 1 = ARG2, W ARG1, PRODH,. MOVF BTFSC SUBWF, 2 = ; Test Sign Bit ; PRODH = PRODH ; - ARG2. , 1 = SB F. , 2 = ",
    "PIC18F6390/6490/8390/8490\nExample 7-3  shows  the  sequence  to  do  a  16  x  16 unsigned multiplication. Equation 7-1 shows the algorithm that is used. The 32-bit result is stored in four registers (RES3:RES0).\nEQUATION 7-2:\n16 x 16 SIGNED MULTIPLICATION ALGORITHM",
    "EQUATION 7-1:\n16 x 16 UNSIGNED MULTIPLICATION ALGORITHM\nRES3:RES0, 1 = ARG1H:ARG1L \u2022 ARG2H:ARG2L \u2022 \u2022 16",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF, 1 = ARG1L, ARG2L. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = PRODH,. MULWF, 2 = RES1. MULWF, 3 = ; ;. MULWF, 4 = ARG1L * ARG2L-> PRODH:PRODL. MOVFF MOVFF, 1 = PRODL,. MOVFF MOVFF, 2 = RES0. MOVFF MOVFF, 3 = ; ;. MOVFF MOVFF, 4 = . MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1H * ARG2H-> PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 =",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nRES3. MOVFF, 3 = ;. MOVFF, 4 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES2. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1L * ARG2H-> PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF, 1 = RES1,. ADDWF, 2 = F. ADDWF, 3 = ;. ADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = products.",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nADDWFC, 1 = RES2,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . MULWF, 1 = ARG2L. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1H * ARG2L-> PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF, 1 = RES1,. ADDWF, 2 = F. ADDWF, 3 = ;.",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = products. ADDWFC, 1 = RES2,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = \nExample 7-4  shows  the  sequence  to  do  a  16  x  16 signed  multiply.  Equation 7-2  shows  the  algorithm used.  The  32-bit  result  is  stored  in  four  registers (RES3:RES0).  To  account  for  the  signed  bits  of  the arguments, the MSb for each argument pair is tested and the appropriate subtractions are done.\nRES3:RES0= ARG1H:ARG1L   ARG2H:ARG2L \u2022",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\n= (ARG1H   ARG2H   2 16 ) + \u2022 \u2022\n(ARG1H   ARG2L   2 8 ) + \u2022 \u2022\n(ARG1L   ARG2H   2 8 ) + \u2022 \u2022\n(ARG1L   ARG2L) + \u2022\n(-1 \u2022 ARG2H<7>   ARG1H:ARG1L   2 16 ) + \u2022 \u2022\n(-1 \u2022 ARG1H<7>   ARG2H:ARG2L   2 16 ) \u2022 \u2022",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\nMULWF, ARG1L, = ARG2L. MULWF, W = . MULWF,  = ; ;. MULWF,  = ARG1L * ARG2L -> PRODH:PRODL. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES1. MOVFF,  = ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES0. MOVFF,  = ;. MOVFF,  = . MOVF MULWF, ARG1L, = ARG1H, ARG2H. MOVF MULWF, W = W. MOVF MULWF,  = ;. MOVF MULWF,  = ARG1H * ARG2H -> PRODH:PRODL. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES3. MOVFF,  = ;. MOVFF,",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES2. MOVFF,  = ;. MOVFF,  = . MOVF MULWF, ARG1L, = ARG1L, ARG2H. MOVF MULWF, W = W. MOVF MULWF,  = ; ; ;. MOVF MULWF,  = ARG1L * ARG2H -> PRODH:PRODL. MOVF ADDWF MOVF, ARG1L, = RES1,. MOVF ADDWF MOVF, W = PRODL, W F PRODH,. MOVF ADDWF MOVF,  = ;. MOVF ADDWF MOVF,  = Add cross. CLRF, ARG1L, = WREG. CLRF, W = F F. CLRF,  = ;. CLRF,  = products. ADDWFC, ARG1L, = RES2,. ADDWFC, W = W. ADDWFC,",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= ;. ADDWFC,  = ARG1H * ARG2L PRODH:PRODL. ADDWFC, ARG1L, = . ADDWFC, W = . ADDWFC,  = ; ;. ADDWFC,  = . ;, ARG1L, = RES3,. ;, W = . ;,  = ;. ;,  = . MOVF MULWF, ARG1L, = ARG1H, ARG2L. MOVF MULWF, W = W. MOVF MULWF,  = ; ;. MOVF MULWF,  = ->. ADDWF MOVF ADDWFC, ARG1L, = RES1, PRODH,. ADDWF MOVF ADDWFC, W = F W. ADDWF MOVF ADDWFC,  = ; ;. ADDWF MOVF ADDWFC,",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= Add cross products. CLRF ADDWFC ; BTFSS, ARG1L, = RES2, WREG RES3,. CLRF ADDWFC ; BTFSS, W = F F. CLRF ADDWFC ; BTFSS,  = ; ; ;. CLRF ADDWFC ; BTFSS,  = ARG2H:ARG2L. BRA MOVF SUBWF, ARG1L, = ARG2H, SIGN_ARG1. BRA MOVF SUBWF, W = 7. BRA MOVF SUBWF,  = ;. BRA MOVF SUBWF,  = neg? no, check ARG1. MOVF, ARG1L, = ARG1L, RES2. MOVF, W = W. MOVF,  = ; ;. MOVF,  = ;. SUBWFB, ARG1L, = ARG1H,. SUBWFB, W = W. SUBWFB,  = ;. SUBWFB,",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . SIGN_ARG1 BTFSS BRA, ARG1L, = ARG1H, CONT_CODE. SIGN_ARG1 BTFSS BRA, W = 7. SIGN_ARG1 BTFSS BRA,  = . SIGN_ARG1 BTFSS BRA,  = . ;, ARG1L, = RES3. ;, W = . ;,  = ; ; ;. ;,  = ARG1H:ARG1L neg?. MOVF SUBWFB, ARG1L, = RES2 ARG2H,. MOVF SUBWFB, W = . MOVF SUBWFB,  = . MOVF SUBWFB,  = . SUBWF, ARG1L, = RES3. SUBWF, W = W. SUBWF,  = . SUBWF,  = no, done. MOVF, ARG1L, = ARG2L,. MOVF, W = W. MOVF,  = . MOVF,  = . , ARG1L, = . , W = . ,  = ;. ,",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . , ARG1L, = . , W = . ,  = ;. ,  = . ; CONT_CODE, ARG1L, = . ; CONT_CODE, W = . ; CONT_CODE,  = . ; CONT_CODE,  = . :, ARG1L, = . :, W = . :,  = . :,  = ",
    "8.0 INTERRUPTS\nThe PIC18F6390/6490/8390/8490 devices have multiple interrupt sources and an interrupt priority feature that allows most interrupt sources to be assigned a  high-priority  level  or  a  low-priority  level.  The  highpriority interrupt vector is at 0008h and the low-priority interrupt  vector  is  at  0018h.  High-priority  interrupt events will interrupt any low-priority interrupts that may be in progress.\nWhen  the  IPEN  bit  is  cleared  (default  state),  the interrupt priority feature is disabled and interrupts are compatible with PIC fi mid-range devices. In Compatibility mode, the interrupt priority bits for each source  have  no  effect.  INTCON<6>  is  the  PEIE  bit, which enables/disables all peripheral interrupt sources. INTCON<7> is the GIE bit, which enables/disables all interrupt  sources.  All  interrupts  branch  to  address 0008h in Compatibility mode.\nThere are thirteen registers which are used to control interrupt operation. These registers are:",
    "8.0 INTERRUPTS\nGLYPH<149> RCON\nGLYPH<149> INTCON\nGLYPH<149> INTCON2\nGLYPH<149> INTCON3\nGLYPH<149> PIR1, PIR2, PIR3\nGLYPH<149> PIE1, PIE2, PIE3\nGLYPH<149> IPR1, IPR2, IPR3\nIt is  recommended  that  the  Microchip  header  files supplied with MPLAB fi  IDE be used for the symbolic bit names in these registers. This allows the assembler/ compiler to automatically take care of the placement of these bits within the specified register.\nIn general, interrupt sources have three bits to control their operation. They are:\nGLYPH<149> Flag bit to indicate that an interrupt event occurred\nGLYPH<149> Enable bit that allows program execution to branch to the interrupt vector address when the flag bit is set\nGLYPH<149> Priority bit to select high priority or low priority",
    "8.0 INTERRUPTS\nThe interrupt priority feature is enabled by setting the IPEN bit (RCON<7>). When  interrupt priority is enabled,  there  are  two  bits  which  enable  interrupts globally. Setting the GIEH bit (INTCON<7>) enables all interrupts  that  have  the  priority  bit  set  (high  priority). Setting the GIEL bit (INTCON<6>) enables all interrupts that have the priority bit cleared (low priority). When  the  interrupt  flag,  enable  bit  and  appropriate global  interrupt  enable  bit  are  set,  the  interrupt  will vector immediately to address 0008h or 0018h, depending on the priority bit setting. Individual interrupts can be disabled through their corresponding enable bits.\nWhen an interrupt is responded to, the global interrupt enable bit is cleared to disable further interrupts. If the IPEN bit is cleared, this is the GIE bit. If interrupt priority levels are used, this will be either the GIEH or GIEL bit. High-priority  interrupt  sources  can  interrupt  a  lowpriority interrupt. Low-priority interrupts are not processed while high-priority interrupts are in progress.",
    "8.0 INTERRUPTS\nThe return address is pushed onto the stack and the PC is loaded with the interrupt vector address (0008h or 0018h). Once in the Interrupt Service Routine, the source(s) of the interrupt can be determined by polling the interrupt flag  bits.  The  interrupt  flag  bits  must  be cleared  in  software  before  re-enabling  interrupts  to avoid recursive interrupts.\nThe GLYPH<147>return  from  interruptGLYPH<148>  instruction, RETFIE ,  exits the interrupt routine and sets the GIE bit (GIEH or GIEL if priority levels are used), which re-enables interrupts.\nFor external interrupt events, such as the INTx pins or the PORTB input change interrupt, the interrupt latency will be  three  to  four  instruction  cycles.  The  exact latency is the same for one or two-cycle instructions. Individual interrupt flag bits are set, regardless of the status of their corresponding enable bit or the GIE bit.\nNote:\nDo not use the MOVFF instruction to modify any of the interrupt control registers while any interrupt  is  enabled.  Doing  so  may cause erratic microcontroller behavior.",
    "8.1 INTCON Registers\nNote:\nThe  INTCON  registers  are  readable  and  writable registers which contain various enable, priority and flag bits.\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global interrupt enable bit. User software should ensure  the  appropriate  interrupt  flag  bits are  clear  prior  to  enabling  an  interrupt. This feature allows for software polling.",
    "REGISTER 8-1: INTCON: INTERRUPT CONTROL REGISTER\nGIE/GIEH, R/W-0 = PEIE/GIEL. GIE/GIEH, R/W-0 = TMR0IE. GIE/GIEH, R/W-0 = INT0IE. GIE/GIEH, R/W-0 = RBIE. GIE/GIEH, R/W-0 = TMR0IF. GIE/GIEH, R/W-0 = INT0IF. GIE/GIEH, R/W-x = RBIF (1). bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 8-1: INTCON: INTERRUPT CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 GIE/GIEH: Global Interrupt Enable bit\nWhen IPEN = 0 :\n1 = Enables all unmasked interrupts\n0 = Disables all interrupts",
    "When IPEN = 1 :\n1 = Enables all high-priority interrupts\n0 = Disables all interrupts\nbit 6\nPEIE/GIEL:\nPeripheral Interrupt Enable bit",
    "When IPEN = 0 :\n1 = Enables all unmasked peripheral interrupts\n0 = Disables all peripheral interrupts",
    "When IPEN = 1 :\n1 = Enables all low-priority peripheral interrupts\n0 = Disables all low-priority peripheral interrupts",
    "bit 5 TMR0IE: TMR0 Overflow Interrupt Enable bit\n1 = Enables the TMR0 overflow interrupt\n0 = Disables the TMR0 overflow interrupt",
    "bit 4\nINT0IE: INT0 External Interrupt Enable bit\n1 = Enables the INT0 external interrupt\n0 = Disables the INT0 external interrupt\nbit 3 RBIE: RB Port Change Interrupt Enable bit\n1 = Enables the RB port change interrupt\n0 = Disables the RB port change interrupt",
    "bit 2 TMR0IF: TMR0 Overflow Interrupt Flag bit\n1 = TMR0 register has overflowed (must be cleared in software)\n0 = TMR0 register did not overflow",
    "bit 1 INT0IF: INT0 External Interrupt Flag bit\n1 = The INT0 external interrupt occurred (must be cleared in software)\n0 = The INT0 external interrupt did not occur",
    "bit 0\nRBIF: RB Port Change Interrupt Flag bit (1)\n1 = At least one of the RB7:RB4 pins changed state (must be cleared in software)\n0 = None of the RB7:RB4 pins have changed state\nNote 1: A mismatch condition will continue to set this bit. Reading PORTB will end the mismatch condition and allow the bit to be cleared.",
    "INTCON2: INTERRUPT CONTROL REGISTER 2\nRBPU, R/W-1 = INTEDG0. RBPU, R/W-1 = INTEDG1. RBPU, R/W-1 = INTEDG2. RBPU, R/W-1 = INTEDG3. RBPU, R/W-1 = TMR0IP. RBPU, R/W-1 = INT3IP. RBPU, R/W-1 = RBIP. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 0",
    "INTCON2: INTERRUPT CONTROL REGISTER 2\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 RBPU: PORTB Pull-up Enable bit\n1 = All PORTB pull-ups are disabled\n0 = PORTB pull-ups are enabled by individual port latch values",
    "bit 6\nINTEDG0: External Interrupt 0 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 5\nINTEDG1: External Interrupt 1 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge",
    "bit 4\nINTEDG2: External Interrupt 2 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge",
    "bit 3\nINTEDG3: External Interrupt 3 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 2\nTMR0IP: TMR0 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nINT3IP: INT3 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nRBIP: RB Port Change Interrupt Priority bit\n1 = High priority\n0 = Low priority\nNote: Interrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global interrupt enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.",
    "INTCON3: INTERRUPT CONTROL REGISTER 3\nINT2IP, R/W-1 = INT1IP. INT2IP, R/W-0 = INT3IE. INT2IP, R/W-0 = INT2IE. INT2IP, R/W-0 = INT1IE. INT2IP, R/W-0 = INT3IF. INT2IP, R/W-0 = INT2IF. INT2IP, R/W-0 = INT1IF. bit 7, R/W-1 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "INTCON3: INTERRUPT CONTROL REGISTER 3\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nINT2IP: INT2 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6\nINT1IP: INT1 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nINT3IE: INT3 External Interrupt Enable bit\n1 = Enables the INT3 external interrupt\n0 = Disables the INT3 external interrupt\nbit 4",
    "INTCON3: INTERRUPT CONTROL REGISTER 3\nINT2IE: INT2 External Interrupt Enable bit\n1 = Enables the INT2 external interrupt\n0 = Disables the INT2 external interrupt\nbit 3\nINT1IE: INT1 External Interrupt Enable bit\n1 = Enables the INT1 external interrupt\n0 = Disables the INT1 external interrupt\nbit 2\nINT3IF: INT3 External Interrupt Flag bit\n1 = The INT3 external interrupt occurred (must be cleared in software)\n0 = The INT3 external interrupt did not occur\nbit 1\nINT2IF: INT2 External Interrupt Flag bit\n1 = The INT2 external interrupt occurred (must be cleared in software)\n0 = The INT2 external interrupt did not occur\nbit 0\nINT1IF: INT1 External Interrupt Flag bit\n1 = The INT1 external interrupt occurred (must be cleared in software)\n0 = The INT1 external interrupt did not occur\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global interrupt enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.",
    "8.2 PIR Registers\nThe PIR registers contain the individual flag bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are three Peripheral Interrupt Request (Flag) registers (PIR1, PIR2, PIR3).\nNote 1: Interrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global interrupt enable bit, GIE (INTCON<7>).\n2: User software should ensure the appropriate interrupt flag bits are cleared prior  to  enabling  an  interrupt  and  after servicing that interrupt.",
    "REGISTER 8-4: PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nGLYPH<151>, R/W-0 = ADIF. GLYPH<151>, R-0 = RC1IF. GLYPH<151>, R-0 = TX1IF. GLYPH<151>, R/W-0 = SSPIF. GLYPH<151>, R/W-0 = CCP1IF. GLYPH<151>, R/W-0 = TMR2IF. GLYPH<151>, R/W-0 = TMR1IF. bit 7, R/W-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 8-4: PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 6\nADIF: A/D Converter Interrupt Flag bit\n1 = An A/D conversion completed (must be cleared in software)\n0 = The A/D conversion is not complete\nbit 5 RC1IF: EUSART Receive Interrupt Flag bit\n1 = The EUSART receive buffer, RCREG1, is full (cleared when RCREG1 is read)\n0 = The EUSART receive buffer is empty\nbit 4 TX1IF: EUSART Transmit Interrupt Flag bit\n1 = The EUSART transmit buffer, TXREG1, is empty (cleared when TXREG1 is written)\n0 = The EUSART transmit buffer is full\nbit 3 SSPIF: Master Synchronous Serial Port Interrupt Flag bit\n1 = The transmission/reception is complete (must be cleared in software)\n0 = Waiting to transmit/receive",
    "bit 2 CCP1IF: CCP1 Interrupt Flag bit\nCapture mode:\n1 = A TMR1/TMR3 register capture occurred (must be cleared in software)\n0 = No TMR1/TMR3 register capture occurred",
    "Compare mode:\n1 = A TMR1/TMR3 register compare match occurred (must be cleared in software)\n0 = No TMR1/TMR3 register compare match occurred\nPWM mode:\nUnused in this mode.",
    "bit 1\nTMR2IF: TMR2 to PR2 Match Interrupt Flag bit\n1 = TMR2 to PR2 match occurred (must be cleared in software)\n0 = No TMR2 to PR2 match occurred",
    "bit 0\nTMR1IF: TMR1 Overflow Interrupt Flag bit\n1 = TMR1 register overflowed (must be cleared in software)\n0 = TMR1 register did not overflow",
    "REGISTER 8-5: PIR2: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 2\nOSCFIF, R/W-0 = CMIF. OSCFIF, U-0 = GLYPH<151>. OSCFIF, U-0 = GLYPH<151>. OSCFIF, R/W-0 = BCLIF. OSCFIF, R/W-0 = HLVDIF. OSCFIF, R/W-0 = TMR3IF. OSCFIF, R/W-0 = CCP2IF. bit 7, R/W-0 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 8-5: PIR2: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 2\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 OSCFIF: Oscillator Fail Interrupt Flag bit\n1 = Device oscillator failed, clock input has changed to INTOSC (must be cleared in software)\n0 = Device clock operating",
    "bit 6\nCMIF: Comparator Interrupt Flag bit\n1 = Comparator input has changed (must be cleared in software)\n0 = Comparator input has not changed",
    "bit 3\nBCLIF: Bus Collision Interrupt Flag bit\n1 = A bus collision occurred (must be cleared in software)\n0 = No bus collision occurred",
    "bit 2 HLVDIF: High/Low-Voltage Detect Interrupt Flag bit\n1 = A low-voltage condition occurred (must be cleared in software)\n0 = The device voltage is above the Low-Voltage Detect trip point",
    "bit 1 TMR3IF: TMR3 Overflow Interrupt Flag bit\n1 = TMR3 register overflowed (must be cleared in software)\n0 = TMR3 register did not overflow",
    "bit 0\nCCP2IF: CCP2 Interrupt Flag bit",
    "Capture mode:\n1 = A TMR1/TMR3 register capture occurred (must be cleared in software)\n0 = No TMR1/TMR3 register capture occurred",
    "Compare mode:\n1 = A TMR1/TMR3 register compare match occurred (must be cleared in software)\n0 = No TMR1/TMR3 register compare match occurred",
    "PWM mode:\nUnused in this mode.",
    "REGISTER 8-6: PIR3: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 3\nU-0, 1 = R/W-0. U-0, 2 = R-0. U-0, 3 = R/W-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = U-0. GLYPH<151>, 1 = LCDIF. GLYPH<151>, 2 = RC2IF. GLYPH<151>, 3 = TX2IF. GLYPH<151>, 4 = GLYPH<151>. GLYPH<151>, 5 = GLYPH<151>. GLYPH<151>, 6 = GLYPH<151>. GLYPH<151>, 7 = GLYPH<151>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit",
    "REGISTER 8-6: PIR3: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 3\n0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 6\nLCDIF: LCD Interrupt Flag bit (valid when Type-B waveform with Non-Static mode is selected)\n1 = LCD data of all COMs is output  (must be cleared in software)\n0 = LCD data of all COMs is not yet output\nbit 5 RC2IF: AUSART Receive Interrupt Flag bit\n1 = The AUSART receive buffer, RCREG2, is full (cleared when RCREG2 is read)\n0 = The AUSART receive buffer is empty",
    "bit 4\nTX2IF: AUSART Transmit Interrupt Flag bit\n1 = The AUSART transmit buffer, TXREG2, is empty (cleared when TXREG2 is written)\n0 = The AUSART transmit buffer is full\nbit 3-0 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>",
    "8.3 PIE Registers\nThe PIE registers contain the individual enable bits for the peripheral interrupts. Due  to the number  of peripheral interrupt sources, there are three Peripheral Interrupt  Enable  registers  (PIE1,  PIE2,  PIE3).  When IPEN = 0 ,  the PEIE bit must be set to enable any of these peripheral interrupts.",
    "REGISTER 8-7: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nGLYPH<151>, R/W-0 = ADIE. GLYPH<151>, R/W-0 = RC1IE. GLYPH<151>, R/W-0 = TX1IE. GLYPH<151>, R/W-0 = SSPIE. GLYPH<151>, R/W-0 = CCP1IE. GLYPH<151>, R/W-0 = TMR2IE. GLYPH<151>, R/W-0 = TMR1IE. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 8-7: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 6\nADIE: A/D Converter Interrupt Enable bit\n1 = Enables the A/D interrupt\n0 = Disables the A/D interrupt\nbit 5\nRC1IE: EUSART Receive Interrupt Enable bit\n1 = Enables the EUSART receive interrupt\n0 = Disables the EUSART receive interrupt\nbit 4\nTX1IE: EUSART Transmit Interrupt Enable bit\n1 = Enables the EUSART transmit interrupt\n0 = Disables the EUSART transmit interrupt\nbit 3\nSSPIE: Master Synchronous Serial Port Interrupt Enable bit\n1 = Enables the MSSP interrupt\n0 = Disables the MSSP interrupt",
    "bit 2\nCCP1IE: CCP1 Interrupt Enable bit\n1 = Enables the CCP1 interrupt\n0 = Disables the CCP1 interrupt",
    "bit 1\nTMR2IE: TMR2 to PR2 Match Interrupt Enable bit\n1 = Enables the TMR2 to PR2 match interrupt\n0 = Disables the TMR2 to PR2 match interrupt\nbit 0\nTMR1IE: TMR1 Overflow Interrupt Enable bit\n1 = Enables the TMR1 overflow interrupt\n0 = Disables the TMR1 overflow interrupt",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nOSCFIE, R/W-0 = CMIE. OSCFIE, U-0 = GLYPH<151>. OSCFIE, U-0 = GLYPH<151>. OSCFIE, R/W-0 = BCLIE. OSCFIE, R/W-0 = HLVDIE. OSCFIE, R/W-0 = TMR3IE. OSCFIE, R/W-0 = CCP2IE. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nOSCFIE: Oscillator Fail Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 6\nCMIE: Comparator Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 5-4 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 3\nBCL1IE: Bus Collision Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 2\nHLVDIE: High Low-Voltage Detect Interrupt Enable bit /\n1 = Enabled\n0 =  Disabled\nbit 1\nTMR3IE: TMR3 Overflow Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 0\nCCP2IE: CCP2 Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "REGISTER 8-9: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\nU-0, 1 = R/W-0. U-0, 2 = R-0. U-0, 3 = R-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = U-0. GLYPH<151>, 1 = LCDIE. GLYPH<151>, 2 = RC2IE. GLYPH<151>, 3 = TX2IE. GLYPH<151>, 4 = GLYPH<151>. GLYPH<151>, 5 = GLYPH<151>. GLYPH<151>, 6 = GLYPH<151>. GLYPH<151>, 7 = GLYPH<151>. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7",
    "REGISTER 8-9: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\nbit 0. bit 7 bit 0, 7 = bit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 6 LCDIE: LCD Interrupt Enable bit (valid when Type-B waveform with Non-Static mode is selected)\n1 = Enabled\n0 = Disabled\nbit 5\nRC2IE: AUSART Receive Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 4\nTX2IE: AUSART Transmit Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 3-0 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>",
    "8.4 IPR Registers\nThe IPR registers contain the individual priority bits for the peripheral interrupts. Due  to the number  of peripheral interrupt sources, there are three Peripheral Interrupt  Priority  registers  (IPR1,  IPR2,  IPR3).  Using the  priority  bits requires  that  the  Interrupt  Priority Enable (IPEN) bit be set.",
    "REGISTER 8-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nGLYPH<151>, R/W-1 = ADIP. GLYPH<151>, R/W-1 = RC1IP. GLYPH<151>, R/W-1 = TX1IP. GLYPH<151>, R/W-1 = SSPIP. GLYPH<151>, R/W-1 = CCP1IP. GLYPH<151>, R/W-1 = TMR2IP. GLYPH<151>, R/W-1 = TMR1IP. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 0",
    "REGISTER 8-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 6\nADIP: A/D Converter Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nRC1IP: EUSART Receive Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4",
    "REGISTER 8-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nTX1IP: EUSART Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nSSPIP: Master Synchronous Serial Port Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nCCP1IP: CCP1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nTMR2IP: TMR2 to PR2 Match Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nTMR1IP: TMR1 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 8-11: IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nOSCFIP, R/W-1 = CMIP. OSCFIP, U-0 = GLYPH<151>. OSCFIP, U-0 = GLYPH<151>. OSCFIP, R/W-1 = BCLIP. OSCFIP, R/W-1 = HLVDIP. OSCFIP, R/W-1 = TMR3IP. OSCFIP, R/W-1 = CCP2IP. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0",
    "REGISTER 8-11: IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nOSCFIP: Oscillator Fail Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6\nCMIP: Comparator Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5-4\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 3",
    "REGISTER 8-11: IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nBCLIP: Bus Collision Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nHLVDIP: High/Low-Voltage Detect Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nTMR3IP: TMR3 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nCCP2IP: CCP2 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 8-12: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nGLYPH<151>, R/W-1 = LCDIP. GLYPH<151>, R/W-1 = RC2IP. GLYPH<151>, R/W-1 = TX2IP. GLYPH<151>, U-0 = GLYPH<151>. GLYPH<151>, U-0 = GLYPH<151>. GLYPH<151>, U-0 = GLYPH<151>. GLYPH<151>, U-0 = GLYPH<151>. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0",
    "REGISTER 8-12: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 6\nLCDIP: LCD Interrupt Priority bit (valid when Type-B waveform with Non-Static mode is selected)\n1 = High priority\n0 = Low priority\nbit 5\nRC2IP: AUSART Receive Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 4\nTX2IP: AUSART Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3-0\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>",
    "8.5 RCON Register\nThe RCON register contains bits used to determine the cause of the last Reset or wake-up from Idle or Sleep modes.  RCON  also  contains  the  bit  that  enables interrupt priorities (IPEN).",
    "REGISTER 8-13: RCON: RESET CONTROL REGISTER\nIPEN, R/W-1 = SBOREN. IPEN, U-0 = GLYPH<151>. IPEN, R/W-1 = RI. IPEN, R-1 = TO. IPEN, R-1 = PD. IPEN, R/W-0 = POR. IPEN, R/W-0 = BOR. bit 7, R/W-1 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R-1 = bit 7. bit 7, R-1 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 8-13: RCON: RESET CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7\nIPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16CXXX Compatibility mode)\nbit 6\nSBOREN: Software BOR Enable bit\nFor details of bit operation and Reset state, see Register 4-1.",
    "bit 5\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 4 RI:\nRESET Instruction Flag bit\nFor details of bit operation, see Register 4-1.\nbit 3\nTO: Watchdog Timer Time-out Flag bit\nFor details of bit operation, see Register 4-1.\nbit 2\nPD: Power-Down Detection Flag bit\nFor details of bit operation, see Register 4-1.\nbit 1\nPOR: Power-on Reset Status bit\nFor details of bit operation, see Register 4-1.\nbit 0\nBOR: Brown-out Reset Status bit\nFor details of bit operation, see Register 4-1.",
    "8.7 TMR0 Interrupt\nExternal  interrupts  on  the  RB0/INT0,  RB1/INT1,  RB2/ INT2  and  RB3/INT3  pins  are  edge-triggered.  If  the corresponding INTEDGx bit in the INTCON2 register is set (= 1 ), the interrupt is triggered by a rising edge; if the bit is clear, the trigger is on the falling edge. When a valid edge appears on the RBx/INTx pin, the corresponding flag bit INTxIF is set. This interrupt can be disabled by clearing  the  corresponding  enable  bit,  INTxIE.  The interrupt  flag  bit  must  be  cleared  in  software  in  the Interrupt Service Routine before re-enabling the interrupt.\nAll external interrupts (INT0, INT1, INT2 and INT3) can wake-up  the processor from the power-managed modes  if  bit  INTxIE  was  set  prior  to  going  into  the power-managed modes. If the Global Interrupt Enable bit, GIE, is set, the processor will branch to the interrupt vector following wake-up.",
    "8.7 TMR0 Interrupt\nIn 8-bit mode (which is the default), an overflow in the TMR0 register (FFh \u2192 00h) will set flag bit, TMR0IF. In 16-bit mode, an overflow in the TMR0H:TMR0L register pair (FFFFh \u2192 0000h) will set TMR0IF. The interrupt can be enabled/disabled by setting/clearing enable bit, TMR0IE (INTCON<5>). Interrupt priority for Timer0 is determined  by  the  value  contained  in  the  interrupt priority bit, TMR0IP (INTCON2<2>). See Section 10.0 GLYPH<147>Timer0 ModuleGLYPH<148> for  further  details  on  the  Timer0 module.",
    "8.8 PORTB Interrupt-on-Change\nInterrupt priority for INT1, INT2 and INT3 is determined by  the  value  contained  in  the  interrupt  priority  bits, INT1IP  (INTCON3<6>),  INT2IP  (INTCON3<7>)  and INT3IP (INTCON2<1>). There is no priority bit associated  with  INT0.  It  is always  a  high-priority interrupt source.\nAn input change on PORTB<7:4> sets flag bit, RBIF (INTCON<0>). The interrupt can be enabled/disabled by  setting/clearing  enable  bit,  RBIE  (INTCON<3>). Interrupt  priority  for  PORTB  interrupt-on-change  is determined  by  the  value  contained  in  the  interrupt priority bit, RBIP (INTCON2<0>).",
    "8.9 Context Saving During Interrupts\nDuring interrupts, the return PC address is saved on the stack. Additionally, the WREG, STATUS and BSR registers are saved on the fast return stack. If a fast return  from  interrupt  is  not  used  (see Section 5.3 GLYPH<147>Data Memory OrganizationGLYPH<148> ), the user may need to save the WREG, STATUS and BSR registers on entry to  the  Interrupt  Service  Routine.  Depending  on  the userGLYPH<146>s application, other registers may also need to be saved.  Example 8-1  saves  and  restores  the  WREG, STATUS and BSR registers during an Interrupt Service Routine.",
    "EXAMPLE 8-1: SAVING STATUS, WREG AND BSR REGISTERS IN RAM\nMOVWF MOVFF MOVFF ; ;, 1 = W_TEMP STATUS, STATUS_TEMP BSR, BSR_TEMP. MOVWF MOVFF MOVFF ; ;, 2 = ; W_TEMP is in virtual bank ; STATUS_TEMP located anywhere ; BSR_TMEP located anywhere. USER ;, 1 = ISR CODE. USER ;, 2 = . MOVFF, 1 = BSR_TEMP, BSR. MOVFF, 2 = ; Restore BSR. MOVF, 1 = W_TEMP, W. MOVF, 2 = ; Restore WREG. MOVFF, 1 = STATUS_TEMP, STATUS. MOVFF, 2 = ; Restore STATUS",
    "9.0 I/O PORTS\nDepending on the device selected and features enabled,  there  are  up  to  nine  ports  available.  Some pins of the I/O ports are multiplexed with an alternate function from the peripheral features on the device. In general, when a peripheral is enabled, that pin may not be used as a general purpose I/O pin.\nEach port has three registers for its operation. These registers are:\nGLYPH<149> TRIS register (data direction register)\nGLYPH<149> PORT register (reads the levels on the pins of the device)\nGLYPH<149> LAT register (output latch)\nThe Data Latch (LAT register) is useful for read-modify-write operations on the value that the I/O pins are driving.\nA simplified  model  of  a  generic  I/O  port,  without  the interfaces to other peripherals, is shown in Figure 9-1.",
    "9.1 PORTA, TRISA and LATA Registers\nPORTA is an 8-bit wide, bidirectional port. The corresponding Data Direction register is  TRISA.  Setting  a TRISA bit (= 1 ) will make the corresponding PORTA pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISA bit (= 0 ) will make the corresponding PORTA pin an output (i.e., put the contents of the output latch on the selected pin).\nReading the  PORTA register reads the  status of  the pins, whereas writing to it will write to the port latch.\nThe Data Latch register (LATA) is also memory mapped. Read-modify-write operations on the LATA register read and write the latched output value for PORTA.",
    "9.1 PORTA, TRISA and LATA Registers\nThe  RA4  pin  is  multiplexed  with  the  Timer0  module clock input and the LCD segment drive to become the RA4/T0CKI/SEG14  pin. Pins RA6  and RA7  are multiplexed  with  the  main  oscillator  pins;  they  are enabled as oscillator or I/O pins by the selection of the main  oscillator in the Configuration register (see Section 23.1 GLYPH<147>Configuration BitsGLYPH<148> for details). When they are not used as port pins, RA6 and RA7 and their associated TRIS and LAT bits are read as GLYPH<145> 0 GLYPH<146>.\nThe  other  PORTA  pins  are  multiplexed  with  analog inputs  and  the  analog  VREF+  and  VREF-  inputs.  The operation of pins RA3:RA0 and RA5 as A/D converter inputs is selected by clearing or setting the control bits in the ADCON1 register (A/D Control Register 1).",
    "9.1 PORTA, TRISA and LATA Registers\nThe RA4/T0CKI/SEG14 pin is a Schmitt Trigger input and an open-drain output. All other PORTA pins have TTL input levels and full CMOS output drivers.\nThe TRISA register controls the direction of the PORTA pins, even when they are being used as analog inputs. The user must ensure the bits in the TRISA register are maintained set when using them as analog inputs.\nRA5:RA2  are  also  multiplexed  with  LCD  segment drives controlled by bits in the LCDSE1 and LCDSE2 registers. I/O port functions are only available when the segments are disabled.",
    "EXAMPLE 9-1: INITIALIZING PORTA\nCLRF, 1 = PORTA. CLRF, 2 = ; Initialize PORTA by ; clearing output ; data latches. CLRF, 1 = LATA. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF, 1 = 07h ADCON1. MOVLW MOVWF, 2 = ; Configure A/D ; for digital inputs. MOVWF, 1 = 07h. MOVWF, 2 = ; Configure comparators. MOVWF, 1 = CMCON. MOVWF, 2 = ; for digital input. MOVLW, 1 = 0CFh. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISA. MOVWF, 2 = ; Set RA<3:0> as inputs ; RA<5:4> as outputs",
    "TABLE 9-1: PORTA FUNCTIONS\nRA0/AN0, Function = RA0. RA0/AN0, TRIS Setting = 0. RA0/AN0, I/O = O. RA0/AN0, Buffer = DIG. RA0/AN0, Description = LATA<0> data output. Not affected by analog pin setting.. RA0/AN0, Function = RA0. RA0/AN0, TRIS Setting = 1. RA0/AN0, I/O = I. RA0/AN0, Buffer = TTL. RA0/AN0, Description = PORTA<0> data input. Reads GLYPH<145> 0 GLYPH<146> on POR.. RA0/AN0, Function = AN0. RA0/AN0, TRIS Setting = 1. RA0/AN0, I/O = I. RA0/AN0, Buffer = ANA. RA0/AN0, Description = A/D input channel 0. Default configuration on POR.. RA1/AN1, Function = RA1. RA1/AN1, TRIS Setting = 0. RA1/AN1, I/O =",
    "TABLE 9-1: PORTA FUNCTIONS\nO. RA1/AN1, Buffer = DIG. RA1/AN1, Description = LATA<1> data output. Not affected by analog pin setting.. RA1/AN1, Function = RA1. RA1/AN1, TRIS Setting = 1. RA1/AN1, I/O = I. RA1/AN1, Buffer = TTL. RA1/AN1, Description = PORTA<1> data input. Reads GLYPH<145> 0 GLYPH<146> on POR.. RA1/AN1, Function = AN1. RA1/AN1, TRIS Setting = 1. RA1/AN1, I/O = I. RA1/AN1, Buffer = ANA. RA1/AN1, Description = A/D input channel 1. Default configuration on POR.. RA2/AN2/VREF-/ SEG16, Function = RA2. RA2/AN2/VREF-/ SEG16, TRIS Setting = 0. RA2/AN2/VREF-/ SEG16, I/O = O.",
    "TABLE 9-1: PORTA FUNCTIONS\nRA2/AN2/VREF-/ SEG16, Buffer = DIG. RA2/AN2/VREF-/ SEG16, Description = LATA<2> data output. Not affected by analog pin setting; disabled when LCD segment enabled.. RA2/AN2/VREF-/ SEG16, Function = RA2. RA2/AN2/VREF-/ SEG16, TRIS Setting = 1. RA2/AN2/VREF-/ SEG16, I/O = I. RA2/AN2/VREF-/ SEG16, Buffer = TTL. RA2/AN2/VREF-/ SEG16, Description = PORTA<2> data input. Reads GLYPH<145> 0 GLYPH<146> on POR.. RA2/AN2/VREF-/ SEG16, Function = AN2. RA2/AN2/VREF-/ SEG16, TRIS Setting = 1. RA2/AN2/VREF-/ SEG16, I/O = I. RA2/AN2/VREF-/",
    "TABLE 9-1: PORTA FUNCTIONS\nSEG16, Buffer = ANA. RA2/AN2/VREF-/ SEG16, Description = A/D input channel 2. Default configuration on POR.. RA2/AN2/VREF-/ SEG16, Function = VREF-. RA2/AN2/VREF-/ SEG16, TRIS Setting = 1. RA2/AN2/VREF-/ SEG16, I/O = I. RA2/AN2/VREF-/ SEG16, Buffer = ANA. RA2/AN2/VREF-/ SEG16, Description = A/D low reference voltage input.. RA2/AN2/VREF-/ SEG16, Function = SEG16. RA2/AN2/VREF-/ SEG16, TRIS Setting = x. RA2/AN2/VREF-/ SEG16, I/O = O. RA2/AN2/VREF-/ SEG16, Buffer = ANA. RA2/AN2/VREF-/ SEG16, Description = Segment 16 analog output for LCD..",
    "TABLE 9-1: PORTA FUNCTIONS\nRA3/AN3/VREF+/ SEG17, Function = RA3. RA3/AN3/VREF+/ SEG17, TRIS Setting = 0. RA3/AN3/VREF+/ SEG17, I/O = O. RA3/AN3/VREF+/ SEG17, Buffer = DIG. RA3/AN3/VREF+/ SEG17, Description = LATA<3> data output. Output is unaffected by analog pin setting; disabled when LCD segment enabled.. RA3/AN3/VREF+/ SEG17, Function = RA3. RA3/AN3/VREF+/ SEG17, TRIS Setting = 1. RA3/AN3/VREF+/ SEG17, I/O = I. RA3/AN3/VREF+/ SEG17, Buffer = TTL. RA3/AN3/VREF+/ SEG17, Description = PORTA<3> data input. Reads GLYPH<145> 0 GLYPH<146> on POR.. RA3/AN3/VREF+/",
    "TABLE 9-1: PORTA FUNCTIONS\nSEG17, Function = AN3. RA3/AN3/VREF+/ SEG17, TRIS Setting = 1. RA3/AN3/VREF+/ SEG17, I/O = I. RA3/AN3/VREF+/ SEG17, Buffer = ANA. RA3/AN3/VREF+/ SEG17, Description = A/D input channel 3. Default configuration on POR.. RA3/AN3/VREF+/ SEG17, Function = VREF+. RA3/AN3/VREF+/ SEG17, TRIS Setting = 1. RA3/AN3/VREF+/ SEG17, I/O = I. RA3/AN3/VREF+/ SEG17, Buffer = ANA. RA3/AN3/VREF+/ SEG17, Description = A/D high reference voltage input.. RA3/AN3/VREF+/ SEG17, Function = SEG17. RA3/AN3/VREF+/ SEG17, TRIS Setting = x.",
    "TABLE 9-1: PORTA FUNCTIONS\nRA3/AN3/VREF+/ SEG17, I/O = O. RA3/AN3/VREF+/ SEG17, Buffer = ANA. RA3/AN3/VREF+/ SEG17, Description = Segment 17 analog output for LCD. Disables all other digital outputs.. RA4/T0CKI/ SEG14, Function = RA4. RA4/T0CKI/ SEG14, TRIS Setting = 0. RA4/T0CKI/ SEG14, I/O = O. RA4/T0CKI/ SEG14, Buffer = DIG. RA4/T0CKI/ SEG14, Description = LATA<4> data output; disabled when LCD segment enabled.. RA4/T0CKI/ SEG14, Function = RA4. RA4/T0CKI/ SEG14, TRIS Setting = 1. RA4/T0CKI/ SEG14, I/O = I. RA4/T0CKI/ SEG14, Buffer = ST. RA4/T0CKI/ SEG14, Description = PORTA<4> data",
    "TABLE 9-1: PORTA FUNCTIONS\ninput.. RA4/T0CKI/ SEG14, Function = T0CKI. RA4/T0CKI/ SEG14, TRIS Setting = . RA4/T0CKI/ SEG14, I/O = I. RA4/T0CKI/ SEG14, Buffer = ST. RA4/T0CKI/ SEG14, Description = Timer0 clock input.. RA4/T0CKI/ SEG14, Function = SEG14. RA4/T0CKI/ SEG14, TRIS Setting = x. RA4/T0CKI/ SEG14, I/O = O. RA4/T0CKI/ SEG14, Buffer = ANA. RA4/T0CKI/ SEG14, Description = Segment 14 analog output for LCD.. RA5/AN4/ HLVDIN/SEG15, Function = RA5. RA5/AN4/ HLVDIN/SEG15, TRIS Setting = 0. RA5/AN4/ HLVDIN/SEG15, I/O = O. RA5/AN4/",
    "TABLE 9-1: PORTA FUNCTIONS\nHLVDIN/SEG15, Buffer = DIG. RA5/AN4/ HLVDIN/SEG15, Description = LATA<5> data output. Not affected by analog pin setting; disabled when LCD segment enabled.. RA5/AN4/ HLVDIN/SEG15, Function = RA5. RA5/AN4/ HLVDIN/SEG15, TRIS Setting = 1. RA5/AN4/ HLVDIN/SEG15, I/O = I. RA5/AN4/ HLVDIN/SEG15, Buffer = TTL. RA5/AN4/ HLVDIN/SEG15, Description = PORTA<5> data input. Reads GLYPH<145> 0 GLYPH<146> on POR.. RA5/AN4/ HLVDIN/SEG15, Function = AN4. RA5/AN4/ HLVDIN/SEG15, TRIS Setting = 1. RA5/AN4/ HLVDIN/SEG15, I/O = I. RA5/AN4/",
    "TABLE 9-1: PORTA FUNCTIONS\nHLVDIN/SEG15, Buffer = ANA. RA5/AN4/ HLVDIN/SEG15, Description = A/D input channel 5. Default configuration on POR.. RA5/AN4/ HLVDIN/SEG15, Function = HLVDIN. RA5/AN4/ HLVDIN/SEG15, TRIS Setting = 1. RA5/AN4/ HLVDIN/SEG15, I/O = I. RA5/AN4/ HLVDIN/SEG15, Buffer = ANA. RA5/AN4/ HLVDIN/SEG15, Description = High/Low-Voltage Detect external trip point input.. RA5/AN4/ HLVDIN/SEG15, Function = SEG15. RA5/AN4/ HLVDIN/SEG15, TRIS Setting = x. RA5/AN4/ HLVDIN/SEG15, I/O = O. RA5/AN4/ HLVDIN/SEG15, Buffer = ANA. RA5/AN4/",
    "TABLE 9-1: PORTA FUNCTIONS\nHLVDIN/SEG15, Description = Segment 15 analog output for LCD.. OSC2/CLKO/RA6, Function = OSC2. OSC2/CLKO/RA6, TRIS Setting = x. OSC2/CLKO/RA6, I/O = O. OSC2/CLKO/RA6, Buffer = ANA. OSC2/CLKO/RA6, Description = Main oscillator feedback output connection (XT, HS and LP modes).. OSC2/CLKO/RA6, Function = CLKO. OSC2/CLKO/RA6, TRIS Setting = x. OSC2/CLKO/RA6, I/O = O. OSC2/CLKO/RA6, Buffer = DIG. OSC2/CLKO/RA6, Description = System cycle clock output (FOSC/4) in all oscillator modes except RCIO, INTIO2 and ECIO.. OSC2/CLKO/RA6, Function = RA6. OSC2/CLKO/RA6, TRIS Setting = 0.",
    "TABLE 9-1: PORTA FUNCTIONS\nOSC2/CLKO/RA6, I/O = O. OSC2/CLKO/RA6, Buffer = DIG. OSC2/CLKO/RA6, Description = LATA<6> data output. Enabled in RCIO, INTIO2 and ECIO modes only.. OSC2/CLKO/RA6, Function = RA6. OSC2/CLKO/RA6, TRIS Setting = 1. OSC2/CLKO/RA6, I/O = I. OSC2/CLKO/RA6, Buffer = TTL. OSC2/CLKO/RA6, Description = PORTA<6> data input. Enabled in RCIO, INTIO2 and ECIO modes only.. OSC1/CLKI/RA7, Function = OSC1. OSC1/CLKI/RA7, TRIS Setting = x. OSC1/CLKI/RA7, I/O = I. OSC1/CLKI/RA7, Buffer = ANA. OSC1/CLKI/RA7, Description = Main oscillator input connection, all modes except",
    "TABLE 9-1: PORTA FUNCTIONS\nINTIO.. OSC1/CLKI/RA7, Function = CLKI. OSC1/CLKI/RA7, TRIS Setting = x. OSC1/CLKI/RA7, I/O = I. OSC1/CLKI/RA7, Buffer = ANA. OSC1/CLKI/RA7, Description = Main clock input connection, all modes except INTIO.. OSC1/CLKI/RA7, Function = RA7. OSC1/CLKI/RA7, TRIS Setting = 0. OSC1/CLKI/RA7, I/O = O. OSC1/CLKI/RA7, Buffer = DIG. OSC1/CLKI/RA7, Description = LATA<7> data output. Available only in INTIO modes; otherwise reads as GLYPH<145> 0 GLYPH<146>.. OSC1/CLKI/RA7, Function = RA7. OSC1/CLKI/RA7, TRIS Setting = 1. OSC1/CLKI/RA7, I/O = I.",
    "TABLE 9-1: PORTA FUNCTIONS\nOSC1/CLKI/RA7, Buffer = TTL. OSC1/CLKI/RA7, Description = PORTA<7> data input. Available only in INTIO modes; otherwise reads as GLYPH<145> 0 GLYPH<146>.\nLegend:\nO = Output, I = Input, ANA = Analog Signal, DIG = Digital Output, ST = Schmitt Buffer Input, TTL = TTL Buffer Input, x = DonGLYPH<146>t care (TRIS bit does not affect port direction or is overridden for this option).",
    "TABLE 9-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nPORTA, Bit 7 = RA7 (1). PORTA, Bit 6 = RA6 (1). PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Reset Values on Page = 62. LATA, Bit 7 = LATA7 (1). LATA, Bit 6 = LATA6 (1). LATA, Bit 5 = LATA Data Output Register. LATA, Bit 4 = LATA Data Output Register. LATA, Bit 3 = LATA Data Output Register. LATA, Bit 2 = LATA Data Output Register. LATA, Bit 1 = LATA Data Output Register. LATA, Bit 0 = LATA Data Output Register. LATA, Reset Values on Page = 62. TRISA, Bit 7 = TRISA7 (1). TRISA, Bit 6 = TRISA6 (1). TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction",
    "TABLE 9-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nRegister. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Reset Values on Page = 62. ADCON1, Bit 7 = GLYPH<151>. ADCON1, Bit 6 = GLYPH<151>. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Reset Values on Page = 61. LCDSE1, Bit 7 = SE15. LCDSE1, Bit 6 = SE14. LCDSE1, Bit 5 = SE13. LCDSE1, Bit 4 = SE12. LCDSE1, Bit 3 = SE11. LCDSE1, Bit 2 = SE10. LCDSE1, Bit 1 = SE9.",
    "TABLE 9-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nLCDSE1, Bit 0 = SE8. LCDSE1, Reset Values on Page = 64. LCDSE2, Bit 7 = SE23. LCDSE2, Bit 6 = SE22. LCDSE2, Bit 5 = SE21. LCDSE2, Bit 4 = SE20. LCDSE2, Bit 3 = SE19. LCDSE2, Bit 2 = SE18. LCDSE2, Bit 1 = SE17. LCDSE2, Bit 0 = SE16. LCDSE2, Reset Values on Page = 64\nLegend:\nGLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used by PORTA.\n- Note 1: RA7:RA6 and their associated latch and data direction bits are enabled as I/O pins based on oscillator configuration; otherwise, they are read as GLYPH<145> 0 GLYPH<146> .",
    "9.2 PORTB, TRISB and LATB Registers\nPORTB is an 8-bit wide, bidirectional port. The corresponding Data Direction register is  TRISB.  Setting  a TRISB bit (= 1 )  will  make the corresponding PORTB pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISB bit (= 0 ) will make the corresponding PORTB pin an output (i.e., put the contents of the output latch on the selected pin).\nFour of the PORTB pins (RB7:RB4) have an interrupt-on-change  feature.  Only  pins  configured  as inputs  can  cause  this  interrupt  to  occur  (i.e.,  any RB7:RB4 pin configured as an output is excluded from the interrupt-on-change comparison). The input pins (of RB7:RB4) are compared with the old value latched on the  last  read  of  PORTB.  The  GLYPH<147>mismatchGLYPH<148>  outputs  of RB7:RB4 are ORed together to generate the RB Port Change Interrupt with Flag bit, RBIF (INTCON<0>).",
    "9.2 PORTB, TRISB and LATB Registers\nThe  Data  Latch  register (LATB)  is also memory mapped.  Read-modify-write  operations  on  the  LATB register  read  and  write  the  latched  output  value  for PORTB.",
    "EXAMPLE 9-2: INITIALIZING PORTB\nCLRF, 1 = PORTB. CLRF, 2 = ; Initialize PORTB by ; clearing output ; data latches. CLRF, 1 = LATB. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0CFh. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISB. MOVWF, 2 = ; Set RB<3:0> as inputs ; RB<5:4> as outputs ; RB<7:6> as inputs\nEach of the PORTB pins has a weak internal pull-up. A single  control  bit  can  turn  on  all  the  pull-ups.  This  is performed by clearing bit RBPU (INTCON2<7>). The weak pull-up is automatically turned off when the port pin  is configured  as  an  output.  The  pull-ups  are disabled on a Power-on Reset.\nThis interrupt can wake the device from power-managed  modes.  The  user,  in  the  Interrupt Service Routine, can clear the interrupt in the following manner:",
    "EXAMPLE 9-2: INITIALIZING PORTB\na) Any  read  or  write  of  PORTB  (except  with  the MOVFF  (ANY),  PORTB instruction).  This  will end the mismatch condition.\nb) Clear flag bit, RBIF.\nA mismatch condition will continue to set flag bit, RBIF. Reading PORTB will end the mismatch condition and allow flag bit RBIF to be cleared.\nThe interrupt-on-change  feature  is  recommended  for wake-up on key depression operation and operations where PORTB is only used for the interrupt-on-change feature. Polling of PORTB is not recommended while using the interrupt-on-change feature.\nRB4:RB1  are  also  multiplexed  with  LCD  segment drives  controlled  by  bits  in  the  LCDSE1  register.  I/O port  functions  are  only  available  when  the  segments are disabled.",
    "TABLE 9-3: PORTB FUNCTIONS\nRB0/INT0, Function = RB0. RB0/INT0, TRIS Setting = 0. RB0/INT0, I/O = O. RB0/INT0, Buffer = DIG. RB0/INT0, Description = LATB<0> data output.. RB0/INT0, Function = RB0. RB0/INT0, TRIS Setting = 1. RB0/INT0, I/O = I. RB0/INT0, Buffer = TTL. RB0/INT0, Description = PORTB<0> data input; programmable weak pull-up.. RB0/INT0, Function = INT0. RB0/INT0, TRIS Setting = 1. RB0/INT0, I/O = I. RB0/INT0, Buffer = ST. RB0/INT0, Description = External interrupt 0 input.. RB1/INT1/SEG8, Function = RB1. RB1/INT1/SEG8, TRIS Setting = 0. RB1/INT1/SEG8, I/O = O.",
    "TABLE 9-3: PORTB FUNCTIONS\nRB1/INT1/SEG8, Buffer = DIG. RB1/INT1/SEG8, Description = LATB<1> data output; disabled when LCD segment enabled.. RB1/INT1/SEG8, Function = RB1. RB1/INT1/SEG8, TRIS Setting = 1. RB1/INT1/SEG8, I/O = I. RB1/INT1/SEG8, Buffer = TTL. RB1/INT1/SEG8, Description = PORTB<1> data input; weak pull-up when RBPU bit is cleared.. RB1/INT1/SEG8, Function = INT1. RB1/INT1/SEG8, TRIS Setting = 1. RB1/INT1/SEG8, I/O = I. RB1/INT1/SEG8, Buffer = ST. RB1/INT1/SEG8, Description = External interrupt 1 input.. RB1/INT1/SEG8, Function = SEG8. RB1/INT1/SEG8, TRIS Setting = x.",
    "TABLE 9-3: PORTB FUNCTIONS\nRB1/INT1/SEG8, I/O = O. RB1/INT1/SEG8, Buffer = ANA. RB1/INT1/SEG8, Description = Segment 8 analog output for LCD. Disables digital output.. RB2/INT2/SEG9, Function = RB2. RB2/INT2/SEG9, TRIS Setting = 0. RB2/INT2/SEG9, I/O = O. RB2/INT2/SEG9, Buffer = DIG. RB2/INT2/SEG9, Description = LATB<2> data output; disabled when LCD segment enabled.. RB2/INT2/SEG9, Function = RB2. RB2/INT2/SEG9, TRIS Setting = 1. RB2/INT2/SEG9, I/O = I. RB2/INT2/SEG9, Buffer = TTL. RB2/INT2/SEG9, Description = PORTB<2> data input; weak pull-up when RBPU bit is cleared..",
    "TABLE 9-3: PORTB FUNCTIONS\nRB2/INT2/SEG9, Function = INT2. RB2/INT2/SEG9, TRIS Setting = 1. RB2/INT2/SEG9, I/O = I. RB2/INT2/SEG9, Buffer = ST. RB2/INT2/SEG9, Description = External interrupt 2 input.. RB2/INT2/SEG9, Function = SEG9. RB2/INT2/SEG9, TRIS Setting = x. RB2/INT2/SEG9, I/O = O. RB2/INT2/SEG9, Buffer = ANA. RB2/INT2/SEG9, Description = Segment 9 analog output for LCD. RB3/INT3/ SEG10, Function = RB3. RB3/INT3/ SEG10, TRIS Setting = 0. RB3/INT3/ SEG10, I/O = O. RB3/INT3/ SEG10, Buffer = DIG. RB3/INT3/ SEG10, Description = LATB<3> data output; disabled when LCD segment",
    "TABLE 9-3: PORTB FUNCTIONS\nenabled.. RB3/INT3/ SEG10, Function = RB3. RB3/INT3/ SEG10, TRIS Setting = 1. RB3/INT3/ SEG10, I/O = I. RB3/INT3/ SEG10, Buffer = TTL. RB3/INT3/ SEG10, Description = PORTB<3> data input; weak pull-up when RBPU bit is cleared.. RB3/INT3/ SEG10, Function = INT3. RB3/INT3/ SEG10, TRIS Setting = 1. RB3/INT3/ SEG10, I/O = I. RB3/INT3/ SEG10, Buffer = ST. RB3/INT3/ SEG10, Description = External interrupt 3 input.. RB3/INT3/ SEG10, Function = SEG10. RB3/INT3/ SEG10, TRIS Setting = x. RB3/INT3/ SEG10, I/O = O. RB3/INT3/ SEG10, Buffer = ANA. RB3/INT3/ SEG10,",
    "TABLE 9-3: PORTB FUNCTIONS\nDescription = Segment 10 analog output for LCD.. RB4/KBI0/ SEG11, Function = RB4. RB4/KBI0/ SEG11, TRIS Setting = 0. RB4/KBI0/ SEG11, I/O = O. RB4/KBI0/ SEG11, Buffer = DIG. RB4/KBI0/ SEG11, Description = LATB<4> data output; disabled when LCD segment enabled.. RB4/KBI0/ SEG11, Function = RB4. RB4/KBI0/ SEG11, TRIS Setting = 1. RB4/KBI0/ SEG11, I/O = I. RB4/KBI0/ SEG11, Buffer = TTL. RB4/KBI0/ SEG11, Description = PORTB<4> data input; weak pull-up when RBPU bit is cleared.. RB4/KBI0/ SEG11, Function = KBI0. RB4/KBI0/ SEG11, TRIS Setting = 1. RB4/KBI0/ SEG11,",
    "TABLE 9-3: PORTB FUNCTIONS\nI/O = I. RB4/KBI0/ SEG11, Buffer = TTL. RB4/KBI0/ SEG11, Description = Interrupt-on-pin change.. RB4/KBI0/ SEG11, Function = SEG11. RB4/KBI0/ SEG11, TRIS Setting = x. RB4/KBI0/ SEG11, I/O = O. RB4/KBI0/ SEG11, Buffer = ANA. RB4/KBI0/ SEG11, Description = Segment 11 analog output for LCD.. RB5/KBI1, Function = RB5. RB5/KBI1, TRIS Setting = 0. RB5/KBI1, I/O = O. RB5/KBI1, Buffer = DIG. RB5/KBI1, Description = LATB<5> data output; disabled when LCD segment enabled.. RB5/KBI1, Function = RB5. RB5/KBI1, TRIS Setting = 1. RB5/KBI1, I/O = I.",
    "TABLE 9-3: PORTB FUNCTIONS\nRB5/KBI1, Buffer = TTL. RB5/KBI1, Description = PORTB<5> data input; weak pull-up when RBPU bit is cleared.. RB5/KBI1, Function = KBI1. RB5/KBI1, TRIS Setting = 1. RB5/KBI1, I/O = I. RB5/KBI1, Buffer = TTL. RB5/KBI1, Description = Interrupt-on-pin change.. RB6/KBI2/PGC, Function = RB6. RB6/KBI2/PGC, TRIS Setting = 0. RB6/KBI2/PGC, I/O = O. RB6/KBI2/PGC, Buffer = DIG. RB6/KBI2/PGC, Description = LATB<6> data output; unavailable when ICD or ICSPGLYPH<153> enabled.. RB6/KBI2/PGC, Function = RB6. RB6/KBI2/PGC, TRIS Setting = 1. RB6/KBI2/PGC,",
    "TABLE 9-3: PORTB FUNCTIONS\nI/O = I. RB6/KBI2/PGC, Buffer = TTL. RB6/KBI2/PGC, Description = PORTB<6> data input; unavailable when ICD or ICSP enabled.. RB6/KBI2/PGC, Function = KBI2. RB6/KBI2/PGC, TRIS Setting = 1. RB6/KBI2/PGC, I/O = I. RB6/KBI2/PGC, Buffer = TTL. RB6/KBI2/PGC, Description = Interrupt-on-pin change; unavailable when ICD or ICSP enabled.. RB6/KBI2/PGC, Function = PGC. RB6/KBI2/PGC, TRIS Setting = x. RB6/KBI2/PGC, I/O = I. RB6/KBI2/PGC, Buffer = ST. RB6/KBI2/PGC, Description = Serial execution (ICSP) clock input for ICSP and ICD operation. (1). RB7/KBI3/PGD, Function =",
    "TABLE 9-3: PORTB FUNCTIONS\nRB7. RB7/KBI3/PGD, TRIS Setting = 0. RB7/KBI3/PGD, I/O = O. RB7/KBI3/PGD, Buffer = DIG. RB7/KBI3/PGD, Description = LATB<7> data output; unavailable when ICD or ICSP enabled.. RB7/KBI3/PGD, Function = RB7. RB7/KBI3/PGD, TRIS Setting = 1. RB7/KBI3/PGD, I/O = I. RB7/KBI3/PGD, Buffer = TTL. RB7/KBI3/PGD, Description = PORTB<7> data input; unavailable when ICD or ICSP enabled.. RB7/KBI3/PGD, Function = KBI3. RB7/KBI3/PGD, TRIS Setting = 1. RB7/KBI3/PGD, I/O = I. RB7/KBI3/PGD, Buffer = TTL. RB7/KBI3/PGD, Description =",
    "TABLE 9-3: PORTB FUNCTIONS\nInterrupt-on-pin change; unavailable when ICD or ICSP enabled.. RB7/KBI3/PGD, Function = PGD. RB7/KBI3/PGD, TRIS Setting = x. RB7/KBI3/PGD, I/O = O. RB7/KBI3/PGD, Buffer = DIG. RB7/KBI3/PGD, Description = Serial execution data output for ICSP and ICD operation. (1). RB7/KBI3/PGD, Function = PGD. RB7/KBI3/PGD, TRIS Setting = x. RB7/KBI3/PGD, I/O = I. RB7/KBI3/PGD, Buffer = ST. RB7/KBI3/PGD, Description = Serial execution data input for ICSP and ICD operation. (1)\nLegend:\n- O = Output, I = Input, ANA = Analog Signal, DIG = Digital Output, ST = Schmitt Buffer Input, TTL = TTL Buffer Input,",
    "TABLE 9-3: PORTB FUNCTIONS\nx = DonGLYPH<146>t care (TRIS bit does not affect port direction or is overridden for this option).\n- Note 1: All other pin functions are disabled when ICSP or ICD are enabled.",
    "SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nPORTB, Bit 7 = RB7. PORTB, Bit 6 = RB6. PORTB, Bit 5 = RB5. PORTB, Bit 4 = RB4. PORTB, Bit 3 = RB3. PORTB, Bit 2 = RB2. PORTB, Bit 1 = RB1. PORTB, Bit 0 = RB0. PORTB, Reset Values on Page = 62. LATB, Bit 7 = LATB Data Output Register. LATB, Bit 6 = LATB Data Output Register. LATB, Bit 5 = LATB Data Output Register. LATB, Bit 4 = LATB Data Output Register. LATB, Bit 3 = LATB Data Output Register. LATB, Bit 2 = LATB Data Output Register. LATB, Bit 1 = LATB Data Output Register. LATB, Bit 0 = LATB Data Output Register. LATB, Reset Values on Page = 62. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB",
    "SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nData Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Reset Values on Page = 62. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = INTEDG3. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = INT3IP. INTCON2, Bit 0 =",
    "SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nRBIP. INTCON2, Reset Values on Page = 59. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = INT3IE. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = INT3IF. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Reset Values on Page = 59. LCDSE1, Bit 7 = SE15. LCDSE1, Bit 6 = SE14. LCDSE1, Bit 5 = SE13. LCDSE1, Bit 4 = SE12. LCDSE1, Bit 3 = SE11. LCDSE1, Bit 2 = SE10. LCDSE1, Bit 1 = SE9. LCDSE1, Bit 0 = SE8. LCDSE1, Reset Values on Page = 64\nLegend: Shaded cells are not used by PORTB.",
    "9.3 PORTC, TRISC and LATC Registers\nPORTC is an 8-bit wide, bidirectional port. The corresponding Data Direction register is  TRISC.  Setting a TRISC bit (= 1 )  will  make the corresponding PORTC pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISC bit (= 0 ) will make the corresponding PORTC pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATC)  is  also memory mapped.  Read-modify-write  operations  on  the  LATC register  read  and  write  the  latched  output  value  for PORTC.\nPORTC is multiplexed with several peripheral functions (Table 9-5). The  pins have Schmitt Trigger input buffers.  RC1  is  normally  configured  by  Configuration bit, CCP2MX, as the default peripheral pin of the CCP2 module (default/erased state, CCP2MX = 1 ).",
    "9.3 PORTC, TRISC and LATC Registers\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTC pin. Some peripherals override the TRIS bit to make a pin an output, while other peripherals override the TRIS bit to make a pin an input. The user should refer to the corresponding peripheral section for the correct TRIS bit settings.\nNote:\nOn  a  Power-on  Reset,  these  pins  are configured as digital inputs.\nThe  contents  of  the  TRISC  register  are  affected  by peripheral  overrides.  Reading  TRISC  always  returns the current contents, even though a peripheral device may be overriding one or more of the pins.\nRC2 and RC5 are also multiplexed with LCD segment drives  controlled  by  bits  in  the  LCDSE1  register.  I/O port  functions  are  only  available  when  the  segments are disabled.",
    "9.3 PORTC, TRISC and LATC Registers\nCLRF, EXAMPLE 9-3: = PORTC. CLRF, INITIALIZING PORTC = ; Initialize PORTC by ; clearing output ; data latches. CLRF, EXAMPLE 9-3: = LATC. CLRF, INITIALIZING PORTC = ; Alternate method ; to clear output ; data latches. MOVLW, EXAMPLE 9-3: = 0CFh. MOVLW, INITIALIZING PORTC = ; Value used to ; initialize data ; direction. MOVWF, EXAMPLE 9-3: = TRISC. MOVWF, INITIALIZING PORTC = ; Set RC<3:0> as inputs ; RC<5:4> as outputs ; RC<7:6> as inputs",
    "TABLE 9-5: PORTC FUNCTIONS\nRC0/T1OSO/ T13CKI/, Function = RC0. RC0/T1OSO/ T13CKI/, TRIS Setting = 0. RC0/T1OSO/ T13CKI/, I/O = O. RC0/T1OSO/ T13CKI/, Buffer = DIG. RC0/T1OSO/ T13CKI/, Description = LATC<0> data output; disabled when Timer1 oscillator is used.. RC0/T1OSO/ T13CKI/, Function = . RC0/T1OSO/ T13CKI/, TRIS Setting = 1. RC0/T1OSO/ T13CKI/, I/O = I. RC0/T1OSO/ T13CKI/, Buffer = ST. RC0/T1OSO/ T13CKI/, Description = PORTC<0> data input; disabled when Timer1 oscillator is used.. RC0/T1OSO/ T13CKI/, Function = T1OSO. RC0/T1OSO/ T13CKI/, TRIS Setting = x. RC0/T1OSO/",
    "TABLE 9-5: PORTC FUNCTIONS\nT13CKI/, I/O = O. RC0/T1OSO/ T13CKI/, Buffer = ANA. RC0/T1OSO/ T13CKI/, Description = Timer1 oscillator output.. RC0/T1OSO/ T13CKI/, Function = T13CKI. RC0/T1OSO/ T13CKI/, TRIS Setting = x. RC0/T1OSO/ T13CKI/, I/O = I. RC0/T1OSO/ T13CKI/, Buffer = ST. RC0/T1OSO/ T13CKI/, Description = Timer1/Timer3 clock input.. RC1/T1OSI/ CCP2, Function = RC1. RC1/T1OSI/ CCP2, TRIS Setting = 0. RC1/T1OSI/ CCP2, I/O = O. RC1/T1OSI/ CCP2, Buffer = DIG. RC1/T1OSI/ CCP2, Description = LATC<1> data output; disabled when Timer1 oscillator is used.. RC1/T1OSI/",
    "TABLE 9-5: PORTC FUNCTIONS\nCCP2, Function = . RC1/T1OSI/ CCP2, TRIS Setting = 1. RC1/T1OSI/ CCP2, I/O = I. RC1/T1OSI/ CCP2, Buffer = ST. RC1/T1OSI/ CCP2, Description = PORTC<1> data input; disabled when Timer1 oscillator is used.. RC1/T1OSI/ CCP2, Function = T1OSI. RC1/T1OSI/ CCP2, TRIS Setting = x. RC1/T1OSI/ CCP2, I/O = I. RC1/T1OSI/ CCP2, Buffer = ANA. RC1/T1OSI/ CCP2, Description = Timer1 oscillator input.. RC1/T1OSI/ CCP2, Function = CCP2 (1). RC1/T1OSI/ CCP2, TRIS Setting = 0. RC1/T1OSI/ CCP2, I/O = O. RC1/T1OSI/ CCP2, Buffer = DIG.",
    "TABLE 9-5: PORTC FUNCTIONS\nRC1/T1OSI/ CCP2, Description = CCP2 compare output or PWMoutput; takes priority over digital I/O data.. RC1/T1OSI/ CCP2, Function = . RC1/T1OSI/ CCP2, TRIS Setting = 1. RC1/T1OSI/ CCP2, I/O = I. RC1/T1OSI/ CCP2, Buffer = ST. RC1/T1OSI/ CCP2, Description = CCP2 capture input.. RC2/CCP1/ SEG13, Function = RC2. RC2/CCP1/ SEG13, TRIS Setting = 0. RC2/CCP1/ SEG13, I/O = O. RC2/CCP1/ SEG13, Buffer = DIG. RC2/CCP1/ SEG13, Description = LATC<2> data output; disabled when LCD segment enabled.. RC2/CCP1/ SEG13, Function = . RC2/CCP1/ SEG13, TRIS Setting = 1.",
    "TABLE 9-5: PORTC FUNCTIONS\nRC2/CCP1/ SEG13, I/O = I. RC2/CCP1/ SEG13, Buffer = ST. RC2/CCP1/ SEG13, Description = PORTC<2> data input.. RC2/CCP1/ SEG13, Function = CCP1. RC2/CCP1/ SEG13, TRIS Setting = 0. RC2/CCP1/ SEG13, I/O = O. RC2/CCP1/ SEG13, Buffer = DIG. RC2/CCP1/ SEG13, Description = CCP1 compare output or PWMoutput; takes priority over digital I/O data.. RC2/CCP1/ SEG13, Function = . RC2/CCP1/ SEG13, TRIS Setting = 1. RC2/CCP1/ SEG13, I/O = I. RC2/CCP1/ SEG13, Buffer = ST. RC2/CCP1/ SEG13, Description = CCP1 capture input.. RC2/CCP1/",
    "TABLE 9-5: PORTC FUNCTIONS\nSEG13, Function = SEG13. RC2/CCP1/ SEG13, TRIS Setting = x. RC2/CCP1/ SEG13, I/O = O. RC2/CCP1/ SEG13, Buffer = ANA. RC2/CCP1/ SEG13, Description = Segment 13 analog output for LCD.. RC3/SCK/SCL, Function = RC3. RC3/SCK/SCL, TRIS Setting = 0. RC3/SCK/SCL, I/O = O. RC3/SCK/SCL, Buffer = DIG. RC3/SCK/SCL, Description = LATC<3> data output.. RC3/SCK/SCL, Function = . RC3/SCK/SCL, TRIS Setting = 1. RC3/SCK/SCL, I/O = I. RC3/SCK/SCL, Buffer = ST. RC3/SCK/SCL, Description = PORTC<3> data input.. RC3/SCK/SCL, Function = SCK.",
    "TABLE 9-5: PORTC FUNCTIONS\nRC3/SCK/SCL, TRIS Setting = 0. RC3/SCK/SCL, I/O = O. RC3/SCK/SCL, Buffer = DIG. RC3/SCK/SCL, Description = SPI clock output (MSSP module); takes priority over port data.. RC3/SCK/SCL, Function = . RC3/SCK/SCL, TRIS Setting = 1. RC3/SCK/SCL, I/O = I. RC3/SCK/SCL, Buffer = ST. RC3/SCK/SCL, Description = SPI clock input (MSSP module).. RC3/SCK/SCL, Function = SCL. RC3/SCK/SCL, TRIS Setting = 0. RC3/SCK/SCL, I/O = O. RC3/SCK/SCL, Buffer = DIG. RC3/SCK/SCL, Description = I 2 CGLYPH<153> clock output (MSSP module); takes priority over port data.. RC3/SCK/SCL,",
    "TABLE 9-5: PORTC FUNCTIONS\nFunction = . RC3/SCK/SCL, TRIS Setting = 1. RC3/SCK/SCL, I/O = I. RC3/SCK/SCL, Buffer = ST. RC3/SCK/SCL, Description = I 2 C clock input (MSSP module); input type depends on module setting.. RC4/SDI/SDA, Function = RC4. RC4/SDI/SDA, TRIS Setting = 0. RC4/SDI/SDA, I/O = O. RC4/SDI/SDA, Buffer = DIG. RC4/SDI/SDA, Description = LATC<4> data output.. RC4/SDI/SDA, Function = . RC4/SDI/SDA, TRIS Setting = 1. RC4/SDI/SDA, I/O = I. RC4/SDI/SDA, Buffer = ST. RC4/SDI/SDA, Description = PORTC<4> data input.. RC4/SDI/SDA, Function = SDI.",
    "TABLE 9-5: PORTC FUNCTIONS\nRC4/SDI/SDA, TRIS Setting = 1. RC4/SDI/SDA, I/O = I. RC4/SDI/SDA, Buffer = ST. RC4/SDI/SDA, Description = SPI data input (MSSP module).. RC4/SDI/SDA, Function = SDA. RC4/SDI/SDA, TRIS Setting = 1. RC4/SDI/SDA, I/O = O. RC4/SDI/SDA, Buffer = DIG. RC4/SDI/SDA, Description = I 2 C data output (MSSP module); takes priority over port data.. RC4/SDI/SDA, Function = . RC4/SDI/SDA, TRIS Setting = 1. RC4/SDI/SDA, I/O = I. RC4/SDI/SDA, Buffer = ST. RC4/SDI/SDA, Description = I 2 C data input (MSSP module); input type depends on module setting.. RC5/SDO/ SEG12, Function =",
    "TABLE 9-5: PORTC FUNCTIONS\nRC5. RC5/SDO/ SEG12, TRIS Setting = 0. RC5/SDO/ SEG12, I/O = O. RC5/SDO/ SEG12, Buffer = DIG. RC5/SDO/ SEG12, Description = LATC<5> data output; disabled when LCD segment enabled.. RC5/SDO/ SEG12, Function = . RC5/SDO/ SEG12, TRIS Setting = 1. RC5/SDO/ SEG12, I/O = I. RC5/SDO/ SEG12, Buffer = ST. RC5/SDO/ SEG12, Description = PORTC<5> data input.. RC5/SDO/ SEG12, Function = SDO. RC5/SDO/ SEG12, TRIS Setting = 0. RC5/SDO/ SEG12, I/O = O. RC5/SDO/ SEG12, Buffer = DIG. RC5/SDO/ SEG12, Description = SPI data output (MSSP module); takes priority over port data..",
    "TABLE 9-5: PORTC FUNCTIONS\nRC5/SDO/ SEG12, Function = SEG12. RC5/SDO/ SEG12, TRIS Setting = x. RC5/SDO/ SEG12, I/O = O. RC5/SDO/ SEG12, Buffer = ANA. RC5/SDO/ SEG12, Description = Segment 12 analog output for LCD.. RC6/TX1/CK1, Function = RC6. RC6/TX1/CK1, TRIS Setting = 0. RC6/TX1/CK1, I/O = O. RC6/TX1/CK1, Buffer = DIG. RC6/TX1/CK1, Description = LATC<6> data output.. RC6/TX1/CK1, Function = . RC6/TX1/CK1, TRIS Setting = 1. RC6/TX1/CK1, I/O = I. RC6/TX1/CK1, Buffer = ST. RC6/TX1/CK1, Description = PORTC<6> data input.. RC6/TX1/CK1, Function = TX1.",
    "TABLE 9-5: PORTC FUNCTIONS\nRC6/TX1/CK1, TRIS Setting = 1. RC6/TX1/CK1, I/O = O. RC6/TX1/CK1, Buffer = DIG. RC6/TX1/CK1, Description = Synchronous serial data output (EUSART module); takes priority over port data.. RC6/TX1/CK1, Function = CK1. RC6/TX1/CK1, TRIS Setting = 1. RC6/TX1/CK1, I/O = O. RC6/TX1/CK1, Buffer = DIG. RC6/TX1/CK1, Description = Synchronous serial data input (EUSART module). User must configure as an input.. RC6/TX1/CK1, Function = . RC6/TX1/CK1, TRIS Setting = 1. RC6/TX1/CK1, I/O = I. RC6/TX1/CK1, Buffer = ST. RC6/TX1/CK1, Description = Synchronous serial clock input (EUSART",
    "TABLE 9-5: PORTC FUNCTIONS\nmodule).. RC7/RX1/DT1, Function = RC7. RC7/RX1/DT1, TRIS Setting = 0. RC7/RX1/DT1, I/O = O. RC7/RX1/DT1, Buffer = DIG. RC7/RX1/DT1, Description = LATC<7> data output.. RC7/RX1/DT1, Function = . RC7/RX1/DT1, TRIS Setting = 1. RC7/RX1/DT1, I/O = I. RC7/RX1/DT1, Buffer = ST. RC7/RX1/DT1, Description = PORTC<7> data input.. RC7/RX1/DT1, Function = RX1. RC7/RX1/DT1, TRIS Setting = 1. RC7/RX1/DT1, I/O = I. RC7/RX1/DT1, Buffer = ST. RC7/RX1/DT1, Description = Asynchronous serial receive data",
    "TABLE 9-5: PORTC FUNCTIONS\ninput (EUSART module).. RC7/RX1/DT1, Function = DT1. RC7/RX1/DT1, TRIS Setting = 1. RC7/RX1/DT1, I/O = O. RC7/RX1/DT1, Buffer = DIG. RC7/RX1/DT1, Description = Synchronous serial data output (EUSART module); takes priority over port data.. RC7/RX1/DT1, Function = . RC7/RX1/DT1, TRIS Setting = 1. RC7/RX1/DT1, I/O = I. RC7/RX1/DT1, Buffer = ST. RC7/RX1/DT1, Description = Synchronous serial data input (EUSART module). User must configure as an input.\nLegend:",
    "TABLE 9-5: PORTC FUNCTIONS\nO = Output, I = Input, ANA = Analog Signal, DIG = Digital Output, ST = Schmitt Buffer Input, TTL = TTL Buffer Input, x = DonGLYPH<146>t care (TRIS bit does not affect port direction or is overridden for this option).\nNote 1: Default assignment for CCP2 (CCP2MX Configuration bit = 1 ).",
    "TABLE 9-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nPORTC, Bit 7 = RC7. PORTC, Bit 6 = RC6. PORTC, Bit 5 = RC5. PORTC, Bit 4 = RC4. PORTC, Bit 3 = RC3. PORTC, Bit 2 = RC2. PORTC, Bit 1 = RC1. PORTC, Bit 0 = RC0. PORTC, Reset Values on Page = 62. LATC, Bit 7 = LATC Data Output Register. LATC, Bit 6 = LATC Data Output Register. LATC, Bit 5 = LATC Data Output Register. LATC, Bit 4 = LATC Data Output Register. LATC, Bit 3 = LATC Data Output Register. LATC, Bit 2 = LATC Data Output Register. LATC, Bit 1 = LATC Data Output Register. LATC, Bit 0 = LATC Data Output Register. LATC, Reset Values on Page = 62. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC",
    "TABLE 9-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nData Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Reset Values on Page = 62. LCDSE1, Bit 7 = SE15. LCDSE1, Bit 6 = SE14. LCDSE1, Bit 5 = SE13. LCDSE1, Bit 4 = SE12. LCDSE1, Bit 3 = SE11. LCDSE1, Bit 2 = SE10. LCDSE1, Bit 1 = SE9. LCDSE1, Bit 0 = SE8. LCDSE1, Reset Values on Page = 64\nLegend: Shaded cells are not used by PORTC.",
    "9.4 PORTD, TRISD and LATD Registers\nPORTD is also multiplexed with LCD segment drives controlled by the LCDSE0 register. I/O port functions are only available when the segments are disabled.\nPORTD is an 8-bit wide, bidirectional port. The corresponding Data Direction register is  TRISD.  Setting a TRISD bit (= 1 )  will  make the corresponding PORTD pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISD bit (= 0 ) will make the corresponding PORTD pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATD)  is  also memory mapped.  Read-modify-write  operations  on  the  LATD register  read  and  write  the  latched  output  value  for PORTD.\nAll  pins  on  PORTD  are  implemented  with  Schmitt Trigger input buffers. Each pin is individually configurable as an input or output.\nNote: On  a  Power-on  Reset,  these  pins  are configured as digital inputs.",
    "TABLE 9-7: PORTD FUNCTIONS\nRD0/SEG0, Function = RD0. RD0/SEG0, TRIS Setting = 0. RD0/SEG0, I/O = O. RD0/SEG0, Buffer = DIG. RD0/SEG0, Description = LATD<0> data output; disabled when LCD segment enabled.. RD0/SEG0, Function = RD0. RD0/SEG0, TRIS Setting = 1. RD0/SEG0, I/O = I. RD0/SEG0, Buffer = ST. RD0/SEG0, Description = PORTD<0> data input.. RD0/SEG0, Function = SEG0. RD0/SEG0, TRIS Setting = x. RD0/SEG0, I/O = O. RD0/SEG0, Buffer = ANA. RD0/SEG0, Description = Segment 0 analog output for LCD.. RD1/SEG1, Function = RD1. RD1/SEG1, TRIS Setting = 0. RD1/SEG1, I/O = O.",
    "TABLE 9-7: PORTD FUNCTIONS\nRD1/SEG1, Buffer = DIG. RD1/SEG1, Description = LATD<1> data output; disabled when LCD segment enabled.. RD1/SEG1, Function = RD1. RD1/SEG1, TRIS Setting = 1. RD1/SEG1, I/O = I. RD1/SEG1, Buffer = ST. RD1/SEG1, Description = PORTD<1> data input.. RD1/SEG1, Function = SEG1. RD1/SEG1, TRIS Setting = x. RD1/SEG1, I/O = O. RD1/SEG1, Buffer = ANA. RD1/SEG1, Description = Segment 1 analog output for LCD.. RD2/SEG2, Function = RD2. RD2/SEG2, TRIS Setting = 0. RD2/SEG2, I/O = O. RD2/SEG2, Buffer = DIG. RD2/SEG2, Description = LATD<2> data output; disabled when LCD segment enabled..",
    "TABLE 9-7: PORTD FUNCTIONS\nRD2/SEG2, Function = RD2. RD2/SEG2, TRIS Setting = 1. RD2/SEG2, I/O = I. RD2/SEG2, Buffer = ST. RD2/SEG2, Description = PORTD<2> data input.. RD2/SEG2, Function = SEG2. RD2/SEG2, TRIS Setting = x. RD2/SEG2, I/O = O. RD2/SEG2, Buffer = ANA. RD2/SEG2, Description = Segment 2 analog output for LCD.. RD3/SEG3, Function = RD3. RD3/SEG3, TRIS Setting = 0. RD3/SEG3, I/O = O. RD3/SEG3, Buffer = DIG. RD3/SEG3, Description = LATD<3> data output; disabled when LCD segment enabled.. RD3/SEG3, Function = RD3. RD3/SEG3, TRIS Setting = 1. RD3/SEG3, I/O = I.",
    "TABLE 9-7: PORTD FUNCTIONS\nRD3/SEG3, Buffer = ST. RD3/SEG3, Description = PORTD<3> data input.. RD3/SEG3, Function = SEG3. RD3/SEG3, TRIS Setting = x. RD3/SEG3, I/O = O. RD3/SEG3, Buffer = ANA. RD3/SEG3, Description = Segment 3 analog output for LCD.. RD4/SEG4, Function = RD4. RD4/SEG4, TRIS Setting = 0. RD4/SEG4, I/O = O. RD4/SEG4, Buffer = DIG. RD4/SEG4, Description = LATD<4> data output; disabled when LCD segment enabled.. RD4/SEG4, Function = RD4. RD4/SEG4, TRIS Setting = 1. RD4/SEG4, I/O = I. RD4/SEG4, Buffer = ST. RD4/SEG4, Description = PORTD<4> data input.. RD4/SEG4, Function =",
    "TABLE 9-7: PORTD FUNCTIONS\nSEG4. RD4/SEG4, TRIS Setting = x. RD4/SEG4, I/O = O. RD4/SEG4, Buffer = ANA. RD4/SEG4, Description = Segment 4 analog output for LCD module.. RD5/SEG5, Function = RD5. RD5/SEG5, TRIS Setting = 0. RD5/SEG5, I/O = O. RD5/SEG5, Buffer = DIG. RD5/SEG5, Description = LATD<5> data output; disabled when LCD segment enabled.. RD5/SEG5, Function = RD5. RD5/SEG5, TRIS Setting = 1. RD5/SEG5, I/O = I. RD5/SEG5, Buffer = ST. RD5/SEG5, Description = PORTD<5> data input.. RD5/SEG5, Function = SEG5. RD5/SEG5, TRIS Setting = x. RD5/SEG5, I/O = O. RD5/SEG5, Buffer =",
    "TABLE 9-7: PORTD FUNCTIONS\nANA. RD5/SEG5, Description = Segment 5 analog output for LCD.. RD6/SEG6, Function = RD6. RD6/SEG6, TRIS Setting = 0. RD6/SEG6, I/O = O. RD6/SEG6, Buffer = DIG. RD6/SEG6, Description = LATD<6> data output; disabled when LCD segment enabled.. RD6/SEG6, Function = RD6. RD6/SEG6, TRIS Setting = 1. RD6/SEG6, I/O = I. RD6/SEG6, Buffer = ST. RD6/SEG6, Description = PORTD<6> data input.. RD6/SEG6, Function = SEG6. RD6/SEG6, TRIS Setting = x. RD6/SEG6, I/O = O. RD6/SEG6, Buffer = ANA. RD6/SEG6, Description = Segment 6 analog output for LCD.. RD7/SEG7, Function = RD7. RD7/SEG7, TRIS",
    "TABLE 9-7: PORTD FUNCTIONS\nSetting = 0. RD7/SEG7, I/O = O. RD7/SEG7, Buffer = DIG. RD7/SEG7, Description = LATD<7> data output; disabled when LCD segment enabled.. RD7/SEG7, Function = RD7. RD7/SEG7, TRIS Setting = 1. RD7/SEG7, I/O = I. RD7/SEG7, Buffer = ST. RD7/SEG7, Description = PORTD<7> data input.. RD7/SEG7, Function = SEG7. RD7/SEG7, TRIS Setting = x. RD7/SEG7, I/O = O. RD7/SEG7, Buffer = ANA. RD7/SEG7, Description = Segment 7 analog output for LCD.\nLegend:",
    "TABLE 9-7: PORTD FUNCTIONS\nO = Output, I = Input, ANA = Analog Signal, DIG = Digital Output, ST = Schmitt Buffer Input, TTL = TTL Buffer Input, x = DonGLYPH<146>t care (TRIS bit does not affect port direction or is overridden for this option).\nCLRF, 9-4: = PORTD. CLRF, INITIALIZING PORTD = ; Initialize PORTD by ; clearing output ; data latches. CLRF, 9-4: = LATD. CLRF, INITIALIZING PORTD = ; Alternate method ; to clear output ; data latches. MOVLW, 9-4: = 0CFh. MOVLW, INITIALIZING PORTD = ; Value used to ; initialize data ; direction. MOVWF, 9-4: = TRISD. MOVWF, INITIALIZING PORTD = ; Set RD<3:0> as inputs ; RD<5:4> as outputs ; RD<7:6> as inputs",
    "TABLE 9-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nPORTD, Bit 7 = RD7. PORTD, Bit 6 = RD6. PORTD, Bit 5 = RD5. PORTD, Bit 4 = RD4. PORTD, Bit 3 = RD3. PORTD, Bit 2 = RD2. PORTD, Bit 1 = RD1. PORTD, Bit 0 = RD0. PORTD, Reset Values on Page = 62. LATD, Bit 7 = LATD Data Output Register. LATD, Bit 6 = LATD Data Output Register. LATD, Bit 5 = LATD Data Output Register. LATD, Bit 4 = LATD Data Output Register. LATD, Bit 3 = LATD Data Output Register. LATD, Bit 2 = LATD Data Output Register. LATD, Bit 1 = LATD Data Output Register. LATD, Bit 0 = LATD Data Output Register. LATD, Reset Values on Page = 62. TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD,",
    "TABLE 9-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nBit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Reset Values on Page = 62. LCDSE0, Bit 7 = SE7. LCDSE0, Bit 6 = SE6. LCDSE0, Bit 5 = SE5. LCDSE0, Bit 4 = SE4. LCDSE0, Bit 3 = SE3. LCDSE0, Bit 2 = SE2. LCDSE0, Bit 1 = SE1. LCDSE0, Bit 0 = SE0. LCDSE0, Reset Values on Page = 64",
    "9.5 PORTE, TRISE and LATE Registers\nRE7 also can be configured as the alternate peripheral pin for the CCP2 module. This is done by clearing the CCP2MX Configuration bit.\nPORTE is a 4-bit wide, bidirectional  port.  The corresponding Data Direction register is  TRISE.  Setting  a TRISE bit (= 1 )  will  make the corresponding PORTE pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISE bit (= 0 ) will make the corresponding PORTE pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATE)  is also memory mapped.  Read-modify-write  operations  on  the  LATE register  read  and  write  the  latched  output  value  for PORTE.\nAll  pins  on  PORTE  are  implemented  with  Schmitt Trigger input buffers. Each pin is individually configurable as an input or output.\nNote: On  a  Power-on  Reset,  these  pins  are configured as digital inputs.",
    "9.5 PORTE, TRISE and LATE Registers\nPins RE6:RE4 are multiplexed with three of the LCD common drives. I/O port functions are only available on those PORTE pins, depending on which commons are active. The configuration is determined by the LMUX1:LMUX0  control  bits (LCDCON<1:0>).  The availability is summarized in Table 9-9.\nRE7  is  also  multiplexed  with  LCD  segment  drive (SEG31)  controlled  by  the  LCDSE3<7>  bit.  I/O  port function is only available when the segment is disabled.\nNote:\nThe  pins  corresponding  to  RE2:RE0  of other  PIC18F  parts  have  the  function  of LCDBIAS3:LCDBIAS1 and the pin corresponding  to  RE3  of  other  PIC18F parts has the function of COM0. These four pins cannot be used as digital I/O.",
    "TABLE 9-9: PORTE PINS AVAILABLE IN DIFFERENT LCD DRIVE CONFIGURATIONS\n00, Active LCD Commons = COM0. 00, PORTE Available for I/O = RE6, RE5, RE4. 01, Active LCD Commons = COM0, COM1. 01, PORTE Available for I/O = RE6, RE5. 10, Active LCD Commons = COM0, COM1 and COM2. 10, PORTE Available for I/O = RE6. 11, Active LCD Commons = All (COM0 through COM3). 11, PORTE Available for I/O = None",
    "EXAMPLE 9-5: INITIALIZING PORTE\nCLRF, 1 = PORTE. CLRF, 2 = ; Initialize PORTE by ; clearing output ; data latches. CLRF, 1 = LATE. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 30h. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISE. MOVWF, 2 = ; Set RE<5:4> as inputs ; RE<7:6> as outputs",
    "TABLE 9-10: PORTE FUNCTIONS\nRE4/COM1, Function = RE4. RE4/COM1, TRIS Setting = 0. RE4/COM1, I/O = O. RE4/COM1, Buffer = DIG. RE4/COM1, Description = LATE<4> data output; disabled when LCD common enabled.. RE4/COM1, Function = RE4. RE4/COM1, TRIS Setting = 1. RE4/COM1, I/O = I. RE4/COM1, Buffer = ST. RE4/COM1, Description = PORTE<4> data input.. RE4/COM1, Function = COM1. RE4/COM1, TRIS Setting = x. RE4/COM1, I/O = O. RE4/COM1, Buffer = ANA. RE4/COM1, Description = Common 1 analog output for LCD.. RE5/COM2, Function = RE5. RE5/COM2, TRIS Setting = 0. RE5/COM2, I/O = O. RE5/COM2, Buffer = DIG. RE5/COM2, Description = LATE<5> data output;",
    "TABLE 9-10: PORTE FUNCTIONS\ndisabled when LCD common enabled.. RE5/COM2, Function = RE5. RE5/COM2, TRIS Setting = 1. RE5/COM2, I/O = I. RE5/COM2, Buffer = ST. RE5/COM2, Description = PORTE<5> data input.. RE5/COM2, Function = COM2. RE5/COM2, TRIS Setting = x. RE5/COM2, I/O = O. RE5/COM2, Buffer = ANA. RE5/COM2, Description = Common 2 analog output for LCD.. RE6/COM3, Function = RE6. RE6/COM3, TRIS Setting = 0. RE6/COM3, I/O = O. RE6/COM3, Buffer = DIG. RE6/COM3, Description = LATE<6> data output; disabled when LCD segment enabled.. RE6/COM3, Function = RE6. RE6/COM3, TRIS Setting = 1. RE6/COM3, I/O = I. RE6/COM3, Buffer = ST. RE6/COM3, Description =",
    "TABLE 9-10: PORTE FUNCTIONS\nPORTE<6> data input.. RE6/COM3, Function = COM3. RE6/COM3, TRIS Setting = x. RE6/COM3, I/O = O. RE6/COM3, Buffer = ANA. RE6/COM3, Description = Common 3 analog output for LCD.. RE7/CCP2/ SEG31, Function = RE7. RE7/CCP2/ SEG31, TRIS Setting = 0. RE7/CCP2/ SEG31, I/O = O. RE7/CCP2/ SEG31, Buffer = DIG. RE7/CCP2/ SEG31, Description = LATE<7> data output; disabled when LCD segment enabled.. RE7/CCP2/ SEG31, Function = RE7. RE7/CCP2/ SEG31, TRIS Setting = 1. RE7/CCP2/ SEG31, I/O = I. RE7/CCP2/ SEG31, Buffer = ST. RE7/CCP2/ SEG31, Description = PORTE<7> data input..",
    "TABLE 9-10: PORTE FUNCTIONS\nRE7/CCP2/ SEG31, Function = CCP2 (1). RE7/CCP2/ SEG31, TRIS Setting = 0. RE7/CCP2/ SEG31, I/O = O. RE7/CCP2/ SEG31, Buffer = DIG. RE7/CCP2/ SEG31, Description = CCP2 compare output and CCP2 PWM output; takes priority over port data.. RE7/CCP2/ SEG31, Function = CCP2 (1). RE7/CCP2/ SEG31, TRIS Setting = 1. RE7/CCP2/ SEG31, I/O = I. RE7/CCP2/ SEG31, Buffer = ST. RE7/CCP2/ SEG31, Description = CCP2 capture input.. RE7/CCP2/ SEG31, Function = SEG31. RE7/CCP2/ SEG31, TRIS Setting = x. RE7/CCP2/ SEG31, I/O = O.",
    "TABLE 9-10: PORTE FUNCTIONS\nRE7/CCP2/ SEG31, Buffer = ANA. RE7/CCP2/ SEG31, Description = Segment 31 analog output for LCD.\nLegend:\nO = Output, I = Input, ANA = Analog Signal, DIG = Digital Output, ST = Schmitt Buffer Input, TTL = TTL Buffer Input, x = DonGLYPH<146>t care (TRIS bit does not affect port direction or is overridden for this option).\nNote 1: Alternate assignment for CCP2 when the CCP2MX Configuration bit = 0 .",
    "TABLE 9-11: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nPORTE, Bit 7 = RE7. PORTE, Bit 6 = RE6. PORTE, Bit 5 = RE5. PORTE, Bit 4 = RE4. PORTE, Bit 3 = GLYPH<151>. PORTE, Bit 2 = GLYPH<151>. PORTE, Bit 1 = GLYPH<151>. PORTE, Bit 0 = GLYPH<151>. PORTE, Reset Values on Page = 62. LATE, Bit 7 = LATE Data Output Register. LATE, Bit 6 = LATE Data Output Register. LATE, Bit 5 = LATE Data Output Register. LATE, Bit 4 = LATE Data Output Register. LATE, Bit 3 = GLYPH<151>. LATE, Bit 2 = GLYPH<151>. LATE, Bit 1 = GLYPH<151>. LATE, Bit 0 = GLYPH<151>. LATE, Reset Values on Page = 62. TRISE, Bit 7 = PORTE Data Direction Register. TRISE, Bit 6 = PORTE Data Direction Register. TRISE, Bit 5 = PORTE Data Direction Register. TRISE, Bit 4 = PORTE Data Direction Register. TRISE, Bit 3 = GLYPH<151>.",
    "TABLE 9-11: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nTRISE, Bit 2 = GLYPH<151>. TRISE, Bit 1 = GLYPH<151>. TRISE, Bit 0 = GLYPH<151>. TRISE, Reset Values on Page = 62. LCDCON, Bit 7 = LCDEN. LCDCON, Bit 6 = SLPEN. LCDCON, Bit 5 = WERR. LCDCON, Bit 4 = GLYPH<151>. LCDCON, Bit 3 = CS1. LCDCON, Bit 2 = CS0. LCDCON, Bit 1 = LMUX1. LCDCON, Bit 0 = LMUX0. LCDCON, Reset Values on Page = 64. LCDSE3, Bit 7 = SE31. LCDSE3, Bit 6 = SE30. LCDSE3, Bit 5 = SE29. LCDSE3, Bit 4 = SE28. LCDSE3, Bit 3 = SE27. LCDSE3, Bit 2 = SE26. LCDSE3, Bit 1 = SE25. LCDSE3, Bit 0 = SE24. LCDSE3, Reset Values on Page = 64",
    "TABLE 9-11: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used by PORTE.",
    "9.6 PORTF, LATF and TRISF Registers\nPORTF is an 8-bit wide, bidirectional port. The corresponding  Data  Direction  register  is  TRISF.  Setting  a TRISF bit (= 1 ) will make the corresponding PORTF pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISF bit (= 0 ) will make the corresponding PORTF pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATF)  is also memory mapped.  Read-modify-write  operations  on  the  LATF register  read  and  write  the  latched  output  value  for PORTF.\nAll  pins  on  PORTF  are  implemented  with  Schmitt Trigger input buffers. Each pin is individually configurable as an input or output.",
    "9.6 PORTF, LATF and TRISF Registers\nCLRF, EXAMPLE 9-6: = PORTF. CLRF, INITIALIZING PORTF = ; Initialize PORTF by ; clearing output ; data latches. CLRF, EXAMPLE 9-6: = LATF. CLRF, INITIALIZING PORTF = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF MOVLW, EXAMPLE 9-6: = 0x07 CMCON 0x0F. MOVLW MOVWF MOVLW, INITIALIZING PORTF = ; ; Turn off comparators ;. MOVWF, EXAMPLE 9-6: = ADCON1. MOVWF, INITIALIZING PORTF = ; Set PORTF as digital I/O. MOVLW, EXAMPLE 9-6: = 0xCF. MOVLW, INITIALIZING PORTF = ; Value used to ; initialize data ; direction. MOVWF, EXAMPLE 9-6: = TRISF. MOVWF, INITIALIZING PORTF = ; Set RF3:RF0 as inputs ; RF5:RF4 as outputs ; RF7:RF6 as inputs",
    "9.6 PORTF, LATF and TRISF Registers\nPORTF is multiplexed with several analog peripheral functions, including the A/D  converter  inputs  and comparator inputs, outputs and voltage reference.\nNote 1: On a Power-on Reset, the RF6:RF0 pins are configured as inputs and read as GLYPH<145> 0 GLYPH<146> .\n2: To configure PORTF as digital I/O, turn off comparators and set ADCON1 value.\nPORTF is also multiplexed with LCD segment drives controlled by bits in the LCDSE2  and  LCDSE3 registers. I/O port functions are only available when the segments are disabled.",
    "TABLE 9-12: PORTF FUNCTIONS\nRF0/AN5/ SEG18, Function = RF0. RF0/AN5/ SEG18, TRIS Setting = 0. RF0/AN5/ SEG18, I/O = O. RF0/AN5/ SEG18, Buffer = DIG. RF0/AN5/ SEG18, Description = LATF<0> data output. Output is unaffected by analog input; disabled when LCD segment is enabled.. RF0/AN5/ SEG18, Function = RF0. RF0/AN5/ SEG18, TRIS Setting = 1. RF0/AN5/ SEG18, I/O = I. RF0/AN5/ SEG18, Buffer = ST. RF0/AN5/ SEG18, Description = PORTF<0> data input. Reads GLYPH<145> 0 GLYPH<146> on POR.. RF0/AN5/ SEG18, Function = AN5. RF0/AN5/ SEG18, TRIS Setting = 1. RF0/AN5/ SEG18, I/O = I. RF0/AN5/",
    "TABLE 9-12: PORTF FUNCTIONS\nSEG18, Buffer = ANA. RF0/AN5/ SEG18, Description = A/D input channel 5. Default configuration on POR.. RF0/AN5/ SEG18, Function = SEG18. RF0/AN5/ SEG18, TRIS Setting = x. RF0/AN5/ SEG18, I/O = O. RF0/AN5/ SEG18, Buffer = ANA. RF0/AN5/ SEG18, Description = Segment 18 analog output for LCD.. RF1/AN6/ C2OUT/SEG19, Function = RF1. RF1/AN6/ C2OUT/SEG19, TRIS Setting = 0. RF1/AN6/ C2OUT/SEG19, I/O = O. RF1/AN6/ C2OUT/SEG19, Buffer = DIG. RF1/AN6/ C2OUT/SEG19, Description = LATF<1> data output. Output is unaffected by analog input; disabled when LCD segment is enabled.. RF1/AN6/ C2OUT/SEG19, Function = RF1.",
    "TABLE 9-12: PORTF FUNCTIONS\nRF1/AN6/ C2OUT/SEG19, TRIS Setting = 1. RF1/AN6/ C2OUT/SEG19, I/O = I. RF1/AN6/ C2OUT/SEG19, Buffer = ST. RF1/AN6/ C2OUT/SEG19, Description = PORTF<1> data input. Reads GLYPH<145> 0 GLYPH<146> on POR.. RF1/AN6/ C2OUT/SEG19, Function = AN6. RF1/AN6/ C2OUT/SEG19, TRIS Setting = 1. RF1/AN6/ C2OUT/SEG19, I/O = I. RF1/AN6/ C2OUT/SEG19, Buffer = ANA. RF1/AN6/ C2OUT/SEG19, Description = A/D input channel 6. Default configuration on POR.. RF1/AN6/ C2OUT/SEG19, Function = C2OUT. RF1/AN6/ C2OUT/SEG19, TRIS Setting = 0. RF1/AN6/ C2OUT/SEG19,",
    "TABLE 9-12: PORTF FUNCTIONS\nI/O = O. RF1/AN6/ C2OUT/SEG19, Buffer = DIG. RF1/AN6/ C2OUT/SEG19, Description = Comparator 2 output; takes priority over port data.. RF1/AN6/ C2OUT/SEG19, Function = SEG19. RF1/AN6/ C2OUT/SEG19, TRIS Setting = x. RF1/AN6/ C2OUT/SEG19, I/O = O. RF1/AN6/ C2OUT/SEG19, Buffer = ANA. RF1/AN6/ C2OUT/SEG19, Description = Segment 19 analog output for LCD.. RF2/AN7/ C1OUT/SEG20, Function = RF2. RF2/AN7/ C1OUT/SEG20, TRIS Setting = 0. RF2/AN7/ C1OUT/SEG20, I/O = O. RF2/AN7/ C1OUT/SEG20, Buffer = DIG. RF2/AN7/ C1OUT/SEG20, Description = LATF<2> data output. Output is unaffected by",
    "TABLE 9-12: PORTF FUNCTIONS\nanalog input; disabled when LCD segment is enabled.. RF2/AN7/ C1OUT/SEG20, Function = RF2. RF2/AN7/ C1OUT/SEG20, TRIS Setting = 1. RF2/AN7/ C1OUT/SEG20, I/O = I. RF2/AN7/ C1OUT/SEG20, Buffer = ST. RF2/AN7/ C1OUT/SEG20, Description = PORTF<2> data input. Reads GLYPH<145> 0 GLYPH<146> on POR.. RF2/AN7/ C1OUT/SEG20, Function = AN7. RF2/AN7/ C1OUT/SEG20, TRIS Setting = 1. RF2/AN7/ C1OUT/SEG20, I/O = I. RF2/AN7/ C1OUT/SEG20, Buffer = ANA. RF2/AN7/ C1OUT/SEG20, Description = A/D input channel 7. Default configuration on POR.. RF2/AN7/ C1OUT/SEG20, Function = C1OUT.",
    "TABLE 9-12: PORTF FUNCTIONS\nRF2/AN7/ C1OUT/SEG20, TRIS Setting = 0. RF2/AN7/ C1OUT/SEG20, I/O = O. RF2/AN7/ C1OUT/SEG20, Buffer = TTL. RF2/AN7/ C1OUT/SEG20, Description = Comparator 1 output; takes priority over port data.. RF2/AN7/ C1OUT/SEG20, Function = SEG20. RF2/AN7/ C1OUT/SEG20, TRIS Setting = x. RF2/AN7/ C1OUT/SEG20, I/O = O. RF2/AN7/ C1OUT/SEG20, Buffer = ANA. RF2/AN7/ C1OUT/SEG20, Description = Segment 20 analog output for LCD.. RF3/AN8/ SEG21, Function = RF3. RF3/AN8/ SEG21, TRIS Setting = 0. RF3/AN8/ SEG21, I/O = O. RF3/AN8/ SEG21, Buffer = DIG. RF3/AN8/",
    "TABLE 9-12: PORTF FUNCTIONS\nSEG21, Description = LATF<3> data output. Output is unaffected by analog input; disabled when LCD segment is enabled.. RF3/AN8/ SEG21, Function = RF3. RF3/AN8/ SEG21, TRIS Setting = 1. RF3/AN8/ SEG21, I/O = I. RF3/AN8/ SEG21, Buffer = ST. RF3/AN8/ SEG21, Description = PORTF<3> data input. Reads GLYPH<145> 0 GLYPH<146> on POR.. RF3/AN8/ SEG21, Function = AN8. RF3/AN8/ SEG21, TRIS Setting = 1. RF3/AN8/ SEG21, I/O = I. RF3/AN8/ SEG21, Buffer = ANA. RF3/AN8/ SEG21, Description = A/D input channel 8 and Comparator C2+ input. Default input configuration on POR; not affected by analog output.. RF3/AN8/ SEG21, Function = SEG21.",
    "TABLE 9-12: PORTF FUNCTIONS\nRF3/AN8/ SEG21, TRIS Setting = x. RF3/AN8/ SEG21, I/O = O. RF3/AN8/ SEG21, Buffer = ANA. RF3/AN8/ SEG21, Description = Segment 21 analog output for LCD.. RF4/AN9/ SEG22, Function = RF4. RF4/AN9/ SEG22, TRIS Setting = 0. RF4/AN9/ SEG22, I/O = O. RF4/AN9/ SEG22, Buffer = DIG. RF4/AN9/ SEG22, Description = LATF<4> data output. Output is unaffected by analog input; disabled when LCD segment is enabled.. RF4/AN9/ SEG22, Function = RF4. RF4/AN9/ SEG22, TRIS Setting = 1. RF4/AN9/ SEG22, I/O = I. RF4/AN9/ SEG22, Buffer = ST. RF4/AN9/ SEG22, Description = PORTF<4> data input. Reads",
    "TABLE 9-12: PORTF FUNCTIONS\nGLYPH<145> 0 GLYPH<146> on POR.. RF4/AN9/ SEG22, Function = AN9. RF4/AN9/ SEG22, TRIS Setting = 1. RF4/AN9/ SEG22, I/O = I. RF4/AN9/ SEG22, Buffer = ANA. RF4/AN9/ SEG22, Description = A/D input channel 9 and Comparator C2- input. Default input configuration on POR; does not affect digital output.. RF4/AN9/ SEG22, Function = SEG22. RF4/AN9/ SEG22, TRIS Setting = x. RF4/AN9/ SEG22, I/O = O. RF4/AN9/ SEG22, Buffer = ANA. RF4/AN9/ SEG22, Description = Segment 22 analog output for LCD.. RF5/AN10/ CVREF/SEG23, Function = RF5. RF5/AN10/ CVREF/SEG23, TRIS Setting = 0. RF5/AN10/",
    "TABLE 9-12: PORTF FUNCTIONS\nCVREF/SEG23, I/O = O. RF5/AN10/ CVREF/SEG23, Buffer = DIG. RF5/AN10/ CVREF/SEG23, Description = LATF<5> data output. Output unaffected by analog input; disabled when either LCD segment or CVREF is enabled.. RF5/AN10/ CVREF/SEG23, Function = RF5. RF5/AN10/ CVREF/SEG23, TRIS Setting = 1. RF5/AN10/ CVREF/SEG23, I/O = I. RF5/AN10/ CVREF/SEG23, Buffer = ST. RF5/AN10/ CVREF/SEG23, Description = PORTF<5> data input. Reads GLYPH<145> 0 GLYPH<146> on POR.. RF5/AN10/ CVREF/SEG23, Function = AN10. RF5/AN10/ CVREF/SEG23, TRIS Setting = 1. RF5/AN10/ CVREF/SEG23,",
    "TABLE 9-12: PORTF FUNCTIONS\nI/O = I. RF5/AN10/ CVREF/SEG23, Buffer = ANA. RF5/AN10/ CVREF/SEG23, Description = A/D input channel 10 and Comparator C1+ input. Default input configuration on POR.. RF5/AN10/ CVREF/SEG23, Function = CVREF. RF5/AN10/ CVREF/SEG23, TRIS Setting = 0. RF5/AN10/ CVREF/SEG23, I/O = O. RF5/AN10/ CVREF/SEG23, Buffer = ANA. RF5/AN10/ CVREF/SEG23, Description = Comparator voltage reference output. Enabling this feature disables digital I/O.. RF5/AN10/ CVREF/SEG23, Function = SEG23. RF5/AN10/ CVREF/SEG23, TRIS Setting = x. RF5/AN10/ CVREF/SEG23, I/O = O. RF5/AN10/ CVREF/SEG23,",
    "TABLE 9-12: PORTF FUNCTIONS\nBuffer = ANA. RF5/AN10/ CVREF/SEG23, Description = Segment 23 analog output for LCD.. RF6/AN11/ SEG24, Function = RF6. RF6/AN11/ SEG24, TRIS Setting = 0. RF6/AN11/ SEG24, I/O = O. RF6/AN11/ SEG24, Buffer = DIG. RF6/AN11/ SEG24, Description = LATF<6> data output. Output is unaffected by analog input; disabled when LCD segment is enabled.. RF6/AN11/ SEG24, Function = RF6. RF6/AN11/ SEG24, TRIS Setting = 1. RF6/AN11/ SEG24, I/O = I. RF6/AN11/ SEG24, Buffer = ST. RF6/AN11/ SEG24, Description = PORTF<6> data input. Reads GLYPH<145> 0 GLYPH<146> on POR.. RF6/AN11/ SEG24, Function = AN11. RF6/AN11/ SEG24,",
    "TABLE 9-12: PORTF FUNCTIONS\nTRIS Setting = 1. RF6/AN11/ SEG24, I/O = I. RF6/AN11/ SEG24, Buffer = ANA. RF6/AN11/ SEG24, Description = A/D input channel 11 and Comparator C1- input. Default input configuration on POR; does not affect digital output.. RF6/AN11/ SEG24, Function = SEG24. RF6/AN11/ SEG24, TRIS Setting = x. RF6/AN11/ SEG24, I/O = O. RF6/AN11/ SEG24, Buffer = ANA. RF6/AN11/ SEG24, Description = Segment 24 analog output for LCD.. RF7/SS/SEG25, Function = RF7. RF7/SS/SEG25, TRIS Setting = 0. RF7/SS/SEG25, I/O = O. RF7/SS/SEG25, Buffer = DIG. RF7/SS/SEG25, Description = LATF<7> data output; disabled when LCD segment is enabled..",
    "TABLE 9-12: PORTF FUNCTIONS\nRF7/SS/SEG25, Function = RF7. RF7/SS/SEG25, TRIS Setting = 1. RF7/SS/SEG25, I/O = I. RF7/SS/SEG25, Buffer = ST. RF7/SS/SEG25, Description = PORTF<7> data input.. RF7/SS/SEG25, Function = SS. RF7/SS/SEG25, TRIS Setting = 1. RF7/SS/SEG25, I/O = I. RF7/SS/SEG25, Buffer = TTL. RF7/SS/SEG25, Description = Slave select input for MSSP module.. RF7/SS/SEG25, Function = SEG25. RF7/SS/SEG25, TRIS Setting = x. RF7/SS/SEG25, I/O = O. RF7/SS/SEG25, Buffer = ANA. RF7/SS/SEG25, Description = Segment 25 analog output for LCD.",
    "TABLE 9-12: PORTF FUNCTIONS\nLegend: O = Output, I = Input, ANA = Analog Signal, DIG = Digital Output, ST = Schmitt Buffer Input, TTL = TTL Buffer Input, x = DonGLYPH<146>t care (TRIS bit does not affect port direction or is overridden for this option).",
    "TABLE 9-13: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nTRISF, Bit 7 = PORTF Data Direction Register. TRISF, Bit 6 = PORTF Data Direction Register. TRISF, Bit 5 = PORTF Data Direction Register. TRISF, Bit 4 = PORTF Data Direction Register. TRISF, Bit 3 = PORTF Data Direction Register. TRISF, Bit 2 = PORTF Data Direction Register. TRISF, Bit 1 = PORTF Data Direction Register. TRISF, Bit 0 = PORTF Data Direction Register. TRISF, Reset Values on Page = 62. PORTF, Bit 7 = Read PORTF Data Latch/Write PORTF Data Latch. PORTF, Bit 6 = Read PORTF Data Latch/Write PORTF Data Latch. PORTF, Bit 5 = Read PORTF Data Latch/Write PORTF Data Latch. PORTF, Bit 4 = Read PORTF Data Latch/Write PORTF Data Latch. PORTF, Bit 3 = Read PORTF Data Latch/Write PORTF Data Latch. PORTF, Bit 2 = Read PORTF Data Latch/Write PORTF Data Latch. PORTF, Bit 1 = Read PORTF Data Latch/Write PORTF Data Latch. PORTF, Bit 0 = Read PORTF Data",
    "TABLE 9-13: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nLatch/Write PORTF Data Latch. PORTF, Reset Values on Page = 62. LATF, Bit 7 = LATF Data Output Register. LATF, Bit 6 = LATF Data Output Register. LATF, Bit 5 = LATF Data Output Register. LATF, Bit 4 = LATF Data Output Register. LATF, Bit 3 = LATF Data Output Register. LATF, Bit 2 = LATF Data Output Register. LATF, Bit 1 = LATF Data Output Register. LATF, Bit 0 = LATF Data Output Register. LATF, Reset Values on Page = 62. ADCON1, Bit 7 = GLYPH<151>. ADCON1, Bit 6 = GLYPH<151>. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Reset Values on Page = 61. CMCON, Bit 7 = C2OUT.",
    "TABLE 9-13: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nCMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Reset Values on Page = 61. CVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0. CVRCON, Reset Values on Page = 61. LCDSE2, Bit 7 = SE23. LCDSE2, Bit 6 = SE22. LCDSE2, Bit 5 = SE21. LCDSE2, Bit 4 = SE20. LCDSE2, Bit 3 = SE19. LCDSE2, Bit 2 = SE18. LCDSE2, Bit 1 = SE17.",
    "TABLE 9-13: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nLCDSE2, Bit 0 = SE16. LCDSE2, Reset Values on Page = 64. LCDSE3, Bit 7 = SE31. LCDSE3, Bit 6 = SE30. LCDSE3, Bit 5 = SE29. LCDSE3, Bit 4 = SE28. LCDSE3, Bit 3 = SE27. LCDSE3, Bit 2 = SE26. LCDSE3, Bit 1 = SE25. LCDSE3, Bit 0 = SE24. LCDSE3, Reset Values on Page = 64\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146>. Shaded cells are not used by PORTF.",
    "9.7 PORTG, TRISG and LATG Registers\nPORTG is a 6-bit wide, bidirectional port. The corresponding Data Direction register is  TRISG.  Setting  a TRISG bit (= 1 ) will make the corresponding PORTG pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISG bit (= 0 ) will make the corresponding PORTG pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATG)  is  also memory mapped.  Read-modify-write  operations  on  the  LATG register  read  and  write  the  latched  output  value  for PORTG.\nPORTG  is  multiplexed  with  both  USART  and  LCD functions (Table 9-14). PORTG  pins  have  Schmitt Trigger input buffers.",
    "9.7 PORTG, TRISG and LATG Registers\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTG pin. Some peripherals  override  the  TRIS  bit  to  make  a  pin  an output, while other peripherals override the TRIS bit to make  a  pin  an  input.  The  user  should  refer  to  the corresponding peripheral section for the correct TRIS bit settings. The pin override value is not loaded into the TRIS register. This allows read-modify-write of the TRIS register without concern due to peripheral overrides.\nPORTG<4:0> are also multiplexed with LCD segment drives  controlled  by  bits  in  the  LCDSE3  register.  I/O port  functions  are  only  available  when  the  segments are disabled.",
    "9.7 PORTG, TRISG and LATG Registers\nThe sixth pin of PORTG (MCLR/VPP/RG5) is an input only  pin.  Its  operation  is  controlled  by  the  MCLRE Configuration bit. When  selected as a port pin (MCLRE = 0 ), it functions as a digital input only pin; as such, it does not have TRIS or LAT bits associated with its  operation.  Otherwise,  it  functions  as  the  deviceGLYPH<146>s Master Clear input. In either  configuration, RG5  also functions  as  the  programming  voltage  input  during programming.",
    "Note:\nOn a Power-on Reset, RG5 is enabled as a digital input only if Master Clear functionality  is  disabled.  All  other  5  pins are configured as digital inputs.",
    "EXAMPLE 9-7: INITIALIZING PORTG\nCLRF, 1 = PORTG. CLRF, 2 = ; Initialize PORTG by ; clearing output ; data latches. CLRF, 1 = LATG. CLRF, 2 = ; Alternate method ; to clear output. MOVLW, 1 = 0x04. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISG. MOVWF, 2 = ; Set RG1:RG0 as outputs ; RG2 as input ; RG4:RG3 as inputs",
    "TABLE 9-14: PORTG FUNCTIONS\nRG0/SEG30, Function = RG0. RG0/SEG30, TRIS Setting = 0. RG0/SEG30, I/O = O. RG0/SEG30, Buffer = DIG. RG0/SEG30, Description = LATG<0> data output; disabled when LCD segment enabled.. RG0/SEG30, Function = RG0. RG0/SEG30, TRIS Setting = 1. RG0/SEG30, I/O = I. RG0/SEG30, Buffer = ST. RG0/SEG30, Description = PORTG<0> data input.. RG0/SEG30, Function = SEG30. RG0/SEG30, TRIS Setting = x. RG0/SEG30, I/O = O. RG0/SEG30, Buffer = ANA. RG0/SEG30, Description = Segment 30 analog output for LCD.. RG1/TX2/CK2/ SEG29, Function = RG1.",
    "TABLE 9-14: PORTG FUNCTIONS\nRG1/TX2/CK2/ SEG29, TRIS Setting = 0. RG1/TX2/CK2/ SEG29, I/O = O. RG1/TX2/CK2/ SEG29, Buffer = DIG. RG1/TX2/CK2/ SEG29, Description = LATG<1> data output; disabled when LCD segment enabled.. RG1/TX2/CK2/ SEG29, Function = RG1. RG1/TX2/CK2/ SEG29, TRIS Setting = 1. RG1/TX2/CK2/ SEG29, I/O = I. RG1/TX2/CK2/ SEG29, Buffer = ST. RG1/TX2/CK2/ SEG29, Description = PORTG<1> data input.. RG1/TX2/CK2/ SEG29, Function = TX2. RG1/TX2/CK2/ SEG29, TRIS Setting = 1. RG1/TX2/CK2/ SEG29,",
    "TABLE 9-14: PORTG FUNCTIONS\nI/O = O. RG1/TX2/CK2/ SEG29, Buffer = DIG. RG1/TX2/CK2/ SEG29, Description = Synchronous serial data output (AUSART module); takes priority over port data.. RG1/TX2/CK2/ SEG29, Function = CK2. RG1/TX2/CK2/ SEG29, TRIS Setting = 1. RG1/TX2/CK2/ SEG29, I/O = O. RG1/TX2/CK2/ SEG29, Buffer = DIG. RG1/TX2/CK2/ SEG29, Description = Synchronous serial data input (AUSART module). User must configure as an input.. RG1/TX2/CK2/ SEG29, Function = CK2. RG1/TX2/CK2/ SEG29, TRIS Setting = 1. RG1/TX2/CK2/ SEG29, I/O = I. RG1/TX2/CK2/",
    "TABLE 9-14: PORTG FUNCTIONS\nSEG29, Buffer = ST. RG1/TX2/CK2/ SEG29, Description = Synchronous serial clock input (AUSART module).. RG1/TX2/CK2/ SEG29, Function = SEG29. RG1/TX2/CK2/ SEG29, TRIS Setting = x. RG1/TX2/CK2/ SEG29, I/O = O. RG1/TX2/CK2/ SEG29, Buffer = ANA. RG1/TX2/CK2/ SEG29, Description = Segment 29 analog output for LCD.. RG2/RX2/DT2/ SEG28, Function = RG2. RG2/RX2/DT2/ SEG28, TRIS Setting = 0. RG2/RX2/DT2/ SEG28, I/O = O. RG2/RX2/DT2/ SEG28, Buffer = DIG. RG2/RX2/DT2/ SEG28, Description = LATG<2> data output;",
    "TABLE 9-14: PORTG FUNCTIONS\ndisabled when LCD segment enabled.. RG2/RX2/DT2/ SEG28, Function = RG2. RG2/RX2/DT2/ SEG28, TRIS Setting = 1. RG2/RX2/DT2/ SEG28, I/O = I. RG2/RX2/DT2/ SEG28, Buffer = ST. RG2/RX2/DT2/ SEG28, Description = PORTG<2> data input.. RG2/RX2/DT2/ SEG28, Function = RX2. RG2/RX2/DT2/ SEG28, TRIS Setting = 1. RG2/RX2/DT2/ SEG28, I/O = I. RG2/RX2/DT2/ SEG28, Buffer = ST. RG2/RX2/DT2/ SEG28, Description = Asynchronous serial receive data input (AUSART module).. RG2/RX2/DT2/ SEG28, Function =",
    "TABLE 9-14: PORTG FUNCTIONS\nDT2. RG2/RX2/DT2/ SEG28, TRIS Setting = 1. RG2/RX2/DT2/ SEG28, I/O = O. RG2/RX2/DT2/ SEG28, Buffer = DIG. RG2/RX2/DT2/ SEG28, Description = Synchronous serial data output (AUSART module); takes priority over port data.. RG2/RX2/DT2/ SEG28, Function = DT2. RG2/RX2/DT2/ SEG28, TRIS Setting = 1. RG2/RX2/DT2/ SEG28, I/O = I. RG2/RX2/DT2/ SEG28, Buffer = ST. RG2/RX2/DT2/ SEG28, Description = Synchronous serial data input (AUSART module). User must configure as an input.. RG2/RX2/DT2/ SEG28, Function = SEG28.",
    "TABLE 9-14: PORTG FUNCTIONS\nRG2/RX2/DT2/ SEG28, TRIS Setting = x. RG2/RX2/DT2/ SEG28, I/O = O. RG2/RX2/DT2/ SEG28, Buffer = ANA. RG2/RX2/DT2/ SEG28, Description = Segment 28 analog output for LCD.. RG3/SEG27, Function = RG3. RG3/SEG27, TRIS Setting = 0. RG3/SEG27, I/O = O. RG3/SEG27, Buffer = DIG. RG3/SEG27, Description = LATG<3> data output; disabled when LCD segment enabled.. RG3/SEG27, Function = RG3. RG3/SEG27, TRIS Setting = 1. RG3/SEG27, I/O = I. RG3/SEG27, Buffer = ST. RG3/SEG27, Description = PORTG<3> data input.. RG3/SEG27, Function",
    "TABLE 9-14: PORTG FUNCTIONS\n= SEG27. RG3/SEG27, TRIS Setting = 0. RG3/SEG27, I/O = O. RG3/SEG27, Buffer = ANA. RG3/SEG27, Description = Segment 27 analog output for LCD.. RG4/SEG26, Function = RG4. RG4/SEG26, TRIS Setting = 0. RG4/SEG26, I/O = O. RG4/SEG26, Buffer = DIG. RG4/SEG26, Description = LATG<4> data output; disabled when LCD segment enabled.. RG4/SEG26, Function = RG4. RG4/SEG26, TRIS Setting = 1. RG4/SEG26, I/O = I. RG4/SEG26, Buffer = ST. RG4/SEG26, Description = PORTG<4> data input.. RG4/SEG26, Function = SEG26. RG4/SEG26, TRIS Setting = x.",
    "TABLE 9-14: PORTG FUNCTIONS\nRG4/SEG26, I/O = O. RG4/SEG26, Buffer = ANA. RG4/SEG26, Description = Segment 26 analog output for LCD.. MCLR/VPP/RG5, Function = MCLR. MCLR/VPP/RG5, TRIS Setting = GLYPH<151> (1). MCLR/VPP/RG5, I/O = I. MCLR/VPP/RG5, Buffer = ST. MCLR/VPP/RG5, Description = External Master Clear input; enabled when MCLRE Configuration bit is set.. MCLR/VPP/RG5, Function = VPP. MCLR/VPP/RG5, TRIS Setting = GLYPH<151> (1). MCLR/VPP/RG5, I/O = I. MCLR/VPP/RG5, Buffer = ANA. MCLR/VPP/RG5, Description = High-voltage detection; used for ICSPGLYPH<153> mode entry detection. Always available, regardless of pin",
    "TABLE 9-14: PORTG FUNCTIONS\nmode.. MCLR/VPP/RG5, Function = RG5. MCLR/VPP/RG5, TRIS Setting = GLYPH<151> (1). MCLR/VPP/RG5, I/O = I. MCLR/VPP/RG5, Buffer = ST. MCLR/VPP/RG5, Description = PORTG<5> data input; enabled when MCLRE Configuration bit is clear.\nLegend: O = Output, I = Input, ANA = Analog Signal, DIG = Digital Output, ST = Schmitt Buffer Input, TTL = TTL Buffer Input, x = DonGLYPH<146>t care (TRIS bit does not affect port direction or is overridden for this option).\nNote 1: RG5 does not have a corresponding TRISG bit.",
    "TABLE 9-15: SUMMARY OF REGISTERS ASSOCIATED WITH PORTG\nPORTG, Bit 7 = GLYPH<151>. PORTG, Bit 6 = GLYPH<151>. PORTG, Bit 5 = RG5 (1). PORTG, Bit 4 = Read PORTG pin/Write PORTG Data Latch. PORTG, Bit 3 = Read PORTG pin/Write PORTG Data Latch. PORTG, Bit 2 = Read PORTG pin/Write PORTG Data Latch. PORTG, Bit 1 = Read PORTG pin/Write PORTG Data Latch. PORTG, Bit 0 = Read PORTG pin/Write PORTG Data Latch. PORTG, Reset Values on Page = 62. LATG, Bit 7 = GLYPH<151>. LATG, Bit 6 = GLYPH<151>. LATG, Bit 5 = GLYPH<151>. LATG, Bit 4 = LATG Data Output Register. LATG, Bit 3 = LATG Data Output Register. LATG, Bit 2 = LATG Data Output Register. LATG, Bit 1 = LATG Data Output Register. LATG, Bit 0 = LATG Data Output",
    "TABLE 9-15: SUMMARY OF REGISTERS ASSOCIATED WITH PORTG\nRegister. LATG, Reset Values on Page = 62. TRISG, Bit 7 = GLYPH<151>. TRISG, Bit 6 = GLYPH<151>. TRISG, Bit 5 = GLYPH<151>. TRISG, Bit 4 = PORTG Data Direction Register. TRISG, Bit 3 = PORTG Data Direction Register. TRISG, Bit 2 = PORTG Data Direction Register. TRISG, Bit 1 = PORTG Data Direction Register. TRISG, Bit 0 = PORTG Data Direction Register. TRISG, Reset Values on Page = 62. LCDSE3, Bit 7 = SE31. LCDSE3, Bit 6 = SE30. LCDSE3, Bit 5 = SE29. LCDSE3, Bit 4 = SE28. LCDSE3, Bit 3 = SE27. LCDSE3, Bit 2 = SE26. LCDSE3, Bit 1 = SE25. LCDSE3, Bit 0 = SE24. LCDSE3, Reset Values on Page = 64",
    "TABLE 9-15: SUMMARY OF REGISTERS ASSOCIATED WITH PORTG\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146>. Shaded cells are not used by PORTG.\nNote 1: RG5 is available as an input only when MCLR is disabled.",
    "INITIALIZING PORTH\nNote:, 1 = PORTH is available only on 80-pin devices.\nPORTH is an 8-bit wide, bidirectional I/O port. The corresponding Data Direction register is TRISH. Setting a TRISH bit (= 1 )  will  make the corresponding PORTH pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISH bit (= 0 ) will make the corresponding PORTH pin an output (i.e., put the contents of the output latch on the selected pin).\nCLRF, 1 = PORTH. CLRF, 2 = ; Initialize PORTH by ; clearing output ; data latches. CLRF, 1 = LATH. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0CFh. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISH. MOVWF, 2 = ; Set RH3:RH0 as inputs ; RH5:RH4 as outputs ; RH7:RH6 as inputs",
    "INITIALIZING PORTH\nThe  Data  Latch  register (LATH)  is  also memory mapped.  Read-modify-write  operations  on  the  LATH register  read  and  write  the  latched  output  value  for PORTH.\nAll  pins  on  PORTH  are  implemented  with  Schmitt Trigger input buffers. Each pin is individually configurable as an input or output.",
    "Note:\nOn  a  Power-on  Reset,  these  pins  are configured as digital inputs.\nPORTH is also multiplexed with LCD segment drives controlled by the LCDSE5 register. I/O port functions are only available when the segments are disabled.",
    "TABLE 9-16: PORTH FUNCTIONS\nRH0/SEG47, Function = RH0. RH0/SEG47, TRIS Setting = 0. RH0/SEG47, I/O = O. RH0/SEG47, Buffer = DIG-4. RH0/SEG47, Description = LATH<0> data output; disabled when LCD segment enabled.. RH0/SEG47, Function = RH0. RH0/SEG47, TRIS Setting = 1. RH0/SEG47, I/O = I. RH0/SEG47, Buffer = ST. RH0/SEG47, Description = PORTH<0> data input.. RH0/SEG47, Function = SEG47. RH0/SEG47, TRIS Setting = x. RH0/SEG47, I/O = O. RH0/SEG47, Buffer = ANA. RH0/SEG47, Description = Segment 47 analog output for LCD.. RH1/SEG46, Function = RH1. RH1/SEG46,",
    "TABLE 9-16: PORTH FUNCTIONS\nTRIS Setting = 0. RH1/SEG46, I/O = O. RH1/SEG46, Buffer = DIG. RH1/SEG46, Description = LATH<1> data output; disabled when LCD segment enabled.. RH1/SEG46, Function = RH1. RH1/SEG46, TRIS Setting = 1. RH1/SEG46, I/O = I. RH1/SEG46, Buffer = ST. RH1/SEG46, Description = PORTH<1> data input.. RH1/SEG46, Function = SEG46. RH1/SEG46, TRIS Setting = x. RH1/SEG46, I/O = O. RH1/SEG46, Buffer = ANA. RH1/SEG46, Description = Segment 46 analog output for LCD.. RH2/SEG45, Function = RH2. RH2/SEG45, TRIS Setting = 0. RH2/SEG45, I/O = O.",
    "TABLE 9-16: PORTH FUNCTIONS\nRH2/SEG45, Buffer = DIG. RH2/SEG45, Description = LATH<2> data output; disabled when LCD segment enabled.. RH2/SEG45, Function = RH2. RH2/SEG45, TRIS Setting = 1. RH2/SEG45, I/O = I. RH2/SEG45, Buffer = ST. RH2/SEG45, Description = PORTH<2> data input.. RH2/SEG45, Function = SEG45. RH2/SEG45, TRIS Setting = x. RH2/SEG45, I/O = O. RH2/SEG45, Buffer = ANA. RH2/SEG45, Description = Segment 45 analog output for LCD.. RH3/SEG44, Function = RH3. RH3/SEG44, TRIS Setting = 0. RH3/SEG44, I/O = O. RH3/SEG44, Buffer = DIG. RH3/SEG44, Description =",
    "TABLE 9-16: PORTH FUNCTIONS\nLATH<3> data output; disabled when LCD segment enabled.. RH3/SEG44, Function = RH3. RH3/SEG44, TRIS Setting = 1. RH3/SEG44, I/O = I. RH3/SEG44, Buffer = ST. RH3/SEG44, Description = PORTH<3> data input.. RH3/SEG44, Function = SEG44. RH3/SEG44, TRIS Setting = x. RH3/SEG44, I/O = O. RH3/SEG44, Buffer = ANA. RH3/SEG44, Description = Segment 44 analog output for LCD.. RH4/SEG40, Function = RH4. RH4/SEG40, TRIS Setting = 0. RH4/SEG40, I/O = O. RH4/SEG40, Buffer = DIG. RH4/SEG40, Description = LATH<4> data output; disabled when LCD segment enabled.. RH4/SEG40, Function",
    "TABLE 9-16: PORTH FUNCTIONS\n= RH4. RH4/SEG40, TRIS Setting = 1. RH4/SEG40, I/O = I. RH4/SEG40, Buffer = ST. RH4/SEG40, Description = PORTH<4> data input.. RH4/SEG40, Function = SEG40. RH4/SEG40, TRIS Setting = x. RH4/SEG40, I/O = O. RH4/SEG40, Buffer = ANA. RH4/SEG40, Description = Segment 40 analog output for LCD. RH5/SEG41, Function = RH5. RH5/SEG41, TRIS Setting = 0. RH5/SEG41, I/O = O. RH5/SEG41, Buffer = DIG. RH5/SEG41, Description = LATH<5> data output; disabled when LCD segment enabled.. RH5/SEG41, Function = RH5. RH5/SEG41, TRIS Setting = 1.",
    "TABLE 9-16: PORTH FUNCTIONS\nRH5/SEG41, I/O = I. RH5/SEG41, Buffer = ST. RH5/SEG41, Description = PORTH<5> data input.. RH5/SEG41, Function = SEG41. RH5/SEG41, TRIS Setting = x. RH5/SEG41, I/O = O. RH5/SEG41, Buffer = ANA. RH5/SEG41, Description = Segment 41 analog output for LCD.. RH6/SEG42, Function = RH6. RH6/SEG42, TRIS Setting = 0. RH6/SEG42, I/O = O. RH6/SEG42, Buffer = DIG. RH6/SEG42, Description = LATH<6> data output; disabled when LCD segment enabled.. RH6/SEG42, Function = RH6. RH6/SEG42, TRIS Setting = 1. RH6/SEG42, I/O = I. RH6/SEG42, Buffer =",
    "TABLE 9-16: PORTH FUNCTIONS\nST. RH6/SEG42, Description = PORTH<6> data input.. RH6/SEG42, Function = SEG42. RH6/SEG42, TRIS Setting = x. RH6/SEG42, I/O = O. RH6/SEG42, Buffer = ANA. RH6/SEG42, Description = Segment 42 analog output for LCD.. RH7/SEG43, Function = RH7. RH7/SEG43, TRIS Setting = 0. RH7/SEG43, I/O = O. RH7/SEG43, Buffer = DIG. RH7/SEG43, Description = LATH<7> data output; disabled when LCD segment enabled.. RH7/SEG43, Function = RH7. RH7/SEG43, TRIS Setting = 1. RH7/SEG43, I/O = I. RH7/SEG43, Buffer = ST. RH7/SEG43, Description = PORTH<7> data input..",
    "TABLE 9-16: PORTH FUNCTIONS\nRH7/SEG43, Function = SEG43. RH7/SEG43, TRIS Setting = x. RH7/SEG43, I/O = O. RH7/SEG43, Buffer = ANA. RH7/SEG43, Description = Segment 43 analog output for LCD.\nLegend:\nO = Output, I = Input, ANA = Analog Signal, DIG = Digital Output, ST = Schmitt Buffer Input, TTL = TTL Buffer Input, x = DonGLYPH<146>t care (TRIS bit does not affect port direction or is overridden for this option).",
    "TABLE 9-17: SUMMARY OF REGISTERS ASSOCIATED WITH PORTH\nTRISH, Bit 7 = PORTH Data Direction Register. TRISH, Bit 6 = PORTH Data Direction Register. TRISH, Bit 5 = PORTH Data Direction Register. TRISH, Bit 4 = PORTH Data Direction Register. TRISH, Bit 3 = PORTH Data Direction Register. TRISH, Bit 2 = PORTH Data Direction Register. TRISH, Bit 1 = PORTH Data Direction Register. TRISH, Bit 0 = PORTH Data Direction Register. TRISH, Reset Values on Page = 62. PORTH, Bit 7 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 6 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 5 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 4 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 3 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 2 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 1 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 0 = Read PORTH pin/Write PORTH Data Latch.",
    "TABLE 9-17: SUMMARY OF REGISTERS ASSOCIATED WITH PORTH\nPORTH, Reset Values on Page = 62. LATH, Bit 7 = LATH Data Output Register. LATH, Bit 6 = LATH Data Output Register. LATH, Bit 5 = LATH Data Output Register. LATH, Bit 4 = LATH Data Output Register. LATH, Bit 3 = LATH Data Output Register. LATH, Bit 2 = LATH Data Output Register. LATH, Bit 1 = LATH Data Output Register. LATH, Bit 0 = LATH Data Output Register. LATH, Reset Values on Page = 62. LCDSE5, Bit 7 = SE47. LCDSE5, Bit 6 = SE46. LCDSE5, Bit 5 = SE45. LCDSE5, Bit 4 = SE44. LCDSE5, Bit 3 = SE43. LCDSE5, Bit 2 = SE42. LCDSE5, Bit 1 = SE41. LCDSE5, Bit 0 = SE40. LCDSE5, Reset Values on Page = 64",
    "Note: PORTJ is available only on 80-pin devices.\nPORTJ is an 8-bit wide, bidirectional port. The corresponding  Data  Direction  register  is  TRISJ.  Setting  a TRISJ bit (= 1 ) will make the corresponding PORTJ pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISJ bit (= 0 ) will make the corresponding PORTJ pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch register (LATJ) is also memory mapped.  Read-modify-write  operations  on  the  LATJ register  read  and  write  the  latched  output  value  for PORTJ.",
    "Note: PORTJ is available only on 80-pin devices.\nCLRF PORTJ, INITIALIZING PORTJ = ; Initialize PORTG by ; clearing output ; data latches. CLRF LATJ, INITIALIZING PORTJ = ; Alternate method ; to clear output ; data latches. MOVLW 0xCF, INITIALIZING PORTJ = ; Value used to ; initialize data ; direction. MOVWF TRISJ, INITIALIZING PORTJ = ; Set RJ3:RJ0 as inputs ; RJ5:RJ4 as output ; RJ7:RJ6 as inputs\nAll pins  on  PORTJ  are  implemented  with  Schmitt Trigger input buffers. Each pin is individually configurable as an input or output.\nNote: On  a  Power-on  Reset,  these  pins  are configured as digital inputs.\nPORTJ is also multiplexed with LCD segment drives controlled by the LCDSE4 register. I/O port functions are only available when the segments are disabled.",
    "TABLE 9-18: PORTJ FUNCTIONS\nRJ0/SEG32, Function = RJ0. RJ0/SEG32, TRIS Setting = 0. RJ0/SEG32, I/O = O. RJ0/SEG32, Buffer = DIG. RJ0/SEG32, Description = LATJ<0> data output; disabled when LCD segment enabled.. RJ0/SEG32, Function = RJ0. RJ0/SEG32, TRIS Setting = 1. RJ0/SEG32, I/O = I. RJ0/SEG32, Buffer = ST. RJ0/SEG32, Description = PORTJ<0> data input.. RJ0/SEG32, Function = SEG32. RJ0/SEG32, TRIS Setting = x. RJ0/SEG32, I/O = O. RJ0/SEG32, Buffer = ANA. RJ0/SEG32, Description = Segment 32 analog output for LCD.. RJ1/SEG33, Function = RJ1. RJ1/SEG33,",
    "TABLE 9-18: PORTJ FUNCTIONS\nTRIS Setting = 0. RJ1/SEG33, I/O = O. RJ1/SEG33, Buffer = DIG. RJ1/SEG33, Description = LATJ<1> data output; disabled when LCD segment enabled.. RJ1/SEG33, Function = RJ1. RJ1/SEG33, TRIS Setting = 1. RJ1/SEG33, I/O = I. RJ1/SEG33, Buffer = ST. RJ1/SEG33, Description = PORTJ<1> data input.. RJ1/SEG33, Function = SEG33. RJ1/SEG33, TRIS Setting = x. RJ1/SEG33, I/O = O. RJ1/SEG33, Buffer = ANA. RJ1/SEG33, Description = Segment 33 analog output for LCD.. RJ2/SEG34, Function = RJ2. RJ2/SEG34, TRIS Setting = 0. RJ2/SEG34, I/O = O.",
    "TABLE 9-18: PORTJ FUNCTIONS\nRJ2/SEG34, Buffer = DIG. RJ2/SEG34, Description = LATJ<2> data output; disabled when LCD segment enabled.. RJ2/SEG34, Function = RJ2. RJ2/SEG34, TRIS Setting = 1. RJ2/SEG34, I/O = I. RJ2/SEG34, Buffer = ST. RJ2/SEG34, Description = PORTJ<2> data input.. RJ2/SEG34, Function = SEG34. RJ2/SEG34, TRIS Setting = x. RJ2/SEG34, I/O = O. RJ2/SEG34, Buffer = ANA. RJ2/SEG34, Description = Segment 34 analog output for LCD.. RJ3/SEG35, Function = RJ3. RJ3/SEG35, TRIS Setting = 0. RJ3/SEG35, I/O = O. RJ3/SEG35, Buffer = DIG. RJ3/SEG35, Description =",
    "TABLE 9-18: PORTJ FUNCTIONS\nLATJ<3> data output; disabled when LCD segment enabled.. RJ3/SEG35, Function = RJ3. RJ3/SEG35, TRIS Setting = 1. RJ3/SEG35, I/O = I. RJ3/SEG35, Buffer = ST. RJ3/SEG35, Description = PORTJ<3> data input.. RJ3/SEG35, Function = SEG35. RJ3/SEG35, TRIS Setting = x. RJ3/SEG35, I/O = O. RJ3/SEG35, Buffer = ANA. RJ3/SEG35, Description = Segment 35 analog output for LCD.. RJ4/SEG39, Function = RJ4. RJ4/SEG39, TRIS Setting = 0. RJ4/SEG39, I/O = O. RJ4/SEG39, Buffer = DIG. RJ4/SEG39, Description = LATJ<4> data output; disabled when LCD segment enabled..",
    "TABLE 9-18: PORTJ FUNCTIONS\nRJ4/SEG39, Function = RJ4. RJ4/SEG39, TRIS Setting = 1. RJ4/SEG39, I/O = I. RJ4/SEG39, Buffer = ST. RJ4/SEG39, Description = PORTJ<4> data input.. RJ4/SEG39, Function = SEG39. RJ4/SEG39, TRIS Setting = x. RJ4/SEG39, I/O = O. RJ4/SEG39, Buffer = ANA. RJ4/SEG39, Description = Segment 39 analog output for LCD.. RJ5/SEG38, Function = RJ5. RJ5/SEG38, TRIS Setting = 0. RJ5/SEG38, I/O = O. RJ5/SEG38, Buffer = DIG. RJ5/SEG38, Description = LATJ<5> data output; disabled when LCD segment enabled.. RJ5/SEG38, Function = RJ5. RJ5/SEG38,",
    "TABLE 9-18: PORTJ FUNCTIONS\nTRIS Setting = 1. RJ5/SEG38, I/O = I. RJ5/SEG38, Buffer = ST. RJ5/SEG38, Description = PORTJ<5> data input.. RJ5/SEG38, Function = SEG38. RJ5/SEG38, TRIS Setting = x. RJ5/SEG38, I/O = O. RJ5/SEG38, Buffer = ANA. RJ5/SEG38, Description = Segment 38 analog output for LCD.. RJ6/SEG37, Function = RJ6. RJ6/SEG37, TRIS Setting = 0. RJ6/SEG37, I/O = O. RJ6/SEG37, Buffer = DIG. RJ6/SEG37, Description = LATJ<6> data output; disabled when LCD segment enabled.. RJ6/SEG37, Function = RJ6. RJ6/SEG37, TRIS Setting = 1. RJ6/SEG37, I/O = I.",
    "TABLE 9-18: PORTJ FUNCTIONS\nRJ6/SEG37, Buffer = ST. RJ6/SEG37, Description = PORTJ<6> data input.. RJ6/SEG37, Function = SEG37. RJ6/SEG37, TRIS Setting = x. RJ6/SEG37, I/O = O. RJ6/SEG37, Buffer = ANA. RJ6/SEG37, Description = Segment 37 analog output for LCD.. RJ7/SEG36, Function = RJ7. RJ7/SEG36, TRIS Setting = 0. RJ7/SEG36, I/O = O. RJ7/SEG36, Buffer = DIG. RJ7/SEG36, Description = LATJ<7> data output; disabled when LCD segment enabled.. RJ7/SEG36, Function = RJ7. RJ7/SEG36, TRIS Setting = 1. RJ7/SEG36, I/O = I. RJ7/SEG36, Buffer = ST. RJ7/SEG36, Description =",
    "TABLE 9-18: PORTJ FUNCTIONS\nPORTJ<7> data input.. RJ7/SEG36, Function = SEG36. RJ7/SEG36, TRIS Setting = x. RJ7/SEG36, I/O = O. RJ7/SEG36, Buffer = ANA. RJ7/SEG36, Description = Segment 36 analog output for LCD.\nLegend:\nO = Output, I = Input, ANA = Analog Signal, DIG = Digital Output, ST = Schmitt Buffer Input, TTL = TTL Buffer Input, x = DonGLYPH<146>t care (TRIS bit does not affect port direction or is overridden for this option).",
    "TABLE 9-19: SUMMARY OF REGISTERS ASSOCIATED WITH PORTJ\nPORTJ, Bit 7 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 6 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 5 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 4 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 3 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 2 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 1 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 0 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Reset Values on Page = 62. LATJ, Bit 7 = LATJ Data Output Register. LATJ, Bit 6 = LATJ Data Output Register. LATJ, Bit 5 = LATJ Data Output Register. LATJ, Bit 4 = LATJ Data Output Register. LATJ, Bit 3 = LATJ Data Output Register. LATJ, Bit 2 = LATJ Data Output Register. LATJ, Bit 1 = LATJ Data Output Register.",
    "TABLE 9-19: SUMMARY OF REGISTERS ASSOCIATED WITH PORTJ\nLATJ, Bit 0 = LATJ Data Output Register. LATJ, Reset Values on Page = 62. TRISJ, Bit 7 = PORTJ Data Direction Register. TRISJ, Bit 6 = PORTJ Data Direction Register. TRISJ, Bit 5 = PORTJ Data Direction Register. TRISJ, Bit 4 = PORTJ Data Direction Register. TRISJ, Bit 3 = PORTJ Data Direction Register. TRISJ, Bit 2 = PORTJ Data Direction Register. TRISJ, Bit 1 = PORTJ Data Direction Register. TRISJ, Bit 0 = PORTJ Data Direction Register. TRISJ, Reset Values on Page = 62. LCDSE4, Bit 7 = SE39. LCDSE4, Bit 6 = SE38. LCDSE4, Bit 5 = SE37. LCDSE4, Bit 4 = SE36. LCDSE4, Bit 3 = SE35. LCDSE4, Bit 2 = SE34. LCDSE4, Bit 1 = SE33. LCDSE4, Bit 0 = SE32. LCDSE4, Reset Values on Page = 64",
    "10.0 TIMER0 MODULE\nThe Timer0 module incorporates the following features:\nThe T0CON  register (Register 10-1) controls all aspects of the moduleGLYPH<146>s operation, including the prescale selection. It is both readable and writable.\nGLYPH<149> Software selectable operation as a timer or counter in both 8-bit or 16-bit modes\nGLYPH<149> Readable and writable registers\nGLYPH<149> Dedicated 8-bit software programmable prescaler\nGLYPH<149> Selectable clock source (internal or external)\nGLYPH<149> Edge select for external clock\nGLYPH<149> Interrupt-on-overflow",
    "REGISTER 10-1: T0CON: TIMER0 CONTROL REGISTER\nTMR0ON, R/W-1 = T08BIT. TMR0ON, R/W-1 = T0CS. TMR0ON, R/W-1 = T0SE. TMR0ON, R/W-1 = PSA. TMR0ON, R/W-1 = T0PS2. TMR0ON, R/W-1 = T0PS1. TMR0ON, R/W-1 = T0PS0. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 0",
    "REGISTER 10-1: T0CON: TIMER0 CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nTMR0ON:\nTimer0 On/Off Control bit\n1 = Enables Timer0\n0 = Stops Timer0\nbit 6 T08BIT : Timer0 8-Bit/16-Bit Control bit\n1 = Timer0 is configured as an 8-bit timer/counter",
    "REGISTER 10-1: T0CON: TIMER0 CONTROL REGISTER\n0 = Timer0 is configured as a 16-bit timer/counter bit 5 T0CS : Timer0 Clock Source Select bit\n1 = Transition on T0CKI pin\n0 = Internal instruction cycle clock (CLKO)\nT0SE : Timer0 Source Edge Select bit\n1 = Increment on high-to-low transition on T0CKI pin\n0 = Increment on low-to-high transition on T0CKI pin bit 3 PSA : Timer0 Prescaler Assignment bit\n1 = TImer0 prescaler is not assigned. Timer0 clock input bypasses prescaler.\n0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.",
    "bit 2-0 T0PS2:T0PS0\n: Timer0 Prescaler Select bits\n111 = 1:256 Prescale value\n110 = 1:128 Prescale value\n101 = 1:64   Prescale value\n100 = 1:32   Prescale value\n011 = 1:16   Prescale value\n010 = 1:8     Prescale value\n001 = 1:4     Prescale value\n000\n= 1:2     Prescale value\nA  simplified  block  diagram  of  the  Timer0  module  in 8-bit mode  is shown  in Figure 10-1. Figure 10-2 shows  a  simplified block diagram  of the Timer0 module in 16-bit mode.",
    "10.1 Timer0 Operation\nTimer0 can operate as either a timer or a counter; the mode is selected by clearing the T0CS bit (T0CON<5>). In Timer mode (T0CS = 0 ), the module increments on every clock by default, unless a different prescaler value is selected (see Section 10.3 GLYPH<147>PrescalerGLYPH<148> ). If the TMR0 register  is  written  to,  the  increment  is  inhibited  for  the following  two  instruction  cycles.  The  user  can  work around this by writing an adjusted value to the TMR0 register.\nThe Counter mode is selected by setting the T0CS bit (= 1 ).  In  Counter mode, Timer0 increments either on every  rising  or  falling  edge  of  pin  RA4/T0CKI.  The incrementing edge is determined by the Timer0 Source Edge Select bit, T0SE (T0CON<4>); clearing this bit selects  the  rising  edge.  Restrictions  on  the  external clock input are discussed below.\ninternal phase clock (TOSC). There is a delay between synchronization  and  the  onset  of  incrementing  the timer/counter.",
    "10.2 Timer0 Reads and Writes in 16-Bit Mode\nTMR0H is not the actual high byte of Timer0 in 16-bit mode; it is actually a buffered version of the real high byte  of  Timer0,  which  is  not  directly  readable  nor writable (refer to Figure 10-2). TMR0H is updated with the contents of the high byte of Timer0 during a read of TMR0L. This provides the ability to read all 16 bits of Timer0, without having to verify that the read of the high and  low  byte  were  valid,  due  to  a  rollover  between successive reads of the high and low byte.\nAn external clock source can be used to drive Timer0; however, it must meet certain requirements to ensure that  the  external  clock  can  be  synchronized  with  the\nSimilarly, a write to the high byte of Timer0 must also take place through the TMR0H Buffer register. The high byte is updated with the contents of TMR0H when a write occurs to TMR0L. This allows all 16 bits of Timer0 to be updated at once.",
    "10.3 Prescaler\nAn 8-bit counter is available as a prescaler for the Timer0 module. The prescaler is not directly readable or writable; its  value  is  set  by  the  PSA  and  T0PS2:T0PS0  bits (T0CON<3:0>), which determine the prescaler assignment and prescale ratio.\nClearing  the  PSA  bit  assigns  the  prescaler  to  the Timer0 module. When it is assigned, prescale values from 1:2 through 1:256 in power-of-2 increments are selectable.\nWhen assigned to the Timer0 module, all instructions writing to the TMR0 register (e.g., CLRF TMR0 MOVWF , TMR0 BSF TMR0 , , etc.) clear the prescaler count.\nNote:, 1 = Writing to TMR0 when the prescaler is assigned to Timer0 will clear the prescaler count, but will not change the prescaler assignment.",
    "10.3.1 SWITCHING PRESCALER ASSIGNMENT\nThe  prescaler  assignment  is  fully  under  software control and can be changed GLYPH<147>on-the-flyGLYPH<148> during program execution.",
    "10.4 Timer0 Interrupt\nThe  TMR0  interrupt  is  generated  when  the  TMR0 register  overflows from  FFh  to  00h in 8-bit  mode, or from FFFFh to 0000h in 16-bit mode. This overflow sets the TMR0IF flag bit. The interrupt can be masked by clearing the TMR0IE bit (INTCON<5>). Before re-enabling  the  interrupt,  the  TMR0IF  bit  must  be cleared in software by the Interrupt Service Routine.\nSince Timer0 is shut down in Sleep mode, the TMR0 interrupt cannot awaken the processor from Sleep.",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0L, Bit 7 = Timer0 Register Low Byte. TMR0L, Bit 6 = Timer0 Register Low Byte. TMR0L, Bit 5 = Timer0 Register Low Byte. TMR0L, Bit 4 = Timer0 Register Low Byte. TMR0L, Bit 3 = Timer0 Register Low Byte. TMR0L, Bit 2 = Timer0 Register Low Byte. TMR0L, Bit 1 = Timer0 Register Low Byte. TMR0L, Bit 0 = Timer0 Register Low Byte. TMR0L, Reset Values on Page = 60. TMR0H, Bit 7 = Timer0 Register High Byte. TMR0H, Bit 6 = Timer0 Register High Byte. TMR0H, Bit 5 = Timer0 Register High Byte. TMR0H, Bit 4 = Timer0 Register High Byte. TMR0H, Bit 3 = Timer0 Register High Byte. TMR0H, Bit 2 = Timer0 Register High Byte. TMR0H, Bit 1 = Timer0 Register High Byte. TMR0H, Bit 0",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH TIMER0\n= Timer0 Register High Byte. TMR0H, Reset Values on Page = 60. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Reset Values on Page = 60. TRISA, Bit 7 = PORTA Data Direction Register. TRISA, Bit 6 = PORTA Data Direction Register.",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH TIMER0\nTRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Reset Values on Page = 62\nLegend: Shaded cells are not used by Timer0.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "bit 6\nbit 5-4",
    "bit 2\nbit 1",
    "11.0 TIMER1 MODULE\nThe Timer1 timer/counter  module  incorporates  these features:\nA  simplified  block  diagram  of  the  Timer1  module  is shown in Figure 11-1. A block diagram of the moduleGLYPH<146>s operation in Read/Write mode is shown in Figure 11-2.\nGLYPH<149> Software selectable operation as a 16-bit timer or counter\nGLYPH<149> Readable and writable 8-bit registers (TMR1H and TMR1L)\nGLYPH<149> Selectable clock source (internal or external) with device clock or Timer1 oscillator internal options\nGLYPH<149> Interrupt-on-overflow\nGLYPH<149> Reset on CCP Special Event Trigger\nGLYPH<149> Device clock status flag (T1RUN)\nThe module incorporates its own low-power oscillator to  provide  an  additional  clocking  option.  The  Timer1 oscillator can also be used as a low-power clock source for the microcontroller in power-managed operation.\nTimer1 can also be used to provide Real-Time Clock (RTC) functionality to applications with only a minimal addition of external components and code overhead.",
    "11.0 TIMER1 MODULE\nTimer1  is controlled through the T1CON  Control register  (Register 11-1).  It  also  contains  the  Timer1 Oscillator Enable  bit (T1OSCEN).  Timer1  can  be enabled or disabled by setting or clearing control bit, TMR1ON (T1CON<0>).",
    "REGISTER 11-1: T1CON: TIMER1 CONTROL REGISTER\nRD16, R-0 = T1RUN. RD16, R/W-0 = T1CKPS1. RD16, R/W-0 = T1CKPS0. RD16, R/W-0 = T1OSCEN. RD16, R/W-0 = T1SYNC. RD16, R/W-0 = TMR1CS. RD16, R/W-0 = TMR1ON. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 11-1: T1CON: TIMER1 CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7\nRD16: 16-Bit Read/Write Mode Enable bit\n- 1 = Enables register read/write of TImer1 in one 16-bit operation\n0 = Enables register read/write of Timer1 in two 8-bit operations\nT1RUN: Timer1 System Clock Status bit\n1 = Device clock is derived from Timer1 oscillator\n0 = Device clock is derived from another source\nT1CKPS1:T1CKPS0: Timer1 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value\nT1OSCEN: Timer1 Oscillator Enable bit\n1 = Timer1 oscillator is enabled\n0 = Timer1 oscillator is shut off\nThe oscillator inverter and feedback resistor are turned off to eliminate power drain.\nT1SYNC: Timer1 External Clock Input Synchronization Select bit\nWhen TMR1CS = 1 :\n1 = Do not synchronize external clock input\n- 0 = Synchronize external clock input\nWhen TMR1CS = 0 :",
    "bit 7\nThis bit is ignored. Timer1 uses the internal clock when TMR1CS = 0 .\nTMR1CS: Timer1 Clock Source Select bit\n1 = External clock from pin RC0/T1OSO/T13CKI (on the rising edge)\n0 = Internal clock (FOSC/4)\nTMR1ON: Timer1 On bit\n1 = Enables Timer1\n- 0 = Stops Timer1",
    "11.1 Timer1 Operation\nTimer1 can operate in one of these modes:\ncycle (FOSC/4). When the bit is set, Timer1 increments on every rising edge of the Timer1 external clock input or the Timer1 oscillator, if enabled.\nGLYPH<149> Timer\nGLYPH<149> Synchronous Counter\nGLYPH<149> Asynchronous Counter\nThe operating mode is determined by the clock select bit, TMR1CS (T1CON<1>). When TMR1CS is cleared (= 0 ), Timer1 increments on every internal instruction\nWhen Timer1 is enabled, the RC1/T1OSI and RC0/T1OSO/T13CKI pins become inputs. This means the values of TRISC<1:0> are ignored and the pins are read as GLYPH<145> 0 GLYPH<146>.",
    "FIGURE 11-2: TIMER1 BLOCK DIAGRAM (16-BIT READ/WRITE MODE)\nNote 1: When T1OSCEN is cleared, the inverter and feedback resistor are turned off to eliminate power drain.",
    "11.2 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured for 16-bit reads and writes (see Figure 11-2). When the RD16 control bit (T1CON<7>) is set, the address for TMR1H is mapped to a buffer register for the high byte of Timer1. A read from TMR1L will load the contents of the high byte of Timer1 into the Timer1 High Byte Buffer register. This provides the user with the ability to accurately read all 16 bits of Timer1 without having to determine whether a read of the high byte, followed by a read of the low byte,  has  become  invalid  due  to  a  rollover  between reads.\nA write to the high byte of Timer1 must also take place through the TMR1H Buffer register. The Timer1 high byte is updated with the contents of TMR1H when a write occurs to TMR1L. This allows a user to write all 16 bits to both the high and low bytes of Timer1 at once.",
    "11.2 Timer1 16-Bit Read/Write Mode\nThe  high  byte  of  Timer1  is  not  directly  readable  or writable in this mode. All reads and writes must take place  through  the  Timer1  High  Byte  Buffer  register. Writes  to  TMR1H  do  not  clear  the  Timer1  prescaler. The prescaler is only cleared on writes to TMR1L.",
    "11.3 Timer1 Oscillator\nAn  on-chip  crystal oscillator circuit is incorporated between  pins  T1OSI  (input)  and  T1OSO  (amplifier output).  It  is  enabled  by  setting  the  Timer1  Oscillator Enable bit, T1OSCEN (T1CON<3>). The oscillator is a low-power  circuit rated for 32 kHz  crystals. It will continue to run during all power-managed modes. The circuit for a typical LP oscillator is shown in Figure 11-3. Table 11-1 shows the capacitor selection for the Timer1 oscillator.\nThe user must provide a software time delay to ensure proper start-up of the Timer1 oscillator.",
    "TABLE 11-1: CAPACITOR SELECTION FOR THE TIMER1 OSCILLATOR (2,3,4)\nLP, Freq = 32 kHz. LP, C1 = 27 pF (1). LP, C2 = 27 pF (1)\nNote 1: Microchip  suggests  these  values  as  a starting  point  in  validating  the  oscillator circuit.\n2: Higher capacitance increases the stability of  the  oscillator,  but  also  increases  the start-up time.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer for appropriate values of external components.\n4: Capacitor values are for design guidance only.",
    "11.3.1 USING TIMER1 AS A CLOCK SOURCE\nThe Timer1 oscillator is also available as a clock source in power-managed modes. By setting the clock select bits, SCS1:SCS0 (OSCCON<1:0>), to GLYPH<145> 01 GLYPH<146>, the device switches  to  SEC_RUN  mode;  both  the  CPU  and peripherals are clocked from the Timer1 oscillator. If the IDLEN  bit  (OSCCON<7>)  is  cleared  and  a SLEEP instruction  is  executed,  the  device  enters  SEC_IDLE mode. Additional details are available  in Section 3.0 GLYPH<147>Power-Managed ModesGLYPH<148> .",
    "11.3.1 USING TIMER1 AS A CLOCK SOURCE\nWhenever the Timer1 oscillator is providing the clock source,  the  Timer1  system  clock status  flag, T1RUN (T1CON<6>), is set. This can be used to determine the controllerGLYPH<146>s current clocking mode. It can also indicate the clock source being currently used by the Fail-Safe Clock Monitor. If the Clock Monitor is enabled and the Timer1 oscillator fails while providing the clock, polling the T1RUN bit will indicate whether the clock is being provided by the Timer1 oscillator or another source.",
    "11.3.2 LOW-POWER TIMER1 OPTION\nThe Timer1 oscillator can operate at two distinct levels of power consumption based on device configuration. When the LPT1OSC Configuration bit is set, the Timer1 oscillator operates in a low-power mode. When LPT1OSC is not set, Timer1 operates at a higher power level.  Power  consumption  for  a  particular  mode  is relatively constant, regardless of the deviceGLYPH<146>s operating mode. The default Timer1 configuration is the higher power mode.\nAs  the  Low-Power  Timer1  mode  tends  to  be  more sensitive to interference, high noise environments may cause some oscillator instability. The low-power option is therefore best suited for low noise applications where power conservation is an important design consideration.",
    "11.3.3 TIMER1 OSCILLATOR LAYOUT CONSIDERATIONS\nThe  Timer1  oscillator  circuit  draws  very  little  power during operation. Due to the low-power nature of the oscillator, it may also be sensitive to rapidly changing signals in close proximity.\nThe oscillator circuit, shown in Figure 11-3, should be located  as  close  as  possible  to  the  microcontroller. There should be no circuits passing within the oscillator circuit boundaries other than VSS or VDD.\nIf a  high-speed  circuit  must  be  located  near  the oscillator (such as the CCP1 pin in Output Compare or PWM mode, or the primary oscillator using the OSC2 pin), a grounded guard ring around the oscillator circuit, as shown in Figure 11-4, may be helpful when used on a single sided PCB or in addition to a ground plane.",
    "11.4 Timer1 Interrupt\nThe TMR1 register pair (TMR1H:TMR1L) increments from  0000h  to  FFFFh  and  rolls  over  to  0000h.  The Timer1 interrupt, if enabled, is generated on overflow, which is latched in interrupt flag bit, TMR1IF (PIR1<0>). This interrupt can be enabled or disabled by setting or clearing the Timer1 Interrupt Enable bit, TMR1IE (PIE1<0>).",
    "11.5 Resetting Timer1 Using the CCP Special Event Trigger\nIf either of the CCP modules is configured in Compare mode to generate a Special Event Trigger (CCP1M3:CCP1M0 or CCP2M3:CCP2M0 = 1011 ), this signal will reset Timer1. The trigger from CCP2 will also  start  an  A/D  conversion  if  the  A/D  module  is enabled (see Section 14.3.4 GLYPH<147>Special Event TriggerGLYPH<148> for more information.).\nThe module must be configured as either a timer or a synchronous counter to take advantage of this feature. When used this way, the CCPRH:CCPRL register pair effectively becomes a period register for Timer1.\nIf  Timer1  is  running  in  Asynchronous  Counter mode, this Reset operation may not work.\nIn  the  event  that  a  write  to  Timer1  coincides  with  a Special  Event  Trigger,  the  write  operation  will  take precedence.\nNote:, 1 = The Special Event Triggers from the CCP2 module will not set the TMR1IF interrupt flag bit (PIR1<0>).",
    "11.6 Using Timer1 as a Real-Time Clock\nAdding an external LP oscillator to Timer1 (such as the one  described  in Section 11.3  GLYPH<147>Timer1  OscillatorGLYPH<148> , above) gives users the option to include RTC functionality to their applications. This is accomplished with an inexpensive watch crystal to provide an accurate time base and several lines of application code to calculate the time. When operating in Sleep mode and using a battery  or  supercapacitor  as  a  power  source,  it  can completely  eliminate  the  need  for  a  separate  RTC device and battery backup.\nThe  application code  routine, RTCisr , shown  in Example 11-1, demonstrates a simple method  to increment a counter at one-second intervals using an Interrupt  Service  Routine.  Incrementing  the  TMR1 register pair to overflow, triggers the interrupt and calls the routine, which increments the seconds counter by one;  additional  counters  for  minutes  and  hours  are incremented as the previous counter overflows.",
    "11.6 Using Timer1 as a Real-Time Clock\nSince the register pair is 16 bits wide, counting up to overflow the register directly from a 32.768 kHz clock would  take  2  seconds.  To  force  the  overflow  at  the required one-second  intervals, it is necessary  to preload it. The simplest method is to set the Most Significant bit of TMR1H with a BSF instruction. Note that the TMR1L register is never preloaded or altered; doing so may introduce cumulative error over many cycles.\nFor this method to be accurate, Timer1 must operate in Asynchronous mode and the Timer1 overflow interrupt must  be  enabled  (PIE1<0>  = 1 ), as  shown  in  the routine, RTCinit . The Timer1 oscillator must also be enabled and running at all times.",
    "EXAMPLE 11-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nMOVLW MOVWF CLRF MOVLW MOVWF CLRF CLRF MOVLW MOVWF, 1 = 80h TMR1H TMR1L bGLYPH<146>00001111GLYPH<146> T1OSC secs mins .12 hours PIE1, TMR1IE. MOVLW MOVWF CLRF MOVLW MOVWF CLRF CLRF MOVLW MOVWF, 2 = ; Preload TMR1 register pair for 1 second overflow. RETURN BSF, 1 = TMR1H, 7. RETURN BSF, 2 = ; Preload for 1 sec overflow Clear interrupt flag. RETURN CLRF INCF, 1 = secs mins, F. RETURN CLRF INCF, 2 = ; No, done ; Clear seconds ; Increment minutes. , 1 = . , 2 = elapsed?. MOVLW CPFSGT RETURN CLRF, 1 = .59 mins. MOVLW CPFSGT RETURN CLRF, 2 =",
    "EXAMPLE 11-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\n; No, done clear minutes. , 1 = hours, F. , 2 = ; Increment hours. MOVLW CPFSGT RETURN, 1 = .23 hours. MOVLW CPFSGT RETURN, 2 = ; 24 hours elapsed?. MOVLW, 1 = .01. MOVLW, 2 = ; No, done Reset hours to 1. RETURN, 1 = hours. RETURN, 2 = Done. MOVWF, 1 = . MOVWF, 2 = . , 1 = . , 2 = ;. , 1 = . , 2 = ;. , 1 = ; 60. , 2 = ; 60. mins, 1 = mins. mins, 2 = mins. minutes, 1 = minutes. minutes, 2 = minutes. INCF, 1 = . INCF, 2 = ",
    "TABLE 11-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 =",
    "TABLE 11-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nTX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page = 61. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte.",
    "TABLE 11-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nTMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Reset Values on Page = 60. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Reset Values on Page = 60. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0.",
    "TABLE 11-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nT1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Reset Values on Page = 60\nLegend:\nGLYPH<151> = unimplemented, read as GLYPH<145>\n0 GLYPH<146> . Shaded cells are not used by the Timer1 module.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "12.0 TIMER2 MODULE\nThe  Timer2  timer  module  incorporates  the  following features:\nGLYPH<149> 8-bit Timer and Period registers (TMR2 and PR2, respectively)\nGLYPH<149> Readable and writable (both registers)\nGLYPH<149> Software programmable prescaler (1:1, 1:4 and 1:16)\nGLYPH<149> Software programmable postscaler (1:1 through 1:16)\nGLYPH<149> Interrupt on TMR2 to PR2 match\nGLYPH<149> Optional use as the shift clock for the MSSP module\nThe module is controlled through the T2CON register (Register 12-1),  which  enables  or  disables  the  timer and  configures  the  prescaler  and  postscaler.  Timer2 can  be  shut  off  by  clearing  control  bit,  TMR2ON (T2CON<2>), to minimize power consumption.\nA simplified block diagram of the module is shown in Figure 12-1.",
    "12.1 Timer2 Operation\nIn normal operation, TMR2 is incremented from 00h on each clock (FOSC/4). A 2-bit counter/prescaler on the clock input gives direct input, divide-by-4 and divide-by-16  prescale  options;  these  are  selected  by the prescaler control bits, T2CKPS1:T2CKPS0 (T2CON<1:0>). The value of TMR2 is compared to that of the Period register, PR2, on each clock cycle. When the  two  values  match,  the  comparator  generates  a match signal as the timer output. This signal also resets the value of TMR2 to 00h on the next cycle and drives the output counter/postscaler (see Section 12.2 GLYPH<147>Timer2 InterruptGLYPH<148> ).\nThe TMR2 and PR2 registers are both directly readable and  writable.  The  TMR2  register  is  cleared  on  any device Reset, while the PR2 register initializes at FFh. Both the prescaler and postscaler counters are cleared on the following events:",
    "12.1 Timer2 Operation\nGLYPH<149> a write to the TMR2 register\nGLYPH<149> a write to the T2CON register\nGLYPH<149> any device Reset (Power-on Reset, MCLR Reset, Watchdog Timer Reset, or Brown-out Reset)\nTMR2 is not cleared when T2CON is written.",
    "REGISTER 12-1: T2CON: TIMER2 CONTROL REGISTER\nGLYPH<151>, R/W-0 = T2OUTPS3. GLYPH<151>, R/W-0 = T2OUTPS2. GLYPH<151>, R/W-0 = T2OUTPS1. GLYPH<151>, R/W-0 = T2OUTPS0. GLYPH<151>, R/W-0 = TMR2ON. GLYPH<151>, R/W-0 = T2CKPS1. GLYPH<151>, R/W-0 = T2CKPS0. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 12-1: T2CON: TIMER2 CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 6-3\nT2OUTPS3:T2OUTPS0: Timer2 Output Postscale Select bits\n0000 = 1:1 Postscale\n0001 = 1:2 Postscale\nGLYPH<149>",
    "REGISTER 12-1: T2CON: TIMER2 CONTROL REGISTER\nGLYPH<149>\nGLYPH<149>\n1111 = 1:16 Postscale\nbit 2\nTMR2ON:\nTimer2 On bit\n1 = Timer2 is on\n0 = Timer2 is off\nbit 1-0\nT2CKPS1:T2CKPS0: Timer2 Clock Prescale Select bits\n00 = Prescaler is 1\n01 = Prescaler is 4\n1x = Prescaler is 16",
    "12.2 Timer2 Interrupt\nTimer2 also can generate an optional device interrupt. The  Timer2  output  signal  (TMR2  to  PR2  match) provides the input for the 4-bit output counter/postscaler. This counter generates the TMR2 match  interrupt flag which  is latched in TMR2IF (PIR1<1>).  The  interrupt  is  enabled  by  setting  the TMR2 Match Interrupt Enable bit, TMR2IE (PIE1<1>).\nA range of 16 postscale options (from 1:1 through 1:16 inclusive) can be selected with the postscaler control bits, T2OUTPS3:T2OUTPS0 (T2CON<6:3>).",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 =",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nTX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page = 61. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2,",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nBit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, Reset Values on Page = 60. T2CON, Bit 7 = GLYPH<151>. T2CON, Bit 6 = T2OUTPS3. T2CON, Bit 5 = T2OUTPS2. T2CON, Bit 4 = T2OUTPS1. T2CON, Bit 3 = T2OUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Reset Values on Page = 60. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Reset Values on",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nPage = 60\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used by the Timer2 module.",
    "12.3 TMR2 Output\nThe unscaled output of TMR2 is available primarily to the CCP modules, where it is used as a time base for operations in PWM mode.\nTimer2 can be optionally used as the shift clock source for the MSSP  module operating in SPI mode. Additional information  is provided  in Section 15.0 GLYPH<147>Master Synchronous Serial Port (MSSP) ModuleGLYPH<148> .",
    "13.0 TIMER3 MODULE\nThe Timer3 timer/counter  module  incorporates  these features:\nA  simplified  block  diagram  of  the  Timer3  module  is shown in Figure 13-1. A block diagram of the moduleGLYPH<146>s operation in Read/Write mode is shown in Figure 13-2.\nGLYPH<149> Software selectable operation as a 16-bit timer or counter\nGLYPH<149> Readable and writable 8-bit registers (TMR3H and TMR3L)\nGLYPH<149> Selectable clock source (internal or external), with device clock or Timer1 oscillator internal options\nGLYPH<149> Interrupt-on-overflow\nGLYPH<149> Module Reset on CCP Special Event Trigger",
    "REGISTER 13-1: T3CON: TIMER3 CONTROL REGISTER\nRD16, R/W-0 = T3CCP2. RD16, R/W-0 = T3CKPS1. RD16, R/W-0 = T3CKPS0. RD16, R/W-0 = T3CCP1. RD16, R/W-0 = T3SYNC. RD16, R/W-0 = TMR3CS. RD16, R/W-0 = TMR3ON. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as GLYPH<145>0GLYPH<146>\n-n = Value at POR\nGLYPH<145> 1GLYPH<146> = Bit is set\nGLYPH<145> 0GLYPH<146> = Bit is cleared\nx = Bit is unknown",
    "bit 7\nRD16: 16-Bit Read/Write Mode Enable bit\n1 = Enables register read/write of Timer3 in one 16-bit operation\n0 = Enables register read/write of Timer3 in two 8-bit operations\nbit 6,3\nT3CCP2:T3CCP1: Timer3 and Timer1 to CCPx Enable bits\n1x = Timer3 is the capture/compare clock source for the CCPx modules\n01 = Timer3 is the capture/compare clock source for the CCP2 module;\nTimer1 is the capture/compare clock source for the CCP1 module\n00 = Timer1 is the capture/compare clock source for the CCPx modules",
    "bit 5-4 T3CKPS1:T3CKPS0 : Timer3 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value",
    "bit 2 T3SYNC: Timer3 External Clock Input Synchronization Control bit\n(Not usable if the device clock comes from Timer1/Timer3.)\nWhen TMR3CS = 1 :\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR3CS = 0 :\nThis bit is ignored. Timer3 uses the internal clock when TMR3CS = 0 .",
    "bit 1\nTMR3CS: Timer3 Clock Source Select bit\n1 = External clock input from Timer1 oscillator or T13CKI (on the rising edge after the first falling edge)\n0 = Internal clock (FOSC/4)",
    "bit 0\nTMR3ON: Timer3 On bit\n1 = Enables Timer3\n0 = Stops Timer3\nThe Timer3 module is controlled through the T3CON register (Register 13-1). It also selects the clock source options  for  the  CCP  modules  (see Section 14.1.1 GLYPH<147>CCP Modules  and  Timer  ResourcesGLYPH<148> for  more information).",
    "13.1 Timer3 Operation\nTimer3 can operate in one of three modes:\ncycle (FOSC/4). When the bit is set, Timer3 increments on every rising edge of the Timer1 external clock input or the Timer1 oscillator, if enabled.\nGLYPH<149> Timer\nGLYPH<149> Synchronous counter\nGLYPH<149> Asynchronous counter\nThe operating mode is determined by the clock select bit, TMR3CS (T3CON<1>). When TMR3CS is cleared (= 0 ), Timer3 increments on every internal instruction\nAs with Timer1, the RC1/T1OSI and RC0/T1OSO/T13CKI  pins  become  inputs  when  the Timer1 oscillator is enabled. This means the values of TRISC<1:0> are ignored and the pins are read as GLYPH<145> 0 GLYPH<146> .",
    "13.2 Timer3 16-Bit Read/Write Mode\nTimer3 can be configured for 16-bit reads and writes (see Figure 13-2). When the RD16 control bit (T3CON<7>) is set, the address for TMR3H is mapped to a buffer register for the high byte of Timer3. A read from TMR3L will load the contents of the high byte of Timer3 into the Timer3 High Byte Buffer register. This provides the user with the ability to accurately read all 16 bits of Timer1 without having to determine whether a read of the high byte, followed by a read of the low byte,  has  become  invalid  due  to  a  rollover  between reads.\nA write to the high byte of Timer3 must also take place through the TMR3H Buffer register. The Timer3 high byte is updated with the contents of TMR3H when a write occurs to TMR3L. This allows a user to write all 16 bits to both the high and low bytes of Timer3 at once.\nThe  high  byte  of  Timer3  is  not  directly  readable  or writable in this mode. All reads and writes must take place through the Timer3 High Byte Buffer register.",
    "13.2 Timer3 16-Bit Read/Write Mode\nWrites  to  TMR3H  do  not  clear  the  Timer3  prescaler. The prescaler is only cleared on writes to TMR3L.",
    "13.3 Using the Timer1 Oscillator as the Timer3 Clock Source\nThe Timer1 internal oscillator may be used as the clock source for Timer3. The Timer1 oscillator is enabled by setting the T1OSCEN (T1CON<3>) bit. To use it as the Timer3 clock source, the TMR3CS bit must also be set. As  previously  noted,  this  also  configures  Timer3  to increment on every rising edge of the oscillator source.",
    "13.4 Timer3 Interrupt\nThe TMR3 register pair (TMR3H:TMR3L) increments from  0000h  to  FFFFh  and  overflows  to  0000h.  The Timer3 interrupt, if enabled, is generated on overflow and is latched in interrupt flag bit, TMR3IF (PIR2<1>). This interrupt can be enabled or disabled by setting or clearing the Timer3  Interrupt  Enable  bit, TMR3IE (PIE2<1>).",
    "13.5 Resetting Timer3 Using the CCP Special Event Trigger\nIf either of the CCP modules is configured in Compare mode to generate a Special Event Trigger (CCP1M3:CCP1M0 or CCP2M3:CCP2M0 = 1011 ), this signal will reset Timer1. The trigger from CCP2 will also  start  an  A/D  conversion  if  the  A/D  module  is enabled (see Section 14.3.4 GLYPH<147>Special Event TriggerGLYPH<148> for more information.).\nThe module must be configured as either a timer or synchronous counter to take advantage of this feature. When used this way,  the  CCPR2H:CCPR2L register pair effectively becomes a Period register for Timer3.\nIf  Timer3  is  running  in  Asynchronous  Counter mode, the Reset operation may not work.\nIn  the  event  that  a  write  to  Timer3  coincides  with  a Special Event Trigger from a CCP module, the write will take precedence.\nNote:\nThe Special Event Triggers from the CCP2 module will not set the TMR3IF interrupt flag bit (PIR2<1>).",
    "13.5 Resetting Timer3 Using the CCP Special Event Trigger\nThe  Timer1  oscillator  is  described  in Section 11.0 GLYPH<147>Timer1 ModuleGLYPH<148> .\n\nTABLE 13-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER",
    "13.5 Resetting Timer3 Using the CCP Special Event Trigger\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = GLYPH<151>. PIR2, Bit 4 = GLYPH<151>. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Reset Values on Page = 61. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = GLYPH<151>. PIE2, Bit",
    "13.5 Resetting Timer3 Using the CCP Special Event Trigger\n4 = GLYPH<151>. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Reset Values on Page = 61. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = GLYPH<151>. IPR2, Bit 4 = GLYPH<151>. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Reset Values on Page = 61. TMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte. TMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4 = Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register",
    "13.5 Resetting Timer3 Using the CCP Special Event Trigger\nLow Byte. TMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = Timer3 Register Low Byte. TMR3L, Reset Values on Page = 61. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit 2 = Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit 0 = Timer3 Register High Byte. TMR3H, Reset Values on Page = 61. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0.",
    "13.5 Resetting Timer3 Using the CCP Special Event Trigger\nT1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Reset Values on Page = 60. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Reset Values on Page = 61\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used by the Timer3 module.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "14.0 CAPTURE/COMPARE/PWM (CCP) MODULES\nPIC18F6390/6490/8390/8490 devices have two CCP (Capture/Compare/PWM) modules, designated CCP1 and CCP2. Both modules implement standard capture, compare and Pulse-Width Modulation (PWM) modes.\nEach CCP module contains a 16-bit register which can operate as a 16-bit Capture register, a 16-bit Compare register or a PWM Master/Slave Duty Cycle register. For the sake of clarity, all CCP module operation in the following sections is described with respect to CCP2, but is equally applicable to CCP1.",
    "REGISTER 14-1: CCPxCON: CCPx CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. GLYPH<151>, 1 = GLYPH<151>. GLYPH<151>, 2 = DCxB1. GLYPH<151>, 3 = DCxB0. GLYPH<151>, 4 = CCPxM3. GLYPH<151>, 5 = CCPxM2. GLYPH<151>, 6 = CCPxM1. GLYPH<151>, 7 = CCPxM0. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 =",
    "REGISTER 14-1: CCPxCON: CCPx CONTROL REGISTER\nbit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as GLYPH<145>0GLYPH<146>\n-n = Value at POR\nGLYPH<145> 1GLYPH<146> = Bit is set\nGLYPH<145>0GLYPH<146> = Bit is cleared\nx = Bit is unknown",
    "bit 7-6 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 5-4\nDCxB1:DCxB0 : PWM Duty Cycle bit 1 and bit 0 for CCPx Module\nCapture mode:\nUnused.\nCompare mode:\nUnused.\nPWM mode:\nThese bits are the two Least Significant bits (bit 1 and bit 0) of the 10-bit PWM duty cycle. The eight Most Significant bits (DCxB9:DCxB2) of the duty cycle are found in CCPRxL.",
    "bit 3-0 CCPxM3:CCPxM0 : CCPx Module Mode Select bits\n0000 = Capture/Compare/PWM disabled (resets CCPx module)\n0001\n= Reserved\n0010 = Compare mode, toggle output on match (CCPxIF bit is set)\n0011 = Reserved\n0100 = Capture mode, every falling edge\n0101 = Capture mode, every rising edge\n0110 = Capture mode, every 4th rising edge\n0111 = Capture mode, every 16th rising edge\n1000 = Compare mode: initialize CCPx pin low; on compare match, force CCPx pin high (CCPxIF bit is set)\n1001 = Compare mode: initialize CCPx pin high; on compare match, force CCPx pin low (CCPxIF bit is set)\n1010 = Compare mode: generate software interrupt on compare match (CCPxIF bit is set, CCPx pin reflects I/O state)\n1011 = Compare mode: trigger special event, reset timer, start A/D conversion on CCPx match (CCPxIF bit is set) (1)\n11xx = PWM mode",
    "bit 3-0 CCPxM3:CCPxM0 : CCPx Module Mode Select bits\nNote 1: CCPxM3:CCPxM0 = 1011 will only reset the timer and not start the A/D conversion on the CCPx match.",
    "14.1 CCP Module Configuration\nEach  Capture/Compare/PWM  module  is  associated with a control register (generically, CCPxCON) and a data register (CCPRx). The data register in turn is comprised of two 8-bit registers: CCPRxL (low byte) and CCPRxH (high byte). All registers  are both readable and writable.",
    "14.1.1 CCP MODULES AND TIMER RESOURCES\nThe CCP modules utilize Timers 1, 2 or 3, depending on the mode selected. Timer1 and Timer3 are available to modules  in  Capture  or  Compare  modes,  while Timer2 is available for modules in PWM mode.\nTABLE 14-1: CCP MODE GLYPH<150> TIMER RESOURCE\n\nCapture Compare PWM, Timer Resource = Timer1 or Timer3 Timer1 or Timer3 Timer2\nThe  assignment  of  a  particular  timer  to  a  module  is determined  by  the  Timer  to  CCP  enable  bits  in  the T3CON register (Register 13-1). Both modules may be active at any given time and may share the same timer resource if they are configured to operate in the same mode  (capture/compare  or  PWM)  at  the  same  time. The interactions between the two modules are summarized in Table 14-2.\nDepending  on  the  configuration  selected,  up  to  four timers may be active at once, with modules in the same configuration (capture/compare or PWM) sharing timer resources.  The  possible  configurations  are  shown  in Figure 14-1.",
    "14.1.2 CCP2 PIN ASSIGNMENT\nThe pin assignment for CCP2 (capture input, compare and PWM output) can change based on device configuration.  The  CCP2MX  Configuration  bit  determines which  pin  CCP2  is  multiplexed  to.  By  default,  it  is assigned to RC1 (CCP2MX = 1 ). If the Configuration bit is cleared, CCP2 is multiplexed with RE7.\nChanging  the  pin  assignment  of  CCP2  does  not automatically change any requirements for configuring the port pin. Users must always verify that the appropriate  TRIS  register  is  configured  correctly  for  CCP2 operation, regardless of where it is located.",
    "FIGURE 14-1: CCP AND TIMER INTERCONNECT CONFIGURATIONS\nTimer1 is used for all capture and  compare  operations  for all  CCP  modules.  Timer2  is used for PWM operations for all CCP  modules.  Modules may share either timer resource  as  a  common  time base.",
    "T3CCP<2:1> = 01\nTimer1  is  used  for  capture and  compare  operations  for CCP1 and Timer 3 is used for CCP2.\nBoth the modules use Timer2 as a common time base if they are in PWM modes.",
    "T3CCP<2:1> = 1x\nTimer3 is used for all capture and  compare  operations  for all  CCP  modules.  Timer2  is used for PWM operations for all CCP  modules.  Modules may share either timer resource  as  a  common  time base.",
    "TABLE 14-2: INTERACTIONS BETWEEN CCP1 AND CCP2 FOR TIMER RESOURCES\nCapture, CCP2 Mode = Capture. Capture, Interaction = Each module can use TMR1 or TMR3 as the time base. The time base can be different for each CCP.. Capture, CCP2 Mode = Compare. Capture, Interaction = CCP2 can be configured for the Special Event Trigger to reset TMR1 or TMR3 (depending upon which time base is used). Automatic A/D conversions on trigger event can also be done. Operation of CCP1 could be affected if it is using the same timer as a time base.. Compare, CCP2 Mode = Capture. Compare, Interaction = CCP1 can be configured for the Special Event Trigger to reset TMR1 or TMR3 (depending upon which time base is used). Operation of CCP2 could be affected if it is using the same timer as a time base.. Compare, CCP2 Mode = Compare. Compare, Interaction = Either module can be configured for the Special Event Trigger to reset the time base. Automatic A/D conversions on CCP2 trigger event can be done. Conflicts may occur if both modules are",
    "TABLE 14-2: INTERACTIONS BETWEEN CCP1 AND CCP2 FOR TIMER RESOURCES\nusing the same time base.. Capture, CCP2 Mode = PWM*. Capture, Interaction = None. Compare, CCP2 Mode = PWM*. Compare, Interaction = None. PWM*, CCP2 Mode = Capture. PWM*, Interaction = None. PWM*, CCP2 Mode = Compare. PWM*, Interaction = None. PWM*, CCP2 Mode = PWM. PWM*, Interaction = Both PWMs will have the same frequency and update rate (TMR2 interrupt).\n- * Includes standard and Enhanced PWM operation.",
    "14.2.3 SOFTWARE INTERRUPT\nIn Capture mode, the CCPR2H:CCPR2L register pair captures  the  16-bit  value  of  the  TMR1  or  TMR3 registers when an event occurs on the CCP2 pin (RC1 or RE7, depending on device configuration). An event is defined as one of the following:\nGLYPH<149> every falling edge\nGLYPH<149> every rising edge\nGLYPH<149> every 4th rising edge\nGLYPH<149> every 16th rising edge\nThe  event  is selected by the mode  select bits, CCP2M3:CCP2M0 (CCP2CON<3:0>). When a capture is made, the interrupt request flag bit, CCP2IF (PIR2<0>),  is  set;  it  must  be  cleared  in  software.  If another  capture  occurs  before  the  value  in  register CCPR2 is read, the old captured value is overwritten by the new captured value.",
    "14.2.1 CCP PIN CONFIGURATION\nIn Capture mode, the appropriate CCPx pin should be configured  as  an  input  by  setting  the  corresponding TRIS direction bit.\nNote:, 1 = If RC1/CCP2 or RE7/CCP2 is configured as an output, a write to the port can cause a capture condition.",
    "14.2.2 TIMER1/TIMER3 MODE SELECTION\nThe timers that are to be used with the capture feature (Timer1 and/or Timer3) must be running in Timer mode or Synchronized Counter mode. In Asynchronous Counter mode, the capture operation may not work.   The timer to be used with each CCP module is selected in the T3CON register (see Section 14.1.1 GLYPH<147>CCP Modules and Timer ResourcesGLYPH<148> ).\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user should keep bit CCP2IE (PIE2<0>) clear to avoid false interrupts and should clear the flag bit, CCP2IF, following any such change in operating mode.",
    "14.2.4 CCP PRESCALER\nThere are four prescaler settings in Capture mode; they are specified as part of the operating mode selected by the mode select bits (CCP2M3:CCP2M0). Whenever the CCP module is turned off, or the CCP module is not in Capture mode, the prescaler counter is cleared. This means that any Reset will clear the prescaler counter.\nSwitching from one capture prescaler to another may generate an interrupt. Also, the prescaler counter will not be cleared; therefore, the first capture may be from a non-zero prescaler. Example 14-1 shows the recommended method for switching between capture prescalers.  This  example  also  clears  the  prescaler counter and will not generate the GLYPH<147>falseGLYPH<148> interrupt.",
    "EXAMPLE 14-1: CHANGING BETWEEN CAPTURE PRESCALERS\nCLRF MOVLW, 1 = CCP2CON NEW_CAPT_PS. CLRF MOVLW, 2 = ; Turn CCP module off ; Load WREG with the ; new prescaler mode ; value and CCP ON. MOVWF, 1 = CCP2CON. MOVWF, 2 = ; Load CCP2CON with ; this value",
    "14.3 Compare Mode\nIn Compare mode, the 16-bit CCPR2 register value is constantly compared against either the TMR1 or TMR3 register  pair value. When a match occurs, the CCP2 pin can be:\nGLYPH<149> driven high\nGLYPH<149> driven low\nGLYPH<149> toggled (high-to-low or low-to-high)\nGLYPH<149> remain unchanged (that is, reflects the state of the I/O latch)\nThe action on the pin is based on the value of the mode select bits (CCP2M3:CCP2M0). At the same time, the interrupt flag bit, CCP2IF, is set.",
    "14.3.1 CCP PIN CONFIGURATION\nThe user must configure the CCPx pin as an output by clearing the appropriate TRIS bit.\nNote:, 1 = Clearing the CCP2CON register will force the RC1 or RE7 compare output latch (depending on device configuration) to the default low level. This is not the PORTC or PORTE I/O data latch.",
    "14.3.3 SOFTWARE INTERRUPT MODE\nWhen the Generate Software Interrupt mode is chosen (CCP2M3:CCP2M0  = 1010 ), the  CCP2  pin  is  not affected. Only a CCP interrupt is generated if enabled and the CCP2IE bit is set.",
    "14.3.4 SPECIAL EVENT TRIGGER\nBoth CCP modules are equipped with a Special Event Trigger. This is an internal hardware signal generated in Compare mode to trigger actions by other modules. The  Special  Event  Trigger  is  enabled  by  selecting the Compare Special Event Trigger mode (CCP2M3:CCP2M0 = 1011 ).\nFor either CCP module, the Special Event Trigger resets the Timer register pair for whichever timer resource is currently  assigned  as  the  moduleGLYPH<146>s  time  base.  This allows the CCPRx registers to serve as a programmable Period register for either timer.\nThe Special Event Trigger for CCP2 can also start an A/D conversion. In order to do this, the A/D converter must already be enabled.",
    "Note:\nThe Special Event Trigger of CCP1 only resets Timer1/Timer3 and cannot start an A/D conversion even when the A/D converter is enabled.\nTimer1 and/or Timer3 must be running in Timer mode, or Synchronized Counter mode, if the CCP module is using the compare feature. In Asynchronous Counter mode, the compare operation may not work.",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. RCON, Bit 7 = IPEN. RCON, Bit 6 = SBOREN. RCON, Bit 5 = GLYPH<151>. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Reset Values on Page = 60. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF.",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nPIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 =",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR1IP. IPR1, Reset Values on Page = 61. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = GLYPH<151>. PIR2, Bit 4 = GLYPH<151>. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Reset Values on Page = 61. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = GLYPH<151>. PIE2, Bit 4 = GLYPH<151>. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Reset Values on Page = 61. IPR2, Bit 7 = OSCFIP.",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nIPR2, Bit 6 = CMIP. IPR2, Bit 5 = GLYPH<151>. IPR2, Bit 4 = GLYPH<151>. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Reset Values on Page = 61. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Reset Values on Page = 62. TRISE, Bit 7 = PORTE Data Direction Register. TRISE, Bit 6 = PORTE Data Direction Register. TRISE, Bit 5 = PORTE Data Direction Register. TRISE, Bit",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n4 = PORTE Data Direction Register. TRISE, Bit 3 = GLYPH<151>. TRISE, Bit 2 = GLYPH<151>. TRISE, Bit 1 = GLYPH<151>. TRISE, Bit 0 = GLYPH<151>. TRISE, Reset Values on Page = 62. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Reset Values on Page = 60. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Reset Values on Page = 60. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Reset Values on Page = 60. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte.",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit 2 = Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit 0 = Timer3 Register High Byte. TMR3H, Reset Values on Page = 61. TMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte. TMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4 = Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register Low Byte. TMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = Timer3 Register Low Byte. TMR3L, Reset Values on Page = 61.",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nT3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Reset Values on Page = 61. CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 =",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCapture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Reset Values on Page = 61. CCPR1H, Bit 7 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Reset Values on Page = 61. CCP1CON, Bit 7 = GLYPH<151>. CCP1CON, Bit 6 =",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nGLYPH<151>. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Reset Values on Page = 61. CCPR2L, Bit 7 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 6 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 5 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 4 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 3 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 2 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 1 = Capture/Compare/PWM Register 2 Low",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nByte. CCPR2L, Bit 0 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Reset Values on Page = 61. CCPR2H, Bit 7 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 6 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 5 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 4 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 3 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 2 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 1 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 0 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Reset Values on Page = 61. CCP2CON, Bit 7 = GLYPH<151>. CCP2CON, Bit 6 = GLYPH<151>.",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Reset Values on Page = 61\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used by capture/compare, Timer1 or Timer3.",
    "14.4 PWM Mode\nIn Pulse-Width Modulation (PWM) mode, the CCP2 pin produces up to a 10-bit resolution PWM output. Since the CCP2 pin is multiplexed with a PORTC or PORTE data latch, the appropriate TRIS bit must be cleared to make the CCP2 pin an output.\nNote:, 1 = Clearing the CCP2CON register will force the RC1 or RE7 output latch (depending on device configuration) to the default low level. This is not the PORTC or PORTE I/O data latch.\nFigure 14-4  shows  a  simplified  block  diagram  of  the CCP2 module in PWM mode.\nFor a step-by-step procedure on how to set up the CCP module for PWM  operation, see Section 14.4.3 GLYPH<147>Setup for PWM OperationGLYPH<148> .",
    "FIGURE 14-4: SIMPLIFIED PWM BLOCK DIAGRAM\nNote 1: The 8-bit TMR2 value is concatenated with the 2-bit internal Q clock, or 2 bits of the prescaler, to create the 10-bit time base.\nA PWM output (Figure 14-5) has a time base (period) and a time that the output stays high (duty cycle). The frequency  of  the  PWM  is  the  inverse  of  the  period (1/period).",
    "14.4.1 PWM PERIOD\nThe  PWM  period  is  specified  by  writing  to  the  PR2 register. The PWM period can be calculated using the following formula:",
    "EQUATION 14-1:\nPWM Period   = (PR2) + 1] GLYPH<149> 4 GLYPH<149> T OSC GLYPH<149> (TMR2 Prescale Value)\nPWM frequency is defined as 1/[PWM period].\nWhen TMR2 is equal to PR2, the following three events occur on the next increment cycle:\nGLYPH<149> TMR2 is cleared\nGLYPH<149> The CCP2 pin is set (exception: if PWM duty cycle = 0%, the CCP2 pin will not be set)\nGLYPH<149> The PWM duty cycle is latched from CCPR2L into CCPR2H\nNote:\nThe Timer2 postscalers (see Section 12.0 GLYPH<147>Timer2 ModuleGLYPH<148> )  are  not  used  in  the determination of the PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.",
    "14.4.2 PWM DUTY CYCLE\nThe  PWM  duty  cycle  is  specified  by  writing  to  the CCPR2L register and to the CCP2CON<5:4> bits. Up to 10-bit resolution is available. The CCPR2L contains the eight MSbs and the CCP2CON<5:4> bits contain the  two  LSbs.  This  10-bit  value  is  represented  by CCPR2L:CCP2CON<5:4>.  The  following  equation  is used to calculate the PWM duty cycle in time:",
    "EQUATION 14-2:\nPWM Duty Cycle = (CCPR2L:CCP2CON<5:4>) GLYPH<149> TOSC GLYPH<149> (TMR2 Prescale V alue)\nThe  CCPR2H  register  and  a  2-bit  internal  latch  are used  to  double-buffer the PWM  duty  cycle.  This double-buffering is essential for glitchless PWM operation.\nWhen  the  CCPR2H  and  2-bit  latch  match  TMR2, concatenated with an internal 2-bit Q clock or 2 bits of the TMR2 prescaler, the CCP2 pin is cleared.\nThe maximum PWM resolution (bits) for a given PWM frequency is given by the equation:",
    "EQUATION 14-3:\nCCPR2L and CCP2CON<5:4> can be written to at any time,  but  the  duty  cycle  value  is  not  latched  into CCPR2H until after a match between PR2 and TMR2 occurs  (i.e.,  the  period  is  complete).  In  PWM  mode, CCPR2H is a read-only register.\n<!-- formula-not-decoded -->\nNote:\nIf the PWM duty cycle value is longer than the PWM period, the CCP2 pin will not be cleared.",
    "TABLE 14-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\nTimer Prescaler (1, 4, 16), 2.44 kHz = 16. Timer Prescaler (1, 4, 16), 9.77 kHz = 4. Timer Prescaler (1, 4, 16), 39.06 kHz = 1. Timer Prescaler (1, 4, 16), 156.25 kHz = 1. Timer Prescaler (1, 4, 16), 312.50 kHz = 1. Timer Prescaler (1, 4, 16), 416.67 kHz = 1. PR2 Value, 2.44 kHz = FFh. PR2 Value, 9.77 kHz = FFh. PR2 Value, 39.06 kHz = FFh. PR2 Value, 156.25 kHz = 3Fh. PR2 Value, 312.50 kHz = 1Fh. PR2 Value, 416.67 kHz = 17h. Maximum Resolution (bits), 2.44 kHz = 14. Maximum Resolution (bits), 9.77 kHz = 12. Maximum Resolution (bits), 39.06 kHz = 10. Maximum Resolution (bits), 156.25 kHz =",
    "TABLE 14-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\n8. Maximum Resolution (bits), 312.50 kHz = 7. Maximum Resolution (bits), 416.67 kHz = 6.58",
    "14.4.3 SETUP FOR PWM OPERATION\nThe following steps should be taken when configuring the CCP2 module for PWM operation:\n3. Make the CCP2 pin an output by clearing the appropriate TRIS bit.\n1. Set  the  PWM  period  by  writing  to  the  PR2 register.\n4. Set  the  TMR2  prescale  value,  then  enable Timer2 by writing to T2CON.\n5. Configure the CCP2 module for PWM operation.\n2. Set  the  PWM  duty  cycle  by  writing  to  the CCPR2L register and CCP2CON<5:4> bits.",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. RCON, Bit 7 = IPEN. RCON, Bit 6 = SBOREN. RCON, Bit 5 = GLYPH<151>. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Reset Values on Page = 60. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= 61. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Reset Values on Page = 62. TRISE, Bit 7 = PORTE Data Direction Register. TRISE, Bit 6 = PORTE Data Direction Register. TRISE, Bit 5 = PORTE Data Direction Register. TRISE, Bit 4 = PORTE Data Direction Register. TRISE, Bit 3 = GLYPH<151>. TRISE, Bit 2 = GLYPH<151>. TRISE, Bit 1 = GLYPH<151>. TRISE, Bit 0 = GLYPH<151>. TRISE, Reset Values on Page = 62. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register.",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nTMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, Reset Values on Page = 60. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Reset Values on Page = 60. T2CON, Bit 7 = GLYPH<151>. T2CON, Bit 6 = T2OUTPS3. T2CON, Bit 5 = T2OUTPS2. T2CON, Bit 4 = T2OUTPS1. T2CON, Bit 3 =",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nT2OUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Reset Values on Page = 60. CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Reset Values on Page = 61. CCPR1H, Bit 7 =",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCapture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Reset Values on Page = 61. CCP1CON, Bit 7 = GLYPH<151>. CCP1CON, Bit 6 = GLYPH<151>. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 =",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Reset Values on Page = 61. CCPR2L, Bit 7 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 6 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 5 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 4 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 3 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 2 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 1 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 0 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Reset Values on Page = 61. CCPR2H, Bit 7 = Capture/Compare/PWM Register 2 High Byte.",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCPR2H, Bit 6 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 5 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 4 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 3 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 2 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 1 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 0 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Reset Values on Page = 61. CCP2CON, Bit 7 = GLYPH<151>. CCP2CON, Bit 6 = GLYPH<151>. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Reset Values on Page = 61\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used by PWM or Timer2.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "15.1 Master SSP (MSSP) Module Overview\nThe Master Synchronous Serial Port (MSSP) module is a serial interface, useful for communicating with other peripheral or microcontroller devices. These peripheral devices  may  be  serial  EEPROMs,  shift  registers, display drivers, A/D converters, etc. The MSSP module can operate in one of two modes:\nGLYPH<149> Serial Peripheral Interface (SPI)\nGLYPH<149> Inter-Integrated Circuit (I 2 C)\n-Full Master mode\n-Slave mode (with general address call)\nThe  I 2 C  interface  supports  the  following  modes  in hardware:\nGLYPH<149> Master mode\nGLYPH<149> Multi-Master mode\nGLYPH<149> Slave mode",
    "15.2 Control Registers\nThe  MSSP  module  has  three  associated  registers. These  include  a  status  register  (SSPSTAT)  and  two control registers (SSPCON1 and SSPCON2). The use of these registers and their individual Configuration bits differ  significantly  depending  on  whether  the  MSSP module is operated in SPI or I 2 C mode.\nAdditional  details  are  provided  under  the  individual sections.",
    "15.3 SPI Mode\nThe SPI mode allows 8 bits of data to be synchronously transmitted and received simultaneously. All four modes of SPI are supported. To accomplish communication, typically three pins are used:\nGLYPH<149> Serial Data Out (SDO) GLYPH<150> RC5/SDO/SEG12\nGLYPH<149> Serial Data In (SDI) GLYPH<150> RC4/SDI/SDA\nGLYPH<149> Serial Clock (SCK) GLYPH<150> RC3/SCK/SCL\nAdditionally, a fourth pin may be used when in a Slave mode of operation:\n- GLYPH<149> Slave Select (SS) GLYPH<150> RF7/SS/SEG25\nFigure 15-1  shows  the  block  diagram  of  the  MSSP module when operating in SPI mode.",
    "15.3.1 REGISTERS\nThe  MSSP  module  has  four  registers  for  SPI  mode operation. These are:\nSSPSR is the shift register used for shifting data in or out. SSPBUF is the buffer register to which data bytes are written to or read from.\nGLYPH<149> MSSP Control Register 1 (SSPCON1)\nGLYPH<149> MSSP Status Register (SSPSTAT)\nGLYPH<149> Serial Receive/Transmit Buffer Register (SSPBUF)\nGLYPH<149> MSSP Shift Register (SSPSR) GLYPH<150> Not directly accessible\nSSPCON1 and SSPSTAT are the control and status registers in SPI  mode  operation.  The  SSPCON1 register  is  readable  and  writable. The  lower 6 bits of the  SSPSTAT are read-only. The upper 2 bits of the SSPSTAT are read/write.\nIn receive operations, SSPSR and SSPBUF together create a double-buffered receiver. When  SSPSR receives a complete byte, it is transferred to SSPBUF and the SSPIF interrupt is set.",
    "15.3.1 REGISTERS\nDuring  transmission,  the  SSPBUF  is  not  doublebuffered. A write to SSPBUF will write to both SSPBUF and SSPSR.",
    "REGISTER 15-1: SSPSTAT: MSSP STATUS REGISTER (SPI MODE)\nSMP, R/W-0 = CKE. SMP, R-0 = D/A. SMP, R-0 = P. SMP, R-0 = S. SMP, R-0 = R/W. SMP, R-0 = UA. SMP, R-0 = BF. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0",
    "REGISTER 15-1: SSPSTAT: MSSP STATUS REGISTER (SPI MODE)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 SMP: Sample bit\nSPI Master mode:\n- 1 = Input data sampled at end of data output time\n0 = Input data sampled at middle of data output time\nSPI Slave mode:\nSMP must be cleared when SPI is used in Slave mode.\nCKE: SPI Clock Edge Select bit\nWhen CKP = 0 :\n1 = Data transmitted on rising edge of SCK\n0 = Data transmitted on falling edge of SCK",
    "When CKP = 1 :\n1 = Data transmitted on falling edge of SCK\n0 = Data transmitted on rising edge of SCK",
    "bit 5 D/A: Data/Address bit\nUsed in I 2 CGLYPH<153> mode only.",
    "bit 4 P: Stop bit\nUsed in I 2 C mode only. This bit is cleared when the MSSP module is disabled, SSPEN is cleared.",
    "bit 3 S: Start bit\nUsed in I 2 C mode only.",
    "bit 2 R/W: Read/Write Information bit\nUsed in I 2 C mode only.",
    "bit 0\nUA: Update Address bit\nUsed in I 2 C mode only.\nBF: Buffer Full Status bit (Receive mode only)\n- 1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty bit 6",
    "REGISTER 15-2: SSPCON1: MSSP CONTROL REGISTER 1 (SPI MODE)\nWCOL, R/W-0 = SSPOV (1). WCOL, R/W-0 = SSPEN (2). WCOL, R/W-0 = CKP. WCOL, R/W-0 = SSPM3 (3). WCOL, R/W-0 = SSPM2 (3). WCOL, R/W-0 = SSPM1 (3). WCOL, R/W-0 = SSPM0 (3). bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 15-2: SSPCON1: MSSP CONTROL REGISTER 1 (SPI MODE)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 WCOL:\nWrite Collision Detect bit (Transmit mode only)\n1 = The SSPBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision",
    "bit 6 SSPOV: Receive Overflow Indicator bit\n(1)\nSPI Slave mode:\n1 = A new byte is received while the SSPBUF register is still holding the previous data. In case of overflow, the data in SSPSR is lost. Overflow can only occur in Slave mode. The user must read the SSPBUF, even if only transmitting data, to avoid setting overflow (must be cleared in software).\n0 = No overflow",
    "bit 5 SSPEN: Synchronous Serial Port Enable bit\n(2)\n1 = Enables serial port and configures SCK, SDO, SDI and SS as serial port pins\n0 = Disables serial port and configures these pins as I/O port pins",
    "bit 4 CKP:\nClock Polarity Select bit\n- 1 = Idle state for clock is a high level\n0 = Idle state for clock is a low level",
    "bit 3-0 SSPM3:SSPM0: Master Synchronous Serial Port Mode Select bits\n(3)\n0101 = SPI Slave mode, clock = SCK pin, SS pin control disabled, SS can be used as I/O pin\n0100 = SPI Slave mode, clock = SCK pin, SS pin control enabled\n0011 = SPI Master mode, clock = TMR2 output/2\n0010 = SPI Master mode, clock = FOSC/64\n0001 = SPI Master mode, clock = FOSC/16\n0000 = SPI Master mode, clock = FOSC/4\nNote 1: In Master mode, the overflow bit is not set, since each new reception (and transmission) is initiated by writing to the SSPBUF register.\n2: When enabled, these pins must be properly configured as inputs or outputs.\n3: Bit combinations not specifically listed here are either reserved or implemented in I 2 CGLYPH<153> mode only.",
    "15.3.2 OPERATION\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control  bits  (SSPCON1<5:0>  and  SSPSTAT<7:6>). These control bits allow the following to be specified:\n- GLYPH<149> Master mode (SCK is the clock output)\nreading the data that was just received. Any write to the SSPBUF register during transmission/reception of data will  be  ignored  and  the  Write  Collision  Detect  bit, WCOL  (SSPCON1<7>),  will  be  set.  User  software must clear the WCOL bit so that it can be determined if the following write(s) to the SSPBUF register completed successfully.\nGLYPH<149> Slave mode (SCK is the clock input)\nGLYPH<149> Clock Polarity (Idle state of SCK)\nGLYPH<149> Data Input Sample Phase (middle or end of data output time)\nGLYPH<149> Clock Edge (output data on rising/falling edge of SCK)\nGLYPH<149> Clock Rate (Master mode only)\nGLYPH<149> Slave Select mode (Slave mode only)",
    "15.3.2 OPERATION\nThe MSSP consists of a Transmit/Receive Shift register  (SSPSR)  and  a  Buffer  register  (SSPBUF).  The SSPSR shifts the data in and out of the device, MSb first. The SSPBUF holds the data that was written to the SSPSR until the received data is ready. Once the 8 bits of data have been received, that byte is moved to the SSPBUF register. Then, the Buffer Full detect bit, BF (SSPSTAT<0>), and the interrupt flag bit, SSPIF, are set. This double-buffering of the received data (SSPBUF) allows the next byte to start reception before",
    "15.3.2 OPERATION\nWhen the application software is expecting to receive valid data, the SSPBUF should be read before the next byte of data to transfer is written to the SSPBUF. The Buffer  Full  bit,  BF  (SSPSTAT<0>),  indicates  when SSPBUF  has  been  loaded  with  the  received  data (transmission is complete). When the SSPBUF is read, the BF bit is cleared. This data may be irrelevant if the SPI is only a transmitter. Generally, the MSSP interrupt is used to determine when the transmission/reception has  completed.  The  SSPBUF  must  be  read  and/or written. If the interrupt method is not going to be used, then software polling can be done to ensure that a write collision  does  not  occur.  Example 15-1  shows  the loading of the SSPBUF (SSPSR) for data transmission.\nThe SSPSR is not directly readable or writable and can only be accessed by addressing the SSPBUF register. Additionally,  the  MSSP  Status  register  (SSPSTAT) indicates the various status conditions.",
    "EXAMPLE 15-1: LOADING THE SSPBUF (SSPSR) REGISTER\nLOOP, 1 = BTFSS. LOOP, 2 = SSPSTAT, BF. LOOP, 3 = ;Has data been received (transmit complete)?. , 1 = BRA. , 2 = LOOP. , 3 = ;No. , 1 = MOVF. , 2 = SSPBUF, W. , 3 = ;WREG reg = contents of SSPBUF. , 1 = MOVWF. , 2 = RXDATA. , 3 = ;Save in user RAM, if data is meaningful. , 1 = MOVF. , 2 = TXDATA, W. , 3 = ;W reg = contents of TXDATA. , 1 = MOVWF. , 2 = SSPBUF. , 3 = ;New data to xmit",
    "15.3.3 ENABLING SPI I/O\nTo  enable  the  serial  port,  MSSP  Enable  bit,  SSPEN (SSPCON1<5>), must be set. To reset or reconfigure SPI mode, clear the SSPEN  bit, reinitialize the SSPCONx registers and then set the SSPEN bit. This configures the SDI, SDO, SCK and SS pins as serial port pins. For the pins to behave as the serial port function,  some must have their data direction bits (in the TRIS register) appropriately programmed as follows:\nGLYPH<149> SDI is automatically controlled by the SPI module\nGLYPH<149> SDO must have TRISC<5> bit cleared\nGLYPH<149> SCK (Master mode) must have TRISC<3> bit cleared\nGLYPH<149> SCK (Slave mode) must have TRISC<3> bit set\nGLYPH<149> SS must have TRISF<7> bit set",
    "15.3.4 TYPICAL CONNECTION\nFigure 15-2 shows a typical connection between two microcontrollers. The  master controller (Processor 1) initiates the data transfer by sending the SCK signal. Data  is  shifted  out  of  both  shift  registers  on  their programmed clock edge and latched on the opposite edge of the clock. Both processors should be programmed to the same Clock Polarity (CKP), then both  controllers  would  send  and  receive  data  at  the same time. Whether the data is meaningful (or dummy data) depends on the application software. This leads to three scenarios for data transmission:\nGLYPH<149> Master sends data GLYPH<150> Slave sends dummy data\nGLYPH<149> Master sends data GLYPH<150> Slave sends data\nGLYPH<149> Master sends dummy data GLYPH<150> Slave sends data\nAny  serial  port  function  that  is  not  desired  may  be overridden  by  programming  the  corresponding  Data Direction (TRIS) register to the opposite value.",
    "15.3.5 MASTER MODE\nThe master can initiate the data transfer at any time because it controls the SCK. The master determines when  the  slave (Processor 2, Figure 15-2) is to broadcast data by the software protocol.\nIn  Master  mode,  the  data  is  transmitted/received  as soon as the SSPBUF register is written to. If the SPI is only  going  to receive,  the  SDO  output  could  be disabled (programmed as an input). The SSPSR register will continue to shift in the signal present on the SDI pin  at  the  programmed  clock  rate.  As  each  byte  is received, it will be loaded into the SSPBUF register as if  a  normal  received  byte  (interrupts  and  status  bits appropriately  set).  This  could  be  useful  in  receiver applications as a GLYPH<147>Line Activity MonitorGLYPH<148> mode.",
    "15.3.5 MASTER MODE\nThe clock polarity is selected by appropriately programming the CKP bit (SSPCON1<4>). This then, would  give  waveforms  for  SPI  communication,  as shown  in  Figure 15-3,  Figure 15-5  and  Figure 15-6, where the MSB is transmitted first. In Master mode, the SPI clock rate (bit rate) is user programmable to be one of the following:\nGLYPH<149> FOSC/4 (or TCY)\nGLYPH<149> FOSC/16 (or 4 GLYPH<149> T CY)\nGLYPH<149> FOSC/64 (or 16 GLYPH<149> T CY)\nGLYPH<149> Timer2 output/2\nThis  allows  a  maximum  data  rate  (at  40  MHz)  of 10.00 Mbps.\nFigure 15-3  shows  the  waveforms  for  Master  mode. When the CKE bit is set, the SDO data is valid before there is a clock edge on SCK. The change of the input sample is shown based on the state of the SMP bit. The time  when  the  SSPBUF  is  loaded  with  the  received data is shown.",
    "15.3.5 MASTER MODE\nFIGURE 15-3:\nSPI MODE WAVEFORM (MASTER MODE)",
    "15.3.6 SLAVE MODE\nIn Slave mode, the data is transmitted and received as the external clock pulses appear on SCK. When the last bit is latched, the SSPIF interrupt flag bit is set.\nWhile in Slave mode, the external clock is supplied by the external clock source on the SCK pin. This external clock must meet the minimum high and low times as specified in the electrical specifications.\nWhile in  Sleep  mode,  the  slave  can  transmit/receive data. When a byte is received, the device will wake-up from Sleep.",
    "15.3.7 SLAVE SELECT SYNCHRONIZATION\neven if in the middle of a transmitted byte and becomes a  floating  output.  External  pull-up/pull-down  resistors may be desirable depending on the application.\nNote 1: When the SPI is in Slave mode with SS pin control enabled (SSPCON<3:0> = 0100 ), the SPI module will reset if the SS pin is set to VDD.\n2: If the SPI is used in Slave mode with CKE set,  then  the  SS  pin  control  must  be enabled.\nWhen the SPI module resets, the bit counter is forced to GLYPH<145> 0 GLYPH<146>. This can be done by either forcing the SS pin to a high level or clearing the SSPEN bit.",
    "15.3.7 SLAVE SELECT SYNCHRONIZATION\nThe SS pin allows  a  Synchronous Slave mode.  The SPI must be in Slave mode with SS pin control enabled (SSPCON1<3:0> = 04h). The pin must not be driven low for the SS pin to function as an input. The data latch must be high. When the SS pin is low, transmission and reception are enabled and the SDO pin is driven. When the SS pin goes high, the SDO pin is no longer driven,\nTo emulate two-wire communication, the SDO pin can be connected to the SDI pin. When the SPI needs to operate as a receiver, the SDO pin can be configured as an input. This disables transmissions from the SDO. The SDI can always be left as an input (SDI function) since it cannot create a bus conflict.\nFIGURE 15-4: SLAVE SYNCHRONIZATION WAVEFORM",
    "PIC18F6390/6490/8390/8490\nFIGURE 15-5:",
    "SPI MODE WAVEFORM (SLAVE MODE WITH CKE = 0\n)\nFIGURE 15-6:\nSPI MODE WAVEFORM (SLAVE MODE WITH CKE =\n1\n)",
    "15.3.8 SLEEP OPERATION\nIn SPI Master mode, module clocks may be operating at a different speed than when in Full-Power mode; in the case of Sleep mode, all clocks are halted.\nIn most power-managed modes, a clock is provided to the peripherals. That clock should be from the primary clock source, the secondary clock (Timer1 oscillator at 32.768 kHz) or the INTOSC source. See Section 2.7 GLYPH<147>Clock Sources and Oscillator SwitchingGLYPH<148> for additional information.\nIn  most cases, the speed that the master clocks SPI data is not important; however, this should be evaluated for each system.\nIf MSSP interrupts are enabled, they can wake the controller from Sleep mode, or one of the Idle modes, when the  master  completes  sending  data.  If  an  exit  from Sleep  or  Idle  mode  is  not  desired,  MSSP  interrupts should be disabled.\nIf  the  Sleep  mode  is  selected,  all  module  clocks  are halted  and  the  transmission/reception  will  remain  in that  state  until  the  devices  wakes.  After  the  device returns to Run mode, the module will resume transmitting and receiving data.",
    "15.3.9 EFFECTS OF A RESET\nA Reset disables the MSSP module and terminates the current transfer.",
    "15.3.10 BUS MODE COMPATIBILITY\nTable 15-1 shows the compatibility between the standard  SPI  modes  and  the  states  of  the  CKP  and CKE control bits.",
    "TABLE 15-1: SPI BUS MODES\n0, 0, Control Bits State.CKP = 0. 0, 0, Control Bits State.CKE = 1. 0, 1, Control Bits State.CKP = 0. 0, 1, Control Bits State.CKE = 0. 1, 0, Control Bits State.CKP = 1. 1, 0, Control Bits State.CKE = 1. 1, 1, Control Bits State.CKP = 1. 1, 1, Control Bits State.CKE = 0\nThere is also an SMP bit which controls when the data is sampled.\nIn  SPI  Slave  mode,  the  SPI  Transmit/Receive  Shift register  operates  asynchronously  to  the  device.  This allows the device to be placed in any power-managed mode  and  data  to  be  shifted  into  the  SPI  Transmit/ Receive  Shift  register.  When  all  8  bits  have  been received, the MSSP interrupt flag bit will be set and if enabled, will wake the device.",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE.",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nPIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page = 61. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register.",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nTRISC, Bit 0 = PORTC Data Direction Register. TRISC, Reset Values on Page = 62. TRISF, Bit 7 = PORTF Data Direction Register. TRISF, Bit 6 = PORTF Data Direction Register. TRISF, Bit 5 = PORTF Data Direction Register. TRISF, Bit 4 = PORTF Data Direction Register. TRISF, Bit 3 = PORTF Data Direction Register. TRISF, Bit 2 = PORTF Data Direction Register. TRISF, Bit 1 = PORTF Data Direction Register. TRISF, Bit 0 = PORTF Data Direction Register. TRISF, Reset Values on Page = 62. SSPBUF, Bit 7 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = MSSP Receive Buffer/Transmit Register. SSPBUF,",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nBit 0 = MSSP Receive Buffer/Transmit Register. SSPBUF, Reset Values on Page = 60. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 = SSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3 = SSPM3. SSPCON1, Bit 2 = SSPM2. SSPCON1, Bit 1 = SSPM1. SSPCON1, Bit 0 = SSPM0. SSPCON1, Reset Values on Page = 60. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Reset Values on Page = 60",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used by the MSSP in SPI mode.",
    "15.4.1 REGISTERS\nThe MSSP module in I 2 C  mode  fully  implements  all master  and  slave  functions  (including  general  call support) and provides interrupts on Start and Stop bits in  hardware  to  determine  a  free  bus  (multi-master function). The MSSP module implements the standard mode  specifications, as well as 7-bit and  10-bit addressing.\nTwo pins are used for data transfer:\nGLYPH<149> Serial clock (SCL) GLYPH<150> RC3/SCK/SCL\nGLYPH<149> Serial data (SDA) GLYPH<150> RC4/SDI/SDA\nThe user must configure these pins as inputs by setting the TRISC<4:3> bits.",
    "(I 2 CGLYPH<153> MODE)\nThe MSSP module has six registers for I 2 C operation. These are:\nGLYPH<149> MSSP Control Register 1 (SSPCON1)\nGLYPH<149> MSSP Control Register 2 (SSPCON2)\nGLYPH<149> MSSP Status Register (SSPSTAT)\nGLYPH<149> Serial Receive/Transmit Buffer Register (SSPBUF)\nGLYPH<149> MSSP Shift Register (SSPSR) GLYPH<150> Not directly accessible\nGLYPH<149> MSSP Address Register (SSPADD)\nSSPCON1, SSPCON2  and  SSPSTAT  are  the  control and status registers in I 2 C mode  operation. The SSPCON1 and SSPCON2 registers are readable and writable. The lower 6 bits of the SSPSTAT are read-only. The upper 2 bits of the SSPSTAT are read/write.\nSSPSR is the shift register used for shifting data in or out. SSPBUF is the buffer register to which data bytes are written to, or read from.",
    "(I 2 CGLYPH<153> MODE)\nSSPADD  register  holds  the  slave  device  address when  the  MSSP  is  configured  in  I 2 C  Slave  mode. When  the  MSSP  is  configured  in  Master  mode,  the lower  7 bits of SSPADD  act  as  the  Baud  Rate Generator reload value.\nIn receive operations, SSPSR and SSPBUF together create a double-buffered receiver. When  SSPSR receives a complete byte, it is transferred to SSPBUF and the SSPIF interrupt is set.\nDuring  transmission,  the  SSPBUF  is  not  doublebuffered. A write to SSPBUF will write to both SSPBUF and SSPSR.\nbit 6",
    "REGISTER 15-3: SSPSTAT: MSSP STATUS REGISTER (I 2 CGLYPH<153> MODE)\nSMP, R/W-0 = CKE. SMP, R-0 = D/A. SMP, R-0 = P (1). SMP, R-0 = S (1). SMP, R-0 = R/W (2,3). SMP, R-0 = UA. SMP, R-0 = BF. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0",
    "REGISTER 15-3: SSPSTAT: MSSP STATUS REGISTER (I 2 CGLYPH<153> MODE)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 SMP:\nSlew Rate Control bit",
    "In Master or Slave mode:\n1 = Slew rate control disabled for Standard Speed mode (100 kHz and 1 MHz)\n0 = Slew rate control enabled for High-Speed mode (400 kHz)\nCKE:\nSMBus Select bit\n1 = Enable SMBus specific inputs\n0 = Disable SMBus specific inputs",
    "bit 5 D/A: Data/Address bit\nIn Master mode:",
    "In Slave mode:\n1 = Indicates that the last byte received or transmitted was data\n0 = Indicates that the last byte received or transmitted was address",
    "bit 4 P: Stop bit\n(1)\n1 = Indicates that a Stop bit has been detected last\n0 = Stop bit was not detected last\nS: Start bit (1)\n1 = Indicates that a Start bit has been detected last\n0 = Start bit was not detected last",
    "In Slave mode:\n1 = Read\n0 = Write",
    "In Master mode:\n1 = Transmit is in progress\n0 = Transmit is not in progress",
    "bit 1 UA: Update Address bit (10-Bit Slave mode only)\n1 = Indicates that the user needs to update the address in the SSPADD register\n0 = Address does not need to be updated",
    "In Transmit mode:\n1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty",
    "In Receive mode:\n1 = Data transmit in progress (does not include the ACK and Stop bits), SSPBUF is full\n0 = Data transmit complete (does not include the ACK and Stop bits), SSPBUF is empty\nNote 1: This bit is cleared on Reset and when SSPEN is cleared.\n2: This bit holds the R/W bit information following the last address match. This bit is only valid from the address match to the next Start bit, Stop bit or not ACK bit.\n3: ORing this bit with SEN, RSEN, PEN, RCEN or ACKEN will indicate if the MSSP is in Idle mode.",
    "REGISTER 15-4: SSPCON1: MSSP CONTROL REGISTER 1 (I 2 CGLYPH<153> MODE)\nWCOL, R/W-0 = SSPOV. WCOL, R/W-0 = SSPEN (1). WCOL, R/W-0 = CKP. WCOL, R/W-0 = SSPM3 (2). WCOL, R/W-0 = SSPM2 (2). WCOL, R/W-0 = SSPM1 (2). WCOL, R/W-0 = SSPM0 (2). bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 15-4: SSPCON1: MSSP CONTROL REGISTER 1 (I 2 CGLYPH<153> MODE)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 WCOL: Write Collision Detect bit\nIn Master Transmit mode:\n1 = A write  to  the  SSPxBUF  register  was  attempted  while  the  I 2 C  conditions  were  not  valid  for  a transmission to be started (must be cleared in software)\n0 = No collision",
    "In Slave Transmit mode:\n1 = The SSPxBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision\nIn Receive mode (Master or Slave modes):\nThis is a GLYPH<147>donGLYPH<146>t careGLYPH<148> bit.",
    "bit 6 SSPOV: Receive Overflow Indicator bit\nIn Receive mode:\n1 = A byte is received while the SSPxBUF register is still holding the previous byte (must be cleared in software)\n0 = No overflow",
    "In Transmit mode:\nThis is a GLYPH<147>donGLYPH<146>t careGLYPH<148> bit in Transmit mode.\nSSPEN:\nSynchronous Serial Port Enable bit\n(1)\n1 = Enables the serial port and configures the SDA and SCL pins as the serial port pins\n0 = Disables serial port and configures these pins as I/O port pins",
    "bit 4 CKP: SCK Release Control bit\nIn Slave mode:\n1 = Releases clock\n0 = Holds clock low (clock stretch), used to ensure data setup time\nIn Master mode:\nUnused in this mode.",
    "bit 3-0 SSPM3:SSPM0: Synchronous Serial Port Mode Select bits (2)\n1111 = I 2 C Slave mode, 10-bit address with Start and Stop bit interrupts enabled\n1110 = I 2 C Slave mode, 7-bit address with Start and Stop bit interrupts enabled\n1011 = I 2 C Firmware Controlled Master mode (Slave Idle)\n1000 = I 2 C Master mode, clock = FOSC/(4 * (SSPADD + 1))\n0111 = I 2 C Slave mode, 10-bit address\n0110 = I 2 C Slave mode, 7-bit address\nNote 1: When enabled, the SDA and SCL pins must be configured as inputs.\n2: Bit combinations not specifically listed here are either reserved or implemented in SPI mode only.\nbit 5\nbit 6\nbit 5\nbit 4\n- bit 1",
    "REGISTER 15-5: SSPCON2: MSSP CONTROL REGISTER 2 (I 2 CGLYPH<153> MODE)\nGCEN, R/W-0 = ACKSTAT. GCEN, R/W-0 = ACKDT (1). GCEN, R/W-0 = ACKEN (2). GCEN, R/W-0 = RCEN (2). GCEN, R/W-0 = PEN (2). GCEN, R/W-0 = RSEN (2). GCEN, R/W-0 = SEN (2). bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 15-5: SSPCON2: MSSP CONTROL REGISTER 2 (I 2 CGLYPH<153> MODE)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\n- bit 7\nGCEN: General Call Enable bit (Slave mode only)\n1 = Enable interrupt when a general call address (0000h) is received in the SSPSR\n0 = General call address disabled\nACKSTAT: Acknowledge Status bit (Master Transmit mode only)",
    "REGISTER 15-5: SSPCON2: MSSP CONTROL REGISTER 2 (I 2 CGLYPH<153> MODE)\n1 = Acknowledge was not received from slave\n0 = Acknowledge was received from slave\nACKDT: Acknowledge Data bit (Master Receive mode only) (1)\n1 = Not Acknowledge\n0 = Acknowledge\nACKEN: Acknowledge Sequence Enable bit (Master Receive mode only) (2)\n1 = Initiate Acknowledge sequence on SDA and SCL pins and transmit ACKDT data bit. Automatically cleared by hardware.\n0 = Acknowledge sequence Idle",
    "bit 3 RCEN: Receive Enable bit (Master mode only) (2)\n1 = Enables Receive mode for I 2 C\n0 = Receive Idle\nbit 2 PEN: Stop Condition Enable bit (Master mode only)\n(2)\n1 = Initiate Stop condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Stop condition Idle\nRSEN: Repeated Start Condition Enable bit (Master mode only) (2)\n1 = Initiate Repeated Start condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Repeated Start condition Idle\nSEN: Start Condition Enable/Stretch Enable bit (2)",
    "In Master mode:\n1 = Initiate Start condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Start condition Idle",
    "In Slave mode:\n1 = Clock stretching is enabled for both slave transmit and slave receive (stretch enabled)\n0 = Clock stretching is disabled\nNote 1: Value that will be transmitted when the user initiates an Acknowledge sequence at the end of a receive.\n2: If the I 2 C module is not in the Idle mode, these bits may not be set (no spooling) and the SSPBUF may not be written (or writes to the SSPBUF are disabled).",
    "15.4.3.1 Addressing\nThe  MSSP  module  functions  are  enabled  by  setting MSSP Enable bit, SSPEN (SSPCON1<5>).\nThe  SSPCON1  register  allows  control  of  the  I 2 C operation. Four mode selection bits (SSPCON1<3:0>) allow one of the following I 2 C modes to be selected:\nGLYPH<149> I 2 C Master mode, clock = (FOSC/4) x (SSPADD + 1)\nGLYPH<149> I 2 C Slave mode (7-bit address)\nGLYPH<149> I 2 C Slave mode (10-bit address)\nGLYPH<149> I 2 C Slave mode (7-bit address) with Start and Stop bit interrupts enabled\nGLYPH<149> I 2 C Slave mode (10-bit address) with Start and Stop bit interrupts enabled\nGLYPH<149> I 2 C Firmware Controlled Master mode, slave is Idle",
    "15.4.3.1 Addressing\nSelection  of  any  I 2 C  mode  with  the  SSPEN  bit  set, forces  the  SCL  and  SDA  pins  to  be  open-drain, provided  these  pins  are  programmed  to  inputs  by setting  the appropriate TRISC bits. To ensure proper operation  of  the  module,  pull-up  resistors  must  be provided externally to the SCL and SDA pins.",
    "15.4.3 SLAVE MODE\nIn Slave mode, the SCL and SDA pins must be configured as inputs (TRISC<4:3> set). The MSSP module will override the input state with the output data when required (slave-transmitter).\nThe I 2 C Slave mode hardware will always generate an interrupt  on  an  address  match.  Through  the  mode select  bits,  the  user  can  also  choose  to  interrupt  on Start and Stop bits\nWhen an address is matched, or the data transfer after an  address  match  is  received,  the  hardware  automatically will generate the Acknowledge (ACK) pulse and load the SSPBUF register with the received value currently in the SSPSR register.\nAny combination of the following conditions will cause the MSSP module not to give this ACK pulse:\nGLYPH<149> The Buffer Full bit, BF (SSPSTAT<0>), was set before the transfer was received.\nGLYPH<149> The overflow bit, SSPOV (SSPCON1<6>), was set before the transfer was received.",
    "15.4.3 SLAVE MODE\nIn  this  case,  the  SSPSR register value is not loaded into the SSPBUF, but the SSPIF bit (PIR1<3>) is set. The BF bit is cleared by reading the SSPBUF register, while bit SSPOV is cleared through software.\nThe SCL clock input must have a minimum high and low time for proper operation. The high and low times of the I 2 C specification, as well as the requirement of the MSSP module, are shown in timing parameter #100 and parameter #101.\nOnce the MSSP module has been enabled, it waits for a Start condition to occur. Following the Start condition, the  8  bits  are  shifted  into  the  SSPSR  register.  All incoming bits are sampled with the rising edge of the clock (SCL) line. The value of register SSPSR<7:1> is compared to the value of the  SSPADD register. The address is compared on the falling edge of the eighth clock (SCL) pulse. If the addresses match and the BF and SSPOV bits are clear, the following events occur:",
    "15.4.3 SLAVE MODE\n1. The  SSPSR  register  value  is  loaded  into  the SSPBUF register.\n2. The Buffer Full bit, BF, is set.\n3. An ACK pulse is generated.\n4. MSSP Interrupt  Flag  bit,  SSPIF  (PIR1<3>),  is set  (interrupt  is  generated,  if  enabled)  on  the falling edge of the ninth SCL pulse.\nIn 10-Bit Addressing mode, two address bytes need to be received by the slave. The five Most Significant bits (MSbs) of the first address byte specify if this is a 10-bit address. Bit R/W (SSPSTAT<2>) must specify a write so  the  slave  device  will  receive  the  second  address byte. For a 10-bit address, the first byte would equal GLYPH<145> 11110  A9  A8  0 GLYPH<146>, where  GLYPH<145> A9 GLYPH<146> and  GLYPH<145> A8 GLYPH<146> are  the two MSbs of the address. The sequence of events for 10-Bit  Addressing  mode  is  as  follows,  with  steps  7 through 9 for the slave-transmitter:",
    "15.4.3 SLAVE MODE\n1. Receive first (high) byte of address (bits SSPIF, BF and UA (SSPSTAT<1>) are set).\n2. Update the SSPADD register with second (low) byte of address (clears bit UA and releases the SCL line).\n3. Read the SSPBUF register (clears bit, BF) and clear flag bit, SSPIF.\n4. Receive  second  (low)  byte  of  address  (bits SSPIF, BF and UA are set).\n5. Update the SSPADD register with the first (high) byte of address. If match releases SCL line, this will clear bit, UA.\n6. Read the SSPBUF register (clears bit, BF) and clear flag bit, SSPIF.\n7. Receive Repeated Start condition.\n8. Receive first (high) byte of address (SSPIF and BF bits are set).\n9. Read the SSPBUF register (clears bit, BF) and clear flag bit, SSPIF.",
    "15.4.3.3 Transmission\nWhen the R/W bit of the address byte is clear and an address  match  occurs,  the  R/W  bit  of  the  SSPSTAT register is cleared. The received address is loaded into the  SSPBUF  register  and  the  SDA  line  is  held  low (ACK).\nWhen the address byte overflow condition exists, then the no Acknowledge (ACK) pulse is given. An overflow condition is defined as either bit BF (SSPSTAT<0>) is set, or bit SSPOV (SSPCON1<6>) is set.\nAn MSSP interrupt is generated for each data transfer byte.  Flag  bit,  SSPIF  (PIR1<3>),  must  be  cleared  in software. The SSPSTAT register is used to determine the status of the byte.\nIf SEN is enabled (SSPCON2<0> = 1 ), RC3/SCK/SCL will  be  held  low  (clock  stretch)  following  each  data transfer.  The  clock  must  be  released  by  setting  bit CKP  (SSPCON1<4>).  See Section 15.4.4  GLYPH<147>Clock StretchingGLYPH<148> for more detail.",
    "15.4.3.3 Transmission\nWhen the R/W bit of the incoming address byte is set and  an  address  match  occurs,  the  R/W  bit  of  the SSPSTAT  register  is  set.  The  received  address  is loaded into the SSPBUF register. The ACK pulse will be sent on the ninth bit and pin RC3/SCK/SCL is held low  regardless  of  SEN  (see Section 15.4.4  GLYPH<147>Clock StretchingGLYPH<148> for  more detail). By stretching the clock, the master will be unable to assert another clock pulse until the slave is done preparing the transmit data. The transmit data must be loaded into the SSPBUF register which also loads the SSPSR register. Then, pin RC3/ SCK/SCL  should  be  enabled  by  setting  bit,  CKP (SSPCON1<4>). The 8 data bits are shifted out on the falling  edge  of  the  SCL  input.  This  ensures  that  the SDA  signal is valid during the SCL  high time (Figure 15-9).",
    "15.4.3.3 Transmission\nThe ACK pulse from the master-receiver is latched on the rising edge of the ninth SCL input pulse. If the SDA line is high  (not  ACK),  then  the  data  transfer  is complete. In this case, when the ACK is latched by the slave, the slave logic is reset and the slave monitors for another occurrence of the Start bit. If the SDA line was low (ACK), the next transmit data must be loaded into the SSPBUF register. Again, pin RC3/SCK/SCL must be enabled by setting bit CKP.\nAn MSSP interrupt is generated for each data transfer byte. The SSPIF bit must be cleared in software and the SSPSTAT register is used to determine the status of the byte. The SSPIF bit is set on the falling edge of the ninth clock pulse.",
    "15.4.4 CLOCK STRETCHING\nBoth 7 and 10-Bit Slave modes implement automatic clock stretching during a transmit sequence.",
    "15.4.4.3 Clock Stretching for 7-Bit Slave Transmit Mode\nThe SEN bit (SSPCON2<0>) allows clock stretching to be  enabled  during  receives.  Setting  SEN  will  cause the  SCL  pin  to  be  held  low  at  the  end  of  each  data receive sequence.",
    "15.4.4.1 Clock Stretching for 7-Bit Slave Receive Mode (SEN = 1 )\nIn 7-Bit Slave Receive mode, on the falling edge of the ninth clock at the end of the ACK sequence, if the BF bit  is  set,  the  CKP  bit  in  the  SSPCON1  register  is automatically  cleared,  forcing  the  SCL  output  to  be held low. The CKP being cleared to GLYPH<145> 0 GLYPH<146> will assert the SCL line low. The CKP bit must be set in the userGLYPH<146>s ISR before reception is allowed to continue. By holding the SCL line low, the user has time to service the ISR and  read  the  contents  of  the  SSPBUF  before  the master device can initiate another receive sequence. This  will  prevent  buffer  overruns  from  occurring  (see Figure 15-13).",
    "15.4.4.1 Clock Stretching for 7-Bit Slave Receive Mode (SEN = 1 )\nNote 1: If the  user  reads  the  contents  of  the SSPBUF  before  the  falling  edge  of  the ninth clock, thus clearing the BF bit, the CKP  bit  will  not  be  cleared  and  clock stretching will not occur.\n2: The  CKP  bit  can  be  set  in  software regardless of the state of the BF bit. The user should be careful to clear the BF bit in the ISR before the next receive sequence in order to prevent an overflow condition.",
    "15.4.4.2 Clock Stretching for 10-Bit Slave Receive Mode (SEN = 1 )\nIn  10-Bit  Slave  Receive  mode  during  the  address sequence,  clock  stretching  automatically  takes  place but CKP is not cleared. During this time, if the UA bit is set  after  the  ninth  clock,  clock  stretching  is  initiated. The UA bit is set after receiving the upper byte of the 10-bit address and following the receive of the second byte of the 10-bit address with the R/W bit cleared to GLYPH<145> 0 GLYPH<146>. The release of the clock line occurs upon updating SSPADD.  Clock  stretching  will  occur  on  each  data receive sequence as described in 7-bit mode.",
    "Note:\nIf the user polls the UA bit and clears it by updating the SSPADD register before the falling edge of the ninth clock occurs and if the user hasnGLYPH<146>t cleared the BF bit by reading the SSPBUF register before that time, then the CKP bit will still NOT be asserted low.  Clock  stretching  on  the  basis  of  the state  of  the  BF  bit  only  occurs  during  a data sequence, not an address sequence.\n7-Bit Slave Transmit mode implements clock stretching by clearing the CKP bit after the falling edge of the ninth clock, if the BF bit is clear. This occurs regardless of the state of the SEN bit.\nThe userGLYPH<146>s ISR must set the CKP bit before transmission  is  allowed  to  continue.  By  holding  the  SCL  line low, the user has time to service the ISR and load the contents of the SSPBUF before the master device can initiate another transmit sequence (see Figure 15-9).",
    "Note:\nNote 1: If the user loads the contents of SSPBUF, setting the BF bit before the falling edge of the  ninth  clock,  the  CKP  bit  will  not  be cleared and clock stretching will not occur.\n2: The  CKP  bit  can  be  set  in  software regardless of the state of the BF bit.",
    "15.4.4.4 Clock Stretching for 10-Bit Slave Transmit Mode\nIn  10-Bit  Slave  Transmit  mode,  clock  stretching  is controlled during the first two address sequences by the  state  of  the  UA  bit,  just  as  it  is  in  10-Bit  Slave Receive  mode. The  first  two  addresses  are  followed by a third address sequence which contains the highorder bits of the 10-bit address and the R/W bit set to GLYPH<145> 1 GLYPH<146>.  After the third address sequence is performed, the UA  bit  is  not  set,  the  module  is  now  configured  in Transmit  mode  and  clock  stretching  is  controlled  by the  BF  flag  as  in  7-Bit  Slave  Transmit  mode  (see Figure 15-11).",
    "15.4.4.5 Clock Synchronization and the CKP bit\nWhen the CKP bit is cleared, the SCL output is forced to GLYPH<145> 0 GLYPH<146>.  However, setting the CKP bit will not assert the SCL output low until the SCL output is already sampled  low.  Therefore,  the  CKP  bit  will  not  assert  the SCL  line  until  an  external  I 2 C  master  device  has already  asserted  the  SCL  line.  The  SCL  output  will remain  low  until  the  CKP  bit  is  set  and  all  other devices  on  the  I 2 C  bus  have  deasserted  SCL.  This ensures that a write to the CKP bit will not violate the minimum high time requirement for SCL (see Figure 15-12).\nFIGURE 15-12: CLOCK SYNCHRONIZATION TIMING",
    "15.4.5 GENERAL CALL ADDRESS SUPPORT\nThe addressing procedure for the I 2 C bus is such that the  first  byte  after  the  Start  condition  usually  determines which device will be the slave addressed by the master. The exception is the general call address which can address all devices. When this address is used, all devices should, in theory, respond with an Acknowledge.\nThe  general  call  address  is  one  of  eight  addresses reserved for specific purposes by the I 2 C protocol. It consists of all GLYPH<145> 0 GLYPH<146> s with R/W = 0 .\nThe  general  call  address  is  recognized  when  the General Call Enable bit (GCEN) is enabled (SSPCON2<7> set). Following a Start bit detect, 8 bits are shifted into the SSPSR  and  the  address  is compared against the SSPADD. It is also compared to the general call address and fixed in hardware.\nIf  the  general  call  address  matches,  the  SSPSR  is transferred to the SSPBUF, the BF flag bit is set (eighth bit) and on the falling edge of the ninth bit (ACK bit), the SSPIF interrupt flag bit is set.",
    "15.4.5 GENERAL CALL ADDRESS SUPPORT\nWhen the interrupt is serviced, the source for the interrupt  can  be  checked  by  reading  the  contents  of  the SSPBUF. The value can be used to determine if the address was device specific or a general call address.\nIn 10-bit mode, the SSPADD is required to be updated for the second half of the address to match and the UA bit is set (SSPSTAT<1>). If the general call address is sampled when the GCEN bit is set, while the slave is configured in 10-Bit Addressing mode, then the second half of the address is not necessary, the UA bit will not be set and the slave will begin receiving data after the Acknowledge (Figure 15-15).",
    "15.4.6 MASTER MODE\nMaster  mode  is  enabled  by  setting  and  clearing  the appropriate SSPM bits in SSPCON1 and by setting the SSPEN bit. In Master mode, the SCL and SDA lines are manipulated by the MSSP hardware.\nMaster  mode  of  operation  is  supported  by  interrupt generation  on  the  detection  of  the  Start  and  Stop conditions. The Stop (P) and Start (S) bits are cleared from a Reset or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set or the bus is Idle, with both the S and P bits clear.\nIn Firmware  Controlled Master mode,  user  code conducts  all  I 2 C  bus  operations  based  on  Start  and Stop bit conditions.\nOnce  Master  mode  is  enabled,  the  user  has  six options.\n1. Assert a Start condition on SDA and SCL.\n2. Assert a Repeated Start condition on SDA and SCL.\n3. Write to the SSPBUF register initiating transmission of data/address.\n4. Configure the I 2 C port to receive data.\n5. Generate an Acknowledge condition at the end of a received byte of data.\n6. Generate a Stop condition on SDA and SCL.",
    "Note:\nThe  MSSP  module,  when  configured  in I 2 C Master mode, does not allow queueing of  events.  For  instance,  the  user  is  not allowed  to  initiate  a  Start  condition  and immediately write the SSPBUF register to initiate transmission before the Start condition is complete. In this case, the SSPBUF will not be written to and the WCOL bit will be  set, indicating that a write to the SSPBUF did not occur.\nThe  following  events  will  cause  the  MSSP  Interrupt Flag bit, SSPIF, to be set (MSSP interrupt, if enabled):\nGLYPH<149> Start condition\nGLYPH<149> Stop condition\nGLYPH<149> Data transfer byte transmitted/received\nGLYPH<149> Acknowledge transmit\nGLYPH<149> Repeated Start",
    "15.4.6.1 I 2 C Master Mode Operation\nA typical transmit sequence would go as follows:\nThe  master  device  generates  all  of  the  serial  clock pulses and the Start and Stop conditions.   A transfer is ended with a Stop condition or with a Repeated Start condition.  Since the Repeated Start condition is also the beginning of the next serial transfer, the I 2 C bus will not be released.\nIn Master  Transmitter  mode,  serial  data  is  output through SDA, while SCL outputs the serial clock. The first byte transmitted contains the slave address of the receiving device (7 bits) and the Read/Write (R/W) bit. In this case, the R/W bit will be logic GLYPH<145> 0 GLYPH<146> .  Serial data is transmitted 8 bits at a time. After each byte is transmitted,  an  Acknowledge  bit  is  received.  Start  and  Stop conditions are output to indicate the beginning and the end of a serial transfer.",
    "15.4.6.1 I 2 C Master Mode Operation\nIn  Master  Receive  mode,  the  first  byte  transmitted contains the slave address of the transmitting device (7 bits) and the R/W bit. In this case, the R/W bit will be logic GLYPH<145> 1 GLYPH<146>. Thus, the first byte transmitted is a 7-bit slave address, followed by a GLYPH<145> 1 GLYPH<146> to indicate the receive bit. Serial data is received via SDA, while SCL outputs the serial clock. Serial data is received 8 bits at a time. After each byte is received, an Acknowledge bit is transmitted.  Start  and  Stop  conditions  indicate  the  beginning and end of transmission.\nThe  Baud  Rate  Generator  used  for  the  SPI  mode operation is used to set the SCL clock frequency for either 100 kHz, 400 kHz or 1 MHz I 2 C operation. See Section 15.4.7 GLYPH<147>Baud RateGLYPH<148> for more detail.",
    "15.4.6.1 I 2 C Master Mode Operation\n1. The user generates a Start condition by setting the Start Enable bit, SEN (SSPCON2<0>).\n2. SSPIF is set. The MSSP module will wait the required  start  time  before  any  other  operation takes place.\n3. The  user  loads  the  SSPBUF  with  the  slave address to transmit.\n4. Address is shifted out the SDA pin until all 8 bits are transmitted.\n5. The MSSP module shifts in the ACK bit from the slave device and  writes its value into the SSPCON2 register (SSPCON2<6>).\n6. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.\n7. The user loads the SSPBUF with 8 bits of data.\n8. Data is shifted out the SDA pin until all 8 bits are transmitted.\n9. The MSSP module shifts in the ACK bit from the slave device and  writes its value into the SSPCON2 register (SSPCON2<6>).\n10. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.",
    "15.4.6.1 I 2 C Master Mode Operation\n11. The user generates a Stop condition by setting the Stop Enable bit, PEN (SSPCON2<2>).\n12. Interrupt is generated once the Stop condition is complete.",
    "15.4.7 BAUD RATE\nIn I 2 C Master mode, the Baud Rate Generator (BRG) reload  value  is  placed  in  the  lower  7  bits  of  the SSPADD register (Figure 15-17). When a write occurs to SSPBUF, the Baud Rate Generator will automatically begin counting. The BRG counts down to 0 and stops until another reload has taken place. The BRG count is decremented twice per instruction cycle (TCY) on the Q2 and Q4 clocks. In I 2 C  Master  mode,  the  BRG  is reloaded automatically.\nOnce the given operation is complete (i.e., transmission of the last data bit is followed by ACK), the internal clock will automatically stop counting and the SCL pin will remain in its last state.\nTable 15-3 demonstrates clock rates based on instruction  cycles  and  the  BRG  value  loaded  into SSPADD.",
    "TABLE 15-3: I 2 CGLYPH<153> CLOCK RATE w/BRG\n10 MHz, FCY * 2 = 20 MHz. 10 MHz, BRG Value = 19h. 10 MHz, FSCL (2 Rollovers of BRG) = 400 kHz (1). 10 MHz, FCY * 2 = 20 MHz. 10 MHz, BRG Value = 20h. 10 MHz, FSCL (2 Rollovers of BRG) = 312.5 kHz. 10 MHz, FCY * 2 = 20 MHz. 10 MHz, BRG Value = 3Fh. 10 MHz, FSCL (2 Rollovers of BRG) = 100 kHz. 4 MHz, FCY * 2 = 8 MHz. 4 MHz, BRG Value = 0Ah. 4 MHz, FSCL (2 Rollovers of BRG) = 400 kHz (1). 4 MHz, FCY * 2 = 8 MHz. 4 MHz, BRG Value = 0Dh. 4 MHz, FSCL (2 Rollovers of BRG) = 308 kHz. 4 MHz, FCY * 2 = 8 MHz. 4 MHz, BRG Value = 28h. 4 MHz, FSCL (2 Rollovers of",
    "TABLE 15-3: I 2 CGLYPH<153> CLOCK RATE w/BRG\nBRG) = 100 kHz. 1 MHz, FCY * 2 = 2 MHz. 1 MHz, BRG Value = 03h. 1 MHz, FSCL (2 Rollovers of BRG) = 333 kHz (1). 1 MHz, FCY * 2 = 2 MHz. 1 MHz, BRG Value = 0Ah. 1 MHz, FSCL (2 Rollovers of BRG) = 100 kHz. 1 MHz, FCY * 2 = 2 MHz. 1 MHz, BRG Value = 00h. 1 MHz, FSCL (2 Rollovers of BRG) = 1 MHz (1)\nNote 1: The I 2 C interface does not conform to the 400 kHz I 2 C specification (which applies to rates greater than 100 kHz) in all details, but may be used with care where higher rates are required by the application.",
    "15.4.7.1 Clock Arbitration\nClock arbitration occurs when the master, during any receive,  transmit  or  Repeated  Start/Stop  condition, deasserts  the  SCL  pin  (SCL  allowed  to  float  high). When the SCL pin is allowed to float high, the Baud Rate  Generator  (BRG)  is  suspended  from  counting until the SCL pin is actually sampled high. When the\nSCL pin is sampled high, the Baud Rate Generator is reloaded  with  the  contents  of  SSPADD<6:0>  and begins counting. This ensures that the SCL high time will always be at least one BRG rollover count in the event that the clock is held low by an external device (Figure 15-18).",
    "15.4.8 I 2 C MASTER MODE START CONDITION TIMING\nTo  initiate  a  Start  condition,  the  user  sets  the  Start Condition Enable bit, SEN (SSPCON2<0>). If the SDA and SCL pins are sampled high, the Baud Rate Generator  is  reloaded  with  the  contents  of  SSPADD<6:0> and starts its count. If SCL and SDA are both sampled high when the Baud Rate Generator times out (TBRG), the SDA pin is driven low. The action of the SDA being driven low while SCL is high is the Start condition and causes the S bit (SSPSTAT<3>) to be set. Following this,  the  Baud  Rate  Generator  is  reloaded  with  the contents  of  SSPADD<6:0>  and  resumes  its  count. When the Baud Rate Generator times out (TBRG), the SEN bit (SSPCON2<0>) will be automatically cleared by hardware, the Baud Rate Generator is suspended, leaving the SDA line held low and the Start condition is complete.\nNote:",
    "15.4.8 I 2 C MASTER MODE START CONDITION TIMING\nIf  at  the  beginning  of  the  Start  condition, the SDA and SCL pins are already sampled low, or if during the Start condition, the SCL line is sampled low before the SDA line  is  driven  low,  a  bus  collision  occurs, the Bus Collision Interrupt Flag, BCLIF, is set, the Start condition is aborted and the I 2 C module is reset into its Idle state.",
    "15.4.8.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Start sequence is in progress, the WCOL is set and the contents of the buffer are unchanged (the write doesnGLYPH<146>t occur).\nNote:\nBecause queueing of events is not allowed,  writing  to  the  lower  5  bits  of SSPCON2  is  disabled until the Start condition is complete.",
    "15.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\n- Note 1: If  RSEN is programmed while any other event is in progress, it will not take effect.",
    "15.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nA Repeated Start condition occurs when the RSEN bit (SSPCON2<1>) is programmed high and the I 2 C logic module is in the Idle state. When the RSEN bit is set, the  SCL  pin  is  asserted  low.  When  the  SCL  pin  is sampled low, the Baud Rate Generator is loaded with the  contents  of  SSPADD<5:0>  and  begins  counting. The SDA pin is released (brought high) for one Baud Rate  Generator  count  (TBRG).  When  the  Baud  Rate Generator times out, if SDA is sampled high, the SCL pin  will  be  deasserted  (brought  high).  When  SCL  is sampled high,  the  Baud  Rate  Generator  is  reloaded with the contents of SSPADD<6:0> and begins counting. SDA and SCL must be sampled high for one TBRG. This action is then followed by assertion of the SDA pin (SDA = 0 ) for one TBRG while SCL is high. Following this, the RSEN bit (SSPCON2<1>) will be automatically cleared  and  the  Baud  Rate  Generator  will  not",
    "15.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nbe reloaded, leaving the SDA pin held low. As soon as a Start condition is detected on the SDA and SCL pins, the S bit (SSPSTAT<3>) will be set. The SSPIF bit will not be set until the Baud Rate Generator has timed out.\n2: A bus collision during the Repeated Start condition occurs if:\nGLYPH<149> SDA is sampled low when SCL goes from low-to-high.\nGLYPH<149> SCL goes low before SDA is asserted low. This may indicate that another master is attempting to transmit a data GLYPH<145> 1 GLYPH<146> .\nImmediately following the SSPIF bit getting set, the user may write the SSPBUF with the 7-bit address in 7-bit mode, or the default first address in 10-bit mode. After the first 8 bits are transmitted and an ACK is received, the  user  may  then  transmit  an  additional  eight  bits  of address (10-bit mode) or 8 bits of data (7-bit mode).",
    "15.4.9.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Repeated Start sequence  is  in  progress,  the  WCOL  is  set  and  the contents of the buffer are unchanged (the write doesnGLYPH<146>t occur).\nNote:\nBecause queueing of events is not allowed,  writing  of  the  lower  5  bits  of SSPCON2 is disabled until the Repeated Start condition is complete.",
    "15.4.10 I 2 C MASTER MODE TRANSMISSION\nTransmission  of  a  data  byte,  a  7-bit  address  or  the other half of a 10-bit address is accomplished by simply writing a value to the SSPBUF register. This action will set the Buffer Full flag bit, BF, and allow the Baud Rate Generator to begin counting and start the next transmission.  Each  bit  of  address/data  will  be  shifted  out onto  the  SDA  pin  after  the  falling  edge  of  SCL  is asserted (see data hold time specification  parameter #106). SCL is held low for one Baud Rate Generator rollover count (TBRG). Data should be valid before SCL is  released  high  (see  data  setup  time  specification parameter #107). When the SCL pin is released high, it is  held  that  way  for  TBRG.  The  data  on  the  SDA  pin must  remain  stable  for  that  duration  and  some  hold time after the next falling edge of SCL. After the eighth bit is shifted out (the falling edge of the eighth clock), the BF flag is cleared and the master releases SDA. This  allows  the  slave  device  being  addressed  to respond with an ACK bit during the ninth bit time if an address  match  occurred,  or  if  data  was",
    "15.4.10 I 2 C MASTER MODE TRANSMISSION\nreceived properly. The status of ACK is written into the ACKDT bit on the falling edge of the ninth clock. If the master receives an Acknowledge, the Acknowledge Status bit, ACKSTAT, is cleared. If not, the bit is set. After the ninth clock, the SSPIF bit is set and the master clock (Baud Rate Generator) is suspended until the next data byte is loaded into the SSPBUF, leaving SCL low and SDA unchanged (Figure 15-21).",
    "15.4.10 I 2 C MASTER MODE TRANSMISSION\nAfter the write to the SSPBUF, each bit of address will be  shifted  out  on  the  falling  edge  of  SCL  until  all 7 address bits and the R/W bit are completed. On the falling edge of the eighth clock, the master will deassert the  SDA  pin,  allowing  the  slave  to  respond  with  an Acknowledge. On the falling edge of the ninth clock, the master will sample the SDA pin to see if the address was recognized by a slave. The status of the ACK bit is loaded into the ACKSTAT status bit (SSPCON2<6>). Following the falling edge of the ninth clock transmission of the address, the SSPIF is set, the BF flag is cleared and the Baud Rate Generator is turned off until another write to the SSPBUF takes place, holding SCL low and allowing SDA to float.",
    "15.4.10.1 BF Status Flag\nIn  Transmit  mode,  the  BF  bit  (SSPSTAT<0>)  is  set when the CPU writes to SSPBUF and is cleared when all 8 bits are shifted out.",
    "15.4.10.2 WCOL Status Flag\nIf  the  user  writes  the  SSPBUF  when  a  transmit  is already in progress (i.e., SSPSR is still shifting out a data byte), the WCOL is set and the contents of the buffer are unchanged (the write doesnGLYPH<146>t occur).\nWCOL must be cleared in software.",
    "15.4.10.3 ACKSTAT Status Flag\nIn Transmit mode, the ACKSTAT bit (SSPCON2<6>) is cleared  when  the  slave  has  sent  an  Acknowledge (ACK = 0 ) and is set when the slave does not Acknowledge (ACK = 1 ). A slave sends an Acknowledge when it has recognized its address (including a general call), or when the slave has properly received its data.",
    "15.4.11 I 2 C MASTER MODE RECEPTION\nMaster mode reception is enabled by programming the Receive Enable bit, RCEN (SSPCON2<3>).\nNote:\nThe MSSP module must be in an Idle state before the RCEN bit is set or the RCEN bit will be disregarded.\nThe Baud Rate Generator begins counting and on each rollover, the state of the SCL pin changes (high-to-low/ low-to-high) and data is shifted into the SSPSR. After the falling edge of the eighth clock, the receive enable flag is automatically  cleared,  the  contents  of  the SSPSR are loaded into the SSPBUF, the BF flag bit is set,  the  SSPIF  flag  bit  is  set  and  the  Baud  Rate Generator  is  suspended  from  counting,  holding  SCL low. The MSSP is now in Idle state awaiting the next command. When the buffer is read by the CPU, the BF flag  bit  is  automatically  cleared.  The  user  can  then send an Acknowledge bit at the end of reception by setting the Acknowledge Sequence Enable bit, ACKEN (SSPCON2<4>).",
    "15.4.11.1 BF Status Flag\nIn receive operation, the BF bit is set when an address or data byte is loaded into SSPBUF from SSPSR. It is cleared when the SSPBUF register is read.",
    "15.4.11.2 SSPOV Status Flag\nIn receive operation, the SSPOV bit is set when 8 bits are  received  into  the  SSPSR  and  the  BF  flag  bit  is already set from a previous reception.",
    "15.4.11.3 WCOL Status Flag\nIf the  user  writes  the  SSPBUF  when  a  receive  is already in progress (i.e., SSPSR is still shifting in a data byte), the WCOL bit is set and the contents of the buffer are unchanged (the write doesnGLYPH<146>t occur).",
    "15.4.13 STOP CONDITION TIMING\nAn  Acknowledge  sequence  is  enabled  by  setting  the Acknowledge Sequence Enable bit, ACKEN (SSPCON2<4>). When this  bit  is  set,  the  SCL  pin  is pulled low and the contents of the Acknowledge data bit are presented on the SDA pin. If the user wishes to generate an Acknowledge, then the ACKDT bit should be cleared. If not, the user should set the ACKDT bit before starting  an  Acknowledge  sequence.  The  Baud  Rate Generator  then  counts  for  one  rollover  period  (TBRG) and the SCL pin is deasserted (pulled high). When the SCL pin is  sampled high (clock  arbitration),  the  Baud Rate Generator counts for TBRG. The SCL pin is then pulled low. Following this, the ACKEN bit is automatically cleared, the Baud Rate Generator is turned off and the MSSP module then goes into Idle mode (Figure 15-23).",
    "15.4.12.1 WCOL Status Flag\nIf the user writes the SSPBUF when an Acknowledge sequence is  in  progress,  then  WCOL  is  set  and  the contents of the buffer are unchanged (the write doesnGLYPH<146>t occur).",
    "15.4.12.1 WCOL Status Flag\nA Stop bit is asserted on the SDA pin at the end of a receive/transmit by setting the Stop Sequence Enable bit,  PEN  (SSPCON2<2>).  At  the  end  of  a  receive/ transmit, the SCL line is held low after the falling edge of the ninth clock. When the PEN bit is set, the master will  assert  the  SDA  line  low.  When  the  SDA  line  is sampled low, the Baud Rate Generator is reloaded and counts  down  to  GLYPH<145> 0 GLYPH<146>. When the  Baud  Rate  Generator times out, the SCL pin will  be brought  high  and one TBRG (Baud Rate Generator rollover count) later, the SDA pin will be deasserted. When the SDA pin is sampled high while SCL is high, the P bit (SSPSTAT<4>) is set. A TBRG later, the PEN bit is cleared and the SSPIF bit is set (Figure 15-24).",
    "15.4.13.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Stop sequence is  in  progress,  then  the  WCOL  bit  is  set  and  the contents of the buffer are unchanged (the write doesnGLYPH<146>t occur).",
    "15.4.14 SLEEP OPERATION\nWhile  in  Sleep  mode,  the  I 2 C  module  can  receive addresses  or  data  and  when  an  address  match  or complete  byte  transfer  occurs,  wake  the  processor from Sleep (if the MSSP interrupt is enabled).",
    "15.4.15 EFFECT OF A RESET\nA Reset disables the MSSP module and terminates the current transfer.",
    "15.4.16 MULTI-MASTER MODE\nIn Multi-Master mode, the interrupt generation on the detection of the  Start  and  Stop  conditions  allows  the determination of when the bus is free. The Stop (P) and Start  (S)  bits  are  cleared  from  a  Reset  or  when  the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit (SSPSTAT<4>) is set, or the bus is Idle, with both the S and P bits clear. When the bus is busy, enabling the MSSP interrupt will generate the interrupt when the Stop condition occurs.\nIn multi-master  operation,  the  SDA  line  must  be monitored for arbitration to see if the signal level is the expected  output  level.  This  check  is  performed  in hardware with the result placed in the BCLIF bit.\nThe states where arbitration can be lost are:\nGLYPH<149> Address Transfer\nGLYPH<149> Data Transfer\nGLYPH<149> A Start Condition\nGLYPH<149> A Repeated Start Condition\nGLYPH<149> An Acknowledge Condition",
    "15.4.17 MULTI-MASTER COMMUNICATION, BUS COLLISION AND BUS ARBITRATION\nMulti-Master mode support is achieved by bus arbitration. When the master outputs address/data bits onto the SDA pin, arbitration takes place when the master outputs  a  GLYPH<145> 1 GLYPH<146> on  SDA,  by  letting  SDA  float  high  and another master asserts a GLYPH<145> 0 GLYPH<146>.  When the SCL pin floats high,  data  should  be  stable.  If  the  expected  data  on SDA is a GLYPH<145> 1 GLYPH<146> and the data sampled on the SDA pin = 0 , then a bus collision has taken place. The master will set the Bus Collision Interrupt Flag, BCLIF and reset the I 2 C port to its Idle state (Figure 15-25).\nIf  a  transmit  was  in  progress  when  the  bus  collision occurred,  the  transmission  is  halted,  the  BF  flag  is cleared, the SDA and SCL lines are deasserted and the SSPBUF can be written to. When the user services the bus collision  Interrupt  Service  Routine  and  if  the  I 2 C bus  is  free,  the  user  can  resume  communication  by asserting a Start condition.",
    "15.4.17 MULTI-MASTER COMMUNICATION, BUS COLLISION AND BUS ARBITRATION\nIf a Start, Repeated  Start, Stop or Acknowledge condition was  in progress  when  the  bus  collision occurred,  the  condition  is  aborted,  the  SDA  and  SCL lines are deasserted and the respective control bits in the SSPCON2 register are cleared. When the user services the bus collision Interrupt Service Routine and if the I 2 C bus is free, the user can resume communication by asserting a Start condition.\nThe master will continue to monitor the SDA and SCL pins. If a Stop condition occurs, the SSPIF bit will be set.\nA write  to  the  SSPBUF  will  start  the  transmission  of data  at  the  first  data  bit,  regardless  of  where  the transmitter left off when the bus collision occurred.\nIn Multi-Master mode, the interrupt generation on the detection of Start and Stop conditions allows the determination of when the bus is free. Control of the I 2 C bus can be taken when the P bit is  set  in  the  SSPSTAT register,  or  the  bus  is  Idle  and  the  S  and  P  bits  are cleared.",
    "15.4.17.1 Bus Collision During a Start Condition\nDuring a Start condition, a bus collision occurs if:\na) SDA or SCL are sampled low at the beginning of the Start condition (Figure 15-26).\nb) SCL is sampled low before SDA is asserted low (Figure 15-27).\nIf  the  SDA  pin  is  sampled  low  during  this  count,  the BRG  is  reset  and  the  SDA  line  is  asserted  early (Figure 15-28). If, however, a GLYPH<145> 1 GLYPH<146> is sampled on the SDA pin, the SDA pin is asserted low at the end of the BRG count. The Baud Rate Generator is then reloaded and counts down to 0 and during this time, if the SCL pins are sampled as GLYPH<145> 0 GLYPH<146>, a bus collision does not occur. At the end of the BRG count, the SCL pin is asserted low.\nDuring a Start  condition,  both the  SDA  and the  SCL pins are monitored.\nIf the SDA pin is already low, or the SCL pin is already low, then all of the following occur:",
    "15.4.17.1 Bus Collision During a Start Condition\nGLYPH<149> the Start condition is aborted,\nGLYPH<149> the BCLIF flag is set and\nGLYPH<149> the MSSP module is reset to its Idle state (Figure 15-26).\nThe Start condition begins with the SDA and SCL pins deasserted. When the SDA pin is sampled high, the Baud  Rate  Generator  is  loaded  from  SSPADD<6:0> and counts down to GLYPH<145> 0 GLYPH<146>.  If  the  SCL pin is sampled low while SDA is high, a bus collision occurs because it is assumed that another master is attempting to drive a data GLYPH<145> 1 GLYPH<146>  during the Start condition.",
    "15.4.17.1 Bus Collision During a Start Condition\nThe reason that bus collision is not a factor during a Start condition is that no two bus masters can assert a Start condition at the exact  same  time.  Therefore,  one  master will  always  assert  SDA  before  the  other. This condition does  not cause  a bus collision because the two masters must be allowed to arbitrate the first address following the Start condition. If the address is the same, arbitration must be allowed to continue  into  the  data  portion,  Repeated Start or Stop conditions.",
    "FIGURE 15-26: BUS COLLISION DURING START CONDITION (SDA ONLY)\nNote:",
    "15.4.17.2 Bus Collision During a Repeated Start Condition\nDuring  a  Repeated  Start  condition,  a  bus  collision occurs if:\n- a) A low level is sampled on SDA when SCL goes from low level to high level.\nIf SDA is low, a bus collision has occurred (i.e., another master is attempting to transmit a data GLYPH<145> 0 GLYPH<146> , Figure 15-29). If SDA is sampled high, the BRG is reloaded and begins counting. If SDA goes from high-to-low before the BRG times  out,  no  bus  collision  occurs  because  no  two masters can assert SDA at exactly the same time.\n- b) SCL  goes  low  before  SDA  is  asserted  low, indicating  that  another master is attempting to transmit a data GLYPH<145> 1 GLYPH<146>.\nWhen the user deasserts SDA and the pin is allowed to float high, the BRG is loaded with SSPADD<6:0> and counts down to 0. The SCL pin is then deasserted and when sampled high, the SDA pin is sampled.",
    "15.4.17.2 Bus Collision During a Repeated Start Condition\nIf SCL goes from high-to-low before the BRG times out and SDA has not already been asserted, a bus collision occurs.  In  this  case,  another  master  is  attempting  to transmit a data GLYPH<145> 1 GLYPH<146>  during the Repeated Start condition (see Figure 15-30).\nIf, at the end of the BRG time-out, both SCL and SDA are still high, the SDA pin is driven low and the BRG is reloaded and begins counting. At the end of the count, regardless of the status of the SCL pin, the SCL pin is driven low and the Repeated Start condition is complete.",
    "15.4.17.3 Bus Collision During a Stop Condition\nBus collision occurs during a Stop condition if:\na) After  the  SDA  pin  has  been  deasserted  and allowed to float high, SDA is sampled low after the BRG has timed out.\nb) After the SCL pin is deasserted, SCL is sampled low before SDA goes high.\nThe  Stop  condition  begins  with  SDA  asserted  low. When SDA is sampled low, the SCL pin is allowed to float. When the pin is sampled high (clock arbitration), the Baud Rate Generator is loaded with SSPADD<6:0> and counts down to 0. After the BRG times out, SDA is sampled. If  SDA is  sampled low, a bus collision has occurred. This is due to another master attempting to drive  a  data  GLYPH<145> 0 GLYPH<146> (Figure 15-31).  If  the  SCL  pin  is sampled low before SDA is allowed to float high, a bus collision occurs. This is another case of another master attempting to drive a data GLYPH<145> 0 GLYPH<146> (Figure 15-32).",
    "FIGURE 15-31: BUS COLLISION DURING A STOP CONDITION (CASE 1)\nSDA\nSCL\nBCLIF\nPEN\nP\nSSPIF\nTBRG\nTBRG\nTBRG\nSDA asserted low\nSDA sampled low after TBRG, set BCLIF\nGLYPH<145> 0 GLYPH<146>\nGLYPH<145>\n0\nGLYPH<146>",
    "FIGURE 15-32: BUS COLLISION DURING A STOP CONDITION (CASE 2)\nSDA\nSCL\nBCLIF\nPEN\nP\nSSPIF\nTBRG\nTBRG\nTBRG\nAssert SDA\nSCL goes low before SDA goes high, set BCLIF\nGLYPH<145>\n0\nGLYPH<146>\nGLYPH<145> 0 GLYPH<146>",
    "TABLE 15-4: REGISTERS ASSOCIATED WITH I 2 CGLYPH<153> OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Valueson Page = 59. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Valueson Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4",
    "TABLE 15-4: REGISTERS ASSOCIATED WITH I 2 CGLYPH<153> OPERATION\n= TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Valueson Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Valueson Page = 61. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register.",
    "TABLE 15-4: REGISTERS ASSOCIATED WITH I 2 CGLYPH<153> OPERATION\nTRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Reset Valueson Page = 62. SSPBUF, Bit 7 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = MSSP Receive Buffer/Transmit Register. SSPBUF, Bit 0 = MSSP Receive Buffer/Transmit Register. SSPBUF, Reset Valueson Page = 60. SSPADD, Bit 7 = MSSP Address Register in I 2 C Slave Mode. MSSP Baud Rate Reload Register in I 2 C Slave Mode.. SSPADD, Bit 6 = MSSP Address Register in I 2 C Slave Mode. MSSP Baud Rate Reload Register in I 2 C Slave",
    "TABLE 15-4: REGISTERS ASSOCIATED WITH I 2 CGLYPH<153> OPERATION\nMode.. SSPADD, Bit 5 = MSSP Address Register in I 2 C Slave Mode. MSSP Baud Rate Reload Register in I 2 C Slave Mode.. SSPADD, Bit 4 = MSSP Address Register in I 2 C Slave Mode. MSSP Baud Rate Reload Register in I 2 C Slave Mode.. SSPADD, Bit 3 = MSSP Address Register in I 2 C Slave Mode. MSSP Baud Rate Reload Register in I 2 C Slave Mode.. SSPADD, Bit 2 = MSSP Address Register in I 2 C Slave Mode. MSSP Baud Rate Reload Register in I 2 C Slave Mode.. SSPADD, Bit 1 = MSSP Address Register in I 2 C Slave Mode. MSSP Baud Rate Reload Register in I 2 C Slave Mode.. SSPADD, Bit 0 = MSSP Address Register in I 2 C Slave Mode. MSSP Baud Rate Reload Register in I 2 C Slave Mode.. SSPADD, Reset Valueson Page = 60. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 =",
    "TABLE 15-4: REGISTERS ASSOCIATED WITH I 2 CGLYPH<153> OPERATION\nSSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3 = SSPM3. SSPCON1, Bit 2 = SSPM2. SSPCON1, Bit 1 = SSPM1. SSPCON1, Bit 0 = SSPM0. SSPCON1, Reset Valueson Page = 60. SSPCON2, Bit 7 = GCEN. SSPCON2, Bit 6 = ACKSTAT. SSPCON2, Bit 5 = ACKDT. SSPCON2, Bit 4 = ACKEN. SSPCON2, Bit 3 = RCEN. SSPCON2, Bit 2 = PEN. SSPCON2, Bit 1 = RSEN. SSPCON2, Bit 0 = SEN. SSPCON2, Reset Valueson Page = 60. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT,",
    "TABLE 15-4: REGISTERS ASSOCIATED WITH I 2 CGLYPH<153> OPERATION\nBit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Reset Valueson Page = 60\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used by the MSSP in SPI mode.",
    "16.0 ENHANCED UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\nPIC18F6390/6490/8390/8490 devices have three serial I/O modules: the MSSP module, discussed in the previous chapter and  two  Universal Synchronous Asynchronous  Receiver  Transmitter  (USART)  modules. (Generically, the USART is also known as a Serial Communications Interface or SCI.) The USART can be configured as a full-duplex asynchronous system that can  communicate  with  peripheral  devices,  such  as CRT terminals and personal computers. It can also be configured as a half-duplex synchronous system that can communicate with peripheral devices, such as A/D or D/A integrated circuits, serial EEPROMs, etc.\nThere are two distinct implementations of the USART module  in these devices: the Enhanced  USART (EUSART) discussed here and the Addressable USART discussed in the next chapter. For this device family,  USART1 always refers to the EUSART, while USART2 is always the AUSART.",
    "16.0 ENHANCED UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\nThe  EUSART  and  AUSART  modules  implement  the same  core  features  for  serial  communications;  their basic operation is essentially the same. The EUSART module provides additional features, including Automatic Baud Rate Detection (ABD) and calibration, automatic wake-up on Sync Break reception and 12-bit Break  character  transmit.  These  features  make  it ideally suited for use in Local Interconnect Network bus (LIN bus) systems.\nThe  EUSART  can  be  configured  in  the  following modes:\nGLYPH<149> Asynchronous (full-duplex) with:\n-Auto-wake-up on character reception\n-Auto-baud calibration\n-12-bit Break character transmission\nGLYPH<149> Synchronous GLYPH<150> Master (half-duplex) with selectable clock polarity\nGLYPH<149> Synchronous GLYPH<150> Slave (half-duplex) with selectable clock polarity",
    "16.0 ENHANCED UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\nThe  pins  of  the  EUSART  are  multiplexed  with  the functions of PORTC (RC6/TX1/CK1 and RC7/RX1/DT1). In order to configure these pins as an EUSART:\nGLYPH<149> bit SPEN (RCSTA1<7>) must be set (= 1 )\nGLYPH<149> bit TRISC<7> must be set (= 1 )\nGLYPH<149> bit TRISC<6> must be set (= 1 )\nNote:\nThe USART  control will automatically reconfigure the pin from input to output as needed.\nThe  operation  of  the  Enhanced  USART  module  is controlled through three registers:\nGLYPH<149> Transmit Status and Control Register 1 (TXSTA1)\nGLYPH<149> Receive Status and Control Register 1 (RCSTA1)\nGLYPH<149> Baud Rate Control Register 1 (BAUDCON1)\nThe registers are described in Register 16-1, Register 16-2 and Register 16-3.",
    "REGISTER 16-1: TXSTA1: EUSART TRANSMIT STATUS AND CONTROL REGISTER\nCSRC, R/W-0 = TX9. CSRC, R/W-0 = TXEN (1). CSRC, R/W-0 = SYNC. CSRC, R/W-0 = SENDB. CSRC, R/W-0 = BRGH. CSRC, R-1 = TRMT. CSRC, R/W-0 = TX9D. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R-1 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 16-1: TXSTA1: EUSART TRANSMIT STATUS AND CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 CSRC: Clock Source Select bit\nAsynchronous mode:\nDonGLYPH<146>t care.\nSynchronous mode:\n1 = Master mode (clock generated internally from BRG)\n0 = Slave mode (clock from external source)",
    "bit 6\nTX9: 9-Bit Transmit Enable bit\n1 = Selects 9-bit transmission\n0 = Selects 8-bit transmission\nbit 5\nTXEN: Transmit Enable bit (1)\n1 = Transmit enabled\n0 = Transmit disabled",
    "bit 4\nSYNC: EUSART Mode Select bit\n1 = Synchronous mode\n0 = Asynchronous mode",
    "bit 3\nSENDB: Send Break Character bit\nAsynchronous mode:\n1 = Send Sync Break on next transmission (cleared by hardware upon completion)\n0 = Sync Break transmission completed\nSynchronous mode:\nDonGLYPH<146>t care.",
    "bit 2 BRGH:\nHigh Baud Rate Select bit\nAsynchronous mode:\n1 = High speed\n0 = Low speed\nSynchronous mode:\nUnused in this mode.",
    "bit 1 TRMT: Transmit Shift Register Status bit\n1 = TSR empty\n0 = TSR full",
    "bit 0\nTX9D: 9th bit of Transmit Data\nCan be address/data bit or a parity bit.\nNote 1: SREN/CREN overrides TXEN in Sync mode.",
    "REGISTER 16-2: RCSTA1: EUSART RECEIVE STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-x. SPEN, 1 = RX9. SPEN, 2 = SREN. SPEN, 3 = CREN. SPEN, 4 = ADDEN. SPEN, 5 = FERR. SPEN, 6 = OERR. SPEN, 7 = RX9D. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 16-2: RCSTA1: EUSART RECEIVE STATUS AND CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nSPEN:\nSerial Port Enable bit\n1 = Serial port enabled (configures RX1/DT1 and TX1/CK1 pins as serial port pins)\n0 = Serial port disabled (held in Reset)",
    "bit 6 RX9: 9-Bit Receive Enable bit\n1 = Selects 9-bit reception\n0 = Selects 8-bit reception",
    "bit 5 SREN: Single Receive Enable bit\nAsynchronous mode:\nDonGLYPH<146>t care.",
    "Synchronous mode GLYPH<150> Master:\n1 = Enables single receive\n0 = Disables single receive\nThis bit is cleared after reception is complete.\nSynchronous mode GLYPH<150> Slave:\nDonGLYPH<146>t care.",
    "bit 4 CREN: Continuous Receive Enable bit\nAsynchronous mode:\n1 = Enables receiver\n0 = Disables receiver",
    "Synchronous mode:\n1 = Enables continuous receive until enable bit, CREN, is cleared (CREN overrides SREN)\n0 = Disables continuous receive\nADDEN: Address Detect Enable bit\nAsynchronous mode 9-Bit (RX9 = 1 ):\n1 = Enables address detection, enables interrupt and loads the receive buffer when RSR<8> is set\n0 = Disables address detection, all bytes are received and ninth bit can be used as parity bit",
    "Asynchronous mode 9-Bit (RX9 = 0 ):\nDonGLYPH<146>t care.",
    "bit 2 FERR: Framing Error bit\n1 = Framing error (can be updated by reading RCREG1 register and receiving next valid byte)\n0 = No framing error",
    "bit 1 OERR: Overrun Error bit\n1 = Overrun error (can be cleared by clearing bit, CREN)\n0 = No overrun error\nRX9D: 9th bit of Received Data\nThis can be address/data bit or a parity bit and must be calculated by user firmware.",
    "REGISTER 16-3: BAUDCON1: BAUD RATE CONTROL REGISTER 1\nR/W-0, 1 = R-1. R/W-0, 2 = U-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = U-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. ABDOVF, 1 = RCIDL. ABDOVF, 2 = GLYPH<151>. ABDOVF, 3 = SCKP. ABDOVF, 4 = BRG16. ABDOVF, 5 = GLYPH<151>. ABDOVF, 6 = WUE. ABDOVF, 7 = ABDEN. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 16-3: BAUDCON1: BAUD RATE CONTROL REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7\nABDOVF: Auto-Baud Acquisition Rollover Status bit\n1 = A BRG rollover has occurred during Auto-Baud Rate Detect mode (must be cleared in software)\n0 = No BRG rollover has occurred",
    "bit 6 RCIDL: Receive Operation Idle Status bit\n1 = Receive operation is Idle\n0 = Receive operation is active",
    "bit 4 SCKP: Synchronous Clock Polarity Select bit\nAsynchronous mode:\nUnused in this mode.",
    "Synchronous mode:\n1 = Idle state for clock (CK1) is a high level\n0 = Idle state for clock (CK1) is a low level",
    "bit 3 BRG16: 16-Bit Baud Rate Register Enable bit\n- 1 = 16-bit Baud Rate Generator GLYPH<150> SPBRGH1 and SPBRG1\n0 = 8-bit Baud Rate Generator GLYPH<150> SPBRG1 only (Compatible mode), SPBRGH1 value ignored",
    "bit 1 WUE: Wake-up Enable bit\nAsynchronous mode:\n1 = EUSART will continue to sample the RX1 pin GLYPH<150> interrupt generated on falling edge; bit cleared in hardware on following rising edge\n0 = RX1 pin not monitored or rising edge detected",
    "Synchronous mode:\nUnused in this mode.",
    "bit 0 ABDEN: Auto-Baud Detect Enable bit\nAsynchronous mode:\nEnable baud rate measurement on the next character. Requires reception of a Sync field (55h);\n1 = cleared in hardware upon completion.\n0 = Baud rate measurement disabled or completed",
    "Synchronous mode:\nUnused in this mode.",
    "16.1 EUSART Baud Rate Generator (BRG)\nThe BRG is a dedicated, 8-bit or 16-bit generator that supports  both  the  Asynchronous  and  Synchronous modes of the EUSART. By default, the BRG operates in 8-bit mode; setting the BRG16 bit (BAUDCON1<3>) selects 16-bit mode.\nThe SPBRGH1:SPBRG1 register pair controls the period of  a  free-running  timer.  In  Asynchronous  mode,  the BRGH (TXSTA1<2>) and BRG16 (BAUDCON1<3>) bits also control the baud rate. In Synchronous mode, BRGH is ignored. Table 16-1 shows the formula for computation of the baud rate for different EUSART modes that only apply in Master mode (internally generated clock).",
    "16.1 EUSART Baud Rate Generator (BRG)\nGiven  the  desired  baud  rate  and  FOSC,  the  nearest integer value for the SPBRGH1:SPBRG1 registers can be  calculated  using  the  formulas  in  T able 16-1.  From this, the error in baud rate can be determined. An example calculation is shown in Example 16-1. Typical baud rates  and  error  values  for  the  various  Asynchronous modes  are  shown  in  Table 16-3.  It  may  be  advanta- geous to use the high baud rate (BRGH = 1 ) or the 16-bit BRG to reduce the baud rate error, or achieve a slow baud rate for a fast oscillator frequency.\nWriting a new value to the SPBRGH1:SPBRG1 registers causes the BRG timer to be reset (or cleared). This ensures  the  BRG does not wait  for  a  timer  overflow before outputting the new baud rate.",
    "16.1.1 OPERATION IN POWER-MANAGED MODES\nThe device clock is used to generate the desired baud rate.  When  one  of  the  power-managed  modes  is entered, the new clock source may be operating at a different frequency. This may require an adjustment to the value in the SPBRG1 register pair.",
    "16.1.2 SAMPLING\nThe data on the RX1 pin is sampled three times by a majority detect circuit to determine if a high or a low level is present at the RX1 pin.",
    "TABLE 16-1: BAUD RATE FORMULAS\n0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-Bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[64 (n + 1)]. 0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 1. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-Bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[16 (n + 1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 16-Bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[16 (n + 1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 1. 0,",
    "TABLE 16-1: BAUD RATE FORMULAS\nBRG/EUSART Mode.BRG/EUSART Mode = 16-Bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]. 1, Configuration Bits.BRG16 = 0. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 8-Bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]. 1, Configuration Bits.BRG16 = 1. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 16-Bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]\nLegend: x = DonGLYPH<146>t care, n = Value of SPBRGH1:SPBRG1 register pair",
    "EXAMPLE 16-1: CALCULATING BAUD RATE ERROR\nFor a device with FOSC of 16 MHz, desired baud rate of 9600, Asynchronous mode, 8-bit BRG:\nDesired Baud Rate = FOSC/(64 ([SPBRGH1:SPBRG1] + 1))\nSolving for SPBRGH1:SPBRG1:\nX = ((FOSC/Desired Baud Rate)/64) GLYPH<150> 1\n= ((16000000/9600)/64) GLYPH<150> 1\n= [25.042] = 25\nCalculated Baud Rate = 16000000/(64 (25 + 1))\n= 9615\nError\n= (Calculated Baud Rate GLYPH<150> Desired Baud Rate)/Desired Baud Rate\n= (9615 GLYPH<150> 9600)/9600 = 0.16%",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH THE BAUD RATE GENERATOR\nTXSTA1, Bit 7 = CSRC. TXSTA1, Bit 6 = TX9. TXSTA1, Bit 5 = TXEN. TXSTA1, Bit 4 = SYNC. TXSTA1, Bit 3 = SENDB. TXSTA1, Bit 2 = BRGH. TXSTA1, Bit 1 = TRMT. TXSTA1, Bit 0 = TX9D. TXSTA1, Reset Values on Page = 61. RCSTA1, Bit 7 = SPEN. RCSTA1, Bit 6 = RX9. RCSTA1, Bit 5 = SREN. RCSTA1, Bit 4 = CREN. RCSTA1, Bit 3 = ADDEN. RCSTA1, Bit 2 = FERR. RCSTA1, Bit 1 = OERR. RCSTA1, Bit 0 = RX9D. RCSTA1, Reset Values on Page = 61. BAUDCON1, Bit 7 = ABDOVF. BAUDCON1, Bit 6 = RCIDL. BAUDCON1, Bit 5 = GLYPH<151>. BAUDCON1, Bit 4 = SCKP. BAUDCON1, Bit",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH THE BAUD RATE GENERATOR\n3 = BRG16. BAUDCON1, Bit 2 = GLYPH<151>. BAUDCON1, Bit 1 = WUE. BAUDCON1, Bit 0 = ABDEN. BAUDCON1, Reset Values on Page = 62. SPBRGH1, Bit 7 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 6 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 5 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 4 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 3 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 2 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 1 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 0 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Reset Values on Page = 62. SPBRG1, Bit 7 = EUSART1 Baud Rate Generator",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH THE BAUD RATE GENERATOR\nRegister Low Byte. SPBRG1, Bit 6 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 5 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 4 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 3 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 2 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 1 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 0 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Reset Values on Page = 61\nLegend:\nGLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used by the BRG.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nGLYPH<151>. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 1.221. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal)",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 255. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 2.441. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 64. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 31. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n10.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 15. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 19.2,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nSYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 15. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 10.000 MHz.SPBRG value (decimal) = 7. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n40.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 4. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 52.083. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -9.58. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 2.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 104.167. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -9.58. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 2. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 78.125. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -32.18. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n8.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = GLYPH<151>",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 0.3, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 1.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 12. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.% Error = GLYPH<151>. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 8.929. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -6.99. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 6. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nGLYPH<151>. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = GLYPH<151>. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 20.833. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 8.51. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 2. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nGLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = GLYPH<151>.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -45.75.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = GLYPH<151>.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nGLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.SPBRG value (decimal) = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = GLYPH<151>. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n8.000 MHz.SPBRG value (decimal) = GLYPH<151>. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = GLYPH<151>. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = GLYPH<151>. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = GLYPH<151>. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = GLYPH<151>. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = GLYPH<151>. 2.4, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 20.000 MHz.SPBRG value (decimal) = GLYPH<151>. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 2.441. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 255. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.SPBRG value (decimal) = 207. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, SYNC",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 129. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n19.531. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 19.230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 1 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRG16 = 0.FOSC = 40.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 21. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.%",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nError = -1.36. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 55.555. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = GLYPH<151>",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = GLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nGLYPH<151>. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n2.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = GLYPH<151>. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\nGLYPH<151>. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = GLYPH<151>.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = GLYPH<151>.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES\n115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 8332. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 4165. 0.3, SYNC = 0 , BRGH = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.02. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 2082. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 1665. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.02. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 2082. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 1041. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 1.200.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -0.03. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 520. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 415. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 2.402. 2.4, SYNC = 0 , BRGH = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 40.000 MHz.% Error = 0.06. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 1040. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 2.399. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 520. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 259. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.16. 9.6, SYNC",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 259. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 10.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nvalue (decimal) = 129. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 19.230. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n20.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 21. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n55.555. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 8.000 MHz.% Error = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = GLYPH<151>",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.04. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 832. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 415. 0.3, SYNC = 0 , BRGH = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 2.404.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 0 ,",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = GLYPH<151>. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nGLYPH<151>. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nGLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.% Error = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 33332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.00.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 16665. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 8332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.01. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 6665. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n8332. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 4165. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.02.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 2082. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 1665. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.02. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 4165. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 2.400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2082. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.402. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.06. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 1040. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2.400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n-0.04. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 832. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.606. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.06. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 1040. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n(K) = 9.596. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 520. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nvalue (decimal) = 259. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 19.193. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= -0.03. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 520. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 259. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K)",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 19.230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n103. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 57.803. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.35. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 172. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 57.471. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n-0.22. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 86. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n57.142. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = 0.79. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 34. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 114.943. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -0.22. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n86. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 116.279. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.94. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 42. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -1.36.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 117.647. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -2.12. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 16",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.01. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 3332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.04.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 1665. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.04. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 832. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.04. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 832. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n415. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 415. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 207. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 2403.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 103. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 103.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 19.230.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 19.230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 12.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 58.824. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 2.12. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 16. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 55.555. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = 3.55.",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 8. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = GLYPH<151>. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.Actual Rate (K) = 111.111. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = -3.55. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC =",
    "TABLE 16-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = GLYPH<151>. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>",
    "16.1.3 AUTO-BAUD RATE DETECT\nThe Enhanced USART module supports the automatic detection and calibration of baud rate. This feature is active only in Asynchronous mode and while the WUE bit is clear.\n- Note 1: If the WUE bit is set with the ABDEN bit, Auto-Baud Rate Detection will occur  on the byte following the Break character.\nThe  automatic  baud  rate  measurement  sequence (Figure 16-1) begins whenever a Start bit is received and the ABDEN  bit is set. The calculation is self-averaging.\nIn the Auto-Baud Rate Detect (ABD) mode, the clock to the BRG is reversed. Rather than the BRG clocking the incoming RX1 signal, the RX1 signal is timing the BRG. In  ABD  mode,  the  internal  Baud  Rate  Generator  is used as a counter to time the bit period of the incoming serial byte stream.",
    "16.1.3 AUTO-BAUD RATE DETECT\nOnce the ABDEN bit is set, the state machine will clear the BRG and look for a Start bit. The Auto-Baud Rate Detect must receive a byte with the value, 55h (ASCII GLYPH<147>UGLYPH<148>, which is also the LIN bus Sync character), in order to  calculate  the  proper  bit  rate.  The  measurement  is taken over both a low and a high bit time in order to minimize  any  effects  caused  by  asymmetry  of  the incoming signal. After a Start bit, the SPBRG1 begins counting up, using the preselected clock source on the first rising edge of RX1. After eight bits on the RX1 pin or the fifth rising edge, an accumulated value totalling the proper BRG period is left in the SPBRGH1:SPBRG1 register pair. Once the 5th edge is seen  (this  should  correspond  to  the  Stop  bit),  the ABDEN bit is automatically cleared.",
    "16.1.3 AUTO-BAUD RATE DETECT\nIf a rollover of the BRG occurs (an overflow from FFFFh to 0000h), the event is trapped by the ABDOVF status bit (BAUDCON1<7>). It is set in hardware by BRG rollovers and can be set or cleared by the user in software. ABD mode  remains  active  after  rollover  events  and  the ABDEN bit remains set (Figure 16-2).\nWhile calibrating the baud rate period, the BRG registers are clocked at 1/8th the preconfigured clock rate. Note  that  the  BRG  clock  will  be  configured  by  the BRG16 and BRGH bits. This allows the user to verify that no carry occurred for 8-bit modes by checking for 00h in the SPBRGH1 register. Refer to Table 16-4 for counter clock rates to the BRG.",
    "16.1.3 AUTO-BAUD RATE DETECT\nWhile  the  ABD  sequence  takes  place,  the  EUSART state machine is held in Idle. The RC1IF interrupt is set once the fifth rising edge on RX1 is detected. The value in the RCREG1 needs to be read to clear the RC1IF interrupt. The contents of RCREG1 should be discarded.\n2: It  is  up  to  the  user  to  determine  that  the incoming character baud rate is within the range of the selected BRG clock source. Some combinations of oscillator frequency and EUSART baud rates are not possible due  to  bit  error  rates.  Overall  system timing and  communication  baud  rates must  be  taken  into  consideration  when using the Auto-Baud Rate Detection feature.\n3: When the auto-baud feature is enabled, the BRG16 bit (BAUDCON<3>) must be set.",
    "TABLE 16-4: BRG COUNTER CLOCK RATES\n0, BRGH = 0. 0, BRG Counter Clock = FOSC/512. 0, BRGH = 1. 0, BRG Counter Clock = FOSC/128. 1, BRGH = 0. 1, BRG Counter Clock = FOSC/128. 1, BRGH = 1. 1, BRG Counter Clock = FOSC/32",
    "16.1.3.1 ABD and EUSART Transmission\nSince the BRG clock is reversed during ABD acquisition,  the  EUSART transmitter cannot be used during ABD. This means that whenever the ABDEN bit is set, TXREG1  cannot  be  written  to.  Users  should  also ensure  that  ABDEN  does  not  become  set  during  a transmit  sequence.  Failing  to  do  this  may  result  in unpredictable EUSART operation.",
    "FIGURE 16-2: BRG OVERFLOW SEQUENCE\nStart\nBit 0\nXXXXh\n0000h\n0000h\nFFFFh\nBRG Clock\nABDEN bit\nRX1 pin\nABDOVF bit\nBRG Value",
    "16.2 EUSART Asynchronous Mode\nThe Asynchronous mode of operation is selected by clearing the SYNC bit (TXSTA1<4>). In this mode, the EUSART uses standard Non-Return-to-Zero (NRZ) format (one Start bit, eight or nine data bits and one Stop bit). The  most  common  data  format  is  8  bits.  An on-chip,  dedicated  8-bit/16-bit  Baud  Rate  Generator can be used to derive standard baud rate frequencies from the oscillator.\nThe EUSART transmits and receives the LSb first. The EUSARTGLYPH<146>s transmitter  and  receiver  are  functionally independent, but use the same data format and baud rate. The Baud Rate Generator produces a clock, either x16 or x64 of the bit shift rate, depending on the BRGH and  BRG16  bits  (TXSTA1<2>  and  BAUDCON1<3>). Parity  is  not  supported  by  the  hardware  but  can  be implemented in software and stored as the 9th data bit.\nWhen operating in Asynchronous mode, the EUSART module consists of the following important elements:",
    "16.2 EUSART Asynchronous Mode\nGLYPH<149> Baud Rate Generator\nGLYPH<149> Sampling Circuit\nGLYPH<149> Asynchronous Transmitter\nGLYPH<149> Asynchronous Receiver\nGLYPH<149> Auto-Wake-up on Sync Break Character\nGLYPH<149> 12-Bit Break Character Transmit\nGLYPH<149> Auto-Baud Rate Detection",
    "16.2.1 EUSART ASYNCHRONOUS TRANSMITTER\nOnce the TXREG1 register transfers  the data  to  the TSR register (occurs in one TCY), the TXREG1 register is empty and the TX1IF flag bit (PIR1<4>) is set. This interrupt can be enabled or disabled by setting or clearing  the  interrupt  enable  bit,  TX1IE  (PIE1<4>).  TX1IF will be set regardless of the state of TX1IE; it cannot be cleared in software. TX1IF is also not cleared immediately upon loading TXREG1, but becomes valid in the second instruction cycle following the load instruction. Polling TX1IF immediately following a load of TXREG1 will return invalid results.\nWhile TX1IF indicates the status of the TXREG1 register, another bit, TRMT (TXSTA1<1>), shows the status of the TSR register. TRMT is a read-only bit which is set when the TSR register is empty. No interrupt logic is tied to this bit so the user has to poll this bit in order to determine if the TSR register is empty.",
    "16.2.1 EUSART ASYNCHRONOUS TRANSMITTER\nNote 1: The TSR register is not mapped in data memory so it is not available to the user.\n2: Flag  bit,  TX1IF,  is  set  when  enable  bit TXEN is set.\nTo set up an Asynchronous Transmission:\n1. Initialize  the  SPBRGH1:SPBRG1  registers  for the  appropriate  baud  rate.  Set  or  clear  the BRGH and BRG16 bits, as required, to achieve the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit, SYNC, and setting bit, SPEN.\n3. If interrupts are desired, set enable bit, TX1IE.",
    "16.2.1 EUSART ASYNCHRONOUS TRANSMITTER\nThe  EUSART transmitter  block  diagram  is  shown  in Figure 16-3. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The Shift register obtains its data from the Read/Write Transmit Buffer register, TXREG1. The TXREG1 register is loaded with data in software. The TSR register is not loaded until the Stop bit  has  been  transmitted  from  the  previous  load.  As soon as the Stop bit is transmitted, the TSR is loaded with new data from the TXREG1 register (if available).\n4. If 9-bit transmission is desired, set transmit bit, TX9; can be used as address/data bit.\n5. Enable  the  transmission  by  setting  bit,  TXEN, which will also set bit, TX1IF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit, TX9D.\n7. Load  data to the TXREG1  register  (starts transmission).\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "FIGURE 16-5: ASYNCHRONOUS TRANSMISSION (BACK-TO-BACK)\nTABLE 16-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION",
    "FIGURE 16-5: ASYNCHRONOUS TRANSMISSION (BACK-TO-BACK)\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit",
    "FIGURE 16-5: ASYNCHRONOUS TRANSMISSION (BACK-TO-BACK)\n4 = TX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page = 61. RCSTA1, Bit 7 = SPEN. RCSTA1, Bit 6 = RX9. RCSTA1, Bit 5 = SREN. RCSTA1, Bit 4 = CREN. RCSTA1, Bit 3 = ADDEN. RCSTA1, Bit 2 = FERR. RCSTA1, Bit 1 = OERR.",
    "FIGURE 16-5: ASYNCHRONOUS TRANSMISSION (BACK-TO-BACK)\nRCSTA1, Bit 0 = RX9D. RCSTA1, Reset Values on Page = 61. TXREG1, Bit 7 = EUSART1 Transmit Register. TXREG1, Bit 6 = EUSART1 Transmit Register. TXREG1, Bit 5 = EUSART1 Transmit Register. TXREG1, Bit 4 = EUSART1 Transmit Register. TXREG1, Bit 3 = EUSART1 Transmit Register. TXREG1, Bit 2 = EUSART1 Transmit Register. TXREG1, Bit 1 = EUSART1 Transmit Register. TXREG1, Bit 0 = EUSART1 Transmit Register. TXREG1, Reset Values on Page = 61. TXSTA1, Bit 7 = CSRC. TXSTA1, Bit 6 = TX9. TXSTA1, Bit 5 = TXEN. TXSTA1, Bit 4 = SYNC. TXSTA1, Bit 3 = SENDB. TXSTA1, Bit 2 = BRGH. TXSTA1, Bit 1 = TRMT. TXSTA1, Bit 0 = TX9D.",
    "FIGURE 16-5: ASYNCHRONOUS TRANSMISSION (BACK-TO-BACK)\nTXSTA1, Reset Values on Page = 61. BAUDCON1, Bit 7 = ABDOVF. BAUDCON1, Bit 6 = RCIDL. BAUDCON1, Bit 5 = GLYPH<151>. BAUDCON1, Bit 4 = SCKP. BAUDCON1, Bit 3 = BRG16. BAUDCON1, Bit 2 = GLYPH<151>. BAUDCON1, Bit 1 = WUE. BAUDCON1, Bit 0 = ABDEN. BAUDCON1, Reset Values on Page = 62. SPBRGH1, Bit 7 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 6 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 5 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 4 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 3 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 2 = EUSART1 Baud Rate",
    "FIGURE 16-5: ASYNCHRONOUS TRANSMISSION (BACK-TO-BACK)\nGenerator Register High Byte. SPBRGH1, Bit 1 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 0 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Reset Values on Page = 62. SPBRG1, Bit 7 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 6 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 5 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 4 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 3 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 2 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 1 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 0 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Reset Values on Page = 61",
    "FIGURE 16-5: ASYNCHRONOUS TRANSMISSION (BACK-TO-BACK)\nLegend: GLYPH<151> = unimplemented locations read as GLYPH<145> 0 GLYPH<146>. Shaded cells are not used for asynchronous transmission.",
    "16.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\nThe receiver block diagram is  shown in Figure 16-6. The data is received on the RX1 pin and drives the data recovery block. The data recovery block is actually a high-speed shifter operating at x16 times the baud rate, whereas the main receive serial shifter operates at the bit rate or at FOSC. This mode would typically be used in RS-232 systems.\nTo set up an Asynchronous Reception:",
    "16.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize  the  SPBRGH1:SPBRG1  registers  for the  appropriate  baud  rate.  Set  or  clear  the BRGH and BRG16 bits, as required, to achieve the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit, SYNC, and setting bit, SPEN.\n3. If interrupts are desired, set enable bit, RC1IE.\n4. If 9-bit reception is desired, set bit, RX9.\n5. Enable the reception by setting bit, CREN.\n6. Flag  bit,  RC1IF,  will  be  set  when  reception  is complete and an interrupt will  be  generated  if enable bit, RC1IE, was set.\n7. Read the RCSTA1 register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n8. Read  the  8-bit  received  data  by  reading  the RCREG1 register.\n9. If any error occurred, clear the error by clearing enable bit, CREN.\nThis mode would typically be used in RS-485 systems. To  set  up  an  Asynchronous  Reception  with  Address Detect Enable:",
    "16.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize  the  SPBRGH1:SPBRG1  registers  for the  appropriate  baud  rate.  Set  or  clear  the BRGH and BRG16 bits, as required, to achieve the desired baud rate.\n2. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n3. If interrupts are required, set the RCEN bit and select the desired priority level with the RC1IP bit.\n4. Set the RX9 bit to enable 9-bit reception.\n5. Set the ADDEN bit to enable address detect.\n6. Enable reception by setting the CREN bit.\n7. The  RC1IF  bit  will  be  set  when  reception  is complete. The interrupt will be Acknowledged if the RC1IE and GIE bits are set.\n8. Read the RCSTA1 register to determine if any error occurred during reception, as well as read bit 9 of data (if applicable).\n9. Read  RCREG1  to  determine  if  the  device  is being addressed.\n10. If any error occurred, clear the CREN bit.",
    "16.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n11. If  the  device  has  been  addressed,  clear  the ADDEN bit  to  allow  all  received  data  into  the receive buffer and interrupt the CPU.\n10. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "FIGURE 16-7: ASYNCHRONOUS RECEPTION\nRX1 (pin), 1 = Start bit bit 1 bit 0 bit 7/8 Stop bit Start bit. Rcv Buffer Reg Rcv Shift Reg, 1 = Word 1 Word 2. Read Rcv Buffer Reg RCREG1, 1 = RCREG1 RCREG1. RC1IF (Interrupt Flag), 1 = . OERR bit CREN bit, 1 = . Note:, 1 = This timing diagram shows three words appearing on the RX1 input. The RCREG1 (Receive Buffer register) is read after the third word causing the OERR (Overrun) bit to be set.",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 =",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nTX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page = 61. RCSTA1, Bit 7 = SPEN. RCSTA1, Bit 6 = RX9. RCSTA1, Bit 5 = SREN. RCSTA1, Bit 4 = CREN. RCSTA1, Bit 3 = ADDEN. RCSTA1, Bit 2 = FERR. RCSTA1, Bit 1 = OERR. RCSTA1, Bit 0",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\n= RX9D. RCSTA1, Reset Values on Page = 61. RCREG1, Bit 7 = EUSART1 Receive Register. RCREG1, Bit 6 = EUSART1 Receive Register. RCREG1, Bit 5 = EUSART1 Receive Register. RCREG1, Bit 4 = EUSART1 Receive Register. RCREG1, Bit 3 = EUSART1 Receive Register. RCREG1, Bit 2 = EUSART1 Receive Register. RCREG1, Bit 1 = EUSART1 Receive Register. RCREG1, Bit 0 = EUSART1 Receive Register. RCREG1, Reset Values on Page = 61. TXSTA1, Bit 7 = CSRC. TXSTA1, Bit 6 = TX9. TXSTA1, Bit 5 = TXEN. TXSTA1, Bit 4 = SYNC. TXSTA1, Bit 3 = SENDB. TXSTA1, Bit 2 = BRGH. TXSTA1, Bit 1 = TRMT. TXSTA1, Bit 0 = TX9D. TXSTA1, Reset Values on Page = 61.",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nBAUDCON1, Bit 7 = ABDOVF. BAUDCON1, Bit 6 = RCIDL. BAUDCON1, Bit 5 = GLYPH<151>. BAUDCON1, Bit 4 = SCKP. BAUDCON1, Bit 3 = BRG16. BAUDCON1, Bit 2 = GLYPH<151>. BAUDCON1, Bit 1 = WUE. BAUDCON1, Bit 0 = ABDEN. BAUDCON1, Reset Values on Page = 62. SPBRGH1, Bit 7 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 6 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 5 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 4 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 3 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 2 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 1 =",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nEUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 0 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Reset Values on Page = 62. SPBRG1, Bit 7 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 6 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 5 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 4 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 3 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 2 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 1 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 0 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Reset Values on Page = 61",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nLegend: GLYPH<151> = unimplemented locations read as GLYPH<145> 0 GLYPH<146>. Shaded cells are not used for asynchronous reception.",
    "16.2.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nDuring  Sleep  mode,  all  clocks  to  the  EUSART  are suspended. Because of this, the Baud Rate Generator is inactive and a proper byte reception cannot be performed. The auto-wake-up feature allows the controller to wake-up, due to activity on the RX1/DT1 line, while the EUSART is operating in Asynchronous mode.\nEnd-Of-Character  (EOC)  and  cause  data  or  framing errors. Therefore, to work properly, the initial character in the transmission must be all GLYPH<145> 0 GLYPH<146> s. This can be 00h (8 bytes) for standard RS-232 devices, or 000h (12 bits) for LIN bus.",
    "16.2.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nThe  auto-wake-up  feature  is  enabled  by  setting  the WUE bit (BAUDCON<1>). Once set, the typical receive sequence on RX1/DT1 is disabled and the EUSART remains in an Idle state, monitoring for a wake-up event independent  of  the  CPU  mode.  A  wake-up  event consists  of  a  high-to-low  transition  on  the  RX1/DT1 line. (This coincides with the start of a Sync Break or a Wake-up Signal character for the LIN protocol.)\nFollowing a wake-up event, the module generates an RC1IF  interrupt.  The  interrupt  is  generated  synchronously  to  the  Q  clocks  in  normal  operating  modes (Figure 16-8)  and  asynchronously,  if  the  device  is  in Sleep  mode  (Figure 16-9).  The  interrupt  condition  is cleared by reading the RCREG1 register.",
    "16.2.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nThe WUE bit is automatically cleared once a low-to-high transition  is  observed  on  the  RX1  line  following  the wake-up event. At this point, the EUSART module is in Idle mode and returns to normal operation. This signals to the user that the Sync Break event is over.",
    "16.2.4.1 Special Considerations Using Auto-Wake-up\nSince auto-wake-up functions by sensing rising edge transitions  on  RX1/DT1,  information  with  any  state changes  before  the  Stop  bit  may  signal  a false\nOscillator start-up time must  also  be  considered, especially in applications using oscillators with longer start-up  intervals  (i.e.,  XT  or  HS  mode).  The  Sync Break  (or  Wake-up  Signal)  character  must  be  of sufficient length and be followed by a sufficient interval to allow enough time for the selected oscillator to start and provide proper initialization of the EUSART.",
    "16.2.4.2 Special Considerations Using the WUE Bit\nThe timing of WUE and RC1IF events may cause some confusion when it comes to determining the validity of received data. As noted, setting the WUE bit places the EUSART in an Idle mode. The wake-up event causes a receive interrupt by setting the RC1IF bit. The WUE bit is cleared after this when a rising edge is seen on RX1/DT1.  The  interrupt  condition  is  then  cleared  by reading the RCREG1 register. Ordinarily,  the  data  in RCREG1 will be dummy data and should be discarded.\nThe fact that the WUE bit has been cleared (or is still set), and the RC1IF flag is set, should not be used as an  indicator  of  the  integrity  of  the  data  in  RCREG1. Users should consider implementing a parallel method in firmware to verify received data integrity.\nTo assure that no actual data is lost, check the RCIDL bit to verify that a receive operation is not in process. If a receive operation is not occurring, the WUE bit may then be set just prior to entering the Sleep mode.",
    "AUTO-WAKE-UP BIT (WUE) TIMINGS DURING NORMAL OPERATION\nFIGURE 16-9:\nAUTO-WAKE-UP BIT (WUE) TIMINGS DURING SLEEP\nNote 1: If the wake-up event requires long oscillator warm-up time, the auto-clear of the WUE bit can occur while the stposc signal is still active. This sequence should not depend on the presence of Q clocks.\n- 2: The EUSART remains in Idle while the WUE bit is set.",
    "16.2.5 BREAK CHARACTER SEQUENCE\nThe  Enhanced  USART  module  has  the  capability  of sending the special Break character sequences that are required by the LIN bus standard. The Break character transmit consists of a Start bit, followed by twelve GLYPH<145> 0 GLYPH<146>   bits and  a  Stop  bit.  The  Frame  Break  character  is  sent whenever the SENDB and TXEN bits (TXSTA<3> and TXSTA<5>) are set while the Transmit Shift Register is loaded with data. Note that the value of data written to TXREG1 will be ignored and all GLYPH<145> 0 GLYPH<146> s will be transmitted.\nThe SENDB bit is automatically reset by hardware after the corresponding Stop bit is sent. This allows the user to preload the transmit FIFO with the next transmit byte following the Break  character  (typically, the Sync character in the LIN specification).\nNote that the data value written to the TXREG1 for the Break character is ignored. The write simply serves the purpose of initiating the proper sequence.\nThe TRMT bit indicates when the transmit operation is active or Idle, just as it does during normal transmission.  See  Figure 16-10  for  the  timing  of  the  Break character sequence.",
    "16.2.5.1 Break and Sync Transmit Sequence\nThe  following  sequence  will  send  a  message  frame header made up of a Break, followed by an Auto-Baud Sync byte. This sequence is typical of a LIN bus master.\n1. Configure the EUSART for the desired mode.\n3. Load the TXREG1 with a dummy character to initiate transmission (the value is ignored).\n4. Write GLYPH<145>55hGLYPH<146> to TXREG1  to  load  the Sync character into the transmit FIFO buffer.\n5. After the Break has been sent, the SENDB bit is reset  by  hardware.  The  Sync  character  now transmits in the preconfigured mode.\nWhen the TXREG1 becomes empty, as indicated by the TX1IF, the next data byte can be written to TXREG1.",
    "16.2.6 RECEIVING A BREAK CHARACTER\nThe  Enhanced  USART  module can  receive  a  Break character in two ways.\nThe first method forces configuration of the baud rate at a frequency of 9/13 the typical speed. This allows for the  Stop  bit  transition  to  be  at  the  correct  sampling location (13 bits for Break versus Start bit and 8 data bits for typical data).\nThe  second  method  uses  the  auto-wake-up  feature described in Section 16.2.4 GLYPH<147>Auto-Wake-up on Sync Break  CharacterGLYPH<148> . By enabling this feature, the EUSART  will  sample  the  next  two  transitions  on RX1/DT1, cause an RC1IF interrupt  and receive  the next data byte followed by another interrupt.\nNote  that  following  a  Break  character,  the  user  will typically  want  to  enable  the  Auto-Baud  Rate  Detect feature. For both methods, the user can set the ABD bit once the TX1IF interrupt is observed.\n- 2. Set  the  TXEN  and  SENDB  bits  to  set  up  the Break character.",
    "16.3 EUSART Synchronous Master Mode\nThe Synchronous Master mode is entered by setting the CSRC bit (TXSTA<7>). In this mode, the data is transmitted in a half-duplex manner (i.e., transmission and reception do not occur at the same time). When transmitting  data,  the  reception  is  inhibited  and  vice versa.  Synchronous  mode  is  entered  by  setting  bit, SYNC  (TXSTA<4>).  In  addition,  enable  bit,  SPEN (RCSTA1<7>), is set in order to configure the TX1 and RX1  pins to CK1  (clock) and  DT1  (data) lines, respectively.",
    "16.3 EUSART Synchronous Master Mode\nOnce the TXREG1 register transfers  the data  to  the TSR register (occurs in one TCYCLE), the TXREG1 is empty  and  the  TX1IF  flag  bit  (PIR1<4>)  is  set.  The interrupt can be enabled or disabled by setting or clearing the interrupt enable bit, TX1IE (PIE1<4>). TX1IF is set  regardless  of  the  state  of  enable  bit,  TX1IE;  it cannot be cleared in software. It will reset only when new data is loaded into the TXREG1 register.\nThe Master mode indicates that the processor transmits the master clock on the CK1 line. Clock polarity is selected  with  the  SCKP  bit  (BAUDCON<4>);  setting SCKP sets the Idle state on CK1 as high, while clearing the bit sets the Idle state as low. This option is provided to support Microwire devices with this module.",
    "16.3.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\nThe  EUSART transmitter  block  diagram  is  shown  in Figure 16-3. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The Shift register obtains its data from the Read/Write Transmit Buffer register, TXREG1. The TXREG1 register is loaded with data in software. The TSR register is not loaded until the last bit  has  been  transmitted  from  the  previous  load.  As soon as the last bit is transmitted, the TSR is loaded with new data from the TXREG1 (if available).\nWhile flag bit, TX1IF, indicates the status of the TXREG1 register,  another  bit,  TRMT  (TXSTA<1>),  shows  the status of the TSR register. TRMT is a read-only bit which is set when the TSR is empty. No interrupt logic is tied to this bit so the user has to poll this bit in order to determine  if  the  TSR  register  is  empty.  The  TSR  is  not mapped in data memory so it is not available to the user.\nTo set up a Synchronous Master Transmission:",
    "16.3.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\n1. Initialize  the  SPBRGH1:SPBRG1  registers  for the  appropriate  baud  rate.  Set  or  clear  the BRG16 bit, as required, to achieve the desired baud rate.\n2. Enable  the  synchronous  master  serial  port  by setting bits, SYNC, SPEN and CSRC.\n3. If interrupts are desired, set enable bit, TX1IE.\n4. If 9-bit transmission is desired, set bit, TX9.\n5. Enable the transmission by setting bit, TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit, TX9D.\n7. Start transmission by loading data to the TXREG1 register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 =",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nTX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page = 61. RCSTA1, Bit 7 = SPEN. RCSTA1, Bit 6 = RX9. RCSTA1, Bit 5 = SREN. RCSTA1, Bit 4 = CREN. RCSTA1, Bit 3 = ADDEN. RCSTA1, Bit 2 = FERR. RCSTA1, Bit 1 = OERR. RCSTA1, Bit 0",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\n= RX9D. RCSTA1, Reset Values on Page = 61. TXREG1, Bit 7 = EUSART1 Transmit Register. TXREG1, Bit 6 = EUSART1 Transmit Register. TXREG1, Bit 5 = EUSART1 Transmit Register. TXREG1, Bit 4 = EUSART1 Transmit Register. TXREG1, Bit 3 = EUSART1 Transmit Register. TXREG1, Bit 2 = EUSART1 Transmit Register. TXREG1, Bit 1 = EUSART1 Transmit Register. TXREG1, Bit 0 = EUSART1 Transmit Register. TXREG1, Reset Values on Page = 61. TXSTA1, Bit 7 = CSRC. TXSTA1, Bit 6 = TX9. TXSTA1, Bit 5 = TXEN. TXSTA1, Bit 4 = SYNC. TXSTA1, Bit 3 = SENDB. TXSTA1, Bit 2 = BRGH. TXSTA1, Bit 1 = TRMT. TXSTA1, Bit 0 = TX9D. TXSTA1, Reset Values on Page = 61.",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nBAUDCON1, Bit 7 = ABDOVF. BAUDCON1, Bit 6 = RCIDL. BAUDCON1, Bit 5 = GLYPH<151>. BAUDCON1, Bit 4 = SCKP. BAUDCON1, Bit 3 = BRG16. BAUDCON1, Bit 2 = GLYPH<151>. BAUDCON1, Bit 1 = WUE. BAUDCON1, Bit 0 = ABDEN. BAUDCON1, Reset Values on Page = 62. SPBRGH1, Bit 7 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 6 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 5 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 4 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 3 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 2 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 1 =",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nEUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 0 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Reset Values on Page = 62. SPBRG1, Bit 7 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 6 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 5 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 4 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 3 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 2 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 1 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 0 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Reset Values on Page = 61",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used for synchronous master transmission.",
    "16.3.2 EUSART SYNCHRONOUS MASTER RECEPTION\nOnce  Synchronous  mode  is  selected,  reception  is enabled by setting either the Single Receive Enable bit, SREN  (RCSTA1<5>),  or  the  Continuous  Receive Enable bit, CREN (RCSTA1<4>). Data is sampled on the RX1 pin on the falling edge of the clock.\nIf enable  bit,  SREN,  is  set,  only  a  single  word  is received. If enable bit, CREN, is set, the reception is continuous until CREN is cleared. If both bits are set, then CREN takes precedence.\nTo set up a Synchronous Master Reception:",
    "16.3.2 EUSART SYNCHRONOUS MASTER RECEPTION\n1. Initialize the SPBRGH1:SPBRG1 registers for the appropriate baud rate. Set or clear the BRG16 bit, as required, to achieve the desired baud rate.\n3. Ensure bits, CREN and SREN, are clear.\n4. If interrupts are desired, set enable bit, RC1IE.\n5. If 9-bit reception is desired, set bit, RX9.\n6. If a single reception is required, set bit, SREN. For continuous reception, set bit, CREN.\n7. Interrupt flag bit, RC1IF, will be set when reception is complete and an interrupt will be generated if the enable bit, RC1IE, was set.\n8. Read the RCSTA1 register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n9. Read  the  8-bit  received  data  by  reading  the RCREG1 register.\n10. If any error occurred, clear the error by clearing bit, CREN.\n2. Enable  the  synchronous  master  serial  port  by setting bits, SYNC, SPEN and CSRC.",
    "16.3.2 EUSART SYNCHRONOUS MASTER RECEPTION\n11. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 =",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nTX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page = 61. RCSTA1, Bit 7 = SPEN. RCSTA1, Bit 6 = RX9. RCSTA1, Bit 5 = SREN. RCSTA1, Bit 4 = CREN. RCSTA1, Bit 3 = ADDEN. RCSTA1, Bit 2 = FERR. RCSTA1, Bit 1 = OERR. RCSTA1, Bit 0",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\n= RX9D. RCSTA1, Reset Values on Page = 61. RCREG1, Bit 7 = EUSART1 Receive Register. RCREG1, Bit 6 = EUSART1 Receive Register. RCREG1, Bit 5 = EUSART1 Receive Register. RCREG1, Bit 4 = EUSART1 Receive Register. RCREG1, Bit 3 = EUSART1 Receive Register. RCREG1, Bit 2 = EUSART1 Receive Register. RCREG1, Bit 1 = EUSART1 Receive Register. RCREG1, Bit 0 = EUSART1 Receive Register. RCREG1, Reset Values on Page = 61. TXSTA1, Bit 7 = CSRC. TXSTA1, Bit 6 = TX9. TXSTA1, Bit 5 = TXEN. TXSTA1, Bit 4 = SYNC. TXSTA1, Bit 3 = SENDB. TXSTA1, Bit 2 = BRGH. TXSTA1, Bit 1 = TRMT. TXSTA1, Bit 0 = TX9D. TXSTA1, Reset Values on Page = 61.",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nBAUDCON1, Bit 7 = ABDOVF. BAUDCON1, Bit 6 = RCIDL. BAUDCON1, Bit 5 = GLYPH<151>. BAUDCON1, Bit 4 = SCKP. BAUDCON1, Bit 3 = BRG16. BAUDCON1, Bit 2 = GLYPH<151>. BAUDCON1, Bit 1 = WUE. BAUDCON1, Bit 0 = ABDEN. BAUDCON1, Reset Values on Page = 62. SPBRGH1, Bit 7 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 6 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 5 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 4 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 3 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 2 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 1 =",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nEUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 0 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Reset Values on Page = 62. SPBRG1, Bit 7 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 6 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 5 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 4 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 3 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 2 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 1 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 0 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Reset Values on Page = 61",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used for synchronous master reception.",
    "16.4 EUSART Synchronous Slave Mode\nSynchronous  Slave  mode  is  entered  by  clearing  bit, CSRC  (TXSTA1<7>).  This  mode  differs  from  the Synchronous  Master  mode  in  that  the  shift  clock  is supplied  externally  at  the  CK1  pin  (instead  of  being supplied  internally  in  Master  mode).  This  allows  the device to transfer or receive data while in any low-power mode.",
    "16.4.1 EUSART SYNCHRONOUS SLAVE TRANSMIT\nThe operation of the Synchronous Master and Slave modes are identical except in the  case  of  the  Sleep mode.\nIf two words are written to the TXREG1, and then the SLEEP instruction is executed, the following will occur:\na) The  first  word  will  immediately  transfer  to  the TSR register and transmit.\nb) The  second  word  will  remain  in  the  TXREG1 register.\nc) Flag bit, TX1IF, will not be set.\nd) When the first word has been shifted out of TSR, the  TXREG1  register  will  transfer  the  second word to the TSR and flag bit, TX1IF, will now be set.\ne) If enable bit, TX1IE, is set, the interrupt will wake the  chip  from  Sleep.  If  the  global  interrupt  is enabled, the program will branch to the interrupt vector.",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 =",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nTX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page = 61. RCSTA1, Bit 7 = SPEN. RCSTA1, Bit 6 = RX9. RCSTA1, Bit 5 = SREN. RCSTA1, Bit 4 = CREN. RCSTA1, Bit 3 = ADDEN. RCSTA1, Bit 2 = FERR. RCSTA1, Bit 1 = OERR. RCSTA1, Bit 0",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\n= RX9D. RCSTA1, Reset Values on Page = 61. TXREG1, Bit 7 = EUSART1 Transmit Register. TXREG1, Bit 6 = EUSART1 Transmit Register. TXREG1, Bit 5 = EUSART1 Transmit Register. TXREG1, Bit 4 = EUSART1 Transmit Register. TXREG1, Bit 3 = EUSART1 Transmit Register. TXREG1, Bit 2 = EUSART1 Transmit Register. TXREG1, Bit 1 = EUSART1 Transmit Register. TXREG1, Bit 0 = EUSART1 Transmit Register. TXREG1, Reset Values on Page = 61. TXSTA1, Bit 7 = CSRC. TXSTA1, Bit 6 = TX9. TXSTA1, Bit 5 = TXEN. TXSTA1, Bit 4 = SYNC. TXSTA1, Bit 3 = SENDB. TXSTA1, Bit 2 = BRGH. TXSTA1, Bit 1 = TRMT. TXSTA1, Bit 0 = TX9D. TXSTA1, Reset Values on Page = 61.",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nBAUDCON1, Bit 7 = ABDOVF. BAUDCON1, Bit 6 = RCIDL. BAUDCON1, Bit 5 = GLYPH<151>. BAUDCON1, Bit 4 = SCKP. BAUDCON1, Bit 3 = BRG16. BAUDCON1, Bit 2 = GLYPH<151>. BAUDCON1, Bit 1 = WUE. BAUDCON1, Bit 0 = ABDEN. BAUDCON1, Reset Values on Page = 62. SPBRGH1, Bit 7 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 6 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 5 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 4 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 3 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 2 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 1 =",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nEUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 0 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Reset Values on Page = 62. SPBRG1, Bit 7 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 6 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 5 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 4 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 3 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 2 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 1 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 0 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Reset Values on Page = 61",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used for synchronous slave transmission.\nTo set up a Synchronous Slave Transmission:\n1. Enable  the  synchronous  slave  serial  port  by setting bits, SYNC and SPEN, and clearing bit, CSRC.\n2. Clear bits, CREN and SREN.\n3. If interrupts are desired, set enable bit, TX1IE.\n4. If 9-bit transmission is desired, set bit, TX9.\n5. Enable the transmission by setting enable bit, TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit, TX9D.\n7. Start transmission by loading data to the TXREG1 register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "16.4.2 EUSART SYNCHRONOUS SLAVE RECEPTION\nTo set up a Synchronous Slave Reception:\nThe operation of the Synchronous Master and Slave modes is identical except in the case of Sleep or any Idle  mode  and  bit,  SREN,  which  is  a  GLYPH<147>donGLYPH<146>t  careGLYPH<148>  in Slave mode.\nIf  receive is enabled by setting the CREN bit prior to entering Sleep or any Idle mode, then a word may be received while in this low-power mode. Once the word is received, the RSR register will transfer the data to the RCREG1 register. If the RC1IE enable bit is set, the interrupt generated will wake  the chip from the low-power mode. If the global interrupt is enabled, the program will branch to the interrupt vector.",
    "16.4.2 EUSART SYNCHRONOUS SLAVE RECEPTION\n1. Enable  the  synchronous  master  serial  port  by setting bits, SYNC and SPEN, and clearing bit, CSRC.\n2. If interrupts are desired, set enable bit, RC1IE.\n3. If 9-bit reception is desired, set bit, RX9.\n4. To enable reception, set enable bit, CREN.\n5. Flag  bit,  RC1IF,  will  be  set  when  reception  is complete.  An  interrupt will be  generated  if enable bit, RC1IE, was set.\n6. Read the RCSTA1 register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n7. Read  the  8-bit  received  data  by  reading  the RCREG1 register.\n8. If any error occurred, clear the error by clearing bit, CREN.\n9. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\n\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used for synchronous slave reception.",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 =",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nTX1IE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page = 61. RCSTA1, Bit 7 = SPEN. RCSTA1, Bit 6 = RX9. RCSTA1, Bit 5 = SREN. RCSTA1, Bit 4 = CREN. RCSTA1, Bit 3 = ADDEN. RCSTA1, Bit 2 = FERR. RCSTA1, Bit 1 = OERR. RCSTA1, Bit 0",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\n= RX9D. RCSTA1, Reset Values on Page = 61. RCREG1, Bit 7 = EUSART1 Receive Register. RCREG1, Bit 6 = EUSART1 Receive Register. RCREG1, Bit 5 = EUSART1 Receive Register. RCREG1, Bit 4 = EUSART1 Receive Register. RCREG1, Bit 3 = EUSART1 Receive Register. RCREG1, Bit 2 = EUSART1 Receive Register. RCREG1, Bit 1 = EUSART1 Receive Register. RCREG1, Bit 0 = EUSART1 Receive Register. RCREG1, Reset Values on Page = 61. TXSTA1, Bit 7 = CSRC. TXSTA1, Bit 6 = TX9. TXSTA1, Bit 5 = TXEN. TXSTA1, Bit 4 = SYNC. TXSTA1, Bit 3 = SENDB. TXSTA1, Bit 2 = BRGH. TXSTA1, Bit 1 = TRMT. TXSTA1, Bit 0 = TX9D. TXSTA1, Reset Values on Page = 61.",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nBAUDCON1, Bit 7 = ABDOVF. BAUDCON1, Bit 6 = RCIDL. BAUDCON1, Bit 5 = GLYPH<151>. BAUDCON1, Bit 4 = SCKP. BAUDCON1, Bit 3 = BRG16. BAUDCON1, Bit 2 = GLYPH<151>. BAUDCON1, Bit 1 = WUE. BAUDCON1, Bit 0 = ABDEN. BAUDCON1, Reset Values on Page = 62. SPBRGH1, Bit 7 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 6 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 5 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 4 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 3 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 2 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 1 =",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nEUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Bit 0 = EUSART1 Baud Rate Generator Register High Byte. SPBRGH1, Reset Values on Page = 62. SPBRG1, Bit 7 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 6 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 5 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 4 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 3 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 2 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 1 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Bit 0 = EUSART1 Baud Rate Generator Register Low Byte. SPBRG1, Reset Values on Page = 61",
    "17.0 ADDRESSABLE UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (AUSART)\nThe  Addressable  Universal  Synchronous  Asynchronous Receiver Transmitter (AUSART) module is very similar  in  function  to  the  Enhanced  USART  module, discussed in the previous chapter. It is provided as an additional channel for serial communication, with external devices, for those situations that do not require Auto-Baud Detection or LIN bus support.\nThe AUSART can be configured in the following modes:\nGLYPH<149> Asynchronous (full-duplex)\nGLYPH<149> Synchronous GLYPH<150> Master (half-duplex)\nGLYPH<149> Synchronous GLYPH<150> Slave (half-duplex)\nThe pins of the AUSART module are multiplexed with the  functions  of  PORTG  (RG1/TX2/CK2/SEG29  and RG2/RX2/DT2/SEG28, respectively). In order to configure these pins as an AUSART:",
    "17.0 ADDRESSABLE UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (AUSART)\nGLYPH<149> SPEN bit (RCSTA2<7>) must be set (= 1 )\nGLYPH<149> TRISG<2> bit must be set (= 1 )\nGLYPH<149> TRISG<1> bit must be cleared (= 0 ) for Asynchronous and Synchronous Master modes\nGLYPH<149> TRISG<1> bit must be set (= 1 ) for Synchronous Slave mode\nNote:\nThe  AUSART  control  will  automatically reconfigure the pin from input to output as needed.\nThe operation of the Addressable USART module is controlled through two registers, TXSTA2 and RXSTA2.  These  are  detailed  in  Register 17-1  and Register 17-2 respectively.",
    "REGISTER 17-1: TXSTA2: AUSART TRANSMIT STATUS AND CONTROL REGISTER\nCSRC, R/W-0 = TX9. CSRC, R/W-0 = TXEN (1). CSRC, R/W-0 = SYNC. CSRC, U-0 = GLYPH<151>. CSRC, R/W-0 = BRGH. CSRC, R-1 = TRMT. CSRC, R/W-0 = TX9D. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R-1 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 17-1: TXSTA2: AUSART TRANSMIT STATUS AND CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 CSRC: Clock Source Select bit\nAsynchronous mode:\nDonGLYPH<146>t care.\nSynchronous mode:\n1 = Master mode (clock generated internally from BRG)\n0 = Slave mode (clock from external source)",
    "bit 6\nTX9: 9-Bit Transmit Enable bit\n1 = Selects 9-bit transmission\n0 = Selects 8-bit transmission\nbit 5\nTXEN: Transmit Enable bit (1)\n1 = Transmit enabled\n0 = Transmit disabled",
    "bit 4\nSYNC: AUSART Mode Select bit\n1 = Synchronous mode\n0 = Asynchronous mode",
    "bit 3\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>",
    "bit 2 BRGH: High Baud Rate Select bit\nAsynchronous mode:\n1 = High speed\n0 = Low speed\nSynchronous mode:\nUnused in this mode.\nbit 1\nTRMT: Transmit Shift Register Status bit\n1 = TSR empty\n0 = TSR full",
    "bit 0\nTX9D: 9th bit of Transmit Data\nCan be address/data bit or a parity bit.\nNote 1: SREN/CREN overrides TXEN in Sync mode.",
    "REGISTER 17-2: RCSTA2: AUSART RECEIVE STATUS AND CONTROL REGISTER\nSPEN, R/W-0 = RX9. SPEN, R/W-0 = SREN. SPEN, R/W-0 = CREN. SPEN, R/W-0 = ADDEN. SPEN, R-0 = FERR. SPEN, R-0 = OERR. SPEN, R-x = RX9D. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R-x = bit 0",
    "REGISTER 17-2: RCSTA2: AUSART RECEIVE STATUS AND CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 SPEN: Serial Port Enable bit\n1 = Serial port enabled (configures RX2/DT2 and TX2/CK2 pins as serial port pins)\n0 = Serial port disabled (held in Reset)",
    "bit 6 RX9: 9-Bit Receive Enable bit\n1 = Selects 9-bit reception\n0 = Selects 8-bit reception",
    "bit 5 SREN:\nSingle Receive Enable bit\nAsynchronous mode:\nDonGLYPH<146>t care.",
    "Synchronous mode GLYPH<150> Master:\n1 = Enables single receive\n0 = Disables single receive\nThis bit is cleared after reception is complete.\nSynchronous mode GLYPH<150> Slave:\nDonGLYPH<146>t care.",
    "bit 4 CREN: Continuous Receive Enable bit\nAsynchronous mode:\n1 = Enables receiver\n0 = Disables receiver\nSynchronous mode:\n1 = Enables continuous receive until enable bit, CREN, is cleared (CREN overrides SREN)\n0 = Disables continuous receive\nADDEN: Address Detect Enable bit\nAsynchronous mode 9-Bit (RX9 = 1 ):\n1 = Enables address detection, enables interrupt and loads the receive buffer when RSR<8> is set\n0 = Disables address detection, all bytes are received and ninth bit can be used as parity bit\nAsynchronous mode 9-Bit (RX9 = 0 ):\nDonGLYPH<146>t care.",
    "bit 2 FERR: Framing Error bit\n1 = Framing error (can be updated by reading RCREG2 register and receiving next valid byte)\n0 = No framing error",
    "bit 1 OERR: Overrun Error bit\n1 = Overrun error (can be cleared by clearing bit, CREN)\n0 = No overrun error\nRX9D: 9th bit of Received Data\nThis can be address/data bit or a parity bit and must be calculated by user firmware.",
    "17.1 AUSART Baud Rate Generator (BRG)\ngeous to use the high baud rate (BRGH = 1 ) to reduce the baud rate error, or achieve a slow baud rate for a fast oscillator frequency.\nThe BRG is a dedicated 8-bit generator that supports both the Asynchronous and Synchronous modes of the AUSART.\nThe SPBRG2  register controls the period of a free-running timer. In Asynchronous mode, bit BRGH (TXSTA<2>) also controls the baud rate. In Synchronous mode, BRGH is ignored. Table 17-1 shows the formula for computation of the baud rate for different AUSART  modes,  which  only  apply  in  Master  mode (internally generated clock).\nGiven  the  desired  baud  rate  and  FOSC,  the  nearest integer value for the SPBRG2 register can be calculated using the formulas in Table 17-1. From this, the error  in  baud  rate  can  be  determined.  An  example calculation  is  shown  in  Example 17-1.  Typical  baud rates  and  error  values  for  the  various  Asynchronous modes are shown  in  Table 17-3.  It  may  be  advanta-",
    "17.1 AUSART Baud Rate Generator (BRG)\nWriting a new value to the SPBRG2 register causes the BRG timer to  be  reset  (or  cleared).  This  ensures  the BRG does not wait for a timer overflow before outputting the new baud rate.",
    "17.1.1 OPERATION IN POWER-MANAGED MODES\nThe device clock is used to generate the desired baud rate.  When  one  of  the  power-managed  modes  is entered, the new clock source may be operating at a different frequency. This may require an adjustment to the value in the SPBRG2 register.",
    "17.1.2 SAMPLING\nThe data on the RX2 pin is sampled three times by a majority detect circuit to determine if a high or a low level is present at the RX2 pin.",
    "TABLE 17-1: BAUD RATE FORMULAS\n0, Configuration Bits.BRGH = 0. 0, BRG/AUSART Mode = Asynchronous. 0, Baud Rate Formula = FOSC/[64 (n + 1)]. 0, Configuration Bits.BRGH = 1. 0, BRG/AUSART Mode = Asynchronous. 0, Baud Rate Formula = FOSC/[16 (n + 1)]. 1, Configuration Bits.BRGH = x. 1, BRG/AUSART Mode = Synchronous. 1, Baud Rate Formula = FOSC/[4 (n + 1)]\nLegend: x = DonGLYPH<146>t care, n = Value of SPBRG2 register",
    "EXAMPLE 17-1: CALCULATING BAUD RATE ERROR\nFor a device with FOSC of 16 MHz, desired baud rate of 9600, Asynchronous mode, BRGH = 0 :, 1 = For a device with FOSC of 16 MHz, desired baud rate of 9600, Asynchronous mode, BRGH = 0 :. For a device with FOSC of 16 MHz, desired baud rate of 9600, Asynchronous mode, BRGH = 0 :, 2 = For a device with FOSC of 16 MHz, desired baud rate of 9600, Asynchronous mode, BRGH = 0 :. Desired Baud Rate Solving for SPBRG2:, 1 = =. Desired Baud Rate Solving for SPBRG2:, 2 = FOSC/(64 ([SPBRG2] + 1)). X, 1 = =. X, 2 = ((FOSC/Desired Baud Rate)/64) GLYPH<150> 1. , 1 = =. , 2 = ((16000000/9600)/64) GLYPH<150> 1. , 1 = =. ,",
    "EXAMPLE 17-1: CALCULATING BAUD RATE ERROR\n2 = [25.042] = 25. Calculated Baud Rate, 1 = =. Calculated Baud Rate, 2 = 16000000/(64 (25 + 1)). , 1 = =. , 2 = 9615. Error, 1 = =. Error, 2 = (Calculated Baud Rate GLYPH<150> Desired Baud Rate)/Desired Baud Rate. , 1 = =. , 2 = (9615 GLYPH<150> 9600)/9600 = 0.16%",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH THE BAUD RATE GENERATOR\nTXSTA2, Bit 7 = CSRC. TXSTA2, Bit 6 = TX9. TXSTA2, Bit 5 = TXEN. TXSTA2, Bit 4 = SYNC. TXSTA2, Bit 3 = GLYPH<151>. TXSTA2, Bit 2 = BRGH. TXSTA2, Bit 1 = TRMT. TXSTA2, Bit 0 = TX9D. TXSTA2, Reset Values on Page = 63. RCSTA2, Bit 7 = SPEN. RCSTA2, Bit 6 = RX9. RCSTA2, Bit 5 = SREN. RCSTA2, Bit 4 = CREN. RCSTA2, Bit 3 = ADDEN. RCSTA2, Bit 2 = FERR. RCSTA2, Bit 1 = OERR. RCSTA2, Bit 0 = RX9D. RCSTA2, Reset Values on Page = 63. SPBRG2, Bit 7 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 6 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 5 = AUSART2 Baud Rate Generator Register.",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH THE BAUD RATE GENERATOR\nSPBRG2, Bit 4 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 3 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 2 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 1 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 0 = AUSART2 Baud Rate Generator Register. SPBRG2, Reset Values on Page = 63\nLegend: Shaded cells are not used by the BRG.",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, BRGH = 0.FOSC = 40.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, BRGH = 0.FOSC = 40.000 MHz.% Error = GLYPH<151>. 0.3, BRGH = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, BRGH = 0.FOSC = 20.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, BRGH = 0.FOSC = 20.000 MHz.% Error = GLYPH<151>. 0.3, BRGH = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, BRGH = 0.FOSC = 10.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, BRGH = 0.FOSC = 10.000 MHz.% Error =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\nGLYPH<151>. 0.3, BRGH = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, BRGH = 0.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, BRGH = 0.FOSC = 8.000 MHz.% Error = GLYPH<151>. 0.3, BRGH = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = GLYPH<151>. 1.2, BRGH = 0.FOSC = 40.000 MHz.Actual Rate (K) = GLYPH<151>. 1.2, BRGH = 0.FOSC = 40.000 MHz.% Error = GLYPH<151>. 1.2, BRGH = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = GLYPH<151>. 1.2, BRGH = 0.FOSC = 20.000",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = 1.221. 1.2, BRGH = 0.FOSC = 20.000 MHz.% Error = 1.73. 1.2, BRGH = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 255. 1.2, BRGH = 0.FOSC = 10.000 MHz.Actual Rate (K) = 1.202. 1.2, BRGH = 0.FOSC = 10.000 MHz.% Error = 0.16. 1.2, BRGH = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 1.2, BRGH = 0.FOSC = 8.000 MHz.Actual Rate (K) = 1.201. 1.2, BRGH = 0.FOSC = 8.000 MHz.% Error = -0.16. 1.2, BRGH = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 103. 2.4, BRGH = 0.FOSC =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n40.000 MHz.Actual Rate (K) = 2.441. 2.4, BRGH = 0.FOSC = 40.000 MHz.% Error = 1.73. 2.4, BRGH = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 2.4, BRGH = 0.FOSC = 20.000 MHz.Actual Rate (K) = 2.404. 2.4, BRGH = 0.FOSC = 20.000 MHz.% Error = 0.16. 2.4, BRGH = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 2.4, BRGH = 0.FOSC = 10.000 MHz.Actual Rate (K) = 2.404. 2.4, BRGH = 0.FOSC = 10.000 MHz.% Error = 0.16. 2.4, BRGH = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 64. 2.4, BRGH =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 8.000 MHz.Actual Rate (K) = 2.403. 2.4, BRGH = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, BRGH = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 9.6, BRGH = 0.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, BRGH = 0.FOSC = 40.000 MHz.% Error = 0.16. 9.6, BRGH = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 64. 9.6, BRGH = 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.766. 9.6, BRGH = 0.FOSC = 20.000 MHz.% Error = 1.73. 9.6, BRGH = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 31.",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n9.6, BRGH = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.766. 9.6, BRGH = 0.FOSC = 10.000 MHz.% Error = 1.73. 9.6, BRGH = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 15. 9.6, BRGH = 0.FOSC = 8.000 MHz.Actual Rate (K) = 9.615. 9.6, BRGH = 0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, BRGH = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 12. 19.2, BRGH = 0.FOSC = 40.000 MHz.Actual Rate (K) = 19.531. 19.2, BRGH = 0.FOSC = 40.000 MHz.% Error = 1.73. 19.2, BRGH = 0.FOSC = 40.000 MHz.SPBRG value",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = 31. 19.2, BRGH = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.531. 19.2, BRGH = 0.FOSC = 20.000 MHz.% Error = 1.73. 19.2, BRGH = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 15. 19.2, BRGH = 0.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, BRGH = 0.FOSC = 10.000 MHz.% Error = 1.73. 19.2, BRGH = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 7. 19.2, BRGH = 0.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 19.2, BRGH = 0.FOSC = 8.000 MHz.% Error = GLYPH<151>. 19.2, BRGH = 0.FOSC",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 8.000 MHz.SPBRG value (decimal) = GLYPH<151>. 57.6, BRGH = 0.FOSC = 40.000 MHz.Actual Rate (K) = 56.818. 57.6, BRGH = 0.FOSC = 40.000 MHz.% Error = -1.36. 57.6, BRGH = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 10. 57.6, BRGH = 0.FOSC = 20.000 MHz.Actual Rate (K) = 62.500. 57.6, BRGH = 0.FOSC = 20.000 MHz.% Error = 8.51. 57.6, BRGH = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 4. 57.6, BRGH = 0.FOSC = 10.000 MHz.Actual Rate (K) = 52.083. 57.6, BRGH = 0.FOSC = 10.000 MHz.% Error = -9.58.",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n57.6, BRGH = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 2. 57.6, BRGH = 0.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, BRGH = 0.FOSC = 8.000 MHz.% Error = GLYPH<151>. 57.6, BRGH = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, BRGH = 0.FOSC = 40.000 MHz.Actual Rate (K) = 125.000. 115.2, BRGH = 0.FOSC = 40.000 MHz.% Error = 8.51. 115.2, BRGH = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 4. 115.2, BRGH = 0.FOSC = 20.000 MHz.Actual Rate (K) = 104.167. 115.2, BRGH = 0.FOSC",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 20.000 MHz.% Error = -9.58. 115.2, BRGH = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 2. 115.2, BRGH = 0.FOSC = 10.000 MHz.Actual Rate (K) = 78.125. 115.2, BRGH = 0.FOSC = 10.000 MHz.% Error = -32.18. 115.2, BRGH = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 1. 115.2, BRGH = 0.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, BRGH = 0.FOSC = 8.000 MHz.% Error = GLYPH<151>. 115.2, BRGH = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = GLYPH<151>",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, BRGH = 0.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, BRGH = 0.FOSC = 4.000 MHz.% Error = 0.16. 0.3, BRGH = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 0.3, BRGH = 0.FOSC = 2.000 MHz.Actual Rate (K) = 0.300. 0.3, BRGH = 0.FOSC = 2.000 MHz.% Error = -0.16. 0.3, BRGH = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 0.3, BRGH = 0.FOSC = 1.000 MHz.Actual Rate (K) = 0.300. 0.3, BRGH = 0.FOSC = 1.000 MHz.% Error = -0.16. 0.3, BRGH = 0.FOSC = 1.000 MHz.SPBRG value",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = 51. 1.2, BRGH = 0.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, BRGH = 0.FOSC = 4.000 MHz.% Error = 0.16. 1.2, BRGH = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 1.2, BRGH = 0.FOSC = 2.000 MHz.Actual Rate (K) = 1.201. 1.2, BRGH = 0.FOSC = 2.000 MHz.% Error = -0.16. 1.2, BRGH = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 1.2, BRGH = 0.FOSC = 1.000 MHz.Actual Rate (K) = 1.201. 1.2, BRGH = 0.FOSC = 1.000 MHz.% Error = -0.16. 1.2, BRGH = 0.FOSC = 1.000",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.SPBRG value (decimal) = 12. 2.4, BRGH = 0.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, BRGH = 0.FOSC = 4.000 MHz.% Error = 0.16. 2.4, BRGH = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 2.4, BRGH = 0.FOSC = 2.000 MHz.Actual Rate (K) = 2.403. 2.4, BRGH = 0.FOSC = 2.000 MHz.% Error = -0.16. 2.4, BRGH = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 2.4, BRGH = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 2.4, BRGH = 0.FOSC = 1.000 MHz.% Error = GLYPH<151>. 2.4, BRGH =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 9.6, BRGH = 0.FOSC = 4.000 MHz.Actual Rate (K) = 8.929. 9.6, BRGH = 0.FOSC = 4.000 MHz.% Error = -6.99. 9.6, BRGH = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 6. 9.6, BRGH = 0.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 9.6, BRGH = 0.FOSC = 2.000 MHz.% Error = GLYPH<151>. 9.6, BRGH = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 9.6, BRGH = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 9.6, BRGH =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 1.000 MHz.% Error = GLYPH<151>. 9.6, BRGH = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 19.2, BRGH = 0.FOSC = 4.000 MHz.Actual Rate (K) = 20.833. 19.2, BRGH = 0.FOSC = 4.000 MHz.% Error = 8.51. 19.2, BRGH = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 2. 19.2, BRGH = 0.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 19.2, BRGH = 0.FOSC = 2.000 MHz.% Error = GLYPH<151>. 19.2, BRGH = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 19.2, BRGH = 0.FOSC =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.000 MHz.Actual Rate (K) = GLYPH<151>. 19.2, BRGH = 0.FOSC = 1.000 MHz.% Error = GLYPH<151>. 19.2, BRGH = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 57.6, BRGH = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, BRGH = 0.FOSC = 4.000 MHz.% Error = 8.51. 57.6, BRGH = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 57.6, BRGH = 0.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, BRGH = 0.FOSC = 2.000 MHz.% Error = GLYPH<151>. 57.6, BRGH = 0.FOSC = 2.000 MHz.SPBRG value",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = GLYPH<151>. 57.6, BRGH = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, BRGH = 0.FOSC = 1.000 MHz.% Error = GLYPH<151>. 57.6, BRGH = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, BRGH = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 115.2, BRGH = 0.FOSC = 4.000 MHz.% Error = -45.75. 115.2, BRGH = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 115.2, BRGH = 0.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, BRGH = 0.FOSC = 2.000 MHz.% Error =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\nGLYPH<151>. 115.2, BRGH = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, BRGH = 0.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, BRGH = 0.FOSC = 1.000 MHz.% Error = GLYPH<151>. 115.2, BRGH = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, BRGH = 1.FOSC = 40.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, BRGH = 1.FOSC = 40.000 MHz.% Error = GLYPH<151>. 0.3, BRGH = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, BRGH = 1.FOSC = 20.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, BRGH = 1.FOSC = 20.000 MHz.% Error = GLYPH<151>. 0.3, BRGH = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, BRGH = 1.FOSC = 10.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, BRGH = 1.FOSC = 10.000 MHz.% Error =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\nGLYPH<151>. 0.3, BRGH = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, BRGH = 1.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, BRGH = 1.FOSC = 8.000 MHz.% Error = GLYPH<151>. 0.3, BRGH = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = GLYPH<151>. 1.2, BRGH = 1.FOSC = 40.000 MHz.Actual Rate (K) = GLYPH<151>. 1.2, BRGH = 1.FOSC = 40.000 MHz.% Error = GLYPH<151>. 1.2, BRGH = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = GLYPH<151>. 1.2, BRGH = 1.FOSC = 20.000",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = GLYPH<151>. 1.2, BRGH = 1.FOSC = 20.000 MHz.% Error = GLYPH<151>. 1.2, BRGH = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = GLYPH<151>. 1.2, BRGH = 1.FOSC = 10.000 MHz.Actual Rate (K) = GLYPH<151>. 1.2, BRGH = 1.FOSC = 10.000 MHz.% Error = GLYPH<151>. 1.2, BRGH = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = GLYPH<151>. 1.2, BRGH = 1.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 1.2, BRGH = 1.FOSC = 8.000 MHz.% Error = GLYPH<151>. 1.2, BRGH = 1.FOSC =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n8.000 MHz.SPBRG value (decimal) = GLYPH<151>. 2.4, BRGH = 1.FOSC = 40.000 MHz.Actual Rate (K) = GLYPH<151>. 2.4, BRGH = 1.FOSC = 40.000 MHz.% Error = GLYPH<151>. 2.4, BRGH = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = GLYPH<151>. 2.4, BRGH = 1.FOSC = 20.000 MHz.Actual Rate (K) = GLYPH<151>. 2.4, BRGH = 1.FOSC = 20.000 MHz.% Error = GLYPH<151>. 2.4, BRGH = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = GLYPH<151>. 2.4, BRGH = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.441. 2.4, BRGH =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.FOSC = 10.000 MHz.% Error = 1.73. 2.4, BRGH = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 255. 2.4, BRGH = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2.403. 2.4, BRGH = 1.FOSC = 8.000 MHz.% Error = -0.16. 2.4, BRGH = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 9.6, BRGH = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.766. 9.6, BRGH = 1.FOSC = 40.000 MHz.% Error = 1.73. 9.6, BRGH = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 9.6, BRGH = 1.FOSC = 20.000 MHz.Actual Rate (K) = 9.615.",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n9.6, BRGH = 1.FOSC = 20.000 MHz.% Error = 0.16. 9.6, BRGH = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, BRGH = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, BRGH = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, BRGH = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 64. 9.6, BRGH = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9.615. 9.6, BRGH = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, BRGH = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, BRGH = 1.FOSC = 40.000 MHz.Actual Rate (K)",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 19.231. 19.2, BRGH = 1.FOSC = 40.000 MHz.% Error = 0.16. 19.2, BRGH = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 129. 19.2, BRGH = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, BRGH = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, BRGH = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, BRGH = 1.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, BRGH = 1.FOSC = 10.000 MHz.% Error = 1.73. 19.2, BRGH = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, BRGH = 1.FOSC = 8.000 MHz.Actual Rate",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(K) = 19.230. 19.2, BRGH = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, BRGH = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, BRGH = 1.FOSC = 40.000 MHz.Actual Rate (K) = 58.140. 57.6, BRGH = 1.FOSC = 40.000 MHz.% Error = 0.94. 57.6, BRGH = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 42. 57.6, BRGH = 1.FOSC = 20.000 MHz.Actual Rate (K) = 56.818. 57.6, BRGH = 1.FOSC = 20.000 MHz.% Error = -1.36. 57.6, BRGH = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 21. 57.6, BRGH = 1.FOSC =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n10.000 MHz.Actual Rate (K) = 56.818. 57.6, BRGH = 1.FOSC = 10.000 MHz.% Error = -1.36. 57.6, BRGH = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 10. 57.6, BRGH = 1.FOSC = 8.000 MHz.Actual Rate (K) = 55.555. 57.6, BRGH = 1.FOSC = 8.000 MHz.% Error = 3.55. 57.6, BRGH = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, BRGH = 1.FOSC = 40.000 MHz.Actual Rate (K) = 113.636. 115.2, BRGH = 1.FOSC = 40.000 MHz.% Error = -1.36. 115.2, BRGH = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 21. 115.2, BRGH =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, BRGH = 1.FOSC = 20.000 MHz.% Error = -1.36. 115.2, BRGH = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, BRGH = 1.FOSC = 10.000 MHz.Actual Rate (K) = 125.000. 115.2, BRGH = 1.FOSC = 10.000 MHz.% Error = 8.51. 115.2, BRGH = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 4. 115.2, BRGH = 1.FOSC = 8.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, BRGH = 1.FOSC = 8.000 MHz.% Error = GLYPH<151>. 115.2, BRGH = 1.FOSC = 8.000 MHz.SPBRG value (decimal)",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= GLYPH<151>",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, BRGH = 1.FOSC = 4.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, BRGH = 1.FOSC = 4.000 MHz.% Error = GLYPH<151>. 0.3, BRGH = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, BRGH = 1.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 0.3, BRGH = 1.FOSC = 2.000 MHz.% Error = GLYPH<151>. 0.3, BRGH = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 0.3, BRGH = 1.FOSC = 1.000 MHz.Actual Rate (K) = 0.300. 0.3, BRGH = 1.FOSC = 1.000 MHz.% Error = -0.16.",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, BRGH = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, BRGH = 1.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, BRGH = 1.FOSC = 4.000 MHz.% Error = 0.16. 1.2, BRGH = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, BRGH = 1.FOSC = 2.000 MHz.Actual Rate (K) = 1.201. 1.2, BRGH = 1.FOSC = 2.000 MHz.% Error = -0.16. 1.2, BRGH = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, BRGH = 1.FOSC = 1.000 MHz.Actual Rate (K) = 1.201. 1.2, BRGH = 1.FOSC = 1.000 MHz.% Error =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n-0.16. 1.2, BRGH = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, BRGH = 1.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, BRGH = 1.FOSC = 4.000 MHz.% Error = 0.16. 2.4, BRGH = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, BRGH = 1.FOSC = 2.000 MHz.Actual Rate (K) = 2.403. 2.4, BRGH = 1.FOSC = 2.000 MHz.% Error = -0.16. 2.4, BRGH = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, BRGH = 1.FOSC = 1.000 MHz.Actual Rate (K) = 2.403. 2.4, BRGH = 1.FOSC = 1.000",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.% Error = -0.16. 2.4, BRGH = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, BRGH = 1.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, BRGH = 1.FOSC = 4.000 MHz.% Error = 0.16. 9.6, BRGH = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, BRGH = 1.FOSC = 2.000 MHz.Actual Rate (K) = 9.615. 9.6, BRGH = 1.FOSC = 2.000 MHz.% Error = -0.16. 9.6, BRGH = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 9.6, BRGH = 1.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 9.6, BRGH =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.FOSC = 1.000 MHz.% Error = GLYPH<151>. 9.6, BRGH = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 19.2, BRGH = 1.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, BRGH = 1.FOSC = 4.000 MHz.% Error = 0.16. 19.2, BRGH = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 12. 19.2, BRGH = 1.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 19.2, BRGH = 1.FOSC = 2.000 MHz.% Error = GLYPH<151>. 19.2, BRGH = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 19.2, BRGH = 1.FOSC =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.000 MHz.Actual Rate (K) = GLYPH<151>. 19.2, BRGH = 1.FOSC = 1.000 MHz.% Error = GLYPH<151>. 19.2, BRGH = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 57.6, BRGH = 1.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, BRGH = 1.FOSC = 4.000 MHz.% Error = 8.51. 57.6, BRGH = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, BRGH = 1.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, BRGH = 1.FOSC = 2.000 MHz.% Error = GLYPH<151>. 57.6, BRGH = 1.FOSC = 2.000 MHz.SPBRG value",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = GLYPH<151>. 57.6, BRGH = 1.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 57.6, BRGH = 1.FOSC = 1.000 MHz.% Error = GLYPH<151>. 57.6, BRGH = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, BRGH = 1.FOSC = 4.000 MHz.Actual Rate (K) = 125.000. 115.2, BRGH = 1.FOSC = 4.000 MHz.% Error = 8.51. 115.2, BRGH = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 1. 115.2, BRGH = 1.FOSC = 2.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, BRGH = 1.FOSC = 2.000 MHz.% Error =",
    "TABLE 17-3: BAUD RATES FOR ASYNCHRONOUS MODES\nGLYPH<151>. 115.2, BRGH = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = GLYPH<151>. 115.2, BRGH = 1.FOSC = 1.000 MHz.Actual Rate (K) = GLYPH<151>. 115.2, BRGH = 1.FOSC = 1.000 MHz.% Error = GLYPH<151>. 115.2, BRGH = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = GLYPH<151>",
    "17.2 AUSART Asynchronous Mode\nThe Asynchronous mode of operation is selected by clearing the SYNC bit (TXSTA2<4>). In this mode, the AUSART  uses  standard  Non-Return-to-Zero  (NRZ) format (one Start bit, eight or nine data bits and one Stop bit). The most common data format is 8 bits. An on-chip, dedicated 8-bit Baud Rate Generator can be used to derive standard baud rate frequencies from the oscillator.\nThe AUSART transmits and receives the LSb first. The AUSARTGLYPH<146>s transmitter  and  receiver  are  functionally independent but use the same data format and baud rate.  The  Baud  Rate  Generator  produces  a  clock, either x16 or x64 of the bit shift rate, depending on the BRGH bit (TXSTA2<2>). Parity is not supported by the hardware  but  can  be  implemented  in  software  and stored as the 9th data bit.\nWhen operating in Asynchronous mode, the AUSART module consists of the following important elements:",
    "17.2 AUSART Asynchronous Mode\nGLYPH<149> Baud Rate Generator\nGLYPH<149> Sampling Circuit\nGLYPH<149> Asynchronous Transmitter\nGLYPH<149> Asynchronous Receiver",
    "17.2.1 AUSART ASYNCHRONOUS TRANSMITTER\nThe  AUSART transmitter  block  diagram  is  shown  in Figure 17-1. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The Shift register obtains its data from the Read/Write Transmit Buffer register, TXREG2. The TXREG2 register is loaded with data in software. The TSR register is not loaded until the Stop bit  has  been  transmitted  from  the  previous  load.  As soon as the Stop bit is transmitted, the TSR is loaded with new data from the TXREG2 register (if available).",
    "17.2.1 AUSART ASYNCHRONOUS TRANSMITTER\nOnce the TXREG2 register transfers  the data  to  the TSR register (occurs in one TCY), the TXREG2 register is empty and the TX2IF flag bit (PIR3<4>) is set. This interrupt  can  be  enabled  or  disabled  by  setting  or clearing  the  interrupt  enable  bit,  TX2IE  (PIE3<4>). TX2IF will be set regardless of the state of TX2IE; it cannot  be  cleared  in  software.  TX2IF  is  also  not cleared immediately upon loading TXREG2, but becomes valid in the second instruction cycle following the load instruction. Polling TX2IF immediately following a load of TXREG2 will return invalid results.\nWhile  TX2IF  indicates  the  status  of  the  TXREG2 register, another bit, TRMT (TXSTA2<1>), shows the status  of  the  TSR  register.  TRMT  is  a  read-only  bit which is set when the TSR register is empty. No interrupt logic is tied to this bit, so the user has to poll this bit in order to determine if the TSR register is empty.",
    "17.2.1 AUSART ASYNCHRONOUS TRANSMITTER\nNote 1: The TSR register is not mapped in data memory, so it is not available to the user.\n2: Flag  bit,  TX2IF,  is  set  when  enable  bit, TXEN is set.\nTo set up an Asynchronous Transmission:",
    "17.2.1 AUSART ASYNCHRONOUS TRANSMITTER\n1. Initialize the SPBRG2 register for the appropriate baud rate. Set or clear the BRGH bit, as required, to achieve the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit, SYNC, and setting bit, SPEN.\n3. If interrupts are desired, set enable bit, TX2IE.\n4. If 9-bit transmission is desired, set transmit bit, TX9. Can be used as address/data bit.\n5. Enable  the  transmission  by  setting  bit,  TXEN, which will also set bit, TX2IF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit, TX9D.\n7. Load  data to the TXREG2  register  (starts transmission).\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 17-4: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR3, Bit 7 = GLYPH<151>. PIR3, Bit 6 = LCDIF. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = GLYPH<151>. PIR3, Bit 2 = GLYPH<151>. PIR3, Bit 1 = GLYPH<151>. PIR3, Bit 0 = GLYPH<151>. PIR3, Reset Values on Page = 61. PIE3, Bit 7 = GLYPH<151>. PIE3, Bit 6 = LCDIE. PIE3, Bit 5 = RC2IE.",
    "TABLE 17-4: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nPIE3, Bit 4 = TX2IE. PIE3, Bit 3 = GLYPH<151>. PIE3, Bit 2 = GLYPH<151>. PIE3, Bit 1 = GLYPH<151>. PIE3, Bit 0 = GLYPH<151>. PIE3, Reset Values on Page = 61. IPR3, Bit 7 = GLYPH<151>. IPR3, Bit 6 = LCDIP. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = GLYPH<151>. IPR3, Bit 2 = GLYPH<151>. IPR3, Bit 1 = GLYPH<151>. IPR3, Bit 0 = GLYPH<151>. IPR3, Reset Values on Page = 61. RCSTA2, Bit 7 = SPEN. RCSTA2, Bit 6 = RX9. RCSTA2, Bit 5 = SREN. RCSTA2, Bit 4 = CREN. RCSTA2, Bit 3 = ADDEN. RCSTA2, Bit 2",
    "TABLE 17-4: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\n= FERR. RCSTA2, Bit 1 = OERR. RCSTA2, Bit 0 = RX9D. RCSTA2, Reset Values on Page = 63. TXREG2, Bit 7 = AUSART2 Transmit Register. TXREG2, Bit 6 = AUSART2 Transmit Register. TXREG2, Bit 5 = AUSART2 Transmit Register. TXREG2, Bit 4 = AUSART2 Transmit Register. TXREG2, Bit 3 = AUSART2 Transmit Register. TXREG2, Bit 2 = AUSART2 Transmit Register. TXREG2, Bit 1 = AUSART2 Transmit Register. TXREG2, Bit 0 = AUSART2 Transmit Register. TXREG2, Reset Values on Page = 63. TXSTA2, Bit 7 = CSRC. TXSTA2, Bit 6 = TX9. TXSTA2, Bit 5 = TXEN. TXSTA2, Bit 4 = SYNC. TXSTA2, Bit 3 = GLYPH<151>. TXSTA2, Bit 2 = BRGH. TXSTA2, Bit 1 = TRMT. TXSTA2, Bit 0 =",
    "TABLE 17-4: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nTX9D. TXSTA2, Reset Values on Page = 63. SPBRG2, Bit 7 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 6 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 5 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 4 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 3 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 2 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 1 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 0 = AUSART2 Baud Rate Generator Register. SPBRG2, Reset Values on Page = 63\nLegend: GLYPH<151> = unimplemented locations read as GLYPH<145> 0 GLYPH<146>. Shaded cells are not used for asynchronous transmission.",
    "17.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\nThe receiver block diagram is  shown in Figure 17-4. The data is received on the RX2 pin and drives the data recovery block. The data recovery block is actually a high-speed  shifter,  operating  at  x16  times  the  baud rate, whereas the main receive serial shifter operates at the bit rate or at FOSC. This mode would typically be used in RS-232 systems.\nTo set up an Asynchronous Reception:",
    "17.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize the SPBRG2 register for the appropriate baud rate. Set or clear the BRGH bit, as required, to achieve the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit, SYNC, and setting bit, SPEN.\n3. If interrupts are desired, set enable bit, RC2IE.\n4. If 9-bit reception is desired, set bit, RX9.\n5. Enable the reception by setting bit, CREN.\n6. Flag  bit,  RC2IF,  will  be  set  when  reception  is complete and an interrupt will  be  generated  if enable bit, RC2IE, was set.\n7. Read the RCSTA2 register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n8. Read  the  8-bit  received  data  by  reading  the RCREG2 register.\n9. If any error occurred, clear the error by clearing enable bit, CREN.\n10. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "17.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\nThis mode would typically be used in RS-485 systems. To  set  up  an  Asynchronous  Reception  with  Address Detect Enable:",
    "17.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize the SPBRG2 register for the appropriate baud rate.  Set or  clear  the  BRGH  and BRG16 bits,  as  required,  to  achieve  the  desired  baud rate.\n2. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n3. If interrupts are required, set the RCEN bit and select the desired priority level with the RC2IP bit.\n4. Set the RX9 bit to enable 9-bit reception.\n5. Set the ADDEN bit to enable address detect.\n6. Enable reception by setting the CREN bit.\n7. The  RC2IF  bit  will  be  set  when  reception  is complete. The interrupt will be Acknowledged if the RC2IE and GIE bits are set.\n8. Read the RCSTA2 register to determine if any error occurred during reception, as well as read bit 9 of data (if applicable).\n9. Read  RCREG2  to  determine  if  the  device  is being addressed.\n10. If any error occurred, clear the CREN bit.",
    "17.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n11. If  the  device  has  been  addressed,  clear  the ADDEN bit  to  allow  all  received  data  into  the receive buffer and interrupt the CPU.",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR3, Bit 7 = GLYPH<151>. PIR3, Bit 6 = LCDIF. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = GLYPH<151>. PIR3, Bit 2 = GLYPH<151>. PIR3, Bit 1 = GLYPH<151>. PIR3, Bit 0 = GLYPH<151>. PIR3, Reset Values on Page = 61. PIE3, Bit 7 = GLYPH<151>. PIE3, Bit 6 = LCDIE. PIE3, Bit 5 = RC2IE.",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nPIE3, Bit 4 = TX2IE. PIE3, Bit 3 = GLYPH<151>. PIE3, Bit 2 = GLYPH<151>. PIE3, Bit 1 = GLYPH<151>. PIE3, Bit 0 = GLYPH<151>. PIE3, Reset Values on Page = 61. IPR3, Bit 7 = GLYPH<151>. IPR3, Bit 6 = LCDIP. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = GLYPH<151>. IPR3, Bit 2 = GLYPH<151>. IPR3, Bit 1 = GLYPH<151>. IPR3, Bit 0 = GLYPH<151>. IPR3, Reset Values on Page = 61. RCSTA2, Bit 7 = SPEN. RCSTA2, Bit 6 = RX9. RCSTA2, Bit 5 = SREN. RCSTA2, Bit 4 = CREN. RCSTA2, Bit 3 = ADDEN. RCSTA2, Bit 2",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\n= FERR. RCSTA2, Bit 1 = OERR. RCSTA2, Bit 0 = RX9D. RCSTA2, Reset Values on Page = 63. RCREG2, Bit 7 = AUSART2 Receive Register. RCREG2, Bit 6 = AUSART2 Receive Register. RCREG2, Bit 5 = AUSART2 Receive Register. RCREG2, Bit 4 = AUSART2 Receive Register. RCREG2, Bit 3 = AUSART2 Receive Register. RCREG2, Bit 2 = AUSART2 Receive Register. RCREG2, Bit 1 = AUSART2 Receive Register. RCREG2, Bit 0 = AUSART2 Receive Register. RCREG2, Reset Values on Page = 63. TXSTA2, Bit 7 = CSRC. TXSTA2, Bit 6 = TX9. TXSTA2, Bit 5 = TXEN. TXSTA2, Bit 4 = SYNC. TXSTA2, Bit 3 = GLYPH<151>. TXSTA2, Bit 2 = BRGH. TXSTA2, Bit 1 = TRMT. TXSTA2, Bit 0 =",
    "TABLE 17-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nTX9D. TXSTA2, Reset Values on Page = 63. SPBRG2, Bit 7 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 6 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 5 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 4 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 3 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 2 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 1 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 0 = AUSART2 Baud Rate Generator Register. SPBRG2, Reset Values on Page = 63\nLegend: GLYPH<151> = unimplemented locations read as GLYPH<145> 0 GLYPH<146>. Shaded cells are not used for asynchronous reception.",
    "17.3 AUSART Synchronous Master Mode\nThe Synchronous Master mode is entered by setting the CSRC bit (TXSTA2<7>). In this mode, the data is transmitted in a half-duplex manner (i.e., transmission and reception do not occur at the same time). When transmitting  data,  the  reception  is  inhibited  and  vice versa.  Synchronous  mode  is  entered  by  setting  bit, SYNC  (TXSTA2<4>).  In  addition,  enable  bit,  SPEN (RCSTA2<7>), is set in order to configure the TX2 and RX2  pins to CK2  (clock) and  DT2  (data) lines, respectively.",
    "17.3 AUSART Synchronous Master Mode\nOnce the TXREG2 register transfers  the data  to  the TSR register (occurs in one TCYCLE), the TXREG2 is empty  and  the  TX2IF  flag  bit  (PIR3<4>)  is  set.  The interrupt can be enabled or disabled by setting or clearing the interrupt enable bit, TX2IE (PIE3<4>). TX2IF is set  regardless  of  the  state  of  enable  bit,  TX2IE;  it cannot be cleared in software. It will reset only when new data is loaded into the TXREG2 register.\nThe Master mode indicates that the processor transmits the master clock on the CK2 line.",
    "17.3.1 AUSART SYNCHRONOUS MASTER TRANSMISSION\nThe  AUSART transmitter  block  diagram  is  shown  in Figure 17-1. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The Shift register obtains its data from the Read/Write Transmit Buffer register, TXREG2. The TXREG2 register is loaded with data in software. The TSR register is not loaded until the last bit  has  been  transmitted  from  the  previous  load.  As soon as the last bit is transmitted, the TSR is loaded with new data from the TXREG2 (if available).\nWhile flag bit, TX2IF, indicates the status of the TXREG2 register,  another  bit,  TRMT  (TXSTA2<1>),  shows  the status of the TSR register. TRMT is a read-only bit which is set when the TSR is empty. No interrupt logic is tied to this bit so the user has to poll this bit in order to determine  if  the  TSR  register  is  empty.  The  TSR  is  not mapped in data memory so it is not available to the user.\nTo set up a Synchronous Master Transmission:",
    "17.3.1 AUSART SYNCHRONOUS MASTER TRANSMISSION\n1. Initialize the SPBRG2 register for the appropriate baud rate.\n2. Enable  the  synchronous  master  serial  port  by setting bits, SYNC, SPEN and CSRC.\n3. If interrupts are desired, set enable bit, TX2IE.\n4. If 9-bit transmission is desired, set bit, TX9.\n5. Enable the transmission by setting bit, TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit, TX9D.\n7. Start transmission by loading data to the TXREG2 register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 17-6: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR3, Bit 7 = GLYPH<151>. PIR3, Bit 6 = LCDIF. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = GLYPH<151>. PIR3, Bit 2 = GLYPH<151>. PIR3, Bit 1 = GLYPH<151>. PIR3, Bit 0 = GLYPH<151>. PIR3, Reset Values on Page = 61. PIE3, Bit 7 = GLYPH<151>. PIE3, Bit 6 = LCDIE. PIE3, Bit 5 = RC2IE.",
    "TABLE 17-6: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nPIE3, Bit 4 = TX2IE. PIE3, Bit 3 = GLYPH<151>. PIE3, Bit 2 = GLYPH<151>. PIE3, Bit 1 = GLYPH<151>. PIE3, Bit 0 = GLYPH<151>. PIE3, Reset Values on Page = 61. IPR3, Bit 7 = GLYPH<151>. IPR3, Bit 6 = LCDIP. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = GLYPH<151>. IPR3, Bit 2 = GLYPH<151>. IPR3, Bit 1 = GLYPH<151>. IPR3, Bit 0 = GLYPH<151>. IPR3, Reset Values on Page = 61. RCSTA2, Bit 7 = SPEN. RCSTA2, Bit 6 = RX9. RCSTA2, Bit 5 = SREN. RCSTA2, Bit 4 = CREN. RCSTA2, Bit 3 = ADDEN. RCSTA2, Bit 2",
    "TABLE 17-6: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\n= FERR. RCSTA2, Bit 1 = OERR. RCSTA2, Bit 0 = RX9D. RCSTA2, Reset Values on Page = 63. TXREG2, Bit 7 = AUSART2 Transmit Register. TXREG2, Bit 6 = AUSART2 Transmit Register. TXREG2, Bit 5 = AUSART2 Transmit Register. TXREG2, Bit 4 = AUSART2 Transmit Register. TXREG2, Bit 3 = AUSART2 Transmit Register. TXREG2, Bit 2 = AUSART2 Transmit Register. TXREG2, Bit 1 = AUSART2 Transmit Register. TXREG2, Bit 0 = AUSART2 Transmit Register. TXREG2, Reset Values on Page = 63. TXSTA2, Bit 7 = CSRC. TXSTA2, Bit 6 = TX9. TXSTA2, Bit 5 = TXEN. TXSTA2, Bit 4 = SYNC. TXSTA2, Bit 3 = GLYPH<151>. TXSTA2, Bit 2 = BRGH. TXSTA2, Bit 1 = TRMT. TXSTA2, Bit 0 =",
    "TABLE 17-6: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nTX9D. TXSTA2, Reset Values on Page = 63. SPBRG2, Bit 7 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 6 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 5 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 4 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 3 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 2 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 1 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 0 = AUSART2 Baud Rate Generator Register. SPBRG2, Reset Values on Page = 63\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used for synchronous master transmission.",
    "17.3.2 AUSART SYNCHRONOUS MASTER RECEPTION\nOnce  Synchronous  mode  is  selected,  reception  is enabled by setting either the Single Receive Enable bit, SREN  (RCSTA2<5>),  or  the  Continuous  Receive Enable bit, CREN (RCSTA2<4>). Data is sampled on the RX2 pin on the falling edge of the clock.\nIf enable  bit,  SREN,  is  set,  only  a  single  word  is received. If enable bit, CREN, is set, the reception is continuous until CREN is cleared. If both bits are set, then CREN takes precedence.\nTo set up a Synchronous Master Reception:",
    "17.3.2 AUSART SYNCHRONOUS MASTER RECEPTION\n1. Initialize the SPBRG2 register for the appropriate baud rate.\n2. Enable  the  synchronous  master  serial  port  by setting bits, SYNC, SPEN and CSRC.\n4. If interrupts are desired, set enable bit, RC2IE.\n5. If 9-bit reception is desired, set bit, RX9.\n6. If a single reception is required, set bit, SREN. For continuous reception, set bit, CREN.\n7. Interrupt flag bit, RC2IF, will be set when reception is complete and an interrupt will be generated if the enable bit, RC2IE, was set.\n8. Read the RCSTA2 register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n9. Read  the  8-bit  received  data  by  reading  the RCREG2 register.\n10. If any error occurred, clear the error by clearing bit, CREN.\n11. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.\n3. Ensure bits, CREN and SREN, are clear.",
    "FIGURE 17-8: SYNCHRONOUS RECEPTION (MASTER MODE, SREN)\nbit, Q3 Q4.Q3 Q4.Q3 Q4.Q3 Q4 = . bit, Q3 Q4.Q3 Q4.Q3 Q4.Q3 Q4 = GLYPH<145> 0 GLYPH<146>. bit, Q3 Q4.Q3 Q4.Q3 Q4.Q3 Q4 = . (Interrupt), Q3 Q4.Q3 Q4.Q3 Q4.Q3 Q4 = . Read, Q3 Q4.Q3 Q4.Q3 Q4.Q3 Q4 = . RCREG2, Q3 Q4.Q3 Q4.Q3 Q4.Q3 Q4 = . Timing diagram demonstrates Sync Master mode with bit SREN = 1 and bit BRGH = 0 ., Q3 Q4.Q3 Q4.Q3 Q4.Q3 Q4 = Timing diagram demonstrates Sync Master mode with bit SREN = 1 and bit BRGH = 0 .",
    "TABLE 17-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\n\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used for synchronous master reception.",
    "TABLE 17-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR3, Bit 7 = GLYPH<151>. PIR3, Bit 6 = LCDIF. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = GLYPH<151>. PIR3, Bit 2 = GLYPH<151>. PIR3, Bit 1 = GLYPH<151>. PIR3, Bit 0 = GLYPH<151>. PIR3, Reset Values on Page = 61. PIE3, Bit 7 = GLYPH<151>. PIE3, Bit 6 = LCDIE. PIE3, Bit 5 = RC2IE.",
    "TABLE 17-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nPIE3, Bit 4 = TX2IE. PIE3, Bit 3 = GLYPH<151>. PIE3, Bit 2 = GLYPH<151>. PIE3, Bit 1 = GLYPH<151>. PIE3, Bit 0 = GLYPH<151>. PIE3, Reset Values on Page = 61. IPR3, Bit 7 = GLYPH<151>. IPR3, Bit 6 = LCDIP. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = GLYPH<151>. IPR3, Bit 2 = GLYPH<151>. IPR3, Bit 1 = GLYPH<151>. IPR3, Bit 0 = GLYPH<151>. IPR3, Reset Values on Page = 61. RCSTA2, Bit 7 = SPEN. RCSTA2, Bit 6 = RX9. RCSTA2, Bit 5 = SREN. RCSTA2, Bit 4 = CREN. RCSTA2, Bit 3 = ADDEN. RCSTA2, Bit 2",
    "TABLE 17-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\n= FERR. RCSTA2, Bit 1 = OERR. RCSTA2, Bit 0 = RX9D. RCSTA2, Reset Values on Page = 63. RCREG2, Bit 7 = AUSART2 Receive Register. RCREG2, Bit 6 = AUSART2 Receive Register. RCREG2, Bit 5 = AUSART2 Receive Register. RCREG2, Bit 4 = AUSART2 Receive Register. RCREG2, Bit 3 = AUSART2 Receive Register. RCREG2, Bit 2 = AUSART2 Receive Register. RCREG2, Bit 1 = AUSART2 Receive Register. RCREG2, Bit 0 = AUSART2 Receive Register. RCREG2, Reset Values on Page = 63. TXSTA2, Bit 7 = CSRC. TXSTA2, Bit 6 = TX9. TXSTA2, Bit 5 = TXEN. TXSTA2, Bit 4 = SYNC. TXSTA2, Bit 3 = GLYPH<151>. TXSTA2, Bit 2 = BRGH. TXSTA2, Bit 1 = TRMT. TXSTA2, Bit 0 =",
    "TABLE 17-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nTX9D. TXSTA2, Reset Values on Page = 63. SPBRG2, Bit 7 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 6 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 5 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 4 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 3 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 2 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 1 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 0 = AUSART2 Baud Rate Generator Register. SPBRG2, Reset Values on Page = 63",
    "17.4 AUSART Synchronous Slave Mode\nSynchronous  Slave  mode  is  entered  by  clearing  bit, CSRC  (TXSTA2<7>).  This  mode  differs  from  the Synchronous  Master  mode  in  that  the  shift  clock  is supplied  externally  at  the  CK2  pin  (instead  of  being supplied  internally  in  Master  mode).  This  allows  the device to transfer or receive data while in any low-power mode.",
    "17.4.1 AUSART SYNCHRONOUS SLAVE TRANSMIT\nThe operation of the Synchronous Master and Slave modes are identical except in the  case  of  the  Sleep mode.\nIf  two words are written to the TXREG2 and then the SLEEP instruction is executed, the following will occur:\na) The  first  word  will  immediately  transfer  to  the TSR register and transmit.\nb) The  second  word  will  remain  in  the  TXREG2 register.\nc) Flag bit, TX2IF, will not be set.\nd) When the first word has been shifted out of TSR, the  TXREG2  register  will  transfer  the  second word to the TSR and flag bit, TX2IF, will now be set.\ne) If enable bit, TX2IE, is set, the interrupt will wake the  chip  from  Sleep.  If  the  global  interrupt  is enabled, the program will branch to the interrupt vector.",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR3, Bit 7 = GLYPH<151>. PIR3, Bit 6 = LCDIF. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = GLYPH<151>. PIR3, Bit 2 = GLYPH<151>. PIR3, Bit 1 = GLYPH<151>. PIR3, Bit 0 = GLYPH<151>. PIR3, Reset Values on Page = 61. PIE3, Bit 7 = GLYPH<151>. PIE3, Bit 6 = LCDIE. PIE3, Bit 5 = RC2IE.",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nPIE3, Bit 4 = TX2IE. PIE3, Bit 3 = GLYPH<151>. PIE3, Bit 2 = GLYPH<151>. PIE3, Bit 1 = GLYPH<151>. PIE3, Bit 0 = GLYPH<151>. PIE3, Reset Values on Page = 61. IPR3, Bit 7 = GLYPH<151>. IPR3, Bit 6 = LCDIP. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = GLYPH<151>. IPR3, Bit 2 = GLYPH<151>. IPR3, Bit 1 = GLYPH<151>. IPR3, Bit 0 = GLYPH<151>. IPR3, Reset Values on Page = 61. RCSTA2, Bit 7 = SPEN. RCSTA2, Bit 6 = RX9. RCSTA2, Bit 5 = SREN. RCSTA2, Bit 4 = CREN. RCSTA2, Bit 3 = ADDEN. RCSTA2, Bit 2",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\n= FERR. RCSTA2, Bit 1 = OERR. RCSTA2, Bit 0 = RX9D. RCSTA2, Reset Values on Page = 63. TXREG2, Bit 7 = AUSART2 Transmit Register. TXREG2, Bit 6 = AUSART2 Transmit Register. TXREG2, Bit 5 = AUSART2 Transmit Register. TXREG2, Bit 4 = AUSART2 Transmit Register. TXREG2, Bit 3 = AUSART2 Transmit Register. TXREG2, Bit 2 = AUSART2 Transmit Register. TXREG2, Bit 1 = AUSART2 Transmit Register. TXREG2, Bit 0 = AUSART2 Transmit Register. TXREG2, Reset Values on Page = 63. TXSTA2, Bit 7 = CSRC. TXSTA2, Bit 6 = TX9. TXSTA2, Bit 5 = TXEN. TXSTA2, Bit 4 = SYNC. TXSTA2, Bit 3 = GLYPH<151>. TXSTA2, Bit 2 = BRGH. TXSTA2, Bit 1 = TRMT. TXSTA2, Bit 0 =",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nTX9D. TXSTA2, Reset Values on Page = 63. SPBRG2, Bit 7 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 6 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 5 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 4 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 3 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 2 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 1 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 0 = AUSART2 Baud Rate Generator Register. SPBRG2, Reset Values on Page = 63\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used for synchronous slave transmission.\nTo set up a Synchronous Slave Transmission:",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\n1. Enable  the  synchronous  slave  serial  port  by setting bits, SYNC and SPEN, and clearing bit, CSRC.\n2. Clear bits, CREN and SREN.\n3. If interrupts are desired, set enable bit, TX2IE.\n4. If 9-bit transmission is desired, set bit, TX9.\n5. Enable the transmission by setting enable bit, TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit, TX9D.\n7. Start transmission by loading data to the TXREG2 register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "17.4.2 AUSART SYNCHRONOUS SLAVE RECEPTION\nTo set up a Synchronous Slave Reception:\nThe operation of the Synchronous Master and Slave modes is identical except in the case of Sleep, or any Idle  mode  and  bit  SREN,  which  is  a  GLYPH<147>donGLYPH<146>t  careGLYPH<148>  in Slave mode.\nIf  receive is enabled by setting the CREN bit prior to entering Sleep, or any Idle mode, then a word may be received while in this low-power mode. Once the word is received, the RSR register will transfer the data to the RCREG2 register; if the RC2IE enable bit is set, the interrupt generated will wake the chip from low-power mode. If the global interrupt is enabled, the program will branch to the interrupt vector.",
    "17.4.2 AUSART SYNCHRONOUS SLAVE RECEPTION\n1. Enable  the  synchronous  master  serial  port  by setting bits, SYNC and SPEN, and clearing bit, CSRC.\n2. If interrupts are desired, set enable bit, RC2IE.\n3. If 9-bit reception is desired, set bit, RX9.\n4. To enable reception, set enable bit, CREN.\n5. Flag  bit,  RC2IF,  will  be  set  when  reception  is complete.  An  interrupt will be  generated  if enable bit, RC2IE, was set.\n6. Read the RCSTA2 register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n7. Read  the  8-bit  received  data  by  reading  the RCREG2 register.\n8. If any error occurred, clear the error by clearing bit, CREN.\n9. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 17-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR3, Bit 7 = GLYPH<151>. PIR3, Bit 6 = LCDIF. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = GLYPH<151>. PIR3, Bit 2 = GLYPH<151>. PIR3, Bit 1 = GLYPH<151>. PIR3, Bit 0 = GLYPH<151>. PIR3, Reset Values on Page = 61. PIE3, Bit 7 = GLYPH<151>. PIE3, Bit 6 = LCDIE. PIE3, Bit 5 = RC2IE.",
    "TABLE 17-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nPIE3, Bit 4 = TX2IE. PIE3, Bit 3 = GLYPH<151>. PIE3, Bit 2 = GLYPH<151>. PIE3, Bit 1 = GLYPH<151>. PIE3, Bit 0 = GLYPH<151>. PIE3, Reset Values on Page = 61. IPR3, Bit 7 = GLYPH<151>. IPR3, Bit 6 = LCDIP. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = GLYPH<151>. IPR3, Bit 2 = GLYPH<151>. IPR3, Bit 1 = GLYPH<151>. IPR3, Bit 0 = GLYPH<151>. IPR3, Reset Values on Page = 61. RCSTA2, Bit 7 = SPEN. RCSTA2, Bit 6 = RX9. RCSTA2, Bit 5 = SREN. RCSTA2, Bit 4 = CREN. RCSTA2, Bit 3 = ADDEN. RCSTA2, Bit 2",
    "TABLE 17-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\n= FERR. RCSTA2, Bit 1 = OERR. RCSTA2, Bit 0 = RX9D. RCSTA2, Reset Values on Page = 63. RCREG2, Bit 7 = AUSART2 Receive Register. RCREG2, Bit 6 = AUSART2 Receive Register. RCREG2, Bit 5 = AUSART2 Receive Register. RCREG2, Bit 4 = AUSART2 Receive Register. RCREG2, Bit 3 = AUSART2 Receive Register. RCREG2, Bit 2 = AUSART2 Receive Register. RCREG2, Bit 1 = AUSART2 Receive Register. RCREG2, Bit 0 = AUSART2 Receive Register. RCREG2, Reset Values on Page = 63. TXSTA2, Bit 7 = CSRC. TXSTA2, Bit 6 = TX9. TXSTA2, Bit 5 = TXEN. TXSTA2, Bit 4 = SYNC. TXSTA2, Bit 3 = GLYPH<151>. TXSTA2, Bit 2 = BRGH. TXSTA2, Bit 1 = TRMT. TXSTA2, Bit 0 =",
    "TABLE 17-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nTX9D. TXSTA2, Reset Values on Page = 63. SPBRG2, Bit 7 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 6 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 5 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 4 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 3 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 2 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 1 = AUSART2 Baud Rate Generator Register. SPBRG2, Bit 0 = AUSART2 Baud Rate Generator Register. SPBRG2, Reset Values on Page = 63\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used for synchronous slave reception.",
    "18.0 10-BIT ANALOG-TO-DIGITAL CONVERTER (A/D) MODULE\nThe  Analog-to-Digital  (A/D)  converter  module  has 12 inputs  for the PIC18F6X90/8X90  devices.  This module allows conversion of an analog input signal to a corresponding 10-bit digital number.\nThe module has five registers:\nGLYPH<149> A/D Result High Register (ADRESH)\nGLYPH<149> A/D Result Low Register (ADRESL)\nGLYPH<149> A/D Control Register 0 (ADCON0)\nGLYPH<149> A/D Control Register 1 (ADCON1)\nGLYPH<149> A/D Control Register 2 (ADCON2)\nThe ADCON0 register, shown in Register 18-1, controls the operation of the A/D module. The ADCON1 register, shown in Register 18-2, configures the functions of the port pins. The ADCON2 register, shown  in  Register 18-3,  configures  the  A/D  clock source, programmed acquisition time and justification.",
    "REGISTER 18-1: ADCON0: A/D CONTROL REGISTER 0\nGLYPH<151>, U-0 = GLYPH<151>. GLYPH<151>, R/W-0 = CHS3. GLYPH<151>, R/W-0 = CHS2. GLYPH<151>, R/W-0 = CHS1. GLYPH<151>, R/W-0 = CHS0. GLYPH<151>, R/W-0 = GO/DONE. GLYPH<151>, R/W-0 = ADON. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 18-1: ADCON0: A/D CONTROL REGISTER 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-6 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 5-2\nCHS3:CHS0: Analog Channel Select bits\n0000 = Channel 0 (AN0)\n0001 = Channel 1 (AN1)\n0010 = Channel 2 (AN2)",
    "REGISTER 18-1: ADCON0: A/D CONTROL REGISTER 0\n0011 = Channel 3 (AN3)\n0100 = Channel 4 (AN4)\n0101 = Channel 5 (AN5)\n0110 = Channel 6 (AN6)\n0111 = Channel 7 (AN7)\n1000 = Channel 8 (AN8)\n1001 = Channel 9 (AN9)\n1010 = Channel 10 (AN10)\n1011 = Channel 11 (AN11)\n1100 = Unimplemented (1)\n1101 = Unimplemented (1)\n1110 = Unimplemented (1)\n1111 = Unimplemented (1)",
    "bit 1\nGO/DONE: A/D Conversion Status bit\nWhen ADON = 1 :\n1 = A/D conversion in progress\n0 = A/D Idle",
    "bit 0\nADON: A/D On bit\n1 = A/D converter module is enabled\n0 = A/D converter module is disabled\nNote 1: Performing a conversion on unimplemented channels will return a floating input measurement.",
    "PIC18F6390/6490/8390/8490\nREGISTER 18-2:\nADCON1: A/D CONTROL REGISTER 1",
    "PIC18F6390/6490/8390/8490\nGLYPH<151>, U-0 = GLYPH<151>. GLYPH<151>, R/W-0 = VCFG1. GLYPH<151>, R/W-0 = VCFG0. GLYPH<151>, R/W-q = PCFG3. GLYPH<151>, R/W-q = PCFG2. GLYPH<151>, R/W-q = PCFG1. GLYPH<151>, R/W-q = PCFG0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-q = bit 7 bit 0. bit 7 bit 0, R/W-q = bit 7 bit 0. bit 7 bit 0, R/W-q = bit 7 bit 0. bit 7 bit 0, R/W-q = bit 7 bit 0",
    "PIC18F6390/6490/8390/8490\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-6 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 5\nVCFG1: Voltage Reference Configuration bit (VREF- source)\n1 = VREF- (AN2)\n0 = AVSS\nbit 4\nVCFG0: Voltage Reference Configuration bit (VREF+ source)\n1 = VREF+ (AN3)\n0 = AVDD",
    "bit 3-0\nPCFG3:PCFG0: A/D Port Configuration Control bits:",
    "bit 3-0\n0000, AN11 = A. 0000, AN10 = A. 0000, AN9 = A. 0000, AN8 = A. 0000, AN7 = A. 0000, AN6 = A. 0000, AN5 = A. 0000, AN4 = A. 0000, AN3 = A. 0000, AN2 = A. 0000, AN1 = A. 0000, AN0 = A. 0001, AN11 = A. 0001, AN10 = A. 0001, AN9 = A. 0001, AN8 = A. 0001, AN7 = A. 0001, AN6 = A. 0001, AN5 = A. 0001, AN4 = A. 0001, AN3 = A. 0001, AN2 = A. 0001, AN1 = A. 0001, AN0 = A. 0010, AN11 = A. 0010, AN10 = A. 0010, AN9 = A. 0010, AN8 = A. 0010, AN7 = A. 0010, AN6 = A. 0010, AN5 = A. 0010,",
    "bit 3-0\nAN4 = A. 0010, AN3 = A. 0010, AN2 = A. 0010, AN1 = A. 0010, AN0 = A. 0011, AN11 = A. 0011, AN10 = A. 0011, AN9 = A. 0011, AN8 = A. 0011, AN7 = A. 0011, AN6 = A. 0011, AN5 = A. 0011, AN4 = A. 0011, AN3 = A. 0011, AN2 = A. 0011, AN1 = A. 0011, AN0 = A. 0100, AN11 = D. 0100, AN10 = A. 0100, AN9 = A. 0100, AN8 = A. 0100, AN7 = A. 0100, AN6 = A. 0100, AN5 = A. 0100, AN4 = A. 0100, AN3 = A. 0100, AN2 = A. 0100, AN1 = A. 0100, AN0 = A. 0101, AN11 = D. 0101, AN10 = D. 0101, AN9 =",
    "bit 3-0\nA. 0101, AN8 = A. 0101, AN7 = A. 0101, AN6 = A. 0101, AN5 = A. 0101, AN4 = A. 0101, AN3 = A. 0101, AN2 = A. 0101, AN1 = A. 0101, AN0 = A. 0110, AN11 = D. 0110, AN10 = D. 0110, AN9 = D. 0110, AN8 = A. 0110, AN7 = A. 0110, AN6 = A. 0110, AN5 = A. 0110, AN4 = A. 0110, AN3 = A. 0110, AN2 = A. 0110, AN1 = A. 0110, AN0 = A. 0111, AN11 = D. 0111, AN10 = D. 0111, AN9 = D. 0111, AN8 = D. 0111, AN7 = A. 0111, AN6 = A. 0111, AN5 = A. 0111, AN4 = A. 0111, AN3 = A. 0111, AN2 = A.",
    "bit 3-0\n0111, AN1 = A. 0111, AN0 = A. 1000, AN11 = D. 1000, AN10 = D. 1000, AN9 = D. 1000, AN8 = D. 1000, AN7 = D. 1000, AN6 = A. 1000, AN5 = A. 1000, AN4 = A. 1000, AN3 = A. 1000, AN2 = A. 1000, AN1 = A. 1000, AN0 = A. 1001, AN11 = D. 1001, AN10 = D. 1001, AN9 = D. 1001, AN8 = D. 1001, AN7 = D. 1001, AN6 = D. 1001, AN5 = A. 1001, AN4 = A. 1001, AN3 = A. 1001, AN2 = A. 1001, AN1 = A. 1001, AN0 = A. 1010, AN11 = D. 1010, AN10 = D. 1010, AN9 = D. 1010, AN8 = D. 1010, AN7 = D. 1010, AN6 = D. 1010, AN5 = D.",
    "bit 3-0\n1010, AN4 = A. 1010, AN3 = A. 1010, AN2 = A. 1010, AN1 = A. 1010, AN0 = A. 1011, AN11 = D. 1011, AN10 = D. 1011, AN9 = D. 1011, AN8 = D. 1011, AN7 = D. 1011, AN6 = D. 1011, AN5 = D. 1011, AN4 = D. 1011, AN3 = A. 1011, AN2 = A. 1011, AN1 = A. 1011, AN0 = A. 1100, AN11 = D. 1100, AN10 = D. 1100, AN9 = D. 1100, AN8 = D. 1100, AN7 = D. 1100, AN6 = D. 1100, AN5 = D. 1100, AN4 = D. 1100, AN3 = D. 1100, AN2 = A. 1100, AN1 = A. 1100, AN0 = A. 1101, AN11 = D. 1101, AN10 = D. 1101, AN9 = D. 1101, AN8 = D.",
    "bit 3-0\n1101, AN7 = D. 1101, AN6 = D. 1101, AN5 = D. 1101, AN4 = D. 1101, AN3 = D. 1101, AN2 = D. 1101, AN1 = A. 1101, AN0 = A. 1110, AN11 = D. 1110, AN10 = D. 1110, AN9 = D. 1110, AN8 = D. 1110, AN7 = D. 1110, AN6 = D. 1110, AN5 = D. 1110, AN4 = D. 1110, AN3 = D. 1110, AN2 = D. 1110, AN1 = D. 1110, AN0 = A. 1111, AN11 = D. 1111, AN10 = D. 1111, AN9 = D. 1111, AN8 = D. 1111, AN7 = D. 1111, AN6 = D. 1111, AN5 = D. 1111, AN4 = D. 1111, AN3 = D. 1111, AN2 = D. 1111, AN1 = D. 1111,",
    "bit 3-0\nAN0 = D\nA = Analog input\nD = Digital I/O",
    "PIC18F6390/6490/8390/8490\nREGISTER 18-3:\nADCON2: A/D CONTROL REGISTER 2\nADFM, U-0 = GLYPH<151>. ADFM, R/W-0 = ACQT2. ADFM, R/W-0 = ACQT1. ADFM, R/W-0 = ACQT0. ADFM, R/W-0 = ADCS2. ADFM, R/W-0 = ADCS1. ADFM, R/W-0 = ADCS0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "PIC18F6390/6490/8390/8490\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7\nADFM: A/D Result Format Select bit\n1 = Right justified\n0 = Left justified\nbit 6\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 5-3\nACQT2:ACQT0: A/D Acquisition Time Select bits\n111 = 20 TAD\n110 = 16 TAD\n101 = 12 TAD\n100 = 8 TAD\n011 = 6 TAD\n010 = 4 TAD\n001 = 2 TAD\n000 = 0 TAD (1)\nbit 2-0 ADCS2:ADCS0: A/D Conversion Clock Select bits\n111 = FRC (clock derived from A/D RC oscillator) (1)\n110 = FOSC/64\n101 = FOSC/16\n100 = FOSC/4\n011 = FRC (clock derived from A/D RC oscillator) (1)\n010 = FOSC/32\n001 = FOSC/8\n000 = FOSC/2\nNote 1: If the A/D FRC clock source is selected, a delay of one TCY (instruction cycle) is added before the A/D clock starts. This allows the SLEEP instruction to be executed before starting a conversion.",
    "PIC18F6390/6490/8390/8490\nThe analog reference voltage is software selectable to either the deviceGLYPH<146>s positive and negative supply voltage (AVDD and AVSS), or the voltage level on the RA3/AN3/VREF+/SEG17  and  RA2/AN2/VREF-/SEG16 pins.\nA device Reset forces all registers to their Reset state. This forces the A/D module to be turned off and any conversion in progress is aborted.\nThe A/D converter has a unique feature of being able to operate while the device is in Sleep mode. To operate in Sleep, the A/D conversion clock must be derived from the A/DGLYPH<146>s internal RC oscillator.\nThe output of the sample and hold is the input into the converter,  which  generates  the  result  via  successive approximation.",
    "PIC18F6390/6490/8390/8490\nEach port pin associated with the A/D converter can be configured as an analog input or as a digital I/O. The ADRESH and ADRESL registers contain the result of the A/D conversion. When the A/D conversion is complete, the result is loaded into the ADRESH/ADRESL registers, the GO/DONE bit (ADCON0<1>) is cleared and the A/D Interrupt Flag bit, ADIF, is set. The block diagram of the A/D module is shown in Figure 18-1.\nThe  value  in  the  ADRESH:ADRESL  registers  is  not modified for a Power-on Reset. The ADRESH:ADRESL registers  will  contain  unknown  data  after  a  Power-on Reset.",
    "PIC18F6390/6490/8390/8490\nAfter the A/D module has been configured as desired, the selected channel must be acquired before the conversion  is  started.  The  analog  input  channels  must have  their  corresponding  TRIS  bits  selected  as  an input. To determine acquisition time, see Section 18.1 GLYPH<147>A/D  Acquisition RequirementsGLYPH<148> .  After this acquisition  time  has  elapsed,  the  A/D  conversion  can  be started.  An  acquisition  time  can  be  programmed  to occur between setting the GO/DONE bit and the actual start of the conversion.\nThe following steps should be followed to perform an A/D conversion:",
    "PIC18F6390/6490/8390/8490\n1. Configure the A/D module:\nGLYPH<149> Configure analog pins, voltage reference and digital I/O (ADCON1)\nGLYPH<149> Select A/D input channel (ADCON0)\nGLYPH<149> Select A/D acquisition time (ADCON2)\nGLYPH<149> Select A/D conversion clock (ADCON2)\nGLYPH<149> Turn on A/D module (ADCON0)\n2. Configure A/D interrupt (if desired):\nGLYPH<149> Clear ADIF bit\nGLYPH<149> Set ADIE bit\nGLYPH<149> Set GIE bit\n3. Wait the required acquisition time (if required).\n4. Start conversion:\nGLYPH<149> Set GO/DONE bit (ADCON0<1>)\n5. Wait for A/D conversion to complete, by either:\nGLYPH<149> Polling for the GO/DONE bit to be cleared\nOR",
    "PIC18F6390/6490/8390/8490\nGLYPH<149> Waiting for the A/D interrupt\n6. Read A/D Result registers (ADRESH:ADRESL); clear ADIF bit, if required.\n7. For next conversion, go to step 1 or step 2, as required.  The  A/D  conversion  time  per  bit  is defined  as  TAD.  A  minimum  wait  of  3  TAD  is required before the next acquisition starts.",
    "18.1 A/D Acquisition Requirements\nFor the A/D converter to meet its specified accuracy, the charge holding capacitor (CHOLD) must be allowed to fully charge to the input channel voltage level. The analog  input  model  is  shown  in  Figure 18-3.  The source  impedance  (RS)  and  the  internal  sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD. The sampling switch (RSS) impedance varies over the device voltage (VDD). The source impedance affects the offset voltage at the analog input (due to pin leakage current). The maximum  recommended  impedance  for  analog sources is 2.5 k \u03a9 .  After the analog input channel is selected (changed), the channel must be sampled for at least the minimum acquisition time before starting a conversion.\nNote:, 1 = When the conversion is started, the holding capacitor is disconnected from the input pin.",
    "EQUATION 18-1: ACQUISITION TIME\nTACQ, 1 = = Amplifier Settling Time + Holding Capacitor Charging Time + Temperature Coefficient. , 1 = = TAMP + TC + TCOFF",
    "EQUATION 18-2: A/D MINIMUM CHARGING TIME\nVHOLD or, 1 = =. VHOLD or, 2 = (VREF GLYPH<150> (VREF/2048)) GLYPH<149> (1 GLYPH<150> e (-T C/CHOLD(RIC + RSS + RS)) ). TC, 1 = =. TC, 2 = -(CHOLD)(RIC + RSS + RS) ln(1/2048)",
    "EQUATION 18-3: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\nTACQ = TAMP + TC + TCOFF\nTAMP = 0.2 \u03bc s\nTCOFF\n= (Temp GLYPH<150> 25 \u00b0 C)(0.02 \u03bc s/ \u00b0 C)\n(50 C GLYPH<150> 25 \u00b0 \u00b0 C)(0.02 \u03bc s/ \u00b0 C)\n1.2 \u03bc s\nTemperature coefficient is only required for temperatures > 25 C. Below 25 C, TCOFF = 0 ms. \u00b0 \u00b0\nTC =\n-(CHOLD)(RIC + RSS + RS) ln(1/2047) \u03bc s -(25 pF) (1 k \u03a9 + 2 k \u03a9 + 2.5 k \u03a9 ) ln(0.0004883) \u03bc s 5.03 \u03bc s\nTACQ =\n0.2\n\u03bc\ns + 5\n\u03bc\ns + 1.2\n\u03bc\ns\n6.4 \u03bc s\nTo calculate the minimum acquisition time, Equation 18-1  may be  used.  This  equation  assumes that 1/2 LSb error is used (1024 steps for the A/D). The 1/2 LSb error is the maximum error allowed for the A/D to meet its specified resolution.",
    "EQUATION 18-3: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\nExample 18-3 shows the calculation  of  the  minimum required  acquisition  time,  TACQ.  This  calculation  is based on the following application system assumptions:\nCHOLD\n= 25 pF\nRs\n= 2.5 k \u03a9\nConversion Error\n\u2264 1/2 LSb\nVDD\n= 5V \u2192 Rss = 2 k \u03a9\nTemperature\n= 85 C (system max.) \u00b0",
    "18.2 Selecting and Configuring Automatic Acquisition Time\nThe  ADCON2  register  allows  the  user  to  select  an acquisition time that occurs each time the GO/DONE bit is set.\nWhen the GO/DONE bit is set, sampling is stopped and a conversion begins. The user is responsible for ensuring the required acquisition time has passed between selecting  the  desired  input  channel  and  setting  the GO/DONE bit. This occurs when the ACQT2:ACQT0 bits (ADCON2<5:3>) remain in their Reset state (GLYPH<145> 000 GLYPH<146>) and  is  compatible  with  devices  that  do  not  offer programmable acquisition times.\nIf desired,  the  ACQT  bits  can  be  set  to  select  a programmable  acquisition  time  for  the  A/D  module. When the GO/DONE bit is set, the A/D module continues  to  sample  the  input  for  the  selected  acquisition time, then automatically begins a conversion. Since the acquisition time is programmed, there may be no need to  wait  for  an  acquisition  time  between  selecting  a channel and setting the GO/DONE bit.",
    "18.3 Selecting the A/D Conversion Clock\nThe A/D conversion time per bit is defined as TAD. The A/D conversion requires 11 TAD per 10-bit conversion. The  source  of  the  A/D  conversion  clock  is  software selectable. There are seven possible options for TAD:\nGLYPH<149> 2 TOSC\nGLYPH<149> 4 TOSC\nGLYPH<149> 8 TOSC\nGLYPH<149> 16 TOSC\nGLYPH<149> 32 TOSC\nGLYPH<149> 64 TOSC\nGLYPH<149> Internal RC Oscillator\nFor correct A/D conversions, the A/D conversion clock (TAD) must be as short as possible, but greater than the minimum TAD (approximately 2 \u03bc s, see parameter 130 for more information).\nTable 18-1 shows the resultant TAD times derived from the  device  operating  frequencies  and  the  A/D  clock source selected.\nIn either case, when the conversion is completed, the GO/DONE bit is cleared, the ADIF flag is set and the A/D  begins  sampling  the  currently  selected  channel again. If  an  acquisition  time  is  programmed,  there  is nothing to indicate if the acquisition time has ended or if the conversion has begun.",
    "TABLE 18-1: TAD vs. DEVICE OPERATING FREQUENCIES\n2 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 000. 2 TOSC, Maximum Device Frequency.PIC18F6X90/8X90 = 1.25 MHz. 2 TOSC, Maximum Device Frequency.PIC18LF6X90/8X90 (4) = 666 kHz. 4 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 100. 4 TOSC, Maximum Device Frequency.PIC18F6X90/8X90 = 2.50 MHz. 4 TOSC, Maximum Device Frequency.PIC18LF6X90/8X90 (4) = 1.33 MHz. 8 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 001. 8 TOSC, Maximum Device Frequency.PIC18F6X90/8X90 = 5.00 MHz. 8 TOSC, Maximum Device Frequency.PIC18LF6X90/8X90 (4) = 2.66 MHz. 16 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 101. 16 TOSC, Maximum",
    "TABLE 18-1: TAD vs. DEVICE OPERATING FREQUENCIES\nDevice Frequency.PIC18F6X90/8X90 = 10.0 MHz. 16 TOSC, Maximum Device Frequency.PIC18LF6X90/8X90 (4) = 5.33 MHz. 32 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 010. 32 TOSC, Maximum Device Frequency.PIC18F6X90/8X90 = 20.0 MHz. 32 TOSC, Maximum Device Frequency.PIC18LF6X90/8X90 (4) = 10.65 MHz. 64 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 110. 64 TOSC, Maximum Device Frequency.PIC18F6X90/8X90 = 40.0 MHz. 64 TOSC, Maximum Device Frequency.PIC18LF6X90/8X90 (4) = 21.33 MHz. RC (3), AD Clock Source (T AD).ADCS2:ADCS0 = x11. RC (3), Maximum Device Frequency.PIC18F6X90/8X90 = 1.00 MHz (1).",
    "TABLE 18-1: TAD vs. DEVICE OPERATING FREQUENCIES\nRC (3), Maximum Device Frequency.PIC18LF6X90/8X90 (4) = 1.00 MHz (2)\nNote\n1: The RC source has a typical TAD time of 4 \u03bc s.\n2: The RC source has a typical TAD time of 6 \u03bc s.\n3: For device frequencies above 1 MHz, the device must be in Sleep for the entire conversion or the A/D accuracy may be out of specification.\n4: Low-power (PIC18LFXXXX) devices only.",
    "18.5 Configuring Analog Port Pins\nThe selection of the automatic acquisition time and A/D conversion  clock  is  determined  in  part  by  the  clock source  and  frequency  while  in  a  power-managed mode.\nIf the A/D is expected to operate while the device is in a power-managed  mode,  the  ACQT2:ACQT0  and ADCS2:ADCS0 bits in ADCON2 should be updated in accordance with the power-managed mode clock that will be  used. After the power-managed  mode  is entered,  an  A/D  acquisition  or  conversion  may  be started. Once an acquisition or conversion is started, the device should continue to be clocked by the same power-managed mode clock source until the conversion has been completed. If desired, the device may be placed  into  the  corresponding  power-managed  Idle mode during the conversion.\nIf  the  power-managed  mode  clock  frequency  is  less than  1 MHz,  the  A/D  RC  clock  source  should  be selected.",
    "18.5 Configuring Analog Port Pins\nOperation  in  the  Sleep  mode  requires  the  A/D  FRC clock to be selected. If bits, ACQT2:ACQT0, are set to GLYPH<145> 000 GLYPH<146> and a conversion is started, the conversion will be delayed one instruction cycle to allow execution of the SLEEP instruction and entry to Sleep mode. The IDLEN and  SCS  bits  in  the  OSCCON  register  must  have already been cleared prior to starting the conversion.\nThe ADCON1, TRISA and TRISF registers all configure the A/D port pins. The port pins needed as analog inputs must have their corresponding TRIS bits set (input). If the TRIS bit is cleared (output), the digital output level (VOH or VOL) will be converted.\nThe A/D operation is independent of the state of the CHS3:CHS0 bits and the TRIS bits.",
    "18.5 Configuring Analog Port Pins\nNote 1: When reading the PORT register, all pins configured as analog input channels will read as cleared (a low level). Pins configured  as  digital  inputs  will convert  an analog input. Analog levels on a digitally configured input will be accurately converted.\n2: Analog  levels  on  any  pin  defined  as  a digital  input  may  cause  the  digital  input buffer  to  consume  current  out  of  the deviceGLYPH<146>s specification limits.",
    "18.6 A/D Conversions\nFigure 18-4 shows the operation of the A/D converter after the GO/DONE  bit has been set and the ACQT2:ACQT0  bits  are  cleared.  A  conversion  is started after the following instruction to allow entry into Sleep mode before the conversion begins.\nFigure 18-5 shows the operation of the A/D converter after the GO/DONE bit has been set, the ACQT2:ACQT0 bits are set to GLYPH<145> 010 GLYPH<146>  and a 4 T AD acquisition  time  has  been  selected  before  the  conversion starts.\nAfter  the  A/D  conversion  is  completed  or  aborted,  a 2 TAD wait is required before the next acquisition can be started.  After  this  wait,  acquisition  on  the  selected channel is automatically started.\nNote:, 1 = The GO/DONE bit should NOT be set in the same instruction that turns on the A/D.",
    "18.7 Discharge\nClearing  the  GO/DONE  bit  during  a  conversion  will abort the current conversion. The A/D Result register pair will NOT be updated with the partially completed A/D conversion sample. This means the ADRESH:ADRESL  registers  will  continue  to  contain the value of the last completed conversion (or the last value written to the ADRESH:ADRESL registers).\nThe discharge phase is used to initialize the value of the  capacitor  array.  The  array  is  discharged  before every  sample.  This  feature  helps  to  optimize  the unity-gain  amplifier  as  the  circuit  always  needs  to charge the capacitor array, rather than charge/discharge based on previous measure values.\nFIGURE 18-4: A/D CONVERSION TAD CYCLES (ACQT<2:0> = 000 , TACQ = 0 )\nFIGURE 18-5: A/D CONVERSION TAD CYCLES   (ACQT<2:0> = 010 , TACQ = 4 TAD)",
    "18.8 Use of the CCP2 Trigger\nAn A/D conversion can be started by the GLYPH<147>Special Event TriggerGLYPH<148>  of  the  CCP2  module.  This  requires  that  the CCP2M3:CCP2M0  bits  (CCP2CON<3:0>)  be  programmed as GLYPH<145> 1011 GLYPH<146> and that the A/D module is enabled (ADON  bit  is  set). When  the  trigger  occurs,  the GO/DONE bit will be set, starting the A/D acquisition and conversion and the Timer1 (or Timer3) counter will be reset to zero. Timer1 (or Timer3) is reset to automatically  repeat  the  A/D  acquisition  period  with  minimal software overhead (moving ADRESH/ADRESL to the desired location). The appropriate analog input channel  must  be  selected  and  the  minimum  acquisition period  is  either  timed  by  the  user,  or  an  appropriate TACQ time selected before the GLYPH<147>Special Event TriggerGLYPH<148> sets the GO/DONE bit (starts a conversion).",
    "18.8 Use of the CCP2 Trigger\nIf the A/D module is not enabled (ADON is cleared), the GLYPH<147>S pecial Event  TriggerGLYPH<148> will  be  ignored  by  the  A/D module,  but  will  still  reset  the  Timer1  (or  Timer3) counter.",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR1, Bit 7 = GLYPH<151>. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RC1IF. PIR1, Bit 4 = TX1IF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page = 61. PIE1, Bit 7 = GLYPH<151>. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RC1IE. PIE1, Bit 4 = TX1IE.",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nPIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page = 61. IPR1, Bit 7 = GLYPH<151>. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RC1IP. IPR1, Bit 4 = TX1IP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page = 61. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = GLYPH<151>. PIR2, Bit 4 = GLYPH<151>. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 =",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nTMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Reset Values on Page = 61. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = GLYPH<151>. PIE2, Bit 4 = GLYPH<151>. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Reset Values on Page = 61. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = GLYPH<151>. IPR2, Bit 4 = GLYPH<151>. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Reset Values on Page = 61. ADRESH, Bit 7 =",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nA/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte. ADRESH, Reset Values on Page = 61. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Reset Values on Page",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH A/D OPERATION\n= 61. ADCON0, Bit 7 = GLYPH<151>. ADCON0, Bit 6 = GLYPH<151>. ADCON0, Bit 5 = CHS3. ADCON0, Bit 4 = CHS2. ADCON0, Bit 3 = CHS1. ADCON0, Bit 2 = CHS0. ADCON0, Bit 1 = GO/DONE. ADCON0, Bit 0 = ADON. ADCON0, Reset Values on Page = 61. ADCON1, Bit 7 = GLYPH<151>. ADCON1, Bit 6 = GLYPH<151>. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Reset Values on Page = 61. ADCON2, Bit 7 = ADFM. ADCON2, Bit 6 = GLYPH<151>.",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nADCON2, Bit 5 = ACQT2. ADCON2, Bit 4 = ACQT1. ADCON2, Bit 3 = ACQT0. ADCON2, Bit 2 = ADCS2. ADCON2, Bit 1 = ADCS1. ADCON2, Bit 0 = ADCS0. ADCON2, Reset Values on Page = 61. PORTA, Bit 7 = RA7 (1). PORTA, Bit 6 = RA6 (1). PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Reset Values on Page = 62. TRISA, Bit 7 = TRISA7 (1) TRISA6 (1). TRISA, Bit 6 = TRISA7 (1) TRISA6 (1). TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register.",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nTRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Reset Values on Page = 62. PORTF, Bit 7 = Read PORTF pins, Write LATF Latch. PORTF, Bit 6 = Read PORTF pins, Write LATF Latch. PORTF, Bit 5 = Read PORTF pins, Write LATF Latch. PORTF, Bit 4 = Read PORTF pins, Write LATF Latch. PORTF, Bit 3 = Read PORTF pins, Write LATF Latch. PORTF, Bit 2 = Read PORTF pins, Write LATF Latch. PORTF, Bit 1 = Read PORTF pins, Write LATF Latch. PORTF, Bit 0 = Read PORTF pins, Write LATF Latch. PORTF, Reset Values on Page = 62. TRISF, Bit 7 = PORTF Data Direction Register. TRISF, Bit 6 = PORTF Data Direction Register. TRISF, Bit 5 = PORTF Data Direction Register. TRISF, Bit 4 = PORTF Data Direction Register. TRISF, Bit 3 = PORTF Data Direction Register.",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH A/D OPERATION\nTRISF, Bit 2 = PORTF Data Direction Register. TRISF, Bit 1 = PORTF Data Direction Register. TRISF, Bit 0 = PORTF Data Direction Register. TRISF, Reset Values on Page = 62. LATF, Bit 7 = LATF Data Output Register. LATF, Bit 6 = LATF Data Output Register. LATF, Bit 5 = LATF Data Output Register. LATF, Bit 4 = LATF Data Output Register. LATF, Bit 3 = LATF Data Output Register. LATF, Bit 2 = LATF Data Output Register. LATF, Bit 1 = LATF Data Output Register. LATF, Bit 0 = LATF Data Output Register. LATF, Reset Values on Page = 62\nLegend:\nGLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used for A/D conversion.\nNote 1: These pins may be configured as port pins depending on the oscillator mode selected.",
    "19.0 COMPARATOR MODULE\nThe analog comparator module contains two comparators  that  can  be  configured  in  a  variety  of ways.  The  inputs  can  be  selected  from  the  analog inputs multiplexed with pins RF3 through RF6, as well as  the  on-chip  voltage  reference  (see Section 20.0 GLYPH<147>Comparator Voltage Reference ModuleGLYPH<148> ). The digital outputs (normal or inverted) are available at the pin level and can also be read through the control register.\nThe CMCON  register (Register 19-1) selects the comparator input and output configuration. Block diagrams of the various comparator configurations are shown in Figure 19-1.",
    "REGISTER 19-1: CMCON: COMPARATOR CONTROL REGISTER\nC2OUT, R-0 = C1OUT. C2OUT, R/W-0 = C2INV. C2OUT, R/W-0 = C1INV. C2OUT, R/W-0 = CIS. C2OUT, R/W-1 = CM2. C2OUT, R/W-1 = CM1. C2OUT, R/W-1 = CM0. bit 7, R-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-1 = bit 0",
    "REGISTER 19-1: CMCON: COMPARATOR CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7\nC2OUT : Comparator 2 Output bit\nWhen C2INV = 0 :\n1 = C2 VIN+ > C2 VIN-\n0 = C2 VIN+ < C2 VIN-\nWhen C2INV = 1 :\n1 = C2 VIN+ < C2 VIN-\n0 = C2 VIN+ > C2 VIN-\nbit 6\nC1OUT : Comparator 1 Output bit\nWhen C1INV = 0 :\n1 = C1 VIN+ > C1 VIN-\n0 = C1 VIN+ < C1 VIN-\nWhen C1INV = 1 :\n1 = C1 VIN+ < C1 VIN-\n0 = C1 VIN+ > C1 VIN-\nbit 5\nC2INV : Comparator 2 Output Inversion bit\n1 = C2 output inverted\n0 = C2 output not inverted",
    "bit 4\nC1INV : Comparator 1 Output Inversion bit\n1 = C1 Output inverted\n0 = C1 Output not inverted",
    "bit 3\nCIS : Comparator Input Switch bit\nWhen CM2:CM0 = 110 :\n1 = C1 VIN- connects to RF5/AN10\nC2 VIN- connects to RF3/AN8\n0 = C1 VIN- connects to RF6/AN11\nC2 VIN- connects to RF4/AN9",
    "bit 2-0\nCM2:CM0 : Comparator Mode bits\nFigure 19-1 shows the Comparator modes and the CM2:CM0 bit settings.",
    "19.1 Comparator Configuration\nThere are eight modes of operation for the comparators,  shown  in  Figure 19-1.  Bits,  CM2:CM0  of  the CMCON register, are used to select these modes. The TRISF  register  controls  the data direction of the comparator  pins  for  each  mode.  If  the  Comparator mode is changed, the comparator output level may not be valid for the specified mode change delay shown in Section 26.0 GLYPH<147>Electrical CharacteristicsGLYPH<148> .\nNote:, 1 = Comparator interrupts should be disabled during a Comparator mode change; otherwise, a false interrupt may occur.",
    "19.2 Comparator Operation\nA single comparator is shown in Figure 19-2, along with the  relationship  between  the  analog  input  levels  and the digital output. When the analog input at VIN+ is less than the analog input VIN-, the output of the comparator is a digital low level. When the analog input at VIN+ is greater  than  the  analog  input  VIN-,  the  output  of  the comparator is a digital high level. The shaded areas of the output of the comparator in Figure 19-2 represent the uncertainty, due to input offsets and response time.",
    "19.3 Comparator Reference\nDepending on the comparator operating mode, either an external or internal voltage reference may be used. The analog signal present at VIN- is compared to the signal at VIN+ and the digital output of the comparator is adjusted accordingly (Figure 19-2).\nFIGURE 19-2: SINGLE COMPARATOR",
    "19.3.1 EXTERNAL REFERENCE SIGNAL\nWhen  external voltage references are used, the comparator module can be configured to have the comparators operate from the same, or different reference sources. However, threshold detector applications may require the same reference. The reference signal must be between VSS and VDD and can be applied to either pin of the comparator(s).",
    "19.3.2 INTERNAL REFERENCE SIGNAL\nThe comparator module also allows the selection of an internally  generated voltage reference from the comparator  voltage  reference  module.  This  module  is described in more detail in Section 20.0 GLYPH<147>Comparator Voltage Reference ModuleGLYPH<148> .\nThe  internal  reference  is  only  available  in  the  mode where four inputs are multiplexed to two comparators (CM2:CM0 = 110 ).  In  this  mode,  the  internal  voltage reference is applied to the VIN+ pin of both comparators.",
    "19.4 Comparator Response Time\nResponse time is the minimum time, after selecting a new  reference  voltage  or  input  source,  before  the comparator output has a valid level. If the internal reference is changed, the maximum delay of the internal voltage reference must be considered when using the comparator outputs. Otherwise, the maximum delay of the  comparators  should  be  used  (see Section 26.0 GLYPH<147>Electrical CharacteristicsGLYPH<148> ).",
    "19.5 Comparator Outputs\nThe comparator outputs are read through the CMCON register.  These  bits  are  read-only.  The  comparator outputs may also be directly output to the RF2 and RF1 I/O pins. When enabled, multiplexers in the output path of the RF2 and RF1 pins will switch and the output of each  pin  will  be  the  unsynchronized  output  of  the comparator. The uncertainty of each of the comparators is related to the input offset voltage and the response time given in the specifications. Figure 19-3 shows the comparator output block diagram.\nThe TRISF bits will still function as an output enable/ disable for the RF2 and RF1 pins while in this mode.\nThe polarity of the comparator outputs can be changed using the C2INV and C1INV bits (CMCON<5:4>).",
    "19.5 Comparator Outputs\nNote 1: When reading the PORT register, all pins configured as analog inputs will read as a GLYPH<145> 0 GLYPH<146>. Pins  configured  as  digital  inputs  will convert an analog input according to the Schmitt Trigger input specification.\n2: Analog  levels  on  any  pin  defined  as  a digital input may cause the input buffer to consume more current than is specified.",
    "19.6 Comparator Interrupts\nThe comparator interrupt flag is set whenever there is a  change  in  the  output  value  of  either  comparator. Software  will  need  to  maintain  information  about  the status of the output bits, as read from CMCON<7:6>, to determine the actual change that occurred. The CMIF bit  (PIR2<6>)  is  the  Comparator  Interrupt  Flag.  The CMIF bit must be reset by clearing it. Since it is also possible  to  write  a  GLYPH<145> 1 GLYPH<146> to  this  register,  a  simulated interrupt may be initiated.",
    "19.7 Comparator Operation During Sleep\nBoth the CMIE  bit (PIE2<6>)  and  the PEIE  bit (INTCON<6>) must be set to enable the interrupt. In addition, the GIE bit (INTCON<7>) must also be set. If any of these bits are clear, the interrupt is not enabled, though  the  CMIF  bit  will  still  be  set  if  an  interrupt condition occurs.\nNote:\nIf a change in the CMCON  register (C1OUT or C2OUT) should occur when a read operation is being executed (start of the  Q2  cycle),  then  the  CMIF  (PIR2<6>) interrupt flag may not get set.\nThe user, in the Interrupt Service Routine, can clear the interrupt in the following manner:\na) Any  read  or  write  of  CMCON  will  end  the mismatch condition.\nb) Clear flag bit, CMIF.\nA mismatch condition will continue to set flag bit, CMIF. Reading CMCON will end the mismatch condition and allow flag bit, CMIF, to be cleared.",
    "19.7 Comparator Operation During Sleep\nWhen a comparator is active and the device is placed in Sleep mode, the comparator remains active and the interrupt  is  functional,  if  enabled.  This  interrupt  will wake-up the device from Sleep mode, when enabled. While  the  comparator  is  powered  up,  higher  Sleep currents than shown in the power-down current specification  will  occur.  Each  operational  comparator will consume  additional  current,  as  shown  in  the comparator specifications. To minimize power consumption while in Sleep mode, turn off the comparators (CM2:CM0 = 111 ) before entering Sleep. If the device wakes up from Sleep, the contents of the CMCON register are not affected.",
    "19.8 Effects of a Reset\nA device Reset forces the CMCON register to its Reset state,  causing  the  comparator  module  to  be  in  the Comparator Reset mode  (CM2:CM0 = 000) . This ensures  that  all  potential  inputs  are  analog  inputs. Device  current  is  minimized  when  analog  inputs  are present at Reset time. The comparators are powered down during the Reset interval.",
    "19.9 Analog Input Connection Considerations\nA  simplified  circuit  for  an  analog  input  is  shown  in Figure 19-4. Since the analog pins are connected to a digital output, they have reverse biased diodes to VDD and VSS. The analog input, therefore, must be between VSS and VDD. If the  input  voltage  deviates  from  this range by more than 0.6V in either direction, one of the diodes is forward biased and a latch-up condition may occur.  A  maximum  source  impedance  of  10 k \u03a9 is recommended  for  the  analog  sources.  Any  external component connected to an analog input pin, such as a  capacitor  or  a  Zener  diode,  should  have  very  little leakage current.",
    "TABLE 19-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nCMCON, Bit 7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Reset Values on Page = 61. CVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0. CVRCON, Reset Values on Page = 61. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 =",
    "TABLE 19-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nTMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = GLYPH<151>. PIR2, Bit 4 = GLYPH<151>. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Reset Values on Page = 61. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = GLYPH<151>. PIE2, Bit 4 = GLYPH<151>. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Reset Values on Page = 61.",
    "TABLE 19-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nIPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = GLYPH<151>. IPR2, Bit 4 = GLYPH<151>. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Reset Values on Page = 61. PORTF, Bit 7 = Read PORTF pins, Write LATF Latch. PORTF, Bit 6 = Read PORTF pins, Write LATF Latch. PORTF, Bit 5 = Read PORTF pins, Write LATF Latch. PORTF, Bit 4 = Read PORTF pins, Write LATF Latch. PORTF, Bit 3 = Read PORTF pins, Write LATF Latch. PORTF, Bit 2 = Read PORTF pins, Write LATF Latch. PORTF, Bit 1 = Read PORTF pins, Write LATF Latch. PORTF, Bit 0 = Read PORTF pins, Write LATF Latch. PORTF, Reset Values on Page =",
    "TABLE 19-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\n62. LATF, Bit 7 = LATF Data Output Register. LATF, Bit 6 = LATF Data Output Register. LATF, Bit 5 = LATF Data Output Register. LATF, Bit 4 = LATF Data Output Register. LATF, Bit 3 = LATF Data Output Register. LATF, Bit 2 = LATF Data Output Register. LATF, Bit 1 = LATF Data Output Register. LATF, Bit 0 = LATF Data Output Register. LATF, Reset Values on Page = 62. TRISF, Bit 7 = PORTF Data Direction Register. TRISF, Bit 6 = PORTF Data Direction Register. TRISF, Bit 5 = PORTF Data Direction Register. TRISF, Bit 4 = PORTF Data Direction Register. TRISF, Bit 3 = PORTF Data Direction Register. TRISF, Bit 2 = PORTF Data Direction Register. TRISF, Bit 1 = PORTF Data Direction Register. TRISF, Bit 0 = PORTF Data Direction Register. TRISF, Reset Values on Page = 62",
    "TABLE 19-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146>. Shaded cells are unused by the comparator module.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "20.0 COMPARATOR VOLTAGE REFERENCE MODULE\nThe comparator voltage reference is a 16-tap resistor ladder  network  that  provides  a  selectable  reference voltage. Although its primary purpose is to provide a reference for the analog comparators, it may also be used independently of them.\nA block diagram of the module is shown in Figure 20-1. The resistor ladder is segmented to provide two ranges of  CVREF  values  and  has  a  power-down  function  to conserve power when the reference is not being used. The moduleGLYPH<146>s  supply  reference can be provided from either device VDD/VSS, or an external voltage reference.",
    "20.1 Configuring the Comparator Voltage Reference\nused is selected by the CVRR bit (CVRCON<5>). The primary difference between the ranges is the size of the steps selected by the CVREF selection bits (CVR3:CVR0), with one range offering finer resolution. The  equations  used  to  calculate  the  output  of  the comparator voltage reference are as follows:\nIf CVRR = 1 : CVREF = ((CVR3:CVR0)/24) x CVRSRC If CVRR = 0 :\nCVREF = (CVDD x 1/4) + (((CVR3:CVR0)/32) x CVRSRC)\nThe  comparator  reference  supply  voltage  can  come from either VDD and VSS, or the external VREF+ and VREF-  that  are  multiplexed  with  RA2  and  RA3.  The voltage source is selected by the CVRSS bit (CVRCON<4>).\nThe voltage reference module is controlled through the CVRCON  register  (Register 20-1).  The  comparator voltage reference provides two ranges of output voltage, each with 16 distinct levels. The range to be",
    "20.1 Configuring the Comparator Voltage Reference\nThe settling time of the comparator voltage reference must be considered when changing the CVREF output  (see  Table 26-3  in Section 26.0  GLYPH<147>Electrical CharacteristicsGLYPH<148> ).",
    "REGISTER 20-1: CVRCON: COMPARATOR VOLTAGE REFERENCE CONTROL REGISTER\nCVREN, R/W-0 = CVROE (1). CVREN, R/W-0 = CVRR. CVREN, R/W-0 = CVRSS. CVREN, R/W-0 = CVR3. CVREN, R/W-0 = CVR2. CVREN, R/W-0 = CVR1. CVREN, R/W-0 = CVR0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 20-1: CVRCON: COMPARATOR VOLTAGE REFERENCE CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nCVREN: Comparator Voltage Reference Enable bit\n1 = CVREF circuit powered on\n0 = CVREF circuit powered down\nbit 6\nCVROE: Comparator VREF Output Enable bit (1)\n1 = CVREF voltage level is also output on the RF5/AN10/CVREF/SEG23 pin",
    "REGISTER 20-1: CVRCON: COMPARATOR VOLTAGE REFERENCE CONTROL REGISTER\n0 = CVREF voltage is disconnected from the RF5/AN10/CVREF/SEG23 pin\nbit 5\nCVRR : Comparator VREF Range Selection bit\n1 = 0.00 CVRSRC to 0.75 CVRSRC, with CVRSRC/24 step size\n0 = 0.25 CVRSRC to 0.75 CVRSRC, with CVRSRC/32 step size\nbit 4\nCVRSS: Comparator VREF Source Selection bit\n1 = Comparator reference source, CVRSRC = (VREF+) GLYPH<150> (VREF-)\n0 = Comparator reference source, CVRSRC = VDD GLYPH<150> VSS\nbit 3-0\nCVR3:CVR0: Comparator VREF Value Selection bits (0 \u2264 (CVR3:CVR0) \u2264 15)\nWhen CVRR = 1 :\nCVREF = ((CVR3:CVR0)/24)   (CVRSRC) \u2022\nWhen CVRR = 0 :",
    "REGISTER 20-1: CVRCON: COMPARATOR VOLTAGE REFERENCE CONTROL REGISTER\nCVREF = (CVRSRC/4) + ((CVR3:CVR0)/32)   (CVRSRC) \u2022\nNote 1: CVROE overrides the TRISF<5> bit setting if enabled for output; RF5 must also be configured as an input by setting TRISF<5> to GLYPH<145> 1 GLYPH<146>.",
    "20.4 Effects of a Reset\nThe full range of voltage reference cannot be realized due to the construction of the module. The transistors on the top and bottom of the resistor ladder network (Figure 20-1) keep CVREF from approaching the reference  source  rails.  The  voltage  reference  is  derived from the reference source; therefore, the CVREF output changes  with  fluctuations  in  that  source.  The  tested absolute  accuracy  of  the  voltage  reference  can  be found in Section 26.0 GLYPH<147>Electrical CharacteristicsGLYPH<148> .",
    "20.3 Operation During Sleep\nWhen  the  device  wakes  up  from  Sleep  through  an interrupt or a Watchdog Timer time-out, the contents of the  CVRCON  register  are  not  affected.  To  minimize current consumption  in Sleep mode,  the  voltage reference should be disabled.\nA  device  Reset  disables  the  voltage  reference  by clearing bit, CVREN (CVRCON<7>). This Reset also disconnects the reference from the RA2 pin by clearing bit, CVROE  (CVRCON<6>),  and  selects  the  high-voltage range by clearing bit, CVRR (CVRCON<5>). The CVR value select bits are also cleared.",
    "20.5 Connection Considerations\nThe voltage reference module operates independently of the comparator module. The output of the reference generator  may  be  connected  to  the  RF5  pin  if  the TRISF<5>  bit  and  the  CVROE  bit  are  both  set. Enabling the voltage reference output onto the RF5 pin, with  an  input  signal  present,  will  increase  current consumption. Connecting RF5 as a digital output with CVRSS enabled will also increase current consumption.\nThe RF5 pin can be used as a simple D/A output with limited drive capability. Due to the limited current drive capability, a  buffer  must  be  used  on  the  voltage reference  output  for  external  connections  to  VREF. Figure 20-2 shows an example buffering technique.",
    "TABLE 20-1: REGISTERS ASSOCIATED WITH THE COMPARATOR VOLTAGE REFERENCE\nCVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0. CVRCON, Reset Values on Page = 61. CMCON, Bit 7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Reset Values on Page = 61. TRISF, Bit 7 = PORTF Data Direction Register. TRISF, Bit 6 = PORTF Data Direction Register. TRISF, Bit 5 = PORTF Data Direction Register. TRISF, Bit 4 = PORTF Data Direction Register. TRISF, Bit 3 = PORTF Data Direction Register.",
    "TABLE 20-1: REGISTERS ASSOCIATED WITH THE COMPARATOR VOLTAGE REFERENCE\nTRISF, Bit 2 = PORTF Data Direction Register. TRISF, Bit 1 = PORTF Data Direction Register. TRISF, Bit 0 = PORTF Data Direction Register. TRISF, Reset Values on Page = 62\nLegend: Shaded cells are not used with the comparator voltage reference.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "21.0 HIGH/LOW-VOLTAGE DETECT (HLVD)\nPIC18F6390/6490/8390/8490 devices have a High/Low-Voltage Detect module (HLVD). This is a programmable circuit that allows the user to specify both a device  voltage  trip  point  and  the  direction  of  change from that point. If the device experiences an excursion past the trip point in that direction, an interrupt flag is set. If the interrupt is enabled, the program execution will  branch  to  the  interrupt  vector  address  and  the software can then respond to the interrupt.\nThe High/Low-Voltage Detect Control register (Register 21-1) completely controls the operation of the HLVD module. This allows the circuitry to be GLYPH<147>turned offGLYPH<148> by the user under software control, which minimizes the current consumption for the device.\nThe block diagram for the HLVD module is shown in Figure 21-1.",
    "REGISTER 21-1: HLVDCON: HIGH/LOW-VOLTAGE DETECT CONTROL REGISTER\nVDIRMAG, U-0 = GLYPH<151>. VDIRMAG, R-0 = IRVST. VDIRMAG, R/W-0 = HLVDEN. VDIRMAG, R/W-0 = HLVDL3 (1). VDIRMAG, R/W-1 = HLVDL2 (1). VDIRMAG, R/W-0 = HLVDL1 (1). VDIRMAG, R/W-1 = HLVDL0 (1). bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0",
    "REGISTER 21-1: HLVDCON: HIGH/LOW-VOLTAGE DETECT CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nVDIRMAG: Voltage Direction Magnitude Select bit\n1 = Event occurs when voltage equals or exceeds trip point (HLVDL3:HLVDL0)\n0 = Event occurs when voltage equals or falls below trip point (HLVDL3:HLVDL0)\nbit 6",
    "REGISTER 21-1: HLVDCON: HIGH/LOW-VOLTAGE DETECT CONTROL REGISTER\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 5\nIRVST: Internal Reference Voltage Stable Flag bit\n1 = Indicates that the voltage detect logic will generate the interrupt flag at the specified voltage range\n0 = Indicates that the voltage detect logic will not generate the interrupt flag at the specified voltage range and the HLVD interrupt should not be enabled\nbit 4\nHLVDEN: High/Low-Voltage Detect Power Enable bit\n1 = HLVD enabled\n0 = HLVD disabled\nbit 3-0\nHLVDL3:HLVDL0: Voltage Detection Limit bits (1)\n1111 = External analog input is used (input comes from the HLVDIN pin)\n1110 = 4.41V-4.87V\n1101 = 4.11V-4.55V\n1100 = 3.92V-4.34V\n1011 = 3.72V-4.12V\n1010 = 3.53V-3.91V\n1001 = 3.43V-3.79V\n1000 = 3.24V-3.58V",
    "REGISTER 21-1: HLVDCON: HIGH/LOW-VOLTAGE DETECT CONTROL REGISTER\n0111 = 2.95V-3.26V\n0110 = 2.75V-3.03V\n0101 = 2.64V-2.92V\n0100 = 2.43V-2.69V\n0011 = 2.35V-2.59V\n0010 = 2.16V-2.38V\n0001 = 1.96V-2.16V\n0000 = Reserved\nNote 1: HLVDL3:HLVDL0 modes that result in a trip point below the valid operating voltage of the device are not tested.",
    "PIC18F6390/6490/8390/8490\nThe  module  is  enabled  by  setting  the  HLVDEN  bit. Each time that the HLVD module is enabled, the circuitry requires some time to stabilize. The IRVST bit is a read-only bit and is used to indicate when the circuit is  stable.  The module can only generate an interrupt after the circuit is stable and IRVST is set.\nevent, depending on the configuration of the module. When the supply voltage is equal to the trip point, the voltage tapped off of the resistor array is equal to the internal  reference  voltage  generated  by  the  voltage reference module. The comparator then generates an interrupt signal by setting the HLVDIF bit.\nThe VDIRMAG bit determines the overall operation of the module. When VDIRMAG is cleared, the module monitors for drops in VDD below a predetermined set point. When the bit is set, the module monitors for rises in VDD above the set point.",
    "21.1 Operation\nWhen the HLVD module is enabled, a comparator uses an  internally  generated  reference  voltage  as  the  set point.  The  set  point  is  compared  with  the  trip  point where each node in the resistor divider represents a trip point voltage. The GLYPH<147>trip pointGLYPH<148> voltage is the voltage level at which the device detects a high or low-voltage\nThe trip point voltage is software programmable to any one  of 16  values. The  trip point is selected  by programming the HLVDL3:HLVDL0 bits (HLVDCON<3:0>).\nThe HLVD module has an additional feature that allows the user to supply the trip voltage to the module from an external  source.  This  mode  is  enabled  when  bits, HLVDL3:HLVDL0, are set to GLYPH<145> 1111 GLYPH<146>. In  this state, the comparator input is multiplexed from the external input pin,  HLVDIN.  This  gives  users  flexibility  because  it allows them to configure the High/Low-Voltage Detect interrupt to occur at any voltage in the valid operating range.",
    "21.1 Operation\nFIGURE 21-1: HLVD MODULE BLOCK DIAGRAM (WITH EXTERNAL INPUT)",
    "21.2 HLVD Setup\nThe following  steps  are  needed  to  set  up  the  HLVD module:\n1. Disable the module by clearing the HLVDEN bit (HLVDCON<4>).\n2. Write the value to the HLVDL3:HLVDL0 bits that selects the desired HLVD trip point.\n3. Set  the  VDIRMAG  bit  to  detect  high  voltage (VDIRMAG = 1 ) or low voltage (VDIRMAG = 0 ).\n4. Enable the HLVD module by setting the HLVDEN bit.\n5. Clear the HLVD interrupt flag (PIR2<2>), which may have been set from a previous interrupt.\n6. Enable  the  HLVD  interrupt,  if  interrupts  are desired,  by  setting  the  HLVDIE  and  GIE  bits (PIE<2> and INTCON<7>). An interrupt will not be generated until the IRVST bit is set.",
    "21.3 Current Consumption\nWhen the  module  is  enabled,  the  HLVD  comparator and voltage divider are enabled and will consume static current. The total current consumption, when enabled, is specified in electrical specification parameter #D022B.\nDepending on the application, the HLVD module does not need to be operating constantly. To decrease the current  requirements,  the  HLVD  circuitry  may  only need to be enabled for short periods where the voltage is  checked. After doing the check, the HLVD module may be disabled.",
    "21.4 HLVD Start-up Time\nThe  internal  reference  voltage  of  the  HLVD  module, specified  in  electrical  specification  parameter  #D423, may be  used  by  other  internal  circuitry,  such  as  the programmable Brown-out Reset. If the HLVD or other circuits  using  the  voltage  reference  are  disabled  to lower the deviceGLYPH<146>s current consumption, the reference voltage circuit will require time to become stable before a low or high-voltage condition can be reliably detected. This start-up time, TIRVST, is an interval that is independent of device clock speed. It is specified in electrical specification parameter 36 (Table 26-10).\nThe HLVD interrupt flag is not enabled until TIRVST has expired and a stable reference voltage is reached. For this reason, brief excursions beyond the set point may not be detected during this interval. Refer to Figure 21-2 or Figure 21-3.",
    "21.5 Applications\nIn many applications, the ability to detect a drop below, or rise above a particular threshold, is desirable. For example,  the  HLVD  module  could  be  periodically enabled to detect USB attach or detach. This assumes the device is powered by a lower voltage source than the  Universal  Serial  Bus  when  detached.  An  attach would indicate a high-voltage detect from, for example, 3.3V to 5V (the voltage on USB) and vice versa for a detach. This feature could save a design a few extra components and an attach signal (input pin).\nFIGURE 21-4: TYPICAL LOW-VOLTAGE DETECT APPLICATION\nFor general battery applications, Figure 21-4 shows a possible voltage curve. Over time, the device voltage decreases. When the device voltage reaches voltage, VA, the HLVD logic generates an interrupt at time, TA. The  interrupt  could  cause  the  execution  of  an  ISR, which would allow the application to perform GLYPH<147>housekeeping  tasksGLYPH<148> and  perform  a  controlled  shutdown before  the  device  voltage  exits  the  valid  operating range at TB. The HLVD, thus, would give the application a time window, represented by the difference between TA and TB, to safely exit.",
    "21.7 Effects of a Reset\nWhen enabled, the HLVD circuitry continues to operate during  Sleep.  If  the  device  voltage  crosses  the  trip point,  the  HLVDIF  bit  will  be  set  and  the  device  will wake-up  from  Sleep.  Device  execution  will  continue from  the  interrupt  vector  address  if  interrupts  have been globally enabled.\nA device Reset forces all registers to their Reset state. This forces the HLVD module to be turned off.",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH HIGH/LOW-VOLTAGE DETECT MODULE\nHLVDCON, Bit 7 = VDIRMAG. HLVDCON, Bit 6 = GLYPH<151>. HLVDCON, Bit 5 = IRVST. HLVDCON, Bit 4 = HLVDEN. HLVDCON, Bit 3 = HLVDL3. HLVDCON, Bit 2 = HLVDL2. HLVDCON, Bit 1 = HLVDL1. HLVDCON, Bit 0 = HLVDL0. HLVDCON, Reset Values on Page = 60. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = CMIF.",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH HIGH/LOW-VOLTAGE DETECT MODULE\nPIR2, Bit 5 = GLYPH<151>. PIR2, Bit 4 = GLYPH<151>. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = HLVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Reset Values on Page = 61. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = GLYPH<151>. PIE2, Bit 4 = GLYPH<151>. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = HLVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Reset Values on Page = 61. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = GLYPH<151>. IPR2, Bit 4 = GLYPH<151>. IPR2, Bit",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH HIGH/LOW-VOLTAGE DETECT MODULE\n3 = BCLIP. IPR2, Bit 2 = HLVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Reset Values on Page = 61\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146>. Shaded cells are unused by the HLVD module.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "22.0 LIQUID CRYSTAL DISPLAY (LCD) DRIVER MODULE\nThe Liquid Crystal Display (LCD) driver module generates  the  timing  control to drive a static or multiplexed LCD panel. In the 80-pin devices (PIC18F8390/8490), the module drives the panels of up to four commons and up to 48 segments and in the 64-pin devices (PIC18F6390/6490), the module drives the panels of up to four commons  and  up  to 32 segments. It also provides control of the LCD pixel data.\nThe LCD driver module supports:\nGLYPH<149> Direct driving of LCD panel\nGLYPH<149> Three LCD clock sources with selectable prescaler\nGLYPH<149> Up to four commons:\n-Static\n-1/2 multiplex\n-1/3 multiplex\n-1/4 multiplex\nGLYPH<149> Up to 48 (in 80-pin devices)/32 (in 64-pin devices) segments\nGLYPH<149> Static, 1/2 or 1/3 LCD bias\nA simplified block diagram of the module is shown in Figure 22-1.",
    "22.1 LCD Registers\nThe LCD driver module has 32 registers:\nused to enable or disable the LCD module. The LCD panel  can  also  operate  during  Sleep  by  clearing  the SLPEN (LCDCON<6>) bit.\nGLYPH<149> LCD Control Register (LCDCON)\nGLYPH<149> LCD Phase Register (LCDPS)\nGLYPH<149> Six LCD Segment Enable Registers (LCDSE5:LCDSE0)\nGLYPH<149> 24 LCD Data Registers (LCDDATA23:LCDDATA0)\nThe LCDPS register, shown in Register 22-2, configures the LCD clock source prescaler and the type of  waveform,  Type-A  or  Type-B.  Details  on  these features  are  provided  in Section 22.2  GLYPH<147>LCD  Clock Source SelectionGLYPH<148> , Section 22.3 GLYPH<147>LCD Bias TypesGLYPH<148> and Section 22.8 GLYPH<147>LCD Waveform GenerationGLYPH<148> .\nThe LCDCON  register, shown in Register 22-1, controls the overall operation of the module. Once the module is configured, the LCDEN (LCDCON<7>) bit is",
    "REGISTER 22-1: LCDCON: LCD CONTROL REGISTER\nLCDEN, R/W-0 = SLPEN. LCDEN, R/C-0 = WERR. LCDEN, U-0 = GLYPH<151>. LCDEN, R/W-0 = CS1. LCDEN, R/W-0 = CS0. LCDEN, R/W-0 = LMUX1. LCDEN, R/W-0 = LMUX0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/C-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 22-1: LCDCON: LCD CONTROL REGISTER\nLegend:, 1 = C = Clearable Only bit. Legend:, 2 = C = Clearable Only bit. Legend:, 3 = C = Clearable Only bit. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nLCDEN:\nLCD Driver Enable bit\n1 = LCD driver module is enabled\n0 = LCD driver module is disabled\nbit 6\nSLPEN: LCD Driver Enable in Sleep mode bit\n1 = LCD driver module is disabled in Sleep mode\n0 = LCD driver module is enabled in Sleep mode\nbit 5\nWERR: LCD Write Failed Error bit",
    "REGISTER 22-1: LCDCON: LCD CONTROL REGISTER\n1 = LCDDATAx register written while LCDPS<WA> = 0 (must be cleared in software)\n0\n= No LCD write error\nbit 4\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>",
    "bit 3-2\nCS1:CS0: Clock Source Select bits\n00 = (FOSC/4)/8192\n01 = T13CKI (Timer1)/32\n1x = INTRC (31.25 kHz)/32",
    "bit 1-0 LMUX1:LMUX0: Commons Select bits\n00, Multiplex = Static (COM0). 00, Maximum Number of Pixels (PIC18F6X90) = 32. 00, Maximum Number of Pixels (PIC18F8X90) = 48. 00, Bias = Static. 01, Multiplex = 1/2 (COM1:COM0). 01, Maximum Number of Pixels (PIC18F6X90) = 64. 01, Maximum Number of Pixels (PIC18F8X90) = 96. 01, Bias = 1/2 or 1/3. 10, Multiplex = 1/3 (COM2:COM0). 10, Maximum Number of Pixels (PIC18F6X90) = 96. 10, Maximum Number of Pixels (PIC18F8X90) = 144. 10, Bias = 1/2 or 1/3. 11, Multiplex = 1/4 (COM3:COM0). 11, Maximum Number of Pixels (PIC18F6X90) = 128. 11, Maximum Number of Pixels (PIC18F8X90) = 192. 11, Bias = 1/3",
    "REGISTER 22-2: LCDPS: LCD PHASE REGISTER\nWFT, R/W-0 = BIASMD. WFT, R-0 = LCDA. WFT, R-0 = WA. WFT, R/W-0 = LP3. WFT, R/W-0 = LP2. WFT, R/W-0 = LP1. WFT, R/W-0 = LP0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 22-2: LCDPS: LCD PHASE REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as GLYPH<145>0GLYPH<146>\n-n = Value at POR\nGLYPH<145> 1GLYPH<146> = Bit is set\nGLYPH<145> 0GLYPH<146> = Bit is cleared\nx = Bit is unknown",
    "bit 7 WFT: Waveform Type Select bit\n1 = Type-B waveform (phase changes on each frame boundary)\n0 = Type-A waveform (phase changes within each common type)",
    "bit 6\nBIASMD: Bias Mode Select bit\nWhen LMUX1:LMUX0 = 00 :\n0 = Static Bias mode (do not set this bit to GLYPH<145> 1 GLYPH<146> )\nWhen LMUX1:LMUX0 = 01 :\n1 = 1/2 Bias mode\n0 = 1/3 Bias mode\nWhen LMUX1:LMUX0 = 10 :\n1 = 1/2 Bias mode\n0 = 1/3 Bias mode\nWhen LMUX1:LMUX0 = 11 :\n0 = 1/3 Bias mode (do not set this bit to GLYPH<145> 1 GLYPH<146>)",
    "bit 5 LCDA: LCD Active Status bit\n1 = LCD driver module is active\n0 = LCD driver module is inactive",
    "bit 4\nWA: LCD Write Allow Status bit\n1 = Write into the LCDDATAx registers is allowed\n0 = Write into the LCDDATAx registers is not allowed",
    "bit 3-0 LP3:LP0: LCD Prescaler Select bits\n1111 = 1:16\n1110 = 1:15\n1101 = 1:14\n1100 = 1:13\n1011 = 1:12\n1010 = 1:11\n1001 = 1:10\n1000 = 1:9\n0111 = 1:8\n0110 = 1:7\n0101 = 1:6\n0100 = 1:5\n0011 = 1:4\n0010 = 1:3\n0001 = 1:2\n0000 = 1:1",
    "PIC18F6390/6490/8390/8490\nThe LCDSE5:LCDSE0 registers configure the functions of the port pins. Setting the segment enable bit for a particular segment configures that pin as an LCD  driver.  There  are  six  LCD  Segment  Enable registers listed in Table 22-1. The prototype LCDSEx register is shown in Register 22-3.",
    "TABLE 22-1: LCDSE REGISTERS AND ASSOCIATED SEGMENTS\nLCDSE0, Segments = 7:0. LCDSE1, Segments = 15:8. LCDSE2, Segments = 23:16. LCDSE3, Segments = 31:24. LCDSE4, Segments = 39:32. LCDSE5, Segments = 47:40\nOnce the module is initialized for the LCD panel, the individual bits of the LCDDATA23:LCDDATA0 registers are cleared or set to represent a clear or dark pixel, respectively.  Specific  sets  of  LCDDATA  registers  are used  with  specific  segments  and  common  signals. Each bit represents a unique combination of a specific segment connected to a specific common. Individual LCDDATA bits are named by the convention GLYPH<147>SxxCyGLYPH<148>, with  GLYPH<147>xxGLYPH<148> as  the  segment  number  and  GLYPH<147>yGLYPH<148> as  the common number.  The  relationship  is  summarized  in Table 22-2. The prototype LCDDATAx  register is shown in Register 22-4.\n.\nNote:",
    "TABLE 22-1: LCDSE REGISTERS AND ASSOCIATED SEGMENTS\nWriting into the registers, LCDDATA4, LCDDATA5,  LCDDATA10,  LCDDATA11, LCDDATA16,  LCDDATA17,  LCDDATA22 and LCDDATA23, in PIC18F6X90 devices will not affect the status of any pixel and these  registers  can  be  used  as  General Purpose Registers.\nNote:\nThe  LCDSE5:LCDSE4  registers  are  not implemented in PIC18F6X90 devices.",
    "REGISTER 22-3: LCDSEx: LCD SEGMENTx ENABLE REGISTER\nSE(n + 7), R/W-0 = SE(n + 6). SE(n + 7), R/W-0 = SE(n + 5). SE(n + 7), R/W-0 = SE(n + 4). SE(n + 7), R/W-0 = SE(n + 3). SE(n + 7), R/W-0 = SE(n + 2). SE(n + 7), R/W-0 = SE(n + 1). SE(n + 7), R/W-0 = SE(n). bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as GLYPH<145>0GLYPH<146>\n-n = Value at POR\nGLYPH<145> 1GLYPH<146> = Bit is set\nGLYPH<145> 0GLYPH<146> = Bit is cleared\nx = Bit is unknown\nbit 7-0\nSE(n + 7):SE(n):\nSegment Enable bits\nFor LCDSE0: n = 0\nFor LCDSE1: n = 8\nFor LCDSE2: n = 16\nFor LCDSE3: n = 24\nFor LCDSE4: n = 32\nFor LCDSE5: n = 40\n1 = Segment function of the pin is enabled, digital I/O is disabled 0 = I/O function of the pin is enabled",
    "TABLE 22-2: LCDDATA REGISTERS AND BITS FOR SEGMENT AND COM COMBINATIONS\n0 through 7, COM Lines.0 = LCDDATA0. 0 through 7, COM Lines.1 = LCDDATA6. 0 through 7, COM Lines.2 = LCDDATA12. 0 through 7, COM Lines.3 = LCDDATA18. 0 through 7, COM Lines.0 = S00C0:S07C0. 0 through 7, COM Lines.1 = S00C1:S07C1. 0 through 7, COM Lines.2 = S00C2:S07C2. 0 through 7, COM Lines.3 = S00C3:S07C3. 8 through 15, COM Lines.0 = LCDDATA1. 8 through 15, COM Lines.1 = LCDDATA7. 8 through 15, COM Lines.2 = LCDDATA13. 8 through 15, COM Lines.3 = LCDDATA19. 8 through 15, COM Lines.0 = S08C0:S15C0. 8 through 15, COM Lines.1 = S08C1:S15C1. 8 through 15, COM Lines.2",
    "TABLE 22-2: LCDDATA REGISTERS AND BITS FOR SEGMENT AND COM COMBINATIONS\n= S08C2:S15C2. 8 through 15, COM Lines.3 = S08C0:S15C3. 16 through 23, COM Lines.0 = LCDDATA2. 16 through 23, COM Lines.1 = LCDDATA8. 16 through 23, COM Lines.2 = LCDDATA14. 16 through 23, COM Lines.3 = LCDDATA20. 16 through 23, COM Lines.0 = S16C0:S23C0. 16 through 23, COM Lines.1 = S16C1:S23C1. 16 through 23, COM Lines.2 = S16C2:S23C2. 16 through 23, COM Lines.3 = S16C3:S23C3. 24 through 31, COM Lines.0 = LCDDATA3. 24 through 31, COM Lines.1 = LCDDATA9. 24 through 31, COM Lines.2 = LCDDATA15. 24 through 31, COM Lines.3 = LCDDATA21. 24 through 31, COM Lines.0 = S24C0:S31C0. 24",
    "TABLE 22-2: LCDDATA REGISTERS AND BITS FOR SEGMENT AND COM COMBINATIONS\nthrough 31, COM Lines.1 = S24C1:S31C1. 24 through 31, COM Lines.2 = S24C2:S31C2. 24 through 31, COM Lines.3 = S24C3:S31C3. 32 through 39, COM Lines.0 = LCDDATA4 (1). 32 through 39, COM Lines.1 = LCDDATA10 (1). 32 through 39, COM Lines.2 = LCDDATA16 (1). 32 through 39, COM Lines.3 = LCDDATA22 (1). 32 through 39, COM Lines.0 = S32C0:S39C0. 32 through 39, COM Lines.1 = S32C1:S39C1. 32 through 39, COM Lines.2 = S32C2:S39C2. 32 through 39, COM Lines.3 = S32C3:S39C3. 40 through 47, COM Lines.0 = LCDDATA5 (1). 40 through 47, COM Lines.1 = LCDDATA11 (1). 40 through 47, COM",
    "TABLE 22-2: LCDDATA REGISTERS AND BITS FOR SEGMENT AND COM COMBINATIONS\nLines.2 = LCDDATA17 (1). 40 through 47, COM Lines.3 = LCDDATA23 (1). 40 through 47, COM Lines.0 = S40C0:S47C0. 40 through 47, COM Lines.1 = S40C1:S47C1. 40 through 47, COM Lines.2 = S40C2:S47C2. 40 through 47, COM Lines.3 = S40C3:S47C3\nNote 1: These registers are implemented but not used as LCD data registers in 64-pin devices. They may be used as general purpose data memory.",
    "REGISTER 22-4: LCDDATAx: LCD DATAx REGISTER\nS(n + 7)Cy, R/W-0 = S(n + 6)Cy. S(n + 7)Cy, R/W-0 = S(n + 5)Cy. S(n + 7)Cy, R/W-0 = S(n + 4)Cy. S(n + 7)Cy, R/W-0 = S(n + 3)Cy. S(n + 7)Cy, R/W-0 = S(n + 2)Cy. S(n + 7)Cy, R/W-0 = S(n + 1)Cy. S(n + 7)Cy, R/W-0 = S(n)Cy. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0",
    "REGISTER 22-4: LCDDATAx: LCD DATAx REGISTER\n= bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0\nS(n + 7)Cy:S(n)Cy: Pixel On bits\nFor LCDDATA0 through LCDDATA5: n = (8x), y = 0\nFor LCDDATA6 through LCDDATA11: n = (8(x GLYPH<150> 6)), y = 1\nFor LCDDATA12 through LCDDATA17: n = (8(x GLYPH<150> 12)), y = 2\nFor LCDDATA18 through LCDDATA23: n = (8(x GLYPH<150> 18)), y = 3\n1 = Pixel on (dark)\n0 = Pixel off (clear)",
    "22.2 LCD Clock Source Selection\nThe LCD driver module has 3 possible clock sources:\nThe  third  clock  source  is  a  31.25  kHz  internal  RC oscillator/32, which  provides  approximately  1  kHz output.\nGLYPH<149> (FOSC/4)/8192\nGLYPH<149> T13CKI Clock/32\nGLYPH<149> INTRC/32\nThe first clock source is the system clock divided by 8192 ((FOSC/4)/8192). This divider ratio is chosen to provide about 1 kHz output when the system clock is 8 MHz. The divider is not programmable. Instead, the LCD prescaler bits, LCDPS<3:0>, are used to set the LCD frame clock rate.\nThe second clock source is the Timer1 oscillator/32. This also gives about 1 kHz when a 32.768 kHz crystal is  used with the Timer1 oscillator. To use the Timer1 oscillator as a clock source, the T1OSCEN (T1CON<3>) bit should be set.",
    "22.2 LCD Clock Source Selection\nThe second and third clock sources may be used to continue  running  the  LCD  while  the  processor  is  in Sleep.\nUsing the bits, CS1:CS0 (LCDCON<3:2>), any of these clock sources can be selected.",
    "22.2.1 LCD PRESCALER\nA 16-bit counter is available as a prescaler for the LCD clock. The prescaler is not directly readable or writable; its value is set by the LP3:LP0 bits (LCDPS<3:0>), which determine the prescaler assignment and prescale ratio.\nThe  prescale  values  from  1:1  through  1:32768  in power-of-2 increments are selectable.",
    "22.3 LCD Bias Types\nThe LCD driver module can be configured into three bias types:\nGLYPH<149> Static Bias (2 voltage levels: AVSS and AVDD)\nGLYPH<149> 1/2 Bias (3 voltage levels: AVSS, 1/2 AVDD and AVDD)\nGLYPH<149> 1/3 Bias (4 voltage levels: AVSS, 1/3 AVDD, 2/3 AVDD and AVDD)\nThis module  uses  an  external resistor ladder to generate the LCD bias voltages.\nThe external resistor ladder should be connected to the Bias 1 pin, Bias 2 pin, Bias 3 pin and VSS. The Bias 3 pin should also be connected to AVDD.\nFigure 22-3  shows  the  proper  way  to  connect  the resistor ladder to the Bias pins.",
    "22.4 LCD Multiplex Types\nThe  LCD  driver  module  can  be  configured  into  four multiplex types:\nGLYPH<149> Static (only COM0 used)\nGLYPH<149> 1/2 multiplex (COM0 and COM1 are used)\nGLYPH<149> 1/3 multiplex (COM0, COM1 and COM2 are used)\nGLYPH<149> 1/4 multiplex (all COM0, COM1, COM2 and COM3 are used)\nIf  the  pin  is  a  digital  I/O,  the  corresponding  TRIS  bit controls the data direction. If the pin is a COM drive, then the TRIS setting of that pin is overridden.\nNote:, 1 = OnaPower-on Reset, the LMUX1:LMUX0 bits are GLYPH<145> 00 GLYPH<146> .",
    "TABLE 22-3: PORTE<6:4> FUNCTION\n00, PORTE<6> = Digital I/O. 00, PORTE<5> = Digital I/O. 00, PORTE<4> = Digital I/O. 01, PORTE<6> = Digital I/O. 01, PORTE<5> = Digital I/O. 01, PORTE<4> = COM1 Driver. 10, PORTE<6> = Digital I/O. 10, PORTE<5> = COM2 Driver. 10, PORTE<4> = COM1 Driver. 11, PORTE<6> = COM3 Driver. 11, PORTE<5> = COM2 Driver. 11, PORTE<4> = COM1 Driver",
    "22.5 Segment Enables\nThe  LCDSEx  registers  are  used  to  select  the  pin function  for  each  segment  pin.  The  selection  allows each pin to operate as either an LCD segment driver or a digital only pin. To configure the pin as a segment pin, the corresponding bits in the LCDSEx registers must be set to GLYPH<145> 1 GLYPH<146> .\nIf  the  pin  is  a  digital  I/O,  the  corresponding  TRIS  bit controls the data direction. Any bit set in the LCDSEx registers overrides any bit settings in the corresponding TRIS register.\nThe LMUX1:LMUX0 setting decides the function of the PORTE<6:4> bits (see Table 22-3 for details).\nNote:\nOn  a  Power-on  Reset,  these  pins  are configured as digital I/O.",
    "FIGURE 22-3: LCD BIAS RESISTOR LADDER CONNECTION DIAGRAM\nVLCD 0, Static Bias = AVSS. VLCD 0, 1/2 Bias = AVSS. VLCD 0, 1/3 Bias = AVSS. VLCD 1, Static Bias = GLYPH<151>. VLCD 1, 1/2 Bias = 1/2 AVDD. VLCD 1, 1/3 Bias = 1/3 AVDD. VLCD 2, Static Bias = GLYPH<151>. VLCD 2, 1/2 Bias = 1/2 AVDD. VLCD 2, 1/3 Bias = 2/3 AVDD. VLCD 3, Static Bias = AVDD. VLCD 3, 1/2 Bias = AVDD. VLCD 3, 1/3 Bias = AVDD\n- * These values are provided for design guidance only and should be optimized for the application by the designer.",
    "22.6 Pixel Control\nThe LCDDATAx registers contain bits which define the state of each pixel. Each bit defines one unique pixel.\nTable 22-2  shows  the  correlation  of  each  bit  in  the LCDDATAx  registers  to  the  respective  common  and segment signals.\nAny LCD pixel location not being used for display can be used as general purpose RAM.",
    "22.7 LCD Frame Frequency\nThe rate at which the COM and SEG outputs changes is called the LCD frame frequency",
    "TABLE 22-4: FRAME FREQUENCY FORMULAS\nStatic, Frame Frequency = = Clock Source/(4 x 1 x (LP3:LP0 + 1)). 1/2, Frame Frequency = = Clock Source/(2 x 2 x (LP3:LP0 + 1)). 1/3, Frame Frequency = = Clock Source/(1 x 3 x (LP3:LP0 + 1)). 1/4, Frame Frequency = = Clock Source/(1 x 4 x (LP3:LP0 + 1))\nNote:\nClock source is (FOSC/4)/8192,\nTimer1 Osc/32 or INTRC/32.\nTABLE 22-5:\nAPPROXIMATE FRAME FREQUENCY (IN Hz) USING FOSC @ 32 MHz, TIMER1 @ 32.768 kHz OR INTRC OSCILLATOR",
    "TABLE 22-4: FRAME FREQUENCY FORMULAS\n1, Static = 125. 1, 1/2 = 125. 1, 1/3 = 167. 1, 1/4 = 125. 2, Static = 83. 2, 1/2 = 83. 2, 1/3 = 111. 2, 1/4 = 83. 3, Static = 62. 3, 1/2 = 62. 3, 1/3 = 83. 3, 1/4 = 62. 4, Static = 50. 4, 1/2 = 50. 4, 1/3 = 67. 4, 1/4 = 50. 5, Static = 42. 5, 1/2 = 42. 5, 1/3 = 56. 5, 1/4 = 42. 6, Static = 36. 6, 1/2 = 36. 6, 1/3 = 48. 6, 1/4 = 36. 7, Static = 31. 7, 1/2 = 31. 7, 1/3 = 42. 7, 1/4 = 31",
    "22.8 LCD Waveform Generation\nLCD waveform generation is based on the philosophy that the net AC voltage across the dark pixel should be maximized  and  the  net  AC  voltage  across  the  clear pixel should be minimized. The net DC voltage across any pixel should be zero.\nThe  COM  signal  represents  the  time  slice  for  each common, while the SEG contains the pixel data.\nThe  pixel  signal  (COM-SEG)  will  have  no  DC  component and it can take only one of the two rms values. The  higher  rms  value  will  create  a  dark  pixel  and  a lower rms value will create a clear pixel.\nAs  the  number  of  commons  increases,  the  delta between  the  two  rms  values  decreases.  The  delta represents the maximum contrast that the display can have.\nThe LCDs can be driven by two types of waveform: Type-A and Type-B. In Type-A waveform, the phase changes within each common type, whereas in Type-B waveform, the phase changes on each frame boundary.  Thus,  Type-A  waveform  maintains  0  VDC over a single frame, whereas Type-B waveform takes two frames.",
    "22.8 LCD Waveform Generation\nNote 1: If  Sleep  has  to  be  executed  with  LCD Sleep enabled (LCDCON<SLPEN>  is GLYPH<145> 1 GLYPH<146>),   then care must be taken to execute Sleep only when VDC on all the pixels is GLYPH<145> 0 GLYPH<146>.\n2: When the LCD clock source is (FOSC/4)/8192, if Sleep is executed irrespective of the LCDCON<SLPEN> setting,  the  LCD  goes  into  Sleep.  Thus, take care to see that VDC on all pixels is GLYPH<145> 0 GLYPH<146> when Sleep is executed.\nFigure 22-4  through  Figure 22-14  provide  waveforms for static, half-multiplex, one-third-multiplex and quarter-multiplex drives for Type-A and Type-B waveforms.",
    "PIC18F6390/6490/8390/8490\nFIGURE 22-5:\nTYPE-A WAVEFORMS IN 1/2 MUX, 1/2 BIAS DRIVE",
    "22.9 LCD Interrupts\nThe LCD timing generation provides an interrupt that defines  the  LCD  frame  timing.  This  interrupt  can  be used to coordinate the writing of the pixel data with the start  of  a  new  frame.  Writing  pixel  data  at  the  frame boundary allows a visually crisp transition of the image. This interrupt can also be used to synchronize external events  to  the  LCD.  For  example,  the  interface  to  an external segment  driver  can  be  synchronized  for segment data update to the LCD frame.\nA new frame is defined to begin at the leading edge of the  COM0  common  signal.  The  interrupt  will  be  set immediately after the LCD controller completes accessing all pixel data required for a frame. This will occur  at  a  fixed  interval  before  the  frame  boundary (TFINT), as shown in Figure 22-15. The LCD controller will begin to access data for the next frame within the interval from the interrupt to when the controller begins to  access  data  after  the  interrupt  (TFWR).  New  data must be written within TFWR, as this is when the LCD controller  will  begin  to  access  the  data  for  the  next frame.",
    "22.9 LCD Interrupts\nWhen the LCD driver is running with Type-B waveforms and the LMUX1:LMUX0 bits are not equal to GLYPH<145> 00 GLYPH<146> ,  there are  some  additional  issues  that  must  be  addressed. Since the DC voltage on the pixel takes two frames to maintain  zero  volts,  the  pixel  data  must  not  change between  subsequent  frames.  If  the  pixel  data  were allowed to change, the waveform for the odd frames would  not  necessarily  be  the  complement  of  the waveform  generated  in  the  even  frames  and  a  DC component would be introduced into the panel. Therefore,  when  using  Type-B  waveforms,  the  user  must synchronize the LCD pixel updates to occur within a subframe after the frame interrupt.\nTo  correctly  sequence  writing  while  in  Type-B,  the interrupt will only occur on complete phase intervals. If the user attempts to write when the write is disabled, the WERR (LCDCON<5>) bit is set.\nNote:, 1 = The interrupt is not generated when the Type-A waveform is selected and when the Type-B with no multiplex (static) is selected.",
    "22.10 Operation During Sleep\nThe LCD module can operate during Sleep. The selection is controlled by bit, SLPEN (LCDCON<6>). Setting the SLPEN bit allows the LCD module to go to Sleep. Clearing the SLPEN bit allows the module to continue to operate during Sleep.\nIf a SLEEP instruction is executed and SLPEN = 1 , the LCD module will cease all functions and go into a very low-current consumption mode. The module will stop operation  immediately  and  drive  the  minimum  LCD voltage on both segment and common lines. Figure 22-16 shows this operation.\nTo ensure that no DC component is introduced on the panel, the SLEEP instruction should  be  executed immediately  after  a  LCD  frame  boundary.  The  LCD interrupt can be used to determine the frame boundary. See Section 22.9 GLYPH<147>LCD InterruptsGLYPH<148> for the formulas to calculate the delay.",
    "22.10 Operation During Sleep\nIf a SLEEP instruction is executed and SLPEN = 0 , the module will continue to display the current contents of the LCDDATA  registers.  To  allow  the module  to continue  operation  while  in  Sleep,  the  clock  source must  be  either  the  internal  RC  oscillator  or  Timer1 external oscillator. While in Sleep, the LCD data cannot be changed. The LCD module current consumption will not decrease  in  this mode,  however,  the  overall consumption of  the  device  will  be  lower  due  to  shut down of the core and other peripheral functions.\nIf the  system  clock  is  selected  and  the  module  is programmed to not Sleep, the module will ignore the SLPEN  bit and stop operation immediately. The minimum  LCD  voltage  will  then  be  driven  onto  the segments and commons.",
    "Note:\nThe  internal RC  oscillator or external Timer1 oscillator must be used to operate the LCD module during Sleep.",
    "22.11 Configuring the LCD Module\nThe following is the sequence of steps to configure the LCD module.\n4. Write initial values  to Pixel Data  registers, LCDDATA0 through LCDDATA23.\n1. Select  the  frame  clock  prescale  using  bits, LP3:LP0 (LCDPS<3:0>).\n2. Configure  the  appropriate  pins  to  function  as segment drivers using the LCDSEx registers.\n3. Configure  the  LCD  module  for  the  following using the LCDCON register:\n-Multiplex and Bias mode, LMUX1:LMUX0 bits\n-Timing source, CS1:CS0 bits\n-Sleep mode, SLPEN bit\n5. Clear  LCD  Interrupt  Flag,  LCDIF  (PIR3<6>), and if desired, enable the interrupt by setting bit, LCDIE (PIE3<6>).\n6. Enable the LCD module by setting bit, LCDEN (LCDCON<7>).",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page = 59. PIR3, Bit 7 = GLYPH<151>. PIR3, Bit 6 = LCDIF. PIR3, Bit 5 = RC2IF. PIR3, Bit 4 = TX2IF. PIR3, Bit 3 = GLYPH<151>. PIR3, Bit 2 = GLYPH<151>. PIR3, Bit 1 = GLYPH<151>. PIR3, Bit 0 = GLYPH<151>. PIR3, Reset Values on Page = 61. PIE3, Bit 7 = GLYPH<151>. PIE3, Bit 6 = LCDIE. PIE3, Bit 5 = RC2IE. PIE3, Bit 4",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\n= TX2IE. PIE3, Bit 3 = GLYPH<151>. PIE3, Bit 2 = GLYPH<151>. PIE3, Bit 1 = GLYPH<151>. PIE3, Bit 0 = GLYPH<151>. PIE3, Reset Values on Page = 61. IPR3, Bit 7 = GLYPH<151>. IPR3, Bit 6 = LCDIP. IPR3, Bit 5 = RC2IP. IPR3, Bit 4 = TX2IP. IPR3, Bit 3 = GLYPH<151>. IPR3, Bit 2 = GLYPH<151>. IPR3, Bit 1 = GLYPH<151>. IPR3, Bit 0 = GLYPH<151>. IPR3, Reset Values on Page = 61. RCON, Bit 7 = IPEN. RCON, Bit 6 = SBOREN. RCON, Bit 5 = GLYPH<151>. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR.",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\nRCON, Bit 0 = BOR. RCON, Reset Values on Page = 60. LCDDATA23 (1), Bit 7 = S47C3. LCDDATA23 (1), Bit 6 = S46C3. LCDDATA23 (1), Bit 5 = S45C3. LCDDATA23 (1), Bit 4 = S44C3. LCDDATA23 (1), Bit 3 = S43C3. LCDDATA23 (1), Bit 2 = S42C3. LCDDATA23 (1), Bit 1 = S41C3. LCDDATA23 (1), Bit 0 = S40C3. LCDDATA23 (1), Reset Values on Page = 63. LCDDATA22 (1), Bit 7 = S39C3. LCDDATA22 (1), Bit 6 = S38C3. LCDDATA22 (1), Bit 5 = S37C3. LCDDATA22 (1), Bit 4 = S36C3. LCDDATA22 (1), Bit 3 = S35C3. LCDDATA22",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\n(1), Bit 2 = S34C3. LCDDATA22 (1), Bit 1 = S33C3. LCDDATA22 (1), Bit 0 = S32C3. LCDDATA22 (1), Reset Values on Page = 63. LCDDATA21, Bit 7 = S31C3. LCDDATA21, Bit 6 = S30C3. LCDDATA21, Bit 5 = S29C3. LCDDATA21, Bit 4 = S28C3. LCDDATA21, Bit 3 = S27C3. LCDDATA21, Bit 2 = S26C3. LCDDATA21, Bit 1 = S25C3. LCDDATA21, Bit 0 = S24C3. LCDDATA21, Reset Values on Page = 63. LCDDATA20, Bit 7 = S23C3. LCDDATA20, Bit 6 = S22C3. LCDDATA20, Bit 5 = S21C3. LCDDATA20, Bit 4 = S20C3. LCDDATA20, Bit 3 = S19C3. LCDDATA20, Bit",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\n2 = S18C3. LCDDATA20, Bit 1 = S17C3. LCDDATA20, Bit 0 = S16C3. LCDDATA20, Reset Values on Page = 63. LCDDATA19, Bit 7 = S15C3. LCDDATA19, Bit 6 = S14C3. LCDDATA19, Bit 5 = S13C3. LCDDATA19, Bit 4 = S12C3. LCDDATA19, Bit 3 = S11C3. LCDDATA19, Bit 2 = S10C3. LCDDATA19, Bit 1 = S09C3. LCDDATA19, Bit 0 = S08C3. LCDDATA19, Reset Values on Page = 63. LCDDATA18, Bit 7 = S07C3. LCDDATA18, Bit 6 = S06C3. LCDDATA18, Bit 5 = S05C3. LCDDATA18, Bit 4 = S04C3. LCDDATA18, Bit 3 = S03C3. LCDDATA18, Bit 2 =",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\nS02C3. LCDDATA18, Bit 1 = S01C3. LCDDATA18, Bit 0 = S00C3. LCDDATA18, Reset Values on Page = 63. LCDDATA17 (1), Bit 7 = S47C2. LCDDATA17 (1), Bit 6 = S46C2. LCDDATA17 (1), Bit 5 = S45C2. LCDDATA17 (1), Bit 4 = S44C2. LCDDATA17 (1), Bit 3 = S43C2. LCDDATA17 (1), Bit 2 = S42C2. LCDDATA17 (1), Bit 1 = S41C2. LCDDATA17 (1), Bit 0 = S40C2. LCDDATA17 (1), Reset Values on Page = 63. LCDDATA16 (1), Bit 7 = S39C2. LCDDATA16 (1), Bit 6 = S38C2. LCDDATA16 (1), Bit 5 = S37C2. LCDDATA16 (1), Bit 4 =",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\nS36C2. LCDDATA16 (1), Bit 3 = S35C2. LCDDATA16 (1), Bit 2 = S34C2. LCDDATA16 (1), Bit 1 = S33C2. LCDDATA16 (1), Bit 0 = S32C2. LCDDATA16 (1), Reset Values on Page = 63. LCDDATA15, Bit 7 = S31C2. LCDDATA15, Bit 6 = S30C2. LCDDATA15, Bit 5 = S29C2. LCDDATA15, Bit 4 = S28C2. LCDDATA15, Bit 3 = S27C2. LCDDATA15, Bit 2 = S26C2. LCDDATA15, Bit 1 = S25C2. LCDDATA15, Bit 0 = S24C2. LCDDATA15, Reset Values on Page = 63. LCDDATA14, Bit 7 = S23C2. LCDDATA14, Bit 6 = S22C2. LCDDATA14, Bit 5 = S21C2. LCDDATA14, Bit 4",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\n= S20C2. LCDDATA14, Bit 3 = S19C2. LCDDATA14, Bit 2 = S18C2. LCDDATA14, Bit 1 = S17C2. LCDDATA14, Bit 0 = S16C2. LCDDATA14, Reset Values on Page = 63. LCDDATA13, Bit 7 = S15C2. LCDDATA13, Bit 6 = S14C2. LCDDATA13, Bit 5 = S13C2. LCDDATA13, Bit 4 = S12C2. LCDDATA13, Bit 3 = S11C2. LCDDATA13, Bit 2 = S10C2. LCDDATA13, Bit 1 = S09C2. LCDDATA13, Bit 0 = S08C2. LCDDATA13, Reset Values on Page = 63. LCDDATA12, Bit 7 = S07C2. LCDDATA12, Bit 6 = S06C2. LCDDATA12, Bit 5 = S05C2. LCDDATA12, Bit 4 = S04C2.",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\nLCDDATA12, Bit 3 = S03C2. LCDDATA12, Bit 2 = S02C2. LCDDATA12, Bit 1 = S01C2. LCDDATA12, Bit 0 = S00C2. LCDDATA12, Reset Values on Page = 63. LCDDATA11 (1), Bit 7 = S47C1. LCDDATA11 (1), Bit 6 = S46C1. LCDDATA11 (1), Bit 5 = S45C1. LCDDATA11 (1), Bit 4 = S44C1. LCDDATA11 (1), Bit 3 = S43C1. LCDDATA11 (1), Bit 2 = S42C1. LCDDATA11 (1), Bit 1 = S41C1. LCDDATA11 (1), Bit 0 = S40C1. LCDDATA11 (1), Reset Values on Page = 63. LCDDATA10 (1), Bit 7 = S39C1. LCDDATA10 (1), Bit 6 = S38C1. LCDDATA10",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\n(1), Bit 5 = S37C1. LCDDATA10 (1), Bit 4 = S36C1. LCDDATA10 (1), Bit 3 = S35C1. LCDDATA10 (1), Bit 2 = S34C1. LCDDATA10 (1), Bit 1 = S33C1. LCDDATA10 (1), Bit 0 = S32C1. LCDDATA10 (1), Reset Values on Page = 63. LCDDATA9, Bit 7 = S31C1. LCDDATA9, Bit 6 = S30C1. LCDDATA9, Bit 5 = S29C1. LCDDATA9, Bit 4 = S28C1. LCDDATA9, Bit 3 = S27C1. LCDDATA9, Bit 2 = S26C1. LCDDATA9, Bit 1 = S25C1. LCDDATA9, Bit 0 = S24C1. LCDDATA9, Reset Values on Page = 63. LCDDATA8, Bit 7 = S23C1. LCDDATA8, Bit 6 =",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\nS22C1. LCDDATA8, Bit 5 = S21C1. LCDDATA8, Bit 4 = S20C1. LCDDATA8, Bit 3 = S19C1. LCDDATA8, Bit 2 = S18C1. LCDDATA8, Bit 1 = S17C1. LCDDATA8, Bit 0 = S16C1. LCDDATA8, Reset Values on Page = 63. LCDDATA7, Bit 7 = S15C1. LCDDATA7, Bit 6 = S14C1. LCDDATA7, Bit 5 = S13C1. LCDDATA7, Bit 4 = S12C1. LCDDATA7, Bit 3 = S11C1. LCDDATA7, Bit 2 = S10C1. LCDDATA7, Bit 1 = S09C1. LCDDATA7, Bit 0 = S08C1. LCDDATA7, Reset Values on Page = 63. LCDDATA6, Bit 7 = S07C1. LCDDATA6, Bit 6 = S06C1. LCDDATA6,",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\nBit 5 = S05C1. LCDDATA6, Bit 4 = S04C1. LCDDATA6, Bit 3 = S03C1. LCDDATA6, Bit 2 = S02C1. LCDDATA6, Bit 1 = S01C1. LCDDATA6, Bit 0 = S00C1. LCDDATA6, Reset Values on Page = 63. LCDDATA5 (1), Bit 7 = S47C0. LCDDATA5 (1), Bit 6 = S46C0. LCDDATA5 (1), Bit 5 = S45C0. LCDDATA5 (1), Bit 4 = S44C0. LCDDATA5 (1), Bit 3 = S43C0. LCDDATA5 (1), Bit 2 = S42C0. LCDDATA5 (1), Bit 1 = S41C0. LCDDATA5 (1), Bit 0 = S40C0. LCDDATA5 (1), Reset Values on Page = 63. LCDDATA4 (1), Bit 7 =",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\nS39C0. LCDDATA4 (1), Bit 6 = S38C0. LCDDATA4 (1), Bit 5 = S37C0. LCDDATA4 (1), Bit 4 = S36C0. LCDDATA4 (1), Bit 3 = S35C0. LCDDATA4 (1), Bit 2 = S34C0. LCDDATA4 (1), Bit 1 = S33C0. LCDDATA4 (1), Bit 0 = S32C0. LCDDATA4 (1), Reset Values on Page = 63. LCDDATA3, Bit 7 = S31C0. LCDDATA3, Bit 6 = S30C0. LCDDATA3, Bit 5 = S29C0. LCDDATA3, Bit 4 = S28C0. LCDDATA3, Bit 3 = S27C0. LCDDATA3, Bit 2 = S26C0. LCDDATA3, Bit 1 = S25C0. LCDDATA3, Bit 0 = S24C0. LCDDATA3, Reset Values on Page =",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\n63. LCDDATA2, Bit 7 = S23C0. LCDDATA2, Bit 6 = S22C0. LCDDATA2, Bit 5 = S21C0. LCDDATA2, Bit 4 = S20C0. LCDDATA2, Bit 3 = S19C0. LCDDATA2, Bit 2 = S18C0. LCDDATA2, Bit 1 = S17C0. LCDDATA2, Bit 0 = S16C0. LCDDATA2, Reset Values on Page = 63. LCDDATA1, Bit 7 = S15C0. LCDDATA1, Bit 6 = S14C0. LCDDATA1, Bit 5 = S13C0. LCDDATA1, Bit 4 = S12C0. LCDDATA1, Bit 3 = S11C0. LCDDATA1, Bit 2 = S10C0. LCDDATA1, Bit 1 = S09C0. LCDDATA1, Bit 0 = S08C0. LCDDATA1, Reset Values on Page = 63. LCDDATA0, Bit 7 =",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\nS07C0. LCDDATA0, Bit 6 = S06C0. LCDDATA0, Bit 5 = S05C0. LCDDATA0, Bit 4 = S04C0. LCDDATA0, Bit 3 = S03C0. LCDDATA0, Bit 2 = S02C0. LCDDATA0, Bit 1 = S01C0. LCDDATA0, Bit 0 = S00C0. LCDDATA0, Reset Values on Page = 63. LCDSE5 (2), Bit 7 = SE47. LCDSE5 (2), Bit 6 = SE46. LCDSE5 (2), Bit 5 = SE45. LCDSE5 (2), Bit 4 = SE44. LCDSE5 (2), Bit 3 = SE43. LCDSE5 (2), Bit 2 = SE42. LCDSE5 (2), Bit 1 = SE41. LCDSE5 (2), Bit 0 = SE40. LCDSE5 (2), Reset Values on Page = 64. LCDSE4 (2), Bit 7 = SE39.",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\nLCDSE4 (2), Bit 6 = SE38. LCDSE4 (2), Bit 5 = SE37. LCDSE4 (2), Bit 4 = SE36. LCDSE4 (2), Bit 3 = SE35. LCDSE4 (2), Bit 2 = SE34. LCDSE4 (2), Bit 1 = SE33. LCDSE4 (2), Bit 0 = SE32. LCDSE4 (2), Reset Values on Page = 64. LCDSE3, Bit 7 = SE31. LCDSE3, Bit 6 = SE30. LCDSE3, Bit 5 = SE29. LCDSE3, Bit 4 = SE28. LCDSE3, Bit 3 = SE27. LCDSE3, Bit 2 = SE26. LCDSE3, Bit 1 = SE25. LCDSE3, Bit 0 = SE24. LCDSE3, Reset Values on Page = 64. LCDSE2, Bit 7 = SE23. LCDSE2, Bit 6 = SE22. LCDSE2, Bit 5 = SE21. LCDSE2, Bit 4 = SE20. LCDSE2, Bit 3 = SE19.",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\nLCDSE2, Bit 2 = SE18. LCDSE2, Bit 1 = SE17. LCDSE2, Bit 0 = SE16. LCDSE2, Reset Values on Page = 64. LCDSE1, Bit 7 = SE15. LCDSE1, Bit 6 = SE14. LCDSE1, Bit 5 = SE13. LCDSE1, Bit 4 = SE12. LCDSE1, Bit 3 = SE11. LCDSE1, Bit 2 = SE10. LCDSE1, Bit 1 = SE9. LCDSE1, Bit 0 = SE8. LCDSE1, Reset Values on Page = 64. LCDSE0, Bit 7 = SE7. LCDSE0, Bit 6 = SE6. LCDSE0, Bit 5 = SE5. LCDSE0, Bit 4 = SE4. LCDSE0, Bit 3 = SE3. LCDSE0, Bit 2 = SE2. LCDSE0, Bit 1 = SE1. LCDSE0, Bit 0 = SE0. LCDSE0, Reset Values on Page = 64. LCDCON, Bit 7 = LCDEN. LCDCON, Bit 6 = SLPEN. LCDCON, Bit 5",
    "TABLE 22-6: REGISTERS ASSOCIATED WITH LCD OPERATION\n= WERR. LCDCON, Bit 4 = GLYPH<151>. LCDCON, Bit 3 = CS1. LCDCON, Bit 2 = CS0. LCDCON, Bit 1 = LMUX1. LCDCON, Bit 0 = LMUX0. LCDCON, Reset Values on Page = 64\nLegend:\nGLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146> . Shaded cells are not used for A/D conversion.\nNote 1: These registers are implemented but unused on 64-pin devices and may be used as general purpose data RAM.\n2: These registers are unimplemented on 64-pin devices.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "23.0 SPECIAL FEATURES OF THE CPU\nPIC18F6390/6490/8390/8490 devices include several features intended to maximize reliability and minimize cost through elimination of external components. These are:\nGLYPH<149> Oscillator Selection\nGLYPH<149> Resets:\n-Power-on Reset (POR)\n-Power-up Timer (PWRT)\n-Oscillator Start-up Timer (OST)\n-Brown-out Reset (BOR)\nGLYPH<149> Interrupts\nGLYPH<149> Watchdog Timer (WDT)\nGLYPH<149> Fail-Safe Clock Monitor\nGLYPH<149> Two-Speed Start-up\nGLYPH<149> Code Protection\nGLYPH<149> ID Locations\nGLYPH<149> In-Circuit Serial ProgrammingGLYPH<153> (ICSPGLYPH<153>)\nThe  oscillator  can  be  configured  for  the  application depending on frequency, power, accuracy and cost. All of  the  options  are  discussed  in  detail  in Section 2.0 GLYPH<147>Oscillator ConfigurationsGLYPH<148> .",
    "23.0 SPECIAL FEATURES OF THE CPU\nA complete discussion of device Resets and interrupts is available in previous sections of this data sheet.\nIn  addition  to  their  Power-up  and  Oscillator  Start-up Timers  provided  for  Resets,  PIC18F6390/6490/8390/ 8490 devices have a Watchdog Timer, which is either permanently  enabled  via  the  Configuration  bits,  or software controlled (if configured as disabled).\nThe inclusion of an internal RC oscillator also provides the  additional  benefits  of  a  Fail-Safe  Clock  Monitor (FSCM) and Two-Speed Start-up. FSCM provides for background  monitoring  of  the  peripheral  clock  and automatic switchover in the event of its failure.  TwoSpeed Start-up  enables  code  to  be  executed  almost immediately on start-up, while the primary clock source completes its start-up delays.\nAll  of  these  features  are  enabled  and  configured  by setting the appropriate Configuration register bits.",
    "23.1 Configuration Bits\nThe Configuration bits  can  be  programmed  (read  as GLYPH<145> 0 GLYPH<146>),  or  left unprogrammed (read as GLYPH<145> 1 GLYPH<146>),  to select various  device  configurations.  These  bits  are  mapped starting at program memory location 300000h.\nThe user will note that address 300000h is beyond the user program memory space. In fact, it belongs to the configuration memory space (300000h-3FFFFFh), which can only be accessed using table reads.",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\n300001h, File Name = CONFIG1H. 300001h, Bit 7 = IESO. 300001h, Bit 6 = FCMEN. 300001h, Bit 5 = GLYPH<151>. 300001h, Bit 4 = GLYPH<151>. 300001h, Bit 3 = FOSC3. 300001h, Bit 2 = FOSC2. 300001h, Bit 1 = FOSC1. 300001h, Bit 0 = FOSC0. 300001h, Default/ Unprogrammed Value = 00--. 300001h, Default/ Unprogrammed Value = 0111. 300002h, File Name = CONFIG2L. 300002h, Bit 7 = GLYPH<151>. 300002h, Bit 6 = GLYPH<151>. 300002h, Bit 5 = GLYPH<151>. 300002h, Bit 4 = BORV1. 300002h, Bit 3 = BORV0. 300002h, Bit 2 = BOREN1. 300002h, Bit 1 =",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\nBOREN0. 300002h, Bit 0 = PWRTEN. 300002h, Default/ Unprogrammed Value = ---1. 300002h, Default/ Unprogrammed Value = 1111. 300003h, File Name = CONFIG2H. 300003h, Bit 7 = GLYPH<151>. 300003h, Bit 6 = GLYPH<151>. 300003h, Bit 5 = GLYPH<151>. 300003h, Bit 4 = WDTPS3. 300003h, Bit 3 = WDTPS2. 300003h, Bit 2 = WDTPS1. 300003h, Bit 1 = WDTPS0. 300003h, Bit 0 = WDTEN. 300003h, Default/ Unprogrammed Value = ---1. 300003h, Default/ Unprogrammed Value = 1111. 300005h, File Name = CONFIG3H. 300005h, Bit 7 = MCLRE. 300005h, Bit 6 =",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\nGLYPH<151>. 300005h, Bit 5 = GLYPH<151>. 300005h, Bit 4 = GLYPH<151>. 300005h, Bit 3 = GLYPH<151>. 300005h, Bit 2 = LPT1OSC. 300005h, Bit 1 = GLYPH<151>. 300005h, Bit 0 = CCP2MX. 300005h, Default/ Unprogrammed Value = 1---. 300005h, Default/ Unprogrammed Value = -0-1. 300006h, File Name = CONFIG4L. 300006h, Bit 7 = DEBUG. 300006h, Bit 6 = XINST. 300006h, Bit 5 = GLYPH<151>. 300006h, Bit 4 = GLYPH<151>. 300006h, Bit 3 = GLYPH<151>. 300006h, Bit 2 = GLYPH<151>. 300006h, Bit 1 = GLYPH<151>.",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\n300006h, Bit 0 = STVREN. 300006h, Default/ Unprogrammed Value = 10--. 300006h, Default/ Unprogrammed Value = ---1. 300008h, File Name = CONFIG5L. 300008h, Bit 7 = GLYPH<151>. 300008h, Bit 6 = GLYPH<151>. 300008h, Bit 5 = GLYPH<151>. 300008h, Bit 4 = GLYPH<151>. 300008h, Bit 3 = GLYPH<151>. 300008h, Bit 2 = GLYPH<151>. 300008h, Bit 1 = GLYPH<151>. 300008h, Bit 0 = CP. 300008h, Default/ Unprogrammed Value = ----. 300008h, Default/ Unprogrammed Value = ---1. 3FFFFEh, File Name = DEVID1. 3FFFFEh, Bit 7 = DEV2. 3FFFFEh, Bit 6 =",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\nDEV1. 3FFFFEh, Bit 5 = DEV0. 3FFFFEh, Bit 4 = REV4. 3FFFFEh, Bit 3 = REV3. 3FFFFEh, Bit 2 = REV2. 3FFFFEh, Bit 1 = REV1. 3FFFFEh, Bit 0 = REV0. 3FFFFEh, Default/ Unprogrammed Value = xxxx. 3FFFFEh, Default/ Unprogrammed Value = xxxx (1). 3FFFFFh, File Name = DEVID2. 3FFFFFh, Bit 7 = DEV10. 3FFFFFh, Bit 6 = DEV9. 3FFFFFh, Bit 5 = DEV8. 3FFFFFh, Bit 4 = DEV7. 3FFFFFh, Bit 3 = DEV6. 3FFFFFh, Bit 2 = DEV5. 3FFFFFh, Bit 1 = DEV4. 3FFFFFh, Bit 0 = DEV3. 3FFFFFh, Default/ Unprogrammed Value = 0000. 3FFFFFh, Default/ Unprogrammed Value =",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\nxxxx (1)\nLegend:\nx = unknown, u = unchanged, -= unimplemented, q = value depends on condition.\nShaded cells are unimplemented, read as GLYPH<145> 0 GLYPH<146>.\nNote 1: See Register 23-7 for DEVID values. DEVID registers are read-only and cannot be programmed by the user.",
    "CONFIG1H: CONFIGURATION REGISTER 1 HIGH (BYTE ADDRESS 300001h)\nIESO, R/P-0 = FCMEN. IESO, U-0 = GLYPH<151>. IESO, U-0 = GLYPH<151>. IESO, R/P-0 = FOSC3. IESO, R/P-1 = FOSC2. IESO, R/P-1 = FOSC1. IESO, R/P-1 = FOSC0. bit 7 bit 0, R/P-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/P-0 = bit 7 bit 0. bit 7 bit 0, R/P-1 = bit 7 bit 0. bit 7 bit 0, R/P-1 = bit 7 bit 0. bit 7 bit 0, R/P-1 = bit 7 bit 0",
    "CONFIG1H: CONFIGURATION REGISTER 1 HIGH (BYTE ADDRESS 300001h)\nLegend:, 1 = Legend:. R = Readable bit P = Programmable bit, 1 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state\nbit 7\nIESO: Internal/External Oscillator Switchover bit\n1 = Oscillator Switchover mode enabled\n0 = Oscillator Switchover mode disabled",
    "bit 6\nFCMEN: Fail-Safe Clock Monitor Enable bit\n1 = Fail-Safe Clock Monitor enabled\n0 = Fail-Safe Clock Monitor disabled\nbit 5-4 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>",
    "bit 3-0 FOSC3:FOSC0: Oscillator Selection bits\n11xx = External RC oscillator, CLKO function on RA6\n101x = External RC oscillator, CLKO function on RA6\n1001 = Internal oscillator block, CLKO function on RA6, port function on RA7\n1000 = Internal oscillator block, port function on RA6 and RA7\n0111 = External RC oscillator, port function on RA6\n0110 = HS oscillator, PLL enabled (clock frequency = 4 x FOSC1)\n0101 = EC oscillator, port function on RA6\n0100 = EC oscillator, CLKO function on RA6\n0011 = External RC oscillator, CLKO function on RA6\n0010 = HS oscillator\n0001 = XT oscillator\n0000 = LP oscillator",
    "REGISTER 23-2: CONFIG2L: CONFIGURATION REGISTER 2 LOW (BYTE ADDRESS 300002h)\nGLYPH<151>, U-0 = GLYPH<151>. GLYPH<151>, U-0 = GLYPH<151>. GLYPH<151>, R/P-1 = BORV1. GLYPH<151>, R/P-1 = BORV0. GLYPH<151>, R/P-1 = BOREN1 (1). GLYPH<151>, R/P-1 = BOREN0 (1). GLYPH<151>, R/P-1 = PWRTEN (1). bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/P-1 = bit 7 bit 0. bit 7 bit 0, R/P-1 = bit 7 bit 0. bit 7 bit 0, R/P-1 = bit 7 bit 0. bit 7 bit 0, R/P-1 = bit 7 bit 0. bit 7 bit 0,",
    "REGISTER 23-2: CONFIG2L: CONFIGURATION REGISTER 2 LOW (BYTE ADDRESS 300002h)\nR/P-1 = bit 7 bit 0\nLegend:, 1 = Legend:. R = Readable bit P = Programmable, 1 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "bit 7-5 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 4-3 BORV1:BORV0: Brown-out Reset Voltage bits\n11 = VBOR set to 2.1V\n10 = VBOR set to 2.8V\n01 = VBOR set to 4.3V\n00 = VBOR set to 4.6V",
    "bit 2-1 BOREN1:BOREN0 Brown-out Reset Enable bits (1)\n11 = Brown-out Reset enabled in hardware only (SBOREN is disabled)\n10 = Brown-out Reset enabled in hardware only and disabled in Sleep mode (SBOREN is disabled)\n10 = Brown-out Reset enabled and controlled by software (SBOREN is enabled)\n10 = Brown-out Reset disabled in hardware and software\nbit 0\nPWRTEN:\nPower-up Timer Enable bit\n(1)\n1 = PWRT disabled\n0 = PWRT enabled\nNote 1: The Power-up Timer is decoupled from Brown-out Reset, allowing these features to be independently controlled.",
    "REGISTER 23-3: CONFIG2H: CONFIGURATION REGISTER 2 HIGH (BYTE ADDRESS 300003h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/P-1. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. GLYPH<151>, 1 = GLYPH<151>. GLYPH<151>, 2 = GLYPH<151>. GLYPH<151>, 3 = WDTPS3. GLYPH<151>, 4 = WDTPS2. GLYPH<151>, 5 = WDTPS1. GLYPH<151>, 6 = WDTPS0. GLYPH<151>, 7 = WDTEN. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "REGISTER 23-3: CONFIG2H: CONFIGURATION REGISTER 2 HIGH (BYTE ADDRESS 300003h)\nLegend:, 1 = Legend:. R = Readable bit P = Programmable, 1 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state\nbit 7-5 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 4-1 WDTPS3:WDTPS0: Watchdog Timer Postscale Select bits\n1111 = 1:32,768\n1110 = 1:16,384\n1101 = 1:8,192\n1100 = 1:4,096\n1011 = 1:2,048\n1010 = 1:1,024\n1001 = 1:512\n1000 = 1:256\n0111 = 1:128\n0110 = 1:64\n0101 = 1:32\n0100 = 1:16\n0011 = 1:8\n0010 = 1:4\n0001 = 1:2\n0000 = 1:1",
    "bit 0 WDTEN: Watchdog Timer Enable bit\n1 = WDT enabled\n0 = WDT disabled (control is placed on the SWDTEN bit)",
    "REGISTER 23-4: CONFIG3H: CONFIGURATION REGISTER 3 HIGH (BYTE ADDRESS 300005h)\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = R/P-0. R/P-1, 6 = U-0. R/P-1, 7 = R/P-1. MCLRE, 1 = GLYPH<151>. MCLRE, 2 = GLYPH<151>. MCLRE, 3 = GLYPH<151>. MCLRE, 4 = GLYPH<151>. MCLRE, 5 = LPT1OSC. MCLRE, 6 = GLYPH<151>. MCLRE, 7 = CCP2MX. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7",
    "REGISTER 23-4: CONFIG3H: CONFIGURATION REGISTER 3 HIGH (BYTE ADDRESS 300005h)\nbit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nLegend:, 1 = Legend:. R = Readable bit P = Programmable, 1 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state\nbit 7\nMCLRE: MCLR Pin Enable bit\n1 = MCLR pin enabled; RG5 input pin disabled\n0 = RG5 input pin enabled; MCLR disabled\nbit 6-3\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 2\nLPT1OSC:\nLow-Power Timer 1 Oscillator Enable bit\n1 = Timer1 configured for low-power operation\n0 = Timer1 configured for higher power operation\nbit 1\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>",
    "bit 0\nCCP2MX: CCP2 MUX bit\n1 = CCP2 input/output is multiplexed with RC1\n0 = CCP2 input/output is multiplexed with RE7",
    "REGISTER 23-5: CONFIG4L: CONFIGURATION REGISTER 4 LOW (BYTE ADDRESS 300006h)\nDEBUG, R/P-0 = XINST. DEBUG, U-0 = GLYPH<151>. DEBUG, U-0 = GLYPH<151>. DEBUG, U-0 = GLYPH<151>. DEBUG, U-0 = GLYPH<151>. DEBUG, U-0 = GLYPH<151>. DEBUG, R/P-1 = STVREN. bit 7 bit 0, R/P-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/P-1 = bit 7 bit 0",
    "REGISTER 23-5: CONFIG4L: CONFIGURATION REGISTER 4 LOW (BYTE ADDRESS 300006h)\nLegend:, 1 = Legend:. R = Readable bit, 1 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state\nbit 7\nDEBUG: Background Debugger Enable bit\n1 = Background debugger disabled, RB6 and RB7 configured as general purpose I/O pins\n0 = Background debugger enabled, RB6 and RB7 are dedicated to In-Circuit Debug\nbit 6\nXINST: Extended Instruction Set Enable bit\n1 = Instruction set extension and Indexed Addressing mode enabled\n0 = Instruction set extension and Indexed Addressing mode disabled (Legacy mode)",
    "bit 5-1 Unimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 0\nSTVREN: Stack Full/Underflow Reset Enable bit\n1 = Stack full/underflow will cause Reset\n- 0 = Stack full/underflow will not cause Reset",
    "REGISTER 23-6: CONFIG5L: CONFIGURATION REGISTER 5 LOW (BYTE ADDRESS 300008h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/C-1. GLYPH<151>, 1 = GLYPH<151>. GLYPH<151>, 2 = GLYPH<151>. GLYPH<151>, 3 = GLYPH<151>. GLYPH<151>, 4 = GLYPH<151>. GLYPH<151>, 5 = GLYPH<151>. GLYPH<151>, 6 = GLYPH<151>. GLYPH<151>, 7 = CP. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit",
    "REGISTER 23-6: CONFIG5L: CONFIGURATION REGISTER 5 LOW (BYTE ADDRESS 300008h)\n0\nLegend:, 1 = Legend:. R = Readable bit, 1 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "bit 7-1\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 0\nCP: Code Protection bit\n1 = Program memory block (000000-003FFFh) not code-protected\n0 = Program memory block (000000-003FFFh) code-protected",
    "REGISTER 23-7: DEVID1: DEVICE ID REGISTER 1 FOR PIC18F6390/6490/8390/8490 DEVICES\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV2, 1 = DEV1. DEV2, 2 = DEV0. DEV2, 3 = REV4. DEV2, 4 = REV3. DEV2, 5 = REV2. DEV2, 6 = REV1. DEV2, 7 = REV0. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nLegend:, 1 = Legend:. R = Readable bit P = Programmable, 1 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state\nbit 7-5",
    "REGISTER 23-7: DEVID1: DEVICE ID REGISTER 1 FOR PIC18F6390/6490/8390/8490 DEVICES\nDEV2:DEV0:\nDevice ID bits\n100 = PIC18F8390/8490\n101 = PIC18F6390/6490\nbit 4-0 REV4:REV0:\nRevision ID bits\nThese bits are used to indicate the device revision.",
    "REGISTER 23-8: DEVID2: DEVICE ID REGISTER 2 FOR PIC18F6390/6490/8390/8490 DEVICES\nDEV10 (1), R = DEV9 (1). DEV10 (1), R = DEV8 (1). DEV10 (1), R = DEV7 (1). DEV10 (1), R = DEV6 (1). DEV10 (1), R = DEV5 (1). DEV10 (1), R = DEV4 (1). DEV10 (1), R = DEV3 (1). bit 7, R = . bit 7, R = . bit 7, R = . bit 7, R = . bit 7, R = . bit 7, R = . bit 7, R = bit 0\nLegend:, 1 = Legend:. R = Readable bit, 1 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "bit 7-0 DEV10:DEV3: Device ID bits\n(1)\nThese bits are used with the DEV2:DEV0 bits in the Device ID Register 1 to identify the part number.\n0000 0110 = PIC18F6490/8490 devices\n0000 1011 = PIC18F6390/8390 devices\nNote 1: These values for DEV10:DEV3 may be shared with other devices. The specific device is always identified by using the entire DEV10:DEV0 bit sequence.",
    "23.2 Watchdog Timer (WDT)\nFor PIC18F6390/6490/8390/8490 devices, the WDT is driven  by  the  INTRC  source.  When  the  WDT  is enabled, the clock source is also enabled. The nominal WDT period is 4 ms and has the same stability as the INTRC oscillator.\nThe 4 ms period of the WDT is multiplied by a 16-bit postscaler. Any  output  of  the  WDT  postscaler  is selected by a multiplexer, controlled by bits in Configuration Register 2H. Available periods range from 4 ms to 134.2 seconds (2.24 minutes). The  WDT  and postscaler are cleared when any of the following events occur: a SLEEP or CLRWDT instruction is executed, the IRCF  bits  (OSCCON<6:4>)  are  changed,  or  a  clock failure has occurred.",
    "23.2 Watchdog Timer (WDT)\nNote 1: The CLRWDT and SLEEP instructions clear  the  WDT  and  postscaler  counts when executed.\n2: Changing  the  setting  of  the  IRCF  bits (OSCCON<6:4>)  clears  the  WDT  and postscaler counts.\n3: When a CLRWDT instruction is executed, the postscaler count will be cleared.",
    "23.2.1 CONTROL REGISTER\nRegister 23-9 shows the WDTCON register. This is a readable and writable register, which contains a control bit  that  allows  software  to  override  the  WDT  enable Configuration bit, but only if the Configuration bit has disabled the WDT.",
    "REGISTER 23-9: WDTCON: WATCHDOG TIMER CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0. GLYPH<151>, 1 = GLYPH<151>. GLYPH<151>, 2 = GLYPH<151>. GLYPH<151>, 3 = GLYPH<151>. GLYPH<151>, 4 = GLYPH<151>. GLYPH<151>, 5 = GLYPH<151>. GLYPH<151>, 6 = GLYPH<151>. GLYPH<151>, 7 = SWDTEN (1). bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit",
    "REGISTER 23-9: WDTCON: WATCHDOG TIMER CONTROL REGISTER\n0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. R = Readable bit, 3 = U = Unimplemented bit, read as GLYPH<145>0GLYPH<146>. -n = Value at POR, 1 = GLYPH<145> 1GLYPH<146> = Bit is set. -n = Value at POR, 2 = GLYPH<145> 0GLYPH<146> = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-1\nUnimplemented: Read as GLYPH<145> 0 GLYPH<146>\nbit 0\nSWDTEN: Software Controlled Watchdog Timer Enable bit (1)\n1 = Watchdog Timer is on\n0 = Watchdog Timer is off\nNote 1: This bit has no effect if the Configuration bit, WDTEN, is enabled.",
    "TABLE 23-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nRCON, Bit 7 = IPEN. RCON, Bit 6 = SBOREN. RCON, Bit 5 = GLYPH<151>. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Reset Values on Page = 60. WDTCON, Bit 7 = GLYPH<151>. WDTCON, Bit 6 = GLYPH<151>. WDTCON, Bit 5 = GLYPH<151>. WDTCON, Bit 4 = GLYPH<151>. WDTCON, Bit 3 = GLYPH<151>. WDTCON, Bit 2 = GLYPH<151>. WDTCON, Bit 1 = GLYPH<151>. WDTCON, Bit 0 = SWDTEN. WDTCON, Reset Values on Page = 60\nLegend: GLYPH<151> = unimplemented, read as GLYPH<145> 0 GLYPH<146>. Shaded cells are not used by the Watchdog Timer.",
    "23.3 Two-Speed Start-up\nThe Two-Speed Start-up feature helps to minimize the latency period from oscillator start-up to code execution by  allowing  the  microcontroller  to  use  the  INTRC oscillator  as  a  clock  source  until  the  primary  clock source is available. It is enabled by setting the IESO Configuration bit.\nTwo-Speed  Start-up  should  be  enabled  only  if  the primary  oscillator  mode  is  LP,  XT,  HS  or  HSPLL (Crystal-Based modes). Other sources do not require a OST  start-up  delay;  for  these,  Two-Speed  Start-up should be disabled.\nWhen enabled, Resets and wake-ups from Sleep mode cause  the  device  to  configure  itself  to  run  from  the internal oscillator block as the clock source, following the time-out of the Power-up Timer after a Power-on Reset is enabled. This allows almost immediate code execution  while  the  primary  oscillator  starts  and  the OST is running. Once the OST times out, the device automatically switches to PRI_RUN mode.",
    "23.3 Two-Speed Start-up\nBecause  the  OSCCON  register  is  cleared  on  Reset events, the INTOSC (or postscaler) clock source is not initially available after a Reset event; the INTRC clock is used directly at its base frequency. To use a higher clock  speed  on  wake-up,  the  INTOSC  or  postscaler clock sources can be selected to provide a higher clock speed by setting bits, IRCF2:IRCF0, immediately after\nReset.  For  wake-ups  from  Sleep,  the  INTOSC  or postscaler clock sources can be selected by setting the IRCF2:IRCF0 bits prior to entering Sleep mode.\nIn all other power-managed modes, Two-Speed Start-up is not used. The device will be clocked by the currently selected  clock  source  until  the  primary  clock  source becomes  available.  The  setting  of  the  IESO  bit  is ignored.",
    "23.3.1 SPECIAL CONSIDERATIONS FOR USING TWO-SPEED START-UP\nWhile using the INTRC  oscillator in Two-Speed Start-up,  the  device  still  obeys  the  normal  command sequences for entering power-managed modes, including serial SLEEP instructions (refer to Section 3.1.2  GLYPH<147>Entering  Power-Managed  ModesGLYPH<148> ). In  practice,  this  means  that  user  code  can  change the SCS1:SCS0 bit settings or issue SLEEP instructions  before  the  OST  times  out.  This  would allow an application to briefly wake-up, perform routine  GLYPH<147>housekeepingGLYPH<148> tasks  and  return  to  Sleep before  the  device  starts  to  operate  from  the  primary oscillator.\nUser code can also check if the primary clock source is currently providing the device clocking by checking the status of the OSTS bit (OSCCON<3>). If the bit is set, the primary oscillator is providing the clock. Otherwise, the internal oscillator block is providing the clock during wake-up from Reset or Sleep mode.",
    "23.4 Fail-Safe Clock Monitor\nThe Fail-Safe Clock Monitor (FSCM) allows the microcontroller to continue operation in the event of an external oscillator failure by automatically switching the device clock to the internal oscillator block. The FSCM function is enabled by setting the FCMEN Configuration bit.\nTo use a higher clock speed on wake-up, the INTOSC or postscaler clock sources can be selected to provide a  higher  clock  speed  by  setting  bits,  IRCF2:IRCF0, immediately after Reset. For wake-ups from Sleep, the INTOSC or postscaler clock sources can be selected by setting the IRCF2:IRCF0 bits prior to entering Sleep mode.",
    "23.4 Fail-Safe Clock Monitor\nWhen FSCM is enabled, the INTRC oscillator runs at all times to monitor clocks to peripherals and provide a backup  clock  in  the  event  of  a  clock  failure.  Clock monitoring (shown in Figure 23-3) is accomplished by creating a sample clock signal, which is the INTRC output  divided  by  64.  This  allows  ample  time  between FSCM sample  clocks  for  a  peripheral  clock  edge  to occur.  The  peripheral  device  clock  and  the  sample clock are presented as inputs to the Clock Monitor latch (CM). The CM is set on the falling edge of the device clock  source,  but  cleared  on  the  rising  edge  of  the sample clock.",
    "FIGURE 23-3: FSCM BLOCK DIAGRAM\nClock  failure  is  tested  for  on  the  falling  edge  of  the sample  clock.  If  a  sample  clock  falling  edge  occurs while CM is still set, a clock failure has been detected (Figure 23-4). This causes the following:\nGLYPH<149> the FSCM generates an oscillator fail interrupt by setting bit OSCFIF (PIR2<7>);\nGLYPH<149> the device clock source is switched to the internal oscillator block (OSCCON is not updated to show the current clock source GLYPH<150> this is the Fail-Safe condition); and\nGLYPH<149> the WDT is reset.",
    "FIGURE 23-3: FSCM BLOCK DIAGRAM\nDuring  switchover,  the  postscaler  frequency  from  the internal oscillator block may not be sufficiently stable for timing sensitive applications. In these cases, it may be desirable to select another clock configuration and enter an alternate power-managed mode. This can be done to attempt a partial recovery or execute a controlled shutdown. See Section 3.1.2 GLYPH<147>Entering  Power-Managed ModesGLYPH<148> and Section 23.3.1 GLYPH<147>Special Considerations for Using Two-Speed Start-upGLYPH<148> for more details.\nThe FSCM will detect failures of the primary or secondary clock sources only. If  the internal  oscillator  block fails, no failure would be detected, nor would any action be possible.",
    "23.4.1 FSCM AND THE WATCHDOG TIMER\nBoth  the  FSCM  and  the  WDT  are  clocked  by  the INTRC  oscillator.  Since  the  WDT  operates  with  a separate divider and counter, disabling the WDT has no effect on the operation of the INTRC oscillator when the FSCM is enabled.\nAs already noted, the clock source is switched to the INTOSC  clock  when  a  clock  failure is detected. Depending on the frequency selected by the IRCF2:IRCF0 bits, this may mean a substantial change in the speed of code execution. If the WDT is enabled with a small prescale value, a decrease in clock speed allows  a  WDT  time-out  to  occur  and  a  subsequent device Reset. For this reason, Fail-Safe Clock Monitor events  also  reset  the  WDT  and  postscaler,  allowing them to start timing from when execution speed was changed and decreasing the likelihood of an erroneous time-out.",
    "23.4.2 EXITING FAIL-SAFE OPERATION\nThe Fail-Safe condition is terminated by either a device Reset  or  by  entering  a  power-managed  mode.  On Reset,  the  controller  starts  the  primary  clock  source specified in Configuration Register 1H  (with any required start-up delays that are required for the oscillator  mode,  such  as  the  OST  or  PLL  timer).  The INTOSC multiplexer provides the device clock until the primary clock source becomes ready (similar to a TwoSpeed Start-up). The clock source is then switched to the  primary  clock  (indicated  by  the  OSTS  bit  in  the OSCCON register becoming set). The Fail-Safe Clock Monitor then resumes monitoring the peripheral clock.\nThe  primary  clock  source  may  never  become  ready during start-up. In this case, operation is clocked by the INTOSC multiplexer. The OSCCON register will remain in  its  Reset  state  until  a  power-managed  mode  is entered.",
    "23.4.4 POR OR WAKE FROM SLEEP\nBy entering a power-managed  mode,  the  clock multiplexer selects the clock source selected by the OSCCON  register.  Fail-Safe  Clock  Monitoring  of the power-managed  clock  source  resumes  in  the power-managed mode.\nIf  an  oscillator  failure  occurs  during  power-managed operation, the subsequent events depend on whether or not the Oscillator Failure Interrupt Flag is enabled. If enabled (OSCFIF = 1 ), code execution will be clocked by  the  INTOSC  multiplexer.  An  automatic  transition back to the failed clock source will not occur.\nIf  the interrupt is disabled, the device will not exit the power-managed mode on oscillator failure. Instead, the device will continue to operate as before, but clocked by the INTOSC multiplexer. While in Idle mode, subsequent interrupts will cause the CPU  to begin executing  instructions  while  being  clocked  by  the INTOSC multiplexer.",
    "23.4.4 POR OR WAKE FROM SLEEP\nThe FSCM is designed to detect oscillator failure at any point  after  the  device  has  exited  Power-on  Reset (POR) or low-power Sleep mode. When the primary device clock is EC, RC or INTRC modes, monitoring can begin immediately following these events.\nFor  oscillator  modes  involving  a  crystal  or  resonator (HS,  HSPLL,  LP  or  XT),  the  situation  is  somewhat different.  Since  the  oscillator  may  require  a  start-up time considerably longer than the FCSM sample clock time, a false clock failure may be detected. To prevent this,  the internal oscillator block is automatically configured  as  the  device  clock  and  functions  until  the primary clock is stable (the OST and PLL timers have timed  out).  This  is  identical  to  Two-Speed  Start-up mode.  Once  the  primary  clock  is  stable,  the  INTRC returns to its role as the FSCM source.\nNote:",
    "23.4.4 POR OR WAKE FROM SLEEP\nThe same logic that prevents false oscillator  failure  interrupts  on  POR,  or wake  from  Sleep,  will  also  prevent  the detection of the oscillatorGLYPH<146>s failure to start at all following these events. This can be avoided by monitoring the OSTS bit and using a timing routine to determine if the oscillator is taking too long to start. Even so,  no  oscillator  failure  interrupt  will  be flagged.\nAs noted in Section 23.3.1 GLYPH<147>Special Considerations for Using Two-Speed Start-upGLYPH<148> , it is also possible to select another clock configuration and enter an alternate power-managed mode while waiting for the primary clock to become stable. When the new powermanaged  mode  is  selected,  the  primary  clock  is disabled.",
    "23.5.1 READING PROGRAM MEMORY AND OTHER LOCATIONS\nThe  overall  structure  of  the  code  protection  on  the PIC18F6390/6490/8390/8490 Flash devices differs from previous PIC18 devices.\nThe  program  memory  may  be  read  to  any  location using the table read instructions. The Device ID and the Configuration registers may be read with the table read instructions.\nFor  all  devices  in  the  PIC18F6X90/8X90  family,  the user  program  memory  is  made  of  a  single  block. Figure 23-5 shows the program memory organization for individual devices. Code protection for this block is controlled by a single bit, CP (CONFIG5L<0>). The CP bit inhibits external reads from and writes to the entire program  memory  space.  It  has  no  direct  effect  in normal execution mode.",
    "23.5.2 CONFIGURATION REGISTER PROTECTION\nThe  Configuration  registers  can  only  be  written  via ICSP  using  an  external  programmer.  No  separate protection bit is associated with them.",
    "FIGURE 23-5: CODE-PROTECTED PROGRAM MEMORY FOR PIC18F6390/6490/8390/8490\nProgram Memory Block, MEMORY SIZE/DEVICE.Address Range = 000000h 001FFFh. Program Memory Block, MEMORY SIZE/DEVICE.16 Kbytes (PIC18F6490/8490) = Program Memory Block. Program Memory Block, MEMORY SIZE/DEVICE.Address Range = 000000h 003FFFh. Program Memory Block, Block Code Protection Controlled By: = CP, EBTR. Unimplemented Read GLYPH<145> 0 GLYPH<146> s, MEMORY SIZE/DEVICE.Address Range = . Unimplemented Read GLYPH<145> 0 GLYPH<146> s, MEMORY SIZE/DEVICE.16 Kbytes (PIC18F6490/8490) = Unimplemented Read GLYPH<145> 0 GLYPH<146> s. Unimplemented Read GLYPH<145> 0 GLYPH<146> s, MEMORY SIZE/DEVICE.Address Range = . Unimplemented Read GLYPH<145> 0 GLYPH<146>",
    "FIGURE 23-5: CODE-PROTECTED PROGRAM MEMORY FOR PIC18F6390/6490/8390/8490\ns, Block Code Protection Controlled By: = (Unimplemented Memory Space)",
    "TABLE 23-3: SUMMARY OF CODE PROTECTION REGISTERS\n300008h, File Name = CONFIG5L. 300008h, Bit 7 = GLYPH<151>. 300008h, Bit 6 = GLYPH<151>. 300008h, Bit 5 = GLYPH<151>. 300008h, Bit 4 = GLYPH<151>. 300008h, Bit 3 = GLYPH<151>. 300008h, Bit 2 = GLYPH<151>. 300008h, Bit 1 = GLYPH<151>. 300008h, Bit 0 = CP\nLegend: Shaded cells are unimplemented.",
    "23.6 ID Locations\nEight memory locations (200000h-200007h) are designated as ID locations,  where  the  user  can  store checksum or other code identification numbers. These locations are readable during normal execution through the TBLRD instruction.  During  program/verify,  these locations  are  readable  and  writable.  The  ID  locations can be read when the device is code-protected.",
    "23.7 In-Circuit Serial Programming\nPIC18F6390/6490/8390/8490 microcontrollers can be serially programmed while in the end application circuit. This is simply done with two lines for clock and data and  three  other  lines  for  power,  ground  and  the programming voltage. This allows customers to manufacture boards with unprogrammed devices and then program the microcontroller just before shipping the product. This also allows the most recent firmware or a custom firmware to be programmed.",
    "23.8 In-Circuit Debugger\nWhen the DEBUG Configuration bit is programmed to a GLYPH<145> 0 GLYPH<146>, the In-Circuit Debugger functionality is enabled. This function allows simple debugging functions when used with MPLAB fi  IDE. When the microcontroller has this feature enabled, some resources are not available for general use. Table 23-4 shows which resources are required by the background debugger.",
    "TABLE 23-4: DEBUGGER RESOURCES\nI/O pins:, 1 = RB6, RB7. Stack:, 1 = 2 levels. Program Memory:, 1 = 512 bytes. Data Memory:, 1 = 10 bytes\nTo use the In-Circuit Debugger function of the microcontroller, the design must implement In-Circuit Serial Programming  connections  to  MCLR/VPP,  VDD,  VSS, RB7  and  RB6.  This  will  interface  to  the  In-Circuit Debugger module available from Microchip or one of the third party development tool companies.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "24.0 INSTRUCTION SET SUMMARY\nThe literal instructions may use some of the following operands:\nPIC18FXX90 devices incorporate the standard set of seventy-five  PIC18  core  instructions,  as  well  as  an extended set of 8 new instructions for the optimization of  code  that  is  recursive  or  that  utilizes  a  software stack.  The  extended  set  is  discussed  later  in  this section.",
    "24.1 Standard Instruction Set\nThe standard PIC18 instruction set adds many enhancements to the previous PIC fi  MCU instruction sets, while maintaining an easy migration from these PIC  MCU  instruction  sets.  Most  instructions  are  a single program memory word (16 bits), but there are four  instructions  that  require  two  program  memory locations.\nEach single-word instruction  is  a 16-bit word  divided into an opcode, which specifies the instruction type and one  or  more  operands,  which  further  specify  the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\nGLYPH<149> Byte-oriented operations\nGLYPH<149> Bit-oriented operations\nGLYPH<149> Literal operations\nGLYPH<149> Control operations\nThe PIC18 instruction set summary in Table 24-2 lists byte-oriented , bit-oriented , literal and control operations. Table 24-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:",
    "24.1 Standard Instruction Set\n1. The file register (specified by GLYPH<145>fGLYPH<146>)\n2. The destination of the result (specified by GLYPH<145>dGLYPH<146>)\n3. The accessed memory (specified by GLYPH<145>aGLYPH<146>)\nThe  file  register  designator,  GLYPH<145>fGLYPH<146>, specifies  which  file register is to be used by the instruction. The destination designator, GLYPH<145>dGLYPH<146>, specifies where the result of the operation is to be placed. If GLYPH<145>dGLYPH<146> is zero, the result is placed in the WREG register. If GLYPH<145>dGLYPH<146> is one, the result is placed in the file register specified in the instruction.\nAll bit-oriented instructions have three operands:",
    "24.1 Standard Instruction Set\n1. The file register (specified by GLYPH<145>fGLYPH<146>)\n2. The bit in the file register (specified by GLYPH<145>bGLYPH<146>)\n3. The accessed memory (specified by GLYPH<145>aGLYPH<146>)\nThe bit field designator, GLYPH<145>bGLYPH<146>, selects the number of the bit affected by the operation, while the file register designator, GLYPH<145>fGLYPH<146>, represents the number of the file in which the bit is located.\nGLYPH<149> A literal value to be loaded into a file register (specified by GLYPH<145>kGLYPH<146>)\nGLYPH<149> The desired FSR register to load the literal value into (specified by GLYPH<145>fGLYPH<146>)\nGLYPH<149> No operand required (specified by GLYPH<145>GLYPH<151>GLYPH<146>)\nThe control instructions may use some of the following operands:",
    "24.1 Standard Instruction Set\nGLYPH<149> A program memory address (specified by GLYPH<145>nGLYPH<146>)\nGLYPH<149> The mode of the CALL or RETURN instructions (specified by GLYPH<145>sGLYPH<146>)\nGLYPH<149> The mode of the table read and table write instructions (specified by GLYPH<145>mGLYPH<146>)\nGLYPH<149> No operand required (specified by GLYPH<145>GLYPH<151>GLYPH<146>)\nAll instructions  are  a  single  word,  except  for  four double-word instructions. These instructions were made double-word to contain the required information in 32 bits. In the second word, the 4 MSbs are GLYPH<145> 1 GLYPH<146> s. If this  second  word  is  executed  as  an  instruction  (by itself), it will execute as a NOP .",
    "24.1 Standard Instruction Set\nAll  single-word  instructions  are  executed  in  a  single instruction cycle, unless a conditional test is true or the program counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles with the additional instruction cycle(s) executed as a NOP .\nThe double-word instructions execute in two instruction cycles.\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \u03bc s. If a conditional test is true, or the program counter is changed as a result of an instruction, the instruction  execution  time is  2 \u03bc s. Two-word branch instructions (if true) would take 3 \u03bc s.\nFigure 24-1 shows the general formats that the instructions can have. All examples use the convention GLYPH<145>nnhGLYPH<146> to represent a hexadecimal number.\nThe  Instruction  Set  Summary,  shown  in  Table 24-2, lists the standard instructions recognized by the Microchip MPASM TM  Assembler.\nSection 24.1.1 GLYPH<147>Standard Instruction SetGLYPH<148> provides a description of each instruction.",
    "TABLE 24-1: OPCODE FIELD DESCRIPTIONS\na, Description = RAM access bit a = 0 : RAM location in Access RAM (BSR register is ignored) a = 1 : RAM bank is specified by BSR register. bbb, Description = Bit address within an 8-bit file register (0 to 7).. BSR, Description = Bank Select Register. Used to select the current RAM bank.. C, DC, Z, OV,, Description = ALU Status bits: C arry, D igit C arry, Z ero, Ov erflow, N egative.. d, Description = Destination select bit d = 0 : store result in WREG d = 1 : store result in file register f. dest, Description = Destination: either the WREG register or the specified register file location.. f, Description = 8-bit register file address (00h to FFh), or 2-bit FSR designator (0h to 3h).. f s, Description = 12-bit register file address (000h to FFFh). This is the source address.. f d, Description = 12-bit register file address (000h to FFFh). This",
    "TABLE 24-1: OPCODE FIELD DESCRIPTIONS\nis the destination address.. GIE, Description = Global Interrupt Enable bit.. k, Description = Literal field, constant data or label (may be either an 8-bit, 12-bit or a 20-bit value).. label, Description = Label name.. mm, Description = The mode of the TBLPTR register for the table read and table write instructions. Only used with table read and table write instructions:. * *+, Description = No change to register (such as TBLPTR with table reads and writes) Post-Increment register (such as TBLPTR with table reads and writes). *-, Description = Post-Decrement register (such as TBLPTR with table reads and writes). +*, Description = Pre-Increment register (such as TBLPTR with table reads and writes). n, Description = The relative address (2GLYPH<146>s complement number) for relative branch instructions or the direct address for Call/Branch and Return instructions.. PC, Description = Program Counter.. PCL, Description = Program Counter Low Byte.. PCH, Description = Program Counter High Byte.. PCLATH,",
    "TABLE 24-1: OPCODE FIELD DESCRIPTIONS\nDescription = Program Counter High Byte Latch.. PCLATU, Description = Program Counter Upper Byte Latch.. PD, Description = Power-Down bit.. PRODH, Description = Product of Multiply High Byte.. PRODL, Description = Product of Multiply Low Byte.. s, Description = Fast Call/Return mode select bit s = 0 : do not update into/from shadow registers s = 1 : certain registers loaded into/from shadow registers (Fast mode). TBLPTR, Description = 21-bit Table Pointer (points to a Program Memory location).. TABLAT, Description = 8-bit Table Latch.. TO, Description = Time-out bit.. TOS, Description = Top-of-Stack.. u, Description = Unused or unchanged.. WDT, Description = Watchdog Timer.. WREG, Description = Working register (accumulator).. x, Description = DonGLYPH<146>t care (GLYPH<145> 0 GLYPH<146> or GLYPH<145> 1 GLYPH<146>). The assembler will generate code with x = 0 . It is the recommended form of use for",
    "TABLE 24-1: OPCODE FIELD DESCRIPTIONS\ncompatibility with all Microchip software tools.. z s, Description = 7-bit offset value for Indirect Addressing of register files (source).. z d, Description = 7-bit offset value for Indirect Addressing of register files (destination).. { }, Description = Optional argument.. [text], Description = Indicates an indexed address.. (text), Description = The contents of text .. [expr]<n>, Description = Specifies bit n of the register indicated by the pointer expr .. \u2192, Description = Assigned to.. < >, Description = Register bit field.. , Description = User-defined term. italics, Description = (font is Courier New).",
    "GENERAL FORMAT FOR INSTRUCTIONS\n,  = (literal)",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nBYTE-ORIENTED OPERATIONS, Mnemonic,.Operands = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Description.Description = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Cycles.Cycles = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Status Affected.Status Affected = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Notes.Notes = BYTE-ORIENTED OPERATIONS. ADDWF, Mnemonic,.Operands = f, d, a. ADDWF, Description.Description = Add WREG and f. ADDWF, Cycles.Cycles = 1. ADDWF, 16-Bit Instruction Word.MSb = 0010. ADDWF, 16-Bit Instruction Word.MSb = 01da. ADDWF, 16-Bit Instruction Word. = ffff. ADDWF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n16-Bit Instruction Word.LSb = ffff. ADDWF, Status Affected.Status Affected = C, DC, Z, OV, N. ADDWF, Notes.Notes = 1, 2. ADDWFC, Mnemonic,.Operands = f, d, a. ADDWFC, Description.Description = Add WREG and Carry bit to f. ADDWFC, Cycles.Cycles = 1. ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word.MSb = 00da. ADDWFC, 16-Bit Instruction Word. = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status Affected.Status Affected = C, DC, Z, OV, N. ADDWFC, Notes.Notes = 1, 2. ANDWF, Mnemonic,.Operands = f, d, a. ANDWF, Description.Description = AND WREG with f. ANDWF, Cycles.Cycles = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nANDWF, 16-Bit Instruction Word.MSb = 01da. ANDWF, 16-Bit Instruction Word. = ffff. ANDWF, 16-Bit Instruction Word.LSb = ffff. ANDWF, Status Affected.Status Affected = Z, N. ANDWF, Notes.Notes = 1,2. CLRF, Mnemonic,.Operands = f, a. CLRF, Description.Description = Clear f. CLRF, Cycles.Cycles = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word.MSb = 101a. CLRF, 16-Bit Instruction Word. = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status Affected.Status Affected = Z. CLRF, Notes.Notes = 2. COMF, Mnemonic,.Operands = f, d, a. COMF, Description.Description = Complement f. COMF, Cycles.Cycles = 1. COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nWord.MSb = 11da. COMF, 16-Bit Instruction Word. = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status Affected.Status Affected = Z, N. COMF, Notes.Notes = 1, 2. CPFSEQ, Mnemonic,.Operands = f, a. CPFSEQ, Description.Description = Compare f with WREG, Skip =. CPFSEQ, Cycles.Cycles = 1 (2 or 3). CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word.MSb = 001a. CPFSEQ, 16-Bit Instruction Word. = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status Affected.Status Affected = None. CPFSEQ, Notes.Notes = 4. CPFSGT, Mnemonic,.Operands = f, a. CPFSGT, Description.Description = Compare f with WREG, Skip >. CPFSGT, Cycles.Cycles = 1",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n(2 or 3). CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word.MSb = 010a. CPFSGT, 16-Bit Instruction Word. = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT, Status Affected.Status Affected = None. CPFSGT, Notes.Notes = 4. CPFSLT, Mnemonic,.Operands = f, a. CPFSLT, Description.Description = Compare f with WREG, Skip < 1. CPFSLT, Cycles.Cycles = (2 or 3). CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word.MSb = 000a. CPFSLT, 16-Bit Instruction Word. = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff. CPFSLT, Status Affected.Status Affected = None. CPFSLT, Notes.Notes = 1, 2. DECF, Mnemonic,.Operands = f, d, a.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nDECF, Description.Description = Decrement f. DECF, Cycles.Cycles = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word.MSb = 01da. DECF, 16-Bit Instruction Word. = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status Affected.Status Affected = C, DC, Z, OV, N. DECF, Notes.Notes = 1, 2, 3, 4. DECFSZ, Mnemonic,.Operands = f, d, a. DECFSZ, Description.Description = Decrement f, Skip if 0. DECFSZ, Cycles.Cycles = 1 (2 or 3). DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word.MSb = 11da. DECFSZ, 16-Bit Instruction Word. = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status Affected.Status Affected = None. DECFSZ,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nNotes.Notes = 1, 2, 3, 4. DCFSNZ, Mnemonic,.Operands = f, d, a. DCFSNZ, Description.Description = Decrement f, Skip if Not 0. DCFSNZ, Cycles.Cycles = 1 (2 or 3). DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word.MSb = 11da. DCFSNZ, 16-Bit Instruction Word. = ffff. DCFSNZ, 16-Bit Instruction Word.LSb = ffff. DCFSNZ, Status Affected.Status Affected = None. DCFSNZ, Notes.Notes = 1, 2. INCF, Mnemonic,.Operands = f, d, a. INCF, Description.Description = Increment f. INCF, Cycles.Cycles = 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF, 16-Bit Instruction Word.MSb = 10da. INCF, 16-Bit Instruction Word. = ffff. INCF, 16-Bit Instruction Word.LSb =",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nffff. INCF, Status Affected.Status Affected = C, DC, Z, OV, N. INCF, Notes.Notes = 1, 2, 3, 4. INCFSZ, Mnemonic,.Operands = f, d, a. INCFSZ, Description.Description = Increment f, Skip if 0. INCFSZ, Cycles.Cycles = 1 (2 or 3). INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word.MSb = 11da. INCFSZ, 16-Bit Instruction Word. = ffff. INCFSZ, 16-Bit Instruction Word.LSb = ffff. INCFSZ, Status Affected.Status Affected = None. INCFSZ, Notes.Notes = 4. INFSNZ, Mnemonic,.Operands = f, d, a. INFSNZ, Description.Description = Increment f, Skip if Not 0. INFSNZ, Cycles.Cycles = 1 (2 or 3). INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n16-Bit Instruction Word.MSb = 10da. INFSNZ, 16-Bit Instruction Word. = ffff. INFSNZ, 16-Bit Instruction Word.LSb = ffff. INFSNZ, Status Affected.Status Affected = None. INFSNZ, Notes.Notes = 1, 2. IORWF, Mnemonic,.Operands = f, d, a. IORWF, Description.Description = Inclusive OR WREG with f. IORWF, Cycles.Cycles = 1. IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word.MSb = 00da. IORWF, 16-Bit Instruction Word. = ffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status Affected.Status Affected = Z, N. IORWF, Notes.Notes = 1, 2. MOVF, Mnemonic,.Operands = f, d, a. MOVF, Description.Description = Move f. MOVF, Cycles.Cycles =",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n1. MOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word.MSb = 00da. MOVF, 16-Bit Instruction Word. = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status Affected.Status Affected = Z, N. MOVF, Notes.Notes = 1. MOVFF, Mnemonic,.Operands = f s , f d. MOVFF, Description.Description = Movef s (source) to 1st word f d (destination) 2nd word 2. MOVFF, Cycles.Cycles = . MOVFF, 16-Bit Instruction Word.MSb = 1100. MOVFF, 16-Bit Instruction Word.MSb = ffff. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction Word.LSb = ffff. MOVFF, Status Affected.Status Affected = None. MOVFF, Notes.Notes = . MOVWF, Mnemonic,.Operands = f, a.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nMOVWF, Description.Description = Move WREG to f. MOVWF, Cycles.Cycles = 1. MOVWF, 16-Bit Instruction Word.MSb = 1111 0110. MOVWF, 16-Bit Instruction Word.MSb = ffff 111a. MOVWF, 16-Bit Instruction Word. = ffff ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff ffff. MOVWF, Status Affected.Status Affected = None. MOVWF, Notes.Notes = . MULWF, Mnemonic,.Operands = f, a. MULWF, Description.Description = Multiply WREG with f. MULWF, Cycles.Cycles = 1. MULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word.MSb = 001a. MULWF, 16-Bit Instruction Word. = ffff. MULWF, 16-Bit Instruction Word.LSb = ffff. MULWF, Status Affected.Status Affected =",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n. MULWF, Notes.Notes = . NEGF, Mnemonic,.Operands = f, a. NEGF, Description.Description = . NEGF, Cycles.Cycles = . NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word.MSb = 110a. NEGF, 16-Bit Instruction Word. = . NEGF, 16-Bit Instruction Word.LSb = . NEGF, Status Affected.Status Affected = None. NEGF, Notes.Notes = 1, 2. RLCF, Mnemonic,.Operands = f, d, a. RLCF, Description.Description = Negate f. RLCF, Cycles.Cycles = 1. RLCF, 16-Bit Instruction Word.MSb = . RLCF, 16-Bit Instruction Word.MSb = . RLCF, 16-Bit Instruction Word. = ffff. RLCF, 16-Bit Instruction Word.LSb = ffff. RLCF, Status Affected.Status Affected = C, DC, Z, OV, N. RLCF, Notes.Notes",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= . , Mnemonic,.Operands = . , Description.Description = Rotate Left f through Carry. , Cycles.Cycles = 1. , 16-Bit Instruction Word.MSb = 0011. , 16-Bit Instruction Word.MSb = 01da. , 16-Bit Instruction Word. = ffff. , 16-Bit Instruction Word.LSb = ffff. , Status Affected.Status Affected = C, Z, N. , Notes.Notes = 1, 2. RLNCF, Mnemonic,.Operands = f, d, a. RLNCF, Description.Description = Rotate Left f (No Carry). RLNCF, Cycles.Cycles = 1. RLNCF, 16-Bit Instruction Word.MSb = 0100. RLNCF, 16-Bit Instruction Word.MSb = 01da. RLNCF, 16-Bit Instruction Word. = ffff. RLNCF, 16-Bit Instruction Word.LSb = ffff. RLNCF, Status Affected.Status Affected = Z, N. RLNCF, Notes.Notes = . RRCF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nMnemonic,.Operands = f, d, a. RRCF, Description.Description = Rotate Right f through Carry. RRCF, Cycles.Cycles = 1. RRCF, 16-Bit Instruction Word.MSb = 0011. RRCF, 16-Bit Instruction Word.MSb = 00da. RRCF, 16-Bit Instruction Word. = ffff. RRCF, 16-Bit Instruction Word.LSb = ffff. RRCF, Status Affected.Status Affected = C, Z, N. RRCF, Notes.Notes = . RRNCF, Mnemonic,.Operands = f, d, a. RRNCF, Description.Description = Rotate Right f (No Carry). RRNCF, Cycles.Cycles = 1. RRNCF, 16-Bit Instruction Word.MSb = 0100. RRNCF, 16-Bit Instruction Word.MSb = 00da. RRNCF, 16-Bit Instruction Word. = ffff. RRNCF, 16-Bit Instruction Word.LSb = ffff. RRNCF, Status Affected.Status Affected = Z,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nN. RRNCF, Notes.Notes = . SETF, Mnemonic,.Operands = f, a. SETF, Description.Description = Set f. SETF, Cycles.Cycles = 1. SETF, 16-Bit Instruction Word.MSb = 0110. SETF, 16-Bit Instruction Word.MSb = 100a. SETF, 16-Bit Instruction Word. = ffff. SETF, 16-Bit Instruction Word.LSb = ffff. SETF, Status Affected.Status Affected = None. SETF, Notes.Notes = 1, 2. SUBFWB, Mnemonic,.Operands = f, d, a. SUBFWB, Description.Description = Subtract f from WREG with Borrow. SUBFWB, Cycles.Cycles = 1. SUBFWB, 16-Bit Instruction Word.MSb = 0101. SUBFWB, 16-Bit Instruction Word.MSb = 01da. SUBFWB, 16-Bit Instruction Word. = ffff. SUBFWB, 16-Bit Instruction Word.LSb = ffff.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nSUBFWB, Status Affected.Status Affected = C, DC, Z, OV, N. SUBFWB, Notes.Notes = . SUBWF, Mnemonic,.Operands = f, d, a. SUBWF, Description.Description = Subtract WREG from f. SUBWF, Cycles.Cycles = 1. SUBWF, 16-Bit Instruction Word.MSb = 0101. SUBWF, 16-Bit Instruction Word.MSb = 11da. SUBWF, 16-Bit Instruction Word. = ffff. SUBWF, 16-Bit Instruction Word.LSb = ffff. SUBWF, Status Affected.Status Affected = C, DC, Z, OV, N. SUBWF, Notes.Notes = 1, 2. SUBWFB, Mnemonic,.Operands = f, d, a. SUBWFB, Description.Description = Subtract WREG from f with Borrow. SUBWFB, Cycles.Cycles = 1. SUBWFB, 16-Bit Instruction Word.MSb = 0101. SUBWFB, 16-Bit Instruction",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nWord.MSb = 10da. SUBWFB, 16-Bit Instruction Word. = ffff. SUBWFB, 16-Bit Instruction Word.LSb = ffff. SUBWFB, Status Affected.Status Affected = C, DC, Z, OV, N. SUBWFB, Notes.Notes = . SWAPF, Mnemonic,.Operands = f, d, a. SWAPF, Description.Description = Swap Nibbles in f. SWAPF, Cycles.Cycles = 1. SWAPF, 16-Bit Instruction Word.MSb = 0011. SWAPF, 16-Bit Instruction Word.MSb = 10da. SWAPF, 16-Bit Instruction Word. = ffff. SWAPF, 16-Bit Instruction Word.LSb = ffff. SWAPF, Status Affected.Status Affected = None. SWAPF, Notes.Notes = 4. TSTFSZ, Mnemonic,.Operands = f, a. TSTFSZ, Description.Description = Test f, Skip if 0. TSTFSZ, Cycles.Cycles = 1 (2 or 3). TSTFSZ, 16-Bit Instruction Word.MSb",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= 0110. TSTFSZ, 16-Bit Instruction Word.MSb = 011a. TSTFSZ, 16-Bit Instruction Word. = ffff. TSTFSZ, 16-Bit Instruction Word.LSb = ffff. TSTFSZ, Status Affected.Status Affected = None. TSTFSZ, Notes.Notes = 1, 2. XORWF, Mnemonic,.Operands = f, d, a. XORWF, Description.Description = Exclusive OR WREG with f. XORWF, Cycles.Cycles = 1. XORWF, 16-Bit Instruction Word.MSb = 0001. XORWF, 16-Bit Instruction Word.MSb = 10da. XORWF, 16-Bit Instruction Word. = ffff. XORWF, 16-Bit Instruction Word.LSb = ffff. XORWF, Status Affected.Status Affected = Z, N. XORWF, Notes.Notes = ",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nNote 1: When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is GLYPH<145> 1 GLYPH<146>  for a pin configured as an input and is driven low by an external device, the data will be written back with a GLYPH<145> 0 GLYPH<146> .\n2: If this instruction is executed on the TMR0 register (and where applicable, GLYPH<145>dGLYPH<146> = 1 ), the prescaler will be cleared if assigned.\n3: If the Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are two-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nBIT-ORIENTED OPERATIONS, Mnemonic,.Operands = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Description.Description = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Cycles.Cycles = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word. = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word.LSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Status Affected.Status Affected = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Notes.Notes = BIT-ORIENTED OPERATIONS. BCF, Mnemonic,.Operands = f, b, a. BCF, Description.Description = Bit Clear f. BCF, Cycles.Cycles = 1. BCF, 16-Bit Instruction Word.MSb = 1001. BCF, 16-Bit Instruction Word.MSb = bbba. BCF, 16-Bit Instruction Word. = ffff. BCF, 16-Bit Instruction Word.LSb",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= ffff. BCF, Status Affected.Status Affected = None. BCF, Notes.Notes = 1, 2. BSF, Mnemonic,.Operands = f, b, a. BSF, Description.Description = Bit Set f. BSF, Cycles.Cycles = 1. BSF, 16-Bit Instruction Word.MSb = 1000. BSF, 16-Bit Instruction Word.MSb = bbba. BSF, 16-Bit Instruction Word. = ffff. BSF, 16-Bit Instruction Word.LSb = ffff. BSF, Status Affected.Status Affected = None. BSF, Notes.Notes = 1, 2. BTFSC, Mnemonic,.Operands = f, b, a. BTFSC, Description.Description = Bit Test f, Skip if Clear. BTFSC, Cycles.Cycles = 1 (2 or 3). BTFSC, 16-Bit Instruction Word.MSb = 1011. BTFSC, 16-Bit Instruction Word.MSb = bbba. BTFSC, 16-Bit Instruction Word. = ffff. BTFSC,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n16-Bit Instruction Word.LSb = ffff. BTFSC, Status Affected.Status Affected = None. BTFSC, Notes.Notes = 3, 4. BTFSS, Mnemonic,.Operands = f, b, a. BTFSS, Description.Description = Bit Test f, Skip if Set. BTFSS, Cycles.Cycles = 1 (2 or 3). BTFSS, 16-Bit Instruction Word.MSb = 1010. BTFSS, 16-Bit Instruction Word.MSb = bbba. BTFSS, 16-Bit Instruction Word. = ffff. BTFSS, 16-Bit Instruction Word.LSb = ffff. BTFSS, Status Affected.Status Affected = None. BTFSS, Notes.Notes = 3, 4. BTG, Mnemonic,.Operands = f, d, a. BTG, Description.Description = Bit Toggle f. BTG, Cycles.Cycles = 1. BTG, 16-Bit Instruction Word.MSb = 0111. BTG, 16-Bit Instruction Word.MSb = bbba.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nBTG, 16-Bit Instruction Word. = ffff. BTG, 16-Bit Instruction Word.LSb = ffff. BTG, Status Affected.Status Affected = None. BTG, Notes.Notes = 1, 2. CONTROL OPERATIONS, Mnemonic,.Operands = CONTROL OPERATIONS. CONTROL OPERATIONS, Description.Description = CONTROL OPERATIONS. CONTROL OPERATIONS, Cycles.Cycles = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, Status Affected.Status Affected = CONTROL OPERATIONS. CONTROL OPERATIONS, Notes.Notes = CONTROL OPERATIONS. BC, Mnemonic,.Operands = n. BC, Description.Description = Branch if Carry. BC, Cycles.Cycles = 1 (2). BC, 16-Bit Instruction Word.MSb = 1110. BC, 16-Bit Instruction Word.MSb = 0010. BC, 16-Bit Instruction Word. = nnnn. BC,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n16-Bit Instruction Word.LSb = nnnn. BC, Status Affected.Status Affected = None. BC, Notes.Notes = . BN, Mnemonic,.Operands = n. BN, Description.Description = Branch if Negative. BN, Cycles.Cycles = 1 (2). BN, 16-Bit Instruction Word.MSb = 1110. BN, 16-Bit Instruction Word.MSb = 0110. BN, 16-Bit Instruction Word. = nnnn. BN, 16-Bit Instruction Word.LSb = nnnn. BN, Status Affected.Status Affected = None. BN, Notes.Notes = . BNC, Mnemonic,.Operands = n. BNC, Description.Description = Branch if Not Carry. BNC, Cycles.Cycles = 1 (2). BNC, 16-Bit Instruction Word.MSb = 1110. BNC, 16-Bit Instruction Word.MSb = 0011. BNC, 16-Bit Instruction Word. = nnnn. BNC, 16-Bit Instruction Word.LSb = nnnn. BNC, Status Affected.Status Affected",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= None. BNC, Notes.Notes = . BNN, Mnemonic,.Operands = n. BNN, Description.Description = Branch if Not Negative. BNN, Cycles.Cycles = 1 (2). BNN, 16-Bit Instruction Word.MSb = 1110. BNN, 16-Bit Instruction Word.MSb = 0111. BNN, 16-Bit Instruction Word. = nnnn. BNN, 16-Bit Instruction Word.LSb = nnnn. BNN, Status Affected.Status Affected = None. BNN, Notes.Notes = . BNOV, Mnemonic,.Operands = n. BNOV, Description.Description = Branch if Not Overflow. BNOV, Cycles.Cycles = 1 (2). BNOV, 16-Bit Instruction Word.MSb = 1110. BNOV, 16-Bit Instruction Word.MSb = 0101. BNOV, 16-Bit Instruction Word. = nnnn. BNOV, 16-Bit Instruction Word.LSb = nnnn. BNOV, Status Affected.Status Affected = None. BNOV,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNotes.Notes = . BNZ, Mnemonic,.Operands = n. BNZ, Description.Description = Branch if Not Zero. BNZ, Cycles.Cycles = 1 (2). BNZ, 16-Bit Instruction Word.MSb = 1110. BNZ, 16-Bit Instruction Word.MSb = 0001. BNZ, 16-Bit Instruction Word. = nnnn. BNZ, 16-Bit Instruction Word.LSb = nnnn. BNZ, Status Affected.Status Affected = None. BNZ, Notes.Notes = . BOV, Mnemonic,.Operands = n. BOV, Description.Description = Branch if Overflow. BOV, Cycles.Cycles = 1 (2). BOV, 16-Bit Instruction Word.MSb = 1110. BOV, 16-Bit Instruction Word.MSb = 0100. BOV, 16-Bit Instruction Word. = nnnn. BOV, 16-Bit Instruction Word.LSb = nnnn. BOV, Status Affected.Status Affected = None. BOV, Notes.Notes = . BRA,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nMnemonic,.Operands = n. BRA, Description.Description = Branch Unconditionally. BRA, Cycles.Cycles = 2. BRA, 16-Bit Instruction Word.MSb = 1101. BRA, 16-Bit Instruction Word.MSb = 0nnn. BRA, 16-Bit Instruction Word. = nnnn. BRA, 16-Bit Instruction Word.LSb = nnnn. BRA, Status Affected.Status Affected = None. BRA, Notes.Notes = . BZ, Mnemonic,.Operands = n. BZ, Description.Description = Branch if Zero. BZ, Cycles.Cycles = 1 (2). BZ, 16-Bit Instruction Word.MSb = 1110. BZ, 16-Bit Instruction Word.MSb = 0000. BZ, 16-Bit Instruction Word. = nnnn. BZ, 16-Bit Instruction Word.LSb = nnnn. BZ, Status Affected.Status Affected = None. BZ, Notes.Notes = . CALL, Mnemonic,.Operands = n, s. CALL, Description.Description = Call",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nSubroutine 1st word. CALL, Cycles.Cycles = 2. CALL, 16-Bit Instruction Word.MSb = 1110. CALL, 16-Bit Instruction Word.MSb = 110s. CALL, 16-Bit Instruction Word. = kkkk. CALL, 16-Bit Instruction Word.LSb = kkkk. CALL, Status Affected.Status Affected = None. CALL, Notes.Notes = . CLRWDT, Mnemonic,.Operands = GLYPH<151>. CLRWDT, Description.Description = Clear Watchdog Timer. CLRWDT, Cycles.Cycles = 1. CLRWDT, 16-Bit Instruction Word.MSb = 0000. CLRWDT, 16-Bit Instruction Word.MSb = 0000. CLRWDT, 16-Bit Instruction Word. = 0000. CLRWDT, 16-Bit Instruction Word.LSb = 0100. CLRWDT, Status Affected.Status Affected = TO, PD. CLRWDT, Notes.Notes = . DAW, Mnemonic,.Operands = GLYPH<151>.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nDAW, Description.Description = Decimal Adjust WREG. DAW, Cycles.Cycles = 1. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word.LSb = 0111. DAW, Status Affected.Status Affected = C. DAW, Notes.Notes = . GOTO, Mnemonic,.Operands = n. GOTO, Description.Description = Go to Address 1st word 2nd word. GOTO, Cycles.Cycles = 2. GOTO, 16-Bit Instruction Word.MSb = 1110. GOTO, 16-Bit Instruction Word.MSb = 1111. GOTO, 16-Bit Instruction Word. = kkkk kkkk. GOTO, 16-Bit Instruction Word.LSb = kkkk. GOTO, Status Affected.Status Affected = None. GOTO, Notes.Notes = . NOP, Mnemonic,.Operands = GLYPH<151>. NOP, Description.Description",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= No Operation. NOP, Cycles.Cycles = 1. NOP, 16-Bit Instruction Word.MSb = 1111 0000. NOP, 16-Bit Instruction Word.MSb = kkkk 0000. NOP, 16-Bit Instruction Word. = 0000. NOP, 16-Bit Instruction Word.LSb = kkkk 0000. NOP, Status Affected.Status Affected = None. NOP, Notes.Notes = . NOP, Mnemonic,.Operands = GLYPH<151>. NOP, Description.Description = No Operation. NOP, Cycles.Cycles = 1. NOP, 16-Bit Instruction Word.MSb = 1111. NOP, 16-Bit Instruction Word.MSb = xxxx. NOP, 16-Bit Instruction Word. = xxxx. NOP, 16-Bit Instruction Word.LSb = xxxx. NOP, Status Affected.Status Affected = None. NOP, Notes.Notes = 4. POP, Mnemonic,.Operands = GLYPH<151>. POP, Description.Description = Pop Top of Return Stack",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n(TOS) 1. POP, Cycles.Cycles = . POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word.LSb = 0110. POP, Status Affected.Status Affected = None. POP, Notes.Notes = . PUSH, Mnemonic,.Operands = GLYPH<151>. PUSH, Description.Description = Push Top of Return Stack (TOS) 1. PUSH, Cycles.Cycles = . PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word. = 0000. PUSH, 16-Bit Instruction Word.LSb = 0101. PUSH, Status Affected.Status Affected = None. PUSH, Notes.Notes = . RCALL, Mnemonic,.Operands = n. RCALL, Description.Description = Relative Call. RCALL, Cycles.Cycles = 2. RCALL, 16-Bit Instruction Word.MSb =",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n1101. RCALL, 16-Bit Instruction Word.MSb = 1nnn. RCALL, 16-Bit Instruction Word. = nnnn. RCALL, 16-Bit Instruction Word.LSb = nnnn. RCALL, Status Affected.Status Affected = None. RCALL, Notes.Notes = . RESET, Mnemonic,.Operands = . RESET, Description.Description = Software Device Reset. RESET, Cycles.Cycles = 1. RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word. = 1111. RESET, 16-Bit Instruction Word.LSb = 1111. RESET, Status Affected.Status Affected = All. RESET, Notes.Notes = . RETFIE, Mnemonic,.Operands = s. RETFIE, Description.Description = Return from Interrupt Enable. RETFIE, Cycles.Cycles = 2. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n16-Bit Instruction Word. = 0001. RETFIE, 16-Bit Instruction Word.LSb = 000s. RETFIE, Status Affected.Status Affected = GIE/GIEH,. RETFIE, Notes.Notes = . RETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with Literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected.Status Affected = None. RETLW, Notes.Notes = . RETURN, Mnemonic,.Operands = s. RETURN, Description.Description = . RETURN, Cycles.Cycles = 2. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word. = .",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nRETURN, 16-Bit Instruction Word.LSb = . RETURN, Status Affected.Status Affected = None. RETURN, Notes.Notes = . , Mnemonic,.Operands = . , Description.Description = Return from Subroutine. , Cycles.Cycles = . , 16-Bit Instruction Word.MSb = . , 16-Bit Instruction Word.MSb = . , 16-Bit Instruction Word. = 0001. , 16-Bit Instruction Word.LSb = 001s. , Status Affected.Status Affected = . , Notes.Notes = . SLEEP, Mnemonic,.Operands = GLYPH<151>. SLEEP, Description.Description = Go into Standby mode. SLEEP, Cycles.Cycles = 1. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word. = 0000. SLEEP, 16-Bit Instruction Word.LSb = 0011. SLEEP, Status Affected.Status Affected = TO, PD. SLEEP, Notes.Notes = ",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNote 1: When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is GLYPH<145> 1 GLYPH<146>  for a pin configured as an input and is driven low by an external device, the data will be written back with a GLYPH<145> 0 GLYPH<146> .\n2: If this instruction is executed on the TMR0 register (and where applicable, GLYPH<145>dGLYPH<146> = 1 ), the prescaler will be cleared if assigned.\n3: If the Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are two-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nLITERAL OPERATIONS,  = LITERAL OPERATIONS. LITERAL OPERATIONS, Description. = LITERAL OPERATIONS. LITERAL OPERATIONS, Cycles. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, Status Affected. = LITERAL OPERATIONS. LITERAL OPERATIONS, Notes. = LITERAL OPERATIONS. ADDLW,  = k. ADDLW, Description. = Add Literal and WREG. ADDLW, Cycles. = 1. ADDLW, 16-Bit Instruction Word.MSb = 0000. ADDLW, 16-Bit Instruction Word. = 1111. ADDLW, 16-Bit Instruction Word. = kkkk. ADDLW, 16-Bit Instruction Word.LSb = kkkk. ADDLW, Status Affected. = C, DC, Z, OV,. ADDLW, Notes. = N. ANDLW,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= k. ANDLW, Description. = AND Literal with WREG. ANDLW, Cycles. = 1. ANDLW, 16-Bit Instruction Word.MSb = 0000. ANDLW, 16-Bit Instruction Word. = 1011. ANDLW, 16-Bit Instruction Word. = kkkk. ANDLW, 16-Bit Instruction Word.LSb = kkkk. ANDLW, Status Affected. = Z, N. ANDLW, Notes. = . IORLW,  = k. IORLW, Description. = Inclusive OR Literal with WREG. IORLW, Cycles. = 1. IORLW, 16-Bit Instruction Word.MSb = 0000. IORLW, 16-Bit Instruction Word. = 1001. IORLW, 16-Bit Instruction Word. = kkkk. IORLW, 16-Bit Instruction Word.LSb = kkkk. IORLW, Status Affected. = Z, N. IORLW, Notes. = . LFSR,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= f, k. LFSR, Description. = Move Literal (12-bit) 2nd word to FSR(f) 1st word. LFSR, Cycles. = 2. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word. = 1110. LFSR, 16-Bit Instruction Word. = 00ff. LFSR, 16-Bit Instruction Word.LSb = kkkk. LFSR, Status Affected. = None. LFSR, Notes. = . MOVLB,  = k. MOVLB, Description. = Move Literal to BSR<3:0>. MOVLB, Cycles. = 1. MOVLB, 16-Bit Instruction Word.MSb = 0000. MOVLB, 16-Bit Instruction Word. = 0001. MOVLB, 16-Bit Instruction Word. = 0000. MOVLB, 16-Bit Instruction Word.LSb = kkkk. MOVLB, Status Affected. = None. MOVLB, Notes. = . MOVLW,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= k. MOVLW, Description. = Move Literal to WREG. MOVLW, Cycles. = 1. MOVLW, 16-Bit Instruction Word.MSb = 0000. MOVLW, 16-Bit Instruction Word. = 1110. MOVLW, 16-Bit Instruction Word. = kkkk. MOVLW, 16-Bit Instruction Word.LSb = kkkk. MOVLW, Status Affected. = None. MOVLW, Notes. = . MULLW,  = k. MULLW, Description. = Multiply Literal with WREG. MULLW, Cycles. = 1. MULLW, 16-Bit Instruction Word.MSb = 0000. MULLW, 16-Bit Instruction Word. = 1101. MULLW, 16-Bit Instruction Word. = kkkk. MULLW, 16-Bit Instruction Word.LSb = kkkk. MULLW, Status Affected. = None. MULLW, Notes. = . RETLW,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= k. RETLW, Description. = Return with Literal in WREG. RETLW, Cycles. = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word. = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected. = None. RETLW, Notes. = . SUBLW,  = k. SUBLW, Description. = Subtract WREG from Literal. SUBLW, Cycles. = 1. SUBLW, 16-Bit Instruction Word.MSb = 0000. SUBLW, 16-Bit Instruction Word. = 1000. SUBLW, 16-Bit Instruction Word. = kkkk. SUBLW, 16-Bit Instruction Word.LSb = kkkk. SUBLW, Status Affected. = C, DC, Z, OV,. SUBLW, Notes. = N. XORLW,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= k. XORLW, Description. = Exclusive OR Literal with WREG. XORLW, Cycles. = 1. XORLW, 16-Bit Instruction Word.MSb = 0000. XORLW, 16-Bit Instruction Word. = 1010. XORLW, 16-Bit Instruction Word. = kkkk. XORLW, 16-Bit Instruction Word.LSb = kkkk. XORLW, Status Affected. = Z, N. XORLW, Notes. = . DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Description. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Cycles. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.LSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Status Affected. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Notes. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. TBLRD*,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLRD*. TBLRD*, Description. = Table Read. TBLRD*, Cycles. = 2. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word. = 0000. TBLRD*, 16-Bit Instruction Word. = 0000. TBLRD*, 16-Bit Instruction Word.LSb = 1000. TBLRD*, Status Affected. = None. TBLRD*, Notes. = . TBLRD*+,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLRD*+. TBLRD*+, Description. = Table Read with Post-Increment. TBLRD*+, Cycles. = . TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected. = None. TBLRD*+, Notes. = . TBLRD*-,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLRD*-. TBLRD*-, Description. = Table Read with Post-Decrement. TBLRD*-, Cycles. = . TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word.LSb = 1010. TBLRD*-, Status Affected. = None. TBLRD*-, Notes. = . TBLRD+*,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLRD+*. TBLRD+*, Description. = Table Read with Pre-Increment. TBLRD+*, Cycles. = . TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected. = None. TBLRD+*, Notes. = . TBLWT*,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLWT*. TBLWT*, Description. = Table Write. TBLWT*, Cycles. = 2. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word.LSb = 1100. TBLWT*, Status Affected. = None. TBLWT*, Notes. = 5. TBLWT*+,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLWT*+. TBLWT*+, Description. = Table Write with Post-Increment. TBLWT*+, Cycles. = . TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word.LSb = 1101. TBLWT*+, Status Affected. = None. TBLWT*+, Notes. = 5. TBLWT*-,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLWT*-. TBLWT*-, Description. = Table Write with Post-Decrement. TBLWT*-, Cycles. = . TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word.LSb = 1110. TBLWT*-, Status Affected. = None. TBLWT*-, Notes. = 5. TBLWT+*,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= TBLWT+*. TBLWT+*, Description. = Table Write with Pre-Increment. TBLWT+*, Cycles. = . TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word.LSb = 1111. TBLWT+*, Status Affected. = None. TBLWT+*, Notes. = 5",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNote 1: When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is GLYPH<145> 1 GLYPH<146>  for a pin configured as an input and is driven low by an external device, the data will be written back with a GLYPH<145> 0 GLYPH<146> .\n2: If this instruction is executed on the TMR0 register (and where applicable, GLYPH<145>dGLYPH<146> = 1 ), the prescaler will be cleared if assigned.\n3: If the Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are two-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "ADD Literal to W\nSyntax:\nADDLW     k\nOperands:\n0 \u2264 k \u2264 255\nOperation:\n(W) + k \u2192 W\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0000\n1111\nkkkk\nkkkk\nDescription:\nThe contents of W are added to the 8-bit literal GLYPH<145>kGLYPH<146> and the result is placed in W.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral GLYPH<145>kGLYPH<146>\nProcess\nData\nWrite to W\nExample:\nADDLW 15h\nBefore Instruction\nW\n=\n10h\nAfter Instruction\nW = 25h",
    "ADDWF\nADD W to f\nSyntax:\nADDWF      f {,d {,a}}\nOperands:\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\nOperation:\n(W) + (f) \u2192 dest\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0010\n01da\nffff\nffff\nDescription:\nAdd W to register GLYPH<145>fGLYPH<146>. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is stored in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored back in register GLYPH<145>fGLYPH<146> (default).",
    "ADDWF\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nADDWF\nREG, 0, 0\nBefore Instruction\nW\n=\n17h\nREG\n=\n0C2h\nAfter Instruction\nW\n=\n0D9h\nREG\n=",
    "ADDWF\n0C2h\nNote:\nAll PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction format then becomes: {label} instruction argument(s).",
    "PIC18F6390/6490/8390/8490\nSyntax:, ADD Wand Carry bit to f = ADDWFC. Syntax:, ADD Wand Carry bit to f = f {,d {,a}}. Syntax:, ADD Wand Carry bit to f = f {,d {,a}}. Syntax:, ADD Wand Carry bit to f = f {,d {,a}}. Operands:, ADD Wand Carry bit to f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wand Carry bit to f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wand Carry bit to f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wand Carry bit to f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, ADD Wand Carry bit to f = (W) + (f) + (C) \u2192 dest. Operation:, ADD Wand Carry bit to f = (W) + (f) +",
    "PIC18F6390/6490/8390/8490\n(C) \u2192 dest. Operation:, ADD Wand Carry bit to f = (W) + (f) + (C) \u2192 dest. Operation:, ADD Wand Carry bit to f = (W) + (f) + (C) \u2192 dest. Status Affected:, ADD Wand Carry bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand Carry bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand Carry bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand Carry bit to f = N,OV, C, DC, Z. Encoding:, ADD Wand Carry bit to f = 0010. Encoding:, ADD Wand Carry bit to f = 00da. Encoding:, ADD Wand Carry bit to f = ffff. Encoding:, ADD Wand Carry bit to f = ffff. Description:, ADD Wand Carry bit to f = Add W, the Carry flag and data memory location GLYPH<145>fGLYPH<146>. If GLYPH<145>",
    "PIC18F6390/6490/8390/8490\ndGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed in data memory location GLYPH<145>fGLYPH<146>.. Description:, ADD Wand Carry bit to f = Add W, the Carry flag and data memory location GLYPH<145>fGLYPH<146>. If GLYPH<145> dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed in data memory location GLYPH<145>fGLYPH<146>.. Description:, ADD Wand Carry bit to f = Add W, the Carry flag and data memory location GLYPH<145>fGLYPH<146>. If GLYPH<145>",
    "PIC18F6390/6490/8390/8490\ndGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed in data memory location GLYPH<145>fGLYPH<146>.. Description:, ADD Wand Carry bit to f = Add W, the Carry flag and data memory location GLYPH<145>fGLYPH<146>. If GLYPH<145> dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed in data memory location GLYPH<145>fGLYPH<146>.. , ADD Wand Carry bit to f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.. , ADD Wand Carry bit to f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.. , ADD Wand Carry bit to f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.. , ADD Wand Carry bit to f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0",
    "PIC18F6390/6490/8390/8490\nGLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.. , ADD Wand Carry bit to f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed. , ADD Wand Carry bit to f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed. , ADD Wand Carry bit to f = If",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed. , ADD Wand Carry bit to f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed. Words:, ADD Wand Carry bit to f = 1. Words:, ADD Wand Carry bit to f = 1. Words:, ADD Wand Carry bit to f = 1. Words:, ADD Wand Carry bit to f = 1. Cycles:, ADD Wand Carry bit to f = 1. Cycles:, ADD Wand Carry bit to f = 1. Cycles:, ADD Wand Carry",
    "PIC18F6390/6490/8390/8490\nbit to f = 1. Cycles:, ADD Wand Carry bit to f = 1. Q Cycle Activity: Q1, ADD Wand Carry bit to f = Q2. Q Cycle Activity: Q1, ADD Wand Carry bit to f = Q3. Q Cycle Activity: Q1, ADD Wand Carry bit to f = . Q Cycle Activity: Q1, ADD Wand Carry bit to f = Q4. Decode, ADD Wand Carry bit to f = . Decode, ADD Wand Carry bit to f = Read register GLYPH<145>f GLYPH<146>. Decode, ADD Wand Carry bit to f = Process Data. Decode, ADD Wand Carry bit to f = Write to destination",
    "PIC18F6390/6490/8390/8490\nSyntax:, AND Literal with W = ANDLW. Syntax:, AND Literal with W = k. Syntax:, AND Literal with W = . Syntax:, AND Literal with W = . Operands:, AND Literal with W = 0 \u2264 k \u2264 255. Operands:, AND Literal with W = 0 \u2264 k \u2264 255. Operands:, AND Literal with W = . Operands:, AND Literal with W = . Operation:, AND Literal with W = (W) .AND. k \u2192 W. Operation:, AND Literal with W = (W) .AND. k \u2192 W. Operation:, AND Literal with W = . Operation:, AND Literal with W = . Status Affected:, AND Literal with W = N, Z. Status Affected:, AND Literal with W = . Status Affected:, AND Literal with W = . Status Affected:, AND Literal with W = . Encoding:, AND Literal with W = 0000. Encoding:, AND Literal with W = 1011. Encoding:, AND Literal with W = kkkk. Encoding:, AND Literal with W = kkkk. Description:, AND Literal with W =",
    "PIC18F6390/6490/8390/8490\nThe contents of Ware ANDed with the 8-bit literal GLYPH<145>kGLYPH<146>. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal GLYPH<145>kGLYPH<146>. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal GLYPH<145>kGLYPH<146>. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal GLYPH<145>kGLYPH<146>. The result is placed in W.. Words:, AND Literal with W = 1. Words:, AND Literal with W = . Words:, AND Literal with W = . Words:, AND Literal with W = . Cycles:, AND Literal with W = 1. Cycles:, AND Literal with W = . Cycles:, AND Literal with W = . Cycles:, AND Literal with W = . Q Cycle Activity:, AND Literal with W = .",
    "PIC18F6390/6490/8390/8490\nQ Cycle Activity:, AND Literal with W = . Q Cycle Activity:, AND Literal with W = . Q Cycle Activity:, AND Literal with W = . Q1, AND Literal with W = Q2. Q1, AND Literal with W = Q3. Q1, AND Literal with W = . Q1, AND Literal with W = Q4. Decode, AND Literal with W = Read literal GLYPH<145>kGLYPH<146>. Decode, AND Literal with W = Process Data. Decode, AND Literal with W = . Decode, AND Literal with W = Write to W. Example:, AND Literal with W = ANDLW. Example:, AND Literal with W = 05Fh. Example:, AND Literal with W = . Example:, AND Literal with W = . Before Instruction W =, AND Literal with W = A3h. Before Instruction W =, AND Literal with W = . Before Instruction W =, AND Literal with W = . Before Instruction W =, AND Literal with W = . After Instruction W =, AND Literal with W = 03h. After Instruction W =, AND Literal with W",
    "PIC18F6390/6490/8390/8490\n= . After Instruction W =, AND Literal with W = . After Instruction W =, AND Literal with W = ",
    "Example:\n, Q2.Read register GLYPH<145>f GLYPH<146> = ADDWFC. , Q3.Process Data = REG, 0,. , Q4.Write to destination = 1. Before Instruction Carry bit = REG = W = After Instruction Carry bit = REG =, Q2.Read register GLYPH<145>f GLYPH<146> = 1 02h 4Dh. Before Instruction Carry bit = REG = W = After Instruction Carry bit = REG =, Q3.Process Data = . Before Instruction Carry bit = REG = W = After Instruction Carry bit = REG =, Q4.Write to destination = \nWords:\nCycles:",
    "PIC18F6390/6490/8390/8490\nSyntax:, AND Wwith f = ANDWF. Syntax:, AND Wwith f = f {,d {,a}}. Syntax:, AND Wwith f = f {,d {,a}}. Syntax:, AND Wwith f = f {,d {,a}}. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 \u2208. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 \u2208. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 \u2208. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 \u2208. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Status",
    "PIC18F6390/6490/8390/8490\nAffected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Encoding:, AND Wwith f = 0001. Encoding:, AND Wwith f = 01da. Encoding:, AND Wwith f = ffff. Encoding:, AND Wwith f = ffff\nDescription:\nThe contents of W are ANDed with register GLYPH<145>fGLYPH<146>. If GLYPH<145>dGLYPH<146>  is GLYPH<145> 0 GLYPH<146>,  the result is stored in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>,  the  result is stored back in register GLYPH<145>fGLYPH<146> (default).",
    "PIC18F6390/6490/8390/8490\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nANDWF\nBefore Instruction\nW\n=\n17h\nREG\n=\nC2h\nAfter Instruction\nW\n=\n02h\nREG\n=\nC2h\nREG, 0, 0",
    "PIC18F6390/6490/8390/8490\nSyntax:,  = Syntax:. Syntax:, Branch if Carry = BC n. Syntax:, Branch if Carry = BC n. Syntax:, Branch if Carry = BC n. Syntax:, Branch if Carry = BC n. Syntax:, Branch if Carry = BC n. Operands:,  = Operands:. Operands:, Branch if Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Carry = -128 \u2264 n \u2264 127. Operation:,",
    "PIC18F6390/6490/8390/8490\n= Operation:. Operation:, Branch if Carry = if Carry bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Carry = if Carry bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Carry = if Carry bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Carry = if Carry bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Carry = if Carry bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Status Affected:,",
    "PIC18F6390/6490/8390/8490\n= Status Affected:. Status Affected:, Branch if Carry = None. Status Affected:, Branch if Carry = None. Status Affected:, Branch if Carry = None. Status Affected:, Branch if Carry = None. Status Affected:, Branch if Carry = None. Encoding:,  = Encoding:. Encoding:, Branch if Carry = 1110. Encoding:, Branch if Carry = 0010. Encoding:, Branch if Carry = nnnn. Encoding:, Branch if Carry = nnnn. Encoding:, Branch if Carry = nnnn. Description:,",
    "PIC18F6390/6490/8390/8490\n= Description:. Description:, Branch if Carry = If the Carry bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Carry = If the Carry bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Carry = If the Carry bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement",
    "PIC18F6390/6490/8390/8490\nnumber GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Carry = If the Carry bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Carry = If the Carry bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 +",
    "PIC18F6390/6490/8390/8490\n2n. This instruction is then a two-cycle instruction.. Words:,",
    "PIC18F6390/6490/8390/8490\n= Words:. Words:, Branch if Carry = 1. Words:, Branch if Carry = 1. Words:, Branch if Carry = 1. Words:, Branch if Carry = 1. Words:, Branch if Carry = 1. Cycles:,  = Cycles:. Cycles:, Branch if Carry = 1(2). Cycles:, Branch if Carry = 1(2). Cycles:, Branch if Carry = 1(2). Cycles:, Branch if Carry = 1(2). Cycles:, Branch if Carry = 1(2). Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:, Branch if Carry = . Q Cycle Activity:, Branch if Carry = . Q Cycle Activity:, Branch if Carry = . Q Cycle Activity:, Branch if Carry = . Q Cycle Activity:, Branch if Carry = . If Jump:,  = If Jump:. If Jump:, Branch if Carry = . If Jump:, Branch if Carry = . If Jump:, Branch if Carry = . If Jump:, Branch if Carry = . If Jump:, Branch if Carry = . ,",
    "PIC18F6390/6490/8390/8490\n= Q1. , Branch if Carry = Q2. , Branch if Carry = . , Branch if Carry = Q3. , Branch if Carry = . , Branch if Carry = Q4. ,  = Decode. , Branch if Carry = Read literal. , Branch if Carry = Read literal. , Branch if Carry = Process Data. , Branch if Carry = Process Data. , Branch if Carry = Write to PC. ,  = No operation. , Branch if Carry = No operation. , Branch if Carry = No operation. , Branch if Carry = No operation. , Branch if Carry = No operation. , Branch if Carry = No operation. If No Jump:,  = If No Jump:. If No Jump:, Branch if Carry = . If No Jump:, Branch if Carry = . If No Jump:, Branch if Carry = . If No Jump:, Branch if Carry = . If No Jump:, Branch if Carry = . ,  = Q1. , Branch if Carry = Q2. , Branch if Carry = Q2. , Branch if Carry = Q3. , Branch if Carry = Q3. , Branch if Carry = Q4. ,",
    "PIC18F6390/6490/8390/8490\n= Decode. , Branch if Carry = Read literal GLYPH<145>nGLYPH<146>. , Branch if Carry = Read literal GLYPH<145>nGLYPH<146>. , Branch if Carry = Process Data. , Branch if Carry = Process Data. , Branch if Carry = No operation. Example:,  = Example:. Example:, Branch if Carry = HERE. Example:, Branch if Carry = BC. Example:, Branch if Carry = . Example:, Branch if Carry = 5. Example:, Branch if Carry = . Before Instruction,  = Before Instruction. Before Instruction, Branch if Carry = Before Instruction. Before Instruction, Branch if Carry = . Before Instruction, Branch if Carry = . Before Instruction, Branch if Carry = . Before Instruction, Branch if Carry = . ,  = PC After Instruction. , Branch if Carry = =. , Branch if Carry = address. , Branch if Carry = address. , Branch if Carry = (HERE). , Branch if Carry = . ,",
    "PIC18F6390/6490/8390/8490\n= If Carry PC. , Branch if Carry = = =. , Branch if Carry = 1; address. , Branch if Carry = 1; address. , Branch if Carry = (HERE. , Branch if Carry = + 12). ,  = If Carry PC. , Branch if Carry = = =. , Branch if Carry = 0; address. , Branch if Carry = 0; address. , Branch if Carry = (HERE. , Branch if Carry = + 2)",
    "PIC18F6390/6490/8390/8490\nBCF, 1 = Bit Clear f. BCF, 2 = Bit Clear f. BCF, 3 = Bit Clear f. Syntax:, 1 = BCF f, b {,a}. Syntax:, 2 = BCF f, b {,a}. Syntax:, 3 = BCF f, b {,a}. Operands:, 1 = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, 2 = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operation:, 1 = 0 \u2192 f<b>. Operation:, 2 = 0 \u2192 f<b>. Operation:, 3 = 0 \u2192 f<b>. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Encoding:, 1 = 1001. Encoding:, 2 = bbba. Encoding:, 3 = ffff ffff. Description:, 1 = Bit",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>bGLYPH<146> in register GLYPH<145>f GLYPH<146> is cleared. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction. Description:, 2 = Bit GLYPH<145>bGLYPH<146> in register GLYPH<145>f GLYPH<146> is cleared. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select",
    "PIC18F6390/6490/8390/8490\nthe GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction. Description:, 3 = Bit GLYPH<145>bGLYPH<146> in register GLYPH<145>f GLYPH<146> is cleared. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Q Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle",
    "PIC18F6390/6490/8390/8490\nActivity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register GLYPH<145>f GLYPH<146>. Decode, 2 = Process Data. Decode, 3 = Write register GLYPH<145>f GLYPH<146>. Example:, 1 = BCF. Example:, 2 = FLAG_REG,. Example:, 3 = 7, 0. Before Instruction FLAG_REG = C7h After Instruction FLAG_REG = 47h, 1 = Before Instruction FLAG_REG = C7h After Instruction FLAG_REG = 47h. Before Instruction FLAG_REG = C7h After Instruction FLAG_REG = 47h, 2 = . Before Instruction FLAG_REG = C7h After Instruction FLAG_REG = 47h, 3 = ",
    "PIC18F6390/6490/8390/8490\nBN Branch if Negative, 1 = BN Branch if Negative. BN Branch if Negative, 2 = BN Branch if Negative. BN Branch if Negative, 3 = BN Branch if Negative. BN Branch if Negative, 4 = BN Branch if Negative. BN Branch if Negative, 5 = BN Branch if Negative. Syntax:, 1 = Syntax:. Syntax:, 2 = BN n. Syntax:, 3 = BN n. Syntax:, 4 = BN n. Syntax:, 5 = BN n. Operands:, 1 = Operands:. Operands:, 2 = -128 \u2264 n \u2264 127. Operands:, 3 = -128 \u2264 n \u2264 127. Operands:, 4 = -128 \u2264 n \u2264 127. Operands:, 5 = -128 \u2264 n \u2264 127. Operation:, 1 = Operation:. Operation:, 2 = if Negative bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, 3 = if Negative bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:,",
    "PIC18F6390/6490/8390/8490\n4 = if Negative bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, 5 = if Negative bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 1110. Encoding:, 3 = 0110. Encoding:, 4 = nnnn nnnn. Encoding:, 5 = nnnn nnnn. Description:, 1 = Description:. Description:, 2 = If the Negative bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be",
    "PIC18F6390/6490/8390/8490\nPC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 3 = If the Negative bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 4 = If the Negative bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 5 = If the Negative bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The",
    "PIC18F6390/6490/8390/8490\n2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1(2). Cycles:, 3 = 1(2). Cycles:, 4 = 1(2). Cycles:, 5 = 1(2). Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . Q Cycle Activity:, 5 = . If Jump:, 1 = If Jump:. If Jump:, 2 = If Jump:. If Jump:, 3 = . If Jump:, 4 = . If Jump:, 5 = . , 1 =",
    "PIC18F6390/6490/8390/8490\nQ1. , 2 = Q2. , 3 = Q3. , 4 = Q4. , 5 = Q4. , 1 = Decode. , 2 = Read literal GLYPH<145>nGLYPH<146>. , 3 = Process Data. , 4 = Write to PC. , 5 = Write to PC. , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = No operation. , 5 = No operation. If No Jump:, 1 = If No Jump:. If No Jump:, 2 = If No Jump:. If No Jump:, 3 = . If No Jump:, 4 = . If No Jump:, 5 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 5 = . , 1 = Decode. , 2 = literal GLYPH<145>nGLYPH<146>. , 3 = Process Data. , 4 = Read. , 5 = Read. , 1 = Example:. , 2 = . , 3 = BN. , 4 = HERE. , 5 = HERE. , 1",
    "PIC18F6390/6490/8390/8490\n= Before PC. , 2 = . , 3 = address. , 4 = Instruction =. , 5 = Instruction =. , 1 = After Instruction If Negative. , 2 = =. , 3 = 1; address. , 4 = =. , 5 = =. , 1 = If Negative. , 2 = =. , 3 = . , 4 = . , 5 = . , 1 = PC. , 2 = . , 3 = . , 4 = . , 5 = . , 1 = . , 2 = . , 3 = address. , 4 = . , 5 = . , 1 = . , 2 = . , 3 = . , 4 = 2). , 5 = 2). , 1 = . , 2 = =. , 3 = . , 4 = . , 5 = . , 1 = . , 2 = . , 3 = . , 4 = +. , 5 = +. , 1 = . , 2 = 0;. , 3 = . , 4 = . , 5 = . , 1 = PC. , 2 = . , 3 = . , 4 = . , 5 = . , 1 = . , 2 = . , 3 =",
    "PIC18F6390/6490/8390/8490\n(HERE. , 4 = . , 5 = . , 1 = . , 2 = . , 3 = . , 4 = (Jump). , 5 = ",
    "PIC18F6390/6490/8390/8490\nBNC Branch if Not Carry, 1 = BNC Branch if Not Carry. BNC Branch if Not Carry, 2 = BNC Branch if Not Carry. BNC Branch if Not Carry, 3 = BNC Branch if Not Carry. Syntax: BNC n, 1 = Syntax: BNC n. Syntax: BNC n, 2 = Syntax: BNC n. Syntax: BNC n, 3 = Syntax: BNC n. Operands: -128 \u2264 n \u2264 127, 1 = Operands: -128 \u2264 n \u2264 127. Operands: -128 \u2264 n \u2264 127, 2 = Operands: -128 \u2264 n \u2264 127. Operands: -128 \u2264 n \u2264 127, 3 = Operands: -128 \u2264 n \u2264 127. Operation: if Carry bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC, 1 = Operation: if Carry bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation: if Carry bit is GLYPH<145> 0 GLYPH<146>,",
    "PIC18F6390/6490/8390/8490\n(PC) + 2 + 2n \u2192 PC, 2 = Operation: if Carry bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation: if Carry bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC, 3 = Operation: if Carry bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Status Affected: None, 1 = Status Affected: None. Status Affected: None, 2 = Status Affected: None. Status Affected: None, 3 = Status Affected: None. Encoding: 1110 0011 nnnn nnnn Description: If the Carry bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is",
    "PIC18F6390/6490/8390/8490\nthen a two-cycle instruction. 1, 1 = Encoding: 1110 0011 nnnn nnnn Description: If the Carry bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction. 1. Encoding: 1110 0011 nnnn nnnn Description: If the Carry bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction. 1, 2 = Encoding: 1110 0011 nnnn nnnn Description: If the",
    "PIC18F6390/6490/8390/8490\nCarry bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction. 1. Encoding: 1110 0011 nnnn nnnn Description: If the Carry bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction. 1, 3 = Encoding: 1110 0011 nnnn nnnn Description: If the Carry bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The",
    "PIC18F6390/6490/8390/8490\n2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction. 1. Words:, 1 = Words:. Words:, 2 = Words:. Words:, 3 = Words:. Cycles: 1(2), 1 = Cycles: 1(2). Cycles: 1(2), 2 = Cycles: 1(2). Cycles: 1(2), 3 = Cycles: 1(2). Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. If Jump:, 1 = If Jump:. If Jump:, 2 = If Jump:. If Jump:, 3 = If Jump:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 1 = Decode. , 2 = Read literal",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>nGLYPH<146>. , 3 = Process Data. , 1 = No. , 2 = No. , 3 = No. , 1 = operation. , 2 = operation. , 3 = operation. If No Jump:, 1 = If No Jump:. If No Jump:, 2 = If No Jump:. If No Jump:, 3 = If No Jump:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 1 = . , 2 = Read literal GLYPH<145>nGLYPH<146>. , 3 = Process Data. , 1 = . , 2 = HERE. , 3 = BNC. , 1 = PC. , 2 = =. , 3 = . , 1 = After Instruction. , 2 = . , 3 = address. , 1 = If Carry. , 2 = =. , 3 = . , 1 = PC. , 2 = . , 3 = (HERE. , 1 = . , 2 = . , 3 = address. , 1 = . , 2 = . , 3 = . , 1 = . , 2 = =. , 3",
    "PIC18F6390/6490/8390/8490\n= . , 1 = . , 2 = . , 3 = . , 1 = . , 2 = =. , 3 = 1;. , 1 = . , 2 = . , 3 = . , 1 = . , 2 = . , 3 = . , 1 = . , 2 = . , 3 = address. , 1 = . , 2 = . , 3 = ",
    "PIC18F6390/6490/8390/8490\nBNN Branch if Not Negative, 1 = BNN Branch if Not Negative. BNN Branch if Not Negative, 2 = BNN Branch if Not Negative. BNN Branch if Not Negative, 3 = BNN Branch if Not Negative. BNN Branch if Not Negative, 4 = BNN Branch if Not Negative. Syntax: BNN n, 1 = Syntax: BNN n. Syntax: BNN n, 2 = Syntax: BNN n. Syntax: BNN n, 3 = Syntax: BNN n. Syntax: BNN n, 4 = Syntax: BNN n. Operands: -128 \u2264 n \u2264 127, 1 = Operands: -128 \u2264 n \u2264 127. Operands: -128 \u2264 n \u2264 127, 2 = Operands: -128 \u2264 n \u2264 127. Operands: -128 \u2264 n \u2264 127, 3 = Operands: -128 \u2264 n \u2264 127. Operands: -128 \u2264 n \u2264 127, 4 = Operands: -128 \u2264 n \u2264 127. Operation: if Negative bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC, 1 =",
    "PIC18F6390/6490/8390/8490\nOperation: if Negative bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation: if Negative bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC, 2 = Operation: if Negative bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation: if Negative bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC, 3 = Operation: if Negative bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation: if Negative bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC, 4 = Operation: if Negative bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Status Affected: None, 1 = Status Affected: None. Status Affected: None, 2",
    "PIC18F6390/6490/8390/8490\n= Status Affected: None. Status Affected: None, 3 = Status Affected: None. Status Affected: None, 4 = Status Affected: None. Encoding: 1110 0111 nnnn nnnn Description: If the Negative bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction., 1 = Encoding: 1110 0111 nnnn nnnn Description: If the Negative bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle",
    "PIC18F6390/6490/8390/8490\ninstruction.. Encoding: 1110 0111 nnnn nnnn Description: If the Negative bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction., 2 = Encoding: 1110 0111 nnnn nnnn Description: If the Negative bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Encoding: 1110 0111 nnnn nnnn Description: If the Negative bit is GLYPH<145> 0",
    "PIC18F6390/6490/8390/8490\nGLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction., 3 = Encoding: 1110 0111 nnnn nnnn Description: If the Negative bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Encoding: 1110 0111 nnnn nnnn Description: If the Negative bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction., 4 = Encoding: 1110 0111 nnnn nnnn Description: If the Negative bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words: 1, 1 = Words: 1. Words: 1, 2 = Words: 1. Words: 1, 3 = Words: 1. Words: 1, 4 = Words: 1. Cycles: 1(2), 1 = Cycles: 1(2). Cycles: 1(2), 2 = Cycles: 1(2). Cycles:",
    "PIC18F6390/6490/8390/8490\n1(2), 3 = Cycles: 1(2). Cycles: 1(2), 4 = Cycles: 1(2). Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. If Jump:, 1 = If Jump:. If Jump:, 2 = If Jump:. If Jump:, 3 = If Jump:. If Jump:, 4 = If Jump:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = Q4. , 1 = Decode. , 2 = Read literal GLYPH<145>nGLYPH<146>. , 3 = Process Data. , 4 = Write to PC. , 1 = No. , 2 = No. , 3 = No. , 4 = . , 1 = operation. , 2 = operation. , 3 = operation. , 4 = . If No Jump:, 1 = If No Jump:. If No Jump:, 2 = If No Jump:.",
    "PIC18F6390/6490/8390/8490\nIf No Jump:, 3 = If No Jump:. If No Jump:, 4 = If No Jump:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read literal GLYPH<145>nGLYPH<146>. , 3 = Process Data. , 4 = . , 1 = Example:. , 2 = HERE. , 3 = BNN. , 4 = . , 1 = PC. , 2 = =. , 3 = address. , 4 = Before Instruction. , 1 = After Instruction. , 2 = =. , 3 = . , 4 = Negative. , 1 = If Negative. , 2 = =. , 3 = . , 4 = PC. , 1 = . , 2 = . , 3 = address. , 4 = . , 1 = . , 2 = . , 3 = . , 4 = 2). , 1 = . , 2 = . , 3 = . , 4 = +. , 1 = . , 2 = =. , 3 = . , 4 = . , 1 = . , 2 = 1;.",
    "PIC18F6390/6490/8390/8490\n, 3 = . , 4 = . , 1 = . , 2 = =. , 3 = . , 4 = . , 1 = PC. , 2 = . , 3 = . , 4 = . , 1 = . , 2 = . , 3 = . , 4 = 0; address. , 1 = . , 2 = . , 3 = . , 4 = . , 1 = . , 2 = . , 3 = . , 4 = (Jump)",
    "PIC18F6390/6490/8390/8490\nSyntax:, Branch if Not Overflow = BNOV n. Syntax:, Branch if Not Overflow = BNOV n. Syntax:, Branch if Not Overflow = BNOV n. Syntax:, Branch if Not Overflow = BNOV n. Syntax:, Branch if Not Overflow = BNOV n. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operation:, Branch if Not Overflow = if Overflow bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Overflow = if Overflow bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Overflow = if Overflow bit",
    "PIC18F6390/6490/8390/8490\nis GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Overflow = if Overflow bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Overflow = if Overflow bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Encoding:, Branch if Not Overflow = 1110. Encoding:, Branch if Not Overflow = 0101. Encoding:, Branch if Not Overflow = nnnn. Encoding:, Branch if Not Overflow = nnnn. Encoding:, Branch if Not Overflow = nnnn. Description:, Branch if Not Overflow = If the Overflow bit",
    "PIC18F6390/6490/8390/8490\nis GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Not Overflow = If the Overflow bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Not Overflow = If the Overflow bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the",
    "PIC18F6390/6490/8390/8490\nPC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Not Overflow = If the Overflow bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Description:, Branch if Not Overflow = If the Overflow bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a. Words:, Branch if Not Overflow = 1. Words:, Branch",
    "PIC18F6390/6490/8390/8490\nif Not Overflow = 1. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Q Cycle Activity: If, Branch if Not Overflow = . Q Cycle Activity: If, Branch if Not Overflow = . Q Cycle Activity: If, Branch if Not Overflow = . Q Cycle Activity: If, Branch if Not Overflow = . Q Cycle Activity: If, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . Q1, Branch if Not Overflow = Q2. Q1, Branch",
    "PIC18F6390/6490/8390/8490\nif Not Overflow = . Q1, Branch if Not Overflow = Q3. Q1, Branch if Not Overflow = . Q1, Branch if Not Overflow = Q4. Decode, Branch if Not Overflow = Read literal GLYPH<145>nGLYPH<146> Process Data Write to PC No operation No operation No operation. Decode, Branch if Not Overflow = Read literal GLYPH<145>nGLYPH<146> Process Data Write to PC No operation No operation No operation. Decode, Branch if Not Overflow = Read literal GLYPH<145>nGLYPH<146> Process Data Write to PC No operation No operation No operation. Decode, Branch if Not Overflow = Read literal GLYPH<145>nGLYPH<146> Process Data Write to PC No operation No operation No operation. Decode, Branch if Not Overflow = Read literal GLYPH<145>nGLYPH<146> Process Data Write to PC No operation No operation No operation. Q1, Branch if Not Overflow = Q2 Q3 Q4 Read literal Process No. Q1, Branch if Not",
    "PIC18F6390/6490/8390/8490\nOverflow = Q2 Q3 Q4 Read literal Process No. Q1, Branch if Not Overflow = Q2 Q3 Q4 Read literal Process No. Q1, Branch if Not Overflow = Q2 Q3 Q4 Read literal Process No. Q1, Branch if Not Overflow = Q2 Q3 Q4 Read literal Process No. Decode Example: Before, Branch if Not Overflow = GLYPH<145>nGLYPH<146> HERE Instruction. Decode Example: Before, Branch if Not Overflow = BNOV address. Decode Example: Before, Branch if Not Overflow = Data Jump (HERE). Decode Example: Before, Branch if Not Overflow = . Decode Example: Before, Branch if Not Overflow = operation. PC After Instruction If Overflow, Branch if Not Overflow = = = =. PC After Instruction If Overflow, Branch if Not Overflow = 0; address. PC After Instruction If Overflow, Branch if Not Overflow = (Jump). PC After Instruction If Overflow, Branch if Not Overflow = . PC After Instruction If Overflow, Branch if Not Overflow = .",
    "PIC18F6390/6490/8390/8490\nPC If Overflow, Branch if Not Overflow = =. PC If Overflow, Branch if Not Overflow = 1; address. PC If Overflow, Branch if Not Overflow = (HERE. PC If Overflow, Branch if Not Overflow = + 2). PC If Overflow, Branch if Not Overflow = . PC, Branch if Not Overflow = =. PC, Branch if Not Overflow = . PC, Branch if Not Overflow = . PC, Branch if Not Overflow = . PC, Branch if Not Overflow = ",
    "PIC18F6390/6490/8390/8490\nBNZ Branch if Not Zero, 1 = BNZ Branch if Not Zero. BNZ Branch if Not Zero, 2 = BNZ Branch if Not Zero. BNZ Branch if Not Zero, 3 = BNZ Branch if Not Zero. BNZ Branch if Not Zero, 4 = BNZ Branch if Not Zero. Syntax: BNZ n, 1 = Syntax: BNZ n. Syntax: BNZ n, 2 = Syntax: BNZ n. Syntax: BNZ n, 3 = Syntax: BNZ n. Syntax: BNZ n, 4 = Syntax: BNZ n. Operands: -128 \u2264 n \u2264 127, 1 = Operands: -128 \u2264 n \u2264 127. Operands: -128 \u2264 n \u2264 127, 2 = Operands: -128 \u2264 n \u2264 127. Operands: -128 \u2264 n \u2264 127, 3 = Operands: -128 \u2264 n \u2264 127. Operands: -128 \u2264 n \u2264 127, 4 = Operands: -128 \u2264 n \u2264 127. Operation: if Zero bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC, 1 =",
    "PIC18F6390/6490/8390/8490\nOperation: if Zero bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation: if Zero bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC, 2 = Operation: if Zero bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation: if Zero bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC, 3 = Operation: if Zero bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation: if Zero bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC, 4 = Operation: if Zero bit is GLYPH<145> 0 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Status Affected: None, 1 = Status Affected: None. Status Affected: None, 2",
    "PIC18F6390/6490/8390/8490\n= Status Affected: None. Status Affected: None, 3 = Status Affected: None. Status Affected: None, 4 = Status Affected: None. Encoding: 1110 0001 nnnn nnnn Description: If the Zero bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction. 1, 1 = Encoding: 1110 0001 nnnn nnnn Description: If the Zero bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle",
    "PIC18F6390/6490/8390/8490\ninstruction. 1. Encoding: 1110 0001 nnnn nnnn Description: If the Zero bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction. 1, 2 = Encoding: 1110 0001 nnnn nnnn Description: If the Zero bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction. 1. Encoding: 1110 0001 nnnn nnnn Description: If the Zero bit is",
    "PIC18F6390/6490/8390/8490\nGLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction. 1, 3 = Encoding: 1110 0001 nnnn nnnn Description: If the Zero bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction. 1. Encoding: 1110 0001 nnnn nnnn Description: If the Zero bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The",
    "PIC18F6390/6490/8390/8490\n2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction. 1, 4 = Encoding: 1110 0001 nnnn nnnn Description: If the Zero bit is GLYPH<145> 0 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction. 1. Words:, 1 = Words:. Words:, 2 = Words:. Words:, 3 = Words:. Words:, 4 = Words:. Cycles: 1(2), 1 = Cycles: 1(2). Cycles: 1(2), 2 = Cycles: 1(2). Cycles:",
    "PIC18F6390/6490/8390/8490\n1(2), 3 = Cycles: 1(2). Cycles: 1(2), 4 = Cycles: 1(2). Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. If Jump:, 1 = If Jump:. If Jump:, 2 = If Jump:. If Jump:, 3 = If Jump:. If Jump:, 4 = If Jump:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = Q4. , 1 = Decode. , 2 = Read literal GLYPH<145>nGLYPH<146>. , 3 = Process Data. , 4 = Write to PC. , 1 = No. , 2 = No. , 3 = No. , 4 = No. , 1 = operation. , 2 = operation. , 3 = operation. , 4 = operation. If No Jump:, 1 = If No Jump:. If No Jump:, 2 = If No",
    "PIC18F6390/6490/8390/8490\nJump:. If No Jump:, 3 = If No Jump:. If No Jump:, 4 = If No Jump:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = Q4. Decode, 1 = . Decode, 2 = Read literal GLYPH<145>nGLYPH<146>. Decode, 3 = Process Data. Decode, 4 = No operation. Example:, 1 = Before Instruction. Example:, 2 = . Example:, 3 = BNZ. Example:, 4 = Jump. PC After Instruction, 1 = PC After Instruction. PC After Instruction, 2 = PC After Instruction. PC After Instruction, 3 = PC After Instruction. PC After Instruction, 4 = PC After Instruction. , 1 = If Zero. , 2 = =. , 3 = address. , 4 = (HERE). If, 1 = Zero. If, 2 = =. If, 3 = . If, 4 = . , 1 = . , 2 = =. , 3 = . , 4 = 2). , 1 = . , 2 = . , 3 = (HERE. ,",
    "PIC18F6390/6490/8390/8490\n4 = . PC, 1 = . PC, 2 = . PC, 3 = . PC, 4 = . , 1 = . , 2 = . , 3 = . , 4 = +. , 1 = . , 2 = . , 3 = 1; address. , 4 = . , 1 = PC. , 2 = =. , 3 = . , 4 = . , 1 = . , 2 = =. , 3 = . , 4 = . , 1 = . , 2 = . , 3 = (Jump). , 4 = (Jump). , 1 = . , 2 = 0; address. , 3 = . , 4 = ",
    "Unconditional Branch\nSyntax:\nBRA    n\nOperands:\n-1024 \u2264 n \u2264 1023\nOperation:\n(PC) + 2 + 2n \u2192 PC\nStatus Affected:\nNone\nEncoding:\n1101\n0nnn\nnnnn\nnnnn\nDescription:\nAdd the 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal\nGLYPH<145>nGLYPH<146>\nProcess\nData\nWrite to PC\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nExample:\nHERE\nBRA Jump\nBefore Instruction\nPC\n=\naddress\n(HERE)\nAfter Instruction\nPC\n=\naddress\n(Jump)",
    "Unconditional Branch\nBSF, 1 = Bit Set f. BSF, 2 = Bit Set f. BSF, 3 = Bit Set f. BSF, 4 = Bit Set f. Syntax:, 1 = BSF f, b {,a}. Syntax:, 2 = BSF f, b {,a}. Syntax:, 3 = BSF f, b {,a}. Syntax:, 4 = BSF f, b {,a}. Operands:, 1 = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, 2 = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, 4 = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operation:, 1 = 1 \u2192 f<b>. Operation:, 2 = 1 \u2192 f<b>. Operation:, 3 = 1 \u2192 f<b>. Operation:, 4 = 1 \u2192 f<b>. Status Affected:, 1 = None. Status Affected:,",
    "Unconditional Branch\n2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 1000. Encoding:, 2 = bbba. Encoding:, 3 = ffff. Encoding:, 4 = ffff. Description:, 1 = Bit GLYPH<145>bGLYPH<146> in register GLYPH<145>f GLYPH<146> is set. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See. Description:, 2 = Bit GLYPH<145>bGLYPH<146> in register GLYPH<145>f GLYPH<146> is",
    "Unconditional Branch\nset. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See. Description:, 3 = Bit GLYPH<145>bGLYPH<146> in register GLYPH<145>f GLYPH<146> is set. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If",
    "Unconditional Branch\nGLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See. Description:, 4 = Bit GLYPH<145>bGLYPH<146> in register GLYPH<145>f GLYPH<146> is set. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:,",
    "Unconditional Branch\n1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . Q1, 1 = . Q1, 2 = . Q1, 3 = . Q1, 4 = . , 1 = Q2. , 2 = Q3. , 3 = Q3. , 4 = Q4 Write register GLYPH<145>f. Decode Example:, 1 = Read register GLYPH<145>f BSF. Decode Example:, 2 = Process Data FLAG_REG, 7,. Decode Example:, 3 = Process Data FLAG_REG, 7,. Decode Example:, 4 = GLYPH<146> 1. Before Instruction, 1 = Before Instruction. Before Instruction, 2 = 0Ah. Before Instruction, 3 = 0Ah. Before Instruction, 4 = 0Ah",
    "Bit Test File, Skip if Clear\nSyntax:\nBTFSC   f, b {,a}\nOperands:\n0 \u2264 f \u2264 255\n0 \u2264 b \u2264 7\na \u2208 [0,1]\nOperation:\nskip if (f<b>) = 0\nStatus Affected:\nNone\nEncoding:\n1011\nbbba\nffff\nffff\nDescription:\nIf bit GLYPH<145>bGLYPH<146> in register GLYPH<145>fGLYPH<146> is GLYPH<145> 0 GLYPH<146>, then the next instruction is skipped. If bit GLYPH<145>bGLYPH<146> is GLYPH<145> 0 GLYPH<146>, then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145> aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.",
    "Bit Test File, Skip if Clear\nIf GLYPH<145>aGLYPH<146>  is  GLYPH<145> 0 GLYPH<146>   and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh).\nSee Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Bit Test File, Skip if Set\nSyntax:\nBTFSS f, b {,a}\nOperands:\n0 \u2264 f \u2264 255\n0 \u2264 b < 7\na \u2208 [0,1]\nOperation:\nskip if (f<b>) = 1\nStatus Affected:\nNone\nEncoding:\n1010\nbbba\nffff\nffff\nDescription:\nIf bit GLYPH<145>bGLYPH<146> in register GLYPH<145>fGLYPH<146> is GLYPH<145> 1 GLYPH<146> , then the next instruction is skipped. If bit GLYPH<145>bGLYPH<146> is GLYPH<145> 1 GLYPH<146> , then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145> aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.",
    "Bit Test File, Skip if Set\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh).\nSee Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\nWords:\n1\nCycles:\n1(2)\nNote:",
    "Q Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>fGLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = No operation\nIf skip:\nNo operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE\nFALSE\nTRUE\nBTFSC\n:\n:\nFLAG, 1, 0\nAfter Instruction If FLAG<1>, = = =. After Instruction If FLAG<1>, address = 0; address (TRUE). PC, = = =. PC, address = . If FLAG<1> PC, = = = =. If FLAG<1> PC, address = 1; address (FALSE)\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>fGLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = No operation. If skip:, Q2 = . If skip:, Q3 = . If skip:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word, Q2 = skip and followed by 2-word. skip and followed by 2-word, Q3 = instruction:. skip and followed by 2-word, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE\nFALSE\nTRUE",
    "Q Cycle Activity:\nBTFSS FLAG, 1, 0\n:\n:\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf FLAG<1>\n=\n0;\nPC\n=\naddress (FALSE)\nIf FLAG<1>\n=\n1;\nPC\n=\naddress (TRUE)",
    "PIC18F6390/6490/8390/8490\nSyntax:, Bit Toggle f = BTG f, b {,a}. Syntax:, Bit Toggle f = BTG f, b {,a}. Syntax:, Bit Toggle f = BTG f, b {,a}. Syntax:, Bit Toggle f = BTG f, b {,a}. Operands:, Bit Toggle f = 0 \u2264 f \u2264 255. Operands:, Bit Toggle f = 0 \u2264 f \u2264 255. Operands:, Bit Toggle f = 0 \u2264 f \u2264 255. Operands:, Bit Toggle f = 0 \u2264 f \u2264 255. , Bit Toggle f = 0 \u2264 b < 7. , Bit Toggle f = 0 \u2264 b < 7. , Bit Toggle f = 0 \u2264 b < 7. , Bit Toggle f = 0 \u2264 b < 7. , Bit Toggle f = a \u2208 [0,1]. , Bit Toggle f = a \u2208 [0,1]. , Bit Toggle f = a \u2208 [0,1]. , Bit Toggle f = a \u2208 [0,1]. Operation:, Bit",
    "PIC18F6390/6490/8390/8490\nToggle f = (f<b>) \u2192 f<b>. Operation:, Bit Toggle f = (f<b>) \u2192 f<b>. Operation:, Bit Toggle f = (f<b>) \u2192 f<b>. Operation:, Bit Toggle f = (f<b>) \u2192 f<b>. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Encoding:, Bit Toggle f = 0111. Encoding:, Bit Toggle f = bbba. Encoding:, Bit Toggle f = ffff. Encoding:, Bit Toggle f = ffff\nDescription:\nBit GLYPH<145>bGLYPH<146> in data memory location GLYPH<145>fGLYPH<146> is inverted.",
    "PIC18F6390/6490/8390/8490\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>,  the BSR is used to select the GPR bank.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write register GLYPH<145>fGLYPH<146>",
    "PIC18F6390/6490/8390/8490\nBefore Instruction: PORTC =, BTG = 0111. Before Instruction: PORTC =, PORTC, = 0101. Before Instruction: PORTC =, 4, 0 = [75h]. After Instruction: PORTC =, BTG = 0110. After Instruction: PORTC =, PORTC, = 0101. After Instruction: PORTC =, 4, 0 = [65h]",
    "PIC18F6390/6490/8390/8490\nSyntax:, Branch if Overflow = BOV n. Syntax:, Branch if Overflow = BOV n. Syntax:, Branch if Overflow = BOV n. Syntax:, Branch if Overflow = BOV n. Syntax:, Branch if Overflow = BOV n. Syntax:, Branch if Overflow = BOV n. Operands:, Branch if Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Overflow = -128 \u2264 n \u2264 127. Operation:, Branch if Overflow = if Overflow bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Overflow = if Overflow bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n",
    "PIC18F6390/6490/8390/8490\n\u2192 PC. Operation:, Branch if Overflow = if Overflow bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Overflow = if Overflow bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Overflow = if Overflow bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Overflow = if Overflow bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Encoding:, Branch if Overflow = 1110. Encoding:, Branch if Overflow =",
    "PIC18F6390/6490/8390/8490\n1110. Encoding:, Branch if Overflow = 0100. Encoding:, Branch if Overflow = nnnn. Encoding:, Branch if Overflow = nnnn. Encoding:, Branch if Overflow = nnnn. Description:, Branch if Overflow = If the Overflow bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be. Description:, Branch if Overflow = If the Overflow bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be. Description:, Branch if Overflow = If the Overflow bit is GLYPH<145> 1",
    "PIC18F6390/6490/8390/8490\nGLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be. Description:, Branch if Overflow = If the Overflow bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be. Description:, Branch if Overflow = If the Overflow bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be. Description:, Branch if Overflow = If the Overflow bit",
    "PIC18F6390/6490/8390/8490\nis GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be. Words:, Branch if Overflow = two-cycle instruction. 1. Words:, Branch if Overflow = two-cycle instruction. 1. Words:, Branch if Overflow = two-cycle instruction. 1. Words:, Branch if Overflow = two-cycle instruction. 1. Words:, Branch if Overflow = two-cycle instruction. 1. Words:, Branch if Overflow = two-cycle instruction. 1. Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Q Cycle",
    "PIC18F6390/6490/8390/8490\nActivity: If, Branch if Overflow = . Q Cycle Activity: If, Branch if Overflow = . Q Cycle Activity: If, Branch if Overflow = . Q Cycle Activity: If, Branch if Overflow = . Q Cycle Activity: If, Branch if Overflow = . Q Cycle Activity: If, Branch if Overflow = . Jump:, Branch if Overflow = . Jump:, Branch if Overflow = . Jump:, Branch if Overflow = . Jump:, Branch if Overflow = . Jump:, Branch if Overflow = . Jump:, Branch if Overflow = . Q1, Branch if Overflow = Q2. Q1, Branch if Overflow = . Q1, Branch if Overflow = Q3. Q1, Branch if Overflow = . Q1, Branch if Overflow = . Q1, Branch if Overflow = Q4. operation Jump:, Branch if Overflow = Read literal GLYPH<145>nGLYPH<146> Process Data Write to PC No operation No operation No operation. operation Jump:, Branch if Overflow = Read literal",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>nGLYPH<146> Process Data Write to PC No operation No operation No operation. operation Jump:, Branch if Overflow = Read literal GLYPH<145>nGLYPH<146> Process Data Write to PC No operation No operation No operation. operation Jump:, Branch if Overflow = Read literal GLYPH<145>nGLYPH<146> Process Data Write to PC No operation No operation No operation. operation Jump:, Branch if Overflow = Read literal GLYPH<145>nGLYPH<146> Process Data Write to PC No operation No operation No operation. operation Jump:, Branch if Overflow = Read literal GLYPH<145>nGLYPH<146> Process Data Write to PC No operation No operation No operation. Q1, Branch if Overflow = . Q1, Branch if Overflow = . Q1, Branch if Overflow = . Q1, Branch if Overflow = . Q1, Branch if Overflow = . Q1, Branch if Overflow = . Decode, Branch if Overflow = Q2 Q3 Q4 Read literal",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>nGLYPH<146> Process Data No operation. Decode, Branch if Overflow = Q2 Q3 Q4 Read literal GLYPH<145>nGLYPH<146> Process Data No operation. Decode, Branch if Overflow = Q2 Q3 Q4 Read literal GLYPH<145>nGLYPH<146> Process Data No operation. Decode, Branch if Overflow = Q2 Q3 Q4 Read literal GLYPH<145>nGLYPH<146> Process Data No operation. Decode, Branch if Overflow = Q2 Q3 Q4 Read literal GLYPH<145>nGLYPH<146> Process Data No operation. Decode, Branch if Overflow = Q2 Q3 Q4 Read literal GLYPH<145>nGLYPH<146> Process Data No operation. Example:, Branch if Overflow = HERE. Example:, Branch if Overflow = BOV address. Example:, Branch if Overflow = (HERE). Example:, Branch if Overflow = Jump. Example:, Branch if Overflow = . Example:, Branch if",
    "PIC18F6390/6490/8390/8490\nOverflow = . Before Instruction PC After Instruction If Overflow, Branch if Overflow = = = =. Before Instruction PC After Instruction If Overflow, Branch if Overflow = 1; address. Before Instruction PC After Instruction If Overflow, Branch if Overflow = . Before Instruction PC After Instruction If Overflow, Branch if Overflow = (Jump). Before Instruction PC After Instruction If Overflow, Branch if Overflow = . Before Instruction PC After Instruction If Overflow, Branch if Overflow = . PC If Overflow, Branch if Overflow = =. PC If Overflow, Branch if Overflow = 0;. PC If Overflow, Branch if Overflow = . PC If Overflow, Branch if Overflow = (HERE. PC If Overflow, Branch if Overflow = + 2). PC If Overflow, Branch if Overflow = . PC, Branch if Overflow = =. PC, Branch if Overflow = . PC, Branch if Overflow = address. PC, Branch if Overflow = . PC, Branch if Overflow = . PC, Branch if Overflow = ",
    "PIC18F6390/6490/8390/8490\nBZ Branch if Zero, 1 = BZ Branch if Zero. BZ Branch if Zero, 2 = BZ Branch if Zero. BZ Branch if Zero, 3 = BZ Branch if Zero. BZ Branch if Zero, 4 = BZ Branch if Zero. BZ Branch if Zero, 5 = BZ Branch if Zero. Syntax:, 1 = Syntax:. Syntax:, 2 = BZ n. Syntax:, 3 = BZ n. Syntax:, 4 = BZ n. Syntax:, 5 = BZ n. Operands:, 1 = Operands:. Operands:, 2 = -128 \u2264 n \u2264 127. Operands:, 3 = -128 \u2264 n \u2264 127. Operands:, 4 = -128 \u2264 n \u2264 127. Operands:, 5 = -128 \u2264 n \u2264 127. Operation:, 1 = Operation:. Operation:, 2 = if Zero bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, 3 = if Zero bit is GLYPH<145> 1 GLYPH<146>,",
    "PIC18F6390/6490/8390/8490\n(PC) + 2 + 2n \u2192 PC. Operation:, 4 = if Zero bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Operation:, 5 = if Zero bit is GLYPH<145> 1 GLYPH<146>, (PC) + 2 + 2n \u2192 PC. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 1110. Encoding:, 3 = 0000. Encoding:, 4 = nnnn. Encoding:, 5 = nnnn. Description:, 1 = Description:. Description:, 2 = If the Zero bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the",
    "PIC18F6390/6490/8390/8490\nnext instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 3 = If the Zero bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 4 = If the Zero bit is GLYPH<145> 1 GLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 5 = If the Zero bit is GLYPH<145> 1",
    "PIC18F6390/6490/8390/8490\nGLYPH<146>, then the program will branch. The 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1(2). Cycles:, 3 = 1(2). Cycles:, 4 = 1(2). Cycles:, 5 = 1(2). Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . Q Cycle Activity:, 5 = . If Jump:, 1 = If Jump:. If Jump:, 2 = If Jump:. If Jump:, 3 = . If",
    "PIC18F6390/6490/8390/8490\nJump:, 4 = . If Jump:, 5 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 5 = Q4. , 1 = Decode. , 2 = Read literal GLYPH<145>nGLYPH<146>. , 3 = Process Data. , 4 = Write. , 5 = to PC. , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = . , 5 = No operation. If No Jump:, 1 = If No Jump:. If No Jump:, 2 = If No Jump:. If No Jump:, 3 = . If No Jump:, 4 = . If No Jump:, 5 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = Q4. , 5 = . , 1 = Decode. , 2 = Read literal GLYPH<145>nGLYPH<146>. , 3 = Process Data. , 4 = . , 5 = No operation. , 1 = . , 2 = HERE. , 3 = BZ.",
    "PIC18F6390/6490/8390/8490\n, 4 = Jump. , 5 = Example:. , 1 = PC. , 2 = . , 3 = address. , 4 = (HERE). , 5 = Before Instruction. , 1 = . , 2 = =. , 3 = . , 4 = . , 5 = After Instruction. , 1 = . , 2 = =. , 3 = . , 4 = . , 5 = . , 1 = . , 2 = =. , 3 = . , 4 = . , 5 = . , 1 = . , 2 = . , 3 = address. , 4 = . , 5 = . , 1 = . , 2 = . , 3 = . , 4 = . , 5 = 2). , 1 = If Zero. , 2 = . , 3 = . , 4 = . , 5 = . , 1 = PC. , 2 = . , 3 = . , 4 = (HERE. , 5 = . , 1 = . , 2 = . , 3 = . , 4 = +. , 5 = +. , 1 = PC. , 2 = 0;. , 3 = . , 4 = . , 5 = . , 1 = . ,",
    "PIC18F6390/6490/8390/8490\n2 = =. , 3 = . , 4 = . , 5 = . , 1 = If Zero. , 2 = . , 3 = . , 4 = . , 5 = . , 1 = . , 2 = =. , 3 = . , 4 = . , 5 = . , 1 = . , 2 = . , 3 = . , 4 = (Jump). , 5 = . , 1 = . , 2 = . , 3 = . , 4 = . , 5 = 1; address",
    "Subroutine Call\nSyntax:\nCALL   k {,s}\nOperands:\n0 \u2264 k \u2264 1048575\ns \u2208 [0,1]\nOperation:\n(PC) + 4 \u2192 TOS,\nk\n\u2192\nPC<20:1>;\nif s = 1 ,\n(W) \u2192 WS,\n(STATUS)\n\u2192\nSTATUSS,\n(BSR)\n\u2192\nBSRS\nStatus Affected:\nNone\nEncoding:\n1st word (k<7:0>)\n2nd word(k<19:8>)\n1110\n1111\n110s\nk 19 kkk\nk 7\nkkk\nkkkk\nkkkk 0\nkkkk 8\nDescription:",
    "Subroutine Call\nSubroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If GLYPH<145>sGLYPH<146> = 1 , the W, STATUS and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If GLYPH<145>sGLYPH<146> = 0 , no update occurs (default). Then, the 20-bit value GLYPH<145>kGLYPH<146> is loaded into PC<20:1>. CALL is a two-cycle instruction.\nWords:\n2\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal\nGLYPH<145>kGLYPH<146><7:0>,\nPush PC to\nstack\nRead literal\nGLYPH<145>kGLYPH<146><19:8>,\nWrite to PC\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation",
    "Example:\nHERE\nCALL   THERE,1\nBefore Instruction, 1 = Before Instruction. Before Instruction, 2 = Before Instruction. Before Instruction, 3 = Before Instruction. PC, 1 = =. PC, 2 = address. PC, 3 = (HERE). After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. After Instruction, 3 = After Instruction. PC, 1 = =. PC, 2 = address. PC, 3 = (THERE). TOS, 1 = =. TOS, 2 = address. TOS, 3 = (HERE + 4). WS, 1 = =. WS, 2 = W. WS, 3 = . BSRS, 1 = =. BSRS, 2 = BSR. BSRS, 3 = . STATUSS=, 1 = . STATUSS=, 2 = STATUS. STATUSS=, 3 = ",
    "PIC18F6390/6490/8390/8490\nSyntax:, Clear f = CLRF f {,a}. Syntax:, Clear f = CLRF f {,a}. Syntax:, Clear f = CLRF f {,a}. Syntax:, Clear f = CLRF f {,a}. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Clear f = 000h \u2192 f, 1 \u2192 Z. Operation:, Clear f = 000h \u2192 f, 1 \u2192 Z. Operation:, Clear f = 000h \u2192 f, 1 \u2192 Z. Operation:, Clear f = 000h \u2192 f, 1 \u2192 Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Encoding:, Clear f = 0110.",
    "PIC18F6390/6490/8390/8490\nEncoding:, Clear f = 101a. Encoding:, Clear f = ffff. Encoding:, Clear f = ffff. Description:, Clear f = Clears the contents of the specified register. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected.. Description:, Clear f = Clears the contents of the specified register. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected.. Description:, Clear f = Clears the contents of the specified register. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected.. Description:, Clear f = Clears the contents of the specified register. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected.. , Clear f = If GLYPH<145>aGLYPH<146> is",
    "PIC18F6390/6490/8390/8490\nGLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed. , Clear f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed. , Clear f = If",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed. , Clear f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed.",
    "PIC18F6390/6490/8390/8490\nWords:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q1, Clear f = Q2. Q1, Clear f = . Q1, Clear f = Q3. Q1, Clear f = Q4. Decode, Clear f = Read register. Decode, Clear f = GLYPH<145>f GLYPH<146>. Decode, Clear f = Process Data. Decode, Clear f = Write register GLYPH<145>f GLYPH<146>. Example:, Clear f = CLRF. Example:, Clear f = . Example:, Clear f = . Example:, Clear f = . , Clear f = . , Clear f = . , Clear f =",
    "PIC18F6390/6490/8390/8490\nFLAG_REG,1. , Clear f = . Before Instruction FLAG_REG, Clear f = =. Before Instruction FLAG_REG, Clear f = 5Ah. Before Instruction FLAG_REG, Clear f = . Before Instruction FLAG_REG, Clear f = ",
    "PIC18F6390/6490/8390/8490\nSyntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT postscaler, 1 \u2192 TO, 1 \u2192 PD. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT postscaler, 1 \u2192 TO, 1 \u2192 PD. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT postscaler, 1 \u2192 TO, 1 \u2192 PD. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT postscaler, 1 \u2192 TO, 1 \u2192 PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer",
    "PIC18F6390/6490/8390/8490\n= TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0100. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status",
    "PIC18F6390/6490/8390/8490\nbits, TO and PD, are set.. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = . Q1, Clear Watchdog Timer = Q4. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = . Decode, Clear Watchdog Timer = No operation\nExample:\nCLRWDT\nBefore Instruction",
    "PIC18F6390/6490/8390/8490\nWDT Counter\n=\n?\nAfter Instruction\nWDT Counter\n=\n00h\nWDT Postscaler\n=\n0\nTO\n=\n1\nPD\n=\n1",
    "Complement f\nSyntax:\nCOMF     f {,d {,a}}\nOperands:\n0 \u2264 f \u2264 255\nd\n\u2208\n[0,1]\na\n\u2208\n[0,1]\nOperation:\n(f)\n\u2192\ndest\nStatus Affected:\nN, Z\nEncoding:\n0001\n11da\nffff\nffff\nDescription:\nThe contents of register GLYPH<145>fGLYPH<146> are complemented. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is stored back in register GLYPH<145>fGLYPH<146> (default).\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.",
    "Complement f\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>  and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nCOMF\nREG, 0, 0\nBefore Instruction\nREG\n=\n13h\nAfter Instruction\nREG\n=\n13h\nW\n=\nECh",
    "Compare f with W, Skip if f = W\nSyntax:\nCPFSEQ    f {,a}\nOperands:\n0 \u2264 f \u2264 255\na \u2208 [0,1]\nOperation:\n(f) GLYPH<150> (W),\nskip if (f) = (W)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n001a\nffff\nffff\nDescription:\nCompares the contents of data memory location GLYPH<145>fGLYPH<146> to the contents of W by performing an unsigned subtraction.\nIf GLYPH<145>fGLYPH<146> = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the BSR is used to select the GPR bank.",
    "Compare f with W, Skip if f = W\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister GLYPH<145>fGLYPH<146>\nProcess\nData\nNo\noperation\nIf skip:\nQ1\nQ2\nQ3\nQ4\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nExample:\nHERE     CPFSEQ REG, 0\nNEQUAL   :\nEQUAL    :\nBefore Instruction\nPC Address W\n=\nHERE\n=\n?\nREG\n=\n?\nAfter Instruction\nIf REG\n=\nW;\nPC\n=\nAddress (EQUAL)\nIf REG\n\u2260\nW;\nPC\n=\nAddress (NEQUAL)",
    "Compare f with W, Skip if f > W\nSyntax:\nCPFSGT    f {,a}\nOperands:\n0 \u2264 f \u2264 255\na \u2208 [0,1]\nOperation:\n(f) - ( W),\nskip if (f) > (W)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n010a\nffff\nffff\nDescription:\nCompares the contents of data memory location GLYPH<145>fGLYPH<146> to the contents of the W by performing an unsigned subtraction.\nIf the contents of GLYPH<145>fGLYPH<146> are greater than the contents of WREG  then the fetched , instruction is discarded and a NOP is executed instead, making this a two-cycle instruction.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.",
    "Compare f with W, Skip if f > W\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Compare f with W, Skip if f > W\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = No operation. skip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No",
    "Compare f with W, Skip if f > W\noperation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE      CPFSGT REG, 0\nNGREATER  :\nGREATER   :\nBefore Instruction\nPC\n= Address (HERE)\nW\n=\n?\nAfter Instruction\nIf REG\n>\nW;\nPC\n= Address (GREATER)\nIf REG\n\u2264 W;\nPC\n=\nAddress\n(NGREATER)",
    "Compare f with W, Skip if f < W\nSyntax:\nCPFSLT    f {,a}\nOperands:\n0 \u2264 f \u2264 255\na \u2208 [0,1]\nOperation:\n(f) GLYPH<150> ( W),\nskip if (f) < (W)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n000a\nffff\nffff\nDescription:\nCompares the contents of data memory location GLYPH<145>fGLYPH<146> to the contents of W by performing an unsigned subtraction.\nIf the contents of GLYPH<145>fGLYPH<146> are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = No operation\nIf skip:\nNo operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nNo operation, No = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE    CPFSLT REG, 1\nNLESS   :\nLESS    :\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nW\n=\n?\nAfter Instruction\nIf REG\n<\nW;\nPC\n= Address (LESS) \u2265\nIf REG\nW;\nPC\n= Address (NLESS)\nQ4",
    "PIC18F6390/6490/8390/8490\nSyntax:, Decimal Adjust WRegister = DAW. Syntax:, Decimal Adjust WRegister = DAW. Syntax:, Decimal Adjust WRegister = DAW. Syntax:, Decimal Adjust WRegister = DAW. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1 ] then, (W<3:0>) + 6 \u2192 W<3:0>; else, ( W<3:0>) \u2192 W<3:0>; If [W<7:4> >9] or [C = 1 ] then, ( W<7:4>) + 6 \u2192 W<7:4>, C = 1 ; else, (W<7:4>) \u2192 W<7:4>. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or",
    "PIC18F6390/6490/8390/8490\n[DC = 1 ] then, (W<3:0>) + 6 \u2192 W<3:0>; else, ( W<3:0>) \u2192 W<3:0>; If [W<7:4> >9] or [C = 1 ] then, ( W<7:4>) + 6 \u2192 W<7:4>, C = 1 ; else, (W<7:4>) \u2192 W<7:4>. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1 ] then, (W<3:0>) + 6 \u2192 W<3:0>; else, ( W<3:0>) \u2192 W<3:0>; If [W<7:4> >9] or [C = 1 ] then, ( W<7:4>) + 6 \u2192 W<7:4>, C = 1 ; else, (W<7:4>) \u2192 W<7:4>. Operation:, Decimal Adjust WRegister = If",
    "PIC18F6390/6490/8390/8490\n[W<3:0> >9] or [DC = 1 ] then, (W<3:0>) + 6 \u2192 W<3:0>; else, ( W<3:0>) \u2192 W<3:0>; If [W<7:4> >9] or [C = 1 ] then, ( W<7:4>) + 6 \u2192 W<7:4>, C = 1 ; else, (W<7:4>) \u2192 W<7:4>. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0111. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addition of two variables (each in",
    "PIC18F6390/6490/8390/8490\npacked BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister",
    "PIC18F6390/6490/8390/8490\n= 1. Q Cycle Activity: Q1, Decimal Adjust WRegister = Q2. Q Cycle Activity: Q1, Decimal Adjust WRegister = Q3. Q Cycle Activity: Q1, Decimal Adjust WRegister = Q3. Q Cycle Activity: Q1, Decimal Adjust WRegister = Q4. Decode, Decimal Adjust WRegister = Read register W. Decode, Decimal Adjust WRegister = Process. Decode, Decimal Adjust WRegister = Process. Decode, Decimal Adjust WRegister = Write W\nExample 1:\nDAW\nBefore Instruction\nW\n=\nA5h\nC\n=\n0\nDC\n=\n0\nAfter Instruction\nW\n=\n05h\nC\n=\n1\nDC\n=\n0\nExample 2:\nBefore Instruction\nW\n=\nCEh\nC\n=\n0\nDC\n=\n0\nAfter Instruction\nW\n=\n34h\nC\n=\n1\nDC\n=\n0",
    "PIC18F6390/6490/8390/8490\nSyntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208",
    "PIC18F6390/6490/8390/8490\n[0,1]. Operation:, Decrement f = (f) GLYPH<150> 1 \u2192 dest. Operation:, Decrement f = (f) GLYPH<150> 1 \u2192 dest. Operation:, Decrement f = (f) GLYPH<150> 1 \u2192 dest. Operation:, Decrement f = (f) GLYPH<150> 1 \u2192 dest. Operation:, Decrement f = (f) GLYPH<150> 1 \u2192 dest. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Encoding:, Decrement f = 0000. Encoding:, Decrement f = 01da. Encoding:,",
    "PIC18F6390/6490/8390/8490\nDecrement f = ffff. Encoding:, Decrement f = ffff. Encoding:, Decrement f = . Description:, Decrement f = Decrement register GLYPH<145> fGLYPH<146>. If GLYPH<145> dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is stored in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored back in register GLYPH<145>fGLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and",
    "PIC18F6390/6490/8390/8490\nthe extended instruction. Description:, Decrement f = Decrement register GLYPH<145> fGLYPH<146>. If GLYPH<145> dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is stored in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored back in register GLYPH<145>fGLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction. Description:, Decrement f = Decrement register GLYPH<145>",
    "PIC18F6390/6490/8390/8490\nfGLYPH<146>. If GLYPH<145> dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is stored in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored back in register GLYPH<145>fGLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction. Description:, Decrement f = Decrement register GLYPH<145> fGLYPH<146>. If GLYPH<145> dGLYPH<146> is",
    "PIC18F6390/6490/8390/8490\nGLYPH<145> 0 GLYPH<146>, the result is stored in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored back in register GLYPH<145>fGLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction. Description:, Decrement f = Decrement register GLYPH<145> fGLYPH<146>. If GLYPH<145> dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is stored in W. If",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored back in register GLYPH<145>fGLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction. Words:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:,",
    "PIC18F6390/6490/8390/8490\nDecrement f = 1. Cycles:, Decrement f = 1. Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q1, Decrement f = Q2. Q1, Decrement f = Q2. Q1, Decrement f = Q3. Q1, Decrement f = Q4. Q1, Decrement f = . Decode, Decrement f = Read register GLYPH<145>f GLYPH<146>. Decode, Decrement f = Read register GLYPH<145>f GLYPH<146>. Decode, Decrement f = Process Data. Decode, Decrement f = Write to destination. Decode, Decrement f = . Example:, Decrement f = DECF. Example:, Decrement f = CNT,. Example:, Decrement f = 1,.",
    "PIC18F6390/6490/8390/8490\nExample:, Decrement f = 0. Example:, Decrement f = . Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. CNT Z, Decrement f = 01h 0. CNT Z, Decrement f = . CNT Z, Decrement f = . CNT Z, Decrement f = . CNT Z, Decrement f = . After, Decrement f = 1. After, Decrement f = . After, Decrement f = . After, Decrement f = . After, Decrement f = . Instruction, Decrement f = Instruction. Instruction, Decrement f = Instruction. Instruction, Decrement f = Instruction. Instruction, Decrement f = Instruction. Instruction, Decrement f = Instruction. CNT Z, Decrement f = 00h. CNT Z, Decrement f = . CNT Z,",
    "PIC18F6390/6490/8390/8490\nDecrement f = . CNT Z, Decrement f = . CNT Z, Decrement f = ",
    "PIC18F6390/6490/8390/8490\nSyntax:, DECFSZ = Syntax:. Syntax:, Decrement f, Skip if 0 = DECFSZ f {,d {,a}}. Syntax:, Decrement f, Skip if 0 = DECFSZ f {,d {,a}}. Syntax:, Decrement f, Skip if 0 = DECFSZ f {,d {,a}}. Syntax:, Decrement f, Skip if 0 = DECFSZ f {,d {,a}}. Operands:, DECFSZ = Operands:. Operands:, Decrement f, Skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, Skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, Skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, Skip if 0 = 0 \u2264 f \u2264 255 d \u2208",
    "PIC18F6390/6490/8390/8490\n[0,1] a \u2208 [0,1]. Operation:, DECFSZ = Operation:. Operation:, Decrement f, Skip if 0 = (f) GLYPH<150> 1 \u2192 dest, skip if result = 0. Operation:, Decrement f, Skip if 0 = (f) GLYPH<150> 1 \u2192 dest, skip if result = 0. Operation:, Decrement f, Skip if 0 = (f) GLYPH<150> 1 \u2192 dest, skip if result = 0. Operation:, Decrement f, Skip if 0 = (f) GLYPH<150> 1 \u2192 dest, skip if result = 0. Status Affected:, DECFSZ = Status Affected:. Status Affected:, Decrement f, Skip if 0 = None. Status Affected:, Decrement f, Skip if 0 = None. Status Affected:, Decrement f, Skip if 0 = None. Status Affected:, Decrement f, Skip if 0 = None. Encoding:, DECFSZ = Encoding:. Encoding:, Decrement f,",
    "PIC18F6390/6490/8390/8490\nSkip if 0 = 0010 11da. Encoding:, Decrement f, Skip if 0 = 0010 11da. Encoding:, Decrement f, Skip if 0 = ffff. Encoding:, Decrement f, Skip if 0 = ffff. Description:, DECFSZ = Description:. Description:, Decrement f, Skip if 0 = The contents of register GLYPH<145>f GLYPH<146> are decremented. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145> fGLYPH<146> (default). If the result is GLYPH<145> 0 GLYPH<146>, the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146> , the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. Description:, Decrement f, Skip if 0 = The contents of register GLYPH<145>f GLYPH<146> are decremented. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the result is placed in W. If",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145> fGLYPH<146> (default). If the result is GLYPH<145> 0 GLYPH<146>, the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146> , the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and",
    "PIC18F6390/6490/8390/8490\nBit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. Description:, Decrement f, Skip if 0 = The contents of register GLYPH<145>f GLYPH<146> are decremented. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145> fGLYPH<146> (default). If the result is GLYPH<145> 0 GLYPH<146>, the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1",
    "PIC18F6390/6490/8390/8490\nGLYPH<146> , the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. Description:, Decrement f, Skip if 0 = The contents of register GLYPH<145>f GLYPH<146> are decremented. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145> fGLYPH<146> (default). If the result is GLYPH<145> 0",
    "PIC18F6390/6490/8390/8490\nGLYPH<146>, the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146> , the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. Words:, DECFSZ = Words:. Words:, Decrement f, Skip if 0 = 1. Words:, Decrement f, Skip if 0 = 1. Words:, Decrement",
    "PIC18F6390/6490/8390/8490\nf, Skip if 0 = 1. Words:, Decrement f, Skip if 0 = 1. Cycles:, DECFSZ = Cycles:. Cycles:, Decrement f, Skip if 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Decrement f, Skip if 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Decrement f, Skip if 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Decrement f, Skip if 0 = 1(2) Note: 3 cycles if skip and followed. Cycle Activity:, DECFSZ = Cycle Activity:. Cycle Activity:, Decrement f, Skip if 0 = Cycle Activity:. Cycle Activity:, Decrement f, Skip if 0 = Cycle Activity:. Cycle Activity:, Decrement f, Skip if 0 = Cycle Activity:. Cycle Activity:, Decrement f, Skip if 0 = Cycle Activity:. Q1, DECFSZ = . Q1, Decrement f, Skip if 0 = Q2. Q1, Decrement",
    "PIC18F6390/6490/8390/8490\nf, Skip if 0 = Q2. Q1, Decrement f, Skip if 0 = Q3. Q1, Decrement f, Skip if 0 = Q4. Decode, DECFSZ = . Decode, Decrement f, Skip if 0 = Read register GLYPH<145>f GLYPH<146>. Decode, Decrement f, Skip if 0 = Read register GLYPH<145>f GLYPH<146>. Decode, Decrement f, Skip if 0 = Process Data. Decode, Decrement f, Skip if 0 = Write to destination. If skip:, DECFSZ = If skip:. If skip:, Decrement f, Skip if 0 = If skip:. If skip:, Decrement f, Skip if 0 = If skip:. If skip:, Decrement f, Skip if 0 = If skip:. If skip:, Decrement f, Skip if 0 = If skip:. Q1, DECFSZ = . Q1, Decrement f, Skip if 0 = Q2. Q1,",
    "PIC18F6390/6490/8390/8490\nDecrement f, Skip if 0 = Q2. Q1, Decrement f, Skip if 0 = Q3. Q1, Decrement f, Skip if 0 = Q4. No operation, DECFSZ = . No operation, Decrement f, Skip if 0 = No operation. No operation, Decrement f, Skip if 0 = No operation. No operation, Decrement f, Skip if 0 = No operation. No operation, Decrement f, Skip if 0 = No operation. If skip and followed by 2-word instruction:, DECFSZ = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, Skip if 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:,",
    "PIC18F6390/6490/8390/8490\nDecrement f, Skip if 0 = If skip and followed by 2-word instruction:. Q1, DECFSZ = Q2. Q1, Decrement f, Skip if 0 = . Q1, Decrement f, Skip if 0 = . Q1, Decrement f, Skip if 0 = Q3. Q1, Decrement f, Skip if 0 = Q4. No operation, DECFSZ = . No operation, Decrement f, Skip if 0 = No operation. No operation, Decrement f, Skip if 0 = No operation. No operation, Decrement f, Skip if 0 = No operation. No operation, Decrement f, Skip if 0 = No operation. No operation, DECFSZ = No. No operation, Decrement f, Skip if 0 = operation. No operation, Decrement f, Skip if 0 = operation. No operation, Decrement f, Skip if 0 = No operation. No operation, Decrement f, Skip if 0 = No operation. Example:, DECFSZ = Example:. Example:, Decrement f, Skip if",
    "PIC18F6390/6490/8390/8490\n0 = HERE. Example:, Decrement f, Skip if 0 = HERE. Example:, Decrement f, Skip if 0 = DECFSZ GOTO. Example:, Decrement f, Skip if 0 = CNT, 1, 1 LOOP. CONTINUE, DECFSZ = CONTINUE. CONTINUE, Decrement f, Skip if 0 = CONTINUE. CONTINUE, Decrement f, Skip if 0 = CONTINUE. CONTINUE, Decrement f, Skip if 0 = CONTINUE. CONTINUE, Decrement f, Skip if 0 = CONTINUE. Before Instruction, DECFSZ = Before Instruction. Before Instruction, Decrement f, Skip if 0 = Before Instruction. Before Instruction, Decrement f, Skip if 0 = . Before Instruction, Decrement f, Skip if 0 = . Before Instruction, Decrement f, Skip if 0 = . PC = After Instruction, DECFSZ = PC = After Instruction. PC = After Instruction, Decrement f, Skip if 0 = PC = After Instruction. PC = After Instruction, Decrement f, Skip if 0 = Address. PC = After Instruction, Decrement f, Skip if",
    "PIC18F6390/6490/8390/8490\n0 = (HERE). PC = After Instruction, Decrement f, Skip if 0 = . CNT = If CNT =, DECFSZ = CNT = If CNT =. CNT = If CNT =, Decrement f, Skip if 0 = CNT = If CNT =. CNT = If CNT =, Decrement f, Skip if 0 = CNT GLYPH<150> 1 0;. CNT = If CNT =, Decrement f, Skip if 0 = . CNT = If CNT =, Decrement f, Skip if 0 = . If CNT, DECFSZ = PC PC. If CNT, Decrement f, Skip if 0 = = \u2260 =. If CNT, Decrement f, Skip if 0 = Address 0; Address. If CNT, Decrement f, Skip if 0 = (CONTINUE) (HERE + 2). If CNT, Decrement f, Skip if 0 = ",
    "PIC18F6390/6490/8390/8490\nSyntax:, Decrement f, Skip if not 0 = DCFSNZ. Syntax:, Decrement f, Skip if not 0 = f {,d {,a}}. Syntax:, Decrement f, Skip if not 0 = . Syntax:, Decrement f, Skip if not 0 = . Operands:, Decrement f, Skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, Skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, Skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, Skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Decrement f, Skip if not 0 = (f) GLYPH<150> 1 \u2192 dest, skip if result \u2260 0. Operation:,",
    "PIC18F6390/6490/8390/8490\nDecrement f, Skip if not 0 = (f) GLYPH<150> 1 \u2192 dest, skip if result \u2260 0. Operation:, Decrement f, Skip if not 0 = (f) GLYPH<150> 1 \u2192 dest, skip if result \u2260 0. Operation:, Decrement f, Skip if not 0 = (f) GLYPH<150> 1 \u2192 dest, skip if result \u2260 0. Status Affected:, Decrement f, Skip if not 0 = None. Status Affected:, Decrement f, Skip if not 0 = None. Status Affected:, Decrement f, Skip if not 0 = None. Status Affected:, Decrement f, Skip if not 0 = None. Encoding:, Decrement f, Skip if not 0 = 0100. Encoding:, Decrement f, Skip if not 0 = 11da. Encoding:, Decrement f, Skip if not 0 = ffff. Encoding:, Decrement f, Skip if not 0 = ffff. Description:, Decrement f, Skip if not 0 = The contents of register",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>f GLYPH<146> are decremented. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>fGLYPH<146> (default). If the result is not GLYPH<145> 0 GLYPH<146>, the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction.. Description:, Decrement f, Skip if not 0 = The contents of register GLYPH<145>f GLYPH<146> are decremented. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1",
    "PIC18F6390/6490/8390/8490\nGLYPH<146>, the result is placed back in register GLYPH<145>fGLYPH<146> (default). If the result is not GLYPH<145> 0 GLYPH<146>, the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction.. Description:, Decrement f, Skip if not 0 = The contents of register GLYPH<145>f GLYPH<146> are decremented. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>fGLYPH<146> (default). If the result is not GLYPH<145> 0 GLYPH<146>, the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle",
    "PIC18F6390/6490/8390/8490\ninstruction.. Description:, Decrement f, Skip if not 0 = The contents of register GLYPH<145>f GLYPH<146> are decremented. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>fGLYPH<146> (default). If the result is not GLYPH<145> 0 GLYPH<146>, the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction.. , Decrement f, Skip if not 0 = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1",
    "PIC18F6390/6490/8390/8490\nGLYPH<146> , the BSR is used to select the GPR bank.. , Decrement f, Skip if not 0 = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146> , the BSR is used to select the GPR bank.. , Decrement f, Skip if not 0 = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146> , the BSR is used to select the GPR bank.. , Decrement f, Skip if not 0 = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146> , the BSR is used to select the GPR bank.. , Decrement f, Skip if not 0 = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. , Decrement f, Skip if not 0 = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. ,",
    "PIC18F6390/6490/8390/8490\nDecrement f, Skip if not 0 = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. , Decrement f, Skip if not 0 = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. Words:, Decrement f, Skip if not 0 = 1. Words:, Decrement f, Skip if not 0 = 1. Words:, Decrement f, Skip if not 0",
    "PIC18F6390/6490/8390/8490\n= 1. Words:, Decrement f, Skip if not 0 = 1. Cycles:, Decrement f, Skip if not 0 = 1(2). Cycles:, Decrement f, Skip if not 0 = 1(2). Cycles:, Decrement f, Skip if not 0 = 1(2). Cycles:, Decrement f, Skip if not 0 = 1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. skip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No",
    "Q Cycle Activity:\noperation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE    DCFSNZ  TEMP, 1, 0\nZERO    :\nNZERO   :\nBefore Instruction\nTEMP\n=\n?\nAfter Instruction\nTEMP\n=\nTEMP GLYPH<150> 1,\nIf TEMP\n=\n0;\nPC\n=\nAddress\n(ZERO)\nIf TEMP\n\u2260\n0;\nPC\n=\nAddress (NZERO)",
    "PIC18F6390/6490/8390/8490\nSyntax:, Unconditional Branch = GOTO k. Syntax:, Unconditional Branch = GOTO k. Syntax:, Unconditional Branch = GOTO k. Syntax:, Unconditional Branch = GOTO k. Operands:, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operands:, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operands:, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operands:, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operation:, Unconditional Branch = k \u2192 PC<20:1>. Operation:, Unconditional Branch = k \u2192 PC<20:1>. Operation:, Unconditional Branch = k \u2192 PC<20:1>. Operation:, Unconditional Branch = k \u2192 PC<20:1>. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Encoding: 1st word (k<7:0>) 2nd",
    "PIC18F6390/6490/8390/8490\nword(k<19:8>), Unconditional Branch = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = 1111 k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = kkkk 0 kkkk 8. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value GLYPH<145>kGLYPH<146> is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value GLYPH<145>kGLYPH<146> is loaded into",
    "PIC18F6390/6490/8390/8490\nPC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value GLYPH<145>kGLYPH<146> is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value GLYPH<145>kGLYPH<146> is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:.",
    "PIC18F6390/6490/8390/8490\nQ Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q1, Unconditional Branch = Q2. Q1, Unconditional Branch = Q3. Q1, Unconditional Branch = Q4. Q1, Unconditional Branch = Q4. Decode, Unconditional Branch = Read literal GLYPH<145>kGLYPH<146><7:0>,. Decode, Unconditional Branch = No operation. Decode, Unconditional Branch = Read literal GLYPH<145>kGLYPH<146><19:8>, Write to PC. Decode, Unconditional Branch = Read literal GLYPH<145>kGLYPH<146><19:8>, Write to PC. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. Example:,",
    "PIC18F6390/6490/8390/8490\nUnconditional Branch = GOTO THERE. Example:, Unconditional Branch = GOTO THERE. Example:, Unconditional Branch = . Example:, Unconditional Branch = . After Instruction PC = Address, Unconditional Branch = . After Instruction PC = Address, Unconditional Branch = . After Instruction PC = Address, Unconditional Branch = . After Instruction PC = Address, Unconditional Branch = \nWords:\nCycles:",
    "PIC18F6390/6490/8390/8490\nSyntax:, Increment f = INCF. Syntax:, Increment f = f {,d {,a}}. Syntax:, Increment f = . Syntax:, Increment f = . Operands:, Increment f = 0 \u2264 f \u2264 255. Operands:, Increment f = 0 \u2264 f \u2264 255. Operands:, Increment f = . Operands:, Increment f = . , Increment f = d \u2208 [0,1]. , Increment f = d \u2208 [0,1]. , Increment f = . , Increment f = . , Increment f = a \u2208 [0,1]. , Increment f = a \u2208 [0,1]. , Increment f = . , Increment f = . Operation:, Increment f = (f) + 1 \u2192 dest. Operation:, Increment f = (f) + 1 \u2192 dest. Operation:, Increment f = . Operation:, Increment f = . Status Affected:, Increment f",
    "PIC18F6390/6490/8390/8490\n= C, DC, N, OV, Z. Status Affected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f = . Status Affected:, Increment f = . Encoding:, Increment f = 0010. Encoding:, Increment f = 10da. Encoding:, Increment f = ffff. Encoding:, Increment f = ffff\nDescription:\nThe contents of register GLYPH<145>fGLYPH<146> are incremented. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>fGLYPH<146> (default).",
    "PIC18F6390/6490/8390/8490\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nExample:\nINCF\nBefore Instruction\nCNT\n=\nFFh\nZ\n=\n0\nC\n=\n?\nDC\n=\n?\nAfter Instruction\nCNT\n=\n00h\nZ\n=\n1\nC\n=\n1",
    "PIC18F6390/6490/8390/8490\nDC\n=\n1\nCNT, 1, 0",
    "If skip:\nQ2\nQ3\nQ4\nRead register GLYPH<145>fGLYPH<146>\nQ2\nNo",
    "Increment f, Skip if 0\nSyntax:\nINCFSZ    f {,d {,a}}\nOperands:\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\nOperation:\n(f) + 1 \u2192 dest,\nskip if result = 0\nStatus Affected:\nNone\nEncoding:\n0011\n11da\nffff\nffff\nDescription:\nThe contents of register GLYPH<145>fGLYPH<146> are incremented. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>fGLYPH<146> (default).\nIf the result is GLYPH<145> 0 GLYPH<146>, the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction.",
    "Increment f, Skip if 0\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\nWords:\n1\nCycles:\n1(2)",
    "Increment f, Skip if not 0\nSyntax:\nINFSNZ    f {,d {,a}}\nOperands:\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\nOperation:\n(f) + 1 \u2192 dest,\nskip if result \u2260 0\nStatus Affected:\nNone\nEncoding:\n0100\n10da\nffff\nffff\nDescription:\nThe contents of register GLYPH<145>fGLYPH<146> are incremented. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>fGLYPH<146> (default).\nIf the result is not GLYPH<145> 0 GLYPH<146>, the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction.",
    "Increment f, Skip if not 0\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nDecode\nQ1\nNo\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE    INCFSZ   CNT, 1, 0\nNZERO   :\nZERO    :\nAfter Instruction, = = . After Instruction, Address = . After Instruction, (HERE) = . CNT, = = =. CNT, Address = CNT + 1. CNT, (HERE) = . If CNT, = = =. If CNT, Address = 0;. If CNT, (HERE) = . PC, = = =. PC, Address = Address. PC, (HERE) = (ZERO). If CNT, = = \u2260. If CNT, Address = 0;. If CNT, (HERE) = . PC, = = =. PC, Address = Address. PC, (HERE) = (NZERO)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. skip:, Q2 = . skip:, Q3 = . skip:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation,",
    "Q Cycle Activity:\nQ4 = No operation\nExample:\nHERE    INFSNZ  REG, 1, 0\nZERO\nNZERO\nBefore Instruction, 1 = Before Instruction. Before Instruction, 2 = Before Instruction. PC, 1 = =. PC, 2 = Address (HERE). After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. REG, 1 = =. REG, 2 = REG + 1. If REG, 1 = \u2260. If REG, 2 = 0;. PC, 1 = =. PC, 2 = Address (NZERO). If REG, 1 = =. If REG, 2 = 0;. PC, 1 = =. PC, 2 = Address (ZERO)\nWrite to destination\nQ4\nNo operation",
    "Inclusive OR Literal with W\nSyntax:\nIORLW   k\nOperands:\n0 \u2264 k \u2264 255\nOperation:\n(W) .OR. k \u2192 W\nStatus Affected:\nN, Z\nEncoding:\n0000\n1001\nkkkk\nkkkk\nDescription:\nThe contents of W are ORed with the eight-bit literal GLYPH<145>kGLYPH<146>. The result is placed in W.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral GLYPH<145>kGLYPH<146>\nProcess\nData\nWrite to W\nExample:\nIORLW\n35h\nBefore Instruction\nW\n=\n9Ah\nAfter Instruction\nW\n=\nBFh",
    "Inclusive OR Literal with W\nSyntax:, Inclusive OR Wwith f = IORWF. Syntax:, Inclusive OR Wwith f = f {,d {,a}}. Syntax:, Inclusive OR Wwith f = . Syntax:, Inclusive OR Wwith f = . Syntax:, Inclusive OR Wwith f = . Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \u2192 dest. Operation:, Inclusive OR Wwith f = (W) .OR.",
    "Inclusive OR Literal with W\n(f) \u2192 dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \u2192 dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \u2192 dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \u2192 dest. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Encoding:, Inclusive OR Wwith f = 0001. Encoding:, Inclusive OR Wwith f = 00da. Encoding:, Inclusive OR Wwith f = ffff. Encoding:, Inclusive OR Wwith f = ffff. Encoding:, Inclusive OR Wwith f = ffff. Description:, Inclusive OR Wwith f = Inclusive GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is",
    "Inclusive OR Literal with W\nGLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>f GLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Offset details.. Description:, Inclusive OR Wwith f = OR Wwith. Description:, Inclusive OR Wwith f = register. Description:, Inclusive OR Wwith f = Inclusive GLYPH<145> 0 GLYPH<146>, the result is placed in W. If",
    "Inclusive OR Literal with W\nGLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>f GLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Offset details.. Description:, Inclusive OR Wwith f = Inclusive GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is",
    "Inclusive OR Literal with W\nGLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>f GLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Offset details.. Words:, Inclusive OR Wwith f = . Words:, Inclusive OR Wwith f = . Words:, Inclusive OR Wwith f = . Words:, Inclusive OR Wwith f = . Words:, Inclusive OR Wwith f = . Cycles:, Inclusive OR Wwith f",
    "Inclusive OR Literal with W\n= . Cycles:, Inclusive OR Wwith f = . Cycles:, Inclusive OR Wwith f = . Cycles:, Inclusive OR Wwith f = . Cycles:, Inclusive OR Wwith f = . Q Cycle Activity:, Inclusive OR Wwith f = . Q Cycle Activity:, Inclusive OR Wwith f = . Q Cycle Activity:, Inclusive OR Wwith f = . Q Cycle Activity:, Inclusive OR Wwith f = . Q Cycle Activity:, Inclusive OR Wwith f = . Q1, Inclusive OR Wwith f = Q2 Q3 Q4. Q1, Inclusive OR Wwith f = Q2 Q3 Q4. Q1, Inclusive OR Wwith f = Q2 Q3 Q4. Q1, Inclusive OR Wwith f = Q2 Q3 Q4. Q1, Inclusive OR Wwith f = Q2 Q3 Q4. Decode, Inclusive OR Wwith f = Read register GLYPH<145>f. Decode, Inclusive OR Wwith f = Process Data. Decode, Inclusive OR Wwith f = . Decode, Inclusive OR Wwith f = Write to destination. Decode, Inclusive OR Wwith f = Write to destination.",
    "Inclusive OR Literal with W\nExample:, Inclusive OR Wwith f = . Example:, Inclusive OR Wwith f = RESULT,. Example:, Inclusive OR Wwith f = 1. Example:, Inclusive OR Wwith f = IORWF. Example:, Inclusive OR Wwith f = IORWF. Before Instruction, Inclusive OR Wwith f = 13h. Before Instruction, Inclusive OR Wwith f = . Before Instruction, Inclusive OR Wwith f = . Before Instruction, Inclusive OR Wwith f = = = 91h. Before Instruction, Inclusive OR Wwith f = = = 91h. After Instruction RESULT, Inclusive OR Wwith f = . After Instruction RESULT, Inclusive OR Wwith f = . After Instruction RESULT, Inclusive OR Wwith f = . After Instruction RESULT, Inclusive OR Wwith f = =. After Instruction RESULT, Inclusive OR Wwith f = =. , Inclusive OR Wwith f = 13h 93h. , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith",
    "Inclusive OR Literal with W\nf = =. , Inclusive OR Wwith f = =. W, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = 0,. , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = for. , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = ModeGLYPH<148>. , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . RESULT, Inclusive OR Wwith f = . RESULT, Inclusive OR Wwith f = . RESULT, Inclusive OR Wwith f = . RESULT, Inclusive OR Wwith f = . RESULT, Inclusive OR Wwith f = . Literal, Inclusive OR Wwith f = . Literal, Inclusive OR Wwith f = .",
    "Inclusive OR Literal with W\nLiteral, Inclusive OR Wwith f = . Literal, Inclusive OR Wwith f = . Literal, Inclusive OR Wwith f = 1. , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = . , Inclusive OR Wwith f = 1. , Inclusive OR Wwith f = ",
    "PIC18F6390/6490/8390/8490\nSyntax:, Load FSR = LFSR f, k. Syntax:, Load FSR = LFSR f, k. Syntax:, Load FSR = LFSR f, k. Syntax:, Load FSR = LFSR f, k. Operands:, Load FSR = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:, Load FSR = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:, Load FSR = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:, Load FSR = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operation:, Load FSR = k \u2192 FSRf. Operation:, Load FSR = k \u2192 FSRf. Operation:, Load FSR = k \u2192 FSRf. Operation:, Load FSR = k \u2192 FSRf. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Encoding:, Load FSR = 1110",
    "PIC18F6390/6490/8390/8490\n1111. Encoding:, Load FSR = 1110 0000. Encoding:, Load FSR = 00ff k 7 kkk. Encoding:, Load FSR = k 11 kkk kkkk. Description:, Load FSR = The 12-bit literal GLYPH<145>kGLYPH<146> is loaded into the file select register pointed to by GLYPH<145>f GLYPH<146> .. Description:, Load FSR = The 12-bit literal GLYPH<145>kGLYPH<146> is loaded into the file select register pointed to by GLYPH<145>f GLYPH<146> .. Description:, Load FSR = The 12-bit literal GLYPH<145>kGLYPH<146> is loaded into the file select register pointed to by GLYPH<145>f GLYPH<146> .. Description:, Load FSR = The 12-bit literal GLYPH<145>kGLYPH<146> is loaded into the file select register pointed to by GLYPH<145>f GLYPH<146> ..",
    "PIC18F6390/6490/8390/8490\nWords:, Load FSR = 2. Words:, Load FSR = 2. Words:, Load FSR = 2. Words:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Cycles:, Load FSR = 2. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q Cycle Activity:, Load FSR = Q Cycle Activity:. Q1, Load FSR = Q2. Q1, Load FSR = Q3. Q1, Load FSR = . Q1, Load FSR = Q4. Decode, Load FSR = Read literal GLYPH<145>kGLYPH<146> MSB. Decode, Load FSR = Process Data. Decode, Load FSR = Process Data. Decode, Load FSR = Write literal GLYPH<145>kGLYPH<146> MSB to FSRfH.",
    "PIC18F6390/6490/8390/8490\nDecode, Load FSR = Read literal GLYPH<145>kGLYPH<146> LSB. Decode, Load FSR = Process Data. Decode, Load FSR = Process Data. Decode, Load FSR = Write literal GLYPH<145>kGLYPH<146> to FSRfL\nExample:\nLFSR 2, 3ABh\nAfter Instruction\nFSR2H\n= 03h\nFSR2L\n=\nABh\nWords:\nCycles:",
    "PIC18F6390/6490/8390/8490\nSyntax:, Move f = MOVF. Syntax:, Move f = f {,d {,a}}. Syntax:, Move f = f {,d {,a}}. Syntax:, Move f = f {,d {,a}}. Operands:, Move f = 0 \u2264 f \u2264 255. Operands:, Move f = 0 \u2264 f \u2264 255. Operands:, Move f = 0 \u2264 f \u2264 255. Operands:, Move f = 0 \u2264 f \u2264 255. , Move f = d \u2208 [0,1]. , Move f = d \u2208 [0,1]. , Move f = d \u2208 [0,1]. , Move f = d \u2208 [0,1]. , Move f = a \u2208 [0,1]. , Move f = a \u2208 [0,1]. , Move f = a \u2208 [0,1]. , Move f = a \u2208 [0,1]. Operation:, Move f = f \u2192 dest. Operation:, Move f = f \u2192 dest. Operation:, Move f = f \u2192 dest.",
    "PIC18F6390/6490/8390/8490\nOperation:, Move f = f \u2192 dest. Status Affected:, Move f = N, Z. Status Affected:, Move f = N, Z. Status Affected:, Move f = N, Z. Status Affected:, Move f = N, Z. Encoding:, Move f = 0101. Encoding:, Move f = 00da. Encoding:, Move f = ffff. Encoding:, Move f = ffff\nDescription:\nThe contents of register GLYPH<145>fGLYPH<146> are moved to a destination dependent upon the status of GLYPH<145>dGLYPH<146>. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>fGLYPH<146> (default). Location GLYPH<145>fGLYPH<146> can be anywhere in the 256-byte bank.",
    "PIC18F6390/6490/8390/8490\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write W",
    "PIC18F6390/6490/8390/8490\nBefore Instruction, MOVF = . Before Instruction, REG, 0, = . REG, MOVF = =. REG, REG, 0, = 22h. W, MOVF = =. W, REG, 0, = FFh. After Instruction, MOVF = . After Instruction, REG, 0, = . REG, MOVF = =. REG, REG, 0, = 22h. W, MOVF = =. W, REG, 0, = 22h",
    "PIC18F6390/6490/8390/8490\nMOVFF, 1 = Move f to f. MOVFF, 2 = Move f to f. MOVFF, 3 = Move f to f. Syntax:, 1 = MOVFF f s ,f d. Syntax:, 2 = MOVFF f s ,f d. Syntax:, 3 = MOVFF f s ,f d. Operands:, 1 = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, 2 = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, 3 = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operation:, 1 = (f s ) \u2192 f d. Operation:, 2 = (f s ) \u2192 f d. Operation:, 3 = (f s ) \u2192 f d. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Encoding:, 1 = . Encoding:, 2 = . Encoding:, 3 = . 1st word (source) 2nd word (destin.), 1 = 1100",
    "PIC18F6390/6490/8390/8490\n1111. 1st word (source) 2nd word (destin.), 2 = ffff ffff ffff. 1st word (source) 2nd word (destin.), 3 = ffff s ffff d. Description:, 1 = The contents of source register GLYPH<145> f s GLYPH<146> are moved to destination register GLYPH<145> f d GLYPH<146> . Location of source GLYPH<145>f s GLYPH<146> can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination GLYPH<145>f d GLYPH<146> can also be anywhere from 000h to FFFh.. Description:, 2 = The contents of source register GLYPH<145> f s GLYPH<146> are moved to destination register GLYPH<145> f d GLYPH<146> . Location of source GLYPH<145>f s GLYPH<146> can be anywhere in the 4096-byte data space (000h to FFFh) and",
    "PIC18F6390/6490/8390/8490\nlocation of destination GLYPH<145>f d GLYPH<146> can also be anywhere from 000h to FFFh.. Description:, 3 = The contents of source register GLYPH<145> f s GLYPH<146> are moved to destination register GLYPH<145> f d GLYPH<146> . Location of source GLYPH<145>f s GLYPH<146> can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination GLYPH<145>f d GLYPH<146> can also be anywhere from 000h to FFFh.. , 1 = Either source or destination can be W (a useful special situation).. , 2 = Either source or destination can be W (a useful special situation).. , 3 = Either source or destination can be W (a useful special situation).. , 1 = MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the. , 2 =",
    "PIC18F6390/6490/8390/8490\nMOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the. , 3 = MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the. Words:, 1 = 2. Words:, 2 = 2. Words:, 3 = 2. Cycles:, 1 = 2 (3). Cycles:, 2 = 2 (3). Cycles:, 3 = 2 (3). Q Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register GLYPH<145>f GLYPH<146> (src). Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation.",
    "PIC18F6390/6490/8390/8490\nDecode, 3 = Write register GLYPH<145>f GLYPH<146> (dest)",
    "PIC18F6390/6490/8390/8490\nSyntax:, Move Literal to Low Nibble in BSR = MOVLW k. Syntax:, Move Literal to Low Nibble in BSR = MOVLW k. Syntax:, Move Literal to Low Nibble in BSR = MOVLW k. Syntax:, Move Literal to Low Nibble in BSR = MOVLW k. Operands:, Move Literal to Low Nibble in BSR = 0 \u2264 k \u2264 255. Operands:, Move Literal to Low Nibble in BSR = 0 \u2264 k \u2264 255. Operands:, Move Literal to Low Nibble in BSR = 0 \u2264 k \u2264 255. Operands:, Move Literal to Low Nibble in BSR = 0 \u2264 k \u2264 255. Operation:, Move Literal to Low Nibble in BSR = k \u2192 BSR. Operation:, Move Literal to Low Nibble in BSR = k \u2192 BSR. Operation:, Move Literal to Low Nibble in BSR = k \u2192 BSR. Operation:, Move Literal to Low Nibble in BSR = k \u2192 BSR. Status Affected:, Move Literal to Low Nibble in BSR",
    "PIC18F6390/6490/8390/8490\n= None. Status Affected:, Move Literal to Low Nibble in BSR = None. Status Affected:, Move Literal to Low Nibble in BSR = None. Status Affected:, Move Literal to Low Nibble in BSR = None. Encoding:, Move Literal to Low Nibble in BSR = 0000. Encoding:, Move Literal to Low Nibble in BSR = 0001. Encoding:, Move Literal to Low Nibble in BSR = kkkk. Encoding:, Move Literal to Low Nibble in BSR = kkkk. Description:, Move Literal to Low Nibble in BSR = The eight-bit literal GLYPH<145>kGLYPH<146> is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains GLYPH<145> 0 GLYPH<146>, regardless of the value of k 7 :k 4 .. Description:, Move Literal to Low Nibble in BSR = The eight-bit literal GLYPH<145>kGLYPH<146> is loaded into the Bank Select Register (BSR). The value",
    "PIC18F6390/6490/8390/8490\nof BSR<7:4> always remains GLYPH<145> 0 GLYPH<146>, regardless of the value of k 7 :k 4 .. Description:, Move Literal to Low Nibble in BSR = The eight-bit literal GLYPH<145>kGLYPH<146> is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains GLYPH<145> 0 GLYPH<146>, regardless of the value of k 7 :k 4 .. Description:, Move Literal to Low Nibble in BSR = The eight-bit literal GLYPH<145>kGLYPH<146> is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains GLYPH<145> 0 GLYPH<146>, regardless of the value of k 7 :k 4 .. Words:, Move Literal to Low Nibble in BSR = 1. Words:, Move Literal to Low Nibble in BSR = 1. Words:, Move Literal to Low Nibble in BSR = 1.",
    "PIC18F6390/6490/8390/8490\nWords:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Q Cycle Activity:, Move Literal to Low Nibble in BSR = . Q Cycle Activity:, Move Literal to Low Nibble in BSR = . Q Cycle Activity:, Move Literal to Low Nibble in BSR = . Q Cycle Activity:, Move Literal to Low Nibble in BSR = . Q1, Move Literal to Low Nibble in BSR = Q2. Q1, Move Literal to Low Nibble in BSR = Q2. Q1, Move Literal to Low Nibble in BSR = Q3. Q1, Move Literal to Low Nibble in BSR = Q4. Decode, Move Literal to Low Nibble in BSR = Read literal GLYPH<145>kGLYPH<146>. Decode, Move Literal to Low Nibble in",
    "PIC18F6390/6490/8390/8490\nBSR = Read literal GLYPH<145>kGLYPH<146>. Decode, Move Literal to Low Nibble in BSR = Process Data. Decode, Move Literal to Low Nibble in BSR = Write literal GLYPH<145>kGLYPH<146> to BSR. Example:, Move Literal to Low Nibble in BSR = MOVLB. Example:, Move Literal to Low Nibble in BSR = MOVLB. Example:, Move Literal to Low Nibble in BSR = 5. Example:, Move Literal to Low Nibble in BSR = . Before Instruction BSR Register =, Move Literal to Low Nibble in BSR = Before Instruction BSR Register =. Before Instruction BSR Register =, Move Literal to Low Nibble in BSR = 02h. Before Instruction BSR Register =, Move Literal to Low Nibble in BSR = . Before Instruction BSR Register =, Move Literal to Low Nibble in BSR = ",
    "Example:\nMOVFF   REG1, REG2\nBefore Instruction\nREG1\n=\n33h\nREG2\n=\n11h\nAfter Instruction\nREG1\n= 33h\nREG2\n=\n33h",
    "PIC18F6390/6490/8390/8490\nSyntax:, Move Literal to W = MOVLW k. Syntax:, Move Literal to W = MOVLW k. Syntax:, Move Literal to W = MOVLW k. Syntax:, Move Literal to W = MOVLW k. Operands:, Move Literal to W = 0 \u2264 k \u2264 255. Operands:, Move Literal to W = 0 \u2264 k \u2264 255. Operands:, Move Literal to W = 0 \u2264 k \u2264 255. Operands:, Move Literal to W = 0 \u2264 k \u2264 255. Operation:, Move Literal to W = k \u2192 W. Operation:, Move Literal to W = k \u2192 W. Operation:, Move Literal to W = k \u2192 W. Operation:, Move Literal to W = k \u2192 W. Status Affected:, Move Literal to W = None. Status Affected:, Move Literal to W = None. Status Affected:, Move Literal to W = None. Status Affected:, Move Literal to W = None. Encoding:, Move Literal to W = 0000. Encoding:, Move Literal to W = 1110. Encoding:, Move Literal to W =",
    "PIC18F6390/6490/8390/8490\nkkkk. Encoding:, Move Literal to W = kkkk. Description:, Move Literal to W = The eight-bit literal GLYPH<145>kGLYPH<146> is loaded into W.. Description:, Move Literal to W = The eight-bit literal GLYPH<145>kGLYPH<146> is loaded into W.. Description:, Move Literal to W = The eight-bit literal GLYPH<145>kGLYPH<146> is loaded into W.. Description:, Move Literal to W = The eight-bit literal GLYPH<145>kGLYPH<146> is loaded into W.. Words:, Move Literal to W = 1. Words:, Move Literal to W = 1. Words:, Move Literal to W = 1. Words:, Move Literal to W = 1. Cycles:, Move Literal to W = 1. Cycles:, Move Literal to W = 1. Cycles:, Move Literal to W = 1. Cycles:, Move Literal to W = 1. Q Cycle Activity:, Move Literal to W = Q Cycle Activity:. Q Cycle Activity:, Move",
    "PIC18F6390/6490/8390/8490\nLiteral to W = Q Cycle Activity:. Q Cycle Activity:, Move Literal to W = Q Cycle Activity:. Q Cycle Activity:, Move Literal to W = Q Cycle Activity:. Q1, Move Literal to W = Q2. Q1, Move Literal to W = Q3. Q1, Move Literal to W = Q4. Q1, Move Literal to W = Q4. Decode, Move Literal to W = Read literal GLYPH<145>kGLYPH<146>. Decode, Move Literal to W = Process Data. Decode, Move Literal to W = Write to W. Decode, Move Literal to W = Write to W. Example:, Move Literal to W = MOVLW. Example:, Move Literal to W = 5Ah. Example:, Move Literal to W = . Example:, Move Literal to W = . After Instruction W =, Move Literal to W = 5Ah. After Instruction W =, Move Literal to W = . After Instruction W =, Move Literal to W = . After Instruction W =, Move Literal to W = ",
    "PIC18F6390/6490/8390/8490\nSyntax:, Move Wto f = MOVWF f {,a}. Syntax:, Move Wto f = MOVWF f {,a}. Syntax:, Move Wto f = MOVWF f {,a}. Syntax:, Move Wto f = MOVWF f {,a}. Operands:, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Move Wto f = (W) \u2192 f. Operation:, Move Wto f = (W) \u2192 f. Operation:, Move Wto f = (W) \u2192 f. Operation:, Move Wto f = (W) \u2192 f. Status Affected:, Move Wto f = None. Status Affected:, Move Wto f = None. Status",
    "PIC18F6390/6490/8390/8490\nAffected:, Move Wto f = None. Status Affected:, Move Wto f = None. Encoding:, Move Wto f = 0110. Encoding:, Move Wto f = 111a. Encoding:, Move Wto f = ffff. Encoding:, Move Wto f = . Description:, Move Wto f = Move data from Wto register GLYPH<145>f GLYPH<146> . Location GLYPH<145>fGLYPH<146> can be anywhere in the 256-byte bank. If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95",
    "PIC18F6390/6490/8390/8490\n(5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and. Description:, Move Wto f = Move data from Wto register GLYPH<145>f GLYPH<146> . Location GLYPH<145>fGLYPH<146> can be anywhere in the 256-byte bank. If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and. Description:, Move Wto f = Move data from Wto register",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>f GLYPH<146> . Location GLYPH<145>fGLYPH<146> can be anywhere in the 256-byte bank. If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and. Description:, Move Wto f = Move data from Wto register GLYPH<145>f GLYPH<146> . Location GLYPH<145>fGLYPH<146> can be anywhere in the 256-byte bank. If GLYPH<145>",
    "PIC18F6390/6490/8390/8490\naGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and. Words:, Move Wto f = . Words:, Move Wto f = . Words:, Move Wto f = . Words:, Move Wto f = . Cycles:, Move Wto f = . Cycles:, Move Wto f = . Cycles:, Move Wto f = . Cycles:, Move Wto f = . Q Cycle Activity:, Move Wto f = . Q Cycle Activity:, Move Wto f = . Q Cycle Activity:, Move Wto",
    "PIC18F6390/6490/8390/8490\nf = . Q Cycle Activity:, Move Wto f = . Q1, Move Wto f = . Q1, Move Wto f = . Q1, Move Wto f = . Q1, Move Wto f = . Decode, Move Wto f = register GLYPH<145>f GLYPH<146>. Decode, Move Wto f = . Decode, Move Wto f = . Decode, Move Wto f = . , Move Wto f = . , Move Wto f = . , Move Wto f = REG, 0. , Move Wto f = . Instruction, Move Wto f = . Instruction, Move Wto f = . Instruction, Move Wto f = . Instruction, Move Wto f = . =, Move Wto f = . =, Move Wto f = . =, Move Wto f = . =, Move Wto f = . =, Move Wto f = . =, Move Wto f = . =, Move Wto f = . =, Move Wto f = . REG, Move Wto f = . REG, Move Wto f",
    "PIC18F6390/6490/8390/8490\n= 4Fh. REG, Move Wto f = . REG, Move Wto f = . , Move Wto f = MOVWF = 4Fh. , Move Wto f = FFh. , Move Wto f = . , Move Wto f = . Instruction, Move Wto f = Literal 1 1. Instruction, Move Wto f = . Instruction, Move Wto f = . Instruction, Move Wto f = . , Move Wto f = Offset. , Move Wto f = . , Move Wto f = . , Move Wto f = . , Move Wto f = . , Move Wto f = 4Fh. , Move Wto f = . , Move Wto f = . Bit-Oriented, Move Wto f = . Bit-Oriented, Move Wto f = . Bit-Oriented, Move Wto f = Q3 Process. Bit-Oriented, Move Wto f = . , Move Wto f = Q2. , Move Wto f = . , Move Wto f = . , Move Wto f = . , Move Wto f = =. , Move Wto f =",
    "PIC18F6390/6490/8390/8490\n. , Move Wto f = . , Move Wto f = . , Move Wto f = . , Move Wto f = . , Move Wto f = Data. , Move Wto f = . , Move Wto f = . , Move Wto f = . , Move Wto f = . , Move Wto f = register GLYPH<145>. , Move Wto f = . , Move Wto f = . , Move Wto f = . , Move Wto f = fGLYPH<146>. , Move Wto f = . , Move Wto f = . , Move Wto f = . , Move Wto f = Write. , Move Wto f = Read. , Move Wto f = . , Move Wto f = . , Move Wto f = ",
    "PIC18F6390/6490/8390/8490\nSyntax:, Multiply Literal with W = MULLW. Syntax:, Multiply Literal with W = k. Syntax:, Multiply Literal with W = . Syntax:, Multiply Literal with W = . Operands:, Multiply Literal with W = 0 \u2264 k \u2264 255. Operands:, Multiply Literal with W = 0 \u2264 k \u2264 255. Operands:, Multiply Literal with W = 0 \u2264 k \u2264 255. Operands:, Multiply Literal with W = 0 \u2264 k \u2264 255. Operation:, Multiply Literal with W = (W) x k \u2192 PRODH:PRODL. Operation:, Multiply Literal with W = (W) x k \u2192 PRODH:PRODL. Operation:, Multiply Literal with W = (W) x k \u2192 PRODH:PRODL. Operation:, Multiply Literal with W = (W) x k \u2192 PRODH:PRODL. Status Affected:, Multiply Literal with W = None. Status Affected:, Multiply Literal with W = None. Status Affected:, Multiply Literal with W = None. Status Affected:, Multiply Literal with W = None.",
    "PIC18F6390/6490/8390/8490\nEncoding:, Multiply Literal with W = 0000. Encoding:, Multiply Literal with W = 1101. Encoding:, Multiply Literal with W = kkkk. Encoding:, Multiply Literal with W = kkkk. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal GLYPH<145>kGLYPH<146>. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither Overflow nor Carry is possible in this operation. A Zero result is possible but not detected.. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal GLYPH<145>kGLYPH<146>. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither Overflow nor Carry is possible in this operation. A Zero result is possible but not",
    "PIC18F6390/6490/8390/8490\ndetected.. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal GLYPH<145>kGLYPH<146>. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither Overflow nor Carry is possible in this operation. A Zero result is possible but not detected.. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal GLYPH<145>kGLYPH<146>. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither Overflow nor Carry is possible in this operation. A Zero result is possible but not detected.. Words:, Multiply Literal with W = 1. Words:, Multiply Literal with W = . Words:, Multiply Literal with W = . Words:, Multiply Literal with W = . Cycles:,",
    "PIC18F6390/6490/8390/8490\nMultiply Literal with W = 1. Cycles:, Multiply Literal with W = . Cycles:, Multiply Literal with W = . Cycles:, Multiply Literal with W = . Q Cycle Activity:, Multiply Literal with W = . Q Cycle Activity:, Multiply Literal with W = . Q Cycle Activity:, Multiply Literal with W = . Q Cycle Activity:, Multiply Literal with W = . Q1, Multiply Literal with W = Q2. Q1, Multiply Literal with W = Q3. Q1, Multiply Literal with W = . Q1, Multiply Literal with W = Q4. Decode, Multiply Literal with W = Read literal GLYPH<145>kGLYPH<146>. Decode, Multiply Literal with W = . Decode, Multiply Literal with W = Process Data. Decode, Multiply Literal with W = Write registers PRODH: PRODL",
    "Example:\nMULLW   0C4h\nBefore Instruction\nW\n=\nE2h\nPRODH\n=\n?\nPRODL\n=\n?\nAfter Instruction\nW\n=\nE2h\nPRODH\n=\nADh\nPRODL\n=\n08h\nWords:\nCycles:",
    "Example:\nSyntax:, Multiply Wwith f = MULWF. Syntax:, Multiply Wwith f = f {,a}. Syntax:, Multiply Wwith f = . Syntax:, Multiply Wwith f = . Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255. Operands:, Multiply Wwith f = . Operands:, Multiply Wwith f = . Operands:, Multiply Wwith f = . , Multiply Wwith f = a \u2208 [0,1]. , Multiply Wwith f = . , Multiply Wwith f = . , Multiply Wwith f = . Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = . Status",
    "Example:\nAffected:, Multiply Wwith f = . Status Affected:, Multiply Wwith f = . Encoding:, Multiply Wwith f = 0000. Encoding:, Multiply Wwith f = 001a. Encoding:, Multiply Wwith f = ffff. Encoding:, Multiply Wwith f = ffff\nDescription:\nAn unsigned multiplication is carried out between the contents of W and the register file location GLYPH<145>fGLYPH<146>. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both W and GLYPH<145>fGLYPH<146> are unchanged.\nNone of the Status flags are affected. Note that neither Overflow nor Carry is possible in this operation. A Zero result is possible but not detected.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.",
    "Example:\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>  and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write registers PRODH: PRODL\nMULWF   REG, 1\nBefore Instruction\nW\n=\nC4h\nREG\n=\nB5h\nPRODH\n=\n?\nPRODL\n=\n?\nAfter Instruction\nW\n=\nC4h\nREG\n=\nB5h\nPRODH\n=\n8Ah\nPRODL\n=\n94h\nCycles:",
    "PIC18F6390/6490/8390/8490\nSyntax:, Negate f = NEGF. Syntax:, Negate f = f {,a}. Syntax:, Negate f = . Syntax:, Negate f = . Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Negate f = (f) + 1 \u2192 f. Operation:, Negate f = (f) + 1 \u2192 f. Operation:, Negate f = (f) + 1 \u2192 f. Operation:, Negate f = (f) + 1 \u2192 f. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status",
    "PIC18F6390/6490/8390/8490\nAffected:, Negate f = N, OV, C, DC, Z. Encoding:, Negate f = 0110. Encoding:, Negate f = 110a. Encoding:, Negate f = ffff. Encoding:, Negate f = ffff. Description:, Negate f = Location GLYPH<145>f GLYPH<146> is negated using twoGLYPH<146>s complement. The result is placed in the data memory location GLYPH<145>f GLYPH<146>.. Description:, Negate f = Location GLYPH<145>f GLYPH<146> is negated using twoGLYPH<146>s complement. The result is placed in the data memory location GLYPH<145>f GLYPH<146>.. Description:, Negate f = Location GLYPH<145>f GLYPH<146> is negated using twoGLYPH<146>s complement. The result is placed in the data memory location GLYPH<145>f GLYPH<146>.. Description:, Negate f = Location",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>f GLYPH<146> is negated using twoGLYPH<146>s complement. The result is placed in the data memory location GLYPH<145>f GLYPH<146>.. , Negate f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.. , Negate f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.. , Negate f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0",
    "PIC18F6390/6490/8390/8490\nGLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.. , Negate f = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.. , Negate f = If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. , Negate f = If GLYPH<145>",
    "PIC18F6390/6490/8390/8490\naGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. , Negate f = If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. , Negate f = If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section",
    "PIC18F6390/6490/8390/8490\n24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. Words:, Negate f = 1. Words:, Negate f = . Words:, Negate f = . Words:, Negate f = \n1\nQ Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write register GLYPH<145> fGLYPH<146>\nBefore Instruction REG =, NEGF = 0011. Before Instruction REG =, REG, = 1010. Before Instruction REG =, 1 = [3Ah]. After Instruction REG =, NEGF = 1100. After Instruction REG =, REG, = 0110. After Instruction REG =, 1 = [C6h]",
    "No Operation\nSyntax:, 1 = NOP. Syntax:, 2 = NOP. Syntax:, 3 = NOP. Syntax:, 4 = NOP. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = No operation. Operation:, 2 = No operation. Operation:, 3 = No operation. Operation:, 4 = No operation. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0000 1111. Encoding:, 2 = 0000 xxxx. Encoding:, 3 = 0000 xxxx. Encoding:, 4 = 0000 xxxx. Description:, 1 = No operation.. Description:, 2 = No operation.. Description:, 3 = No operation.. Description:, 4 = No operation.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1.",
    "No Operation\nCycles:, 4 = 1. Q Cycle Activity: Q1, 1 = Q2. Q Cycle Activity: Q1, 2 = Q3. Q Cycle Activity: Q1, 3 = . Q Cycle Activity: Q1, 4 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = . Decode, 4 = No operation\nExample:\nNone.",
    "PIC18F6390/6490/8390/8490\nSyntax:, Pop Top of Return Stack = POP. Syntax:, Pop Top of Return Stack = POP. Syntax:, Pop Top of Return Stack = POP. Syntax:, Pop Top of Return Stack = POP. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return Stack =",
    "PIC18F6390/6490/8390/8490\n0000. Encoding:, Pop Top of Return Stack = 0110. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return. Words:, Pop Top of Return Stack =",
    "PIC18F6390/6490/8390/8490\n1. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Q Cycle Activity:, Pop Top of Return Stack = . Q Cycle Activity:, Pop Top of Return Stack = . Q Cycle Activity:, Pop Top of Return Stack = . Q Cycle Activity:, Pop Top of Return Stack = . Q1, Pop Top of Return Stack = Q2. Q1, Pop Top of Return Stack = Q3. Q1, Pop Top of Return Stack = Q3. Q1, Pop Top of Return Stack = Q4. Decode, Pop Top of Return Stack = No operation. Decode, Pop Top of Return Stack = POP TOS value. Decode, Pop Top of Return Stack = POP TOS value. Decode, Pop Top of Return Stack = No operation. Example:, Pop Top of Return Stack = POP. Example:,",
    "PIC18F6390/6490/8390/8490\nPop Top of Return Stack = . Example:, Pop Top of Return Stack = . Example:, Pop Top of Return Stack = . Before Instruction, Pop Top of Return Stack = GOTO. Before Instruction, Pop Top of Return Stack = NEW. Before Instruction, Pop Top of Return Stack = . Before Instruction, Pop Top of Return Stack = . TOS, Pop Top of Return Stack = . TOS, Pop Top of Return Stack = = =. TOS, Pop Top of Return Stack = 0031A2h 014332h. TOS, Pop Top of Return Stack = . Stack (1 level down) After Instruction, Pop Top of Return Stack = Stack (1 level down) After Instruction. Stack (1 level down) After Instruction, Pop Top of Return Stack = . Stack (1 level down) After Instruction, Pop Top of Return Stack = . Stack (1 level down) After Instruction, Pop Top of Return Stack = . TOS, Pop Top of Return Stack = . TOS, Pop Top of Return Stack = =. TOS, Pop Top of Return Stack = 014332h. TOS, Pop Top of Return Stack = . PC, Pop",
    "PIC18F6390/6490/8390/8490\nTop of Return Stack = . PC, Pop Top of Return Stack = =. PC, Pop Top of Return Stack = NEW. PC, Pop Top of Return Stack = ",
    "PIC18F6390/6490/8390/8490\nSyntax:, Push Top of Return Stack = PUSH. Syntax:, Push Top of Return Stack = PUSH. Syntax:, Push Top of Return Stack = PUSH. Syntax:, Push Top of Return Stack = PUSH. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operation:, Push Top of Return Stack = (PC + 2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC + 2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC + 2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC + 2) \u2192 TOS. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top",
    "PIC18F6390/6490/8390/8490\nof Return Stack = 0000. Encoding:, Push Top of Return Stack = 0101. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return",
    "PIC18F6390/6490/8390/8490\nstack.. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Q Cycle Activity:, Push Top of Return Stack = . Q Cycle Activity:, Push Top of Return Stack = . Q Cycle Activity:, Push Top of Return Stack = . Q Cycle Activity:, Push Top of Return Stack = . Q1, Push Top of Return Stack = Q2. Q1, Push Top of Return Stack = Q3. Q1, Push Top of Return Stack = Q3. Q1, Push Top of Return Stack = Q4. Decode, Push Top of Return Stack = PUSH PC + 2 onto return stack. Decode, Push Top of Return Stack = No operation. Decode, Push Top of Return Stack = No operation. Decode, Push Top of Return Stack = No operation.",
    "PIC18F6390/6490/8390/8490\nExample:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. TOS, Push Top of Return Stack = TOS. TOS, Push Top of Return Stack = =. TOS, Push Top of Return Stack = 345Ah. TOS, Push Top of Return Stack = . PC, Push Top of Return Stack = PC. PC, Push Top of Return Stack = =. PC, Push Top of Return Stack = 0124h. PC, Push Top of Return Stack = . After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. PC, Push Top of Return Stack = PC. PC, Push Top of",
    "PIC18F6390/6490/8390/8490\nReturn Stack = =. PC, Push Top of Return Stack = 0126h. PC, Push Top of Return Stack = . TOS, Push Top of Return Stack = TOS. TOS, Push Top of Return Stack = =. TOS, Push Top of Return Stack = 0126h. TOS, Push Top of Return Stack = . Stack (1 level down), Push Top of Return Stack = Stack (1 level down). Stack (1 level down), Push Top of Return Stack = =. Stack (1 level down), Push Top of Return Stack = 345Ah. Stack (1 level down), Push Top of Return Stack = ",
    "PIC18F6390/6490/8390/8490\nSyntax:, Relative Call = RCALL n. Syntax:, Relative Call = RCALL n. Syntax:, Relative Call = RCALL n. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Encoding:, Relative Call = 1101. Encoding:, Relative Call = 1nnn. Encoding:, Relative Call = nnnn nnnn. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address",
    "PIC18F6390/6490/8390/8490\n(PC + 2) is pushed onto the stack. Then, add the 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2GLYPH<146>s complement number GLYPH<145>2nGLYPH<146> to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2GLYPH<146>s complement number",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>2nGLYPH<146> to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Words:, Relative Call = 1. Words:, Relative Call = 1. Words:, Relative Call = 1. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Q Cycle Activity:, Relative Call = Q Cycle Activity:. Q Cycle Activity:, Relative Call = Q Cycle Activity:. Q Cycle Activity:, Relative Call = Q Cycle Activity:. Q1, Relative Call = Q2. Q1, Relative Call = Q3. Q1, Relative Call = Q4. Decode, Relative Call = Read literal GLYPH<145> nGLYPH<146> PUSH PC to stack. Decode, Relative Call = Process Data. Decode, Relative Call = Write to PC. No operation, Relative Call = No operation. No operation, Relative Call = No operation. No operation, Relative Call = No operation",
    "PIC18F6390/6490/8390/8490\nSyntax:, Reset = RESET. Syntax:, Reset = RESET. Syntax:, Reset = RESET. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Encoding:, Reset = 0000. Encoding:, Reset = 0000. Encoding:, Reset = 1111. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Cycles:, Reset = 1.",
    "PIC18F6390/6490/8390/8490\nCycles:, Reset = 1. Cycles:, Reset = 1. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q1, Reset = Q2. Q1, Reset = Q3. Q1, Reset = Q4. Decode, Reset = Start Reset. Decode, Reset = No operation. Decode, Reset = No operation. Example:, Reset = RESET. Example:, Reset = RESET. Example:, Reset = RESET. After Instruction Registers = Flags* =, Reset = . After Instruction Registers = Flags* =, Reset = . After Instruction Registers = Flags* =, Reset = ",
    "Example:\nHERE\nRCALL Jump\nBefore Instruction\nPC = Address (HERE)\nAfter Instruction\nPC =\nAddress\n(Jump)\nTOS =\nAddress\n(HERE + 2)",
    "PIC18F6390/6490/8390/8490\nSyntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Operands:, Return from Interrupt = s \u2208 [0,1]. Operands:, Return from Interrupt = s \u2208 [0,1]. Operands:, Return from Interrupt = s \u2208 [0,1]. Operands:, Return from Interrupt = s \u2208 [0,1]. Operation:, Return from Interrupt = (TOS) \u2192 PC, 1 \u2192 GIE/GIEH or PEIE/GIEL; if s = 1 , (WS) \u2192 W, (STATUSS) \u2192 STATUS, (BSRS) \u2192 BSR,. Operation:, Return from Interrupt = (TOS) \u2192 PC, 1 \u2192 GIE/GIEH or PEIE/GIEL; if s = 1 , (WS) \u2192 W, (STATUSS) \u2192 STATUS, (BSRS) \u2192 BSR,. Operation:, Return from Interrupt =",
    "PIC18F6390/6490/8390/8490\n(TOS) \u2192 PC, 1 \u2192 GIE/GIEH or PEIE/GIEL; if s = 1 , (WS) \u2192 W, (STATUSS) \u2192 STATUS, (BSRS) \u2192 BSR,. Operation:, Return from Interrupt = (TOS) \u2192 PC, 1 \u2192 GIE/GIEH or PEIE/GIEL; if s = 1 , (WS) \u2192 W, (STATUSS) \u2192 STATUS, (BSRS) \u2192 BSR,. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0001. Encoding:, Return from Interrupt = 000s. Description:, Return from Interrupt = Return from Interrupt. Stack",
    "PIC18F6390/6490/8390/8490\nis popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low-priority global interrupt enable bit. If GLYPH<145>sGLYPH<146> = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If GLYPH<145>sGLYPH<146> = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from Interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low-priority global interrupt enable bit. If GLYPH<145>sGLYPH<146> = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If GLYPH<145>sGLYPH<146> = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from Interrupt.",
    "PIC18F6390/6490/8390/8490\nStack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low-priority global interrupt enable bit. If GLYPH<145>sGLYPH<146> = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If GLYPH<145>sGLYPH<146> = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from Interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low-priority global interrupt enable bit. If GLYPH<145>sGLYPH<146> = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If GLYPH<145>sGLYPH<146> = 0 , no update of these registers occurs (default).. Words:, Return from Interrupt = 1.",
    "PIC18F6390/6490/8390/8490\nWords:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Q Cycle Activity:, Return from Interrupt = . Q Cycle Activity:, Return from Interrupt = . Q Cycle Activity:, Return from Interrupt = . Q Cycle Activity:, Return from Interrupt = . Q1, Return from Interrupt = Q2. Q1, Return from Interrupt = Q3. Q1, Return from Interrupt = Q3. Q1, Return from Interrupt = Q4. Decode, Return from Interrupt = No operation. Decode, Return from Interrupt = No operation. Decode, Return from Interrupt = No operation. Decode, Return from Interrupt = POP PC from stack Set GIEH or GIEL. No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation",
    "RETFIE  1\nAfter Interrupt\nPC\n=\nTOS\nW\n=\nWS\nBSR\n=\nBSRS\nSTATUS\n= STATUSS\nGIE/GIEH, PEIE/GIEL\n=\n1",
    "RETFIE  1\nSyntax:, Return Literal to W = RETLW k. Syntax:, Return Literal to W = RETLW k. Syntax:, Return Literal to W = RETLW k. Syntax:, Return Literal to W = RETLW k. Operands:, Return Literal to W = 0 \u2264 k \u2264 255. Operands:, Return Literal to W = 0 \u2264 k \u2264 255. Operands:, Return Literal to W = 0 \u2264 k \u2264 255. Operands:, Return Literal to W = 0 \u2264 k \u2264 255. Operation:, Return Literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Status",
    "RETFIE  1\nAffected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Encoding:, Return Literal to W = 0000. Encoding:, Return Literal to W = 1100. Encoding:, Return Literal to W = kkkk. Encoding:, Return Literal to W = kkkk. Description:, Return Literal to W = Wis loaded with the eight-bit literal GLYPH<145> kGLYPH<146>. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal GLYPH<145> kGLYPH<146>. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal GLYPH<145> kGLYPH<146>. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to",
    "RETFIE  1\nW = Wis loaded with the eight-bit literal GLYPH<145> kGLYPH<146>. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q1, Return Literal to W = Q2. Q1, Return Literal to W = Q3. Q1, Return Literal to W = . Q1, Return Literal to W = Q4. Decode, Return Literal to W = Read literal",
    "RETFIE  1\nGLYPH<145>kGLYPH<146>. Decode, Return Literal to W = Process Data. Decode, Return Literal to W = . Decode, Return Literal to W = POP PC from stack, Write to W. No operation, Return Literal to W = No operation. No operation, Return Literal to W = No operation. No operation, Return Literal to W = . No operation, Return Literal to W = No operation",
    "Example:\nCALL, 1 = TABLE. CALL, 2 = ; ; ;. CALL, 3 = W contains table offset value W now has. :, 1 = . :, 2 = . :, 3 = . TABLE, 1 = . TABLE, 2 = . TABLE, 3 = . ADDWF RETLW, 1 = PCL k0. ADDWF RETLW, 2 = ;. ADDWF RETLW, 3 = W = offset Begin table. , 1 = . , 2 = ;. , 3 = . RETLW, 1 = k1. RETLW, 2 = ;. RETLW, 3 = . :, 1 = . :, 2 = . :, 3 = . :, 1 = . :, 2 = . :, 3 = . RETLW, 1 = kn. RETLW, 2 = ;. RETLW, 3 = End of table. Before Instruction, 1 = Before Instruction. Before Instruction, 2 = Before Instruction. Before Instruction, 3 = . W, 1 = . W, 2 = =. W, 3 = 07h. After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. After Instruction, 3 = . W,",
    "Example:\n1 = . W, 2 = =. W, 3 = value of kn",
    "PIC18F6390/6490/8390/8490\nSyntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Operands:, Return from Subroutine = s \u2208 [0,1]. Operands:, Return from Subroutine = s \u2208 [0,1]. Operands:, Return from Subroutine = s \u2208 [0,1]. Operands:, Return from Subroutine = s \u2208 [0,1]. Operation:, Return from Subroutine = (TOS) \u2192 PC; if s = 1 , (WS) \u2192 W, (STATUSS) \u2192 STATUS, (BSRS) \u2192 BSR,. Operation:, Return from Subroutine = (TOS) \u2192 PC; if s = 1 , (WS) \u2192 W, (STATUSS) \u2192 STATUS, (BSRS) \u2192 BSR,. Operation:, Return from Subroutine = (TOS) \u2192 PC; if s = 1 , (WS)",
    "PIC18F6390/6490/8390/8490\n\u2192 W, (STATUSS) \u2192 STATUS, (BSRS) \u2192 BSR,. Operation:, Return from Subroutine = (TOS) \u2192 PC; if s = 1 , (WS) \u2192 W, (STATUSS) \u2192 STATUS, (BSRS) \u2192 BSR,. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Encoding:, Return from Subroutine = 0000. Encoding:, Return from Subroutine = 0000. Encoding:, Return from Subroutine = 0001. Encoding:, Return from Subroutine = 001s. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If GLYPH<145>sGLYPH<146>= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR.",
    "PIC18F6390/6490/8390/8490\nIf GLYPH<145>sGLYPH<146> = 0 , no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If GLYPH<145>sGLYPH<146>= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If GLYPH<145>sGLYPH<146> = 0 , no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If GLYPH<145>sGLYPH<146>= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If GLYPH<145>sGLYPH<146> = 0 , no update of these registers occurs",
    "PIC18F6390/6490/8390/8490\n(default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If GLYPH<145>sGLYPH<146>= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If GLYPH<145>sGLYPH<146> = 0 , no update of these registers occurs (default).. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from",
    "PIC18F6390/6490/8390/8490\nSubroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. , Return from Subroutine = Q1 Q2. , Return from Subroutine = Q3. , Return from Subroutine = . , Return from Subroutine = Q4. Decode, Return from Subroutine = . Decode, Return from Subroutine = No operation. Decode, Return from Subroutine = Process Data. Decode, Return from Subroutine = POP PC from stack. No, Return from Subroutine = operation. No, Return from Subroutine = No operation. No, Return from Subroutine = No operation. No, Return from Subroutine = No operation\nExample:\nRETURN\nAfter Interrupt PC = TOS",
    "PIC18F6390/6490/8390/8490\nSyntax:, Rotate Left f through Carry = RLCF f {,d {,a}}. Syntax:, Rotate Left f through Carry = RLCF f {,d {,a}}. Syntax:, Rotate Left f through Carry = RLCF f {,d {,a}}. Syntax:, Rotate Left f through Carry = RLCF f {,d {,a}}. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1]. , Rotate Left f through Carry = a \u2208 [0,1]. , Rotate Left f through Carry = a \u2208 [0,1]. , Rotate Left f through Carry = a \u2208 [0,1]. , Rotate Left f through Carry = a \u2208 [0,1].",
    "PIC18F6390/6490/8390/8490\nOperation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C,. Operation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C,. Operation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C,. Operation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C,. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = . Status Affected:, Rotate Left f through Carry = . Status Affected:, Rotate Left f through Carry = . Encoding:, Rotate Left f through Carry = 0011. Encoding:, Rotate Left f through Carry = 01da ffff. Encoding:, Rotate Left f through Carry = 01da ffff. Encoding:, Rotate Left f through Carry = ffff. Description:, Rotate",
    "PIC18F6390/6490/8390/8490\nLeft f through Carry = The contents one bit to the left through the Carry flag. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored back in register GLYPH<145>fGLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145> aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3",
    "PIC18F6390/6490/8390/8490\nGLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset. Description:, Rotate Left f through Carry = of register. Description:, Rotate Left f through Carry = The contents one bit to the left through the Carry flag. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored back in register GLYPH<145>fGLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145> aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the",
    "PIC18F6390/6490/8390/8490\nextended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset. Description:, Rotate Left f through Carry = GLYPH<146> are rotated. , Rotate Left f through Carry = C register f. , Rotate Left f through Carry = C register f. , Rotate Left f through Carry = C register f. , Rotate Left f through Carry = C register f. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = . Words:, Rotate Left f through Carry = . Words:, Rotate Left f through Carry = . Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = . Cycles:, Rotate Left f through Carry = . Cycles:, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = Q2 Read register GLYPH<145>f GLYPH<146>. Q Cycle Activity: Q1, Rotate Left f through Carry =",
    "PIC18F6390/6490/8390/8490\nQ3. Q Cycle Activity: Q1, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = Q4. Decode, Rotate Left f through Carry = . Decode, Rotate Left f through Carry = Process Data. Decode, Rotate Left f through Carry = . Decode, Rotate Left f through Carry = Write to destination. Example:, Rotate Left f through Carry = RLCF. Example:, Rotate Left f through Carry = REG,. Example:, Rotate Left f through Carry = 0,. Example:, Rotate Left f through Carry = . , Rotate Left f through Carry = . , Rotate Left f through Carry = . , Rotate Left f through Carry = . , Rotate Left f through Carry = 0. Before Instruction REG = 1110 0110 C = 0 After Instruction, Rotate Left f through Carry = Before Instruction REG = 1110 0110 C = 0 After Instruction. Before Instruction REG = 1110 0110 C = 0 After Instruction, Rotate Left f through Carry = Before Instruction REG = 1110 0110 C = 0 After Instruction. Before Instruction REG = 1110 0110 C = 0 After Instruction, Rotate",
    "PIC18F6390/6490/8390/8490\nLeft f through Carry = Before Instruction REG = 1110 0110 C = 0 After Instruction. Before Instruction REG = 1110 0110 C = 0 After Instruction, Rotate Left f through Carry = Before Instruction REG = 1110 0110 C = 0 After Instruction. REG, Rotate Left f through Carry = = 1110. REG, Rotate Left f through Carry = 0110. REG, Rotate Left f through Carry = . REG, Rotate Left f through Carry = . W, Rotate Left f through Carry = = 1100. W, Rotate Left f through Carry = 1100. W, Rotate Left f through Carry = . W, Rotate Left f through Carry = . C, Rotate Left f through Carry = = 1. C, Rotate Left f through Carry = . C, Rotate Left f through Carry = . C, Rotate Left f through Carry = ",
    "PIC18F6390/6490/8390/8490\nSyntax:, Rotate Left f (No Carry) = RLNCF. Syntax:, Rotate Left f (No Carry) = f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = f {,d {,a}}. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192",
    "PIC18F6390/6490/8390/8490\ndest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Encoding:, Rotate Left f (No Carry) = 0100. Encoding:, Rotate Left f (No Carry) = 01da. Encoding:, Rotate Left f (No Carry) = ffff. Encoding:, Rotate Left f (No Carry) =",
    "PIC18F6390/6490/8390/8490\nffff. Description:, Rotate Left f (No Carry) = The contents of register GLYPH<145>fGLYPH<146> are rotated one bit to the left. If GLYPH<145> dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145> dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored back in register GLYPH<145>f GLYPH<146> (default). If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145> aGLYPH<146> is GLYPH<145> 1 GLYPH<146> , the BSR is used to select the GPR bank. If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates. Description:,",
    "PIC18F6390/6490/8390/8490\nRotate Left f (No Carry) = The contents of register GLYPH<145>fGLYPH<146> are rotated one bit to the left. If GLYPH<145> dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145> dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored back in register GLYPH<145>f GLYPH<146> (default). If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145> aGLYPH<146> is GLYPH<145> 1 GLYPH<146> , the BSR is used to select the GPR bank. If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates. Description:, Rotate Left f (No",
    "PIC18F6390/6490/8390/8490\nCarry) = The contents of register GLYPH<145>fGLYPH<146> are rotated one bit to the left. If GLYPH<145> dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145> dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored back in register GLYPH<145>f GLYPH<146> (default). If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145> aGLYPH<146> is GLYPH<145> 1 GLYPH<146> , the BSR is used to select the GPR bank. If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates. Description:, Rotate Left f (No Carry) = The contents of",
    "PIC18F6390/6490/8390/8490\nregister GLYPH<145>fGLYPH<146> are rotated one bit to the left. If GLYPH<145> dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145> dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored back in register GLYPH<145>f GLYPH<146> (default). If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145> aGLYPH<146> is GLYPH<145> 1 GLYPH<146> , the BSR is used to select the GPR bank. If GLYPH<145> aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates. Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f",
    "PIC18F6390/6490/8390/8490\n(No Carry) = 1. Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Q Cycle Activity: Q1, Rotate Left f (No Carry) = Q2. Q Cycle Activity: Q1, Rotate Left f (No Carry) = Q3. Q Cycle Activity: Q1, Rotate Left f (No Carry) = . Q Cycle Activity: Q1, Rotate Left f (No Carry) = Q4. Decode, Rotate Left f (No Carry) = Read register GLYPH<145>f. Decode, Rotate Left f (No Carry) = Process Data. Decode, Rotate Left f (No Carry) = Process Data. Decode, Rotate Left f (No Carry) = Write to destination. Example:, Rotate Left f (No Carry) = RLNCF. Example:, Rotate Left f",
    "PIC18F6390/6490/8390/8490\n(No Carry) = REG,. Example:, Rotate Left f (No Carry) = 1,. Example:, Rotate Left f (No Carry) = 0. Before Instruction REG =, Rotate Left f (No Carry) = 1010. Before Instruction REG =, Rotate Left f (No Carry) = 1011. Before Instruction REG =, Rotate Left f (No Carry) = . Before Instruction REG =, Rotate Left f (No Carry) = . After Instruction REG =, Rotate Left f (No Carry) = 0101. After Instruction REG =, Rotate Left f (No Carry) = 0111. After Instruction REG =, Rotate Left f (No Carry) = . After Instruction REG =, Rotate Left f (No Carry) = ",
    "PIC18F6390/6490/8390/8490\nSyntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0",
    "PIC18F6390/6490/8390/8490\n\u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Right f through Carry = (f<n>) \u2192 dest<n GLYPH<150> 1>, (f<0>) \u2192 C, (C) \u2192 dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192 dest<n GLYPH<150> 1>, (f<0>) \u2192 C, (C) \u2192 dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192 dest<n GLYPH<150> 1>, (f<0>) \u2192 C, (C) \u2192 dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192 dest<n GLYPH<150> 1>, (f<0>) \u2192 C, (C) \u2192 dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192 dest<n GLYPH<150> 1>,",
    "PIC18F6390/6490/8390/8490\n(f<0>) \u2192 C, (C) \u2192 dest<7>. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 00da. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff. Description:, Rotate Right f through Carry = The contents of register GLYPH<145>f GLYPH<146> are rotated one bit to the right through the Carry flag. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>f GLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Rotate Right f through Carry = The contents of register GLYPH<145>f GLYPH<146> are rotated one bit to the right through the Carry flag.",
    "PIC18F6390/6490/8390/8490\nIf GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>f GLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed.",
    "PIC18F6390/6490/8390/8490\nDescription:, Rotate Right f through Carry = The contents of register GLYPH<145>f GLYPH<146> are rotated one bit to the right through the Carry flag. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>f GLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset",
    "PIC18F6390/6490/8390/8490\nAddressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Rotate Right f through Carry = The contents of register GLYPH<145>f GLYPH<146> are rotated one bit to the right through the Carry flag. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>f GLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Rotate Right f through Carry = The contents of register GLYPH<145>f GLYPH<146> are rotated one bit to the right through the Carry flag. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145>f GLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Q Cycle Activity:, Rotate Right f through Carry = . Q Cycle",
    "PIC18F6390/6490/8390/8490\nActivity:, Rotate Right f through Carry = . Q Cycle Activity:, Rotate Right f through Carry = . Q Cycle Activity:, Rotate Right f through Carry = . Q Cycle Activity:, Rotate Right f through Carry = . Q1, Rotate Right f through Carry = Q2 Q3. Q1, Rotate Right f through Carry = Q2 Q3. Q1, Rotate Right f through Carry = Q2 Q3. Q1, Rotate Right f through Carry = Q4. Q1, Rotate Right f through Carry = Q4. Decode, Rotate Right f through Carry = Read register GLYPH<145>f GLYPH<146> Process Data. Decode, Rotate Right f through Carry = Read register GLYPH<145>f GLYPH<146> Process Data. Decode, Rotate Right f through Carry = Read register GLYPH<145>f GLYPH<146> Process Data. Decode, Rotate Right f through Carry = Write to destination. Decode, Rotate Right f through Carry = Write to destination. Example: RRCF REG, 0, 0, Rotate Right f through Carry = Example: RRCF",
    "PIC18F6390/6490/8390/8490\nREG, 0, 0. Example: RRCF REG, 0, 0, Rotate Right f through Carry = Example: RRCF REG, 0, 0. Example: RRCF REG, 0, 0, Rotate Right f through Carry = Example: RRCF REG, 0, 0. Example: RRCF REG, 0, 0, Rotate Right f through Carry = Example: RRCF REG, 0, 0. Example: RRCF REG, 0, 0, Rotate Right f through Carry = Example: RRCF REG, 0, 0. REG, Rotate Right f through Carry = = 1110. REG, Rotate Right f through Carry = 0110. REG, Rotate Right f through Carry = . REG, Rotate Right f through Carry = . REG, Rotate Right f through Carry = . C, Rotate Right f through Carry = = 0. C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. After",
    "PIC18F6390/6490/8390/8490\nInstruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. REG, Rotate Right f through Carry = = 1110. REG, Rotate Right f through Carry = 0110. REG, Rotate Right f through Carry = . REG, Rotate Right f through Carry = . REG, Rotate Right f through Carry = . W, Rotate Right f through Carry = = 0111. W, Rotate Right f through Carry = 0011. W, Rotate Right f through Carry = . W, Rotate Right f through Carry = . W, Rotate Right f through Carry = . C, Rotate Right f through Carry = = 0. C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . C, Rotate Right f through Carry = ",
    "PIC18F6390/6490/8390/8490\nSyntax:, Rotate Right f (No Carry) = RRNCF f {,d {,a}}. Syntax:, Rotate Right f (No Carry) = RRNCF f {,d {,a}}. Syntax:, Rotate Right f (No Carry) = RRNCF f {,d {,a}}. Syntax:, Rotate Right f (No Carry) = RRNCF f {,d {,a}}. Syntax:, Rotate Right f (No Carry) = RRNCF f {,d {,a}}. Operands:, Rotate Right f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a",
    "PIC18F6390/6490/8390/8490\n\u2208 [0,1]. Operands:, Rotate Right f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Right f (No Carry) = (f<n>) \u2192 dest<n GLYPH<150> 1>, (f<0>) \u2192 dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \u2192 dest<n GLYPH<150> 1>, (f<0>) \u2192 dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \u2192 dest<n GLYPH<150> 1>, (f<0>) \u2192 dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \u2192 dest<n GLYPH<150> 1>, (f<0>) \u2192 dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \u2192 dest<n",
    "PIC18F6390/6490/8390/8490\nGLYPH<150> 1>, (f<0>) \u2192 dest<7>. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = N, Z. Encoding:, Rotate Right f (No Carry) = 0100. Encoding:, Rotate Right f (No Carry) = 00da. Encoding:, Rotate Right f (No Carry) = ffff. Encoding:, Rotate Right f (No Carry) = ffff. Encoding:, Rotate Right f (No Carry) = ffff. Description:, Rotate Right f (No Carry) = The contents of register GLYPH<145>f GLYPH<146> are rotated one bit to the right. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in",
    "PIC18F6390/6490/8390/8490\nW. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145> fGLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank will be selected, overriding the BSR value. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, then the bank will be selected as per the BSR value. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. Description:, Rotate Right f (No Carry) = The contents of register",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>f GLYPH<146> are rotated one bit to the right. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145> fGLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank will be selected, overriding the BSR value. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, then the bank will be selected as per the BSR value. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95",
    "PIC18F6390/6490/8390/8490\n(5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. Description:, Rotate Right f (No Carry) = The contents of register GLYPH<145>f GLYPH<146> are rotated one bit to the right. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145> fGLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank will be selected, overriding the BSR value. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, then the bank will be selected as per",
    "PIC18F6390/6490/8390/8490\nthe BSR value. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. Description:, Rotate Right f (No Carry) = The contents of register GLYPH<145>f GLYPH<146> are rotated one bit to the right. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145> fGLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0",
    "PIC18F6390/6490/8390/8490\nGLYPH<146>, the Access Bank will be selected, overriding the BSR value. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, then the bank will be selected as per the BSR value. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. Description:, Rotate Right f (No Carry) = The contents of register GLYPH<145>f GLYPH<146> are rotated one bit to the right. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is",
    "PIC18F6390/6490/8390/8490\nGLYPH<145> 1 GLYPH<146>, the result is placed back in register GLYPH<145> fGLYPH<146> (default). If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank will be selected, overriding the BSR value. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, then the bank will be selected as per the BSR value. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. Words:, Rotate Right f (No Carry) = 1. Words:, Rotate Right f (No Carry) = 1. Words:, Rotate Right f",
    "PIC18F6390/6490/8390/8490\n(No Carry) = 1. Words:, Rotate Right f (No Carry) = 1. Words:, Rotate Right f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = 1. Q Cycle Activity:, Rotate Right f (No Carry) = . Q Cycle Activity:, Rotate Right f (No Carry) = . Q Cycle Activity:, Rotate Right f (No Carry) = . Q Cycle Activity:, Rotate Right f (No Carry) = . Q Cycle Activity:, Rotate Right f (No Carry) = . Q1, Rotate Right f (No Carry) = . Q1, Rotate Right f (No Carry) = . Q1, Rotate Right f (No Carry) = . Q1, Rotate Right f (No Carry) = . Q1, Rotate Right f (No Carry) = . , Rotate Right f (No Carry) = Q2. ,",
    "PIC18F6390/6490/8390/8490\nRotate Right f (No Carry) = Q3. , Rotate Right f (No Carry) = Q3. , Rotate Right f (No Carry) = Q4. , Rotate Right f (No Carry) = Q4. Decode, Rotate Right f (No Carry) = Read register GLYPH<145>f. Decode, Rotate Right f (No Carry) = Process Data. Decode, Rotate Right f (No Carry) = Process Data. Decode, Rotate Right f (No Carry) = Write to destination. Decode, Rotate Right f (No Carry) = Write to destination. Example 1:, Rotate Right f (No Carry) = RRNCF. Example 1:, Rotate Right f (No Carry) = REG, 1, 0. Example 1:, Rotate Right f (No Carry) = REG, 1, 0. Example 1:, Rotate Right f (No Carry) = . Example 1:, Rotate Right f (No Carry) = . Before Instruction REG = 1101 0111, Rotate Right f (No Carry) = Before Instruction REG = 1101 0111. Before Instruction REG = 1101 0111, Rotate Right",
    "PIC18F6390/6490/8390/8490\nf (No Carry) = Before Instruction REG = 1101 0111. Before Instruction REG = 1101 0111, Rotate Right f (No Carry) = Before Instruction REG = 1101 0111. Before Instruction REG = 1101 0111, Rotate Right f (No Carry) = Before Instruction REG = 1101 0111. Before Instruction REG = 1101 0111, Rotate Right f (No Carry) = Before Instruction REG = 1101 0111. After Instruction REG, Rotate Right f (No Carry) = 1110. After Instruction REG, Rotate Right f (No Carry) = 1011. After Instruction REG, Rotate Right f (No Carry) = 1011. After Instruction REG, Rotate Right f (No Carry) = . After Instruction REG, Rotate Right f (No Carry) = . Example 2:, Rotate Right f (No Carry) = RRNCF. Example 2:, Rotate Right f (No Carry) = REG, 0,. Example 2:, Rotate Right f (No Carry) = REG, 0,. Example 2:, Rotate Right f (No Carry) = . Example 2:, Rotate Right f (No Carry) = . Before",
    "PIC18F6390/6490/8390/8490\nInstruction, Rotate Right f (No Carry) = Before Instruction. Before Instruction, Rotate Right f (No Carry) = Before Instruction. Before Instruction, Rotate Right f (No Carry) = Before Instruction. Before Instruction, Rotate Right f (No Carry) = Before Instruction. Before Instruction, Rotate Right f (No Carry) = Before Instruction. W, Rotate Right f (No Carry) = ? 1101. W, Rotate Right f (No Carry) = 0111. W, Rotate Right f (No Carry) = 0111. W, Rotate Right f (No Carry) = . W, Rotate Right f (No Carry) = . Instruction, Rotate Right f (No Carry) = Instruction. Instruction, Rotate Right f (No Carry) = Instruction. Instruction, Rotate Right f (No Carry) = Instruction. Instruction, Rotate Right f (No Carry) = Instruction. Instruction, Rotate Right f (No Carry) = Instruction. REG, Rotate Right f (No Carry) = . REG, Rotate Right f (No Carry) = . REG, Rotate Right f (No Carry) = . REG, Rotate Right f (No Carry) = . REG, Rotate Right f",
    "PIC18F6390/6490/8390/8490\n(No Carry) = . After, Rotate Right f (No Carry) = After. After, Rotate Right f (No Carry) = After. After, Rotate Right f (No Carry) = After. After, Rotate Right f (No Carry) = After. After, Rotate Right f (No Carry) = After. W REG, Rotate Right f (No Carry) = 1110 1101. W REG, Rotate Right f (No Carry) = 1011. W REG, Rotate Right f (No Carry) = . W REG, Rotate Right f (No Carry) = . W REG, Rotate Right f (No Carry) = ",
    "PIC18F6390/6490/8390/8490\nSETF, 1 = Set f. SETF, 2 = Set f. SETF, 3 = Set f. SETF, 4 = Set f. Syntax:, 1 = SETF f {,a}. Syntax:, 2 = SETF f {,a}. Syntax:, 3 = SETF f {,a}. Syntax:, 4 = SETF f {,a}. Operands:, 1 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 2 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 4 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, 1 = FFh \u2192 f. Operation:, 2 = FFh \u2192 f. Operation:, 3 = FFh \u2192 f. Operation:, 4 = FFh \u2192 f. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0110.",
    "PIC18F6390/6490/8390/8490\nEncoding:, 2 = 100a. Encoding:, 3 = ffff. Encoding:, 4 = ffff. Description:, 1 = The contents of the specified register are set to FFh. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.. Description:, 2 = The contents of the specified register are set to FFh. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.. Description:, 3 = The contents of the specified register are set to FFh. If GLYPH<145>aGLYPH<146> is",
    "PIC18F6390/6490/8390/8490\nGLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.. Description:, 4 = The contents of the specified register are set to FFh. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.. , 1 = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148>",
    "PIC18F6390/6490/8390/8490\nfor details.. , 2 = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. , 3 = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. , 4 = If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95",
    "PIC18F6390/6490/8390/8490\n(5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . Q1, 1 = Q2. Q1, 2 = Q2. Q1, 3 = Q3. Q1, 4 = Q4. Decode, 1 = Read register GLYPH<145>f GLYPH<146>. Decode, 2 = Read register GLYPH<145>f GLYPH<146>. Decode, 3 = Process Data. Decode, 4 = Write register GLYPH<145>f. Example:, 1 = SETF. Example:, 2 = .",
    "PIC18F6390/6490/8390/8490\nExample:, 3 = REG,1. Example:, 4 = . Before Instruction, 1 = Before Instruction. Before Instruction, 2 = . Before Instruction, 3 = . Before Instruction, 4 = . REG, 1 = =. REG, 2 = 5Ah. REG, 3 = . REG, 4 = . After Instruction REG =, 1 = After Instruction REG =. After Instruction REG =, 2 = FFh. After Instruction REG =, 3 = . After Instruction REG =, 4 = ",
    "PIC18F6390/6490/8390/8490\nSLEEP, 1 = SLEEP. SLEEP, 2 = Enter Sleep mode. SLEEP, 3 = Enter Sleep mode. SLEEP, 4 = Enter Sleep mode. Syntax:, 1 = Syntax:. Syntax:, 2 = SLEEP. Syntax:, 3 = SLEEP. Syntax:, 4 = SLEEP. Operands:, 1 = Operands:. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = Operation:. Operation:, 2 = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Operation:, 3 = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Operation:, 4 = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = TO, PD. Status Affected:, 3 = TO, PD. Status Affected:, 4 = TO, PD. Encoding:, 1 = Encoding:. Encoding:, 2 = 0000. Encoding:,",
    "PIC18F6390/6490/8390/8490\n3 = 0000. Encoding:, 4 = 0000. Description:, 1 = Description:. Description:, 2 = The Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared.. Description:, 3 = The Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared.. Description:, 4 = The Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = Q1. Q Cycle Activity:, 2 = Q2. Q Cycle Activity:, 3 = Q3. Q Cycle Activity:, 4 =",
    "PIC18F6390/6490/8390/8490\nQ3. , 1 = Decode. , 2 = No operation. , 3 = Process Data. , 4 = Process Data\nExample:\nSLEEP\nBefore Instruction\nTO\n=\n?\nPD\n=\n?\nAfter Instruction\nTO = 1 GLYPH<134>\nPD = 0\n- GLYPH<134>   If WDT causes wake-up, this bit is cleared.",
    "SUBFWB\nSyntax:, 1 = SUBFWB f {,d {,a}}. Syntax:, 2 = SUBFWB f {,d {,a}}. Syntax:, 3 = SUBFWB f {,d {,a}}. Syntax:, 4 = SUBFWB f {,d {,a}}. Operands:, 1 = 0 \u2264 f \u2264 255 \u2208. Operands:, 2 = 0 \u2264 f \u2264 255 \u2208. Operands:, 3 = 0 \u2264 f \u2264 255 \u2208. Operands:, 4 = 0 \u2264 f \u2264 255 \u2208. Operation:, 1 = (W) GLYPH<150> (f) GLYPH<150> (C) \u2192 dest. Operation:, 2 = (W) GLYPH<150> (f) GLYPH<150> (C) \u2192 dest. Operation:, 3 = (W) GLYPH<150> (f) GLYPH<150> (C) \u2192 dest. Operation:, 4 = (W) GLYPH<150> (f) GLYPH<150> (C) \u2192 dest. Status Affected:,",
    "SUBFWB\n1 = N, OV, C, DC, Z. Status Affected:, 2 = N, OV, C, DC, Z. Status Affected:, 3 = N, OV, C, DC, Z. Status Affected:, 4 = N, OV, C, DC, Z. Encoding:, 1 = 0101. Encoding:, 2 = 01da. Encoding:, 3 = ffff. Encoding:, 4 = ffff\nDescription:\nWords:\nCycles:",
    "Subtract f from W with Borrow\nSubtract register GLYPH<145>fGLYPH<146> and Carry flag (borrow) from W (2GLYPH<146>s complement method). If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146> ,  the  result is stored in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the result is stored in register GLYPH<145>fGLYPH<146> (default).\nIf GLYPH<145>aGLYPH<146>  is  GLYPH<145> 0 GLYPH<146> ,  the  Access Bank is selected. If GLYPH<145>aGLYPH<146>  is  GLYPH<145> 1 GLYPH<146> ,  the  BSR is used to select the GPR bank.",
    "Subtract f from W with Borrow\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>  and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\n1\n1\nQ Cycle Activity:",
    "PIC18F6390/6490/8390/8490\nSyntax:, Subtract Wfrom Literal = SUBLW k. Syntax:, Subtract Wfrom Literal = SUBLW k. Syntax:, Subtract Wfrom Literal = SUBLW k. Syntax:, Subtract Wfrom Literal = SUBLW k. Operands:, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operands:, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operands:, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operands:, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operation:, Subtract Wfrom Literal = k GLYPH<150> (W) \u2192 W. Operation:, Subtract Wfrom Literal = k GLYPH<150> (W) \u2192 W. Operation:, Subtract Wfrom Literal = k GLYPH<150> (W) \u2192 W. Operation:, Subtract Wfrom Literal = k GLYPH<150> (W) \u2192 W. Status Affected:, Subtract",
    "PIC18F6390/6490/8390/8490\nWfrom Literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Encoding:, Subtract Wfrom Literal = 0000 1000 kkkk. Encoding:, Subtract Wfrom Literal = 0000 1000 kkkk. Encoding:, Subtract Wfrom Literal = 0000 1000 kkkk. Encoding:, Subtract Wfrom Literal = kkkk. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal GLYPH<145> kGLYPH<146>. The result is placed in W.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal GLYPH<145> kGLYPH<146>. The result is placed in W.. Description:,",
    "PIC18F6390/6490/8390/8490\nSubtract Wfrom Literal = Wis subtracted from the eight-bit literal GLYPH<145> kGLYPH<146>. The result is placed in W.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal GLYPH<145> kGLYPH<146>. The result is placed in W.. Words:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Q1, Subtract Wfrom Literal = Q2. Q1, Subtract Wfrom Literal = Q2. Q1, Subtract Wfrom Literal = Q4. Q1, Subtract Wfrom Literal = Q4.",
    "PIC18F6390/6490/8390/8490\nDecode, Subtract Wfrom Literal = Read literal GLYPH<145>kGLYPH<146>. Decode, Subtract Wfrom Literal = Process Data. Decode, Subtract Wfrom Literal = Write to W. Decode, Subtract Wfrom Literal = Write to W. Example 1:, Subtract Wfrom Literal = SUBLW 02h. Example 1:, Subtract Wfrom Literal = SUBLW 02h. Example 1:, Subtract Wfrom Literal = . Example 1:, Subtract Wfrom Literal = . Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. W C, Subtract Wfrom Literal = 01h ?. W C, Subtract Wfrom Literal = 01h ?. W C, Subtract Wfrom Literal = . W C, Subtract Wfrom Literal =",
    "PIC18F6390/6490/8390/8490\n. After Instruction, Subtract Wfrom Literal = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. W, Subtract Wfrom Literal = 01h. W, Subtract Wfrom Literal = 01h. W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . Z, Subtract Wfrom Literal = 1 ; 0. Z, Subtract Wfrom Literal = result is positive. Z, Subtract Wfrom Literal = result is positive. Z, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = 0. N, Subtract Wfrom Literal = 0. N, Subtract Wfrom Literal = . N,",
    "PIC18F6390/6490/8390/8490\nSubtract Wfrom Literal = . Example 2:, Subtract Wfrom Literal = SUBLW. Example 2:, Subtract Wfrom Literal = 02h. Example 2:, Subtract Wfrom Literal = 02h. Example 2:, Subtract Wfrom Literal = . Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. C, Subtract Wfrom Literal = 02h ?. C, Subtract Wfrom Literal = 02h ?. C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . = After Instruction =, Subtract Wfrom Literal = = After Instruction =. = After Instruction =, Subtract Wfrom Literal = = After Instruction =. = After Instruction =, Subtract Wfrom Literal = = After Instruction =. = After Instruction =, Subtract Wfrom Literal =",
    "PIC18F6390/6490/8390/8490\n= After Instruction =. W, Subtract Wfrom Literal = 00h. W, Subtract Wfrom Literal = 00h. W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = 1. C, Subtract Wfrom Literal = ; result is zero. C, Subtract Wfrom Literal = ; result is zero. C, Subtract Wfrom Literal = . Z N, Subtract Wfrom Literal = 1 0. Z N, Subtract Wfrom Literal = 1 0. Z N, Subtract Wfrom Literal = . Z N, Subtract Wfrom Literal = . 3:, Subtract Wfrom Literal = . 3:, Subtract Wfrom Literal = . 3:, Subtract Wfrom Literal = . 3:, Subtract Wfrom Literal = . Example SUBLW 02h, Subtract Wfrom Literal = Example SUBLW 02h. Example SUBLW 02h, Subtract Wfrom",
    "PIC18F6390/6490/8390/8490\nLiteral = Example SUBLW 02h. Example SUBLW 02h, Subtract Wfrom Literal = Example SUBLW 02h. Example SUBLW 02h, Subtract Wfrom Literal = Example SUBLW 02h. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. W, Subtract Wfrom Literal = 03h ?. W, Subtract Wfrom Literal = 03h ?. W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . C = After Instruction, Subtract Wfrom Literal = C = After Instruction. C = After Instruction, Subtract Wfrom Literal = C = After Instruction. C = After Instruction, Subtract Wfrom Literal = C = After Instruction. C = After Instruction, Subtract Wfrom Literal = C = After Instruction. W, Subtract Wfrom Literal =",
    "PIC18F6390/6490/8390/8490\n= FFh; (2GLYPH<146>s complement) =. W, Subtract Wfrom Literal = = FFh; (2GLYPH<146>s complement) =. W, Subtract Wfrom Literal = = FFh; (2GLYPH<146>s complement) =. W, Subtract Wfrom Literal = = FFh; (2GLYPH<146>s complement) =. C, Subtract Wfrom Literal = 0 ; result is negative. C, Subtract Wfrom Literal = 0 ; result is negative. C, Subtract Wfrom Literal = 0 ; result is negative. C, Subtract Wfrom Literal = 0 ; result is negative. Z, Subtract Wfrom Literal = 0 1. Z, Subtract Wfrom Literal = 0 1. Z, Subtract Wfrom Literal = 0 1. Z, Subtract Wfrom Literal = 0 1. N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal",
    "PIC18F6390/6490/8390/8490\n= . N, Subtract Wfrom Literal = . , Subtract Wfrom Literal = =. , Subtract Wfrom Literal = =. , Subtract Wfrom Literal = =. , Subtract Wfrom Literal = =",
    "PIC18F6390/6490/8390/8490\nSyntax:, Subtract = SUBWF f {,d {,a}}. Syntax:, Wfrom f = . Syntax:,  = . Syntax:,  = . Syntax:,  = . Operands:, Subtract = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Wfrom f = . Operands:,  = . Operands:,  = . Operands:,  = . Operation:, Subtract = (f) GLYPH<150> (W) \u2192 dest. Operation:, Wfrom f = . Operation:,  = . Operation:,  = . Operation:,  = . Status Affected:, Subtract = N, OV, C, DC, Z. Status Affected:, Wfrom f = . Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Encoding:, Subtract = 0101. Encoding:, Wfrom f = 11da. Encoding:,  = ffff. Encoding:,  = ffff. Encoding:,",
    "PIC18F6390/6490/8390/8490\n= . Q Cycle Activity: Q1 Decode, Subtract = Q2 Read register GLYPH<145>f GLYPH<146>. Q Cycle Activity: Q1 Decode, Wfrom f = . Q Cycle Activity: Q1 Decode,  = Q3. Q Cycle Activity: Q1 Decode,  = Q4. Q Cycle Activity: Q1 Decode,  = . Example 1:, Subtract = . Example 1:, Wfrom f = Data. Example 1:,  = Process. Example 1:,  = Write to destination. Example 1:,  = . , Subtract = SUBWF. , Wfrom f = REG,. ,  = 1, 0. ,  = . ,  = . Before, Subtract = . Before, Wfrom f = . Before,  = . Before,  = . Before,  = Instruction. REG W C, Subtract = = = =. REG W C, Wfrom f = . REG W C,  = is. REG W C,  = 3 2 ?. REG W C,",
    "PIC18F6390/6490/8390/8490\n= . After Instruction REG, Subtract = =. After Instruction REG, Wfrom f = 1 2. After Instruction REG,  = . After Instruction REG,  = . After Instruction REG,  = . W C, Subtract = = = = =. W C, Wfrom f = 1. W C,  = positive. W C,  = ; result 0. W C,  = . N 2:, Subtract = . N 2:, Wfrom f = 0. N 2:,  = . N 2:,  = . N 2:,  = . Example, Subtract = . Example, Wfrom f = ?. Example,  = 0,. Example,  = SUBWF. Example,  = . Before Instruction REG W C, Subtract = = =. Before Instruction REG W C, Wfrom f = 2 2. Before Instruction REG W C,  = 0. Before Instruction REG W C,  = . Before Instruction REG W C,  = . Z N, Subtract = . Z N, Wfrom f = . Z N,  = . Z N,  = REG,. Z N,",
    "PIC18F6390/6490/8390/8490\n= . Before Instruction REG, Subtract = = =. Before Instruction REG, Wfrom f = . Before Instruction REG,  = . Before Instruction REG,  = . Before Instruction REG,  = . W C, Subtract = =. W C, Wfrom f = . W C,  = . W C,  = . W C,  = . After, Subtract = . After, Wfrom f = . After,  = . After,  = . After,  = . Instruction REG, Subtract = = = =. Instruction REG, Wfrom f = 2. Instruction REG,  = . Instruction REG,  = . Instruction REG,  = . W C, Subtract = =. W C, Wfrom f = 1. W C,  = . W C,  = 0 1 ; result. W C,  = . Z N, Subtract = . Z N, Wfrom f = 0. Z N,  = . Z N,  = . Z N,  = . 3:, Subtract = . 3:, Wfrom f = . 3:,  = . 3:,  = . 3:,",
    "PIC18F6390/6490/8390/8490\n= . , Subtract = =. , Wfrom f = . ,  = is zero. ,  = SUBWF. ,  = . Example, Subtract = . Example, Wfrom f = . Example,  = . Example,  = . Example,  = . , Subtract = . , Wfrom f = . ,  = 1, 0. ,  = REG,. ,  = . , Subtract = = = =. , Wfrom f = ?. ,  = . ,  = 1 2. ,  = . After Instruction REG, Subtract = = =. After Instruction REG, Wfrom f = FFh. After Instruction REG,  = complement). After Instruction REG,  = . After Instruction REG,  = . W C, Subtract = . W C, Wfrom f = 0. W C,  = is. W C,  = ;(2GLYPH<146>s 2 ; result 0. W C,  = . , Subtract = . , Wfrom f = . ,  = . ,  = 1. ,  = . , Subtract = . , Wfrom f = . ,",
    "PIC18F6390/6490/8390/8490\n= negative. ,  = . ,  = . , Subtract = =. , Wfrom f = . ,  = . ,  = . ,  = ",
    "Subtract W from f with Borrow\nSyntax:\nSUBWFB    f {,d {,a}}\nOperands:\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\nOperation:\n(f) GLYPH<150> (W) GLYPH<150> (C) \u2192 dest\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0101\n10da\nffff\nffff\nDescription:\nSubtract W and the Carry flag (borrow) from register GLYPH<145>fGLYPH<146> (2GLYPH<146>s complement method). If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is stored in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>,  the result is stored back in register GLYPH<145>fGLYPH<146> (default).",
    "Subtract W from f with Borrow\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:",
    "Subtract W from f with Borrow\nSUBWFB,  = SUBWFB. SUBWFB, Q2 Read. = . SUBWFB, Q3 Process Data.0 = REG, 1,. SUBWFB,  = . Before Instruction,  = Before Instruction. Before Instruction, Q2 Read. = . Before Instruction, Q3 Process Data.0 = . Before Instruction,  = . REG,  = =. REG, Q2 Read. = 19h. REG, Q3 Process Data.0 = (0001 1001). REG,  = . W,  = =. W, Q2 Read. = 0Dh. W, Q3 Process Data.0 = (0000 1101). W,  = . C,  = =. C, Q2 Read. = 1. C, Q3 Process Data.0 = . C,  = . After Instruction,  = After Instruction. After Instruction, Q2 Read. = . After Instruction, Q3 Process Data.0 = . After Instruction,  = . REG,  = =. REG, Q2 Read. = 0Ch. REG, Q3 Process Data.0 = (0000. REG,  = . W,",
    "Subtract W from f with Borrow\n= =. W, Q2 Read. = 0Dh. W, Q3 Process Data.0 = (0000. W,  = . C,  = =. C, Q2 Read. = 1. C, Q3 Process Data.0 = 1101). C,  = . Z,  = =. Z, Q2 Read. = 0. Z, Q3 Process Data.0 = . Z,  = . N,  = =. N, Q2 Read. = 0. N, Q3 Process Data.0 = ; result is positive. N,  = ; result is positive. Example 2: SUBWFB,  = Example 2: SUBWFB. Example 2: SUBWFB, Q2 Read. = Example 2: SUBWFB. Example 2: SUBWFB, Q3 Process Data.0 = REG, 0,. Example 2: SUBWFB,  = . Before Instruction,  = Before Instruction. Before Instruction, Q2 Read. = . Before Instruction, Q3 Process Data.0 = . Before Instruction,  = . REG,",
    "Subtract W from f with Borrow\n= =. REG, Q2 Read. = 1Bh. REG, Q3 Process Data.0 = (0001. REG,  = . W,  = =. W, Q2 Read. = 1Ah. W, Q3 Process Data.0 = (0001. W,  = . C,  = =. C, Q2 Read. = 0. C, Q3 Process Data.0 = 1010). C,  = . After Instruction,  = After Instruction. After Instruction, Q2 Read. = . After Instruction, Q3 Process Data.0 = . After Instruction,  = . REG,  = =. REG, Q2 Read. = 1Bh. REG, Q3 Process Data.0 = (0001 1011). REG,  = . W,  = =. W, Q2 Read. = 00h. W, Q3 Process Data.0 = . W,  = . C,  = =. C, Q2 Read. = 1. C, Q3 Process Data.0 = . C,  = . Z,  = =. Z, Q2 Read. = 1. Z, Q3 Process Data.0 = ; result is zero. Z,",
    "Subtract W from f with Borrow\n= . N,  = =. N, Q2 Read. = 0. N, Q3 Process Data.0 = . N,  = . Example 3: SUBWFB,  = Example 3: SUBWFB. Example 3: SUBWFB, Q2 Read. = Example 3: SUBWFB. Example 3: SUBWFB, Q3 Process Data.0 = REG, 1,. Example 3: SUBWFB,  = . Before Instruction,  = Before Instruction. Before Instruction, Q2 Read. = Before Instruction. Before Instruction, Q3 Process Data.0 = . Before Instruction,  = . REG,  = =. REG, Q2 Read. = 03h. REG, Q3 Process Data.0 = (0000 0011). REG,  = . W,  = =. W, Q2 Read. = 0Eh. W, Q3 Process Data.0 = (0000 1101). W,  = . C,  = =. C, Q2 Read. = 1. C, Q3 Process Data.0 = . C,  = . After Instruction,",
    "Subtract W from f with Borrow\n= After Instruction. After Instruction, Q2 Read. = After Instruction. After Instruction, Q3 Process Data.0 = . After Instruction,  = . REG,  = =. REG, Q2 Read. = F5h. REG, Q3 Process Data.0 = (1111 0100) ; [2GLYPH<146>s comp]. REG,  = . W,  = =. W, Q2 Read. = 0Eh. W, Q3 Process Data.0 = (0000 1101). W,  = . C,  = =. C, Q2 Read. = 0. C, Q3 Process Data.0 = . C,  = . Z,  = =. Z, Q2 Read. = 0. Z, Q3 Process Data.0 = . Z,  = . N,  = =. N, Q2 Read. = 1. N, Q3 Process Data.0 = ; result is negative. N,  = ; result is negative",
    "Subtract W from f with Borrow\nSyntax:, Swap f = SWAPF f {,d {,a}}. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operation:, Swap f = (f<3:0>) \u2192 dest<7:4>, (f<7:4>) \u2192 dest<3:0>\nStatus Affected:\nNone\nEncoding:\nDescription:\nWords:\nCycles:\n0011\n10da\nffff\nffff\nThe upper and lower nibbles of register GLYPH<145> f GLYPH<146> are exchanged. If GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the result is placed in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146> , the result is placed in register GLYPH<145>fGLYPH<146> (default).",
    "Subtract W from f with Borrow\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "Example:\nSWAPF\nREG, 1, 0\nBefore Instruction\nREG\n=\n53h\nAfter Instruction\nREG\n=\n35h",
    "PIC18F6390/6490/8390/8490\nTBLRD, 1 = TBLRD. TBLRD, 2 = Table Read. TBLRD, 3 = Table Read. TBLRD, 4 = Table Read. Syntax:, 1 = Syntax:. Syntax:, 2 = TBLRD ( *; *+; *-; +*). Syntax:, 3 = TBLRD ( *; *+; *-; +*). Syntax:, 4 = TBLRD ( *; *+; *-; +*). Operands:, 1 = Operands:. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = Operation:. Operation:, 2 = if TBLRD *, (Prog Mem (TBLPTR)) \u2192 TABLAT, TBLPTR GLYPH<150> No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192 TABLAT, (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \u2192",
    "PIC18F6390/6490/8390/8490\nTABLAT, (TBLPTR) GLYPH<150> 1 \u2192 TBLPTR; if TBLRD +*,. Operation:, 3 = if TBLRD *, (Prog Mem (TBLPTR)) \u2192 TABLAT, TBLPTR GLYPH<150> No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192 TABLAT, (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \u2192 TABLAT, (TBLPTR) GLYPH<150> 1 \u2192 TBLPTR; if TBLRD +*,. Operation:, 4 = if TBLRD *, (Prog Mem (TBLPTR)) \u2192 TABLAT, TBLPTR GLYPH<150> No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192 TABLAT, (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \u2192 TABLAT,",
    "PIC18F6390/6490/8390/8490\n(TBLPTR) GLYPH<150> 1 \u2192 TBLPTR; if TBLRD +*,. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Encoding:, 4 = 0000. Description:, 1 = Description:. Description:, 2 = =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer, called Table Pointer (TBLPTR), is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR<0> = 0 : Least Significant Byte of Program Memory Word TBLPTR<0> = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: GLYPH<149> no change GLYPH<149>",
    "PIC18F6390/6490/8390/8490\npost-increment GLYPH<149> post-decrement GLYPH<149> pre-increment. Description:, 3 = =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer, called Table Pointer (TBLPTR), is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR<0> = 0 : Least Significant Byte of Program Memory Word TBLPTR<0> = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: GLYPH<149> no change GLYPH<149> post-increment GLYPH<149> post-decrement GLYPH<149> pre-increment. Description:, 4 = =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer, called Table Pointer",
    "PIC18F6390/6490/8390/8490\n(TBLPTR), is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR<0> = 0 : Least Significant Byte of Program Memory Word TBLPTR<0> = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: GLYPH<149> no change GLYPH<149> post-increment GLYPH<149> post-decrement GLYPH<149> pre-increment. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 2. Cycles:, 3 = 2. Cycles:, 4 = 2. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 =",
    "PIC18F6390/6490/8390/8490\nQ1. , 2 = Q2. , 3 = Q3. , 4 = Q3. , 1 = Decode. , 2 = No operation. , 3 = No operation. , 4 = No operation. , 1 = No operation. , 2 = No operation (Read Program Memory). , 3 = No operation. , 4 = No operation",
    "TBLRD Table Read (Continued)\nExample 1:, 1 = TBLRD. Example 1:, 2 = ;. Example 1:, 3 = . Before Instruction, 1 = Before Instruction. Before Instruction, 2 = =. Before Instruction, 3 = 55h. TABLAT TBLPTR, 1 = TABLAT TBLPTR. TABLAT TBLPTR, 2 = =. TABLAT TBLPTR, 3 = 00A356h. MEMORY(00A356h), 1 = MEMORY(00A356h). MEMORY(00A356h), 2 = =. MEMORY(00A356h), 3 = 34h. After Instruction TABLAT, 1 = After Instruction TABLAT. After Instruction TABLAT, 2 = =. After Instruction TABLAT, 3 = 34h. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 00A357h. Example 2:, 1 = TBLRD +*. Example 2:, 2 = ;. Example 2:, 3 = . Before Instruction TABLAT, 1 = Before Instruction TABLAT. Before Instruction TABLAT, 2 = =. Before Instruction TABLAT, 3",
    "TBLRD Table Read (Continued)\n= 0AAh. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 01A357h. MEMORY(01A357h), 1 = MEMORY(01A357h). MEMORY(01A357h), 2 = =. MEMORY(01A357h), 3 = 12h. MEMORY(01A358h), 1 = MEMORY(01A358h). MEMORY(01A358h), 2 = =. MEMORY(01A358h), 3 = 34h. After Instruction TABLAT, 1 = After Instruction TABLAT. After Instruction TABLAT, 2 = =. After Instruction TABLAT, 3 = 34h. TBLPTR, 1 = TBLPTR. TBLPTR, 2 = =. TBLPTR, 3 = 01A358h",
    "TBLWT\nTable Write\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nQ Cycle Activity:\nTBLWT ( *; *+; *-; +*)\nNone if TBLWT*,\n(TABLAT)\n\u2192\nHolding Register,\nTBLPTR GLYPH<150> No Change;\nif TBLWT*+,\n(TABLAT)\n\u2192\nHolding Register,\n(TBLPTR) + 1\n\u2192\nTBLPTR;\nif TBLWT*-,\n(TABLAT)\n\u2192\nHolding Register,\n(TBLPTR) GLYPH<150> 1\n\u2192\nTBLPTR;\nif TBLWT+*,\n(TBLPTR) + 1\n\u2192\nTBLPTR,\n(TABLAT)\n\u2192\nHolding Register\nNone\n0000",
    "TBLWT\nExample 1:, Table Write = TBLWT *+;. Example 1:, (Continued) = TBLWT *+;. Example 1:, (Continued) = TBLWT *+;. Before Instruction, Table Write = Before Instruction. Before Instruction, (Continued) = . Before Instruction, (Continued) = . TABLAT, Table Write = TABLAT. TABLAT, (Continued) = =. TABLAT, (Continued) = 55h. TBLPTR, Table Write = TBLPTR. TBLPTR, (Continued) = =. TBLPTR, (Continued) = 00A356h. HOLDING REGISTER (00A356h), Table Write = HOLDING REGISTER (00A356h). HOLDING REGISTER (00A356h), (Continued) = =. HOLDING REGISTER (00A356h), (Continued) = FFh. After Instructions (table write completion), Table Write = After Instructions (table write completion). After Instructions (table write completion), (Continued) = After Instructions (table write completion). After Instructions (table write completion), (Continued) = After Instructions (table write completion). TABLAT, Table Write =",
    "TBLWT\nTABLAT. TABLAT, (Continued) = =. TABLAT, (Continued) = 55h. TBLPTR, Table Write = TBLPTR. TBLPTR, (Continued) = =. TBLPTR, (Continued) = 00A357h. HOLDING REGISTER (00A356h), Table Write = HOLDING REGISTER (00A356h). HOLDING REGISTER (00A356h), (Continued) = =. HOLDING REGISTER (00A356h), (Continued) = 55h. Example 2:, Table Write = TBLWT +*;. Example 2:, (Continued) = TBLWT +*;. Example 2:, (Continued) = TBLWT +*;. Before Instruction, Table Write = Before Instruction. Before Instruction, (Continued) = . Before Instruction, (Continued) = . TABLAT, Table Write = TABLAT. TABLAT, (Continued) = =. TABLAT, (Continued) = 34h. TBLPTR, Table Write = TBLPTR. TBLPTR, (Continued) = =. TBLPTR, (Continued) = 01389Ah. HOLDING REGISTER (01389Ah),",
    "TBLWT\nTable Write = HOLDING REGISTER (01389Ah). HOLDING REGISTER (01389Ah), (Continued) = =. HOLDING REGISTER (01389Ah), (Continued) = FFh. HOLDING REGISTER (01389Bh), Table Write = HOLDING REGISTER (01389Bh). HOLDING REGISTER (01389Bh), (Continued) = =. HOLDING REGISTER (01389Bh), (Continued) = FFh. After Instruction (table write completion), Table Write = After Instruction (table write completion). After Instruction (table write completion), (Continued) = After Instruction (table write completion). After Instruction (table write completion), (Continued) = After Instruction (table write completion). TABLAT, Table Write = TABLAT. TABLAT, (Continued) = =. TABLAT, (Continued) = 34h. TBLPTR, Table Write = TBLPTR. TBLPTR, (Continued) = =. TBLPTR, (Continued) = 01389Bh. HOLDING REGISTER (01389Ah), Table Write = HOLDING REGISTER (01389Ah). HOLDING REGISTER (01389Ah), (Continued) = =. HOLDING",
    "TBLWT\nREGISTER (01389Ah), (Continued) = FFh. HOLDING REGISTER (01389Bh), Table Write = HOLDING REGISTER (01389Bh). HOLDING REGISTER (01389Bh), (Continued) = =. HOLDING REGISTER (01389Bh), (Continued) = 34h\n11nn nn=0 *\n=1 *+\n=2 *-\n=3 +*\nThis instruction uses the 3 LSBs of the\nTBLPTR to determine which of the\n8 holding registers the TABLAT is written to.\nThe holding registers are used to program the contents of Program Memory (P.M.).\n(Refer to\nSection 6.0 GLYPH<147>Flash Program\nMemoryGLYPH<148>\nfor additional details on programming Flash memory.)\nThe TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MBtye address range. The LSb of the TBLPTR selects which byte of the program memory location to access.\nTBLPTR<0> = 0 :\nLeast Significant Byte of Program Memory Word\nTBLPTR<0> = 1 :\nMost Significant Byte of Program Memory Word",
    "TBLWT\nThe TBLWT instruction can modify the value of TBLPTR as follows:\nGLYPH<149> no change\nGLYPH<149> post-increment\nGLYPH<149> post-decrement\nGLYPH<149> pre-increment\n1\n2\nQ1\nDecode",
    "Note:\nThe  table  write  ( TBLWT )  instructions  are not available in user mode in PIC18F6X90/8X90 devices, as these devices are standard Flash parts without an external bus interface.\n0000\nQ2\nQ3\nNo\nNo operation operation\nNo\nNo\nNo operation operation operation\n(Read\nTABLAT)\n0000\nQ4\nNo operation\nNo operation\n(Write to\nHolding\nRegister )",
    "PIC18F6390/6490/8390/8490\nSyntax:, Test f, Skip if 0 = TSTFSZ f {,a}. Syntax:, Test f, Skip if 0 = TSTFSZ f {,a}. Syntax:, Test f, Skip if 0 = TSTFSZ f {,a}. Syntax:, Test f, Skip if 0 = TSTFSZ f {,a}. Operands:, Test f, Skip if 0 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Test f, Skip if 0 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Test f, Skip if 0 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Test f, Skip if 0 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Test f, Skip if 0 = skip if f = 0. Operation:, Test f, Skip if 0 = skip if f = 0. Operation:, Test f, Skip if 0 = skip if f = 0. Operation:, Test f, Skip if 0 = skip if f = 0. Status Affected:, Test",
    "PIC18F6390/6490/8390/8490\nf, Skip if 0 = None. Status Affected:, Test f, Skip if 0 = None. Status Affected:, Test f, Skip if 0 = None. Status Affected:, Test f, Skip if 0 = None. Encoding:, Test f, Skip if 0 = 0110. Encoding:, Test f, Skip if 0 = 011a. Encoding:, Test f, Skip if 0 = ffff. Encoding:, Test f, Skip if 0 = ffff. Description:, Test f, Skip if 0 = If GLYPH<145>f GLYPH<146> = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146>",
    "PIC18F6390/6490/8390/8490\nis GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See. Description:, Test f, Skip if 0 = If GLYPH<145>f GLYPH<146> = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See. Description:, Test f, Skip if 0 = If",
    "PIC18F6390/6490/8390/8490\nGLYPH<145>f GLYPH<146> = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See. Description:, Test f, Skip if 0 = If GLYPH<145>f GLYPH<146> = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If GLYPH<145>aGLYPH<146> is",
    "PIC18F6390/6490/8390/8490\nGLYPH<145> 0 GLYPH<146> , the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank. If GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146> and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See. Words:, Test f, Skip if 0 = 1. Words:, Test f, Skip if 0 = 1. Words:, Test f, Skip if 0 = 1. Words:, Test f, Skip if 0 = 1. Cycles:, Test f, Skip if 0 = 1(2). Cycles:, Test f, Skip if 0 = 1(2). Cycles:, Test f, Skip if 0 = 1(2). Cycles:, Test f, Skip if 0 = 1(2)",
    "PIC18F6390/6490/8390/8490\nSyntax:, Exclusive OR Literal with W = XORLW k. Syntax:, Exclusive OR Literal with W = XORLW k. Syntax:, Exclusive OR Literal with W = XORLW k. Operands:, Exclusive OR Literal with W = 0 \u2264 k \u2264 255. Operands:, Exclusive OR Literal with W = 0 \u2264 k \u2264 255. Operands:, Exclusive OR Literal with W = 0 \u2264 k \u2264 255. Operation:, Exclusive OR Literal with W = (W) .XOR. k \u2192 W. Operation:, Exclusive OR Literal with W = (W) .XOR. k \u2192 W. Operation:, Exclusive OR Literal with W = (W) .XOR. k \u2192 W. Status Affected:, Exclusive OR Literal with W = N, Z. Status Affected:, Exclusive OR Literal with W = N, Z. Status Affected:, Exclusive OR Literal with W = N, Z. Encoding:, Exclusive OR Literal with W = 0000. Encoding:, Exclusive OR Literal with W = 1010. Encoding:, Exclusive OR Literal with W = kkkk kkkk. Description:, Exclusive OR Literal",
    "PIC18F6390/6490/8390/8490\nwith W = The contents of Ware XORed with the 8-bit literal GLYPH<145>kGLYPH<146>. The result is placed in W.. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal GLYPH<145>kGLYPH<146>. The result is placed in W.. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal GLYPH<145>kGLYPH<146>. The result is placed in W.. Words:, Exclusive OR Literal with W = 1. Words:, Exclusive OR Literal with W = 1. Words:, Exclusive OR Literal with W = 1. Cycles:, Exclusive OR Literal with W = 1. Cycles:, Exclusive OR Literal with W = 1. Cycles:, Exclusive OR Literal with W = 1. Q Cycle Activity:, Exclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Exclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Exclusive OR Literal with W = Q Cycle Activity:. Q1, Exclusive OR Literal with",
    "PIC18F6390/6490/8390/8490\nW = Q2. Q1, Exclusive OR Literal with W = Q3. Q1, Exclusive OR Literal with W = Q4. Decode, Exclusive OR Literal with W = Read literal GLYPH<145>kGLYPH<146>. Decode, Exclusive OR Literal with W = Process Data. Decode, Exclusive OR Literal with W = Write to W. Example:, Exclusive OR Literal with W = XORLW. Example:, Exclusive OR Literal with W = 0AFh. Example:, Exclusive OR Literal with W = . Before Instruction W =, Exclusive OR Literal with W = B5h. Before Instruction W =, Exclusive OR Literal with W = . Before Instruction W =, Exclusive OR Literal with W = . After Instruction W =, Exclusive OR Literal with W = 1Ah. After Instruction W =, Exclusive OR Literal with W = . After Instruction W =, Exclusive OR Literal with W = \nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = No operation. skip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No",
    "Q Cycle Activity:\noperation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE    TSTFSZ  CNT, 1\nNZERO   :\nZERO    :\nAfter Instruction, = = . After Instruction, Address = . After Instruction, (HERE) = . If CNT, = = =. If CNT, Address = 00h,. If CNT, (HERE) = . PC, = = =. PC, Address = Address. PC, (HERE) = (ZERO). If CNT, = = \u2260. If CNT, Address = 00h,. If CNT, (HERE) = . PC, = = =. PC, Address = Address. PC, (HERE) = (NZERO)",
    "Exclusive OR W with f\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nXORWF     f {,d {,a}}\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\n(W) .XOR. (f) \u2192 dest\nN, Z\n0001\n10da ffff\nffff\nExclusive OR the contents of W with register GLYPH<145>fGLYPH<146>. If GLYPH<145>dGLYPH<146>  is GLYPH<145> 0 GLYPH<146>,  the result is stored in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146>,  the  result is stored back in the register GLYPH<145>fGLYPH<146> (default).",
    "Exclusive OR W with f\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>, the Access Bank is selected. If GLYPH<145>aGLYPH<146> is GLYPH<145> 1 GLYPH<146>, the BSR is used to select the GPR bank.\nIf GLYPH<145>aGLYPH<146> is GLYPH<145> 0 GLYPH<146>  and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 24.2.3 GLYPH<147>Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset ModeGLYPH<148> for details.\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>f GLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "Example:\nXORWF   REG, 1, 0\nBefore Instruction\nREG\n=\nW\n=\nAfter Instruction\nREG\n=\nW\n=\nAFh\nB5h\n1Ah\nB5h",
    "24.2 Extended Instruction Set\nIn addition to the standard 75 instructions of the PIC18 instruction set, PIC18FXX90 devices also provide an optional extension to the core CPU functionality. The added features include eight additional instructions that augment Indirect and Indexed Addressing operations and  the implementation  of Indexed  Literal Offset Addressing  mode  for  many  of  the  standard  PIC18 instructions.\nThe  additional  features  are  disabled  by  default.  To enable them, users must set the XINST Configuration bit.\nThe  instructions in the extended  set  can  all be classified as literal operations, which either manipulate the  File  Select  Registers  or  use  them  for  Indexed Addressing.  Two  of  the  instructions, ADDFSR and SUBFSR , each have an additional special instantiation for using FSR2. These versions ( ADDULNK and SUBULNK ) allow for automatic return after execution.\nThe extended instructions are specifically implemented to optimize re-entrant program code (that is, code that is  recursive  or  that  uses  a  software  stack)  written  in high-level languages,  particularly C. Among  other things, they allow users working in high-level languages  to perform  certain operations on  data structures more efficiently. These include:",
    "24.2 Extended Instruction Set\nGLYPH<149> dynamic allocation and deallocation of software stack space when entering and leaving subroutines\nGLYPH<149> Function Pointer invocation\nGLYPH<149> Software Stack Pointer manipulation\nA summary of the instructions in the extended instruction set is provided in Table 24-3. Detailed descriptions are provided in Section 24.2.2 GLYPH<147>Extended Instruction SetGLYPH<148> . The opcode field descriptions in Table 24-1 apply to  both the standard and extended PIC18 instruction sets.\nNote:\nThe  instruction set extension  and  the Indexed  Literal  Offset  Addressing  mode were designed for optimizing applications written in C; the user may likely never use these  instructions  directly  in  assembler. The  syntax  for  these  commands  is  provided as a reference for users who may be reviewing  code that  has  been  generated by a compiler.",
    "24.2.1 EXTENDED INSTRUCTION SYNTAX\nMost  of  the  extended  instructions  use  indexed  arguments, using one of the File Select Registers and some offset to specify a source or destination register. When an  argument  for  an  instruction  serves  as  part  of Indexed Addressing, it is enclosed in square brackets (GLYPH<147>[  ]GLYPH<148>).  This  is done to indicate that the argument is used as an index or offset. MPASMGLYPH<153> Assembler will flag an error if it determines that an index or offset value is not bracketed.\nWhen the extended instruction set is enabled, brackets are  also  used  to  indicate  index  arguments  in  byteoriented and bit-oriented instructions. This is in addition to other changes in their syntax. For more details, see Section 24.2.3.1 GLYPH<147>Extended Instruction Syntax with Standard PIC18 CommandsGLYPH<148> .\n- GLYPH<149> manipulation of variables located in a software stack\nNote:\nIn  the  past,  square  brackets  have  been used to denote optional arguments in the PIC18 and earlier instruction  sets.  In  this text and going forward, optional arguments are denoted by braces (GLYPH<147>{ }GLYPH<148>).",
    "TABLE 24-3: EXTENSIONS TO THE PIC18 INSTRUCTION SET\nADDFSR, Mnemonic,.Operands = f, k. ADDFSR, Description. = Add Literal to FSR. ADDFSR, Cycles. = 1. ADDFSR, 16-Bit Instruction Word.MSb = 1110. ADDFSR, 16-Bit Instruction Word.MSb = 1000. ADDFSR, 16-Bit Instruction Word.LSb = ffkk. ADDFSR, 16-Bit Instruction Word. = kkkk. ADDFSR, Status Affected. = None. ADDULNK, Mnemonic,.Operands = k. ADDULNK, Description. = Add Literal to FSR2 and Return. ADDULNK, Cycles. = 2. ADDULNK, 16-Bit Instruction Word.MSb = 1110. ADDULNK, 16-Bit Instruction Word.MSb = 1000. ADDULNK, 16-Bit Instruction Word.LSb = 11kk. ADDULNK, 16-Bit Instruction Word. = kkkk. ADDULNK, Status Affected. = None. CALLW, Mnemonic,.Operands = . CALLW, Description. = Call Subroutine using",
    "TABLE 24-3: EXTENSIONS TO THE PIC18 INSTRUCTION SET\nWREG. CALLW, Cycles. = 2. CALLW, 16-Bit Instruction Word.MSb = 0000. CALLW, 16-Bit Instruction Word.MSb = 0000. CALLW, 16-Bit Instruction Word.LSb = 0001. CALLW, 16-Bit Instruction Word. = 0100. CALLW, Status Affected. = None. MOVSF, Mnemonic,.Operands = z s , f d. MOVSF, Description. = Move z s (source) to 1st word f d (destination) 2nd word. MOVSF, Cycles. = 2. MOVSF, 16-Bit Instruction Word.MSb = 1110. MOVSF, 16-Bit Instruction Word.MSb = 1011. MOVSF, 16-Bit Instruction Word.LSb = 0zzz. MOVSF, 16-Bit Instruction Word. = zzzz. MOVSF, Status Affected. = None. MOVSS, Mnemonic,.Operands = z s , z d. MOVSS, Description. = Move z s (source) to 1st word z d (destination) 2nd",
    "TABLE 24-3: EXTENSIONS TO THE PIC18 INSTRUCTION SET\nword. MOVSS, Cycles. = 2. MOVSS, 16-Bit Instruction Word.MSb = 1110. MOVSS, 16-Bit Instruction Word.MSb = 1011. MOVSS, 16-Bit Instruction Word.LSb = 1zzz. MOVSS, 16-Bit Instruction Word. = zzzz. MOVSS, Status Affected. = None. PUSHL, Mnemonic,.Operands = k. PUSHL, Description. = Store Literal at FSR2, Decrement FSR2. PUSHL, Cycles. = 1. PUSHL, 16-Bit Instruction Word.MSb = 1110. PUSHL, 16-Bit Instruction Word.MSb = 1010. PUSHL, 16-Bit Instruction Word.LSb = kkkk. PUSHL, 16-Bit Instruction Word. = kkkk. PUSHL, Status Affected. = None. SUBFSR, Mnemonic,.Operands = f, k. SUBFSR, Description. = Subtract Literal from FSR. SUBFSR, Cycles. = 1. SUBFSR, 16-Bit Instruction",
    "TABLE 24-3: EXTENSIONS TO THE PIC18 INSTRUCTION SET\nWord.MSb = 1110. SUBFSR, 16-Bit Instruction Word.MSb = 1001. SUBFSR, 16-Bit Instruction Word.LSb = ffkk. SUBFSR, 16-Bit Instruction Word. = kkkk. SUBFSR, Status Affected. = None. SUBULNK, Mnemonic,.Operands = k. SUBULNK, Description. = Subtract Literal from FSR2 and Return. SUBULNK, Cycles. = 2. SUBULNK, 16-Bit Instruction Word.MSb = 1110. SUBULNK, 16-Bit Instruction Word.MSb = 1001. SUBULNK, 16-Bit Instruction Word.LSb = 11kk. SUBULNK, 16-Bit Instruction Word. = kkkk. SUBULNK, Status Affected. = None",
    "Add Literal to FSR\nSyntax:, 1 = ADDFSR f, k. Syntax:, 2 = ADDFSR f, k. Syntax:, 3 = ADDFSR f, k. Syntax:, 4 = ADDFSR f, k. Operands:, 1 = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operands:, 2 = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operands:, 3 = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operands:, 4 = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operation:, 1 = FSR(f) + k \u2192 FSR(f). Operation:, 2 = FSR(f) + k \u2192 FSR(f). Operation:, 3 = FSR(f) + k \u2192 FSR(f). Operation:, 4 = FSR(f) + k \u2192 FSR(f). Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 1110. Encoding:,",
    "Add Literal to FSR\n2 = 1000. Encoding:, 3 = ffkk. Encoding:, 4 = kkkk. Description:, 1 = The 6-bit literal GLYPH<145> kGLYPH<146> is added to the contents of the FSR specified by GLYPH<145>f GLYPH<146>.. Description:, 2 = The 6-bit literal GLYPH<145> kGLYPH<146> is added to the contents of the FSR specified by GLYPH<145>f GLYPH<146>.. Description:, 3 = The 6-bit literal GLYPH<145> kGLYPH<146> is added to the contents of the FSR specified by GLYPH<145>f GLYPH<146>.. Description:, 4 = The 6-bit literal GLYPH<145> kGLYPH<146> is added to the contents of the FSR specified by GLYPH<145>f GLYPH<146>.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:,",
    "Add Literal to FSR\n2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity: Q1, 1 = Q2. Q Cycle Activity: Q1, 2 = Q3. Q Cycle Activity: Q1, 3 = Q3. Q Cycle Activity: Q1, 4 = Q4. Decode, 1 = Read literal GLYPH<145>kGLYPH<146>. Decode, 2 = Process Data. Decode, 3 = Process Data. Decode, 4 = Write to FSR\nExample:\nADDFSR 2, 23h\nBefore Instruction\nFSR2\n=\n03FFh\nAfter Instruction\nFSR2\n=\n0422h",
    "Add Literal to FSR\nSyntax:, Add Literal to FSR2 and Return = ADDULNK k. Syntax:, Add Literal to FSR2 and Return = ADDULNK k. Syntax:, Add Literal to FSR2 and Return = ADDULNK k. Syntax:, Add Literal to FSR2 and Return = ADDULNK k. Operands:, Add Literal to FSR2 and Return = 0 \u2264 k \u2264 63. Operands:, Add Literal to FSR2 and Return = 0 \u2264 k \u2264 63. Operands:, Add Literal to FSR2 and Return = 0 \u2264 k \u2264 63. Operands:, Add Literal to FSR2 and Return = 0 \u2264 k \u2264 63. Operation:, Add Literal to FSR2 and Return = FSR2 + k \u2192 FSR2, PC = (TOS). Operation:, Add Literal to FSR2 and Return = FSR2 + k \u2192 FSR2, PC = (TOS). Operation:, Add Literal to FSR2 and Return = FSR2 + k \u2192 FSR2, PC = (TOS). Operation:, Add Literal to FSR2 and Return = FSR2 + k \u2192",
    "Add Literal to FSR\nFSR2, PC = (TOS). Status Affected:, Add Literal to FSR2 and Return = None. Status Affected:, Add Literal to FSR2 and Return = None. Status Affected:, Add Literal to FSR2 and Return = None. Status Affected:, Add Literal to FSR2 and Return = None. Encoding:, Add Literal to FSR2 and Return = 1110. Encoding:, Add Literal to FSR2 and Return = 1000. Encoding:, Add Literal to FSR2 and Return = 11kk. Encoding:, Add Literal to FSR2 and Return = kkkk. Description:, Add Literal to FSR2 and Return = The 6-bit literal GLYPH<145>kGLYPH<146> is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS.. Description:, Add Literal to FSR2 and Return = The 6-bit literal GLYPH<145>kGLYPH<146> is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS.. Description:, Add Literal to FSR2 and Return =",
    "Add Literal to FSR\nThe 6-bit literal GLYPH<145>kGLYPH<146> is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS.. Description:, Add Literal to FSR2 and Return = The 6-bit literal GLYPH<145>kGLYPH<146> is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS.. , Add Literal to FSR2 and Return = The instruction takes two cycles to execute; a NOP is performed during the second cycle.. , Add Literal to FSR2 and Return = The instruction takes two cycles to execute; a NOP is performed during the second cycle.. , Add Literal to FSR2 and Return = The instruction takes two cycles to execute; a NOP is performed during the second cycle.. , Add Literal to FSR2 and Return = The instruction takes two cycles to execute; a NOP is performed during the second cycle.. , Add Literal to FSR2 and Return = This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary GLYPH<145> 11",
    "Add Literal to FSR\nGLYPH<146>); it operates only on FSR2.. , Add Literal to FSR2 and Return = This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary GLYPH<145> 11 GLYPH<146>); it operates only on FSR2.. , Add Literal to FSR2 and Return = This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary GLYPH<145> 11 GLYPH<146>); it operates only on FSR2.. , Add Literal to FSR2 and Return = This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary GLYPH<145> 11 GLYPH<146>); it operates only on FSR2.. Words:, Add Literal to FSR2 and Return = 1. Words:, Add Literal to FSR2 and Return = . Words:, Add Literal to FSR2 and Return = . Words:, Add Literal to FSR2 and Return = . Cycles:, Add Literal to FSR2 and Return =",
    "Add Literal to FSR\n2. Cycles:, Add Literal to FSR2 and Return = . Cycles:, Add Literal to FSR2 and Return = . Cycles:, Add Literal to FSR2 and Return = ",
    "Q Cycle Activity:\nDecode, Q2 = Read literal GLYPH<145>kGLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write to FSR. No Operation, Q2 = No Operation. No Operation, Q3 = No Operation. No Operation, Q4 = No Operation",
    "Example:\nADDULNK 23h\nBefore Instruction, 1 = Before Instruction. , 1 = FSR2. , 1 = PC. After Instruction, 1 = After Instruction. , 1 = FSR2. , 1 = PC\nNote:\nAll PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction syntax then becomes: {label} instruction argument(s).",
    "PIC18F6390/6490/8390/8490\nSyntax:, Subroutine Call Using WREG = CALLW. Syntax:, Subroutine Call Using WREG = CALLW. Syntax:, Subroutine Call Using WREG = CALLW. Syntax:, Subroutine Call Using WREG = CALLW. Operands:, Subroutine Call Using WREG = None. Operands:, Subroutine Call Using WREG = None. Operands:, Subroutine Call Using WREG = None. Operands:, Subroutine Call Using WREG = None. Operation:, Subroutine Call Using WREG = (PC + 2) \u2192 TOS, (W) \u2192 PCL, (PCLATH) \u2192 PCH, (PCLATU) \u2192 PCU. Operation:, Subroutine Call Using WREG = (PC + 2) \u2192 TOS, (W) \u2192 PCL, (PCLATH) \u2192 PCH, (PCLATU) \u2192 PCU. Operation:, Subroutine Call Using WREG = (PC + 2) \u2192 TOS, (W) \u2192 PCL, (PCLATH) \u2192 PCH,",
    "PIC18F6390/6490/8390/8490\n(PCLATU) \u2192 PCU. Operation:, Subroutine Call Using WREG = (PC + 2) \u2192 TOS, (W) \u2192 PCL, (PCLATH) \u2192 PCH, (PCLATU) \u2192 PCU. Status Affected:, Subroutine Call Using WREG = None. Status Affected:, Subroutine Call Using WREG = None. Status Affected:, Subroutine Call Using WREG = None. Status Affected:, Subroutine Call Using WREG = None. Encoding:, Subroutine Call Using WREG = 0000. Encoding:, Subroutine Call Using WREG = 0000. Encoding:, Subroutine Call Using WREG = 0001. Encoding:, Subroutine Call Using WREG = 0100. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a",
    "PIC18F6390/6490/8390/8490\nNOP instruction while the new next instruction is fetched. Unlike CALL , there is no option to update W, STATUS or BSR.. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL , there is no option to update W, STATUS or BSR.. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL , there is no option to update W, STATUS or BSR.. Description,",
    "PIC18F6390/6490/8390/8490\nSubroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL , there is no option to update W, STATUS or BSR.. Words:, Subroutine Call Using WREG = 1. Words:, Subroutine Call Using WREG = 1. Words:, Subroutine Call Using WREG = 1. Words:, Subroutine Call Using WREG = 1. Cycles:, Subroutine Call Using WREG = 2. Cycles:, Subroutine Call Using WREG = 2. Cycles:, Subroutine Call Using WREG = 2. Cycles:, Subroutine Call Using WREG = 2. Q Cycle Activity:, Subroutine Call Using WREG = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call Using WREG = Q Cycle",
    "PIC18F6390/6490/8390/8490\nActivity:. Q Cycle Activity:, Subroutine Call Using WREG = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call Using WREG = Q Cycle Activity:. , Subroutine Call Using WREG = Q1 Q2. , Subroutine Call Using WREG = Q3. , Subroutine Call Using WREG = . , Subroutine Call Using WREG = Q4. Decode, Subroutine Call Using WREG = Read. Decode, Subroutine Call Using WREG = WREG. Decode, Subroutine Call Using WREG = Push PC to stack. Decode, Subroutine Call Using WREG = No operation. No, Subroutine Call Using WREG = operation. No, Subroutine Call Using WREG = No operation. No, Subroutine Call Using WREG = No operation. No, Subroutine Call Using WREG = No operation",
    "Example:\nHERE\nCALLW\nBefore Instruction\nPC\n=\naddress (HERE)\nPCLATH =\n10h\nPCLATU =\n00h\nW\n=\n06h\nAfter Instruction\nPC\n=\n001006h\nTOS\n=\naddress (HERE + 2)\nPCLATH =\n10h\nPCLATU =\n00h\nW\n=\n06h",
    "Example:\nSyntax:, Move Indexed to f = MOVSF [z s ], f d. Syntax:, Move Indexed to f = MOVSF [z s ], f d. Syntax:, Move Indexed to f = MOVSF [z s ], f d. Syntax:, Move Indexed to f = MOVSF [z s ], f d. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operation:, Move Indexed to f = ((FSR2) + z s ) \u2192 f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \u2192 f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \u2192 f d. Operation:, Move Indexed to f = ((FSR2) + z",
    "Example:\ns ) \u2192 f d. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Encoding:, Move Indexed to f = . Encoding:, Move Indexed to f = . Encoding:, Move Indexed to f = . Encoding:, Move Indexed to f = . 1st word (source), Move Indexed to f = 1110. 1st word (source), Move Indexed to f = 1011. 1st word (source), Move Indexed to f = 0zzz. 1st word (source), Move Indexed to f = zzzz s. 2nd word (destin.), Move Indexed to f = 1111. 2nd word (destin.), Move Indexed to f = ffff. 2nd word (destin.), Move Indexed to f = ffff. 2nd word (destin.), Move Indexed to f = ffff d\nDescription:",
    "Example:\nThe contents of the source register are moved to destination register GLYPH<145>f d GLYPH<146>. The actual address of the source register is determined by adding the 7-bit literal offset GLYPH<145>z s GLYPH<146> in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal GLYPH<145> f d GLYPH<146> in the second word. Both addresses can be anywhere in the 4096-byte data space (000h to FFFh).\nThe MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.\nIf the resultant source address points to an Indirect Addressing register, the value returned will be 00h.\nWords:\n2\nCycles:\n2\nQ Cycle Activity:",
    "Example:\nDecode, Q2 = Determine source addr. Decode, Q3 = Determine source addr. Decode, Q4 = Read source reg. Decode, Q2 = No operation No dummy read. Decode, Q3 = No operation. Decode, Q4 = Write register GLYPH<145>f GLYPH<146> (dest)\nMOVSF   [05h], REG2\nBefore Instruction\nFSR2\n=\n80h\nContents\nof 85h\n= 33h\nREG2\n= 11h\nAfter Instruction\nFSR2\n= 80h\nContents\nof 85h\n= 33h\nREG2\n=\n33h",
    "PIC18F6390/6490/8390/8490\nMOVSS",
    "Move Indexed to Indexed\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\n1st word (source)\n2nd word (dest.)\nDescription\nWords:\nCycles:\nMOVSS   [z s ], [z d ]\n0 \u2264 z s \u2264 127\n0 \u2264 z d \u2264 127\n((FSR2) + z s ) \u2192 ((FSR2) + z d )\nNone\n1110\n1011\n1zzz zzzz s\n1111\nxxxx xzzz\nzzzz d\nThe contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets GLYPH<145>z s GLYPH<146> or GLYPH<145>z d GLYPH<146>, respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh).\nThe MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.",
    "PUSHL\nStore Literal at FSR2, Decrement FSR2\nSyntax:\nPUSHL k\nOperands:\n0 \u2264 k \u2264 255\nOperation:\nk \u2192 (FSR2),\nFSR2 GLYPH<150> 1 \u2192 FSR2\nStatus Affected:\nNone\nEncoding:\n1111\n1010\nkkkk\nkkkk\nDescription:\nThe 8-bit literal GLYPH<145>kGLYPH<146> is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation.\nThis instruction allows users to push values onto a software stack.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead GLYPH<145>kGLYPH<146>\nProcess\ndata\nWrite to\ndestination\nIf the resultant source address points to an Indirect Addressing register, the value returned will be 00h. If the resultant destination address points to an Indirect Addressing register, the instruction will execute as a NOP .\n2\n2\nQ Cycle Activity:\nQ1",
    "PUSHL\nDecode, 1 = Determine source addr. Decode, 2 = Determine source addr. Decode, 3 = Read source reg. Decode, 1 = Determine dest addr. Decode, 2 = Determine dest addr. Decode, 3 = Write to dest reg\nQ2\nQ3\nQ4",
    "Example:\nMOVSS [05h], [06h]\nBefore Instruction\nFSR2\n=\n80h\nContents\nof 85h\n= 33h\nContents\nof 86h\n= 11h\nAfter Instruction\nFSR2\n=\n80h\nContents\nof 85h\n=\n33h\nContents\nof 86h\n= 33h\nExample:\nPUSHL 08h\nBefore Instruction\nFSR2H:FSR2L\n= 01ECh\nMemory (01ECh)\n= 00h\nAfter Instruction\nFSR2H:FSR2L\n=\n01EBh\nMemory (01ECh)\n= 08h",
    "PIC18F6390/6490/8390/8490\nSyntax:, Subtract Literal from FSR = SUBFSR f, k. Syntax:, Subtract Literal from FSR = SUBFSR f, k. Syntax:, Subtract Literal from FSR = SUBFSR f, k. Syntax:, Subtract Literal from FSR = SUBFSR f, k. Operands:, Subtract Literal from FSR = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operands:, Subtract Literal from FSR = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operands:, Subtract Literal from FSR = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operands:, Subtract Literal from FSR = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operation:, Subtract Literal from FSR = FSRf GLYPH<150> k \u2192 FSRf. Operation:, Subtract Literal from FSR = FSRf GLYPH<150> k \u2192 FSRf. Operation:, Subtract Literal from",
    "PIC18F6390/6490/8390/8490\nFSR = FSRf GLYPH<150> k \u2192 FSRf. Operation:, Subtract Literal from FSR = FSRf GLYPH<150> k \u2192 FSRf. Status Affected:, Subtract Literal from FSR = None. Status Affected:, Subtract Literal from FSR = None. Status Affected:, Subtract Literal from FSR = None. Status Affected:, Subtract Literal from FSR = None. Encoding:, Subtract Literal from FSR = 1110. Encoding:, Subtract Literal from FSR = 1001. Encoding:, Subtract Literal from FSR = ffkk. Encoding:, Subtract Literal from FSR = kkkk. Description:, Subtract Literal from FSR = The 6-bit literal GLYPH<145>kGLYPH<146> is subtracted from the contents of the FSR specified by GLYPH<145>fGLYPH<146>.. Description:, Subtract Literal from FSR = The 6-bit literal GLYPH<145>kGLYPH<146> is",
    "PIC18F6390/6490/8390/8490\nsubtracted from the contents of the FSR specified by GLYPH<145>fGLYPH<146>.. Description:, Subtract Literal from FSR = The 6-bit literal GLYPH<145>kGLYPH<146> is subtracted from the contents of the FSR specified by GLYPH<145>fGLYPH<146>.. Description:, Subtract Literal from FSR = The 6-bit literal GLYPH<145>kGLYPH<146> is subtracted from the contents of the FSR specified by GLYPH<145>fGLYPH<146>.. Words:, Subtract Literal from FSR = 1. Words:, Subtract Literal from FSR = 1. Words:, Subtract Literal from FSR = 1. Words:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1. Q Cycle",
    "PIC18F6390/6490/8390/8490\nActivity:, Subtract Literal from FSR = Q Cycle Activity:. Q Cycle Activity:, Subtract Literal from FSR = Q Cycle Activity:. Q Cycle Activity:, Subtract Literal from FSR = Q Cycle Activity:. Q Cycle Activity:, Subtract Literal from FSR = Q Cycle Activity:. Q1, Subtract Literal from FSR = Q2. Q1, Subtract Literal from FSR = Q3. Q1, Subtract Literal from FSR = . Q1, Subtract Literal from FSR = Q4. Decode, Subtract Literal from FSR = Read register GLYPH<145>f GLYPH<146>. Decode, Subtract Literal from FSR = Process Data. Decode, Subtract Literal from FSR = . Decode, Subtract Literal from FSR = Write to destination\nExample:\nSUBFSR 2, 23h\nBefore Instruction\nFSR2\n=\n03FFh\nAfter Instruction\nFSR2\n=\n03DCh",
    "PIC18F6390/6490/8390/8490\nSyntax:, Subtract Literal from FSR2 and Return = SUBULNK k. Syntax:, Subtract Literal from FSR2 and Return = SUBULNK k. Syntax:, Subtract Literal from FSR2 and Return = SUBULNK k. Syntax:, Subtract Literal from FSR2 and Return = SUBULNK k. Operands:, Subtract Literal from FSR2 and Return = 0 \u2264 k \u2264 63. Operands:, Subtract Literal from FSR2 and Return = 0 \u2264 k \u2264 63. Operands:, Subtract Literal from FSR2 and Return = 0 \u2264 k \u2264 63. Operands:, Subtract Literal from FSR2 and Return = 0 \u2264 k \u2264 63. Operation:, Subtract Literal from FSR2 and Return = FSR2 GLYPH<150> k \u2192 FSR2, (TOS) \u2192 PC. Operation:, Subtract Literal from FSR2 and Return = FSR2 GLYPH<150> k \u2192 FSR2, (TOS) \u2192 PC. Operation:, Subtract Literal from",
    "PIC18F6390/6490/8390/8490\nFSR2 and Return = FSR2 GLYPH<150> k \u2192 FSR2, (TOS) \u2192 PC. Operation:, Subtract Literal from FSR2 and Return = FSR2 GLYPH<150> k \u2192 FSR2, (TOS) \u2192 PC. Status Affected:, Subtract Literal from FSR2 and Return = None. Status Affected:, Subtract Literal from FSR2 and Return = None. Status Affected:, Subtract Literal from FSR2 and Return = None. Status Affected:, Subtract Literal from FSR2 and Return = None. Encoding:, Subtract Literal from FSR2 and Return = 1110. Encoding:, Subtract Literal from FSR2 and Return = 1001. Encoding:, Subtract Literal from FSR2 and Return = 11kk. Encoding:, Subtract Literal from FSR2 and Return = kkkk. Description:, Subtract Literal from FSR2 and Return = The 6-bit literal GLYPH<145>kGLYPH<146> is subtracted from the contents of the",
    "PIC18F6390/6490/8390/8490\nFSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary GLYPH<145> 11 GLYPH<146> ); it operates only on FSR2.. Description:, Subtract Literal from FSR2 and Return = The 6-bit literal GLYPH<145>kGLYPH<146> is subtracted from the contents of the FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary GLYPH<145> 11 GLYPH<146> ); it operates only on FSR2.. Description:, Subtract Literal from FSR2 and Return = The 6-bit literal GLYPH<145>kGLYPH<146> is subtracted from the contents of",
    "PIC18F6390/6490/8390/8490\nthe FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary GLYPH<145> 11 GLYPH<146> ); it operates only on FSR2.. Description:, Subtract Literal from FSR2 and Return = The 6-bit literal GLYPH<145>kGLYPH<146> is subtracted from the contents of the FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary GLYPH<145> 11 GLYPH<146> ); it operates only on FSR2.. Words:, Subtract Literal from FSR2 and Return = 1. Words:, Subtract Literal from FSR2 and Return = 1. Words:,",
    "PIC18F6390/6490/8390/8490\nSubtract Literal from FSR2 and Return = 1. Words:, Subtract Literal from FSR2 and Return = 1. Cycles:, Subtract Literal from FSR2 and Return = 2. Cycles:, Subtract Literal from FSR2 and Return = 2. Cycles:, Subtract Literal from FSR2 and Return = 2. Cycles:, Subtract Literal from FSR2 and Return = 2. Q Cycle Activity:, Subtract Literal from FSR2 and Return = Q Cycle Activity:. Q Cycle Activity:, Subtract Literal from FSR2 and Return = Q Cycle Activity:. Q Cycle Activity:, Subtract Literal from FSR2 and Return = Q Cycle Activity:. Q Cycle Activity:, Subtract Literal from FSR2 and Return = Q Cycle Activity:. Q1, Subtract Literal from FSR2 and Return = Q2. Q1, Subtract Literal from FSR2 and Return = . Q1, Subtract Literal from FSR2 and Return = Q3. Q1, Subtract Literal from FSR2 and Return =",
    "PIC18F6390/6490/8390/8490\nQ4. Decode, Subtract Literal from FSR2 and Return = . Decode, Subtract Literal from FSR2 and Return = Read register GLYPH<145>f GLYPH<146>. Decode, Subtract Literal from FSR2 and Return = Process Data. Decode, Subtract Literal from FSR2 and Return = Write to destination. No Operation, Subtract Literal from FSR2 and Return = No. No Operation, Subtract Literal from FSR2 and Return = Operation. No Operation, Subtract Literal from FSR2 and Return = No Operation. No Operation, Subtract Literal from FSR2 and Return = No Operation\nExample:\nSUBULNK 23h\nBefore Instruction\nFSR2\n=\n03FFh\nPC\n=\n0100h\nAfter Instruction\nFSR2\n=\n03DCh\nPC\n=\n(TOS)",
    "24.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nNote:\nEnabling the PIC18 instruction set extension may cause legacy applications to behave erratically or fail entirely.\nIn addition to eight new commands in the extended set, enabling  the  extended  instruction  set  also  enables Indexed Literal Offset Addressing mode ( Section 5.6.1 GLYPH<147>Indexed Addressing With Literal OffsetGLYPH<148> ). This has a significant impact on the way that many commands of the standard PIC18 instruction set are interpreted.",
    "24.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nWhen the extended set is disabled, addresses embedded in opcodes are treated as literal memory locations: either as a location in the Access Bank (a = 0 ), or in a GPR bank designated by the BSR (a = 1 ).  When the extended instruction set is enabled and a = 0 , however, a file register argument of 5Fh or less is interpreted as an offset from the pointer value in FSR2 and not as a literal address. For practical purposes, this means that all  instructions  that  use  the  Access  RAM  bit  as  an argument  GLYPH<150>  that  is,  all  byte-oriented  and  bit-oriented instructions, or almost half of the core PIC18 instructions GLYPH<150> may behave differently when the extended instruction set is enabled.",
    "24.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nWhen the content of FSR2 is 00h, the boundaries of the Access RAM are essentially remapped to their original values.  This  may  be  useful  in  creating  backward compatible code. If this technique is used, it may be necessary  to  save  the  value  of  FSR2  and  restore  it when moving back and forth between GLYPH<145>CGLYPH<146> and assembly routines in order to preserve the Stack Pointer. Users must also keep in mind the syntax requirements of the extended instruction set (see Section 24.2.3.1 GLYPH<147>Extended Instruction Syntax with Standard PIC18 CommandsGLYPH<148> ).\nAlthough the Indexed Literal Offset Addressing mode can  be  very  useful  for  dynamic  stack  and  pointer manipulation, it can also be very annoying if a simple arithmetic operation is carried out on  the wrong register.  Users  who  are  accustomed  to  the  PIC18 programming  must  keep  in  mind  that,  when  the extended instruction set is enabled, register addresses of  5Fh  or  less  are  used  for  Indexed  Literal  Offset Addressing.",
    "24.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nRepresentative examples of typical byte-oriented and bit-oriented  instructions  in  the  Indexed  Literal  Offset Addressing mode are provided on the following page to show how execution is affected. The operand conditions shown in the examples are applicable to all instructions of these types.\nWhen the extended instruction set is enabled, the file register argument, GLYPH<145>fGLYPH<146>, in the standard byte-oriented and bit-oriented commands is replaced with the literal offset value, GLYPH<145>kGLYPH<146>. As already noted, this occurs only when GLYPH<145>fGLYPH<146> is less than or equal to 5Fh. When an offset value is used, it must be indicated by square brackets (GLYPH<147>[ ]GLYPH<148>). As with the extended instructions, the use of brackets indicates to the compiler that the value is to be interpreted as an index  or  an  offset.  Omitting  the  brackets,  or  using  a value greater than 5Fh within brackets, will generate an error in the MPASMGLYPH<153> Assembler.",
    "24.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nIf the index argument is properly bracketed for Indexed Literal Offset Addressing, the Access RAM argument is never specified; it will automatically be assumed to be GLYPH<145> 0 GLYPH<146> .  This is in contrast to standard operation (extended instruction set disabled) when GLYPH<145>aGLYPH<146> is set on the basis of the  target  address.  Declaring  the  Access  RAM  bit  in this  mode will  also  generate  an  error  in  the  MPASM Assembler.\nThe destination argument, GLYPH<145>dGLYPH<146>, functions as before.\nIn the latest versions  of the MPASM  Assembler, language support for the extended instruction set must be  explicitly  invoked.  This  is  done  with  either  the command line  option, /y ,  or  the  PE  directive  in  the source listing.",
    "24.2.4 CONSIDERATIONS WHEN ENABLING THE EXTENDED INSTRUCTION SET\nIt is important to note that the extensions to the instruction set may not be beneficial to all users. In particular, users who are not writing code that uses a software stack may not benefit from using the extensions to the instruction set.\nAdditionally, the  Indexed  Literal  Offset  Addressing mode  may  create  issues  with  legacy  applications written to the  PIC18  assembler.  This  is  because instructions in the legacy code may attempt to address registers in the Access Bank below 5Fh. Since these addresses  are  interpreted  as  literal  offsets  to  FSR2 when  the  instruction  set  extension  is  enabled,  the application  may  read  or  write  to  the  wrong  data addresses.\nWhen porting an application to the PIC18FXX90, it is very important to consider the type of code. A large, reentrant application that is written in GLYPH<145>CGLYPH<146> and would benefit from  efficient  compilation  will  do  well  when  using  the instruction set extensions.  Legacy  applications  that heavily use the Access Bank will most likely not benefit from using the extended instruction set.",
    "PIC18F6390/6490/8390/8490\nADDWF",
    "ADD W to Indexed (Indexed Literal Offset mode)\nSyntax:\nADDWF      [k] {,d}\nOperands:\n0 \u2264 k \u2264 95\nd \u2208 [0,1]\na = 0\nOperation:\n(W) + ((FSR2) + k) \u2192 dest\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0010\n01d0\nkkkk\nkkkk\nDescription:\nThe contents of W are added to the contents of the register indicated by FSR2, offset by the value GLYPH<145>kGLYPH<146>.\nIf GLYPH<145>dGLYPH<146> is GLYPH<145> 0 GLYPH<146> ,  the result is stored in W. If GLYPH<145>dGLYPH<146> is GLYPH<145> 1 GLYPH<146> , the result is stored back in register GLYPH<145>fGLYPH<146> (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead GLYPH<145>kGLYPH<146>\nProcess\nData\nWrite to\ndestination",
    "Example:\nADDWF\n[OFST] ,0\nBefore Instruction\nW\n=\n17h\nOFST\n=\n2Ch\nFSR2\n=\n0A00h\nContents\nof 0A2Ch\n=\n20h\nAfter Instruction\nW\n=\n37h\nContents\nof 0A2Ch\n=\n20h",
    "Example:\nSyntax:, Bit Set Indexed (Indexed Literal Offset mode) = BSF [k], b. Syntax:, Bit Set Indexed (Indexed Literal Offset mode) = BSF [k], b. Syntax:, Bit Set Indexed (Indexed Literal Offset mode) = BSF [k], b. Syntax:, Bit Set Indexed (Indexed Literal Offset mode) = BSF [k], b. Operands:, Bit Set Indexed (Indexed Literal Offset mode) = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7 a = 0. Operands:, Bit Set Indexed (Indexed Literal Offset mode) = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7 a = 0. Operands:, Bit Set Indexed (Indexed Literal Offset mode) = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7 a = 0. Operands:, Bit Set Indexed (Indexed Literal Offset mode) = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7 a = 0. Operation:, Bit Set Indexed (Indexed Literal Offset mode) = 1 \u2192 ((FSR2 + k))<b>. Operation:, Bit Set Indexed (Indexed Literal Offset mode) = 1 \u2192 ((FSR2 + k))<b>.",
    "Example:\nOperation:, Bit Set Indexed (Indexed Literal Offset mode) = 1 \u2192 ((FSR2 + k))<b>. Operation:, Bit Set Indexed (Indexed Literal Offset mode) = 1 \u2192 ((FSR2 + k))<b>. Status Affected:, Bit Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Bit Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Bit Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Bit Set Indexed (Indexed Literal Offset mode) = None. Encoding:, Bit Set Indexed (Indexed Literal Offset mode) = 1000. Encoding:, Bit Set Indexed (Indexed Literal Offset mode) = bbb0. Encoding:, Bit Set Indexed (Indexed Literal Offset mode) = kkkk. Encoding:, Bit Set Indexed (Indexed Literal Offset mode) = kkkk. Description:, Bit Set Indexed (Indexed Literal Offset mode) = Bit GLYPH<145>bGLYPH<146> of the register indicated by FSR2, offset by the value GLYPH<145>kGLYPH<146>, is set.. Description:, Bit Set Indexed (Indexed Literal Offset mode)",
    "Example:\n= Bit GLYPH<145>bGLYPH<146> of the register indicated by FSR2, offset by the value GLYPH<145>kGLYPH<146>, is set.. Description:, Bit Set Indexed (Indexed Literal Offset mode) = Bit GLYPH<145>bGLYPH<146> of the register indicated by FSR2, offset by the value GLYPH<145>kGLYPH<146>, is set.. Description:, Bit Set Indexed (Indexed Literal Offset mode) = Bit GLYPH<145>bGLYPH<146> of the register indicated by FSR2, offset by the value GLYPH<145>kGLYPH<146>, is set.. Words:, Bit Set Indexed (Indexed Literal Offset mode) = 1. Words:, Bit Set Indexed (Indexed Literal Offset mode) = 1. Words:, Bit Set Indexed (Indexed Literal Offset mode) = 1. Words:, Bit Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Bit Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Bit Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Bit Set Indexed (Indexed",
    "Example:\nLiteral Offset mode) = 1. Cycles:, Bit Set Indexed (Indexed Literal Offset mode) = 1\nQ Cycle Activity:\nDecode, Q2 = Read register GLYPH<145>fGLYPH<146>. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. , Q2 = BSF. , Q3 = [FLAG_OFST],. , Q4 = 7. Before Instruction FLAG_OFST, Q2 = Before Instruction FLAG_OFST. Before Instruction FLAG_OFST, Q3 = 0Ah 0A00h 55h. Before Instruction FLAG_OFST, Q4 = ",
    "Example:\nSyntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Syntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Syntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Syntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95. Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \u2192 ((FSR2) + k). Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \u2192 ((FSR2) + k). Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \u2192 ((FSR2) + k). Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \u2192 ((FSR2) + k). Status Affected:, Set Indexed",
    "Example:\n(Indexed Literal Offset mode) = None. Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Encoding:, Set Indexed (Indexed Literal Offset mode) = 0110. Encoding:, Set Indexed (Indexed Literal Offset mode) = 1000. Encoding:, Set Indexed (Indexed Literal Offset mode) = kkkk. Encoding:, Set Indexed (Indexed Literal Offset mode) = kkkk. Description:, Set Indexed (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by GLYPH<145>kGLYPH<146>, are set to FFh.. Description:, Set Indexed (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by GLYPH<145>kGLYPH<146>, are set to FFh.. Description:, Set Indexed (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by GLYPH<145>kGLYPH<146>, are set to FFh.. Description:, Set",
    "Example:\nIndexed (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by GLYPH<145>kGLYPH<146>, are set to FFh.. Words:, Set Indexed (Indexed Literal Offset mode) = 1. Words:, Set Indexed (Indexed Literal Offset mode) = 1. Words:, Set Indexed (Indexed Literal Offset mode) = 1. Words:, Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Set Indexed (Indexed Literal Offset mode) = 1. Q Cycle Activity: Q1, Set Indexed (Indexed Literal Offset mode) = Q2. Q Cycle Activity: Q1, Set Indexed (Indexed Literal Offset mode) = Q3. Q Cycle Activity: Q1, Set Indexed (Indexed Literal Offset mode) = . Q Cycle Activity: Q1, Set Indexed (Indexed Literal Offset mode) = Q4. Decode, Set Indexed (Indexed Literal Offset mode) = Read GLYPH<145>kGLYPH<146>.",
    "Example:\nDecode, Set Indexed (Indexed Literal Offset mode) = Process Data. Decode, Set Indexed (Indexed Literal Offset mode) = . Decode, Set Indexed (Indexed Literal Offset mode) = Write register\nBefore Instruction OFST, SETF = =. Before Instruction OFST, [OFST] = 2Ch. FSR2, SETF = =. FSR2, [OFST] = 0A00h. Contents of 0A2Ch, SETF = =. Contents of 0A2Ch, [OFST] = 00h. After Instruction Contents of 0A2Ch, SETF = =. After Instruction Contents of 0A2Ch, [OFST] = FFh",
    "24.2.5 SPECIAL CONSIDERATIONS WITH MICROCHIP MPLAB fi  IDE TOOLS\nThe latest versions of MicrochipGLYPH<146>s software tools have been designed to fully support the extended instruction set of the PIC18FXX90 family of devices. This includes the MPLAB C18 C compiler, MPASM  assembly language and MPLAB Integrated Development Environment (IDE).\nWhen selecting a target device for software development, MPLAB IDE will automatically set default Configuration bits for that device. The default setting for the XINST Configuration bit is GLYPH<145> 0 GLYPH<146>, disabling the extended instruction  set  and  Indexed  Literal  Offset  Addressing mode. For proper execution of applications developed to  take  advantage  of  the  extended  instruction  set, XINST must be set during programming.\nTo develop software for the extended instruction set, the user must enable support for the instructions and the Indexed Addressing mode in their language tool(s). Depending on the environment being used, this may be done in several ways:",
    "24.2.5 SPECIAL CONSIDERATIONS WITH MICROCHIP MPLAB fi  IDE TOOLS\nGLYPH<149> A menu option, or dialog box within the environment, that allows the user to configure the language tool and its settings for the project\nGLYPH<149> A command line option\nGLYPH<149> A directive in the source code\nThese options vary between different compilers, assemblers and development environments. Users are encouraged to review the documentation accompanying  their  development  systems  for  the  appropriate information.",
    "25.0 DEVELOPMENT SUPPORT\nThe  PIC fi microcontrollers  are  supported  with  a  full range of hardware and software development tools:\nGLYPH<149> Integrated Development Environment\n-MPLAB fi  IDE Software\nGLYPH<149> Assemblers/Compilers/Linkers\n-MPASM TM  Assembler\n-MPLAB C18 and MPLAB C30 C Compilers\n-MPLINK TM  Object Linker/ MPLIB TM  Object Librarian\n-MPLAB ASM30 Assembler/Linker/Library\nGLYPH<149> Simulators\n-MPLAB SIM Software Simulator\nGLYPH<149> Emulators\n-MPLAB ICE 2000 In-Circuit Emulator\n-MPLAB REAL ICEGLYPH<153> In-Circuit Emulator\nGLYPH<149> In-Circuit Debugger\n-MPLAB ICD 2\nGLYPH<149> Device Programmers\n-PICSTART fi  Plus Development Programmer\n-MPLAB PM3 Device Programmer\n-PICkitGLYPH<153> 2 Development Programmer\nGLYPH<149> Low-Cost Demonstration and Development Boards and Evaluation Kits",
    "25.1 MPLAB Integrated Development Environment Software\nThe MPLAB IDE software brings an ease of software development previously unseen in the 8/16-bit microcontroller  market.  The  MPLAB  IDE  is  a  Windows fi operating system-based application that contains:\nGLYPH<149> A single graphical interface to all debugging tools\n-Simulator\n-Programmer (sold separately)\n-Emulator (sold separately)\n-In-Circuit Debugger (sold separately)\nGLYPH<149> A full-featured editor with color-coded context\nGLYPH<149> A multiple project manager\nGLYPH<149> Customizable data windows with direct edit of contents\nGLYPH<149> High-level source code debugging\nGLYPH<149> Visual device initializer for easy register initialization\nGLYPH<149> Mouse over variable inspection\nGLYPH<149> Drag and drop variables from source to watch windows\nGLYPH<149> Extensive on-line help\nGLYPH<149> Integration of select third party tools, such as HI-TECH Software C Compilers and IAR C Compilers\nThe MPLAB IDE allows you to:",
    "25.1 MPLAB Integrated Development Environment Software\nGLYPH<149> Edit your source files (either assembly or C)\nGLYPH<149> One touch assemble (or compile) and download to PIC MCU emulator and simulator tools (automatically updates all project information)\nGLYPH<149> Debug using:\n-Source files (assembly or C)\n-Mixed assembly and C\n-Machine code\nMPLAB  IDE  supports  multiple  debugging  tools  in  a single development paradigm, from the cost-effective simulators,  through  low-cost  in-circuit  debuggers,  to full-featured  emulators.  This  eliminates  the  learning curve when upgrading to tools with increased flexibility and power.",
    "25.2 MPASM Assembler\nThe  MPASM  Assembler  is  a  full-featured,  universal macro assembler for all PIC MCUs.\nThe MPASM Assembler generates relocatable object files for the MPLINK Object Linker, Intel fi standard HEX files,  MAP  files  to  detail  memory  usage  and  symbol reference, absolute LST files that contain source lines and  generated  machine  code  and  COFF  files  for debugging.\nThe MPASM Assembler features include:\nGLYPH<149> Integration into MPLAB IDE projects\nGLYPH<149> User-defined macros to streamline assembly code\nGLYPH<149> Conditional assembly for multi-purpose source files\nGLYPH<149> Directives that allow complete control over the assembly process",
    "25.3 MPLAB C18 and MPLAB C30 C Compilers\nThe MPLAB C18 and MPLAB C30 Code Development Systems are complete ANSI C compilers for MicrochipGLYPH<146>s PIC18 and PIC24 families of microcontrollers and the dsPIC30 and dsPIC33 family of digital signal controllers. These  compilers  provide powerful integration capabilities, superior code optimization and ease of use not found with other compilers.\nFor easy source level debugging, the compilers provide symbol information that is optimized to the MPLAB IDE debugger.",
    "25.4 MPLINK Object Linker/ MPLIB Object Librarian\nThe  MPLINK  Object  Linker  combines relocatable objects  created  by  the  MPASM  Assembler  and  the MPLAB C18 C Compiler. It can link relocatable objects from  precompiled  libraries,  using  directives  from  a linker script.\nThe MPLIB Object Librarian manages the creation and modification of library files of precompiled code. When a routine from a library is called from a source file, only the modules that contain that routine will be linked in with  the  application.  This  allows  large  libraries  to  be used efficiently in many different applications.\nThe object linker/library features include:\nGLYPH<149> Efficient linking of single libraries instead of many smaller files\nGLYPH<149> Enhanced code maintainability by grouping related modules together\nGLYPH<149> Flexible creation of libraries with easy module listing, replacement, deletion and extraction",
    "25.5 MPLAB ASM30 Assembler, Linker and Librarian\nMPLAB ASM30 Assembler produces relocatable machine  code  from  symbolic  assembly  language  for dsPIC30F devices. MPLAB C30 C Compiler uses the assembler  to  produce  its  object  file.  The  assembler generates  relocatable  object  files  that  can  then  be archived or linked with other relocatable object files and archives to create an executable file. Notable features of the assembler include:\nGLYPH<149> Support for the entire dsPIC30F instruction set\nGLYPH<149> Support for fixed-point and floating-point data\nGLYPH<149> Command line interface\nGLYPH<149> Rich directive set\nGLYPH<149> Flexible macro language\nGLYPH<149> MPLAB IDE compatibility",
    "25.6 MPLAB SIM Software Simulator\nThe  MPLAB  SIM  Software  Simulator  allows  code development in a PC-hosted environment by simulating the PIC MCUs and dsPIC fi  DSCs on an instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a comprehensive stimulus controller. Registers can be logged to files for further run-time analysis. The trace buffer and logic analyzer display extend the power of the simulator to record and track program execution, actions on I/O, most peripherals and internal registers.\nThe  MPLAB  SIM  Software  Simulator  fully  supports symbolic debugging using the MPLAB  C18  and MPLAB  C30  C Compilers,  and  the MPASM  and MPLAB ASM30 Assemblers.  The software  simulator offers the flexibility to develop and debug code outside of the hardware laboratory environment, making it an excellent, economical software development tool.",
    "25.7 MPLAB ICE 2000 High-Performance In-Circuit Emulator\nThe MPLAB ICE 2000 In-Circuit Emulator is intended to  provide  the  product  development  engineer  with  a complete microcontroller design tool set for PIC microcontrollers. Software control of the MPLAB ICE 2000 In-Circuit Emulator is advanced by the MPLAB Integrated  Development  Environment,  which  allows editing,  building,  downloading and  source  debugging from a single environment.\nThe  MPLAB  ICE  2000  is  a  full-featured  emulator system with enhanced trace, trigger and data monitoring features. Interchangeable processor modules allow the system to be easily reconfigured for emulation of different  processors.  The  architecture  of  the  MPLAB ICE  2000  In-Circuit  Emulator  allows  expansion  to support new PIC microcontrollers.\nThe MPLAB ICE 2000 In-Circuit Emulator system has been designed as a real-time emulation system with advanced  features  that  are  typically  found  on  more expensive  development  tools.  The  PC  platform  and Microsoft fi Windows fi   32-bit  operating  system  were chosen  to  best  make  these  features  available  in  a simple, unified application.",
    "25.8 MPLAB REAL ICE In-Circuit Emulator System\nMPLAB  REAL  ICE  In-Circuit Emulator System  is MicrochipGLYPH<146>s next  generation  high-speed  emulator  for Microchip Flash DSC and MCU devices. It debugs and programs PIC fi  Flash MCUs and dsPIC fi  Flash DSCs with the easy-to-use, powerful graphical user interface of the MPLAB Integrated Development Environment (IDE), included with each kit.\nThe MPLAB REAL ICE probe is connected to the design engineerGLYPH<146>s PC using a high-speed USB 2.0 interface and is connected  to  the  target  with  either  a  connector compatible  with  the  popular  MPLAB  ICD  2  system (RJ11) or with the new high-speed, noise tolerant, LowVoltage Differential Signal (LVDS) interconnection (CAT5).",
    "25.8 MPLAB REAL ICE In-Circuit Emulator System\nMPLAB REAL ICE is field upgradeable through future firmware downloads  in MPLAB  IDE.  In  upcoming releases of MPLAB IDE, new devices will be supported, and new features will be added, such as software breakpoints  and  assembly  code  trace.  MPLAB  REAL  ICE offers significant advantages over competitive emulators including low-cost, full-speed emulation, real-time variable watches, trace analysis, complex breakpoints, a ruggedized probe interface and long (up to three meters) interconnection cables.",
    "25.9 MPLAB ICD 2 In-Circuit Debugger\nMicrochipGLYPH<146>s  In-Circuit  Debugger,  MPLAB  ICD  2,  is  a powerful, low-cost, run-time development tool, connecting to the host PC via an RS-232 or high-speed USB  interface.  This  tool  is  based  on  the  Flash  PIC MCUs and can be used to develop for these and other PIC MCUs and dsPIC DSCs. The MPLAB ICD 2 utilizes the  in-circuit  debugging  capability  built  into  the Flash devices. This feature, along with MicrochipGLYPH<146>s In-Circuit Serial  Programming TM   (ICSP TM )  protocol,  offers  costeffective, in-circuit Flash debugging from the graphical user interface of the MPLAB Integrated Development Environment. This enables a designer to develop and debug source code by setting breakpoints, single stepping  and  watching  variables,  and  CPU  status  and peripheral  registers.  Running  at  full  speed  enables testing hardware and applications in real time. MPLAB ICD 2 also serves as a development programmer for selected PIC devices.",
    "25.10 MPLAB PM3 Device Programmer\nThe MPLAB PM3 Device Programmer is a universal, CE compliant device programmer with programmable voltage verification at VDDMIN and VDDMAX for maximum  reliability.  It  features  a  large  LCD  display (128 x 64) for menus and error messages and a modular,  detachable  socket  assembly  to  support  various package types. The ICSPGLYPH<153> cable assembly is included as a standard item. In Stand-Alone mode, the MPLAB PM3 Device Programmer can read, verify and program PIC devices without a PC connection. It can also set code  protection in this mode.  The  MPLAB  PM3 connects to the host PC via an RS-232 or USB cable. The MPLAB PM3 has high-speed communications and optimized  algorithms  for  quick  programming  of  large memory devices and incorporates an SD/MMC card for file storage and secure data applications.",
    "25.11 PICSTART Plus Development Programmer\nThe PICSTART Plus Development Programmer is an easy-to-use, low-cost, prototype programmer. It connects to the PC via a COM (RS-232) port. MPLAB Integrated Development Environment software makes using the programmer simple and efficient. The PICSTART  Plus  Development  Programmer  supports most  PIC  devices  in  DIP  packages  up  to  40  pins. Larger pin count devices, such as the PIC16C92X and PIC17C76X, may be supported with an adapter socket. The PICSTART Plus Development Programmer is CE compliant.",
    "25.12 PICkit 2 Development Programmer\nThe PICkitGLYPH<153> 2 Development Programmer is a low-cost programmer and selected Flash device debugger with an  easy-to-use  interface  for  programming  many  of MicrochipGLYPH<146>s baseline, mid-range and PIC18F families of Flash memory microcontrollers. The PICkit 2 Starter Kit includes  a  prototyping  development  board,  twelve sequential  lessons,  software  and  HI-TECHGLYPH<146>s  PICCGLYPH<153> Lite C compiler, and is designed to help get up to speed quickly using PIC fi microcontrollers.  The  kit  provides everything needed to program, evaluate and develop applications using  MicrochipGLYPH<146>s powerful,  mid-range Flash memory family of microcontrollers.",
    "25.13 Demonstration, Development and Evaluation Boards\nA  wide  variety  of demonstration,  development  and evaluation  boards  for  various  PIC  MCUs  and  dsPIC DSCs allows quick application development on fully functional systems. Most boards include prototyping areas for adding custom circuitry and provide application firmware and source code for examination and modification.\nThe boards support a variety of features, including LEDs, temperature sensors, switches, speakers, RS-232 interfaces, LCD displays, potentiometers and additional EEPROM memory.\nThe  demonstration  and  development  boards  can  be used in teaching environments, for prototyping custom circuits and for learning about various microcontroller applications.\nIn addition to the PICDEMGLYPH<153> and dsPICDEMGLYPH<153> demonstration/development board series of circuits, Microchip has a line of evaluation kits and demonstration software for  analog  filter  design,  KEELOQ fi security  ICs,  CAN, IrDA fi , PowerSmart  battery  management,  SEEVAL fi evaluation system, Sigma-Delta ADC, flow rate sensing, plus many more.\nCheck the Microchip web page (www.microchip.com) for  the  complete  list  of  demonstration,  development and evaluation kits.",
    "Absolute Maximum Ratings (GLYPH<134>)\nAmbient temperature under bias.............................................................................................................-40GLYPH<176>C to +125GLYPH<176>C",
    "Absolute Maximum Ratings (GLYPH<134>)\nStorage temperature .............................................................................................................................. -65GLYPH<176>C to +150GLYPH<176>C\nVoltage on any pin with respect to VSS (except VDD and MCLR) ................................................... -0.3V to (VDD + 0.3V)",
    "Absolute Maximum Ratings (GLYPH<134>)\nVoltage on VDD with respect to VSS  .........................................................................................................  -0.3V to +7.5V\nVoltage on MCLR with respect to VSS (Note 2)\n......................................................................................... 0V to +13.25V\nTotal power dissipation (Note 1)",
    "Absolute Maximum Ratings (GLYPH<134>)\n...............................................................................................................................1.0W",
    "Absolute Maximum Ratings (GLYPH<134>)\nMaximum current out of VSS pin ...........................................................................................................................300 mA",
    "Absolute Maximum Ratings (GLYPH<134>)\nMaximum current into VDD pin ..............................................................................................................................250 mA\nInput clamp current, IIK (VI < 0 or VI > VDD)",
    "Absolute Maximum Ratings (GLYPH<134>)\n...................................................................................................................... \u00b1\n20 mA\nOutput clamp current, IOK (VO < 0 or VO > VDD)",
    "Absolute Maximum Ratings (GLYPH<134>)\n.............................................................................................................. \u00b1\n20 mA\nMaximum output current sunk by any I/O pin..........................................................................................................25 mA",
    "Absolute Maximum Ratings (GLYPH<134>)\nMaximum output current sourced by any I/O pin ....................................................................................................25 mA\nMaximum current sunk by all ports .......................................................................................................................200 mA",
    "Absolute Maximum Ratings (GLYPH<134>)\nMaximum current sourced by all ports ..................................................................................................................200 mA\nNote 1: Power dissipation is calculated as follows:\nPdis = VDD x {IDD GLYPH<150> \u2211 IOH} + \u2211 {(VDD GLYPH<150> VOH) x IOH} + \u2211 (VOL x IOL)",
    "Absolute Maximum Ratings (GLYPH<134>)\n- 2: Voltage spikes below VSS at the MCLR/VPP/RG5 pin, inducing currents greater than 80 mA, may cause latch-up. Thus, a series resistor of 50-100 \u03a9 should be used when applying a GLYPH<147>lowGLYPH<148> level to the MCLR/VPP/ RG5 pin, rather than pulling this pin directly to VSS.\nGLYPH<134> NOTICE: Stresses above those listed under GLYPH<147>Absolute Maximum RatingsGLYPH<148> may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure to maximum rating conditions for extended periods may affect device reliability.",
    "PIC18F6390/6490/8390/8490\n26.1 DC Characteristics:",
    "Supply Voltage PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial)\nPIC18LF6390/6490/8390/8490 (Industrial)\nPIC18F6390/6490/8390/8490\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nOperating temperature\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial",
    "Supply Voltage PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial)\nD001, Symbol = VDD. D001, Characteristic = Supply Voltage. D001, Min = Supply Voltage. D001, Typ = Supply Voltage. D001, Max = Supply Voltage. D001, Units = Supply Voltage. D001, Conditions = Supply Voltage. D001, Symbol = VDD. D001, Characteristic = PIC18LF6390/6490/8390/8490. D001, Min = 2.0. D001, Typ = GLYPH<151>. D001, Max = 5.5. D001, Units = V. D001, Conditions = HS, XT, RC and LP Oscillator modes. D001, Symbol = VDD. D001, Characteristic = PIC18F6390/6490/8390/8490. D001, Min = 4.2. D001, Typ = GLYPH<151>. D001, Max =",
    "Supply Voltage PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial)\n5.5. D001, Units = V. D001, Conditions = . D002, Symbol = VDR. D002, Characteristic = RAM Data Retention Voltage (1). D002, Min = 1.5. D002, Typ = GLYPH<151>. D002, Max = GLYPH<151>. D002, Units = V. D002, Conditions = . D003, Symbol = VPOR. D003, Characteristic = VDD Start Voltage to Ensure Internal Power-on Reset Signal. D003, Min = GLYPH<151>. D003, Typ = GLYPH<151>. D003, Max = 0.7. D003, Units = V. D003, Conditions = See section on Power-on Reset for details. D004, Symbol = SVDD. D004, Characteristic = VDD Rise Rate to Ensure Internal Power-on Reset Signal. D004, Min =",
    "Supply Voltage PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial)\n0.05. D004, Typ = GLYPH<151>. D004, Max = GLYPH<151>. D004, Units = V/ms. D004, Conditions = See section on Power-on Reset for details. D005, Symbol = VBOR. D005, Characteristic = Brown-out Reset Voltage. D005, Min = Brown-out Reset Voltage. D005, Typ = Brown-out Reset Voltage. D005, Max = Brown-out Reset Voltage. D005, Units = Brown-out Reset Voltage. D005, Conditions = Brown-out Reset Voltage. D005, Symbol = VBOR. D005, Characteristic = PIC18LF6390/6490/8390/8490. D005, Min = . D005, Typ = . D005, Max = . D005, Units = . D005, Conditions = . D005, Symbol = VBOR.",
    "Supply Voltage PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial)\nD005, Characteristic = BORV1:BORV0 = 11. D005, Min = 2.00. D005, Typ = 2.05. D005, Max = 2.16. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 10. D005, Min = 2.65. D005, Typ = 2.79. D005, Max = 2.93. D005, Units = V. D005, Conditions = . D005, Symbol = . D005, Characteristic = All devices. D005, Min = . D005, Typ = . D005, Max = . D005, Units = . D005, Conditions = . D005, Symbol = . D005, Characteristic = BORV1:BORV0 = 01. D005,",
    "Supply Voltage PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial)\nMin = 4.11. D005, Typ = 4.33. D005, Max = 4.55. D005, Units = V. D005, Conditions = . D005, Symbol = . D005, Characteristic = BORV1:BORV0 = 00. D005, Min = 4.36. D005, Typ = 4.59. D005, Max = 4.82. D005, Units = V. D005, Conditions = \nLegend:\nShading of rows is to assist in readability of the table.\nNote 1: This is the limit to which VDD can be lowered in Sleep mode, or during a device Reset, without losing RAM data.",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial)\nPIC18LF6390/6490/8390/8490\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial\nPIC18F6390/6490/8390/8490\n(Industrial)\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial)\n, Device = Power-Down Current (I PD) (1). , Typ = Power-Down Current (I PD) (1). , Max = Power-Down Current (I PD) (1). , Units = Power-Down Current (I PD) (1). , Conditions = Power-Down Current (I PD) (1). , Conditions = Power-Down Current (I PD) (1). , Device = PIC18LF6390/6490/8390/8490. , Typ = 0.1. , Max = 1. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 2.0V ( Sleep mode). , Device = 0.1 1. , Typ = . , Max = . , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 2.0V ( Sleep mode). , Device = 0.2 5.",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial)\n, Typ = . , Max = . , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 2.0V ( Sleep mode). , Device = PIC18LF6390/6490/8390/8490. , Typ = 0.1. , Max = 2. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V ( Sleep mode). , Device = 0.1 2. , Typ = . , Max = . , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 3.0V ( Sleep mode). , Device = 0.3. , Typ = . , Max = 8. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 3.0V ( Sleep mode). , Device = All devices. ,",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial)\nTyp = 0.1. , Max = 2.0. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V ( Sleep mode). , Device = 0.1. , Typ = . , Max = 2.0. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V ( Sleep mode). , Device = 0.4. , Typ = . , Max = 15. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 5.0V ( Sleep mode)\nLegend:\nShading of rows is to assist in readability of the table.",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial)\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD or VSS;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial)\n3: Low-power Timer1 oscillator selected.\n4: BOR and HLVD enable internal band gap reference. With both modules enabled, current consumption will be less than the sum of both specifications.\n26.2 DC Characteristics:",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nPIC18LF6390/6490/8390/8490\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nOperating temperature\n-40GLYPH<176>C\n\u2264\nTA\n\u2264\n+85GLYPH<176>C for industrial\nPIC18F6390/6490/8390/8490 (Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C TA +85GLYPH<176>C for industrial\n\u2264 \u2264",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n, Device = Supply Current (I DD) (2). , Typ = Supply Current (I DD) (2). , Max = Supply Current (I DD) (2). , Units = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Device = PIC18LF6390/6490/8390/8490. , Typ = 12. , Max = 26. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 12. , Max = 24. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n2.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 12. , Max = 23. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 32. , Max = 50. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 27. , Max = 48. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nPIC18LF6390/6490/8390/8490. , Typ = 22. , Max = 46. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = All devices. , Typ = 84. , Max = 134. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 82. , Max = 128. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 72. , Max = 128. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . ,",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nDevice = PIC18LF6390/6490/8390/8490. , Typ = .26. , Max = .8. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = .26. , Max = .8. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = .26. , Max = .8. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. ,",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nTyp = .48. , Max = 1.04. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = . , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = .44. , Max = .96. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = . , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = .48. , Max = .88. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = . , Conditions = . , Device = All devices. , Typ = .88. , Max = 1.84. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. ,",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nTyp = .88. , Max = 1.76. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = .8. , Max = 1.68. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = ",
    "Legend:\nShading of rows is to assist in readability of the table.\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD or VSS;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend:\n3: Low-power Timer1 oscillator selected.\n4: BOR and HLVD enable internal band gap reference. With both modules enabled, current consumption will be less than the sum of both specifications.",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nPIC18LF6390/6490/8390/8490\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C\n\u2264\nTA\n\u2264\n+85GLYPH<176>C for industrial\nPIC18F6390/6490/8390/8490\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n, Device = Supply Current (I DD) (2). , Typ = Supply Current (I DD) (2). , Max = Supply Current (I DD) (2). , Units = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Device = PIC18LF6390/6490/8390/8490. , Typ = 0.6. , Max = 1.7. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 0.6. , Max = 1.6. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n= VDD = 2.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 0.6. , Max = 1.5. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 1.0. , Max = 2.4. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 1.0. , Max = 2.4. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = .",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n, Device = PIC18LF6390/6490/8390/8490. , Typ = 1.0. , Max = 2.4. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = All devices. , Typ = 2.0. , Max = 4.2. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 2.0. , Max = 4. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 2.0. , Max = 3.8. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nVDD = 5.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 2.3. , Max = 6.4. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 2.5. , Max = 6.4. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 2.9. , Max = 8.8. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n= . , Device = PIC18LF6390/6490/8390/8490. , Typ = 3.6. , Max = 8.8. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = . , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 3.8. , Max = 8.8. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = . , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 4.6. , Max = 12. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = . , Conditions = . , Device = All devices. , Typ = 7.4. , Max = 16. , Units = \u03bc A. , Conditions =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n-40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 7.8. , Max = 16. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 9.1. , Max = 29. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = \nLegend:\nShading of rows is to assist in readability of the table.\nNote 1:",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nThe power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD or VSS;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n3: Low-power Timer1 oscillator selected.\n4: BOR and HLVD enable internal band gap reference. With both modules enabled, current consumption will be less than the sum of both specifications.\n26.2 DC Characteristics:\nPIC18LF6390/6490/8390/8490\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C\n\u2264\nTA\n\u2264\n+85GLYPH<176>C for industrial\nPIC18F6390/6490/8390/8490 (Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C TA +85GLYPH<176>C for industrial\n\u2264 \u2264",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n, Device = Supply Current (I DD) (2). , Typ = Supply Current (I DD) (2). , Max = Supply Current (I DD) (2). , Units = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Device = PIC18LF6390/6490/8390/8490. , Typ = 132. , Max = 400. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 140. , Max = 400. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n2.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 152. , Max = 400. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 200. , Max = 600. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 216. , Max = 600. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nPIC18LF6390/6490/8390/8490. , Typ = 252. , Max = 600. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = All devices. , Typ = 0.40. , Max = 1. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 0.42. , Max = 1. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 0.44. , Max = 1. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n= . , Device = PIC18LF6390/6490/8390/8490. , Typ = 272. , Max = 700. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 280. , Max = 700. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 288. , Max = 700. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. ,",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nTyp = 0.416. , Max = 1. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = . , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 0.432. , Max = 1. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = . , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 0.464. , Max = 1. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = . , Conditions = . , Device = All devices. , Typ = .8. , Max = 1.6. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\ndevices. , Typ = .9. , Max = 1.6. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = .9. , Max = 1.6. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = ",
    "Legend:\nShading of rows is to assist in readability of the table.",
    "Note\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD or VSS;\nMCLR = VDD; WDT enabled/disabled as specified.\n3: Low-power Timer1 oscillator selected.\n4: BOR and HLVD enable internal band gap reference. With both modules enabled, current consumption will be less than the sum of both specifications.",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nPIC18LF6390/6490/8390/8490\n(Industrial)\nPIC18F6390/6490/8390/8490\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C\n\u2264\nTA\n\u2264\n+85GLYPH<176>C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nOperating temperature\n-40GLYPH<176>C \u2264 TA \u2264\n+85GLYPH<176>C for industrial",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n, Device = Supply Current (I DD) (2). , Typ = Supply Current (I DD) (2). , Max = Supply Current (I DD) (2). , Units = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Device = PIC18LF6390/6490/8390/8490. , Typ = 250. , Max = 500. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 2.0V. , Conditions = FOSC = 1 MHZ ( PRI_RUN , EC oscillator). , Device = . , Typ = 260. , Max = 500. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n2.0V. , Conditions = FOSC = 1 MHZ ( PRI_RUN , EC oscillator). , Device = . , Typ = 250. , Max = 500. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 2.0V. , Conditions = FOSC = 1 MHZ ( PRI_RUN , EC oscillator). , Device = PIC18LF6390/6490/8390/8490. , Typ = 550. , Max = 650. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHZ ( PRI_RUN , EC oscillator). , Device = . , Typ = 480. , Max = 650. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n3.0V. , Conditions = FOSC = 1 MHZ ( PRI_RUN , EC oscillator). , Device = . , Typ = 460. , Max = 650. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHZ ( PRI_RUN , EC oscillator). , Device = All devices. , Typ = 1.2. , Max = 1.6. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 1 MHZ ( PRI_RUN , EC oscillator). , Device = . , Typ = 1.1. , Max = 1.5. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nFOSC = 1 MHZ ( PRI_RUN , EC oscillator). , Device = . , Typ = 1.0. , Max = 1.4. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 1 MHZ ( PRI_RUN , EC oscillator). , Device = PIC18LF6390/6490/8390/8490. , Typ = 0.72. , Max = 2.0. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = . , Conditions = FOSC = 4 MHz ( PRI_RUN , EC oscillator). , Device = . , Typ = 0.74. , Max = 2.0. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = . , Conditions = FOSC = 4 MHz",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n( PRI_RUN , EC oscillator). , Device = . , Typ = 0.74. , Max = 2.0. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = . , Conditions = FOSC = 4 MHz ( PRI_RUN , EC oscillator). , Device = PIC18LF6390/6490/8390/8490. , Typ = 1.3. , Max = 3.0. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz ( PRI_RUN , EC oscillator). , Device = . , Typ = 1.3. , Max = 3.0. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nMHz ( PRI_RUN , EC oscillator). , Device = . , Typ = 1.3. , Max = 3.0. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz ( PRI_RUN , EC oscillator). , Device = All devices. , Typ = 2.7. , Max = 6.0. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHz ( PRI_RUN , EC oscillator). , Device = . , Typ = 2.6. , Max = 6.0. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHz ( PRI_RUN",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n, EC oscillator). , Device = . , Typ = 2.5. , Max = 6.0. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHz ( PRI_RUN , EC oscillator). , Device = All devices. , Typ = 15. , Max = 35. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = . , Conditions = FOSC = 40 MHZ ( PRI_RUN , EC oscillator). , Device = . , Typ = 16. , Max = 35. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = . , Conditions = FOSC = 40 MHZ ( PRI_RUN , EC oscillator). , Device = . , Typ = 16. , Max = 35. , Units =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nmA. , Conditions = +85GLYPH<176>C. , Conditions = . , Conditions = FOSC = 40 MHZ ( PRI_RUN , EC oscillator). , Device = All devices. , Typ = 21. , Max = 40. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHZ ( PRI_RUN , EC oscillator). , Device = . , Typ = 21. , Max = 40. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHZ ( PRI_RUN , EC oscillator). , Device = . , Typ = 21. , Max = 40. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = VDD =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n5.0V. , Conditions = FOSC = 40 MHZ ( PRI_RUN , EC oscillator)\nLegend:\nShading of rows is to assist in readability of the table.\nThe power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that\nNote 1: add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD or VSS;\nMCLR = VDD; WDT enabled/disabled as specified.\n3: Low-power Timer1 oscillator selected.\n4: BOR and HLVD enable internal band gap reference. With both modules enabled, current consumption will be less than the sum of both specifications.\n26.2 DC Characteristics:\nPIC18LF6390/6490/8390/8490\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C\n\u2264\nTA\n\u2264\n+85GLYPH<176>C for industrial\nPIC18F6390/6490/8390/8490 (Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C TA +85GLYPH<176>C for industrial\n\u2264 \u2264",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n, Device = Supply Current (I DD) (2). , Typ = . , Max = . , Units = . , Conditions = . , Conditions = . , Conditions = . , Device = All devices. , Typ = 7.5. , Max = 16. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 4 MHZ. 16 MHz internal ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 7.4. , Max = 15. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 4 MHZ. 16 MHz internal ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 7.3. , Max = 14. , Units = mA. , Conditions =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n+85GLYPH<176>C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 4 MHZ. 16 MHz internal ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 10. , Max = 21. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHZ, 16 MHz internal ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 10. , Max = 20. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHZ, 16 MHz internal ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 9.7. , Max = 19. , Units = mA. , Conditions =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n+85GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHZ, 16 MHz internal ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 17. , Max = 35. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 10 MHZ, 40 MHz internal ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 17. , Max = 35. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 10 MHZ, 40 MHz internal ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 17. , Max = 35. , Units = mA. , Conditions =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n+85GLYPH<176>C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 10 MHZ, 40 MHz internal ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 23. , Max = 40. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 10 MHZ, 40 MHz internal ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 23. , Max = 40. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 10 MHZ, 40 MHz internal ( PRI_RUN HS+PLL ). , Device = All devices. , Typ = 23. , Max = 40. , Units = mA. , Conditions =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n+85GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 10 MHZ, 40 MHz internal ( PRI_RUN HS+PLL )\nLegend:\nShading of rows is to assist in readability of the table.\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD or VSS;\nMCLR = VDD; WDT enabled/disabled as specified.\n3: Low-power Timer1 oscillator selected.\n4: BOR and HLVD enable internal band gap reference. With both modules enabled, current consumption will be less than the sum of both specifications.\nPIC18LF6390/6490/8390/8490\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18F6390/6490/8390/8490\nOperating temperature\n-40GLYPH<176>C\n\u2264\nTA\n\u2264\n+85GLYPH<176>C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nOperating temperature\n-40GLYPH<176>C \u2264 TA \u2264\n+85GLYPH<176>C for industrial",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n, Device = Supply Current (I DD) (2). , Typ = Supply Current (I DD) (2). , Max = Supply Current (I DD) (2). , Units = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Device = PIC18LF6390/6490/8390/8490. , Typ = 59. , Max = 117. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 2.0V. , Conditions = FOSC = 1 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ = 59. , Max = 108. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n= 2.0V. , Conditions = FOSC = 1 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ = 63. , Max = 104. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 2.0V. , Conditions = FOSC = 1 MHz ( PRI_IDLE mode, EC oscillator). , Device = PIC18LF6390/6490/8390/8490. , Typ = 108. , Max = 243. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ = 108. , Max = 225. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nVDD = 3.0V. , Conditions = FOSC = 1 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ = 117. , Max = 216. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHz ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ = 270. , Max = 432. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 1 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ = 216. , Max = 405. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n= FOSC = 1 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ = 270. , Max = 387. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 1 MHz ( PRI_IDLE mode, EC oscillator). , Device = PIC18LF6390/6490/8390/8490. , Typ = 234. , Max = 428. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = . , Conditions = FOSC = 4 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ = 230. , Max = 405. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = . , Conditions = FOSC = 4 MHz (",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nPRI_IDLE mode, EC oscillator). , Device = . , Typ = 243. , Max = 387. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = . , Conditions = FOSC = 4 MHz ( PRI_IDLE mode, EC oscillator). , Device = PIC18LF6390/6490/8390/8490. , Typ = 378. , Max = 810. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ = 387. , Max = 765. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz (",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nPRI_IDLE mode, EC oscillator). , Device = . , Typ = 405. , Max = 729. , Units = \u03bc A. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ = .8. , Max = 1.35. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 4 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ = .8. , Max = 1.26. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 4 MHz ( PRI_IDLE mode, EC",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\noscillator). , Device = . , Typ = .8. , Max = 1.17. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 4 MHz ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ = 5.4. , Max = 14.4. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = . , Conditions = FOSC = 40 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ = 5.6. , Max = 14.4. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = . , Conditions = FOSC = 40 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n5.9. , Max = 14.4. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = . , Conditions = FOSC = 40 MHz ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ = 7.3. , Max = 16.2. , Units = mA. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ = 8.2. , Max = 16.2. , Units = mA. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHz ( PRI_IDLE mode, EC oscillator). , Device = . , Typ = 7.5. , Max =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n16.2. , Units = mA. , Conditions = +85GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHz ( PRI_IDLE mode, EC oscillator)\nLegend:\nShading of rows is to assist in readability of the table.\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD or VSS;\nMCLR = VDD; WDT enabled/disabled as specified.\n3: Low-power Timer1 oscillator selected.\n4: BOR and HLVD enable internal band gap reference. With both modules enabled, current consumption will be less than the sum of both specifications.\n26.2 DC Characteristics:\nPIC18LF6390/6490/8390/8490\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C\n\u2264\nTA\n\u2264\n+85GLYPH<176>C for industrial\nPIC18F6390/6490/8390/8490 (Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C TA +85GLYPH<176>C for industrial\n\u2264 \u2264",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n, Device = Supply Current (I DD) (2). , Typ = Supply Current (I DD) (2). , Max = Supply Current (I DD) (2). , Units = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Conditions = Supply Current (I DD) (2). , Device = PIC18LF6390/6490/8390/8490. , Typ = 13. , Max = 40. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 14. , Max = 40. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n2.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 16. , Max = 40. , Units = \u03bc A. , Conditions = +80GLYPH<176>C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 34. , Max = 70. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 31. , Max = 70. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nPIC18LF6390/6490/8390/8490. , Typ = 28. , Max = 70. , Units = \u03bc A. , Conditions = +80GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = All devices. , Typ = 72. , Max = 150. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 65. , Max = 150. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 59. , Max = 150. , Units = \u03bc A. , Conditions = +80GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . ,",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nDevice = PIC18LF6390/6490/8390/8490. , Typ = 5.5. , Max = 15. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 5.8. , Max = 15. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 6.1. , Max = 18. , Units = \u03bc A. , Conditions = +80GLYPH<176>C. , Conditions = VDD = 3.0V. , Conditions = . , Device =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nPIC18LF6390/6490/8390/8490. , Typ = 8.2. , Max = 30. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = . , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 8.6. , Max = 30. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = . , Conditions = . , Device = PIC18LF6390/6490/8390/8490. , Typ = 8.8. , Max = 35. , Units = \u03bc A. , Conditions = +80GLYPH<176>C. , Conditions = . , Conditions = . , Device = All devices. , Typ = 13. , Max = 80. , Units = \u03bc A. , Conditions = -40GLYPH<176>C. , Conditions = VDD",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n= 5.0V. , Conditions = . , Device = All devices. , Typ = 13. , Max = 80. , Units = \u03bc A. , Conditions = +25GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 13. , Max = 85. , Units = \u03bc A. , Conditions = +80GLYPH<176>C. , Conditions = VDD = 5.0V. , Conditions = ",
    "Legend:\nShading of rows is to assist in readability of the table.",
    "Note\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD or VSS;\nMCLR = VDD; WDT enabled/disabled as specified.\n3: Low-power Timer1 oscillator selected.\n4: BOR and HLVD enable internal band gap reference. With both modules enabled, current consumption will be less than the sum of both specifications.",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nPIC18LF6390/6490/8390/8490\n(Industrial)\nPIC18F6390/6490/8390/8490\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C\n\u2264\nTA\n\u2264\n+85GLYPH<176>C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nOperating temperature\n-40GLYPH<176>C \u2264 TA \u2264\n+85GLYPH<176>C for industrial",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nD022 ( \u0394 I WDT), Device = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). D022 ( \u0394 I WDT), Typ = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). D022 ( \u0394 I WDT), Max = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). D022 ( \u0394 I WDT), Units = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). D022 ( \u0394 I WDT), Conditions = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nLVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). D022 ( \u0394 I WDT), Conditions = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). D022 ( \u0394 I WDT), Conditions = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). D022 ( \u0394 I WDT), Device = Watchdog Timer. D022 ( \u0394 I WDT), Typ = 1.7. D022 ( \u0394 I WDT), Max = 4. D022 ( \u0394 I WDT), Units = \u03bc A. D022 ( \u0394 I WDT), Conditions = -40GLYPH<176>C. D022 ( \u0394 I WDT), Conditions = VDD = 2.0V.",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nD022 ( \u0394 I WDT), Conditions = . D022 ( \u0394 I WDT), Device = Watchdog Timer. D022 ( \u0394 I WDT), Typ = 2.1. D022 ( \u0394 I WDT), Max = 4. D022 ( \u0394 I WDT), Units = \u03bc A. D022 ( \u0394 I WDT), Conditions = +25GLYPH<176>C. D022 ( \u0394 I WDT), Conditions = VDD = 2.0V. D022 ( \u0394 I WDT), Conditions = . D022 ( \u0394 I WDT), Device = Watchdog Timer. D022 ( \u0394 I WDT), Typ = 2.6. D022 ( \u0394 I WDT), Max = 5. D022 ( \u0394 I WDT), Units = \u03bc A. D022 ( \u0394 I WDT), Conditions =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n+85GLYPH<176>C. D022 ( \u0394 I WDT), Conditions = VDD = 2.0V. D022 ( \u0394 I WDT), Conditions = . D022 ( \u0394 I WDT), Device = Watchdog Timer. D022 ( \u0394 I WDT), Typ = 2.2. D022 ( \u0394 I WDT), Max = 6. D022 ( \u0394 I WDT), Units = \u03bc A. D022 ( \u0394 I WDT), Conditions = -40GLYPH<176>C. D022 ( \u0394 I WDT), Conditions = VDD = 3.0V. D022 ( \u0394 I WDT), Conditions = . D022 ( \u0394 I WDT), Device = Watchdog Timer. D022 ( \u0394 I WDT), Typ = 2.4. D022 ( \u0394 I WDT), Max = 6. D022 ( \u0394 I",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nWDT), Units = \u03bc A. D022 ( \u0394 I WDT), Conditions = +25GLYPH<176>C. D022 ( \u0394 I WDT), Conditions = VDD = 3.0V. D022 ( \u0394 I WDT), Conditions = . D022 ( \u0394 I WDT), Device = Watchdog Timer. D022 ( \u0394 I WDT), Typ = 2.8. D022 ( \u0394 I WDT), Max = 7. D022 ( \u0394 I WDT), Units = \u03bc A. D022 ( \u0394 I WDT), Conditions = +85GLYPH<176>C. D022 ( \u0394 I WDT), Conditions = VDD = 3.0V. D022 ( \u0394 I WDT), Conditions = . D022 ( \u0394 I WDT), Device = Watchdog Timer. D022 ( \u0394 I WDT), Typ =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n2.9. D022 ( \u0394 I WDT), Max = 10. D022 ( \u0394 I WDT), Units = \u03bc A. D022 ( \u0394 I WDT), Conditions = -40GLYPH<176>C. D022 ( \u0394 I WDT), Conditions = VDD = 5.0V. D022 ( \u0394 I WDT), Conditions = . D022 ( \u0394 I WDT), Device = Watchdog Timer. D022 ( \u0394 I WDT), Typ = 3.1. D022 ( \u0394 I WDT), Max = 10. D022 ( \u0394 I WDT), Units = \u03bc A. D022 ( \u0394 I WDT), Conditions = +25GLYPH<176>C. D022 ( \u0394 I WDT), Conditions = VDD = 5.0V. D022 ( \u0394 I WDT), Conditions = . D022 ( \u0394 I",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nWDT), Device = Watchdog Timer. D022 ( \u0394 I WDT), Typ = 3.3. D022 ( \u0394 I WDT), Max = 13. D022 ( \u0394 I WDT), Units = \u03bc A. D022 ( \u0394 I WDT), Conditions = +85GLYPH<176>C. D022 ( \u0394 I WDT), Conditions = VDD = 5.0V. D022 ( \u0394 I WDT), Conditions = . D022A ( \u0394 I BOR), Device = Brown-out Reset. D022A ( \u0394 I BOR), Typ = 17. D022A ( \u0394 I BOR), Max = 50. D022A ( \u0394 I BOR), Units = \u03bc A. D022A ( \u0394 I BOR), Conditions = -40 \u00b0 C to +85 \u00b0 C. D022A ( \u0394 I BOR), Conditions =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nVDD = 3.0V. D022A ( \u0394 I BOR), Conditions = . D022A ( \u0394 I BOR), Device = Brown-out Reset. D022A ( \u0394 I BOR), Typ = 42. D022A ( \u0394 I BOR), Max = 60. D022A ( \u0394 I BOR), Units = \u03bc A. D022A ( \u0394 I BOR), Conditions = -40 \u00b0 C to +85 \u00b0 C. D022A ( \u0394 I BOR), Conditions = VDD = 5.0V. D022A ( \u0394 I BOR), Conditions = . D022B ( \u0394 I LVD), Device = High/Low-Voltage Detect. D022B ( \u0394 I LVD), Typ = 14. D022B ( \u0394 I LVD), Max = 38. D022B ( \u0394 I LVD), Units = \u03bc",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nA. D022B ( \u0394 I LVD), Conditions = -40 \u00b0 C to +85 \u00b0 C. D022B ( \u0394 I LVD), Conditions = VDD = 2.0V. D022B ( \u0394 I LVD), Conditions = . D022B ( \u0394 I LVD), Device = High/Low-Voltage Detect. D022B ( \u0394 I LVD), Typ = 18. D022B ( \u0394 I LVD), Max = 40. D022B ( \u0394 I LVD), Units = \u03bc A. D022B ( \u0394 I LVD), Conditions = -40 \u00b0 C to +85 \u00b0 C. D022B ( \u0394 I LVD), Conditions = VDD = 3.0V. D022B ( \u0394 I LVD), Conditions = . D022B ( \u0394 I LVD), Device = High/Low-Voltage Detect. D022B ( \u0394",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nI LVD), Typ = 21. D022B ( \u0394 I LVD), Max = 45. D022B ( \u0394 I LVD), Units = \u03bc A. D022B ( \u0394 I LVD), Conditions = -40 \u00b0 C to +85 \u00b0 C. D022B ( \u0394 I LVD), Conditions = VDD = 5.0V. D022B ( \u0394 I LVD), Conditions = . D024 ( \u0394 I LCD), Device = LCD Module. D024 ( \u0394 I LCD), Typ = 1.5. D024 ( \u0394 I LCD), Max = 3. D024 ( \u0394 I LCD), Units = \u03bc A. D024 ( \u0394 I LCD), Conditions = -40GLYPH<176>C. D024 ( \u0394 I LCD), Conditions = VDD = 2.0V. D024 ( \u0394 I LCD), Conditions = LCD on INTRC",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nclock, LCD segments enabled.. D024 ( \u0394 I LCD), Device = LCD Module. D024 ( \u0394 I LCD), Typ = 1.5. D024 ( \u0394 I LCD), Max = 3. D024 ( \u0394 I LCD), Units = \u03bc A. D024 ( \u0394 I LCD), Conditions = +25GLYPH<176>C. D024 ( \u0394 I LCD), Conditions = VDD = 2.0V. D024 ( \u0394 I LCD), Conditions = LCD on INTRC clock, LCD segments enabled.. D024 ( \u0394 I LCD), Device = LCD Module. D024 ( \u0394 I LCD), Typ = 1.7. D024 ( \u0394 I LCD), Max = 4. D024 ( \u0394 I LCD), Units = \u03bc A. D024 ( \u0394 I LCD), Conditions = +85GLYPH<176>C. D024 ( \u0394 I LCD),",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nConditions = VDD = 2.0V. D024 ( \u0394 I LCD), Conditions = LCD on INTRC clock, LCD segments enabled.. D024 ( \u0394 I LCD), Device = LCD Module. D024 ( \u0394 I LCD), Typ = 2.2. D024 ( \u0394 I LCD), Max = 5. D024 ( \u0394 I LCD), Units = \u03bc A. D024 ( \u0394 I LCD), Conditions = -40GLYPH<176>C. D024 ( \u0394 I LCD), Conditions = VDD = 3.0V. D024 ( \u0394 I LCD), Conditions = LCD on INTRC clock, LCD segments enabled.. D024 ( \u0394 I LCD), Device = LCD Module. D024 ( \u0394 I LCD), Typ = 2.5. D024 ( \u0394 I LCD), Max = 5. D024 ( \u0394 I LCD), Units = \u03bc A. D024 (",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n\u0394 I LCD), Conditions = +25GLYPH<176>C. D024 ( \u0394 I LCD), Conditions = VDD = 3.0V. D024 ( \u0394 I LCD), Conditions = LCD on INTRC clock, LCD segments enabled.. D024 ( \u0394 I LCD), Device = LCD Module. D024 ( \u0394 I LCD), Typ = 2.7. D024 ( \u0394 I LCD), Max = 6. D024 ( \u0394 I LCD), Units = \u03bc A. D024 ( \u0394 I LCD), Conditions = +85GLYPH<176>C. D024 ( \u0394 I LCD), Conditions = VDD = 5.0V. D024 ( \u0394 I LCD), Conditions = . D024 ( \u0394 I LCD), Device = LCD Module. D024 ( \u0394 I LCD), Typ = 6.1. D024 ( \u0394 I LCD), Max = 10. D024",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n( \u0394 I LCD), Units = \u03bc A. D024 ( \u0394 I LCD), Conditions = -40GLYPH<176>C. D024 ( \u0394 I LCD), Conditions = . D024 ( \u0394 I LCD), Conditions = LCD on INTRC clock, LCD segments enabled.. D024 ( \u0394 I LCD), Device = LCD Module. D024 ( \u0394 I LCD), Typ = 6.5. D024 ( \u0394 I LCD), Max = 10. D024 ( \u0394 I LCD), Units = \u03bc A. D024 ( \u0394 I LCD), Conditions = +25GLYPH<176>C. D024 ( \u0394 I LCD), Conditions = . D024 ( \u0394 I LCD), Conditions = LCD on INTRC clock, LCD segments enabled.. D024 ( \u0394 I LCD), Device = LCD Module. D024 ( \u0394 I LCD), Typ = 7.2. D024 ( \u0394",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nI LCD), Max = 10. D024 ( \u0394 I LCD), Units = \u03bc A. D024 ( \u0394 I LCD), Conditions = +85GLYPH<176>C. D024 ( \u0394 I LCD), Conditions = . D024 ( \u0394 I LCD), Conditions = LCD on INTRC clock, LCD segments enabled.",
    "Legend:\nShading of rows is to assist in readability of the table.\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD or VSS;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend:\n3: Low-power Timer1 oscillator selected.\n4: BOR and HLVD enable internal band gap reference. With both modules enabled, current consumption will be less than the sum of both specifications.",
    "PIC18F6390/6490/8390/8490\n26.2 DC Characteristics:",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nPIC18LF6390/6490/8390/8490 (Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial\nPIC18F6390/6490/8390/8490 (Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n, Device = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). , Typ = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). , Max = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). , Units = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). , Conditions = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). , Conditions = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nOSCB, \u0394 I AD). , Conditions = Module Differential Currents ( \u0394 I WDT, \u0394 I BOR, \u0394 I LVD, \u0394 I LCD, \u0394 I OSCB, \u0394 I AD). D025 ( \u0394 I OSCB), Device = Timer1 Oscillator. D025 ( \u0394 I OSCB), Typ = 1.0. D025 ( \u0394 I OSCB), Max = 3.5. D025 ( \u0394 I OSCB), Units = \u03bc A. D025 ( \u0394 I OSCB), Conditions = -10 \u00b0 C. D025 ( \u0394 I OSCB), Conditions = VDD = 2.0V. D025 ( \u0394 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \u0394 I OSCB), Device = . D025 ( \u0394 I OSCB), Typ = 1.1. D025 ( \u0394 I OSCB), Max =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n3.5. D025 ( \u0394 I OSCB), Units = \u03bc A. D025 ( \u0394 I OSCB), Conditions = +25 \u00b0 C. D025 ( \u0394 I OSCB), Conditions = VDD = 2.0V. D025 ( \u0394 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \u0394 I OSCB), Device = . D025 ( \u0394 I OSCB), Typ = 1.1. D025 ( \u0394 I OSCB), Max = 4.5. D025 ( \u0394 I OSCB), Units = \u03bc A. D025 ( \u0394 I OSCB), Conditions = +70 \u00b0 C. D025 ( \u0394 I OSCB), Conditions = VDD = 2.0V. D025 ( \u0394 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \u0394 I OSCB), Device =",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n1.2. D025 ( \u0394 I OSCB), Typ = . D025 ( \u0394 I OSCB), Max = 4.5. D025 ( \u0394 I OSCB), Units = \u03bc A. D025 ( \u0394 I OSCB), Conditions = -10 \u00b0 C. D025 ( \u0394 I OSCB), Conditions = VDD = 3.0V. D025 ( \u0394 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \u0394 I OSCB), Device = 1.3. D025 ( \u0394 I OSCB), Typ = . D025 ( \u0394 I OSCB), Max = 4.5. D025 ( \u0394 I OSCB), Units = \u03bc A. D025 ( \u0394 I OSCB), Conditions = +25 \u00b0 C. D025 ( \u0394 I OSCB), Conditions = VDD = 3.0V. D025 ( \u0394 I",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nOSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \u0394 I OSCB), Device = 1.2. D025 ( \u0394 I OSCB), Typ = . D025 ( \u0394 I OSCB), Max = 5.5. D025 ( \u0394 I OSCB), Units = \u03bc A. D025 ( \u0394 I OSCB), Conditions = +70 \u00b0 C. D025 ( \u0394 I OSCB), Conditions = VDD = 3.0V. D025 ( \u0394 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \u0394 I OSCB), Device = 1.8. D025 ( \u0394 I OSCB), Typ = . D025 ( \u0394 I OSCB), Max = 6.0. D025 ( \u0394 I OSCB), Units = \u03bc A. D025 ( \u0394 I OSCB), Conditions = -10 \u00b0",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nC. D025 ( \u0394 I OSCB), Conditions = VDD = 5.0V. D025 ( \u0394 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \u0394 I OSCB), Device = 1.9. D025 ( \u0394 I OSCB), Typ = . D025 ( \u0394 I OSCB), Max = 6.0. D025 ( \u0394 I OSCB), Units = \u03bc A. D025 ( \u0394 I OSCB), Conditions = +25 \u00b0 C. D025 ( \u0394 I OSCB), Conditions = VDD = 5.0V. D025 ( \u0394 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \u0394 I OSCB), Device = 1.9. D025 ( \u0394 I OSCB), Typ = . D025 ( \u0394 I OSCB), Max = 7.0. D025",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n( \u0394 I OSCB), Units = \u03bc A. D025 ( \u0394 I OSCB), Conditions = +70 \u00b0 C. D025 ( \u0394 I OSCB), Conditions = VDD = 5.0V. D025 ( \u0394 I OSCB), Conditions = 32 kHz on Timer1 (4). D026 ( \u0394 I AD), Device = A/D Converter. D026 ( \u0394 I AD), Typ = 1.0. D026 ( \u0394 I AD), Max = 3.0. D026 ( \u0394 I AD), Units = \u03bc A. D026 ( \u0394 I AD), Conditions = GLYPH<151>. D026 ( \u0394 I AD), Conditions = VDD = 2.0V. D026 ( \u0394 I AD), Conditions = A/D on, not converting. D026 ( \u0394 I AD), Device = 1.0. D026 ( \u0394 I",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nAD), Typ = . D026 ( \u0394 I AD), Max = 4.0. D026 ( \u0394 I AD), Units = \u03bc A. D026 ( \u0394 I AD), Conditions = GLYPH<151>. D026 ( \u0394 I AD), Conditions = VDD = 3.0V. D026 ( \u0394 I AD), Conditions = A/D on, not converting. D026 ( \u0394 I AD), Device = 1.0. D026 ( \u0394 I AD), Typ = . D026 ( \u0394 I AD), Max = 8.0. D026 ( \u0394 I AD), Units = \u03bc A. D026 ( \u0394 I AD), Conditions = GLYPH<151>. D026 ( \u0394 I AD), Conditions = VDD = 5.0V. D026 ( \u0394 I AD), Conditions = A/D on, not converting\nLegend:",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nShading of rows is to assist in readability of the table.\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD or VSS;",
    "Power-Down and Supply Current PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nMCLR = VDD; WDT enabled/disabled as specified.\n3: Low-power Timer1 oscillator selected.\n4: BOR and HLVD enable internal band gap reference. With both modules enabled, current consumption will be less than the sum of both specifications.",
    "26.3 DC Characteristics:\nPIC18F6390/6490/8390/8490 (Industrial)\nPIC18LF6390/6490/8390/8490 (Industrial)",
    "DC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial",
    "DC CHARACTERISTICS\nD030 D030A D031 D032, Symbol = VIL. D030 D030A D031 D032, Characteristic = Input Low Voltage I/O Ports: with TTL Buffer. D030 D030A D031 D032, Min = VSS GLYPH<151> VSS VSS VSS. D030 D030A D031 D032, Max = 0.15 VDD 0.8 0.2 VDD 0.3 VDD 0.2 VDD. D030 D030A D031 D032, Units = V V V V V V. D030 D030A D031 D032, Conditions = VDD < 4.5V 4.5V \u2264 VDD \u2264 5.5V. D033, Symbol = VIH. D033, Characteristic = OSC1 Input High Voltage I/O Ports: with TTL Buffer. D033, Min = VSS 0.25 VDD + 0.8V. D033, Max = 0.2 VDD. D033, Units = V. D033, Conditions =",
    "DC CHARACTERISTICS\nmodes (1) EC mode (1). D040 D040A D041, Symbol = . D040 D040A D041, Characteristic = with Schmitt Trigger Buffer RC3 and RC4. D040 D040A D041, Min = 2.0 0.8 VDD 0.7 VDD. D040 D040A D041, Max = VDD VDD VDD VDD. D040 D040A D041, Units = V V V V. D040 D040A D041, Conditions = VDD < 4.5V 4.5V \u2264 VDD \u2264 5.5V. D042 D042A, Symbol = . D042 D042A, Characteristic = MCLR OSC1 and T1OSI. D042 D042A, Min = 0.8 VDD 0.7 VDD. D042 D042A, Max = VDD. D042 D042A, Units = V V. D042 D042A, Conditions = LP, XT, HS, HSPLL. , Symbol = . , Characteristic",
    "DC CHARACTERISTICS\n= OSC1. , Min = 0.8 VDD. , Max = VDD VDD. , Units = V. , Conditions = modes (1) EC mode (1). D043 D060, Symbol = I IL. D043 D060, Characteristic = Input Leakage Current (2,3) I/O Ports. D043 D060, Min = GLYPH<151>. D043 D060, Max = \u00b1 1. D043 D060, Units = \u03bc A. D043 D060, Conditions = VSS \u2264 VPIN \u2264 VDD, Pin at hi-impedance. D061, Symbol = . D061, Characteristic = MCLR. D061, Min = GLYPH<151>. D061, Max = \u00b1 5. D061, Units = \u03bc A. D061, Conditions = VSS \u2264 VPIN \u2264 VDD. D063, Symbol = . D063, Characteristic = OSC1. D063, Min = GLYPH<151>. D063, Max = \u00b1 5.",
    "DC CHARACTERISTICS\nD063, Units = \u03bc A. D063, Conditions = VSS \u2264 VPIN \u2264 VDD. , Symbol = PU I PURB. , Characteristic = Weak Pull-up Current PORTB Weak Pull-up Current. , Min = 50. , Max = 400. , Units = . , Conditions = . D070, Symbol = I. D070, Characteristic = . D070, Min = . D070, Max = . D070, Units = . D070, Conditions = VDD = 5V, VPIN = VSS. , Symbol = . , Characteristic = . , Min = . , Max = . , Units = \u03bc A. , Conditions = ",
    "DC CHARACTERISTICS\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PIC fi device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.\n4: Parameter is characterized but not tested.",
    "26.3 DC Characteristics: PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nD080, DC CHARACTERISTICS.Symbol = VOL. D080, DC CHARACTERISTICS.Characteristic = Output Low Voltage I/O Ports. D080, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min = GLYPH<151>. D080, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max = 0.6. D080, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units = V. D080, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions = I OL = 8.5 mA, VDD = 4.5V, -40",
    "26.3 DC Characteristics: PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n\u00b0 C to +85 \u00b0 C. D083, DC CHARACTERISTICS.Symbol = . D083, DC CHARACTERISTICS.Characteristic = OSC2/CLKO (RC, RCIO, EC, ECIO modes). D083, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min = GLYPH<151>. D083, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max = 0.6. D083, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units = V. D083, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264",
    "26.3 DC Characteristics: PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n+85GLYPH<176>C for industrial.Conditions = I OL = 1.6 mA, VDD = 4.5V, -40 \u00b0 C to +85 \u00b0 C. D090, DC CHARACTERISTICS.Symbol = VOH. D090, DC CHARACTERISTICS.Characteristic = Output High Voltage (3) I/O Ports. D090, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min = VDD GLYPH<150> 0.7. D090, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max = GLYPH<151>. D090, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units = V. D090, Standard",
    "26.3 DC Characteristics: PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nOperating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions = I OH = -3.0 mA, VDD = 4.5V, -40 \u00b0 C to +85 \u00b0 C. D092, DC CHARACTERISTICS.Symbol = . D092, DC CHARACTERISTICS.Characteristic = OSC2/CLKO (RC, RCIO, EC, ECIO modes). D092, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min = VDD GLYPH<150> 0.7. D092, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max = GLYPH<151>. D092, Standard Operating Conditions (unless otherwise stated) Operating",
    "26.3 DC Characteristics: PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\ntemperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units = V. D092, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions = I OH = -1.3 mA, VDD = 4.5V, -40 \u00b0 C to +85 \u00b0 C. D150, DC CHARACTERISTICS.Symbol = VOD. D150, DC CHARACTERISTICS.Characteristic = Open-Drain High Voltage. D150, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min = GLYPH<151>. D150, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max = 8.5. D150,",
    "26.3 DC Characteristics: PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units = V. D150, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions = RA4 pin. D100 (4), DC CHARACTERISTICS.Symbol = COSC2. D100 (4), DC CHARACTERISTICS.Characteristic = on Output Pins OSC2 pin. D100 (4), Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min = GLYPH<151>. D100 (4), Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max = 15. D100 (4), Standard Operating Conditions",
    "26.3 DC Characteristics: PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n(unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units = pF. D100 (4), Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions = In XT, HS and LP modes when external clock is used to drive OSC1. D101, DC CHARACTERISTICS.Symbol = CIO. D101, DC CHARACTERISTICS.Characteristic = All I/O pins and OSC2 (in RC mode). D101, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min = GLYPH<151>. D101, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max",
    "26.3 DC Characteristics: PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\n= 50. D101, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units = pF. D101, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions = To meet the AC Timing Specifications. D102, DC CHARACTERISTICS.Symbol = CB. D102, DC CHARACTERISTICS.Characteristic = SCL, SDA. D102, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min = GLYPH<151>. D102, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max = 400. D102, Standard Operating Conditions (unless otherwise",
    "26.3 DC Characteristics: PIC18F6390/6490/8390/8490 (Industrial) PIC18LF6390/6490/8390/8490 (Industrial) (Continued)\nstated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units = pF. D102, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions = I 2 CGLYPH<153> Specification\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PIC fi device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.\n4: Parameter is characterized but not tested.",
    "DC Characteristics\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial",
    "DC Characteristics\n, Sym = . , Characteristic = Program Flash Memory. , Min = . , TypGLYPH<134> = . , Max = . , Units = . , Conditions = . D110, Sym = VPP. D110, Characteristic = Voltage on MCLR/VPP pin. D110, Min = 10.0. D110, TypGLYPH<134> = GLYPH<151>. D110, Max = 12.0. D110, Units = V. D110, Conditions = . D113, Sym = I DDP. D113, Characteristic = Supply Current during Programming. D113, Min = GLYPH<151>. D113, TypGLYPH<134> = GLYPH<151>. D113, Max = 1. D113, Units = mA. D113, Conditions = . D130, Sym = EP. D130, Characteristic = Cell Endurance. D130, Min = GLYPH<151>. D130, TypGLYPH<134> = 1K. D130, Max = GLYPH<151>.",
    "DC Characteristics\nD130, Units = E/W. D130, Conditions = -40 \u00b0 C to +85 \u00b0 C. D131, Sym = VPR. D131, Characteristic = VDD for Read. D131, Min = VMIN. D131, TypGLYPH<134> = GLYPH<151>. D131, Max = 5.5. D131, Units = V. D131, Conditions = VMIN = Minimum operating voltage. D132, Sym = VIE. D132, Characteristic = VDD for Block Erase. D132, Min = 2.75. D132, TypGLYPH<134> = GLYPH<151>. D132, Max = 5.5. D132, Units = V. D132, Conditions = Using ICSPGLYPH<153> port. D132A, Sym = VIW. D132A, Characteristic = VDD for Externally Timed Erase or Write. D132A, Min = 2.75. D132A, TypGLYPH<134> = GLYPH<151>. D132A, Max",
    "DC Characteristics\n= 5.5. D132A, Units = V. D132A, Conditions = Using ICSP port. D132B, Sym = VPEW. D132B, Characteristic = VDD for Self-Timed Write. D132B, Min = VMIN. D132B, TypGLYPH<134> = GLYPH<151>. D132B, Max = 5.5. D132B, Units = V. D132B, Conditions = VMIN = Minimum operating voltage. D133, Sym = TIE. D133, Characteristic = ICSP Block Erase Cycle Time. D133, Min = GLYPH<151>. D133, TypGLYPH<134> = 4. D133, Max = GLYPH<151>. D133, Units = ms. D133, Conditions = VDD > 4.5V. D133A, Sym = TIW. D133A, Characteristic = ICSP Erase or Write Cycle Time (externally timed). D133A, Min = 2. D133A, TypGLYPH<134> =",
    "DC Characteristics\nGLYPH<151>. D133A, Max = GLYPH<151>. D133A, Units = ms. D133A, Conditions = VDD > 4.5V. D133A, Sym = TIW. D133A, Characteristic = Self-Timed Write Cycle Time. D133A, Min = GLYPH<151>. D133A, TypGLYPH<134> = 2. D133A, Max = GLYPH<151>. D133A, Units = ms. D133A, Conditions = . D134, Sym = TRETD. D134, Characteristic = Characteristic Retention. D134, Min = 40. D134, TypGLYPH<134> = 100. D134, Max = GLYPH<151>. D134, Units = Year. D134, Conditions = Provided no other specifications are violated",
    "DC Characteristics\n- GLYPH<134> Data in GLYPH<147>TypGLYPH<148> column is at 5.0V, 25GLYPH<176>C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "TABLE 26-2: COMPARATOR SPECIFICATIONS\nOperating Conditions: 3.0V < VDD < 5.5V, -40GLYPH<176>C < T A < +85GLYPH<176>C, unless otherwise stated.",
    "TABLE 26-2: COMPARATOR SPECIFICATIONS\nD300, Sym = VIOFF. D300, Characteristics = Input Offset Voltage. D300, Min = GLYPH<151>. D300, Typ = -5.0. D300, Max = -10. D300, Units = mV. D300, Comments = . D301, Sym = VICM. D301, Characteristics = Input Common Mode Voltage*. D301, Min = 0. D301, Typ = GLYPH<151>. D301, Max = VDD GLYPH<150> 1.5. D301, Units = V. D301, Comments = . D302, Sym = CMRR. D302, Characteristics = Common Mode Rejection Ratio*. D302, Min = 55. D302, Typ = GLYPH<151>. D302, Max = GLYPH<151>. D302, Units = dB. D302, Comments = . 300, Sym = TRESP. 300, Characteristics = Response Time* (1). 300, Min =",
    "TABLE 26-2: COMPARATOR SPECIFICATIONS\nGLYPH<151>. 300, Typ = 150. 300, Max = 400. 300, Units = ns. 300, Comments = PIC18 F XXXX. 300A, Sym = . 300A, Characteristics = . 300A, Min = GLYPH<151>. 300A, Typ = 150. 300A, Max = 600. 300A, Units = ns. 300A, Comments = PIC18 LF XXXX, VDD = 2.0V. 301, Sym = TMC2OV. 301, Characteristics = Comparator Mode Change to Output Valid*. 301, Min = GLYPH<151>. 301, Typ = GLYPH<151>. 301, Max = 10. 301, Units = \u03bc s. 301, Comments = \n* These parameters are characterized but not tested.\nNote 1: Response time measured with one comparator input at (VDD GLYPH<150> 1.5)/2, while the other input transitions from VSS to VDD.",
    "TABLE 26-3: VOLTAGE REFERENCE SPECIFICATIONS\nOperating Conditions: 3.0V < VDD < 5.5V, -40GLYPH<176>C < TA < +85GLYPH<176>C, unless otherwise stated.",
    "TABLE 26-3: VOLTAGE REFERENCE SPECIFICATIONS\nD310, Sym = VRES. D310, Characteristics = Resolution. D310, Min = VDD/24. D310, Typ = GLYPH<151>. D310, Max = VDD/32. D310, Units = LSb. D310, Comments = . D311, Sym = VRAA. D311, Characteristics = Absolute Accuracy. D311, Min = GLYPH<151>. D311, Typ = GLYPH<151>. D311, Max = 1/2. D311, Units = LSb. D311, Comments = . D312, Sym = VRUR. D312, Characteristics = Unit Resistor Value (R). D312, Min = GLYPH<151>. D312, Typ = 2k. D312, Max = GLYPH<151>. D312, Units = \u03a9. D312, Comments = . 310, Sym = TSET. 310, Characteristics = Settling Time (1). 310, Min = GLYPH<151>. 310,",
    "TABLE 26-3: VOLTAGE REFERENCE SPECIFICATIONS\nTyp = GLYPH<151>. 310, Max = 10. 310, Units = \u03bc s. 310, Comments = \nNote 1: Settling time measured while CVRR = 1 and CVR3:CVR0 transitions from GLYPH<145> 0000 GLYPH<146> to GLYPH<145> 1111 GLYPH<146>.",
    "TABLE 26-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial",
    "TABLE 26-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 0000. D420, Min = 2.06. D420, TypGLYPH<134> = 2.17. D420, Max = 2.28. D420, Units = V. D420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 0001. D420, Min = 2.12. D420, TypGLYPH<134> = 2.23. D420, Max = 2.34. D420, Units = V. D420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 0010.",
    "TABLE 26-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Min = 2.24. D420, TypGLYPH<134> = 2.36. D420, Max = 2.48. D420, Units = V. D420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 0011. D420, Min = 2.32. D420, TypGLYPH<134> = 2.44. D420, Max = 2.56. D420, Units = V. D420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 0100. D420, Min = 2.47. D420, TypGLYPH<134> = 2.60. D420, Max = 2.73. D420, Units = V. D420,",
    "TABLE 26-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nConditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 0101. D420, Min = 2.65. D420, TypGLYPH<134> = 2.79. D420, Max = 2.93. D420, Units = V. D420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 0110. D420, Min = 2.74. D420, TypGLYPH<134> = 2.89. D420, Max = 3.04. D420, Units = V. D420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> =",
    "TABLE 26-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\n0111. D420, Min = 2.96. D420, TypGLYPH<134> = 3.12. D420, Max = 3.28. D420, Units = V. D420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 1000. D420, Min = 3.22. D420, TypGLYPH<134> = 3.39. D420, Max = 3.56. D420, Units = V. D420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 1001. D420, Min = 3.37. D420, TypGLYPH<134> = 3.55. D420, Max = 3.73. D420, Units = V.",
    "TABLE 26-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 1010. D420, Min = 3.52. D420, TypGLYPH<134> = 3.71. D420, Max = 3.90. D420, Units = V. D420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 1011. D420, Min = 3.70. D420, TypGLYPH<134> = 3.90. D420, Max = 4.10. D420, Units = V. D420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic =",
    "TABLE 26-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nHLVDL<3:0> = 1100. D420, Min = 3.90. D420, TypGLYPH<134> = 4.11. D420, Max = 4.32. D420, Units = V. D420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 1101. D420, Min = 4.11. D420, TypGLYPH<134> = 4.33. D420, Max = 4.55. D420, Units = V. D420, Conditions = . D420, Sym = . D420, Characteristic = HLVD Voltage on VDD Transition High-to-Low. D420, Characteristic = HLVDL<3:0> = 1110. D420, Min = 4.36. D420, TypGLYPH<134> = 4.59. D420, Max = 4.82.",
    "TABLE 26-4: HIGH/LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Units = V. D420, Conditions = . D423, Sym = VBG. D423, Characteristic = Band Gap Reference Voltage Value. D423, Characteristic = HLVDL<3:0> = 1111. D423, Min = GLYPH<151>. D423, TypGLYPH<134> = 1.2. D423, Max = GLYPH<151>. D423, Units = V. D423, Conditions = HLVD input external.\n- GLYPH<134> Production tested at TAMB = 25GLYPH<176>C. Specifications over temperature limits ensured by characterization.",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\nThe  timing  parameter  symbols  have  been  created following one of the following formats:",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\n2. TppS, 1. TppS2ppS = 2. TppS. 2. TppS, 3. TCC:ST 4. Ts = . 2. TppS, (I 2 C specifications only) (I 2 C specifications only) = . T F, 1. TppS2ppS = Frequency. T F, 3. TCC:ST 4. Ts = T. T F, (I 2 C specifications only) (I 2 C specifications only) = Time. Lowercase letters (pp) and their meanings:, 1. TppS2ppS = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, 3. TCC:ST 4. Ts = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, (I 2 C specifications only) (I 2 C specifications only) = Lowercase letters (pp) and their meanings:. pp, 1. TppS2ppS = pp. pp, 3. TCC:ST 4. Ts = . pp, (I 2 C specifications only) (I 2 C specifications only) = . cc, 1.",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\nTppS2ppS = CCP1. cc, 3. TCC:ST 4. Ts = osc. cc, (I 2 C specifications only) (I 2 C specifications only) = OSC1. ck, 1. TppS2ppS = CLKO. ck, 3. TCC:ST 4. Ts = rd. ck, (I 2 C specifications only) (I 2 C specifications only) = RD. cs, 1. TppS2ppS = CS. cs, 3. TCC:ST 4. Ts = rw. cs, (I 2 C specifications only) (I 2 C specifications only) = RD or WR. di, 1. TppS2ppS = SDI. di, 3. TCC:ST 4. Ts = sc. di, (I 2 C specifications only) (I 2 C specifications only) = SCK. do, 1. TppS2ppS = SDO. do, 3. TCC:ST 4. Ts = ss. do, (I 2 C specifications only) (I 2 C specifications only) = SS. dt, 1. TppS2ppS = Data in. dt, 3.",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\nTCC:ST 4. Ts = t0. dt, (I 2 C specifications only) (I 2 C specifications only) = T0CKI. io, 1. TppS2ppS = I/O port. io, 3. TCC:ST 4. Ts = t1. io, (I 2 C specifications only) (I 2 C specifications only) = T13CKI. mc, 1. TppS2ppS = MCLR. mc, 3. TCC:ST 4. Ts = wr. mc, (I 2 C specifications only) (I 2 C specifications only) = WR. Uppercase letters and their meanings:, 1. TppS2ppS = Uppercase letters and their meanings:. Uppercase letters and their meanings:, 3. TCC:ST 4. Ts = Uppercase letters and their meanings:. Uppercase letters and their meanings:, (I 2 C specifications only) (I 2 C specifications only) = Uppercase letters and their meanings:. S, 1. TppS2ppS = S. S, 3. TCC:ST 4. Ts = . S, (I 2 C specifications only) (I 2 C specifications only)",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\n= . F, 1. TppS2ppS = Fall. F, 3. TCC:ST 4. Ts = P. F, (I 2 C specifications only) (I 2 C specifications only) = Period. H, 1. TppS2ppS = High. H, 3. TCC:ST 4. Ts = R. H, (I 2 C specifications only) (I 2 C specifications only) = Rise. I, 1. TppS2ppS = Invalid (High-impedance). I, 3. TCC:ST 4. Ts = V. I, (I 2 C specifications only) (I 2 C specifications only) = Valid. L, 1. TppS2ppS = Low. L, 3. TCC:ST 4. Ts = Z. L, (I 2 C specifications only) (I 2 C specifications only) = High-impedance. I 2 C only, 1. TppS2ppS = I 2 C only. I 2 C only, 3. TCC:ST 4. Ts = . I 2 C only, (I 2 C specifications only) (I 2 C specifications only) = . AA, 1.",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\nTppS2ppS = output access. AA, 3. TCC:ST 4. Ts = High. AA, (I 2 C specifications only) (I 2 C specifications only) = High. BUF, 1. TppS2ppS = Bus free. BUF, 3. TCC:ST 4. Ts = Low. BUF, (I 2 C specifications only) (I 2 C specifications only) = Low. TCC:ST (I 2 C specifications only), 1. TppS2ppS = TCC:ST (I 2 C specifications only). TCC:ST (I 2 C specifications only), 3. TCC:ST 4. Ts = . TCC:ST (I 2 C specifications only), (I 2 C specifications only) (I 2 C specifications only) = . CC, 1. TppS2ppS = CC. CC, 3. TCC:ST 4. Ts = . CC, (I 2 C specifications only) (I 2 C specifications only) = . HD, 1. TppS2ppS = Hold. HD, 3. TCC:ST 4. Ts = SU. HD, (I 2 C specifications only)",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\n(I 2 C specifications only) = Setup. ST, 1. TppS2ppS = ST. ST, 3. TCC:ST 4. Ts = . ST, (I 2 C specifications only) (I 2 C specifications only) = . DAT, 1. TppS2ppS = DATA input hold. DAT, 3. TCC:ST 4. Ts = STO. DAT, (I 2 C specifications only) (I 2 C specifications only) = Stop condition. STA, 1. TppS2ppS = Start condition. STA, 3. TCC:ST 4. Ts = . STA, (I 2 C specifications only) (I 2 C specifications only) = ",
    "26.4.2 TIMING CONDITIONS\nThe temperature and voltages specified in Table 26-5 apply  to  all timing  specifications  unless  otherwise noted. Figure 26-4 specifies the load conditions for the timing specifications.\nNote:\nBecause of space limitations, the  generic terms GLYPH<147>PIC18FXXXXGLYPH<148> and GLYPH<147>PIC18LFXXXXGLYPH<148> are used throughout this section to refer to the PIC18F6390/6490/8390/8490 and PIC18LF6390/6490/8390/8490  families  of devices specifically and only those devices.",
    "TABLE 26-5: TEMPERATURE AND VOLTAGE SPECIFICATIONS GLYPH<150> AC\nAC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C   for industrial\nOperating voltage VDD range as described in DC spec Section 26.1 and\nSection 26.3\n.\nLF parts operate for industrial temperatures only.",
    "FIGURE 26-4: LOAD CONDITIONS FOR DEVICE TIMING SPECIFICATIONS\nVDD/2 CL RL Pin VSS RL CL, Load Condition 2 = Pin VSS CL",
    "TABLE 26-6: EXTERNAL CLOCK TIMING REQUIREMENTS\n1A, Symbol = FOSC. 1A, Characteristic = External CLKI Frequency (1). 1A, Min = DC DC DC DC 0.1 4 5. 1A, Max = 1 20 31.25 4 4 20 200. 1A, Units = MHz MHz kHz MHz MHz MHz kHz. 1A, Conditions = XT, RC Oscillator mode HS Oscillator mode LP Oscillator mode RC Oscillator mode XT Oscillator mode HS Oscillator mode LP Oscillator mode. 1, Symbol = TOSC. 1, Characteristic = External CLKI Period (1). 1, Min = 1000 50 32 250 250 100 50. 1, Max = GLYPH<151> GLYPH<151> GLYPH<151> GLYPH<151> 1 250 250. 1, Units = ns ns \u03bc s ns \u03bc s ns ns \u03bc s. 1, Conditions = XT, RC Oscillator mode HS Oscillator mode LP Oscillator mode RC Oscillator mode XT Oscillator mode HS Oscillator mode HS Oscillator mode. 2, Symbol =",
    "TABLE 26-6: EXTERNAL CLOCK TIMING REQUIREMENTS\nTCY. 2, Characteristic = Instruction Cycle Time (1). 2, Min = 100. 2, Max = GLYPH<151>. 2, Units = ns. 2, Conditions = TCY = 4/FOSC. 3, Symbol = TOSL, TOSH. 3, Characteristic = External Clock in (OSC1) High or Low Time. 3, Min = 30 2.5 10. 3, Max = GLYPH<151> GLYPH<151> GLYPH<151>. 3, Units = ns \u03bc s ns. 3, Conditions = XT Oscillator mode LP Oscillator mode HS Oscillator mode. 4, Symbol = TOSR, TOSF. 4, Characteristic = External Clock in (OSC1) Rise or Fall Time. 4, Min = GLYPH<151> GLYPH<151> GLYPH<151>. 4, Max = 20 50. 4, Units = ns ns. 4, Conditions = XT Oscillator mode LP Oscillator mode HS Oscillator mode",
    "TABLE 26-6: EXTERNAL CLOCK TIMING REQUIREMENTS\nNote 1: Instruction cycle period (TCY) equals four times the input oscillator time base period for all configurations except PLL. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at GLYPH<147>min.GLYPH<148> values with an external clock applied to the OSC1/CLKI pin. When an external clock input is used, the GLYPH<147>max.GLYPH<148> cycle time limit is GLYPH<147>DCGLYPH<148> (no clock) for all devices.",
    "TABLE 26-7: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2V TO 5.5V)\nF10, Sym = FOSC. F10, Characteristic = Oscillator Frequency Range. F10, Min = 4. F10, TypGLYPH<134> = GLYPH<151>. F10, Max = 10. F10, Units = MHz. F10, Conditions = HS mode only. F11, Sym = FSYS. F11, Characteristic = On-Chip VCO System Frequency. F11, Min = 16. F11, TypGLYPH<134> = GLYPH<151>. F11, Max = 40. F11, Units = MHz. F11, Conditions = HS mode only. F12, Sym = t rc. F12, Characteristic = PLL Start-up Time (Lock Time). F12, Min = GLYPH<151>. F12, TypGLYPH<134> = GLYPH<151>. F12, Max = 2. F12, Units = ms. F12, Conditions = . F13, Sym = \u0394 CLK. F13, Characteristic =",
    "TABLE 26-7: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2V TO 5.5V)\nCLKO Stability (Jitter). F13, Min = -2. F13, TypGLYPH<134> = GLYPH<151>. F13, Max = +2. F13, Units = %. F13, Conditions = \n- GLYPH<134> Data in GLYPH<147>TypGLYPH<148> column is at 5V , 25 \u00b0 C, unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nPIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -2. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Typ.INTOSC Accuracy @Freq = 8",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nMHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +/-1. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 2. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +25GLYPH<176>C. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 2.7-3.3V. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nkHz (1) = -5. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = GLYPH<151>. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nindustrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 5. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nstated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -10GLYPH<176>C to +85GLYPH<176>C. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 2.7-3.3V.",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nPIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -10. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Typ.INTOSC Accuracy @Freq = 8",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nMHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +/-1. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 10. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -40GLYPH<176>C to +85GLYPH<176>C. PIC18LF6390/6490/8390/8490, Standard Operating Conditions",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n(unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 2.7-3.3V. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz,",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n500 kHz, 250 kHz, 125 kHz (1) = -2. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +/-1. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n+85GLYPH<176>C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 2. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nindustrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +25GLYPH<176>C. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 4.5-5.5V.",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nPIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -5. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Typ.INTOSC Accuracy @Freq = 8",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nMHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = GLYPH<151>. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 5. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -10GLYPH<176>C to +85GLYPH<176>C. PIC18F6390/6490/8390/8490, Standard Operating Conditions",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n(unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 4.5-5.5V. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz,",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n500 kHz, 250 kHz, 125 kHz (1) = -10. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = +/-1. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n+85GLYPH<176>C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 10. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = %. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nindustrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -40GLYPH<176>C to +85GLYPH<176>C. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD =",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n4.5-5.5V. INTRC Accuracy @Freq = 31 kHz (2), Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). INTRC Accuracy @Freq = 31 kHz (2), Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n+85GLYPH<176>C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). INTRC Accuracy @Freq = 31 kHz (2), Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). INTRC Accuracy @Freq = 31 kHz (2), Standard Operating Conditions (unless otherwise stated) Operating",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\ntemperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). INTRC Accuracy @Freq = 31 kHz (2), Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nkHz (1) = INTRC Accuracy @Freq = 31 kHz (2). INTRC Accuracy @Freq = 31 kHz (2), Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = INTRC Accuracy @Freq = 31 kHz (2). PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 26.562. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = GLYPH<151>. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n-40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 35.938. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = kHz.",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nPIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial..INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -40GLYPH<176>C to +85GLYPH<176>C. PIC18LF6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nindustrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 2.7-3.3V. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Min.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 26.562. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\n+85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Typ.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = GLYPH<151>. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Max.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = 35.938.",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nPIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Units.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = kHz. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial..INTOSC Accuracy @Freq = 8 MHz, 4",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nMHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = -40GLYPH<176>C to +85GLYPH<176>C. PIC18F6390/6490/8390/8490, Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40GLYPH<176>C \u2264 TA \u2264 +85GLYPH<176>C for industrial.Conditions.INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1) = VDD = 4.5-5.5V",
    "TABLE 26-8: AC CHARACTERISTICS: INTERNAL RC ACCURACY PIC18LF6390/6490/8390/8490 (INDUSTRIAL) PIC18F6390/6490/8390/8490 (INDUSTRIAL)\nLegend:\nShading of rows is to assist in readability of the table.\nNote\n1: Frequency calibrated at 25GLYPH<176>C. OSCTUNE register can be used to compensate for temperature drift.\n2: INTRC frequency after calibration.",
    "TABLE 26-9: CLKO AND I/O TIMING REQUIREMENTS\n10, Symbol = TOSH2CKL. 10, Characteristic = OSC1 \u2191 to CLKO \u2193. 10, Characteristic = OSC1 \u2191 to CLKO \u2193. 10, Min = GLYPH<151>. 10, Typ = 75. 10, Max = 200. 10, Units = ns. 10, Conditions = (Note 1). 11, Symbol = TOSH2CKH. 11, Characteristic = OSC1 \u2191 to CLKO \u2191. 11, Characteristic = OSC1 \u2191 to CLKO \u2191. 11, Min = GLYPH<151>. 11, Typ = 75. 11, Max = 200. 11, Units = ns. 11, Conditions = (Note 1). 12, Symbol = TCKR. 12, Characteristic = CLKO Rise Time. 12, Characteristic = CLKO Rise Time. 12, Min = GLYPH<151>. 12, Typ = 35. 12, Max = 100. 12, Units = ns. 12, Conditions = (Note 1). 13, Symbol = TCKF. 13, Characteristic = CLKO Fall Time. 13, Characteristic = CLKO Fall Time. 13, Min",
    "TABLE 26-9: CLKO AND I/O TIMING REQUIREMENTS\n= GLYPH<151>. 13, Typ = 35. 13, Max = 100. 13, Units = ns. 13, Conditions = (Note 1). 14, Symbol = TCKL2IOV. 14, Characteristic = CLKO \u2193 to Port Out Valid. 14, Characteristic = CLKO \u2193 to Port Out Valid. 14, Min = GLYPH<151>. 14, Typ = GLYPH<151>. 14, Max = 0.5 TCY + 20. 14, Units = ns. 14, Conditions = (Note 1). 15, Symbol = TIOV2CKH. 15, Characteristic = Port In Valid before CLKO \u2191. 15, Characteristic = Port In Valid before CLKO \u2191. 15, Min = 0.25 TCY + 25. 15, Typ = GLYPH<151>. 15, Max = GLYPH<151>. 15, Units = ns. 15, Conditions = (Note 1). 16, Symbol = TCKH2IOI. 16, Characteristic = Port In Hold after CLKO \u2191. 16, Characteristic = Port In Hold after CLKO \u2191. 16, Min =",
    "TABLE 26-9: CLKO AND I/O TIMING REQUIREMENTS\n0. 16, Typ = GLYPH<151>. 16, Max = GLYPH<151>. 16, Units = ns. 16, Conditions = (Note 1). 17, Symbol = TOSH2IOV. 17, Characteristic = OSC1 \u2191 (Q1 cycle) to Port Out Valid. 17, Characteristic = OSC1 \u2191 (Q1 cycle) to Port Out Valid. 17, Min = GLYPH<151>. 17, Typ = 50. 17, Max = 150. 17, Units = ns. 17, Conditions = . 18, Symbol = TOSH2IOI. 18, Characteristic = OSC1 \u2191 (Q2 cycle) to. 18, Characteristic = PIC18 F XXXX. 18, Min = 100. 18, Typ = GLYPH<151>. 18, Max = GLYPH<151>. 18, Units = ns. 18, Conditions = . 18A, Symbol = . 18A, Characteristic = Port Input Invalid (I/O in hold time). 18A, Characteristic = PIC18 LF XXXX. 18A, Min = 200. 18A, Typ",
    "TABLE 26-9: CLKO AND I/O TIMING REQUIREMENTS\n= GLYPH<151>. 18A, Max = GLYPH<151>. 18A, Units = ns. 18A, Conditions = VDD = 2.0V. 19, Symbol = TIOV2OSH. 19, Characteristic = Port Input Valid to OSC1 \u2191 (I/O in setup time). 19, Characteristic = Port Input Valid to OSC1 \u2191 (I/O in setup time). 19, Min = 0. 19, Typ = GLYPH<151>. 19, Max = GLYPH<151>. 19, Units = ns. 19, Conditions = . 20, Symbol = TIOR. 20, Characteristic = Port Output Rise Time. 20, Characteristic = PIC18 F XXXX. 20, Min = GLYPH<151>. 20, Typ = 10. 20, Max = 25. 20, Units = ns. 20, Conditions = . 20A, Symbol = . 20A, Characteristic = . 20A, Characteristic = PIC18 LF XXXX. 20A, Min = GLYPH<151>. 20A, Typ = GLYPH<151>.",
    "TABLE 26-9: CLKO AND I/O TIMING REQUIREMENTS\n20A, Max = 60. 20A, Units = ns. 20A, Conditions = VDD = 2.0V. 21, Symbol = TIOF. 21, Characteristic = Port Output Fall Time. 21, Characteristic = PIC18 F XXXX. 21, Min = GLYPH<151>. 21, Typ = 10. 21, Max = 25. 21, Units = ns. 21, Conditions = . 21A, Symbol = . 21A, Characteristic = . 21A, Characteristic = PIC18 LF XXXX. 21A, Min = GLYPH<151>. 21A, Typ = GLYPH<151>. 21A, Max = 60. 21A, Units = ns. 21A, Conditions = VDD = 2.0V. 22GLYPH<134>, Symbol = TINP. 22GLYPH<134>, Characteristic = INTx pin High or Low Time. 22GLYPH<134>, Characteristic = INTx pin High or Low Time. 22GLYPH<134>, Min = TCY. 22GLYPH<134>, Typ = GLYPH<151>.",
    "TABLE 26-9: CLKO AND I/O TIMING REQUIREMENTS\n22GLYPH<134>, Max = GLYPH<151>. 22GLYPH<134>, Units = ns. 22GLYPH<134>, Conditions = . 23GLYPH<134>, Symbol = TRBP. 23GLYPH<134>, Characteristic = RB7:RB4 Change INTx High or Low Time. 23GLYPH<134>, Characteristic = RB7:RB4 Change INTx High or Low Time. 23GLYPH<134>, Min = TCY. 23GLYPH<134>, Typ = GLYPH<151>. 23GLYPH<134>, Max = GLYPH<151>. 23GLYPH<134>, Units = ns. 23GLYPH<134>, Conditions = \nGLYPH<134> These parameters are asynchronous events not related to any internal clock edges.\nNote 1: Measurements are taken in RC mode, where CLKO output is 4 x TOSC.",
    "TABLE 26-10: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\n30, Symbol = TMCL. 30, Characteristic = MCLR Pulse Width (low). 30, Min = 2. 30, Typ = GLYPH<151>. 30, Max = GLYPH<151>. 30, Units = \u03bc s. 30, Conditions = . 31, Symbol = TWDT. 31, Characteristic = Watchdog Timer Time-out Period (No postscaler). 31, Min = 3.4. 31, Typ = 4.0. 31, Max = 4.6. 31, Units = ms. 31, Conditions = . 32, Symbol = TOST. 32, Characteristic = Oscillator Start-up Timer Period. 32, Min = 1024 TOSC. 32, Typ = GLYPH<151>. 32, Max = 1024 TOSC. 32, Units = GLYPH<151>. 32, Conditions = TOSC = OSC1 period. 33, Symbol = TPWRT. 33, Characteristic = Power-up Timer Period. 33, Min = 55.5. 33,",
    "TABLE 26-10: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\nTyp = 65.5. 33, Max = 75. 33, Units = ms. 33, Conditions = . 34, Symbol = TIOZ. 34, Characteristic = I/O High-Impedance from MCLR Low or Watchdog Timer Reset. 34, Min = GLYPH<151>. 34, Typ = 2. 34, Max = GLYPH<151>. 34, Units = \u03bc s. 34, Conditions = . 35, Symbol = TBOR. 35, Characteristic = Brown-out Reset Pulse Width. 35, Min = 200. 35, Typ = GLYPH<151>. 35, Max = GLYPH<151>. 35, Units = \u03bc s. 35, Conditions = VDD \u2264 BVDD (see D005). 36, Symbol = TIRVST. 36, Characteristic = Time for Internal Reference Voltage to become Stable. 36, Min = GLYPH<151>. 36, Typ = 20. 36, Max = 50. 36, Units = \u03bc s. 36, Conditions = . 37, Symbol =",
    "TABLE 26-10: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\nTLVD. 37, Characteristic = Low-Voltage Detect Pulse Width. 37, Min = 200. 37, Typ = GLYPH<151>. 37, Max = GLYPH<151>. 37, Units = \u03bc s. 37, Conditions = VDD \u2264 VLVD. 38, Symbol = TCSD. 38, Characteristic = CPU Start-up Time. 38, Min = GLYPH<151>. 38, Typ = 10. 38, Max = GLYPH<151>. 38, Units = \u03bc s. 38, Conditions = . 39, Symbol = TIOBST. 39, Characteristic = Time for INTRC Block to Stabilize. 39, Min = GLYPH<151>. 39, Typ = 1. 39, Max = GLYPH<151>. 39, Units = ms. 39, Conditions = ",
    "TABLE 26-11: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n40, Symbol = TT0H. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = No Prescaler. 40, Min = 0.5 TCY + 20. 40, Max = GLYPH<151>. 40, Units = ns. 40, Conditions = . 40, Symbol = TT0H. 40, Characteristic = . 40, Characteristic = . 40, Characteristic = With Prescaler. 40, Min = 10. 40, Max = GLYPH<151>. 40, Units = ns. 40, Conditions = . 41, Symbol = TT0L. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = No Prescaler. 41, Min = 0.5 TCY + 20. 41, Max = GLYPH<151>. 41, Units = ns. 41, Conditions = . 41, Symbol = TT0L. 41, Characteristic = . 41, Characteristic = . 41, Characteristic = With Prescaler. 41, Min = 10. 41, Max =",
    "TABLE 26-11: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nGLYPH<151>. 41, Units = ns. 41, Conditions = . 42, Symbol = TT0P. 42, Characteristic = T0CKI Period. 42, Characteristic = T0CKI Period. 42, Characteristic = No Prescaler. 42, Min = TCY + 10. 42, Max = GLYPH<151>. 42, Units = ns. 42, Conditions = . 42, Symbol = TT0P. 42, Characteristic = . 42, Characteristic = . 42, Characteristic = With Prescaler. 42, Min = Greater of: 20 ns or (T CY + 40)/N. 42, Max = GLYPH<151>. 42, Units = ns. 42, Conditions = N = prescale value (1, 2, 4,..., 256). 45, Symbol = TT1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Synchronous, No Prescaler. 45, Characteristic = Synchronous, No Prescaler. 45, Min = 0.5 TCY + 20. 45, Max = GLYPH<151>. 45, Units",
    "TABLE 26-11: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n= ns. 45, Conditions = VDD = 2.0V. 45, Symbol = TT1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Synchronous, with Prescaler. 45, Characteristic = PIC18 F XXXX. 45, Min = 10. 45, Max = GLYPH<151>. 45, Units = ns. 45, Conditions = VDD = 2.0V. 45, Symbol = TT1H. 45, Characteristic = T13CKI High Time. 45, Characteristic = Synchronous, with Prescaler. 45, Characteristic = PIC18 LF XXXX. 45, Min = 25. 45, Max = GLYPH<151>. 45, Units = ns. 45, Conditions = . 45, Symbol = TT1H. 45, Characteristic = . 45, Characteristic = Asynchronous. 45, Characteristic = PIC18 F XXXX. 45, Min = 30. 45, Max = GLYPH<151>. 45, Units = ns. 45, Conditions = . 45, Symbol = TT1H. 45, Characteristic = . 45, Characteristic =",
    "TABLE 26-11: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nAsynchronous. 45, Characteristic = PIC18 LF XXXX. 45, Min = 50. 45, Max = GLYPH<151>. 45, Units = ns. 45, Conditions = VDD = 2.0V. 46, Symbol = TT1L. 46, Characteristic = T13CKI. 46, Characteristic = Synchronous, No Prescaler. 46, Characteristic = Synchronous, No Prescaler. 46, Min = 0.5 TCY + 5. 46, Max = GLYPH<151>. 46, Units = ns. 46, Conditions = . 46, Symbol = TT1L. 46, Characteristic = Low Time. 46, Characteristic = Synchronous, with Prescaler. 46, Characteristic = PIC18 F XXXX. 46, Min = 10. 46, Max = GLYPH<151>. 46, Units = ns. 46, Conditions = . 46, Symbol = TT1L. 46, Characteristic = T13CKI. 46, Characteristic = Synchronous, with Prescaler. 46, Characteristic = PIC18 LF XXXX. 46, Min =",
    "TABLE 26-11: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n25. 46, Max = GLYPH<151>. 46, Units = ns. 46, Conditions = VDD = 2.0V. 46, Symbol = TT1L. 46, Characteristic = . 46, Characteristic = Asynchronous. 46, Characteristic = PIC18 F XXXX. 46, Min = 30. 46, Max = GLYPH<151>. 46, Units = ns. 46, Conditions = . 46, Symbol = TT1L. 46, Characteristic = . 46, Characteristic = Asynchronous. 46, Characteristic = PIC18 LF XXXX. 46, Min = 50. 46, Max = GLYPH<151>. 46, Units = ns. 46, Conditions = VDD = 2.0V. 47, Symbol = TT1P. 47, Characteristic = T13CKI Input Period. 47, Characteristic = Synchronous. 47, Characteristic = Synchronous. 47, Min = Greater of: 20 ns or (T CY + 40)/N. 47, Max = GLYPH<151>. 47, Units = ns. 47, Conditions = N = prescale value",
    "TABLE 26-11: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n(1, 2, 4, 8). 47, Symbol = TT1P. 47, Characteristic = . 47, Characteristic = Asynchronous. 47, Characteristic = Asynchronous. 47, Min = 60. 47, Max = GLYPH<151>. 47, Units = ns. 47, Conditions = . , Symbol = FT1. , Characteristic = T13CKI Oscillator Input Frequency Range. , Characteristic = T13CKI Oscillator Input Frequency Range. , Characteristic = T13CKI Oscillator Input Frequency Range. , Min = DC. , Max = 50. , Units = kHz. , Conditions = . 48, Symbol = TCKE2TMRI. 48, Characteristic = Delay from External T13CKI Clock Edge to Timer Increment. 48, Characteristic = Delay from External T13CKI Clock Edge to Timer Increment. 48, Characteristic = Delay from External T13CKI Clock Edge to Timer Increment. 48, Min = 2 TOSC. 48, Max = 7 TOSC. 48, Units = GLYPH<151>. 48, Conditions = ",
    "TABLE 26-12: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\n50, Symbol = TCCL. 50, Characteristic = CCPxInputLow Time. 50, Characteristic = No Prescaler. 50, Characteristic = No Prescaler. 50, Min = 0.5 TCY + 20. 50, Max = GLYPH<151>. 50, Units = ns. 50, Conditions = . 50, Symbol = TCCL. 50, Characteristic = CCPxInputLow Time. 50, Characteristic = With Prescaler. 50, Characteristic = PIC18 F XXXX. 50, Min = 10. 50, Max = GLYPH<151>. 50, Units = ns. 50, Conditions = . 50, Symbol = TCCL. 50, Characteristic = CCPxInputLow Time. 50, Characteristic = With Prescaler. 50, Characteristic = PIC18 LF XXXX. 50, Min = 20. 50, Max = GLYPH<151>. 50, Units = ns. 50, Conditions = VDD = 2.0V. 51, Symbol = TCCH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = No Prescaler. 51,",
    "TABLE 26-12: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\nCharacteristic = No Prescaler. 51, Min = 0.5 TCY + 20. 51, Max = GLYPH<151>. 51, Units = ns. 51, Conditions = . 51, Symbol = TCCH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = With Prescaler. 51, Characteristic = PIC18 F XXXX. 51, Min = 10. 51, Max = GLYPH<151>. 51, Units = ns. 51, Conditions = . 51, Symbol = TCCH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = With Prescaler. 51, Characteristic = PIC18 LF XXXX. 51, Min = 20. 51, Max = GLYPH<151>. 51, Units = ns. 51, Conditions = VDD = 2.0V. 52, Symbol = TCCP. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Min = 3 TCY + 40 N. 52, Max =",
    "TABLE 26-12: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\nGLYPH<151>. 52, Units = ns. 52, Conditions = N = prescale value (1, 4 or 16). 53, Symbol = TCCR. 53, Characteristic = CCPx Output Fall Time. 53, Characteristic = CCPx Output Fall Time. 53, Characteristic = PIC18 F XXXX. 53, Min = GLYPH<151>. 53, Max = 25. 53, Units = ns. 53, Conditions = . 53, Symbol = TCCR. 53, Characteristic = . 53, Characteristic = . 53, Characteristic = PIC18 LF XXXX. 53, Min = GLYPH<151>. 53, Max = 45. 53, Units = ns. 53, Conditions = VDD = 2.0V. 54, Symbol = TCCF. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = PIC18 F XXXX. 54, Min = GLYPH<151>. 54, Max = 25. 54, Units = ns. 54, Conditions = . 54, Symbol = TCCF.",
    "TABLE 26-12: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\n54, Characteristic = . 54, Characteristic = . 54, Characteristic = PIC18 LF XXXX. 54, Min = GLYPH<151>. 54, Max = 45. 54, Units = ns. 54, Conditions = VDD = 2.0V",
    "FIGURE 26-11: EXAMPLE SPI MASTER MODE TIMING (CKE = 0\n)\nTABLE 26-13: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0 )",
    "FIGURE 26-11: EXAMPLE SPI MASTER MODE TIMING (CKE = 0\n70, Symbol = TSSL2SCH, TSSL2SCL. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 Input. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 Input. 70, Min = TCY. 70, Max = GLYPH<151>. 70, Units = ns. 70, Conditions = . 71, Symbol = TSCH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 TCY + 30. 71, Max = GLYPH<151>. 71, Units = ns. 71, Conditions = . 71A, Symbol = TSCH. 71A, Characteristic = SCK Input High Time (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = GLYPH<151>. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TSCL. 72, Characteristic = SCK Input Low Time (Slave mode). 72, Characteristic = Continuous. 72, Min = 1.25 TCY",
    "FIGURE 26-11: EXAMPLE SPI MASTER MODE TIMING (CKE = 0\n+ 30. 72, Max = GLYPH<151>. 72, Units = ns. 72, Conditions = . 72A, Symbol = TSCL. 72A, Characteristic = SCK Input Low Time (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = GLYPH<151>. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TDIV2SCH, TDIV2SCL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = GLYPH<151>. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Min = 1.5 TCY + 40. 73A, Max =",
    "FIGURE 26-11: EXAMPLE SPI MASTER MODE TIMING (CKE = 0\nGLYPH<151>. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TSCH2DIL, TSCL2DIL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = GLYPH<151>. 74, Units = ns. 74, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 F XXXX. 75, Min = GLYPH<151>. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 LF XXXX. 75, Min = GLYPH<151>. 75, Max = 45. 75, Units = ns. 75, Conditions = VDD = 2.0V. 76, Symbol = TDOF. 76, Characteristic = SDO Data Output Fall Time. 76,",
    "FIGURE 26-11: EXAMPLE SPI MASTER MODE TIMING (CKE = 0\nCharacteristic = SDO Data Output Fall Time. 76, Min = GLYPH<151>. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = TSCR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18 F XXXX. 78, Min = GLYPH<151>. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TSCR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18 LF XXXX. 78, Min = GLYPH<151>. 78, Max = 45. 78, Units = ns. 78, Conditions = VDD = 2.0V. 79, Symbol = TSCF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = GLYPH<151>. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TSCH2DOV,",
    "FIGURE 26-11: EXAMPLE SPI MASTER MODE TIMING (CKE = 0\nTSCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 F XXXX. 80, Min = GLYPH<151>. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TSCH2DOV, TSCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 LF XXXX. 80, Min = GLYPH<151>. 80, Max = 100. 80, Units = ns. 80, Conditions = VDD = 2.0V\nNote 1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "FIGURE 26-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\n)\nTABLE 26-14: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1 )",
    "FIGURE 26-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\n71, Symbol = TSCH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 TCY + 30. 71, Max = GLYPH<151>. 71, Units = ns. 71, Conditions = . 71A, Symbol = . 71A, Characteristic = . 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = GLYPH<151>. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TSCL. 72, Characteristic = SCK Input Low Time. 72, Characteristic = Continuous. 72, Min = 1.25 TCY + 30. 72, Max = GLYPH<151>. 72, Units = ns. 72, Conditions = . 72A, Symbol = . 72A, Characteristic = (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = GLYPH<151>. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol =",
    "FIGURE 26-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\nTDIV2SCH, TDIV2SCL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = GLYPH<151>. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Min = 1.5 TCY + 40. 73A, Max = GLYPH<151>. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TSCH2DIL, TSCL2DIL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = GLYPH<151>. 74, Units = ns. 74, Conditions = . 75,",
    "FIGURE 26-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\nSymbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 F XXXX. 75, Min = GLYPH<151>. 75, Max = 25. 75, Units = ns. 75, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXXX. , Min = GLYPH<151>. , Max = 45. , Units = ns. , Conditions = VDD = 2.0V. 76, Symbol = TDOF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = GLYPH<151>. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = TSCR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18 F XXXX. 78, Min = GLYPH<151>. 78, Max = 25. 78, Units = ns. 78, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXXX. , Min =",
    "FIGURE 26-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\nGLYPH<151>. , Max = 45. , Units = ns. , Conditions = VDD = 2.0V. 79, Symbol = TSCF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = GLYPH<151>. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TSCH2DOV, TSCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 F XXXX. 80, Min = GLYPH<151>. 80, Max = 50. 80, Units = ns. 80, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXXX. , Min = GLYPH<151>. , Max = 100. , Units = ns. , Conditions = VDD = 2.0V. 81, Symbol = TDOV2SCH, TDOV2SCL. 81, Characteristic = SDO Data Output Setup to SCK Edge. 81,",
    "FIGURE 26-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\nCharacteristic = SDO Data Output Setup to SCK Edge. 81, Min = TCY. 81, Max = GLYPH<151>. 81, Units = ns. 81, Conditions = \nNote 1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "FIGURE 26-13: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0\n)",
    "TABLE 26-15: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n)\n70, Symbol = TSSL2SCH, TSSL2SCL. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 Input. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 Input. 70, Min = TCY. 70, Max = GLYPH<151>. 70, Units = ns. 70, Conditions = . 71, Symbol = TSCH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 TCY + 30. 71, Max = GLYPH<151>. 71, Units = ns. 71, Conditions = . 71A, Symbol = TSCH. 71A, Characteristic = SCK Input High Time (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = GLYPH<151>. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TSCL. 72, Characteristic = SCK Input Low Time (Slave mode). 72, Characteristic = Continuous. 72, Min =",
    "TABLE 26-15: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n1.25 TCY + 30. 72, Max = GLYPH<151>. 72, Units = ns. 72, Conditions = . 72A, Symbol = TSCL. 72A, Characteristic = SCK Input Low Time (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = GLYPH<151>. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TDIV2SCH, TDIV2SCL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = GLYPH<151>. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Min = 1.5 TCY + 40. 73A,",
    "TABLE 26-15: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\nMax = GLYPH<151>. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TSCH2DIL, TSCL2DIL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = GLYPH<151>. 74, Units = ns. 74, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 F XXXX. 75, Min = GLYPH<151>. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 LF XXXX. 75, Min = GLYPH<151>. 75, Max = 45. 75, Units = ns. 75, Conditions = VDD = 2.0V. 76, Symbol = TDOF. 76, Characteristic = SDO Data Output",
    "TABLE 26-15: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\nFall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = GLYPH<151>. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol = TSSH2DOZ. 77, Characteristic = SS \u2191 to SDO Output High-Impedance. 77, Characteristic = SS \u2191 to SDO Output High-Impedance. 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 78, Symbol = TSCR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18 F XXXX. 78, Min = GLYPH<151>. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TSCR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18 LF XXXX. 78, Min = GLYPH<151>. 78, Max = 45. 78, Units = ns. 78, Conditions = VDD = 2.0V. 79, Symbol =",
    "TABLE 26-15: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\nTSCF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = GLYPH<151>. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TSCH2DOV, TSCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge PIC18 F XXXX. 80, Characteristic = SDO Data Output Valid after SCK Edge PIC18 F XXXX. 80, Min = GLYPH<151>. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TSCH2DOV, TSCL2DOV. 80, Characteristic = . 80, Characteristic = PIC18 LF XXXX. 80, Min = GLYPH<151>. 80, Max = 100. 80, Units = ns. 80, Conditions = VDD = 2.0V. 83, Symbol = TSCH2SSH, TSCL2SSH. 83, Characteristic = SS \u2191 after SCK Edge.",
    "TABLE 26-15: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n83, Characteristic = SS \u2191 after SCK Edge. 83, Min = 1.5 TCY + 40. 83, Max = GLYPH<151>. 83, Units = ns. 83, Conditions = \nNote 1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "FIGURE 26-14: EXAMPLE SPI SLAVE MODE TIMING (CKE = 1\n)",
    "TABLE 26-16: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n)",
    "TABLE 26-16: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n70, Symbol = TSSL2SCH, TSSL2SCL. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 Input. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 Input. 70, Min = TCY. 70, Max = GLYPH<151>. 70, Units = ns. 70, Conditions = . 71 71A, Symbol = TSCH. 71 71A, Characteristic = SCK Input High Time (Slave mode). 71 71A, Characteristic = Continuous. 71 71A, Min = 1.25 TCY + 30. 71 71A, Max = GLYPH<151>. 71 71A, Units = ns. 71 71A, Conditions = . 71 71A, Symbol = TSCH. 71 71A, Characteristic = SCK Input High Time (Slave mode). 71 71A, Characteristic = Single Byte. 71 71A, Min = 40. 71 71A, Max = GLYPH<151>. 71 71A, Units = ns. 71 71A, Conditions = (Note 1). 72 72A, Symbol = TSCL. 72 72A, Characteristic =",
    "TABLE 26-16: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\nSCK Input Low Time (Slave mode). 72 72A, Characteristic = Continuous. 72 72A, Min = 1.25 TCY + 30. 72 72A, Max = GLYPH<151>. 72 72A, Units = ns. 72 72A, Conditions = . 72 72A, Symbol = TSCL. 72 72A, Characteristic = SCK Input Low Time (Slave mode). 72 72A, Characteristic = Single Byte. 72 72A, Min = 40. 72 72A, Max = GLYPH<151>. 72 72A, Units = ns. 72 72A, Conditions = (Note 1). 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Min = 1.5 TCY + 40. 73A, Max = GLYPH<151>. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TSCH2DIL,",
    "TABLE 26-16: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\nTSCL2DIL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = GLYPH<151>. 74, Units = ns. 74, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 F XXXX. 75, Min = GLYPH<151>. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 LF XXXX. 75, Min = GLYPH<151>. 75, Max = 45. 75, Units = ns. 75, Conditions = VDD = 2.0V. 76, Symbol = TDOF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = GLYPH<151>. 76, Max = 25. 76, Units = ns. 76,",
    "TABLE 26-16: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\nConditions = . 77, Symbol = TSSH2DOZ. 77, Characteristic = SS \u2191 to SDO Output High-Impedance. 77, Characteristic = SS \u2191 to SDO Output High-Impedance. 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 78, Symbol = TSCR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18 F XXXX. 78, Min = GLYPH<151>. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TSCR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18 LF XXXX. 78, Min = GLYPH<151>. 78, Max = 45. 78, Units = ns. 78, Conditions = VDD = 2.0V. 79, Symbol = TSCF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = GLYPH<151>.",
    "TABLE 26-16: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TSCH2DOV, TSCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 F XXXX. 80, Min = GLYPH<151>. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TSCH2DOV, TSCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 LF XXXX. 80, Min = GLYPH<151>. 80, Max = 100. 80, Units = ns. 80, Conditions = VDD = 2.0V. 82, Symbol = TSSL2DOV. 82, Characteristic = SDO Data Output Valid after SS \u2193 Edge. 82, Characteristic = PIC18 F XXXX. 82, Min = GLYPH<151>. 82, Max = 50. 82, Units = ns. 82, Conditions = . 82, Symbol = TSSL2DOV. 82, Characteristic = SDO Data",
    "TABLE 26-16: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\nOutput Valid after SS \u2193 Edge. 82, Characteristic = PIC18 LF XXXX. 82, Min = GLYPH<151>. 82, Max = 100. 82, Units = ns. 82, Conditions = VDD = 2.0V. 83, Symbol = TSCH2SSH, TSCL2SSH. 83, Characteristic = SS \u2191 after SCK Edge. 83, Characteristic = SS \u2191 after SCK Edge. 83, Min = 1.5 TCY + 40. 83, Max = GLYPH<151>. 83, Units = ns. 83, Conditions = \nNote 1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "TABLE 26-17: I 2 CGLYPH<153> BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\n90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 4700. 90, Max = GLYPH<151>. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. , Symbol = . , Characteristic = . , Characteristic = 400 kHz mode. , Min = 600. , Max = GLYPH<151>. , Units = . , Conditions = . 91, Symbol = THD:STA. 91, Characteristic = Start Condition. 91, Characteristic = 100 kHz mode. 91, Min = 4000. 91, Max = GLYPH<151>. 91, Units = ns. 91, Conditions = After this period, the first. , Symbol = . , Characteristic = Hold Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = GLYPH<151>. , Units = . , Conditions = clock pulse is generated. 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition. 92, Characteristic = 100 kHz mode. 92, Min =",
    "TABLE 26-17: I 2 CGLYPH<153> BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\n4700. 92, Max = GLYPH<151>. 92, Units = ns. 92, Conditions = . , Symbol = . , Characteristic = Setup Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = GLYPH<151>. , Units = . , Conditions = . 93, Symbol = THD:STO. 93, Characteristic = Stop Condition. 93, Characteristic = 100 kHz mode. 93, Min = 4000. 93, Max = GLYPH<151>. 93, Units = ns. 93, Conditions = . , Symbol = . , Characteristic = Hold Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = GLYPH<151>. , Units = . , Conditions = ",
    "TABLE 26-18: I 2 CGLYPH<153> BUS DATA REQUIREMENTS (SLAVE MODE)\n100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 100 kHz mode. 100, Min = 4.0. 100, Max = GLYPH<151>. 100, Units = \u03bc s. 100, Conditions = PIC18FXXXX must operate at a minimum of 1.5 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 400 kHz mode. 100, Min = 0.6. 100, Max = GLYPH<151>. 100, Units = \u03bc s. 100, Conditions = PIC18FXXXX must operate at a minimum of 10 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = MSSP module. 100, Min = 1.5 TCY. 100, Max = GLYPH<151>. 100, Units = . 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 100 kHz mode. 101, Min = 4.7. 101, Max = GLYPH<151>. 101, Units = \u03bc s.",
    "TABLE 26-18: I 2 CGLYPH<153> BUS DATA REQUIREMENTS (SLAVE MODE)\n101, Conditions = PIC18FXXXX must operate at a minimum of 1.5 MHz. 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 400 kHz mode. 101, Min = 1.3. 101, Max = GLYPH<151>. 101, Units = \u03bc s. 101, Conditions = PIC18FXXXX must operate at a minimum of 10 MHz. 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = MSSP module. 101, Min = 1.5 TCY. 101, Max = GLYPH<151>. 101, Units = . 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 100 kHz mode. 102, Min = GLYPH<151>. 102, Max = 1000. 102, Units = ns. 102, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max =",
    "TABLE 26-18: I 2 CGLYPH<153> BUS DATA REQUIREMENTS (SLAVE MODE)\n300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 100 kHz mode. 103, Min = GLYPH<151>. 103, Max = 300. 103, Units = ns. 103, Conditions = . 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 4.7. 90, Max = GLYPH<151>. 90, Units = \u03bc s. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode.",
    "TABLE 26-18: I 2 CGLYPH<153> BUS DATA REQUIREMENTS (SLAVE MODE)\n90, Min = 0.6. 90, Max = GLYPH<151>. 90, Units = \u03bc s. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD:STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode. 91, Min = 4.0. 91, Max = GLYPH<151>. 91, Units = \u03bc s. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 0.6. 91, Max = GLYPH<151>. 91, Units = \u03bc s. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD:DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = GLYPH<151>. 106, Units = ns. 106, Conditions = . 106, Symbol = THD:DAT.",
    "TABLE 26-18: I 2 CGLYPH<153> BUS DATA REQUIREMENTS (SLAVE MODE)\n106, Characteristic = Data Input Hold Time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = \u03bc s. 106, Conditions = . 107, Symbol = TSU:DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = GLYPH<151>. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = TSU:DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = GLYPH<151>. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 4.7. 92, Max = GLYPH<151>. 92, Units = \u03bc s. 92, Conditions = . 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition Setup Time.",
    "TABLE 26-18: I 2 CGLYPH<153> BUS DATA REQUIREMENTS (SLAVE MODE)\n92, Characteristic = 400 kHz mode. 92, Min = 0.6. 92, Max = GLYPH<151>. 92, Units = \u03bc s. 92, Conditions = . 109, Symbol = TAA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 100 kHz mode. 109, Min = GLYPH<151>. 109, Max = 3500. 109, Units = ns. 109, Conditions = (Note 1). 109, Symbol = TAA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 400 kHz mode. 109, Min = GLYPH<151>. 109, Max = GLYPH<151>. 109, Units = ns. 109, Conditions = (Note 1). 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = GLYPH<151>. 110, Units = \u03bc s. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free",
    "TABLE 26-18: I 2 CGLYPH<153> BUS DATA REQUIREMENTS (SLAVE MODE)\nTime. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = GLYPH<151>. 110, Units = \u03bc s. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = Bus Capacitive Loading. D102, Characteristic = . D102, Min = GLYPH<151>. D102, Max = 400. D102, Units = pF. D102, Conditions = ",
    "TABLE 26-18: I 2 CGLYPH<153> BUS DATA REQUIREMENTS (SLAVE MODE)\nNote 1: As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of Start or Stop conditions.\n2: A Fast mode I 2 C bus device can be used in a Standard mode I 2 CGLYPH<153> bus system, but the requirement, TSU:DAT \u2265 250 ns, must then be met. This will automatically be the case if the device does not stretch the LOW period of the SCL signal. If such a device does stretch the LOW period of the SCL signal, it must output the next data bit to the SDA line, TR max. + TSU:DAT = 1000 + 250 = 1250 ns (according to the Standard mode I 2 C bus specification), before the SCL line\nis released.",
    "TABLE 26-19: MASTER SSP I 2 CGLYPH<153> BUS START/STOP BITS REQUIREMENTS\n\nNote 1: Maximum pin capacitance = 10 pF for all I 2 CGLYPH<153> pins.",
    "TABLE 26-19: MASTER SSP I 2 CGLYPH<153> BUS START/STOP BITS REQUIREMENTS\n90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = GLYPH<151>. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = TSU:STA. 90, Characteristic = . 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = GLYPH<151>. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = TSU:STA. 90, Characteristic = . 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = GLYPH<151>. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD:STA. 91, Characteristic = Start Condition. 91, Characteristic = 100 kHz",
    "TABLE 26-19: MASTER SSP I 2 CGLYPH<153> BUS START/STOP BITS REQUIREMENTS\nmode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = GLYPH<151>. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = GLYPH<151>. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = . 91, Characteristic = 1 MHz mode (1). 91, Min = 2(T OSC)(BRG + 1). 91, Max = GLYPH<151>. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition. 92, Characteristic = 100 kHz mode. 92, Min = 2(T",
    "TABLE 26-19: MASTER SSP I 2 CGLYPH<153> BUS START/STOP BITS REQUIREMENTS\nOSC)(BRG + 1). 92, Max = GLYPH<151>. 92, Units = ns. 92, Conditions = . 92, Symbol = TSU:STO. 92, Characteristic = Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = GLYPH<151>. 92, Units = ns. 92, Conditions = . 92, Symbol = TSU:STO. 92, Characteristic = . 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = GLYPH<151>. 92, Units = ns. 92, Conditions = . 93, Symbol = THD:STO. 93, Characteristic = Stop Condition. 93, Characteristic = 100 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max = GLYPH<151>. 93, Units = ns. 93, Conditions = . 93, Symbol =",
    "TABLE 26-19: MASTER SSP I 2 CGLYPH<153> BUS START/STOP BITS REQUIREMENTS\nTHD:STO. 93, Characteristic = Hold Time. 93, Characteristic = 400 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max = GLYPH<151>. 93, Units = ns. 93, Conditions = . 93, Symbol = THD:STO. 93, Characteristic = . 93, Characteristic = 1 MHz mode (1). 93, Min = 2(T OSC)(BRG + 1). 93, Max = GLYPH<151>. 93, Units = ns. 93, Conditions = ",
    "TABLE 26-20: MASTER SSP I 2 CGLYPH<153> BUS DATA REQUIREMENTS\n100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 100 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = GLYPH<151>. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 400 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = GLYPH<151>. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 1 MHz mode (1). 100, Min = 2(T OSC)(BRG + 1). 100, Max = GLYPH<151>. 100, Units = ms. 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 100 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = GLYPH<151>.",
    "TABLE 26-20: MASTER SSP I 2 CGLYPH<153> BUS DATA REQUIREMENTS\n101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 400 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = GLYPH<151>. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 1 MHz mode (1). 101, Min = 2(T OSC)(BRG + 1). 101, Max = GLYPH<151>. 101, Units = ms. 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 100 kHz mode. 102, Min = GLYPH<151>. 102, Max = 1000. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 400 kHz mode. 102, Min = 20 +",
    "TABLE 26-20: MASTER SSP I 2 CGLYPH<153> BUS DATA REQUIREMENTS\n0.1 CB. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 1 MHz mode (1). 102, Min = GLYPH<151>. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 100 kHz mode. 103, Min = GLYPH<151>. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol =",
    "TABLE 26-20: MASTER SSP I 2 CGLYPH<153> BUS DATA REQUIREMENTS\nTF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 1 MHz mode (1). 103, Min = GLYPH<151>. 103, Max = 100. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = GLYPH<151>. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = GLYPH<151>. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 1 MHz mode",
    "TABLE 26-20: MASTER SSP I 2 CGLYPH<153> BUS DATA REQUIREMENTS\n(1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = GLYPH<151>. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD:STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = GLYPH<151>. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = GLYPH<151>. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 1 MHz mode (1). 91, Min =",
    "TABLE 26-20: MASTER SSP I 2 CGLYPH<153> BUS DATA REQUIREMENTS\n2(T OSC)(BRG + 1). 91, Max = GLYPH<151>. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD:DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = GLYPH<151>. 106, Units = ns. 106, Conditions = . 106, Symbol = THD:DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = ms. 106, Conditions = . 106, Symbol = THD:DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 1 MHz mode (1). 106, Min = GLYPH<151>. 106, Max = GLYPH<151>. 106, Units = ns. 106, Conditions = . 107, Symbol = TSU:DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 100 kHz",
    "TABLE 26-20: MASTER SSP I 2 CGLYPH<153> BUS DATA REQUIREMENTS\nmode. 107, Min = 250. 107, Max = GLYPH<151>. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = TSU:DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = GLYPH<151>. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = TSU:DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 1 MHz mode (1). 107, Min = GLYPH<151>. 107, Max = GLYPH<151>. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = GLYPH<151>. 92, Units = ms. 92, Conditions = . 92, Symbol = TSU:STO. 92, Characteristic",
    "TABLE 26-20: MASTER SSP I 2 CGLYPH<153> BUS DATA REQUIREMENTS\n= Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = GLYPH<151>. 92, Units = ms. 92, Conditions = . 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = GLYPH<151>. 92, Units = ms. 92, Conditions = . 109, Symbol = TAA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 100 kHz mode. 109, Min = GLYPH<151>. 109, Max = 3500. 109, Units = ns. 109, Conditions = . 109, Symbol = TAA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 400 kHz mode. 109, Min = GLYPH<151>. 109, Max = 1000. 109, Units = ns. 109, Conditions = . 109, Symbol = TAA. 109, Characteristic",
    "TABLE 26-20: MASTER SSP I 2 CGLYPH<153> BUS DATA REQUIREMENTS\n= Output Valid from Clock. 109, Characteristic = 1 MHz mode (1). 109, Min = GLYPH<151>. 109, Max = GLYPH<151>. 109, Units = ns. 109, Conditions = . 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = GLYPH<151>. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = GLYPH<151>. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 1 MHz mode (1). 110, Min = GLYPH<151>. 110, Max = GLYPH<151>. 110, Units = ms. 110, Conditions",
    "TABLE 26-20: MASTER SSP I 2 CGLYPH<153> BUS DATA REQUIREMENTS\n= Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = Bus Capacitive Loading. D102, Characteristic = Bus Capacitive Loading. D102, Min = GLYPH<151>. D102, Max = 400. D102, Units = pF. D102, Conditions = \nNote 1: Maximum pin capacitance = 10 pF for all I 2 CGLYPH<153> pins.\n2: A Fast mode I 2 C bus device can be used in a Standard mode I 2 C bus system, but parameter #107 \u2265 250 ns must then be met. This will automatically be the case if the device does not stretch the LOW period of the SCL signal. If such a device does stretch the LOW period of the SCL signal, it must output the next data bit to the SDA line, parameter #102 + parameter #107 = 1000 + 250 = 1250 ns (for 100 kHz mode,) before the SCL line is released.",
    "TABLE 26-21: USART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n120, Symbol = TCKH2DTV. 120, Characteristic = SYNC XMIT (MASTER and SLAVE) Clock High to Data Out Valid. 120, Characteristic = PIC18 F XXXX. 120, Min = GLYPH<151>. 120, Max = 40. 120, Units = ns. 120, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXXX. , Min = GLYPH<151>. , Max = 100. , Units = ns. , Conditions = VDD = 2.0V. 121, Symbol = TCKRF. 121, Characteristic = Clock Out Rise Time and Fall Time. 121, Characteristic = PIC18 F XXXX. 121, Min = GLYPH<151>. 121, Max = 20. 121, Units = ns. 121, Conditions = . , Symbol = . , Characteristic = (Master mode). , Characteristic = PIC18 LF XXXX. , Min = GLYPH<151>. , Max = 50. , Units = ns. , Conditions = VDD = 2.0V. 122, Symbol = TDTRF. 122, Characteristic = Data Out Rise Time",
    "TABLE 26-21: USART SYNCHRONOUS TRANSMISSION REQUIREMENTS\nand Fall Time. 122, Characteristic = PIC18 F XXXX. 122, Min = GLYPH<151>. 122, Max = 20. 122, Units = ns. 122, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXXX. , Min = GLYPH<151>. , Max = 50. , Units = ns. , Conditions = VDD = 2.0V",
    "TABLE 26-22: USART SYNCHRONOUS RECEIVE REQUIREMENTS\n125, Symbol = TDTV2CKL. 125, Characteristic = SYNC RCV (MASTER and SLAVE) Data Hold before CKx \u2193 (DTx hold time). 125, Min = 10. 125, Max = GLYPH<151>. 125, Units = ns. 125, Conditions = . 126, Symbol = TCKL2DTL. 126, Characteristic = Data Hold after CKx \u2193 (DTx hold time). 126, Min = 15. 126, Max = GLYPH<151>. 126, Units = ns. 126, Conditions = ",
    "TABLE 26-23: A/D CONVERTER CHARACTERISTICS: PIC18F6390/6490/8390/8490 (INDUSTRIAL) PIC18LF6390/6490/8390/8490 (INDUSTRIAL)\nA01, Symbol = NR. A01, Characteristic = Resolution. A01, Min = GLYPH<151>. A01, Typ = GLYPH<151>. A01, Max = 10. A01, Units = bit. A01, Conditions = \u0394 VREF \u2265 3.0V. A03, Symbol = EIL. A03, Characteristic = Integral Linearity Error. A03, Min = GLYPH<151>. A03, Typ = GLYPH<151>. A03, Max = <-1. A03, Units = LSb. A03, Conditions = \u0394 VREF \u2265 3.0V. A04, Symbol = EDL. A04, Characteristic = Differential Linearity Error. A04, Min = GLYPH<151>. A04, Typ = GLYPH<151>. A04, Max = <-1.",
    "TABLE 26-23: A/D CONVERTER CHARACTERISTICS: PIC18F6390/6490/8390/8490 (INDUSTRIAL) PIC18LF6390/6490/8390/8490 (INDUSTRIAL)\nA04, Units = LSb. A04, Conditions = \u0394 VREF \u2265 3.0V. A06, Symbol = EOFF. A06, Characteristic = Offset Error. A06, Min = GLYPH<151>. A06, Typ = GLYPH<151>. A06, Max = <-1. A06, Units = LSb. A06, Conditions = \u0394 VREF \u2265 3.0V. A07, Symbol = EGN. A07, Characteristic = Gain Error. A07, Min = GLYPH<151>. A07, Typ = GLYPH<151>. A07, Max = <-1. A07, Units = LSb. A07, Conditions = \u0394 VREF \u2265 3.0V. A10, Symbol = GLYPH<151>. A10, Characteristic = Monotonicity. A10, Min =",
    "TABLE 26-23: A/D CONVERTER CHARACTERISTICS: PIC18F6390/6490/8390/8490 (INDUSTRIAL) PIC18LF6390/6490/8390/8490 (INDUSTRIAL)\nGuaranteed (1). A10, Typ = Guaranteed (1). A10, Max = Guaranteed (1). A10, Units = GLYPH<151>. A10, Conditions = . A20, Symbol = \u0394 VREF. A20, Characteristic = Reference Voltage Range (VREFH GLYPH<150> VREFL). A20, Min = 3. A20, Typ = GLYPH<151>. A20, Max = AVDD GLYPH<150> AVSS. A20, Units = V. A20, Conditions = For 10-bit resolution. A21, Symbol = VREFH. A21, Characteristic = Reference Voltage High. A21, Min = AVSS + 3.0V. A21, Typ = GLYPH<151>. A21, Max = AVDD + 0.3V. A21, Units = V. A21, Conditions = For 10-bit resolution. A22,",
    "TABLE 26-23: A/D CONVERTER CHARACTERISTICS: PIC18F6390/6490/8390/8490 (INDUSTRIAL) PIC18LF6390/6490/8390/8490 (INDUSTRIAL)\nSymbol = VREFL. A22, Characteristic = Reference Voltage Low. A22, Min = AVSS GLYPH<150> 0.3V. A22, Typ = GLYPH<151>. A22, Max = AVDD GLYPH<150> 3.0V. A22, Units = V. A22, Conditions = For 10-bit resolution. A25, Symbol = VAIN. A25, Characteristic = Analog Input Voltage. A25, Min = VREFL. A25, Typ = GLYPH<151>. A25, Max = VREFH. A25, Units = V. A25, Conditions = . A30, Symbol = ZAIN. A30, Characteristic = Recommended Impedance of Analog Voltage Source. A30, Min = GLYPH<151>. A30, Typ = GLYPH<151>. A30, Max = 2.5. A30, Units = k \u03a9. A30,",
    "TABLE 26-23: A/D CONVERTER CHARACTERISTICS: PIC18F6390/6490/8390/8490 (INDUSTRIAL) PIC18LF6390/6490/8390/8490 (INDUSTRIAL)\nConditions = . A50, Symbol = I REF. A50, Characteristic = VREF Input Current (Note 2). A50, Min = GLYPH<151> GLYPH<151>. A50, Typ = GLYPH<151> GLYPH<151>. A50, Max = -5 -150. A50, Units = \u03bc A \u03bc A. A50, Conditions = During VAIN acquisition. During A/D conversion cycle.\nNote 1: The A/D conversion result never decreases with an increase in the input voltage and has no missing codes.\n2: VREFH current is from RA3/AN3/VREF+/SEG17 pin or AVDD, whichever is selected as the VREFH source. VREFL current is from RA2/AN2/VREF-/SEG16 pin or AVSS, whichever is selected as the VREFL source.",
    "FIGURE 26-21: A/D CONVERSION TIMING\nNote 1: If the A/D clock source is selected as RC, a time of TCY is added before the A/D clock starts. This allows the SLEEP instruction to be executed.\n2: This is a minimal RC delay (typically 100 ns), which also disconnects the holding capacitor from the analog input.",
    "TABLE 26-24: A/D CONVERSION REQUIREMENTS\n130, Symbol = TAD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18 F XXXX. 130, Min = 0.7. 130, Max = 25.0 (1). 130, Units = \u03bc s. 130, Conditions = TOSC based, VREF \u2265 3.0V. 130, Symbol = TAD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18 LF XXXX. 130, Min = 1.4. 130, Max = 25.0 (1). 130, Units = \u03bc s. 130, Conditions = VDD = 2.0V; TOSC based, VREF full range. 130, Symbol = TAD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18 F XXXX. 130, Min = TBD. 130, Max = 1. 130, Units = \u03bc s. 130, Conditions = A/D RC mode. 130, Symbol = TAD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18 LF XXXX. 130, Min = TBD. 130, Max = 3. 130, Units = \u03bc s.",
    "TABLE 26-24: A/D CONVERSION REQUIREMENTS\n130, Conditions = VDD = 2.0V; A/D RC mode. 131, Symbol = TCNV. 131, Characteristic = Conversion Time (not including acquisition time) (Note 2). 131, Characteristic = Conversion Time (not including acquisition time) (Note 2). 131, Min = 11. 131, Max = 12. 131, Units = TAD. 131, Conditions = . 132, Symbol = TACQ. 132, Characteristic = Acquisition Time (Note 3). 132, Characteristic = Acquisition Time (Note 3). 132, Min = 1.4 TBD. 132, Max = GLYPH<151> GLYPH<151>. 132, Units = \u03bc s \u03bc s. 132, Conditions = -40 \u00b0 C to +85 \u00b0 C 0 \u00b0 C \u2264 to \u2264 +85 \u00b0 C. 135, Symbol = TSWC. 135, Characteristic = Switching Time from Convert \u2192 Sample. 135, Characteristic = Switching Time from Convert \u2192 Sample. 135, Min = GLYPH<151>. 135, Max = (Note 4). 135, Units = . 135, Conditions = . TBD, Symbol = TDIS. TBD, Characteristic = Discharge",
    "TABLE 26-24: A/D CONVERSION REQUIREMENTS\nTime. TBD, Characteristic = Discharge Time. TBD, Min = 0.2. TBD, Max = GLYPH<151>. TBD, Units = \u03bc s. TBD, Conditions = \nLegend: TBD = To Be Determined\nNote 1: The time of the A/D clock period is dependent on the device frequency and the TAD clock divider.\n2: ADRES register may be read on the following TCY cycle.\n3: The time for the holding capacitor to acquire the GLYPH<147>NewGLYPH<148> input voltage when the voltage changes full scale after the conversion (VDD to VSS or VSS to VDD). The source impedance (RS) on the input channels is 50 \u03a9 .\n4: On the following cycle of the device clock.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "27.0 DC AND AC CHARACTERISTICS GRAPHS AND TABLES\nGraphs and tables are not available at this time.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "Legend:\nXX...X\nCustomer-specific information\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week GLYPH<145>01GLYPH<146>)\nNNN\nAlphanumeric traceability code\nPb-free JEDEC designator for Matte Tin (Sn)\n*\nThis package is Pb-free. The Pb-free JEDEC designator (     ) 3 e\ncan be found on the outer packaging for this package.",
    "Note :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.\n3\ne",
    "28.2 Package Details\nThe following sections give the technical details of the packages.",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g49/g82/g87/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng72/g29",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g41/g82/g85/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g87/g75/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng72/g3/g80/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng82/g86/g87/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g70/g88/g85",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng85/g72/g81/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng87/g3/g83/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g70/g78/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g74/g72/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g71/g85/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g90/g76/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng81/g74/g86/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng15/g3/g83/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng79/g72/g68/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng86/g72/g3/g86",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng72/g72/g3/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng87/g75/g72/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g48/g76/g70",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng85/g82/g70/g75",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng76/g83/g3/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng51/g68/g70/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng78/g68/g74/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng76/g81/g74/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g54",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g83/g72/g70/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng76/g73/g76/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g68/g87/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng76/g82/g81/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g79/g82/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g68/g87/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng72/g71/g3/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g87/g3",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g75/g87/g87/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng83/g29/g18/g18",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng90/g90/g90",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g17/g80/g76/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g85/g82/g70",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng75/g76/g83/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng17/g70/g82/g80",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng18/g83/g68/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g78/g68/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng74/g76/g81/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng74\n\u03b1\nA2",
    "/g49/g82/g87/g72/g86/g29\n/g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g47/g72/g68/g71/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g49. /g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g47/g72/g68/g71/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/g29\n/g25/g23. /g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g47/g72/g68/g71/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g25/g23. /g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g47/g72/g68/g71/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g25/g23.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g72/g68/g71/g3/g51/g76/g87/g70/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g72. /g47/g72/g68/g71/g3/g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g19/g17/g24/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g72/g68/g71/g3/g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g19/g17/g24/g19/g3/g37/g54/g38. /g47/g72/g68/g71/g3/g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g19/g17/g24/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g50/g89/g72/g85/g68/g79/g79/g3/g43/g72/g76/g74/g75/g87, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g36. /g50/g89/g72/g85/g68/g79/g79/g3/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g177.",
    "/g49/g82/g87/g72/g86/g29\n/g50/g89/g72/g85/g68/g79/g79/g3/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g50/g89/g72/g85/g68/g79/g79/g3/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g17/g21/g19.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g36/g21.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g19/g17/g28/g24. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g17/g19/g19. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g17/g19/g24.",
    "/g49/g82/g87/g72/g86/g29\n/g54/g87/g68/g81/g71/g82/g73/g73/g3/g3, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g36/g20. /g54/g87/g68/g81/g71/g82/g73/g73/g3/g3, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g19/g17/g19/g24.",
    "/g49/g82/g87/g72/g86/g29\n/g54/g87/g68/g81/g71/g82/g73/g73/g3/g3, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g54/g87/g68/g81/g71/g82/g73/g73/g3/g3, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g19/g17/g20/g24. /g41/g82/g82/g87/g3/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g47. /g41/g82/g82/g87/g3/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g19/g17/g23/g24. /g41/g82/g82/g87/g3/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g19/g17/g25/g19. /g41/g82/g82/g87/g3/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g19/g17/g26/g24. /g41/g82/g82/g87/g83/g85/g76/g81/g87,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g47/g20. /g41/g82/g82/g87/g83/g85/g76/g81/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20/g17/g19/g19/g3/g53/g40/g41. /g41/g82/g82/g87/g83/g85/g76/g81/g87,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g17/g19/g19/g3/g53/g40/g41. /g41/g82/g82/g87/g83/g85/g76/g81/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g17/g19/g19/g3/g53/g40/g41. /g41/g82/g82/g87/g3/g36/g81/g74/g79/g72,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g73. /g41/g82/g82/g87/g3/g36/g81/g74/g79/g72, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g19/g131. /g41/g82/g82/g87/g3/g36/g81/g74/g79/g72,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g22/g17/g24/g131. /g41/g82/g82/g87/g3/g36/g81/g74/g79/g72, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g26/g131. /g50/g89/g72/g85/g68/g79/g79/g3/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g40. /g50/g89/g72/g85/g68/g79/g79/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20/g21/g17/g19/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g50/g89/g72/g85/g68/g79/g79/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g21/g17/g19/g19/g3/g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/g29\n/g20/g21/g17/g19/g19/g3/g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/g74/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g39. /g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20/g21/g17/g19/g19/g3/g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g21/g17/g19/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g21/g17/g19/g19/g3/g37/g54/g38. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g40/g20. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20/g19/g17/g19/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g19/g17/g19/g19/g3/g37/g54/g38. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g19/g17/g19/g19/g3/g37/g54/g38. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g47/g72/g81/g74/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g39/g20.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20/g19/g17/g19/g19/g3/g37/g54/g38. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g19/g17/g19/g19/g3/g37/g54/g38. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g19/g17/g19/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g70. /g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/g29\n/g19/g17/g19/g28. /g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g19/g17/g21/g19.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g69. /g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g19/g17/g20/g26.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g19/g17/g21/g21. /g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g19/g17/g21/g26.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g55 /g82/g83, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g68. /g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g55 /g82/g83,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20 /g20/g131. /g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g55 /g82/g83, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g21/g131.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g55 /g82/g83, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g22/g131. /g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g37/g82/g87/g87/g82/g80,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g69. /g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g37/g82/g87/g87/g82/g80, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20 /g20/g131.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g37/g82/g87/g87/g82/g80, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g21/g131. /g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g37/g82/g87/g87/g82/g80,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g22/g131\n/g20/g17 /g51/g76/g81/g3/g20/g3/g89/g76/g86/g88/g68/g79/g3/g76/g81/g71/g72/g91/g3/g73/g72/g68/g87/g88/g85/g72/g3/g80/g68/g92/g3/g89/g68/g85/g92",
    "/g49/g82/g87/g72/g86/g29\n/g15/g3/g69/g88/g87/g3/g80/g88/g86/g87/g3/g69/g72/g3/g79/g82/g70/g68/g87/g72/g71/g3/g90/g76/g87/g75/g76/g81/g3/g87/g75/g72/g3/g75/g68/g87/g70/g75/g72/g71/g3/g68/g85/g72/g68/g17",
    "/g49/g82/g87/g72/g86/g29\n/g21/g17 /g38/g75/g68/g80/g73/g72/g85/g86/g3/g68/g87/g3/g70/g82/g85/g81/g72/g85/g86/g3/g68/g85/g72/g3/g82/g83/g87/g76/g82/g81/g68/g79/g30/g3/g86/g76/g93/g72/g3/g80/g68/g92/g3/g89/g68/g85/g92 /g17\n/g22/g17",
    "/g49/g82/g87/g72/g86/g29\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g86/g3/g39/g20/g3/g68/g81/g71/g3/g40/g20/g3/g71/g82/g3/g81/g82/g87/g3/g76/g81/g70/g79/g88/g71/g72/g3/g80/g82/g79/g71/g3/g73/g79/g68/g86/g75/g3/g82/g85/g3/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/g17/g3/g48/g82/g79/",
    "/g49/g82/g87/g72/g86/g29\ng71/g3/g73/g79/g68/g86/g75/g3/g82/g85/g3/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/g3/g86/g75/g68/g79/g79/g3/g81/g82/g87/g3/g72/g91/g70/g72/g72/g71/g3/g19/g17/g21/g24/g3/g80/g80/g3/g83/g72/g85/g3/g86/g76/g71/g72/g17",
    "/g49/g82/g87/g72/g86/g29\n/g23/g17 /g39/g76/g80/g72/g81/g86/g76/g82/g81/g76/g81/g74/g3/g68/g81/g71/g3/g87/g82/g79/g72/g85/g68/g81/g70/g76/g81/g74/g3/g83/g72/g85/g3/g36/g54/g48/g40/g3/g60/g20/g23/g17/g24/g48/g17\n/g37/g54/g38/g29",
    "/g49/g82/g87/g72/g86/g29\n/g37/g68/g86/g76/g70/g3/g39/g76/g80/g72/g81/g86/g76/g82/g81/g17/g3/g55/g75/g72/g82/g85/g72/g87/g76/g70/g68/g79/g79/g92/g3/g72/g91/g68/g70/g87/g3/g89/g68/g79/g88/g72/g3/g86/g75/g82/g90/g81/g3/g90/g76/g87/g75/g82/g88/g87/g3/g87/g82/g79/g72/g85/g68/g81/g70/",
    "/g49/g82/g87/g72/g86/g29\ng72/g86/g17\n/g48/g76/g70/g85/g82/g70/g75/g76/g83 /g55 /g72/g70/g75/g81/g82/g79/g82/g74/g92 /g39/g85/g68/g90/g76/g81/g74 /g38/g19/g23/g16/g19/g27/g24/g37\n/g53/g40/g41/g29",
    "/g49/g82/g87/g72/g86/g29\n/g53/g72/g73/g72/g85/g72/g81/g70/g72/g3/g39/g76/g80/g72/g81/g86/g76/g82/g81/g15/g3/g88/g86/g88/g68/g79/g79/g92/g3/g90/g76/g87/g75/g82/g88/g87/g3/g87/g82/g79/g72/g85/g68/g81/g70/g72/g15/g3/g73/g82/g85/g3/g76/g81/g73/g82/g85/g80/g68/g87/g76/g82/g81/g3/",
    "/g49/g82/g87/g72/g86/g29\ng83/g88/g85/g83/g82/g86/g72/g86/g3/g82/g81/g79/g92\n/g17",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g49/g82/g87/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng72/g29,\n1 =",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g41/g82/g85/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g87/g75/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng72/g3/g80/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng82/g86/g87/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g70/g88/g85",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng85/g72/g81/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng87/g3/g83/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g70/g78/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g74/g72/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g71/g85/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g90/g76/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng81/g74/g86/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng15/g3/g83/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng79/g72/g68/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng86/g72/g3/g86",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng72/g72/g3/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng87/g75/g72/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g48/g76/g70",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng85/g82/g70/g75",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng76/g83/g3/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng51/g68/g70/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng78/g68/g74/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng76/g81/g74/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g54",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g83/g72/g70/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng76/g73/g76/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g68/g87/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng76/g82/g81/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g79/g82/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g68/g87/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng72/g71/g3/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g87/g3",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g75/g87/g87/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng83/g29/g18/g18",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng90/g90/g90",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g17/g80/g76/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g85/g82/g70",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng75/g76/g83/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng17/g70/g82/g80",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng18/g83/g68/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g78/g68/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng74/g76/g81/",
    "/g25/g23/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g19/g91/g20/g19/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng74",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g49/g82/g87/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng72/g29",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g41/g82/g85/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g87/g75/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng72/g3/g80/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng82/g86/g87/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g70/g88/g85",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng85/g72/g81/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng87/g3/g83/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g70/g78/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g74/g72/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g71/g85/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g90/g76/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng81/g74/g86/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng15/g3/g83/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng79/g72/g68/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng86/g72/g3/g86",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng72/g72/g3/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng87/g75/g72/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g48/g76/g70",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng85/g82/g70/g75",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng76/g83/g3/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng51/g68/g70/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng78/g68/g74/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng76/g81/g74/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g54",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g83/g72/g70/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng76/g73/g76/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g68/g87/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng76/g82/g81/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g79/g82/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g68/g87/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng72/g71/g3/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g87/g3",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g75/g87/g87/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng83/g29/g18/g18",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng90/g90/g90",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g17/g80/g76/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g85/g82/g70",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng75/g76/g83/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng17/g70/g82/g80",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng18/g83/g68/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g78/g68/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng74/g76/g81/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng74\n\u03b1",
    "/g49/g82/g87/g72/g86/g29\n/g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g47/g72/g68/g71/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g49. /g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g47/g72/g68/g71/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/g29\n/g27/g19. /g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g47/g72/g68/g71/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g27/g19. /g49/g88/g80/g69/g72/g85/g3/g82/g73/g3/g47/g72/g68/g71/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g27/g19.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g72/g68/g71/g3/g51/g76/g87/g70/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g72. /g47/g72/g68/g71/g3/g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g19/g17/g24/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g72/g68/g71/g3/g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g19/g17/g24/g19/g3/g37/g54/g38. /g47/g72/g68/g71/g3/g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g19/g17/g24/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g50/g89/g72/g85/g68/g79/g79/g3/g43/g72/g76/g74/g75/g87, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g36. /g50/g89/g72/g85/g68/g79/g79/g3/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g177.",
    "/g49/g82/g87/g72/g86/g29\n/g50/g89/g72/g85/g68/g79/g79/g3/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g50/g89/g72/g85/g68/g79/g79/g3/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g17/g21/g19.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g36/g21.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g19/g17/g28/g24. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g17/g19/g19. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g17/g19/g24.",
    "/g49/g82/g87/g72/g86/g29\n/g54/g87/g68/g81/g71/g82/g73/g73/g3/g3, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g36/g20. /g54/g87/g68/g81/g71/g82/g73/g73/g3/g3, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g19/g17/g19/g24.",
    "/g49/g82/g87/g72/g86/g29\n/g54/g87/g68/g81/g71/g82/g73/g73/g3/g3, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g54/g87/g68/g81/g71/g82/g73/g73/g3/g3, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g19/g17/g20/g24. /g41/g82/g82/g87/g3/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g47. /g41/g82/g82/g87/g3/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g19/g17/g23/g24. /g41/g82/g82/g87/g3/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g19/g17/g25/g19. /g41/g82/g82/g87/g3/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g19/g17/g26/g24. /g41/g82/g82/g87/g83/g85/g76/g81/g87,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g47/g20. /g41/g82/g82/g87/g83/g85/g76/g81/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20/g17/g19/g19/g3/g53/g40/g41. /g41/g82/g82/g87/g83/g85/g76/g81/g87,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g17/g19/g19/g3/g53/g40/g41. /g41/g82/g82/g87/g83/g85/g76/g81/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g17/g19/g19/g3/g53/g40/g41. /g41/g82/g82/g87/g3/g36/g81/g74/g79/g72,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g73. /g41/g82/g82/g87/g3/g36/g81/g74/g79/g72, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g19/g131. /g41/g82/g82/g87/g3/g36/g81/g74/g79/g72,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g22/g17/g24/g131. /g41/g82/g82/g87/g3/g36/g81/g74/g79/g72, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g26/g131. /g50/g89/g72/g85/g68/g79/g79/g3/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g40. /g50/g89/g72/g85/g68/g79/g79/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20/g23/g17/g19/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g50/g89/g72/g85/g68/g79/g79/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g23/g17/g19/g19/g3/g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/g29\n/g20/g23/g17/g19/g19/g3/g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/g74/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g39. /g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20/g23/g17/g19/g19/g3/g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g23/g17/g19/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g50/g89/g72/g85/g68/g79/g79/g3/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g23/g17/g19/g19/g3/g37/g54/g38. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g40/g20. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20/g21/g17/g19/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g21/g17/g19/g19/g3/g37/g54/g38. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g21/g17/g19/g19/g3/g37/g54/g38. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g47/g72/g81/g74/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g39/g20.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20/g21/g17/g19/g19/g3/g37/g54/g38. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g21/g17/g19/g19/g3/g37/g54/g38. /g48/g82/g79/g71/g72/g71/g3/g51/g68/g70/g78/g68/g74/g72/g3/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g21/g17/g19/g19/g3/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g70. /g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/g29\n/g19/g17/g19/g28. /g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g47/g72/g68/g71/g3/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g19/g17/g21/g19.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g69. /g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g19/g17/g20/g26.",
    "/g49/g82/g87/g72/g86/g29\n/g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g19/g17/g21/g21. /g47/g72/g68/g71/g3/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g19/g17/g21/g26.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g55 /g82/g83, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g68. /g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g55 /g82/g83,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20 /g20/g131. /g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g55 /g82/g83, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g21/g131.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g55 /g82/g83, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g22/g131. /g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g37/g82/g87/g87/g82/g80,",
    "/g49/g82/g87/g72/g86/g29\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/g3/g47/g76/g80/g76/g87/g86 = /g69. /g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g37/g82/g87/g87/g82/g80, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g20 /g20/g131.",
    "/g49/g82/g87/g72/g86/g29\n/g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g37/g82/g87/g87/g82/g80, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g20/g21/g131. /g48/g82/g79/g71/g3/g39/g85/g68/g73/g87/g3/g36/g81/g74/g79/g72/g3/g37/g82/g87/g87/g82/g80,",
    "/g49/g82/g87/g72/g86/g29\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g20/g22/g131\n/g20/g17 /g51/g76/g81/g3/g20/g3/g89/g76/g86/g88/g68/g79/g3/g76/g81/g71/g72/g91/g3/g73/g72/g68/g87/g88/g85/g72/g3/g80/g68/g92/g3/g89/g68/g85/g92",
    "/g49/g82/g87/g72/g86/g29\n/g15/g3/g69/g88/g87/g3/g80/g88/g86/g87/g3/g69/g72/g3/g79/g82/g70/g68/g87/g72/g71/g3/g90/g76/g87/g75/g76/g81/g3/g87/g75/g72/g3/g75/g68/g87/g70/g75/g72/g71/g3/g68/g85/g72/g68/g17",
    "/g49/g82/g87/g72/g86/g29\n/g21/g17 /g38/g75/g68/g80/g73/g72/g85/g86/g3/g68/g87/g3/g70/g82/g85/g81/g72/g85/g86/g3/g68/g85/g72/g3/g82/g83/g87/g76/g82/g81/g68/g79/g30/g3/g86/g76/g93/g72/g3/g80/g68/g92/g3/g89/g68/g85/g92 /g17\n/g22/g17",
    "/g49/g82/g87/g72/g86/g29\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g86/g3/g39/g20/g3/g68/g81/g71/g3/g40/g20/g3/g71/g82/g3/g81/g82/g87/g3/g76/g81/g70/g79/g88/g71/g72/g3/g80/g82/g79/g71/g3/g73/g79/g68/g86/g75/g3/g82/g85/g3/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/g17/g3/g48/g82/g79/",
    "/g49/g82/g87/g72/g86/g29\ng71/g3/g73/g79/g68/g86/g75/g3/g82/g85/g3/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/g3/g86/g75/g68/g79/g79/g3/g81/g82/g87/g3/g72/g91/g70/g72/g72/g71/g3/g19/g17/g21/g24/g3/g80/g80/g3/g83/g72/g85/g3/g86/g76/g71/g72/g17",
    "/g49/g82/g87/g72/g86/g29\n/g23/g17 /g39/g76/g80/g72/g81/g86/g76/g82/g81/g76/g81/g74/g3/g68/g81/g71/g3/g87/g82/g79/g72/g85/g68/g81/g70/g76/g81/g74/g3/g83/g72/g85/g3/g36/g54/g48/g40/g3/g60/g20/g23/g17/g24/g48/g17\n/g37/g54/g38/g29",
    "/g49/g82/g87/g72/g86/g29\n/g37/g68/g86/g76/g70/g3/g39/g76/g80/g72/g81/g86/g76/g82/g81/g17/g3/g55/g75/g72/g82/g85/g72/g87/g76/g70/g68/g79/g79/g92/g3/g72/g91/g68/g70/g87/g3/g89/g68/g79/g88/g72/g3/g86/g75/g82/g90/g81/g3/g90/g76/g87/g75/g82/g88/g87/g3/g87/g82/g79/g72/g85/g68/g81/g70/",
    "/g49/g82/g87/g72/g86/g29\ng72/g86/g17\n/g53/g40/g41/g29",
    "/g49/g82/g87/g72/g86/g29\n/g53/g72/g73/g72/g85/g72/g81/g70/g72/g3/g39/g76/g80/g72/g81/g86/g76/g82/g81/g15/g3/g88/g86/g88/g68/g79/g79/g92/g3/g90/g76/g87/g75/g82/g88/g87/g3/g87/g82/g79/g72/g85/g68/g81/g70/g72/g15/g3/g73/g82/g85/g3/g76/g81/g73/g82/g85/g80/g68/g87/g76/g82/g81/g3/",
    "/g49/g82/g87/g72/g86/g29\ng83/g88/g85/g83/g82/g86/g72/g86/g3/g82/g81/g79/g92\n/g17\n/g48/g76/g70/g85/g82/g70/g75/g76/g83 /g55 /g72/g70/g75/g81/g82/g79/g82/g74/g92 /g39/g85/g68/g90/g76/g81/g74 /g38/g19/g23/g16/g19/g28/g21/g37",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g49/g82/g87/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng72/g29,\n1 =",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g41/g82/g85/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g87/g75/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng72/g3/g80/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng82/g86/g87/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g70/g88/g85",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng85/g72/g81/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng87/g3/g83/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g70/g78/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g74/g72/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g71/g85/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g90/g76/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng81/g74/g86/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng15/g3/g83/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng79/g72/g68/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng86/g72/g3/g86",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng72/g72/g3/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng87/g75/g72/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g48/g76/g70",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng85/g82/g70/g75",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng76/g83/g3/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng51/g68/g70/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng78/g68/g74/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng76/g81/g74/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g54",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g83/g72/g70/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng76/g73/g76/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g68/g87/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng76/g82/g81/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng3/g79/g82/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g68/g87/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng72/g71/g3/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng68/g87/g3",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g75/g87/g87/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng83/g29/g18/g18",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng90/g90/g90",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/g17/g80/g76/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g85/g82/g70",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng75/g76/g83/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng17/g70/g82/g80",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\n/\ng18/g83/g68/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng70/g78/g68/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng74/g76/g81/",
    "/g27/g19/g16/g47/g72/g68/g71/g3/g51/g79/g68/g86/g87/g76/g70/g3/g55/g75/g76/g81/g3/g52/g88/g68/g71/g3/g41/g79/g68/g87/g83/g68/g70/g78/g3/g11/g51/g55/g12/g3/g177/g3/g20/g21/g91/g20/g21/g91/g20/g3/g80/g80/g3/g37/g82/g71/g92 /g15/g3/g21/g17/g19/g19/g3/g80/g80/g3/g62/g55/g52/g41/g51/g64\ng74",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "Revision A (July 2004)\nOriginal  data  sheet  for  PIC18F6390/6490/8390/8490 devices.",
    "Revision B (August 2004)\nUpdated preliminary GLYPH<147>electrical characteristicsGLYPH<148> data.",
    "Revision C (November 2007)\nRevised I 2 CGLYPH<153> Slave Mode Timing figure. Updated DC Power-Down and Supply Current table  and  package drawings.\nAPPENDIX B:\nDEVICE DIFFERENCES\nThe differences between the devices listed in this data sheet are shown in Table B-1.",
    "TABLE B-1: DEVICE DIFFERENCES\nNumber of Pixels the LCD Driver can Drive, PIC18F6390 = 128 (4 x 32). Number of Pixels the LCD Driver can Drive, PIC18F6490 = 128 (4 x 32). Number of Pixels the LCD Driver can Drive, PIC18F8390 = 192 (4 x 48). Number of Pixels the LCD Driver can Drive, PIC18F8490 = 192 (4 x 48). I/O Ports, PIC18F6390 = Ports A, B, C, D, E, F, G. I/O Ports, PIC18F6490 = Ports A, B, C, D, E, F, G. I/O Ports, PIC18F8390 = Ports A, B, C, D, E, F, G, H, J. I/O Ports, PIC18F8490 = Ports A, B, C, D, E, F, G, H, J. Flash Program Memory, PIC18F6390 = 8 Kbytes. Flash Program Memory, PIC18F6490 = 16 Kbytes. Flash Program Memory, PIC18F8390 = 8",
    "TABLE B-1: DEVICE DIFFERENCES\nKbytes. Flash Program Memory, PIC18F8490 = 16 Kbytes. Packages, PIC18F6390 = 64-Pin TQFP. Packages, PIC18F6490 = 64-Pin TQFP. Packages, PIC18F8390 = 80-Pin TQFP. Packages, PIC18F8490 = 80-Pin TQFP",
    "APPENDIX C: CONVERSION CONSIDERATIONS\nThis appendix discusses the considerations for converting  from  previous  versions  of  a  device  to  the ones listed in this data sheet. Typically, these changes are due to the differences in the process technology used. An example of this type of conversion is from a PIC16C74A to a PIC16C74B.\nNot Applicable\nAPPENDIX D:\nMIGRATION FROM BASELINE TO ENHANCED DEVICES\nThis section discusses how to migrate from a Baseline device (i.e., PIC16C5X) to an Enhanced MCU device (i.e., PIC18FXXX).\nThe  following  are  the  list  of  modifications  over  the PIC16C5X microcontroller family:\nNot Currently Available",
    "PIC18F6390/6490/8390/8490\nAPPENDIX E:",
    "MIGRATION FROM MID-RANGE TO ENHANCED DEVICES\nAPPENDIX F:",
    "MIGRATION FROM HIGH-END TO ENHANCED DEVICES\nA detailed  discussion of the  differences between  the mid-range  MCU  devices  (i.e.,  PIC16CXXX)  and  the enhanced  devices  (i.e.,  PIC18FXXX)  is  provided  in AN716,  GLYPH<147>Migrating  Designs  from  PIC16C74A/74B  to PIC18C442.GLYPH<148> The  changes  discussed,  while  device specific,  are  generally  applicable  to  all  mid-range  to enhanced device migrations.\nThis Application Note is available as Literature Number DS00716.\nA  detailed  discussion  of  the  migration  pathway  and differences between the high-end MCU devices (i.e., PIC17CXXX) and the enhanced devices (i.e., PIC18FXXX)  is  provided  in  AN726,  GLYPH<147>PIC17CXXX  to PIC18CXXX  Migration.GLYPH<148> This Application Note is available as Literature Number DS00726.",
    "PIC18F6390/6490/8390/8490\nNOTES:",
    "A\nA/D ..................................................................................., 1 = 231. A/D Converter Interrupt, Configuring, 1 = ....................... 235. Acquisition Requirements ........................................, 1 = 236. ADCON0 Register, 1 = .................................................... 231. ADCON1 Register, 1 =",
    "A\n.................................................... 231. ADCON2 Register, 1 = .................................................... 231. ADRESH Register, 1 = ............................................ 231, 234. ADRESL Register, 1 = .................................................... 231. Analog Port Pins, Configuring",
    "A\n.................................., 1 = 238. Associated Registers, 1 = ............................................... 240. Automatic Acquisition Time, 1 = ...................................... 237. Configuring the Module, 1 = ............................................ 235. Conversion Clock (TAD), 1 = ........................................... 237. Conversion Status (GO/DONE",
    "A\nBit), 1 = .......................... 234. Conversions, 1 = ............................................................. 239. Converter Characteristics, 1 = ........................................ 384. Discharge, 1 = ................................................................. 239. Operation in Power-Managed Modes, 1 = ...................... 238. Special Event",
    "A\nTrigger (CCP), 1 = .................................... 240. Use of the CCP2 Trigger, 1 = .......................................... 240. Absolute Maximum Ratings, 1 = ............................................. 349. AC (Timing) Characteristics, 1 = 367. ............................................., 1 = . Load Conditions for Device Timing Specifications Parameter Symbology, 1 =",
    "A\n................................................... 368 ............................................. 367. Temperature and Voltage Specifications, 1 = ................. 368. Timing Conditions, 1 = .................................................... 368. Access Bank",
    "A\n......................................................................, 1 = 73. Mapping with Indexed Literal Offset Mode, 1 = ................. 86. ACKSTAT ........................................................................, 1 = 187. ACKSTAT Status Flag, 1 = ..................................................... 187. ADCON0 Register, 1 =",
    "A\n............................................................ 231. GO/DONE Bit, 1 = ........................................................... 234 ............................................................ 231. ADCON1 Register ADCON2 Register, 1 =",
    "A\n............................................................ 231. ADDFSR, 1 = .......................................................................... 338. , 1 = 301. ADDLW ............................................................................ Addressable Universal Synchronous Asynchronous Receiver Transmitter (AUSART). See AUSART. ADDULNK",
    "A\n........................................................................, 1 = 338. ADDWF ............................................................................, 1 = 301. ADDWFC, 1 = ......................................................................... 302. ADRESH Register, 1 =",
    "A\n............................................................ 231. , 1 = 231,. ADRESL Register .................................................... Analog-to-Digital Converter. See, 1 = 234. A/D. ANDLW ............................................................................, 1 = 302 303. ANDWF",
    "A\n............................................................................ Assembler MPASM, 1 = ................................................... Assembler AUSART, 1 = 346. Asynchronous Mode Associated Registers, Associated Registers,, 1 = ................................................ 222 Receive ........................ 225 223. Transmit Receiver",
    "A\n........................................................... Setting up 9-Bit Mode with, 1 = ........................ , 1 = 224. Address Detect ........................................, 1 = 224. ......................................................., 1 = . Transmitter, 1 = 222",
    "PIC18F6390/6490/8390/8490\nBaud Rate Generator (BRG)  ................................... 220\nAssociated Registers ....................................... 220\nBaud Rate Error, Calculating ........................... 220\nBaud Rates, Asynchronous Modes  ................. 221\nHigh Baud Rate Select (BRGH Bit)  ................. 220\nOperation in Power-Managed Modes .............. 220",
    "PIC18F6390/6490/8390/8490\nSampling  ......................................................... 220\nSynchronous Master Mode ...................................... 226\nAssociated Registers, Receive ........................ 228\nAssociated Registers, Transmit ....................... 227\nReception  ........................................................ 228",
    "PIC18F6390/6490/8390/8490\nTransmission  ................................................... 226\nSynchronous Slave Mode ........................................ 229\nAssociated Registers, Receive ........................ 230\nAssociated Registers, Transmit ....................... 229\nReception  ........................................................ 230",
    "PIC18F6390/6490/8390/8490\nTransmission  ................................................... 229\nAuto-Wake-up on Sync Break Character ......................... 210",
    "B\nBank Select Register (BSR), 1 = .............................................. 71. Baud Rate Generator ......................................................, 1 = 183. BC ...................................................................................., 1 = 303. BCF, 1 =",
    "B\n................................................................................. 304. BF, 1 = .................................................................................... 187. BF Status Flag, 1 = ................................................................. 187. Block Diagrams, 1 = .",
    "B\nA/D, 1 = ........................................................................... 234. Analog Input Model, 1 = .................................................. 235. AUSART Receive, 1 = .................................................... 224. AUSART Transmit, 1 =",
    "B\n................................................... 222. Baud Rate Generator, 1 = .............................................. 183. Capture Mode Operation, 1 = ......................................... 150. Comparator Analog Input Model, 1 = .............................. 245. Comparator I/O Operating Modes, 1 = ........................... 242. Comparator Output, 1 =",
    "B\n.................................................. 244. Comparator Voltage Reference, 1 = ............................... 248. Compare Mode Operation ......................................., 1 = 151. Device Clock, 1 = .............................................................. 36. EUSART Receive, 1 =",
    "B\n.................................................... 208. EUSART Transmit, 1 = ................................................... 206. External Power-on Reset Circuit (Slow VDD Power-up) ........................................, 1 = 53. Fail-Safe Clock Monitor, 1 = ........................................... 290. Generic I/O Port Operation",
    "B\n......................................, 1 = 109. HLVD Module (with External Input), 1 = ......................... 252. Interrupt Logic, 1 = ............................................................ 94. LCD Clock Generation, 1 = ............................................. 262. LCD Driver Module, 1 =",
    "B\n.................................................. 257. LCD Resistor Ladder Connection, 1 = ............................ 263. MSSP (I 2 C Master Mode) ........................................, 1 = 181. MSSP (I 2 C Mode), 1 = .................................................... 166. MSSP (SPI Mode), 1 =",
    "B\n................................................... 157. On-Chip Reset Circuit, 1 = ................................................ 51. PLL (HS Mode), 1 = .......................................................... 33. PWM Operation (Simplified) ...................................., 1 = 153. Reads from Flash Program Memory, 1 =",
    "B\n......................... 88. Single Comparator, 1 = ................................................... 243. Table Read Operation, 1 = ............................................... 87. Timer0 in 16-Bit Mode, 1 = ............................................. 132",
    "PIC18F6390/6490/8390/8490\nTimer0 in 8-Bit Mode ................................................, 1 = 132. Timer1, 1 = ...................................................................... 136. Timer1 (16-Bit Read/Write Mode), 1 = ............................ 136. Timer2",
    "PIC18F6390/6490/8390/8490\n......................................................................, 1 = 142. Timer3, 1 = ...................................................................... 144. Timer3 (16-Bit Read/Write Mode), 1 = ............................ 144. Voltage Reference Output Buffer Example, 1 = .............. 249. Watchdog Timer",
    "PIC18F6390/6490/8390/8490\n......................................................., 1 = 287. BN ...................................................................................., 1 = 304. BNC, 1 = .................................................................................. 305.",
    "PIC18F6390/6490/8390/8490\nBNN, 1 = .................................................................................. 305. BNOV, 1 = ............................................................................... 306. BNZ",
    "PIC18F6390/6490/8390/8490\n.................................................................................., 1 = 306. BOR. See Brown-out Reset., 1 = . BOV .................................................................................., 1 = 309. BRA, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................................................. 307. Break Character (12-Bit) Transmit and Receive, 1 = .............. 211. BRG. See Baud Rate Generator., 1 = . Brown-out Reset (BOR) ............................................., 1 = 54, 281. Disabling in Sleep Mode, 1 = ............................................ 54.",
    "PIC18F6390/6490/8390/8490\nBSF, 1 = .................................................................................. 307. BSR, 1 = .................................................................................... 86. BTFSC, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................................. 308. BTFSS, 1 = .............................................................................. 308. BTG",
    "PIC18F6390/6490/8390/8490\n.................................................................................., 1 = 309. BZ, 1 = ..................................................................................... 310. C, 1 = . C Compilers MPLAB, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................. 346. C18 MPLAB C30, 1 = ............................................................. 346. CALL ................................................................................, 1 = 310. CALLW, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................................. 339. Capture (CCP Module) ....................................................., 1 = 150. Associated Registers ..............................................., 1 = 152. CCP Pin Configuration",
    "PIC18F6390/6490/8390/8490\n............................................., 1 = 150. CCPR2H:CCPR2L Registers, 1 = ................................... 150. Software Interrupt, 1 = .................................................... 150. Timer1/Timer3 Mode Selection, 1 = ................................ 150. Capture/Compare/PWM, 1 =",
    "PIC18F6390/6490/8390/8490\n........................................ 147. (CCP) Capture Mode. See Capture., 1 = . CCP Mode and Timer Resources, 1 = ............................ 148. CCPRxH Register, 1 = .................................................... 148. CCPRxL Register, 1 = ..................................................... 148. Compare Mode. See Compare., 1 = . Interaction of CCP1 and CCP2 for Timer",
    "PIC18F6390/6490/8390/8490\nResources .............................................., 1 = 149. Interconnect Configurations, 1 = ..................................... 148. Module Configuration, 1 = ............................................... 148. Selecting the 31 kHz Source ......................................, 1 = 37. Selection Using OSCCON Register, 1 = ........................... 37. CLRF",
    "PIC18F6390/6490/8390/8490\n................................................................................, 1 = 311. CLRWDT, 1 = .......................................................................... 311. Code Examples, 1 = . 16 x 16 Signed Multiply Routine, 1 = ................................ 92. 16 x 16 Unsigned Multiply Routine, 1 =",
    "PIC18F6390/6490/8390/8490\n............................ 92. 8 x 8 Signed Multiply Routine, 1 = .................................... 91. 8 x 8 Unsigned Multiply Routine, 1 = ................................ 91. Changing Between Capture Prescalers, 1 = ................... 150. Computed GOTO Using an Offset Value, 1 = ................... 68. Fast Register Stack ...................................................., 1 =",
    "PIC18F6390/6490/8390/8490\n68. How to Clear RAM (Bank 1) Using, 1 = . Indirect Addressing ............................................ Implementing a Real-Time Clock Using, 1 = 81. a Timer1 Interrupt Service ..............................., 1 = 139",
    "PIC18F6390/6490/8390/8490\nInitializing PORTA, 1 = .................................................... 109. Initializing PORTB, 1 = .................................................... 112. Initializing PORTC, 1 = ................................................... 115. Initializing PORTD, 1 = ...................................................",
    "PIC18F6390/6490/8390/8490\n118. Initializing PORTE, 1 = .................................................... 120. Initializing PORTF, 1 = .................................................... 122. Initializing PORTG, 1 = ................................................... 125. Initializing PORTH, 1 = ...................................................",
    "PIC18F6390/6490/8390/8490\n127. Initializing PORTJ, 1 = .................................................... 129. Loading the SSPBUF (SSPSR) Register, 1 = ................. 160. Reading a Flash Program Memory Word Saving STATUS, WREG and BSR, 1 = .................. 89. Registers in RAM ............................................., 1 = 108. Code Protection, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................... 281. COMF, 1 = .............................................................................. 312. Comparator, 1 = ...................................................................... 241. Analog Input Connection Considerations, 1 =",
    "PIC18F6390/6490/8390/8490\n................ 245. Associated Registers, 1 = ............................................... 245. Configuration, 1 = ........................................................... 242. Effects of a Reset, 1 = .................................................... 244. Interrupts, 1 =",
    "PIC18F6390/6490/8390/8490\n................................................................. 244. Operation, 1 = ................................................................. 243. Operation During Sleep, 1 = ........................................... 244. Outputs, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................................... 243. Reference, 1 = ................................................................ 243. External Signal, 1 = ................................................ 243. Internal Signal Response Time",
    "PIC18F6390/6490/8390/8490\n........................................................, 1 = .................................................. 243 243. Comparator Specifications ..............................................., 1 = 365. Comparator Voltage Reference, 1 = ....................................... 247. Accuracy and Error",
    "PIC18F6390/6490/8390/8490\n.................................................., 1 = 248. Associated Registers, 1 = ............................................... 249. Configuring, 1 = .............................................................. 247. Connection Considerations, 1 = ...................................... 248. Effects of a Reset",
    "PIC18F6390/6490/8390/8490\n...................................................., 1 = 248. Operation During Sleep, 1 = ........................................... 248. Compare (CCP Module), 1 = .................................................. 151. Associated Registers, 1 = ............................................... 152. CCP Pin Configuration, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................. 151. CCPR2 Register, 1 = ...................................................... 151. Software Interrupt, 1 = .................................................... 151. Special Event Trigger .............................., 1 = 145, 151, 240. Timer1/Timer3 Mode Selection, 1 =",
    "PIC18F6390/6490/8390/8490\n................................ 151. Computed GOTO, 1 = ............................................................... 68. Configuration Bits, 1 = ............................................................ 281. Configuration Register Protection, 1 = .................................... 292 108. Context Saving During Interrupts, 1 =",
    "PIC18F6390/6490/8390/8490\n...................................... Conversion Considerations, 1 = .............................................. 396 ........................................................................... CPFSEQ, 1 = 312. CPFSGT, 1 =",
    "PIC18F6390/6490/8390/8490\n.......................................................................... 313. CPFSLT, 1 = ........................................................................... 313. Crystal Oscillator/Ceramic Resonator, 1 = ................................ 31. Customer Change Notification Service Customer Notification, 1 =",
    "PIC18F6390/6490/8390/8490\n............................ 409 Service ......................................... 409. Customer Support ............................................................, 1 = 409",
    "D\nData Addressing Modes, 1 = .................................................... 81. Comparing Addressing Modes with the, 1 = . Extended Instruction Set Enabled, 1 = ..................... 85. Direct, 1 = ......................................................................... 81. Indexed Literal Offset, 1 = ................................................ 84. Indirect, 1 =",
    "D\n....................................................................... 81. Inherent and Literal ...................................................., 1 = 81",
    "PIC18F6390/6490/8390/8490\nData Memory, 1 = ..................................................................... 71. Access Bank .............................................................., 1 = 73. and the Extended Instruction Set, 1 = ............................... 84. Bank Select Register (BSR) ......................................., 1 = 71. General Purpose Registers",
    "PIC18F6390/6490/8390/8490\n........................................, 1 = 73. Map for PIC18F6X90/8X90 Devices, 1 = .......................... 72. Special Function Registers ........................................ DAW ................................................................................., 1 = 74. DC and AC Characteristics, 1 = . Graphs and Tables, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................. 387. DC Characteristics, 1 = ........................................................... 362. Power-Down and Supply Current, 1 = ............................ 352. Supply Voltage, 1 = ......................................................... 351. DCFSNZ, 1 =",
    "PIC18F6390/6490/8390/8490\n.......................................................................... 315. DECF ..............................................................................., 1 = 314. DECFSZ ...........................................................................,",
    "PIC18F6390/6490/8390/8490\n1 = 315. Development Support, 1 = ...................................................... 345. Device Differences, 1 = ........................................................... 395. Device Overview, 1 = .................................................................. 7. Features (table)",
    "PIC18F6390/6490/8390/8490\n............................................................, 1 = 9. New Core Features, 1 = ...................................................... 7. Special Features, 1 = .......................................................... 8. Direct Addressing, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................... 82. E, 1 = . Effect on Standard Instructions .........................................., 1 = 84. Effect on Standard PIC MCU Instructions, 1 = ........................ 342. Electrical Characteristics .................................................., 1 = 349. Enhanced Universal Synchronous Asynchronous Receiver Transmitter (EUSART). See EUSART.,",
    "PIC18F6390/6490/8390/8490\n1 = . Equations, 1 = . A/D Acquisition Time ................................................, 1 = 236. A/D Minimum Charging Time ..................................., 1 = 236. Calculating the Minimum Required, 1 = 236. Acquisition Time .............................................. Errata",
    "PIC18F6390/6490/8390/8490\n..................................................................................., 1 = 5. EUSART, 1 = . Asynchronous Mode, 1 = ................................................ 206. 12-Bit Break Transmit and Receive, 1 = ................. 211. Associated Registers, Receive ........................, 1 = 209. Associated Registers, Transmit, 1 =",
    "PIC18F6390/6490/8390/8490\n....................... 207. Auto-Wake-up on Sync Break, 1 = ......................... 210. Receiver, 1 = ........................................................... 208. Address Detect Transmitter ......................................................., 1 = ........................................ 208 206. Baud Rate Generator (BRG),",
    "PIC18F6390/6490/8390/8490\n1 = .................................... 201. Associated Registers ......................................., 1 = 201. Auto-Baud Rate Detect, 1 = .................................... 204. Baud Rate Error, Calculating, 1 = ........................... 201. Baud Rates, Asynchronous Modes, 1 = ................. 202. High Baud Rate Select (BRGH Bit), 1 = ................. 201. Operation in Power-Managed",
    "PIC18F6390/6490/8390/8490\nModes, 1 = .............. 201. Sampling .........................................................., 1 = 201. Synchronous Master Mode ......................................, 1 = 212. Associated Registers, Receive, 1 = ........................ 214. Associated Registers, Transmit, 1 = ....................... 213. Reception, 1 =",
    "PIC18F6390/6490/8390/8490\n......................................................... 214. Transmission ..................................................., 1 = 212. Synchronous Slave Mode ........................................, 1 = 215. Associated Registers, Receive, 1 = ........................ 216 ....................... 215. Associated Registers, Transmit",
    "PIC18F6390/6490/8390/8490\n........................................................., 1 = 216. Reception Transmission, 1 = ................................................... 215",
    "PIC18F6390/6490/8390/8490\nExtended Instruction Set, 1 = . ADDFSR .................................................................., 1 = 338. ADDULNK, 1 = ............................................................... 338. CALLW, 1 = .................................................................... 339. MOVSF, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................................... 339. MOVSS, 1 = .................................................................... 340. PUSHL, 1 = ..................................................................... 340. SUBFSR, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................................. 341. SUBULNK, 1 = ................................................................ 341. External Clock Input, 1 = ........................................................... 32. F, 1 = . Fail-Safe Clock Monitor",
    "PIC18F6390/6490/8390/8490\n..........................................., 1 = 281, 290. Interrupts in Power-Managed Modes, 1 = ...................... 291. POR or Wake from Sleep, 1 = ........................................ 291. WDT During Oscillator Failure, 1 = ................................. 290. Fast Register Stack, 1 =",
    "PIC18F6390/6490/8390/8490\n........................................................... 68. Firmware Instructions, 1 = ...................................................... 295. Flash Program Memory, 1 = ..................................................... 87. Associated Registers, 1 = ................................................. 89. Control",
    "PIC18F6390/6490/8390/8490\nRegisters ......................................................., 1 = 88 ......................... TABLAT (Table Latch) Register, 1 = 88. Reading ....................................................................., 1 = . , 1 = 88. Table Reads, 1 =",
    "PIC18F6390/6490/8390/8490\n.............................................................. 87. FSCM. See Fail-Safe Clock Monitor., 1 = . G, 1 = . , 1 = .............................................................................. 316. H, 1 = . Hardware Multiplier, 1 = 91. Introduction, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................ ................................................................ 91. Operation ..................................................................., 1 = 91. Performance Comparison, 1 =",
    "PIC18F6390/6490/8390/8490\n.......................................... 91. High/Low-Voltage Detect ................................................., 1 = 251. Applications ............................................................., 1 = 254. Typical Low-Voltage Detect (diagram), 1 = ............ 254. Associated Registers, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................... 255. Characteristics ........................................................., 1 = 366. Current Consumption, 1 = .............................................. 253. Effects of a Reset Operation ................................................................., 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................... 255 252. During Sleep, 1 = .................................................... 255. Setup ......................................................................., 1 = 253. Start-up Time",
    "PIC18F6390/6490/8390/8490\n..........................................................., 1 = 253. See High/Low-Voltage, 1 = .............................. HLVD. Detect., 1 = 251. I, 1 = . I/O Ports, 1 = 109. .......................................................................... I 2 C Mode (MSSP), 1 = . Acknowledge Sequence Timing, 1 =",
    "PIC18F6390/6490/8390/8490\n.............................. 190. Associated Registers ..............................................., 1 = 196. Baud Rate Generator, 1 = 183. Bus Collision, 1 = ............................................... During a Repeated Start Condition, 1 = .................. 194. During a Start Condition, 1 = .................................. 192. During a Stop Condition, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................. 195. Clock Arbitration, 1 = ...................................................... 184. Clock Stretching, 1 = ...................................................... 176. 10-Bit Slave Receive Mode (SEN = 1), 1 = ............ 176. 10-Bit Slave Transmit Mode ............................ .............., 1 = 176.",
    "PIC18F6390/6490/8390/8490\n7-Bit Slave Receive Mode (SEN = 1), 1 = 176. 7-Bit Slave Transmit Mode .............................., 1 = 176",
    "PIC18F6390/6490/8390/8490\nEffect of a Reset, 1 = ...................................................... 191. General Call Address Support, 1 = ................................. 180. I 2 C Clock Rate w/BRG ............................................., 1 = 183. Master Mode, 1 = ............................................................ 181. Operation, 1 = 182.",
    "PIC18F6390/6490/8390/8490\n......................................................... Reception ........................................................., 1 = 187. Repeated Start Condition Timing, 1 = ..................... 186. Start Condition, 1 = ................................................. 185. Transmission, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................... 187. Transmit Sequence .........................................., 1 = 182. Multi-Master Communication, Bus Collision and Arbitration .................................................., 1 = 191. Multi-Master Mode, 1 = ................................................... 191. Operation",
    "PIC18F6390/6490/8390/8490\n................................................................., 1 = 170. Read/Write Bit Information (R/W Bit), 1 = ............... 170, 171. Registers, 1 = .................................................................. 166. Serial Clock (RC3/SCK/SCL), 1 = ................................... 171. Slave Mode, 1 =",
    "PIC18F6390/6490/8390/8490\n.............................................................. 170. Addressing, 1 = ....................................................... 170. Reception, 1 = ......................................................... 171. Sleep Operation, 1 =",
    "PIC18F6390/6490/8390/8490\n....................................................... 191. Stop Condition Timing, 1 = .............................................. 190. Transmission, 1 = ............................................................ 171. Locations",
    "PIC18F6390/6490/8390/8490\n................................................................................., 1 = ............................................................. 281, 293. , 1 = 316. INCFSZ, 1 = ............................................................................ 317. In-Circuit",
    "PIC18F6390/6490/8390/8490\nDebugger, 1 = .......................................................... 293. Indexed Literal Offset Addressing Mode, 1 = .......................... 342. and Standard PIC18 Instructions, 1 = ............................. 342. Indexed Literal Offset Mode, 1 = ......................................... 84, 86. Indirect Addressing, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................ 82 317. INFSNZ ............................................................................, 1 = . Initialization Conditions for all Registers, 1 = ...................... 59GLYPH<150>64. Instruction Cycle",
    "PIC18F6390/6490/8390/8490\n................................................................., 1 = 69 ....................................................... 69. Clocking Scheme Flow/Pipelining, 1 = ................................................. 69. Instruction Instruction Set",
    "PIC18F6390/6490/8390/8490\n.................................................................., 1 = 295. ...................................................................., 1 = 301. ADDLW ADDWF, 1 = 301. .................................................................... ADDWF (Indexed Literal Offset mode), 1 =",
    "PIC18F6390/6490/8390/8490\n.................... 343. ADDWFC ................................................................. ...................................................................., 1 = 302. ANDLW, 1 = 302. ANDWF",
    "PIC18F6390/6490/8390/8490\n............................................................................, 1 = .................................................................... 303 303. BC, 1 = . BCF, 1 = .......................................................................... 304. BN, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................................ 304. BNC, 1 = ......................................................................... 305. BNN, 1 = ......................................................................... 305. BNOV,",
    "PIC18F6390/6490/8390/8490\n1 = ....................................................................... 306 ........................................................................... BNZ, 1 = 306 ......................................................................... 309. BOV BRA, 1 = . , 1 =",
    "PIC18F6390/6490/8390/8490\n.......................................................................... 307. BSF .......................................................................... BSF (Indexed Literal Offset mode), 1 = 307. BTFSC ....................................................................., 1 =",
    "PIC18F6390/6490/8390/8490\n.......................... 343 308. BTFSS, 1 = ..................................................................... 308 309. BTG .........................................................................., 1 = .",
    "PIC18F6390/6490/8390/8490\n............................................................................, 1 = . BZ, 1 = 310 310. CALL CLRF, 1 = ........................................................................ 311. ........................................................................",
    "PIC18F6390/6490/8390/8490\nCLRWDT, 1 = .................................................................. 311. , 1 = 312. COMF, 1 = 312. ...................................................................... CPFSEQ, 1 = ................................................................... CPFSGT, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................................. 313 ................................................................... 313. CPFSLT, 1 = ",
    "PIC18F6390/6490/8390/8490\nDAW, 1 = ........................................................................ 314. DCFSNZ, 1 = .................................................................. 315. DECF ......................................................................., 1 = 314. DECFSZ, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................................. 315. Extended Instructions .............................................., 1 = 337. and Using MPLAB IDE Tools, 1 = .......................... 344. Considerations when Enabling, 1 = ........................ 342. Syntax",
    "PIC18F6390/6490/8390/8490\n.............................................................., 1 = 337. General Format, 1 = ........................................................ 297. GOTO INCF ........................................................................, 1 =",
    "PIC18F6390/6490/8390/8490\n...................................................................... 316 316. INCFSZ, 1 = .................................................................... 317. INFSNZ, 1 = .................................................................... 317. IORLW, 1 =",
    "PIC18F6390/6490/8390/8490\n..................................................................... 318. IORWF, 1 = ..................................................................... 318. LFSR, 1 = ....................................................................... 319. MOVF, 1 =",
    "PIC18F6390/6490/8390/8490\n...................................................................... 319. MOVFF, 1 = .................................................................... 320. MOVLB, 1 = .................................................................... 320. MOVLW, 1 =",
    "PIC18F6390/6490/8390/8490\n................................................................... 321. MOVWF, 1 = ................................................................... 321. MULLW, 1 = .................................................................... 322. MULWF, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................................... 322. NEGF, 1 = ....................................................................... 323. NOP, 1 = ......................................................................... 323. POP, 1 =",
    "PIC18F6390/6490/8390/8490\n......................................................................... 324. RCALL, 1 = ..................................................................... 325. RESET, 1 = ..................................................................... 325. RETFIE, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................................... 326. RETLW ...................................................................., 1 = 326. RETURN, 1 = .................................................................. 327. RLCF, 1 =",
    "PIC18F6390/6490/8390/8490\n....................................................................... 327. RLNCF, 1 = ..................................................................... 328. RRCF, 1 = ....................................................................... 328. RRNCF, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................................... 329. SETF (Indexed Literal Offset mode), 1 = ........................ 343. SLEEP ....................................................................., 1 = 330. Standard Instructions, 1 = ............................................... 295. SUBFWB,",
    "PIC18F6390/6490/8390/8490\n1 = ................................................................. 330. SUBLW, 1 = .................................................................... 331. SUBWF ...................................................................., 1 = 331. SUBWFB, 1 =",
    "PIC18F6390/6490/8390/8490\n................................................................. 332. SWAPF, 1 = .................................................................... 332. TBLRD, 1 = ..................................................................... 333. TBLWT, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................................... 334. TSTFSZ, 1 = ................................................................... 335. XORLW XORWF, 1 = ................................................................... 335.",
    "PIC18F6390/6490/8390/8490\n................................................................... Summary Table, 1 = 336 ....................................................... 298. INTCON Register, 1 = . RBIF Bit, 1 = ................................................................... 112. INTCON Registers",
    "PIC18F6390/6490/8390/8490\n............................................................. Inter-Integrated Circuit. See I 2 C., 1 = 95. Internal Oscillator Block, 1 = ..................................................... 34. Adjustment ................................................................., 1 = 34. INTIO Modes",
    "PIC18F6390/6490/8390/8490\n............................................................., 1 = 34. INTOSC Output Frequency, 1 = ....................................... 34. OSCTUNE Register Internal RC Oscillator, 1 = ................................................... 34. Use with WDT, 1 =",
    "PIC18F6390/6490/8390/8490\n.......................................................... 287. Internet Address, 1 = .............................................................. 409",
    "PIC18F6390/6490/8390/8490\nInterrupt Sources, 1 = ............................................................. 281. A/D Conversion Complete, 1 = ....................................... 235. Capture Complete (CCP) ........................................., 1 = 150. Compare Complete (CCP) ......................................., 1 = 151. Interrupt-on-Change (RB7:RB4), 1 =",
    "PIC18F6390/6490/8390/8490\n.............................. 112. INTx Pin ..................................................................., 1 = 108. PORTB, Interrupt-on-Change, 1 = .................................. 108. TMR0 ......................................................................., 1 = 108. TMR0 Overflow,",
    "PIC18F6390/6490/8390/8490\n1 = ........................................................ 133. TMR1 Overflow, 1 = ........................................................ 135. TMR2 to PR2 Match (PWM), 1 = .................................... 153. TMR3 Overflow, 1 = ................................................ 143,",
    "PIC18F6390/6490/8390/8490\n145. Interrupts ............................................................................, 1 = 93. Interrupts, Flag Bits Interrupt-on-Change (RB7:RB4) Flag (RBIF Bit) ........................................................., 1 = 112. INTOSC Frequency Drift, 1 = .................................................... 34. INTOSC, INTRC. See IORLW",
    "PIC18F6390/6490/8390/8490\n............................................................................., 1 = Internal Oscillator Block. 318. IORWF ............................................................................., 1 = 318. IPR Registers, 1 =",
    "PIC18F6390/6490/8390/8490\n................................................................... 104. L, 1 = . LCD, 1 = . Associated Registers, 1 = ............................................... 279. Bias Types, 1 = ............................................................... 263. Clock Source Selection, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................ 262. Configuring the Module, 1 = ............................................ 278. Frame Frequency, 1 = ..................................................... 264. Interrupts, 1 = .................................................................. 276. LCDCON Register, 1 =",
    "PIC18F6390/6490/8390/8490\n................................................... 258. LCDDATA Register, 1 = .................................................. 258. LCDPS Register, 1 = ....................................................... 258. LCDSE Register, 1 = ....................................................... 258. Multiplex",
    "PIC18F6390/6490/8390/8490\nTypes, 1 = ........................................................ 263. Operation During Sleep, 1 = ........................................... 277. Pixel Control, 1 = ............................................................. 264. Prescaler",
    "PIC18F6390/6490/8390/8490\n.................................................................., 1 = 262. Segment Enables, 1 = ..................................................... 263. Waveform Generation ..........................................................., 1 =",
    "PIC18F6390/6490/8390/8490\n.............................................. 264. LCDCON Register, 1 = 258. LCDDATA Register LCDPS Register ..............................................................., 1 = .......................................................... 258. LP3:LP0 Bits, 1 = 258",
    "PIC18F6390/6490/8390/8490\n............................................................ 262. LCDSE Register, 1 = ............................................................... 258. LFSR ................................................................................, 1 = 319. Liquid Crystal Display (LCD) Driver, 1 =",
    "PIC18F6390/6490/8390/8490\n................................. 257. Look-up Tables, 1 = .................................................................. 68. M, 1 = . Master Clear (MCLR), 1 = ......................................................... 53. Master Synchronous Serial Port (MSSP). See MSSP. Memory Organization, 1 =",
    "PIC18F6390/6490/8390/8490\n......................................................... 65. Data Memory, 1 = ............................................................. 71 ....................................................... 65. Memory Programming Requirements, 1 = .............................. 364. Microchip Internet Web Site",
    "PIC18F6390/6490/8390/8490\n............................................., 1 = 409. Migration from Baseline to Enhanced Devices, 1 = ................ 396. Migration from High-End to Enhanced Devices, 1 = ............... 397. Migration from Mid-Range to Enhanced Devices, 1 = ............ 397. MOVF ..............................................................................., 1 = 319 320. MOVFF, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................................. MOVLB, 1 = ............................................................................ 320. MOVLW, 1 =",
    "PIC18F6390/6490/8390/8490\n........................................................................... 321. MOVSF, 1 = ............................................................................ 339. MOVSS, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................................ 340",
    "PIC18F6390/6490/8390/8490\nMOVWF, 1 = ........................................................................... 321. MPLAB ASM30 Assembler, Linker, Librarian, 1 = .................. 346. MPLAB ICD 2 In-Circuit Debugger .................................., 1 = 347. MPLAB ICE 2000 High-Performance Universal In-Circuit Emulator ..................................., 1 = 347. MPLAB Integrated Development Environment Software",
    "PIC18F6390/6490/8390/8490\n............................................., 1 = 345. MPLAB PM3 Device Programmer, 1 = 347. ................................... MPLAB REAL ICE In-Circuit Emulator System, 1 = ............... 347. MPLINK Object Linker/MPLIB Object Librarian, 1 = ............... 346. MSSP, 1 = . ACK Pulse, 1 = 170, 171. ....................................................... Control Registers (general), 1 =",
    "PIC18F6390/6490/8390/8490\n..................................... 157. I 2 C Mode. See I 2 C Mode. Module Overview, 1 = ..................................................... 157. SPI Master/Slave Connection, 1 = .................................. 161. SPI Mode. See SPI Mode. SSPBUF .................................................................., 1 = 162.",
    "PIC18F6390/6490/8390/8490\nSSPSR ............................................................................, 1 = .................................................................... 162. MULLW, 1 = 322. MULWF, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................................ 322. N, 1 = . NEGF, 1 = ............................................................................... 323. NOP",
    "PIC18F6390/6490/8390/8490\n................................................................................., 1 = 323. O, 1 = . Opcode Field Descriptions ..............................................., 1 = 296. Oscillator Configuration, 1 = ..................................................... 31. EC",
    "PIC18F6390/6490/8390/8490\n.............................................................................., 1 = 31. ECIO, 1 = .......................................................................... 31. HS",
    "PIC18F6390/6490/8390/8490\n.............................................................................., 1 = 31. HSPLL Internal Oscillator Block, 1 = ....................................................................... 31 .............................................. INTIO1",
    "PIC18F6390/6490/8390/8490\n......................................................................., 1 = 34. , 1 = 31. INTIO2, 1 = ....................................................................... 31. LP, 1 =",
    "PIC18F6390/6490/8390/8490\n.............................................................................. 31. RC, 1 = ............................................................................. 31. RCIO, 1 =",
    "PIC18F6390/6490/8390/8490\n.......................................................................... 31. XT .............................................................................. Oscillator Selection, 1 = 31 281. .......................................................... Oscillator Start-up Timer (OST), 1 =",
    "PIC18F6390/6490/8390/8490\n........................... 39, 55, 281. Oscillator Switching, 1 = ........................................................... 36 .......................................................... Oscillator Transitions, 1 = 37. Oscillator, Timer1 Oscillator, Timer3, 1 = ..................................................... 135,",
    "PIC18F6390/6490/8390/8490\n145. P, 1 = . Packaging, 1 = ........................................................................ 389. Details, 1 = ...................................................................... 390. Marking, 1 = .................................................................... 389. PICSTART Plus",
    "PIC18F6390/6490/8390/8490\nDevelopment Programmer, 1 = .................... 348. PIE Registers Pin Functions, 1 = ................................................................... 101. AVDD, 1 = .......................................................................... 29. AVDD, 1 =",
    "PIC18F6390/6490/8390/8490\n.......................................................................... 19. AVSS, 1 = .......................................................................... 29. AVSS, 1 = .......................................................................... 19. COM0,",
    "PIC18F6390/6490/8390/8490\n1 = 17, 25. .................................................................. LCDBIAS1, 1 = ........................................................... 17, 25. LCDBIAS2, 1 = ........................................................... 17, 25. LCDBIAS3, 1 =",
    "PIC18F6390/6490/8390/8490\n........................................................... 17, 25. MCLR/VPP/RG5, 1 = ................................................... 12, 20. OSC1/CLKI/RA7 .................................................., 1 = 12, 20 12, 20. OSC2/CLKO/RA6 RA0/AN0",
    "PIC18F6390/6490/8390/8490\n.............................................................., 1 = ................................................ 13, 21",
    "PIC18F6390/6490/8390/8490\nRA1/AN1, 1 = .............................................................. 13, 21. RA2/AN2/VREF-/SEG16, 1 = ....................................... 13, 21. RA3/AN3/VREF+/SEG17, 1 = ...................................... 13, 21. RA4/T0CKI/SEG14, 1 =",
    "PIC18F6390/6490/8390/8490\n.............................................. 13, 21. RA5/AN4/HLVDIN/SEG15, 1 = ................................... 13, 21. RB0/INT0, 1 = ............................................................. 14, 22. RB1/INT1/SEG8, 1 =",
    "PIC18F6390/6490/8390/8490\n................................................... 14, 22. RB2/INT2/SEG9, 1 = ................................................... 14, 22. RB3/INT3/SEG10, 1 = ................................................. 14, 22. RB4/KBI0/SEG11, 1 =",
    "PIC18F6390/6490/8390/8490\n................................................. 14, 22. RB5/KBI1, 1 = ............................................................. 14, 22. RB6/KBI2/PGC, 1 = .................................................... 14, 22. RB7/KBI3/PGD, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................... 14, 22. RC0/T1OSO/T13CKI, 1 = ........................................... 15, 23. RC1/T1OSI/CCP2, 1 = ................................................ 15, 23. RC2/CCP1/SEG13, 1 = ...............................................",
    "PIC18F6390/6490/8390/8490\n15, 23. RC3/SCK/SCL, 1 = ..................................................... 15, 23. RC4/SDI/SDA, 1 = ...................................................... 15, 23. RC5/SDO/SEG12, 1 = ................................................ 15, 23. RC6/TX1/CK1, 1 =",
    "PIC18F6390/6490/8390/8490\n...................................................... 15, 23. RC7/RX1/DT1, 1 = ...................................................... 15, 23. RD0/SEG0, 1 = ........................................................... 16, 24. RD1/SEG1, 1 =",
    "PIC18F6390/6490/8390/8490\n........................................................... 16, 24. RD2/SEG2, 1 = ........................................................... 16, 24. RD3/SEG3, 1 = ........................................................... 16, 24. RD4/SEG4, 1 =",
    "PIC18F6390/6490/8390/8490\n........................................................... 16, 24. RD5/SEG5, 1 = ........................................................... 16, 24 16, 24. RD7/SEG7, 1 = ........................................................... 16, 24. RE4/COM1, 1 =",
    "PIC18F6390/6490/8390/8490\n........................................................... 17, 25. RE5/COM2, 1 = ........................................................... 17, 25. RE6/COM3, 1 = ........................................................... 17, 25. RE7/CCP2/SEG31, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................... 17, 25. RF0/AN5/SEG18, 1 = .................................................. 18, 26. RF1/AN6/C2OUT/SEG19, 1 = .................................... 18, 26. RF2/AN7/C1OUT/SEG20, 1 = .................................... 18, 26. RF3/AN8/SEG21, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................. 18, 26. RF4/AN9/SEG22, 1 = .................................................. 18, 26. RF5/AN10/CVREF/SEG23 ................................................, 1 = .................................... 18, 26. RF6/AN11/SEG24, 1 = 18, 26.",
    "PIC18F6390/6490/8390/8490\nRF7/SS/SEG25 RG0/SEG30 ........................................................., 1 = .................................................... 18, 26 19, 27. RG1/TX2/CK2/SEG29, 1 = ......................................... 19,. , 1 = 27. RG2/RX2/DT2/SEG28 RG3/SEG27, 1 =",
    "PIC18F6390/6490/8390/8490\n......................................... 19, 27 19, 27. RG4/SEG26, 1 = ......................................................... 19,. , 1 = 27. RG5 ...................................................................... RH0/SEG47, 1 = 19, 27",
    "PIC18F6390/6490/8390/8490\n................................................................ , 1 = 28 ............................................................... 28. RH1/SEG46, 1 = ................................................................ RH2/SEG45, 1 = 28. RH3/SEG44, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................... 28 ............................................................... 28. RH4/SEG40, 1 = ................................................................ RH5/SEG41 RH6/SEG42, 1 = 28",
    "PIC18F6390/6490/8390/8490\n............................................................... 28. RH7/SEG43, 1 = ............................................................... 28 ................................................................. RJ0/SEG32, 1 = 29",
    "PIC18F6390/6490/8390/8490\n................................................................. RJ1/SEG33, 1 = 29. RJ2/SEG34, 1 = ................................................................ 29. RJ3/SEG35, 1 = ................................................................ 29. RJ4/SEG39, 1 =",
    "PIC18F6390/6490/8390/8490\n................................................................ 29 ................................................................ 29. RJ5/SEG38, 1 = . RJ6/SEG37, 1 = ................................................................ 29 29. RJ7/SEG36, 1 =",
    "PIC18F6390/6490/8390/8490\n................................................................ 29. VDD ............................................................................., 1 = . , 1 = ............................................................................. 19. VDD, 1 = ",
    "PIC18F6390/6490/8390/8490\nVSS ............................................................................, ............................................................................ 29 = 19. Pinout I/O Descriptions,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = . PIC18F6X90, ............................................................................ 29 = .............................................................. 12. PIC18F8X90,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = .............................................................. 20. PIR Registers .....................................................................,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = 98. PLL ....................................................................................,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = 33. HSPLL Oscillator Mode, ............................................................................ 29 = ............................................. 33. Use with INTOSC,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ................................................ 33, 34. PLL Lock Time-out, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n............................................................. 55. POP ................................................................................. POR. See Power-on Reset., ............................................................................ 29 = 324. PORTA,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = . Associated Registers, ............................................................................ 29 = ............................................... 111. LATA Register,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ......................................................... 109. PORTA Register, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n...................................................... 109. TRISA Register, ............................................................................ 29 = ........................................................ 109. PORTB,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = . Associated Registers ..............................................., ............................................................................ 29 = 114. LATB Register,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ......................................................... 112. PORTB Register, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n...................................................... 112. RB7:RB4 Interrupt-on-Change Flag (RBIF Bit), ............................................................................ 29 = ......................................................... 112. TRISB Register",
    "PIC18F6390/6490/8390/8490\n........................................................, ............................................................................ 29 = 112. PORTC, ............................................................................ 29 = . Associated Registers,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ............................................... 117. LATC Register, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n......................................................... 115. PORTC Register, ............................................................................ 29 = ...................................................... 115. RC3/SCK/SCL Pin,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ................................................... 171. TRISC Register, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n........................................................ 115. PORTD, ............................................................................ 29 = . Associated Registers ...............................................,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = 119. LATD Register, ............................................................................ 29 = ......................................................... 118. PORTD Register,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ...................................................... 118. TRISD Register, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n........................................................ 118. PORTE, ............................................................................ 29 = . Associated Registers, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n............................................... 121. LATE Register, ............................................................................ 29 = ......................................................... 120. PORTE Register,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ...................................................... 120. TRISE Register, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n........................................................ 120. PORTF, ............................................................................ 29 = . Associated Registers, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n............................................... 124. LATF Register, ............................................................................ 29 = .......................................................... 122. PORTF Register,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ...................................................... 122. TRISF Register, ............................................................................ 29 = 122. PORTG,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ......................................................... Associated Registers ...............................................,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = 126. LATG Register, ............................................................................ 29 = ......................................................... 125. PORTG Register,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ...................................................... 125. TRISG Register, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n....................................................... 125. PORTH, ............................................................................ 29 = . Associated Registers ...............................................,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = 128. LATH Register, ............................................................................ 29 = ......................................................... 127. PORTH Register,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ...................................................... 127. TRISH Register, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n........................................................ 127. PORTJ, ............................................................................ 29 = . Associated Registers, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n............................................... 130. LATJ Register, ............................................................................ 29 = .......................................................... 129. PORTJ Register,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ....................................................... 129. TRISJ Register, ............................................................................ 29 =",
    "PIC18F6390/6490/8390/8490\n........................................................ 129. Postscaler, WDT, ............................................................................ 29 = ............................................... Assignment (PSA,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = Bit) 133. Rate Select (T0PS2:T0PS0 Bits) ............................., ............................................................................ 29 = 133. Switching Between Timer0 and WDT,",
    "PIC18F6390/6490/8390/8490\n............................................................................ 29 = ...................... 133",
    "PIC18F6390/6490/8390/8490\nPower-Managed Modes, 1 = ..................................................... 41. and Multiple Sleep Commands, 1 = .................................. 42. Effects on Clock Sources ..........................................., 1 = 39. Entering, 1 = ...................................................................... 41. Exiting Idle and Sleep Modes, 1 =",
    "PIC18F6390/6490/8390/8490\n. by Reset ............................................................., 1 = 48. by WDT Time-out ..............................................., 1 = 48. Without a Start-up Delay, 1 = .................................... 48. Exiting Idle or Sleep Modes, 1 = ....................................... 48. by Interrupt, 1 =",
    "PIC18F6390/6490/8390/8490\n......................................................... 48. Idle Modes, 1 = ................................................................. 45. PRI_IDLE, 1 = ........................................................... 46. Run Modes",
    "PIC18F6390/6490/8390/8490\n................................................................., 1 = 42. PRI_RUN, 1 = ........................................................... 42. RC_RUN, 1 = ............................................................ 44. SEC_RUN, 1 =",
    "PIC18F6390/6490/8390/8490\n.......................................................... 42. Selecting ...................................................................., 1 = 41 ................................................................. Sleep Mode, 1 = 45. Summary (table), 1 =",
    "PIC18F6390/6490/8390/8490\n........................................................ 41. Power-on Reset (POR) .............................................., 1 = 53, 281. Oscillator Start-up Timer (OST), 1 = ................................. 55. Power-up Timer (PWRT) ..................................., 1 = 55, 281. Time-out Sequence",
    "PIC18F6390/6490/8390/8490\n...................................................., 1 = 55. Power-up Delays, 1 = ................................................................ 39. Power-up Timer (PWRT), 1 = ............................................. 39, 55. Prescaler, Capture, 1 =",
    "PIC18F6390/6490/8390/8490\n........................................................... 150. Prescaler, Timer0, 1 = ............................................................. 133 133. Rate Select, 1 = Bits) ............................. 133. (T0PS2:T0PS0 Switching Between, 1 = Timer0 and WDT ...................... 133. Prescaler, Timer2, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................. 154. Program Counter, 1 = ............................................................... 66. PCL, PCH and PCU Registers, 1 = ................................... 66. PCLATH and PCLATU, 1 = Registers .............................. 66. Program Memory, 1 = . and Extended Instruction Set, 1 =",
    "PIC18F6390/6490/8390/8490\n..................................... 84. Instructions, 1 = ................................................................. 70. Two-Word, 1 = .......................................................... 70. Interrupt Vector, 1 = .......................................................... 65.",
    "PIC18F6390/6490/8390/8490\nMap and Stack (diagram), 1 = ........................................... 65. Reset Vector .............................................................., 1 = 65. Program Verification and Code Protection Associated Registers, 1 = ....................... 292 ............................................... 292. Programming, Device Instructions",
    "PIC18F6390/6490/8390/8490\n................................... Pulse-Width Modulation. See PWM (CCP Module)., 1 = 295. PUSH ..............................................................................., 1 = 324. PUSH and POP Instructions, 1 = .............................................. 67. PUSHL",
    "PIC18F6390/6490/8390/8490\n............................................................................., 1 = 340. PWM (CCP Module), 1 = . Associated Registers, 1 = ............................................... 155. Duty Cycle, 1 = ................................................................ 154. Example Frequencies/Resolutions, 1 =",
    "PIC18F6390/6490/8390/8490\n.......................... 154. Period ......................................................................., 1 = 153. Setup for PWM Operation, 1 = ........................................ 155. TMR2 to PR2 Match, 1 = ................................................ 153. Q, 1 = . Q Clock, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................................ 154. R, 1 = . RC Oscillator ......................................................................, 1 = 33. RCIO Oscillator Mode, 1 = ................................................ 33. RCALL",
    "PIC18F6390/6490/8390/8490\n............................................................................. RCON Register, 1 = 325. Bit Status During Initialization, 1 = .................................... 58",
    "PIC18F6390/6490/8390/8490\nReader Response ............................................................, 1 = 410. Reading Program Memory and Other Locations ......................................................................., 1 = ............. 292. Register File, 1 = 73. Register File Summary ................................................, 1 = 76GLYPH<150>79. Registers, 1 = . ADCON0",
    "PIC18F6390/6490/8390/8490\n(A/D Control 0), 1 = ......................................... 231. ADCON1 (A/D Control 1), 1 = ......................................... 232. ADCON2 (A/D Control 2), 1 = ......................................... 233. BAUDCON1 (Baud Rate Control 1), 1 = ......................... 200. CCPxCON (CCPx Control)",
    "PIC18F6390/6490/8390/8490\n......................................, 1 = 147. CMCON (Comparator Control) ................................, 1 = 241. CONFIG1H (Configuration 1 High), 1 = .......................... 282. CONFIG2H (Configuration 2 High), 1 = .......................... 284. CONFIG2L (Configuration 2 Low), 1 = ........................... 283. CONFIG3H (Configuration 3 High), 1 =",
    "PIC18F6390/6490/8390/8490\n.......................... 284. CONFIG4L (Configuration 4 Low), 1 = ........................... 285. CONFIG5L (Configuration 5 Low), 1 = ........................... 285. CVRCON (Comparator Voltage Reference Control) .........................................., 1 = 247. DEVID1 (Device ID 1) .............................................., 1 = 286. DEVID2 (Device ID 2)",
    "PIC18F6390/6490/8390/8490\n.............................................., 1 = 286. HLVDCON (High/Low-Voltage, 1 = . Detect Control) ................................................, 1 = 251 ........................................ INTCON (Interrupt Control), 1 = 95. INTCON2 (Interrupt Control 2), 1 = .................................. 96. INTCON3 (Interrupt Control 3), 1 =",
    "PIC18F6390/6490/8390/8490\n.................................. 97. IPR1 (Peripheral Interrupt Priority 1) ......................., 1 = 104. IPR2 (Peripheral Interrupt Priority 2) Priority 3), 1 = ....................... 105 ....................... 106. IPR3 (Peripheral Interrupt LCDCON (LCD Control) .........................................., 1 = 258. LCDDATAx (LCD Datax), 1 =",
    "PIC18F6390/6490/8390/8490\n......................................... 261. LCDPS (LCD Phase) ..............................................., 1 = 259. LCDSEx (LCD Segmentx Enable), 1 = ........................... 260. OSCCON (Oscillator Control), 1 = .................................... 38. OSCTUNE (Oscillator Tuning), 1 = ...................................",
    "PIC18F6390/6490/8390/8490\n35. PIE1 (Peripheral Interrupt Enable 1), 1 = ....................... 101. PIE2 (Peripheral Interrupt Enable 2) ......................., 1 = 102. PIE3 (Peripheral Interrupt Enable 3) ......................., 1 = 103. PIR1 (Peripheral Interrupt Request (Flag) 1), 1 = ............. 98. PIR2 (Peripheral Interrupt Request (Flag) 2), 1 = ............. 99. PIR3 (Peripheral Interrupt Request (Flag) 3) ..........., 1 = 100. RCON (Reset Control)",
    "PIC18F6390/6490/8390/8490\n....................................... RCSTA1 (EUSART Receive, 1 = 52, 107. Status and Control) RCSTA2 (AUSART Receive Status and Control) .........................................., 1 = .......................................... 199 219. SSPCON1 (MSSP Control 1, I 2 C Mode), 1 = ................. 168. SSPCON1 (MSSP Control 1, SPI Mode), 1 = ................ 159. SSPCON2 (MSSP Control 2,",
    "PIC18F6390/6490/8390/8490\nI 2 C Master Mode) ............................................ 2, 1 = 169. SSPSTAT (MSSP Status, I C Mode) SSPSTAT (MSSP Status, SPI Mode), 1 = ...................... 167 ...................... 158. STATUS ...................................................................., 1 = 80",
    "PIC18F6390/6490/8390/8490\n............................................. STKPTR (Stack Pointer), 1 = 67. T0CON (Timer0 Control), 1 = ......................................... 131. T1CON (Timer1 Control), 1 = .......................................... T2CON (Timer2 Control), 1 = 135. T3CON (Timer3 Control), 1 = ......................................... 141 143.",
    "PIC18F6390/6490/8390/8490\n......................................... TXSTA1 (EUSART Transmit Status and Control), 1 = 198. .......................................... TXSTA2 (AUSART Transmit, 1 = 218. Status and Control) .......................................... WDTCON (Watchdog Timer Control), 1 = ...................... 288.",
    "PIC18F6390/6490/8390/8490\n............................................................................., 1 = . RESET, 1 = 325",
    "PIC18F6390/6490/8390/8490\nReset .................................................................................., 1 = 51. MCLR Reset, during Power-Managed Modes, 1 = ........... 51. MCLR Reset, Normal Operation ................................, 1 = 51. Power-on Reset (POR) .............................................., 1 = 51. Programmable Brown-out Reset (BOR), 1 =",
    "PIC18F6390/6490/8390/8490\n.................... 51. Stack Full Reset, 1 = ......................................................... 51. Stack Underflow Reset .............................................., 1 = 51. Watchdog Timer (WDT), 1 = Reset ................................... 51. Resets, 1 =",
    "PIC18F6390/6490/8390/8490\n.............................................................................. 281. RETFIE RETLW, 1 = ............................................................................ 326",
    "PIC18F6390/6490/8390/8490\n............................................................................. 326. RETURN, 1 = 327. .........................................................................., 1 = 66. Return Address Stack ........................................................ Return Stack Pointer (STKPTR), 1 = 67. Revision History, 1",
    "PIC18F6390/6490/8390/8490\n= ........................................ ............................................................... 395. RLCF ................................................................................, 1 = 327. RLNCF, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................................. 328. , 1 = 328. RRCF ..............................................................................., 1 = . RRNCF, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................................. 329. S, 1 = . SCK, 1 = .................................................................................. 157. SDI",
    "PIC18F6390/6490/8390/8490\n..................................................................................., 1 = 157. SDO, 1 = ................................................................................. 157. Serial Clock, SCK, 1 =",
    "PIC18F6390/6490/8390/8490\n............................................................. 157. Serial Data In (SDI), 1 = .......................................................... 157. Serial Data Out (SDO) ....................................................., 1 = 157. Serial Peripheral Interface. See SPI Mode., 1 = . SETF",
    "PIC18F6390/6490/8390/8490\n................................................................................, 1 = 329. Slave Select (SS), 1 = ............................................................. 157. SLEEP, 1 = .............................................................................. 330. Sleep",
    "PIC18F6390/6490/8390/8490\nOSC1 and OSC2 Pin States, 1 = ...................................... 39. Software Enabled BOR ......................................................, 1 = 54. Special Event Trigger. See Compare (CCP Module)., 1 = . Special Features of the CPU ............................................, 1 = 281. Special Function Registers ................................................, 1 = 74.",
    "PIC18F6390/6490/8390/8490\nMap ...................................................................... SPI Mode (MSSP), 1 = 74GLYPH<150>75. Associated Registers, 1 = ............................................... 165. Bus Mode Compatibility, 1 = ........................................... 165. Effects of a Reset",
    "PIC18F6390/6490/8390/8490\n....................................................., 1 = 165. Enabling SPI I/O, 1 = ...................................................... 161. Master Mode, 1 = ............................................................ 162. Master/Slave Connection, 1 = ......................................... 161.",
    "PIC18F6390/6490/8390/8490\nOperation, 1 = ................................................................. 160. Serial Clock, 1 = .............................................................. 157. Serial Data In, 1 = ........................................................... 157. Serial Data Out, 1 =",
    "PIC18F6390/6490/8390/8490\n........................................................ 157. Slave Mode, 1 = .............................................................. 163. Slave Select ............................................................. Slave Select Synchronization, 1 = 157 163.",
    "PIC18F6390/6490/8390/8490\n......................................................., 1 = . Sleep Operation, 1 = 165. SPI Clock ................................................................., 1 = 162. Typical Connection ...................................................................................., 1 =",
    "PIC18F6390/6490/8390/8490\n.................................................. 161. SS SSPOV, 1 = 157 187. SSPOV Status Flag SSPSTAT Register, 1 = .......................................................... 187. R/W Bit, 1 = ............................................................. 170, 171. Stack Full/Underflow Resets, 1 =",
    "PIC18F6390/6490/8390/8490\n.............................................. 68. STATUS Register SUBFSR ..........................................................................., 1 = ............................................................... 80 341. SUBFWB, 1 =",
    "PIC18F6390/6490/8390/8490\n.......................................................................... 330. SUBLW, 1 = ............................................................................ 331",
    "PIC18F6390/6490/8390/8490\nSUBULNK, 1 = ........................................................................ 341. SUBWF, 1 = ............................................................................ 331. SUBWFB, 1 =",
    "PIC18F6390/6490/8390/8490\n......................................................................... 332. SWAPF, 1 = ............................................................................ 332",
    "T\nT0CON Register, 1 = . PSA Bit ...................................................................., 1 = 133. T0CS Bit, 1 = .................................................................. 132. T0PS2:T0PS0 Bits, 1 = ................................................... 133. T0SE Bit",
    "T\n.................................................................., 1 = 132. Table Pointer Operations (table), 1 = ........................................ 88. Table Reads, 1 = ...................................................................... 68. TBLRD",
    "T\n............................................................................., 1 = 333. TBLWT ............................................................................., 1 = 334. Time-out in Various Situations (table), 1 = ................................ 55. Timer0",
    "T\n.............................................................................., 1 = 131. 16-Bit Mode Timer Reads and Writes, 1 = ...................... 132. Associated Registers ..............................................., 1 = 133. Clock Source Edge Select (T0SE Bit), 1 = ..................... 132. Clock Source Select (T0CS Bit), 1 = ............................... 132. Operation",
    "T\n................................................................., 1 = 132. Overflow Interrupt, 1 = .................................................... 133. Prescaler. See Prescaler, Timer0., 1 = . Timer1 .............................................................................., 1 = 135. 16-Bit Read/Write Mode, 1 =",
    "T\n.......................................... 137. Associated Registers, 1 = ............................................... 139. Interrupt, 1 = ................................................................... 138. Operation, 1 = ................................................................. 136. Oscillator, 1 =",
    "T\n.......................................................... 135, 137. Layout Considerations, 1 = ..................................... 138. Overflow Interrupt, 1 = .................................................... 135. Resetting, Using a Special Event Trigger, 1 = . Output (CCP) ..................................................., 1 = 138. TMR1H Register, 1 =",
    "T\n...................................................... 135. TMR1L Register ......................................................., 1 = 135. Use as a Real-Time Clock, 1 = 138. .............................................................................., 1 = 141. Timer2, 1 =",
    "T\n........................................ Associated Registers, 1 = ............................................... 142. Interrupt, 1 = ................................................................... 142. Operation, 1 = ................................................................. 141. Output, 1 =",
    "T\n...................................................................... 142. PR2 Register ..........................................................., 1 = 153 153. TMR2 to PR2 Match Interrupt, 1 = .................................. 143. Timer3",
    "T\n.............................................................................. 16-Bit Read/Write Mode, 1 = .......................................... 145. Associated Registers, 1 = ............................................... 145. Operation, 1 = .................................................................",
    "T\n144. Oscillator, 1 = .......................................................... 143, 145. Overflow Interrupt ............................................, 1 = 143, 145. Special Event Trigger (CCP) ......................................................, 1 = ................................... 145. TMR3H Register, 1 = 143. TMR3L Register, 1 =",
    "T\n....................................................... 143. Timing Diagrams, 1 = . A/D Conversion, 1 = ........................................................ 385. Acknowledge Sequence, 1 = .......................................... 190. Asynchronous Reception ................................., 1 = 209, 225. Asynchronous Transmission, 1 = . (Back-to-Back), 1 =",
    "T\n......................................... 207, 223. Automatic Baud Rate Calculation, 1 = ............................ 205. Auto-Wake-up Bit (WUE) During Normal Operation, 1 = ............................................ 210. Baud Rate Generator with Clock Arbitration, 1 = ............ 184. BRG Overflow Sequence ........................................., 1 = 205",
    "PIC18F6390/6490/8390/8490\nBRG Reset Due to SDA Arbitration During Start Condition ....................................., 1 = 193. Brown-out Reset (BOR) ..........................................., 1 = 372. Bus Collision During a Repeated Start Condition (Case 1) .................................., 1 = 194. Bus Collision During a Repeated Start Condition (Case 2) .................................., 1 = 194. Bus Collision During a Start Condition (SCL = 0)",
    "PIC18F6390/6490/8390/8490\n........................................., 1 = 193. Bus Collision During a Start Condition (SDA Only) Bus Collision During a Stop, 1 = ...................................... 192. Condition (Case 1) ........................................... Stop, 1 = 195. Bus Collision During a Condition (Case 2) ..........................................., 1 = 195. Bus Collision for Transmit and Acknowledge, 1 = ........... 191.",
    "PIC18F6390/6490/8390/8490\nCapture/Compare/PWM (All CCP Modules), 1 = ............ 374. CLKO and I/O, 1 = .......................................................... 371. Clock Synchronization ............................................., 1 = 177. Clock/Instruction Cycle .............................................., 1 = 69. Example SPI Master Mode (CKE = 0), 1 =",
    "PIC18F6390/6490/8390/8490\n..................... 375. Example SPI Master Mode (CKE = 1), 1 = ..................... 376. Example SPI Slave Mode (CKE = 0), 1 = ....................... 377. Example SPI Slave Mode (CKE = 1) ......................., 1 = 378. External Clock (All Modes Except PLL), 1 = ................... 369. Fail-Safe Clock Monitor ............................................, 1 = 291. High/Low-Voltage Detect Characteristics Operation",
    "PIC18F6390/6490/8390/8490\n(VDIRMAG, 1 = ................ 366 ....... High-Voltage Detect = 2, 1 = 1) 254. I C Bus Data ............................................................ 2, 1 = 379. I C Bus Start/Stop Bits, 1 = ............................................. 379. I 2 C Master Mode (7 or 10-Bit Transmission) 2, 1 = ........... 188. I C Master Mode (7-Bit Reception) 2, 1 =",
    "PIC18F6390/6490/8390/8490\n.......................... 189. I C Master Mode First Start Bit ................................ I 2 C Slave Mode (10-Bit Reception, SEN = 0), 1 = 185 .......... 174. I 2 C Slave Mode (10-Bit Reception, SEN = 1), 1 = 179. I 2 C Slave Mode (10-Bit Transmission) ....................., 1 = .......... 175. I 2 C Slave Mode (7-Bit Reception, SEN =, 1 = ............ 172. 0) I 2 1), 1 = ............. C Slave Mode (7-Bit Reception, SEN =, 1 = 178. I 2 C Slave Mode",
    "PIC18F6390/6490/8390/8490\n(7-Bit Transmission) ....................... I 2 C Slave Mode General Call Address Sequence (7 or 10-Bit Addressing Mode), 1 = 173 ........ 180. I 2 C Stop Condition Receive or Transmit Mode, 1 = 190. ........ LCD Interrupt Timing in Quarter-Duty Cycle Drive LCD Sleep Entry/Exit When SLPEN = 1 or, 1 = ... 276. CS1:CS0 = 00 .................................................. Low-Voltage Detect Operation (VDIRMAG = 0), 1 = 277 253. Master SSP I 2 C Bus Data ........................................, 1 =",
    "PIC18F6390/6490/8390/8490\n...... 381. Master SSP I 2 C Bus Start/Stop Bits, 1 = ........................ 381. PWM Output ............................................................, 1 = 153. , 1 = 186. Repeat Start Condition ............................................. Reset, Watchdog Timer (WDT), Oscillator Start-up Timer (OST) and Power-up Timer (PWRT) ....., 1 = 372. Send Break Character Sequence, 1 =",
    "PIC18F6390/6490/8390/8490\n............................ 211. Slave Synchronization ............................................. Slow Rise Time (MCLR Tied to VDD,, 1 = 163. VDD Rise > TPWRT) ............................................, 1 = 57. SPI Mode (Master Mode) ......................................... SPI Mode (Slave Mode, CKE =, 1 = 162. 0) SPI Mode (Slave Mode, CKE = 1), 1 =",
    "PIC18F6390/6490/8390/8490\n........................... 164 ........................... 164. Synchronous Reception, 1 = 228 212, 226. (Master Mode, SREN) ............................., 1 = 214,. Synchronous Transmission .............................. Synchronous Transmission, 1 = 213,. (Through TXEN) ......................................, 1 = 227",
    "PIC18F6390/6490/8390/8490\nTime-out Sequence on POR w/PLL Enabled (MCLR Tied to VDD) .........................................., 1 = 57. Time-out Sequence on Power-up, 1 = . MCLR Not Tied to VDD, Case 1, 1 = ......................... 56. MCLR Not Tied to VDD, Case 2, 1 = ......................... 56. MCLR Tied to VDD, VDD Rise < TPWRT, 1 = ............. 56. Timer0 and Timer1 External Clock .........................., 1 = 373. Transition for Entry to PRI_IDLE Mode, 1 =",
    "PIC18F6390/6490/8390/8490\n..................... 46. Transition for Entry to SEC_RUN Mode, 1 = .................... 43. Transition for Entry to Sleep Mode, 1 = ............................ 45. Transition for Two-Speed Start-up (INTOSC to HSPLL) ........................................, 1 = . , 1 = 289. Transition for Wake from Idle to Run Mode, 1 = ............... 46. Transition for Wake from Sleep (HSPLL) Transition from RC_RUN Mode to, 1 = .................. 45. PRI_RUN Mode",
    "PIC18F6390/6490/8390/8490\n................................................. Transition from SEC_RUN, 1 = 44. Mode to PRI_RUN Mode (HSPLL) .................................., 1 = 43. Transition to RC_RUN Mode ....................................., 1 = 44. Type-A in 1/2 MUX, 1/2 Bias Drive .........................., 1 = 266. Type-A in 1/2 MUX, 1/3 Bias Drive",
    "PIC18F6390/6490/8390/8490\n.........................., 1 = 268. Type-A in 1/3 MUX, 1/2 Bias Drive .........................., 1 = 270. Type-A in 1/3 MUX, 1/3 Bias Drive .........................., 1 = 272. Type-A in 1/4 MUX, 1/3 Bias Drive .........................., 1 = 274. Type-A/Type-B in Static Drive ................................., 1 = 265. Type-B in 1/2 MUX, 1/2 Bias Drive",
    "PIC18F6390/6490/8390/8490\n.........................., 1 = 267. Type-B in 1/2 MUX, 1/3 Bias Drive .........................., 1 = 269. Type-B in 1/3 MUX, 1/2 Bias Drive .........................., 1 = 271. Type-B in 1/3 MUX, 1/3 Bias Drive .......................... Type-B in 1/4 MUX, 1/3 Bias Drive .........................., 1 = 273 275. USART Synchronous Receive (Master/Slave), 1 = 383. USART Synchronous Transmission",
    "PIC18F6390/6490/8390/8490\n................................................., 1 = . (Master/Slave), 1 = 383. Diagrams and Specifications A/D Conversion Requirements ................................, 1 = 385. AC Characteristics - Internal RC Accuracy .............., 1 = 370. Capture/Compare/PWM Requirements ..........................................., 1 = 374. ................................... Example SPI Mode Requirements, 1 = 371. (All CCP",
    "PIC18F6390/6490/8390/8490\nModules) CLKO and I/O Requirements, 1 = . Example SPI Mode Requirements (Master Mode, CKE = 1) .................................., 1 = 375. (Master Mode, CKE = 0) .................................., 1 = 376. Example SPI Mode Requirements (Slave Mode, CKE = 0) ...................................., 1 = 377. Example SPI Slave Mode Requirements (CKE = 1) .........................................................,",
    "PIC18F6390/6490/8390/8490\n1 = 378. External Clock Requirements, 1 = 369. .................................. I 2 C Bus Data Requirements (Slave Mode) .............., 1 = 380. I 2 C Bus Start/Stop Bits Requirements, 1 = . Master SSP I C Bus Data ................ Bits, 1 = 382. (Slave Mode) ................................................... 2 Requirements, 1 = 379. Master SSP I 2 C Bus Start/Stop, 1 = 381. Requirements",
    "PIC18F6390/6490/8390/8490\n.................................................., 1 = 370. PLL Clock ................................................................ Reset, Watchdog Timer, Oscillator Start-up and Brown-out, 1 = . Timer, Power-up Timer Reset Requirements, 1 = 372. Timer0 and Timer1 External Clock Requirements ........................................, 1 = .",
    "PIC18F6390/6490/8390/8490\n........................................, 1 = 373. Requirements .................................................. USART Synchronous Transmission, 1 = 383. Requirements .................................................., 1 = 383",
    "PIC18F6390/6490/8390/8490\nTop-of-Stack Access, 1 = .......................................................... 66. TSTFSZ, 1 = ............................................................................ 335. Two-Speed Start-up, 1 = ................................................. 281, 289. Two-Word Instructions Example Cases",
    "PIC18F6390/6490/8390/8490\n.........................................................., 1 = 70. TXSTA1 Register BRGH Bit ................................................................., 1 = 201. TXSTA2 Register BRGH Bit ................................................................., 1 = 220. Voltage Reference Specifications, 1 =",
    "PIC18F6390/6490/8390/8490\n.................................... 365",
    "W\nWatchdog Timer (WDT) ..........................................., 1 = 281, 287. Watchdog Timer (WDT) ..........................................., 2 = . Associated Registers ..............................................., 1 = 288. Associated Registers ..............................................., 2 = . Control Register",
    "W\n......................................................., 1 = 287. Control Register ......................................................., 2 = . During Oscillator Failure .........................................., 1 = 290. During Oscillator Failure .........................................., 2 = . Programming Considerations",
    "W\n.................................., 1 = 287. Programming Considerations .................................., 2 = . WCOL ...................................................... 185, 186,, 1 = 187, 190. WCOL ...................................................... 185, 186,, 2 = . WCOL Status Flag ................................... 185,, 1 =",
    "W\n186, 187, 190. WCOL Status Flag ................................... 185,, 2 = . WWWAddress ................................................................, 1 = 409. WWWAddress ................................................................, 2 = . WWW, On-Line Support",
    "W\n......................................................, 1 = 5. WWW, On-Line Support ......................................................, 2 = . X, 1 = X. X, 2 = X. XORLW, 1 = ............................................................................ 335. XORLW, 2 = . XORWF, 1 =",
    "W\n........................................................................... 336. XORWF, 2 = ",
    "THE MICROCHIP WEB SITE\nMicrochip provides online support via our WWW site at www.microchip.com. This web site is used as a means to make  files and  information  easily available to customers. Accessible by using your favorite Internet browser, the web site contains the following information:\nGLYPH<149> Product Support GLYPH<150> Data sheets and errata, application notes and sample programs, design resources, userGLYPH<146>s guides and hardware support documents, latest software releases and archived software\nGLYPH<149> General Technical Support GLYPH<150> Frequently Asked Questions (FAQ), technical support requests, online discussion groups, Microchip consultant program member listing\nGLYPH<149> Business of Microchip GLYPH<150> Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "CUSTOMER CHANGE NOTIFICATION SERVICE\nMicrochipGLYPH<146>s  customer  notification  service  helps  keep customers current on Microchip products. Subscribers will receive  e-mail  notification  whenever  there  are changes,  updates,  revisions  or  errata  related  to  a specified product family or development tool of interest.\nTo register, access the Microchip web site at www.microchip.com, click on Customer Change Notification and follow the registration instructions.",
    "CUSTOMER SUPPORT\nUsers  of  Microchip  products  can  receive  assistance through several channels:\nGLYPH<149> Distributor or Representative\nGLYPH<149> Local Sales Office\nGLYPH<149> Field Application Engineer (FAE)\nGLYPH<149> Technical Support\nGLYPH<149> Development Systems Information Line\nCustomers should contact their distributor, representative  or  field  application  engineer  (FAE)  for support. Local sales offices are also available to help customers.  A  listing  of  sales  offices  and  locations  is included in the back of this document.\nTechnical support is available through the web site at: http://support.microchip.com",
    "READER RESPONSE\nIt is our intention to provide you with the best documentation possible to ensure successful use of your Microchip product.  If you wish to provide your comments on organization, clarity, subject matter, and ways in which our documentation can better serve you, please FAX your comments to the Technical Publications Manager at (480) 792-4150.\nPlease list the following information, and use this outline to provide us with your comments about this document.\nTo:\nTechnical Publications Manager\nRE:\nReader Response\nTotal Pages Sent ________\nFrom:\nName\nCompany\nAddress\nCity / State / ZIP / Country\nTelephone: (_______) _________ - _________\nApplication (optional):\nWould you like a reply?       Y         N\nDevice:  PIC18F6390/6490/8390/8490\nLiterature Number: DS39629C\nQuestions:\nFAX: (______) _________ - _________\n1. What are the best features of this document?\n2. How does this document meet your hardware and software development needs?",
    "READER RESPONSE\n3. Do you find the organization of this document easy to follow? If not, why?\n4. What additions to the document do you think would enhance the structure and subject?\n5. What deletions from the document could be made without affecting the overall usefulness?\n6. Is there any incorrect or misleading information (what and where)?\n7. How would you improve this document?",
    "PIC18F6390/6490/8390/8490 PRODUCT IDENTIFICATION SYSTEM\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.\nPART NO.\nX\n/XX\nXXX\nPattern\nPackage\nTemperature Range\nDevice\nDevice (1), (2)\nPIC18F6390/6490/8390/8490,\nPIC18F6390/6490/8390/8490T; VDD range 4.2V to 5.5V PIC18LF6390/6490/8390/8490, PIC18LF6390/6490/8390/8490T; VDD range 2.0V to 5.5V\nTemperature Range\nI \u00b0 \u00b0\n= -40 C to +85 C (Industrial)\nE = -40 C to \u00b0 +125 C \u00b0 (Extended)\nPackage\nPT = TQFP (Thin Quad Flatpack)\nPattern\nQTP, SQTP, Code or Special Requirements (blank otherwise)",
    "Examples:\na) PIC18LF6490-I/PT 301 = Industrial temp., TQFP package, Extended VDD limits, QTP pattern #301.\nb) PIC18F8490-I/PT = Industrial temp., TQFP package, normal VDD limits.\nc) PIC18F8490-E/PT = Extended temp., TQFP package, normal VDD limits.\nNote 1:\nF =\nStandard Voltage Range\nLF =\nWide Voltage Range\n2: T =\nIn tape and reel",
    "AMERICAS\nCorporate Office 2355 West Chandler Blvd. Chandler, AZ  85224-6199 Tel:  480-792-7200 Fax:  480-792-7277 Technical Support: http://support.microchip.com Web Address: www.microchip.com\nAtlanta Duluth, GA Tel: 678-957-9614 Fax: 678-957-1455",
    "Boston\nWestborough, MA Tel: 774-760-0087 Fax: 774-760-0088",
    "Chicago\nItasca, IL\nTel: 630-285-0071\nFax: 630-285-0075\nDallas Addison, TX Tel: 972-818-7423 Fax: 972-818-2924\nDetroit Farmington Hills, MI Tel: 248-538-2250 Fax: 248-538-2260\nKokomo Kokomo, IN Tel: 765-864-8360 Fax: 765-864-8387\nLos Angeles Mission Viejo, CA Tel: 949-462-9523 Fax: 949-462-9608\nSanta Clara Santa Clara, CA Tel: 408-961-6444 Fax: 408-961-6445\nToronto Mississauga, Ontario, Canada Tel: 905-673-0699 Fax:  905-673-6509",
    "ASIA/PACIFIC\nAsia Pacific Office Suites 3707-14, 37th Floor Tower 6, The Gateway Harbour City, Kowloon Hong Kong Tel: 852-2401-1200 Fax: 852-2401-3431\nAustralia - Sydney Tel: 61-2-9868-6733 Fax: 61-2-9868-6755\nChina - Beijing Tel: 86-10-8528-2100 Fax: 86-10-8528-2104\nChina - Chengdu Tel: 86-28-8665-5511 Fax: 86-28-8665-7889\nChina - Fuzhou Tel: 86-591-8750-3506 Fax: 86-591-8750-3521\nChina - Hong Kong SAR Tel: 852-2401-1200 Fax: 852-2401-3431\nChina - Nanjing Tel: 86-25-8473-2460 Fax: 86-25-8473-2470\nChina - Qingdao Tel: 86-532-8502-7355 Fax: 86-532-8502-7205",
    "ASIA/PACIFIC\nChina - Shanghai Tel: 86-21-5407-5533 Fax: 86-21-5407-5066\nChina - Shenyang Tel: 86-24-2334-2829 Fax: 86-24-2334-2393\nChina - Shenzhen Tel: 86-755-8203-2660 Fax: 86-755-8203-1760\nChina - Shunde Tel: 86-757-2839-5507 Fax: 86-757-2839-5571\nChina - Wuhan Tel: 86-27-5980-5300 Fax: 86-27-5980-5118",
    "China - Xian\nTel: 86-29-8833-7252 Fax: 86-29-8833-7256\nIndia - Bangalore Tel: 91-80-4182-8400 Fax: 91-80-4182-8422\nIndia - New Delhi Tel: 91-11-4160-8631 Fax: 91-11-4160-8632",
    "India - Pune\nTel: 91-20-2566-1512 Fax: 91-20-2566-1513\nJapan - Yokohama Tel: 81-45-471- 6166 Fax: 81-45-471-6122",
    "Korea - Daegu\nTel: 82-53-744-4301\nFax: 82-53-744-4302\nKorea - Seoul Tel: 82-2-554-7200 Fax: 82-2-558-5932 or 82-2-558-5934",
    "Malaysia - Kuala Lumpur\nTel: 60-3-6201-9857 Fax: 60-3-6201-9859\nMalaysia - Penang Tel: 60-4-227-8870 Fax: 60-4-227-4068",
    "Philippines - Manila\nTel: 63-2-634-9065 Fax: 63-2-634-9069",
    "Singapore\nTel:  65-6334-8870 Fax: 65-6334-8850\nTaiwan - Hsin Chu Tel: 886-3-572-9526 Fax: 886-3-572-6459",
    "Taiwan - Kaohsiung\nTel: 886-7-536-4818\nFax: 886-7-536-4803",
    "Taiwan - Taipei\nTel: 886-2-2500-6610\nFax: 886-2-2508-0102\nThailand - Bangkok Tel: 66-2-694-1351 Fax: 66-2-694-1350",
    "EUROPE\nAustria - Wels Tel: 43-7242-2244-39 Fax: 43-7242-2244-393\nDenmark - Copenhagen\nTel: 45-4450-2828\nFax: 45-4485-2829\nFrance - Paris Tel: 33-1-69-53-63-20 Fax: 33-1-69-30-90-79\nGermany - Munich Tel: 49-89-627-144-0 Fax: 49-89-627-144-44",
    "Italy - Milan\nTel: 39-0331-742611 Fax: 39-0331-466781",
    "Netherlands - Drunen\nTel: 31-416-690399 Fax: 31-416-690340\nSpain - Madrid Tel: 34-91-708-08-90 Fax: 34-91-708-08-91\nUK - Wokingham Tel: 44-118-921-5869 Fax: 44-118-921-5820",
    "Mouser Electronics\nAuthorized Distributor\nClick to View Pricing, Inventory, Delivery & Lifecycle Information:\nMicrochip:\nPIC18F8490-I/PT\u00a0 PIC18F8390-I/PT\u00a0 PIC18F6390T-I/PT\u00a0 PIC18F6490T-I/PT\u00a0 PIC18LF6490-I/PT\u00a0 PIC18LF6390-I/PT PIC18F8490-E/PT\u00a0 PIC18LF8490-I/PT\u00a0 PIC18LF8390-I/PT\u00a0 PIC18F8490T-I/PT\u00a0 PIC18LF6390T-I/PT\u00a0 PIC18LF6490T- I/PT\u00a0 PIC18F6490-I/PT\u00a0 PIC18F6390-I/PT"
]
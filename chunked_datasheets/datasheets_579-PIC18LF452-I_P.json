[
    "PIC18FXX2 Data Sheet\nHigh-Performance, Enhanced Flash Microcontrollers with 10-Bit A/D",
    "Note the following details of the code protection feature on Microchip devices:\nGLYPH<129> Microchip products meet the specification contained in their particular Microchip Data Sheet.\nGLYPH<129> Microchip believes that its family of products is one of the most secure families of its kind on the market today, when used in the intended manner and under normal conditions.\nGLYPH<129> There are dishonest and possibly illegal methods used to breach the code protection feature. All of these methods, to our knowledge, require using the Microchip products in a manner outside the operating specifications contained in Microchip's Data Sheets. Most likely, the person doing so is engaged in theft of intellectual property.\nGLYPH<129> Microchip is willing to work with the customer who is concerned about the integrity of their code.\nGLYPH<129> Neither Microchip nor any other semiconductor manufacturer can guarantee the security of their code. Code protection does not mean that we are guaranteeing the product as 'unbreakable.'",
    "Note the following details of the code protection feature on Microchip devices:\nCode protection is constantly evolving. We at Microchip are committed to continuously improving the code protection features of our products. Attempts to break Microchip's code protection feature may be a violation of the Digital Millennium Copyright Act. If such acts allow unauthorized access to your software or other copyrighted work, you may have a right to sue for relief under that Act.",
    "Note the following details of the code protection feature on Microchip devices:\nInformation  contained  in  this  publication  regarding  device applications and the like is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure  that  your  application  meets  with  your  specifications. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES  OF  ANY  KIND  WHETHER  EXPRESS  OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION, INCLUDING  BUT  NOT  LIMITED  TO  ITS CONDITION, QUALITY, PERFORMANCE, MERCHANTABILITY OR FITNESS  FOR  PURPOSE . Microchip  disclaims  all  liability arising  from  this  information  and  its  use.  Use  of  Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold  harmless  Microchip  from  any  and  all  damages,  claims, suits,  or  expenses  resulting  from  such  use.  No  licenses  are conveyed, implicitly or otherwise, under any Microchip intellectual property rights.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, Accuron, dsPIC, KEELOQ, micro ID , MPLAB, PIC, PICmicro, PICSTART, PRO MATE, PowerSmart, rfPIC and SmartShunt are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nAmpLab, FilterLab, Migratable Memory, MXDEV, MXLAB, SEEVAL, SmartSensor and The Embedded Control Solutions Company are registered trademarks of Microchip Technology Incorporated in the U.S.A.",
    "Trademarks\nAnalog-for-the-Digital Age, Application Maestro, CodeGuard, dsPICDEM, dsPICDEM.net, dsPICworks, ECAN, ECONOMONITOR, FanSense, FlexROM, fuzzyLAB, In-Circuit Serial Programming, ICSP, ICEPIC, Linear Active Thermistor, Mindi, MiWi, MPASM, MPLIB, MPLINK, PICkit, PICDEM, PICDEM.net, PICLAB, PICtail, PowerCal, PowerInfo, PowerMate, PowerTool, REAL ICE, rfLAB, rfPICDEM, Select Mode, Smart Serial, SmartTel, Total Endurance, UNI/O, WiperLock and ZENA are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nAll other trademarks mentioned herein are property of their respective companies.\n' 2006, Microchip Technology Incorporated, Printed in the U.S.A., All Rights Reserved.\nPrinted on recycled paper.",
    "Trademarks\nMicrochip received ISO/TS-16949:2002 certification for its worldwide headquarters, design and wafer fabrication facilities in Chandler and Tempe, Arizona, Gresham, Oregon and Mountain View, California. The Company's quality system processes and procedures are for its PICmicro fi 8-bit MCUs, KEELOQ fi  code hopping devices, Serial EEPROMs, microperipherals, nonvolatile memory and analog products. In addition, Microchip's quality system for the design and manufacture of development systems is ISO 9001:2000 certified.\nQUALITY MANAGEMENT SYSTEM CERTIFIED BY DNV",
    "Peripheral Features (Continued):\nGLYPH<129> C compiler optimized architecture/instruction set\n-Source code compatible with the PIC16 and PIC17 instruction sets\nGLYPH<129> Linear program memory addressing to 32 Kbytes\nGLYPH<129> Linear data memory addressing to 1.5 Kbytes\nGLYPH<129> Up to 10 MIPs operation:\n-DC - 40 MHz osc./clock input\n-4 MHz - 10 MHz osc./clock input with PLL active\nGLYPH<129> 16-bit wide instructions, 8-bit wide data path\nGLYPH<129> Priority levels for interrupts\nGLYPH<129> 8 x 8 Single Cycle Hardware Multiplier",
    "Peripheral Features (Continued):\nPIC18F242, On-Chip Program Memory.FLASH (bytes) = 16K. PIC18F242, On-Chip Program Memory.# Single Word Instructions = 8192. PIC18F242, On-Chip RAM (bytes).On-Chip RAM (bytes) = 768. PIC18F242, Data EEPROM (bytes).Data EEPROM (bytes) = 256. PIC18F252, On-Chip Program Memory.FLASH (bytes) = 32K. PIC18F252, On-Chip Program Memory.# Single Word Instructions = 16384. PIC18F252, On-Chip RAM (bytes).On-Chip RAM (bytes) = 1536. PIC18F252, Data EEPROM (bytes).Data EEPROM (bytes) = 256. PIC18F442, On-Chip Program Memory.FLASH (bytes) = 16K. PIC18F442, On-Chip Program Memory.# Single Word Instructions = 8192. PIC18F442, On-Chip RAM (bytes).On-Chip RAM (bytes) = 768.",
    "Peripheral Features (Continued):\nPIC18F442, Data EEPROM (bytes).Data EEPROM (bytes) = 256. PIC18F452, On-Chip Program Memory.FLASH (bytes) = 32K. PIC18F452, On-Chip Program Memory.# Single Word Instructions = 16384. PIC18F452, On-Chip RAM (bytes).On-Chip RAM (bytes) = 1536. PIC18F452, Data EEPROM (bytes).Data EEPROM (bytes) = 256",
    "Peripheral Features:\nGLYPH<129> High current sink/source 25 mA/25 mA\nGLYPH<129> Three external interrupt pins\nGLYPH<129> Timer0 module: 8-bit/16-bit timer/counter with 8-bit programmable prescaler\nGLYPH<129> Timer1 module: 16-bit timer/counter\nGLYPH<129> Timer2 module: 8-bit timer/counter with 8-bit period register (time-base for PWM)\nGLYPH<129> Timer3 module: 16-bit timer/counter\nGLYPH<129> Secondary oscillator clock option - Timer1/Timer3\nGLYPH<129> Two Capture/Compare/PWM (CCP) modules. CCP pins that can be configured as:\n-Capture input: capture is 16-bit, max. resolution 6.25 ns (TCY/16)\n-Compare is 16-bit, max. resolution 100 ns (TCY)\n-PWM output: PWM resolution is 1- to 10-bit, max. PWM freq. @: 8-bit resolution = 156 kHz 10-bit resolution = 39 kHz",
    "Peripheral Features:\nGLYPH<129> Master Synchronous Serial Port (MSSP) module, Two modes of operation:\n-3-wire SPI\u2122 (supports all 4 SPI modes)\n-I 2 C\u2122 Master and Slave mode\nGLYPH<129> Addressable USART module:\n-Supports RS-485 and RS-232\nGLYPH<129> Parallel Slave Port (PSP) module",
    "Analog Features:\nGLYPH<129> Compatible 10-bit Analog-to-Digital Converter module (A/D) with:\n-Fast sampling rate\n-Conversion available during SLEEP\n-Linearity \u2264 1 LSb\nGLYPH<129> Programmable Low Voltage Detection (PLVD)\n-Supports interrupt on-Low Voltage Detection\nGLYPH<129> Programmable Brown-out Reset (BOR)",
    "Special Microcontroller Features:\nGLYPH<129> 100,000 erase/write cycle Enhanced FLASH program memory typical\nGLYPH<129> 1,000,000 erase/write cycle Data EEPROM memory\nGLYPH<129> FLASH/Data EEPROM Retention: > 40 years\nGLYPH<129> Self-reprogrammable under software control\nGLYPH<129> Power-on Reset (POR), Power-up Timer (PWRT) and Oscillator Start-up Timer (OST)\nGLYPH<129> Watchdog Timer (WDT) with its own On-Chip RC Oscillator for reliable operation\nGLYPH<129> Programmable code protection\nGLYPH<129> Power saving SLEEP mode\nGLYPH<129> Selectable oscillator options including:\n-4X Phase Lock Loop (of primary oscillator)\n-Secondary Oscillator (32 kHz) clock input\nGLYPH<129> Single supply 5V In-Circuit Serial Programming\u2122 (ICSP\u2122) via two pins\nGLYPH<129> In-Circuit Debug (ICD) via two pins",
    "CMOS Technology:\nGLYPH<129> Low power, high speed FLASH/EEPROM technology\nGLYPH<129> Fully static design\nGLYPH<129> Wide operating voltage range (2.0V to 5.5V)\nGLYPH<129> Industrial and Extended temperature ranges\nGLYPH<129> Low power consumption:\n-< 1.6 mA typical @ 5V, 4 MHz\n-25 \u00b5 A typical @ 3V, 32 kHz\n-< 0.2 \u00b5 A typical standby current",
    "Table of Contents\n1.0, 1 = Device Overview .......................................................................................................................................................................... 7. 1.0, 2 = Device Overview",
    "Table of Contents\n.......................................................................................................................................................................... 7. 2.0, 1 = Oscillator Configurations",
    "Table of Contents\n............................................................................................................................................................. 2.0, 2 = 17. 3.0, 1 =",
    "Table of Contents\nReset........................................................................................................................................................................................... 3.0, 2 = 25. 4.0, 1 = Memory",
    "Table of Contents\nOrganization.................................................................................................................................................................. 4.0, 2 = 35. 5.0, 1 = FLASH Program",
    "Table of Contents\nMemory............................................................................................................................................................ 5.0, 2 = 55. 6.0, 1 = Data EEPROM Memory",
    "Table of Contents\n.............................................................................................................................................................. 6.0, 2 = 65. 7.0, 1 = 8 X 8 Hardware Multiplier",
    "Table of Contents\n............................................................................................................................................................ 7.0, 2 = 71. 8.0, 1 = Interrupts",
    "Table of Contents\n..................................................................................................................................................................................... 8.0, 2 = 73. 9.0, 1 = I/O Ports",
    "Table of Contents\n...................................................................................................................................................................................... 9.0, 2 = 87. 10.0, 1 = Timer0 Module",
    "Table of Contents\n.......................................................................................................................................................................... 10.0, 2 = 103. 11.0, 1 = Timer1 Module",
    "Table of Contents\n.......................................................................................................................................................................... 11.0, 2 = 107. 12.0, 1 = Timer2 Module",
    "Table of Contents\n.......................................................................................................................................................................... 12.0, 2 = 111. 13.0, 1 = Timer3 Module",
    "Table of Contents\n.......................................................................................................................................................................... 13.0, 2 = 113. 14.0, 1 = Capture/Compare/PWM (CCP) Modules",
    "Table of Contents\n.................................................................................................................................. 14.0, 2 = 117. 15.0, 1 = Master Synchronous Serial Port (MSSP) Module",
    "Table of Contents\n..................................................................................................................... 15.0, 2 = 125. 16.0, 1 = Addressable Universal Synchronous Asynchronous Receiver Transmitter (USART)............................................................... 16.0, 2 = 165. 17.0, 1 = Compatible 10-bit Analog-to-Digital Converter (A/D)",
    "Table of Contents\nModule.................................................................................................... 17.0, 2 = 181. 18.0, 1 = Low Voltage Detect",
    "Table of Contents\n................................................................................................................................................................... 18.0, 2 = 189. 19.0, 1 = Special Features of the",
    "Table of Contents\nCPU..................................................................................................................................................... 19.0, 2 = 195. 20.0, 1 = Instruction Set",
    "Table of Contents\nSummary........................................................................................................................................................... 20.0, 2 = 211. 21.0, 1 = Development",
    "Table of Contents\nSupport................................................................................................................................................................ 21.0, 2 = 253. 22.0, 1 = Electrical Characteristics",
    "Table of Contents\n........................................................................................................................................................... 22.0, 2 = 259. 23.0, 1 = DC and AC Characteristics Graphs and",
    "Table of Contents\nTables........................................................................................................................ 23.0, 2 = 289. 24.0, 1 = Packaging",
    "Table of Contents\nInformation............................................................................................................................................................... 24.0, 2 = 305. Appendix A: Revision",
    "Table of Contents\nHistory............................................................................................................................................................, 1 = Appendix A: Revision",
    "Table of Contents\nHistory............................................................................................................................................................. Appendix A: Revision",
    "Table of Contents\nHistory............................................................................................................................................................, 2 = 313. Appendix B: Device",
    "Table of Contents\nDifferences........................................................................................................................................................, 1 = Appendix B: Device",
    "Table of Contents\nDifferences......................................................................................................................................................... Appendix B: Device",
    "Table of Contents\nDifferences........................................................................................................................................................, 2 = 313. Appendix C: Conversion",
    "Table of Contents\nConsiderations..........................................................................................................................................., 1 = Appendix C: Conversion",
    "Table of Contents\nConsiderations............................................................................................................................................ Appendix C: Conversion",
    "Table of Contents\nConsiderations..........................................................................................................................................., 2 = 314. Appendix D: Migration from Baseline to Enhanced Devices",
    "Table of Contents\n............................................................................................................., 1 = Appendix D: Migration from Baseline to Enhanced Devices .............................................................................................................. Appendix D: Migration from Baseline to Enhanced Devices",
    "Table of Contents\n............................................................................................................., 2 = 314. Appendix E: Migration from Mid-range to Enhanced Devices..........................................................................................................., 1 = Appendix E: Migration from Mid-range to Enhanced",
    "Table of Contents\nDevices............................................................................................................ Appendix E: Migration from Mid-range to Enhanced Devices..........................................................................................................., 2 = 315. Appendix F: Migration from High-end to Enhanced Devices",
    "Table of Contents\n............................................................................................................, 1 = Appendix F: Migration from High-end to Enhanced Devices ............................................................................................................. Appendix F: Migration from High-end to Enhanced Devices",
    "Table of Contents\n............................................................................................................, 2 = 315. Index",
    "Table of Contents\n.................................................................................................................................................................................................., 1 = Index",
    "Table of Contents\n................................................................................................................................................................................................... Index",
    "Table of Contents\n.................................................................................................................................................................................................., 2 = 317. On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................., 1 = On-Line",
    "Table of Contents\nSupport.................................................................................................................................................................................. On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................., 2 = 327. Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................., 1 = Reader",
    "Table of Contents\nResponse............................................................................................................................................................................... Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................., 2 = 328. PIC18FXX2 Product Identification",
    "Table of Contents\nSystem........................................................................................................................................., 1 = PIC18FXX2 Product Identification",
    "Table of Contents\nSystem.......................................................................................................................................... PIC18FXX2 Product Identification",
    "Table of Contents\nSystem........................................................................................................................................., 2 = 329",
    "TO OUR VALUED CUSTOMERS\nIt is our intention to provide our valued customers with the best documentation possible to ensure successful use of your Microchip products. To this end, we will continue to improve our publications to better suit your needs. Our publications will be refined and enhanced as new volumes and updates are introduced.\nIf you have any questions or comments regarding this publication, please contact the Marketing Communications Department via E-mail at docerrors@microchip.com or fax the Reader Response Form in the back of this data sheet to (480) 792-4150. We welcome your feedback.",
    "Most Current Data Sheet\nTo obtain the most up-to-date version of this data sheet, please register at our Worldwide Web site at:\nhttp://www.microchip.com\nYou can determine the version of a data sheet by examining its literature number found on the bottom outside corner of any page. The last character of the literature number is the version number, (e.g., DS30000A is version A of document DS30000).",
    "Errata\nAn errata sheet, describing minor operational differences from the data sheet and recommended workarounds, may exist for current devices. As device/documentation issues become known to us, we will publish an errata sheet. The errata will specify the revision of silicon and revision of document to which it applies.\nTo determine if an errata sheet exists for a particular device, please check with one of the following:\nGLYPH<129> Microchip's Worldwide Web site; http://www.microchip.com\nGLYPH<129> Your local Microchip sales office (see last page)\nWhen contacting a sales office, please specify which device, revision of silicon and data sheet (include literature number) you are using.",
    "Customer Notification System\nRegister on our web site at www.microchip.com to receive the most current information on all of our products.",
    "PIC18FXX2\nNOTES:",
    "1.0 DEVICE OVERVIEW\nThis document contains device specific information for the following devices:\nGLYPH<129> PIC18F242\nGLYPH<129> PIC18F442\nGLYPH<129> PIC18F252\nGLYPH<129> PIC18F452\nThese devices come in 28-pin and 40/44-pin packages. The 28-pin devices do not have a Parallel Slave Port (PSP)  implemented  and  the  number  of  Analog-toDigital (A/D) converter input channels is reduced to 5. An overview of features is shown in Table 1-1.",
    "TABLE 1-1: DEVICE FEATURES\nOperating Frequency, PIC18F242 = DC - 40 MHz. Operating Frequency, PIC18F252 = DC - 40 MHz. Operating Frequency, PIC18F442 = DC - 40 MHz. Operating Frequency, PIC18F452 = DC - 40 MHz. Program Memory (Bytes), PIC18F242 = 16K. Program Memory (Bytes), PIC18F252 = 32K. Program Memory (Bytes), PIC18F442 = 16K. Program Memory (Bytes), PIC18F452 = 32K. Program Memory (Instructions), PIC18F242 = 8192. Program Memory (Instructions), PIC18F252 = 16384. Program Memory (Instructions), PIC18F442 = 8192. Program Memory (Instructions), PIC18F452 = 16384. Data Memory (Bytes), PIC18F242 = 768. Data Memory (Bytes), PIC18F252 = 1536. Data Memory (Bytes), PIC18F442 = 768. Data Memory (Bytes), PIC18F452 = 1536. Data EEPROM Memory (Bytes),",
    "TABLE 1-1: DEVICE FEATURES\nPIC18F242 = 256. Data EEPROM Memory (Bytes), PIC18F252 = 256. Data EEPROM Memory (Bytes), PIC18F442 = 256. Data EEPROM Memory (Bytes), PIC18F452 = 256. Interrupt Sources, PIC18F242 = 17. Interrupt Sources, PIC18F252 = 17. Interrupt Sources, PIC18F442 = 18. Interrupt Sources, PIC18F452 = 18. I/O Ports, PIC18F242 = Ports A, B, C. I/O Ports, PIC18F252 = Ports A, B, C. I/O Ports, PIC18F442 = Ports A, B, C, D, E. I/O Ports, PIC18F452 = Ports A, B, C, D, E. Timers, PIC18F242 = 4. Timers, PIC18F252 = 4. Timers, PIC18F442 = 4. Timers, PIC18F452 = 4. Capture/Compare/PWM Modules, PIC18F242 = 2.",
    "TABLE 1-1: DEVICE FEATURES\nCapture/Compare/PWM Modules, PIC18F252 = 2. Capture/Compare/PWM Modules, PIC18F442 = 2. Capture/Compare/PWM Modules, PIC18F452 = 2. Serial Communications, PIC18F242 = MSSP, Addressable USART. Serial Communications, PIC18F252 = MSSP, Addressable USART. Serial Communications, PIC18F442 = MSSP, Addressable USART. Serial Communications, PIC18F452 = MSSP, Addressable USART. Parallel Communications, PIC18F242 = -. Parallel Communications, PIC18F252 = -. Parallel Communications, PIC18F442 = PSP. Parallel Communications, PIC18F452 = PSP. 10-bit Analog-to-Digital Module, PIC18F242 = 5 input channels. 10-bit Analog-to-Digital Module, PIC18F252 = 5 input channels. 10-bit Analog-to-Digital Module, PIC18F442 = 8 input channels. 10-bit Analog-to-Digital Module, PIC18F452 = 8 input channels. RESETS (and",
    "TABLE 1-1: DEVICE FEATURES\nDelays), PIC18F242 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). RESETS (and Delays), PIC18F252 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). RESETS (and Delays), PIC18F442 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). RESETS (and Delays), PIC18F452 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Programmable Low Voltage Detect, PIC18F242 = Yes. Programmable Low Voltage Detect, PIC18F252 = Yes. Programmable Low Voltage Detect, PIC18F442 = Yes. Programmable Low Voltage Detect, PIC18F452 = Yes. Programmable Brown-out Reset, PIC18F242 = Yes. Programmable Brown-out Reset, PIC18F252 = Yes. Programmable Brown-out Reset, PIC18F442 = Yes. Programmable Brown-out Reset,",
    "TABLE 1-1: DEVICE FEATURES\nPIC18F452 = Yes. Instruction Set, PIC18F242 = 75 Instructions. Instruction Set, PIC18F252 = 75 Instructions. Instruction Set, PIC18F442 = 75 Instructions. Instruction Set, PIC18F452 = 75 Instructions. Packages, PIC18F242 = 28-pin DIP 28-pin SOIC. Packages, PIC18F252 = 28-pin DIP 28-pin SOIC. Packages, PIC18F442 = 40-pin DIP 44-pin PLCC 44-pin TQFP. Packages, PIC18F452 = 40-pin DIP 44-pin PLCC 44-pin TQFP\nThe following  two  figures  are  device  block  diagrams sorted by pin count: 28-pin for Figure 1-1 and 40/44-pin for  Figure 1-2.  The  28-pin  and  40/44-pin  pinouts  are listed in Table 1-2 and Table 1-3, respectively.",
    "FIGURE 1-1: PIC18F2X2 BLOCK DIAGRAM\nNote 1: Optional multiplexing of CCP2 input/output with RB3 is enabled by selection of configuration bit.\n2: The high order bits of the Direct Address for the RAM are from the BSR register (except for the MOVFF instruction).\n3: Many of the general purpose I/O pins are multiplexed with one or more peripheral module functions. The multiplexing combinations are device dependent.",
    "FIGURE 1-2: PIC18F4X2 BLOCK DIAGRAM\nNote\n1: Optional multiplexing of CCP2 input/output with RB3 is enabled by selection of configuration bit.\n2: The high order bits of the Direct Address for the RAM are from the BSR register (except for the MOVFF instruction).\n3: Many of the general purpose I/O pins are multiplexed with one or more peripheral module functions. The multiplexing combinations are device dependent.",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS\nMCLR/VPP, Pin Number.DIP = 1. MCLR/VPP, Pin Number.SOIC = 1. MCLR/VPP, Pin.Type = . MCLR/VPP, Buffer.Type = . MCLR/VPP, Description = Master Clear (input) or high voltage ICSP programming enable pin.. MCLR, Pin Number.DIP = . MCLR, Pin Number.SOIC = . MCLR, Pin.Type = I. MCLR, Buffer.Type = ST. MCLR, Description = Master Clear (Reset) input. This pin is an active low RESET to the device.. VPP, Pin Number.DIP = . VPP, Pin Number.SOIC = . VPP, Pin.Type = I. VPP, Buffer.Type = ST. VPP, Description = High voltage ICSP programming enable pin.. NC, Pin Number.DIP = -. NC, Pin Number.SOIC = -. NC, Pin.Type = -. NC, Buffer.Type = -. NC, Description = These pins should be left unconnected.. OSC1/CLKI,",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS\nPin Number.DIP = 9. OSC1/CLKI, Pin Number.SOIC = 9. OSC1/CLKI, Pin.Type = . OSC1/CLKI, Buffer.Type = . OSC1/CLKI, Description = Oscillator crystal or external clock input.. OSC1, Pin Number.DIP = . OSC1, Pin Number.SOIC = . OSC1, Pin.Type = I. OSC1, Buffer.Type = ST. OSC1, Description = Oscillator crystal input or external clock source input. ST buffer when configured in RC mode, CMOS otherwise. External clock source input. Always associated with. OSC2/CLKO/RA6, Pin Number.DIP = 10. OSC2/CLKO/RA6, Pin Number.SOIC = 10. OSC2/CLKO/RA6, Pin.Type = . OSC2/CLKO/RA6, Buffer.Type = . OSC2/CLKO/RA6, Description = Oscillator crystal or clock output.. OSC2, Pin",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS\nNumber.DIP = . OSC2, Pin Number.SOIC = . OSC2, Pin.Type = O. OSC2, Buffer.Type = -. OSC2, Description = Oscillator crystal output. Connects to crystal or resonator in Crystal Oscillator mode.. CLKO RA6, Pin Number.DIP = . CLKO RA6, Pin Number.SOIC = . CLKO RA6, Pin.Type = O. CLKO RA6, Buffer.Type = -. CLKO RA6, Description = In RC mode, OSC2 pin outputs CLKO which has 1/4 the frequency of OSC1, and denotes the instruction cycle rate.. , Pin Number.DIP = . , Pin Number.SOIC = . , Pin.Type = I/O. , Buffer.Type = TTL. , Description = General Purpose I/O pin.. RA0/AN0, Pin Number.DIP = 2. RA0/AN0, Pin Number.SOIC = 2. RA0/AN0, Pin.Type = . RA0/AN0, Buffer.Type =",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS\n. RA0/AN0, Description = PORTA is a bi-directional I/O port.. RA0 AN0, Pin Number.DIP = . RA0 AN0, Pin Number.SOIC = . RA0 AN0, Pin.Type = I/O I. RA0 AN0, Buffer.Type = TTL Analog. RA0 AN0, Description = Digital I/O. Analog input. RA1/AN1 RA1, Pin Number.DIP = 3. RA1/AN1 RA1, Pin Number.SOIC = 3. RA1/AN1 RA1, Pin.Type = . RA1/AN1 RA1, Buffer.Type = . RA1/AN1 RA1, Description = TTL Analog Digital I/O. Analog input 1.. RA2/AN2/VREF- RA2, Pin Number.DIP = 4. RA2/AN2/VREF- RA2, Pin Number.SOIC = 4. RA2/AN2/VREF- RA2, Pin.Type = I/O. RA2/AN2/VREF- RA2,",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS\nBuffer.Type = TTL. RA2/AN2/VREF- RA2, Description = . AN2, Pin Number.DIP = . AN2, Pin Number.SOIC = . AN2, Pin.Type = I. AN2, Buffer.Type = Analog. AN2, Description = Digital I/O. Analog input 2.. , Pin Number.DIP = . , Pin Number.SOIC = . , Pin.Type = I. , Buffer.Type = Analog. , Description = A/D Reference Voltage (Low) input.. VREF-, Pin Number.DIP = 5. VREF-, Pin Number.SOIC = 5. VREF-, Pin.Type = . VREF-, Buffer.Type = . VREF-, Description = . RA3/AN3/VREF+ RA3, Pin Number.DIP = . RA3/AN3/VREF+ RA3, Pin Number.SOIC = . RA3/AN3/VREF+ RA3, Pin.Type = I/O. RA3/AN3/VREF+ RA3, Buffer.Type =",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS\nTTL. RA3/AN3/VREF+ RA3, Description = Digital I/O.. AN3, Pin Number.DIP = . AN3, Pin Number.SOIC = . AN3, Pin.Type = I. AN3, Buffer.Type = Analog. AN3, Description = Analog input 3.. , Pin Number.DIP = . , Pin Number.SOIC = . , Pin.Type = I. , Buffer.Type = Analog. , Description = A/D Reference Voltage (High) input.. VREF+, Pin Number.DIP = 6. VREF+, Pin Number.SOIC = 6. VREF+, Pin.Type = . VREF+, Buffer.Type = . VREF+, Description = . RA4/T0CKI RA4, Pin Number.DIP = . RA4/T0CKI RA4, Pin Number.SOIC = . RA4/T0CKI RA4, Pin.Type = I/O. RA4/T0CKI RA4, Buffer.Type = . RA4/T0CKI RA4, Description = . T0CKI,",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS\nPin Number.DIP = . T0CKI, Pin Number.SOIC = . T0CKI, Pin.Type = . T0CKI, Buffer.Type = . T0CKI, Description = Digital I/O. Open drain when external clock input.. RA5/AN4/SS/LVDIN, Pin Number.DIP = . RA5/AN4/SS/LVDIN, Pin Number.SOIC = 7. RA5/AN4/SS/LVDIN, Pin.Type = . RA5/AN4/SS/LVDIN, Buffer.Type = ST/OD. RA5/AN4/SS/LVDIN, Description = ST configured as output.. , Pin Number.DIP = . , Pin Number.SOIC = . , Pin.Type = I. , Buffer.Type = . , Description = Timer0. RA5 AN4, Pin Number.DIP = 7. RA5 AN4, Pin Number.SOIC = . RA5 AN4, Pin.Type = I/O I. RA5 AN4, Buffer.Type = TTL Analog. RA5",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS\nAN4, Description = Digital I/O. Analog input 4.. SS, Pin Number.DIP = . SS, Pin Number.SOIC = . SS, Pin.Type = I. SS, Buffer.Type = . SS, Description = . , Pin Number.DIP = . , Pin Number.SOIC = . , Pin.Type = . , Buffer.Type = ST. , Description = SPI Slave Select input.. LVDIN, Pin Number.DIP = . LVDIN, Pin Number.SOIC = . LVDIN, Pin.Type = I. LVDIN, Buffer.Type = Analog. LVDIN, Description = Low Voltage Detect Input.. RA6, Pin Number.DIP = . RA6, Pin Number.SOIC = . RA6, Pin.Type = . RA6, Buffer.Type = . RA6, Description = See the OSC2/CLKO/RA6. , Pin Number.DIP = . , Pin Number.SOIC = . , Pin.Type = . , Buffer.Type = . , Description = pin.",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS\nLegend: TTL = TTL compatible input ST = Schmitt Trigger input with CMOS levels\nO = Output\nOD = Open Drain (no P diode to VDD)\nCMOS = CMOS compatible input or output I = Input P = Power",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRB0/INT0 RB0 INT0 RB1/INT1 RB1 INT1, Pin Number.DIP = 21. RB0/INT0 RB0 INT0 RB1/INT1 RB1 INT1, Pin Number.SOIC = 21. RB0/INT0 RB0 INT0 RB1/INT1 RB1 INT1, Pin Type. = I/O I. RB0/INT0 RB0 INT0 RB1/INT1 RB1 INT1, Buffer Type. = TTL ST. RB0/INT0 RB0 INT0 RB1/INT1 RB1 INT1, Description. = Digital I/O. External Interrupt 0.. , Pin Number.DIP = 22. , Pin Number.SOIC = 22. , Pin Type. = I/O I. , Buffer Type. = TTL ST. , Description. = External Interrupt 1.. RB2/INT2 RB2 INT2, Pin Number.DIP = 23. RB2/INT2 RB2 INT2, Pin Number.SOIC = 23. RB2/INT2 RB2 INT2, Pin Type. =",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nI/O I. RB2/INT2 RB2 INT2, Buffer Type. = TTL ST. RB2/INT2 RB2 INT2, Description. = Digital I/O. External Interrupt 2.. RB3/CCP2 RB3 CCP2, Pin Number.DIP = 24. RB3/CCP2 RB3 CCP2, Pin Number.SOIC = 24. RB3/CCP2 RB3 CCP2, Pin Type. = I/O I/O. RB3/CCP2 RB3 CCP2, Buffer Type. = TTL ST. RB3/CCP2 RB3 CCP2, Description. = Digital I/O. Capture2 input, Compare2 output, PWM2 output.. RB4, Pin Number.DIP = 25. RB4, Pin Number.SOIC = 25. RB4, Pin Type. = I/O. RB4, Buffer Type. = TTL. RB4, Description. = Digital I/O. Interrupt-on-change pin.. RB5/PGM RB5 PGM, Pin",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.DIP = 26. RB5/PGM RB5 PGM, Pin Number.SOIC = 26. RB5/PGM RB5 PGM, Pin Type. = I/O I/O I/O. RB5/PGM RB5 PGM, Buffer Type. = TTL ST. RB5/PGM RB5 PGM, Description. = Digital I/O. Interrupt-on-change pin. Low Voltage ICSP programming enable pin.. RB6/PGC RB6 PGC, Pin Number.DIP = 27. RB6/PGC RB6 PGC, Pin Number.SOIC = 27. RB6/PGC RB6 PGC, Pin Type. = I/O. RB6/PGC RB6 PGC, Buffer Type. = TTL ST. RB6/PGC RB6 PGC, Description. = Digital I/O. Interrupt-on-change pin. In-Circuit Debugger and ICSP programming clock pin.. RB7/PGD RB7 PGD, Pin Number.DIP = 28. RB7/PGD RB7",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nPGD, Pin Number.SOIC = 28. RB7/PGD RB7 PGD, Pin Type. = I/O. RB7/PGD RB7 PGD, Buffer Type. = TTL. RB7/PGD RB7 PGD, Description. = Digital I/O. Interrupt-on-change pin.. , Pin Number.DIP = . , Pin Number.SOIC = . , Pin Type. = I/O. , Buffer Type. = ST. , Description. = In-Circuit Debugger and ICSP programming data pin.\nLegend: TTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels O = Output OD = Open Drain (no P diode to VDD)\nCMOS = CMOS compatible input or output I = Input\nP = Power",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC0/T1OSO/T1CKI, Pin Number.DIP = 11. RC0/T1OSO/T1CKI, Pin Number.SOIC = 11. RC0/T1OSO/T1CKI, Pin.Type = I/O. RC0/T1OSO/T1CKI, Buffer.Type = ST. RC0/T1OSO/T1CKI, Description = Digital I/O.. RC0 T1OSO, Pin Number.DIP = . RC0 T1OSO, Pin Number.SOIC = . RC0 T1OSO, Pin.Type = O. RC0 T1OSO, Buffer.Type = -. RC0 T1OSO, Description = Timer1 oscillator output.. T1CKI, Pin Number.DIP = . T1CKI, Pin Number.SOIC = . T1CKI, Pin.Type = I. T1CKI, Buffer.Type = ST. T1CKI, Description = Timer1/Timer3 external clock input.. RC1/T1OSI/CCP2, Pin Number.DIP = 12.",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC1/T1OSI/CCP2, Pin Number.SOIC = 12. RC1/T1OSI/CCP2, Pin.Type = . RC1/T1OSI/CCP2, Buffer.Type = . RC1/T1OSI/CCP2, Description = . RC1, Pin Number.DIP = . RC1, Pin Number.SOIC = . RC1, Pin.Type = I/O. RC1, Buffer.Type = ST. RC1, Description = Digital I/O.. T1OSI, Pin Number.DIP = . T1OSI, Pin Number.SOIC = . T1OSI, Pin.Type = I. T1OSI, Buffer.Type = CMOS. T1OSI, Description = Timer1 oscillator input.. CCP2, Pin Number.DIP = . CCP2, Pin Number.SOIC = . CCP2, Pin.Type = I/O. CCP2, Buffer.Type = ST. CCP2, Description = Capture2 input, Compare2 output, PWM2 output..",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC2/CCP1, Pin Number.DIP = 13. RC2/CCP1, Pin Number.SOIC = 13. RC2/CCP1, Pin.Type = . RC2/CCP1, Buffer.Type = . RC2/CCP1, Description = . RC2, Pin Number.DIP = . RC2, Pin Number.SOIC = . RC2, Pin.Type = I/O. RC2, Buffer.Type = ST. RC2, Description = Digital I/O.. CCP1, Pin Number.DIP = . CCP1, Pin Number.SOIC = . CCP1, Pin.Type = I/O. CCP1, Buffer.Type = ST. CCP1, Description = Capture1 input/Compare1 output/PWM1 output.. RC3/SCK/SCL, Pin Number.DIP = 14. RC3/SCK/SCL, Pin Number.SOIC = 14. RC3/SCK/SCL, Pin.Type = . RC3/SCK/SCL, Buffer.Type",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= . RC3/SCK/SCL, Description = . RC3, Pin Number.DIP = . RC3, Pin Number.SOIC = . RC3, Pin.Type = I/O. RC3, Buffer.Type = ST. RC3, Description = Digital I/O.. SCK, Pin Number.DIP = . SCK, Pin Number.SOIC = . SCK, Pin.Type = I/O. SCK, Buffer.Type = ST. SCK, Description = Synchronous serial clock input/output for SPI mode.. SCL, Pin Number.DIP = . SCL, Pin Number.SOIC = . SCL, Pin.Type = I/O. SCL, Buffer.Type = ST. SCL, Description = Synchronous serial clock input/output for I 2 C mode. RC4/SDI/SDA, Pin Number.DIP = 15. RC4/SDI/SDA, Pin Number.SOIC = 15. RC4/SDI/SDA, Pin.Type = .",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC4/SDI/SDA, Buffer.Type = . RC4/SDI/SDA, Description = . RC4, Pin Number.DIP = . RC4, Pin Number.SOIC = . RC4, Pin.Type = I/O. RC4, Buffer.Type = ST. RC4, Description = Digital I/O.. SDI, Pin Number.DIP = . SDI, Pin Number.SOIC = . SDI, Pin.Type = I. SDI, Buffer.Type = ST. SDI, Description = SPI Data In.. SDA, Pin Number.DIP = . SDA, Pin Number.SOIC = . SDA, Pin.Type = I/O. SDA, Buffer.Type = ST. SDA, Description = I 2 C Data I/O.. RC5/SDO, Pin Number.DIP = 16. RC5/SDO, Pin Number.SOIC = 16. RC5/SDO, Pin.Type = . RC5/SDO, Buffer.Type = . RC5/SDO, Description = .",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC5, Pin Number.DIP = . RC5, Pin Number.SOIC = . RC5, Pin.Type = I/O. RC5, Buffer.Type = ST. RC5, Description = Digital I/O.. SDO, Pin Number.DIP = . SDO, Pin Number.SOIC = . SDO, Pin.Type = O. SDO, Buffer.Type = -. SDO, Description = SPI Data Out.. RC6/TX/CK, Pin Number.DIP = 17. RC6/TX/CK, Pin Number.SOIC = 17. RC6/TX/CK, Pin.Type = . RC6/TX/CK, Buffer.Type = . RC6/TX/CK, Description = . RC6, Pin Number.DIP = . RC6, Pin Number.SOIC = . RC6, Pin.Type = I/O. RC6, Buffer.Type = ST. RC6, Description = Digital I/O.. TX, Pin Number.DIP = . TX, Pin Number.SOIC = . TX, Pin.Type = O.",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nTX, Buffer.Type = -. TX, Description = USART Asynchronous Transmit.. CK, Pin Number.DIP = . CK, Pin Number.SOIC = . CK, Pin.Type = I/O. CK, Buffer.Type = ST. CK, Description = USART Synchronous Clock (see related RX/DT).. RC7/RX/DT, Pin Number.DIP = 18. RC7/RX/DT, Pin Number.SOIC = 18. RC7/RX/DT, Pin.Type = . RC7/RX/DT, Buffer.Type = . RC7/RX/DT, Description = . RC7, Pin Number.DIP = . RC7, Pin Number.SOIC = . RC7, Pin.Type = I/O. RC7, Buffer.Type = ST. RC7, Description = Digital I/O.. RX, Pin Number.DIP = . RX, Pin Number.SOIC = . RX, Pin.Type = I. RX, Buffer.Type = ST. RX,",
    "TABLE 1-2: PIC18F2X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nDescription = USART Asynchronous Receive.. DT, Pin Number.DIP = . DT, Pin Number.SOIC = . DT, Pin.Type = I/O. DT, Buffer.Type = ST. DT, Description = USART Synchronous Data (see related TX/CK).. VSS, Pin Number.DIP = 8, 19. VSS, Pin Number.SOIC = 8, 19. VSS, Pin.Type = P. VSS, Buffer.Type = -. VSS, Description = Ground reference for logic and I/O pins.. VDD, Pin Number.DIP = 20. VDD, Pin Number.SOIC = 20. VDD, Pin.Type = P. VDD, Buffer.Type = -. VDD, Description = Positive supply for logic and I/O pins.\nLegend: TTL = TTL compatible input ST = Schmitt Trigger input with CMOS levels O = Output OD = Open Drain (no P diode to VDD)\nCMOS = CMOS compatible input or output I = Input\nP = Power",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS\nMCLR/VPP MCLR, Pin Number.DIP = 1. MCLR/VPP MCLR, Pin Number.PLCC = 2. MCLR/VPP MCLR, Pin Number.TQFP = 18. MCLR/VPP MCLR, Pin.Type = I. MCLR/VPP MCLR, Buffer.Type = ST. MCLR/VPP MCLR, Description = Master Clear (input) or high voltage ICSP programming enable pin. Master Clear (Reset) input. This pin is an. , Pin Number.DIP = . , Pin Number.PLCC = . , Pin Number.TQFP = . , Pin.Type = . , Buffer.Type = . , Description = active low RESET to the device.. VPP, Pin Number.DIP = . VPP, Pin Number.PLCC = . VPP, Pin Number.TQFP = . VPP, Pin.Type = I. VPP, Buffer.Type = ST. VPP, Description = High voltage ICSP programming enable pin.. NC, Pin Number.DIP = -. NC, Pin Number.PLCC = . NC, Pin",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS\nNumber.TQFP = . NC, Pin.Type = -. NC, Buffer.Type = -. NC, Description = These pins should be left unconnected.. OSC1/CLKI OSC1, Pin Number.DIP = 13. OSC1/CLKI OSC1, Pin Number.PLCC = 14. OSC1/CLKI OSC1, Pin Number.TQFP = 30. OSC1/CLKI OSC1, Pin.Type = I. OSC1/CLKI OSC1, Buffer.Type = ST. OSC1/CLKI OSC1, Description = Oscillator crystal or external clock input. Oscillator crystal input or external clock source input. ST buffer when configured in RC mode, CMOS otherwise.. CLKI, Pin Number.DIP = . CLKI, Pin Number.PLCC = . CLKI, Pin Number.TQFP = . CLKI, Pin.Type = I. CLKI, Buffer.Type = CMOS. CLKI, Description = External clock source input. Always associated with pin function OSC1. (See related",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS\nOSC1/CLKI, OSC2/CLKO pins.). OSC2/CLKO/RA6, Pin Number.DIP = 14. OSC2/CLKO/RA6, Pin Number.PLCC = 15. OSC2/CLKO/RA6, Pin Number.TQFP = 31. OSC2/CLKO/RA6, Pin.Type = . OSC2/CLKO/RA6, Buffer.Type = . OSC2/CLKO/RA6, Description = Oscillator crystal or clock output.. OSC2 CLKO, Pin Number.DIP = . OSC2 CLKO, Pin Number.PLCC = . OSC2 CLKO, Pin Number.TQFP = . OSC2 CLKO, Pin.Type = O O. OSC2 CLKO, Buffer.Type = - -. OSC2 CLKO, Description = Oscillator crystal output. Connects to crystal or resonator in Crystal Oscillator mode. In RC mode, OSC2 pin outputs CLKO,. , Pin Number.DIP = . , Pin",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS\nNumber.PLCC = . , Pin Number.TQFP = . , Pin.Type = . , Buffer.Type = . , Description = which has 1/4 the frequency of OSC1 and denotes the instruction cycle rate.. RA6, Pin Number.DIP = . RA6, Pin Number.PLCC = . RA6, Pin Number.TQFP = . RA6, Pin.Type = I/O. RA6, Buffer.Type = TTL. RA6, Description = General Purpose I/O pin.. RA0/AN0 RA0, Pin Number.DIP = 2. RA0/AN0 RA0, Pin Number.PLCC = 3. RA0/AN0 RA0, Pin Number.TQFP = 19. RA0/AN0 RA0, Pin.Type = I/O. RA0/AN0 RA0, Buffer.Type = TTL Analog. RA0/AN0 RA0, Description = Digital I/O.. AN0 RA1/AN1 RA1, Pin Number.DIP = . AN0 RA1/AN1 RA1, Pin Number.PLCC = .",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS\nAN0 RA1/AN1 RA1, Pin Number.TQFP = . AN0 RA1/AN1 RA1, Pin.Type = I. AN0 RA1/AN1 RA1, Buffer.Type = . AN0 RA1/AN1 RA1, Description = Analog input 0.. , Pin Number.DIP = 3. , Pin Number.PLCC = 4. , Pin Number.TQFP = 20. , Pin.Type = . , Buffer.Type = TTL. , Description = Digital I/O.. AN1 RA2, Pin Number.DIP = . AN1 RA2, Pin Number.PLCC = . AN1 RA2, Pin Number.TQFP = . AN1 RA2, Pin.Type = I/O I. AN1 RA2, Buffer.Type = Analog. AN1 RA2, Description = Analog input 1.. RA2/AN2/VREF-, Pin Number.DIP = 4. RA2/AN2/VREF-, Pin Number.PLCC = 5. RA2/AN2/VREF-, Pin Number.TQFP = 21.",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS\nRA2/AN2/VREF-, Pin.Type = . RA2/AN2/VREF-, Buffer.Type = TTL. RA2/AN2/VREF-, Description = Digital I/O.. AN2, Pin Number.DIP = . AN2, Pin Number.PLCC = . AN2, Pin Number.TQFP = . AN2, Pin.Type = I/O I. AN2, Buffer.Type = Analog. AN2, Description = . VREF-, Pin Number.DIP = . VREF-, Pin Number.PLCC = . VREF-, Pin Number.TQFP = . VREF-, Pin.Type = I. VREF-, Buffer.Type = Analog. VREF-, Description = Analog input 2. A/D Reference Voltage (Low) input.. RA3/AN3/VREF+, Pin Number.DIP = 5. RA3/AN3/VREF+, Pin Number.PLCC = 6. RA3/AN3/VREF+, Pin Number.TQFP = 22.",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS\nRA3/AN3/VREF+, Pin.Type = . RA3/AN3/VREF+, Buffer.Type = TTL. RA3/AN3/VREF+, Description = Digital I/O.. RA3 AN3, Pin Number.DIP = . RA3 AN3, Pin Number.PLCC = . RA3 AN3, Pin Number.TQFP = . RA3 AN3, Pin.Type = I/O I. RA3 AN3, Buffer.Type = Analog. RA3 AN3, Description = Analog input 3.. VREF+, Pin Number.DIP = . VREF+, Pin Number.PLCC = . VREF+, Pin Number.TQFP = . VREF+, Pin.Type = I. VREF+, Buffer.Type = Analog. VREF+, Description = A/D Reference Voltage (High) input.. RA4/T0CKI RA4 T0CKI, Pin Number.DIP = 6. RA4/T0CKI RA4 T0CKI, Pin Number.PLCC = 7. RA4/T0CKI RA4",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS\nT0CKI, Pin Number.TQFP = 23. RA4/T0CKI RA4 T0CKI, Pin.Type = I/O I. RA4/T0CKI RA4 T0CKI, Buffer.Type = ST/OD ST. RA4/T0CKI RA4 T0CKI, Description = Digital I/O. Open drain when configured as output. Timer0 external clock input.. RA5/AN4/SS/LVDIN, Pin Number.DIP = 7. RA5/AN4/SS/LVDIN, Pin Number.PLCC = 8. RA5/AN4/SS/LVDIN, Pin Number.TQFP = 24. RA5/AN4/SS/LVDIN, Pin.Type = I/O. RA5/AN4/SS/LVDIN, Buffer.Type = TTL. RA5/AN4/SS/LVDIN, Description = Digital I/O.. RA5 AN4, Pin Number.DIP = . RA5 AN4, Pin Number.PLCC = . RA5 AN4, Pin Number.TQFP",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS\n= . RA5 AN4, Pin.Type = I. RA5 AN4, Buffer.Type = Analog. RA5 AN4, Description = Analog input 4.. SS, Pin Number.DIP = . SS, Pin Number.PLCC = . SS, Pin Number.TQFP = . SS, Pin.Type = I. SS, Buffer.Type = ST. SS, Description = SPI Slave Select input.. LVDIN, Pin Number.DIP = . LVDIN, Pin Number.PLCC = . LVDIN, Pin Number.TQFP = . LVDIN, Pin.Type = I. LVDIN, Buffer.Type = Analog. LVDIN, Description = Low Voltage Detect Input.. RA6, Pin Number.DIP = . RA6, Pin Number.PLCC = . RA6, Pin Number.TQFP = . RA6, Pin.Type = . RA6, Buffer.Type = . RA6, Description = (See the OSC2/CLKO/RA6. , Pin Number.DIP = . , Pin Number.PLCC = . , Pin Number.TQFP = .",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS\n, Pin.Type = . , Buffer.Type = . , Description = pin.)\nLegend: TTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels\nO = Output\nOD = Open Drain (no P diode to VDD)\nCMOS = CMOS compatible input or output I = Input\nP = Power",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRB0/INT0 RB0 INT0, Pin Number.DIP = 33. RB0/INT0 RB0 INT0, Pin Number.PLCC = 36. RB0/INT0 RB0 INT0, Pin Number.TQFP = 8. RB0/INT0 RB0 INT0, Pin Type. = I/O I. RB0/INT0 RB0 INT0, Buffer.Type = TTL ST. RB0/INT0 RB0 INT0, Description. = Digital I/O. External Interrupt 0.. RB1/INT1 RB1 INT1, Pin Number.DIP = 34. RB1/INT1 RB1 INT1, Pin Number.PLCC = 37. RB1/INT1 RB1 INT1, Pin Number.TQFP = 9. RB1/INT1 RB1 INT1, Pin Type. = I/O I. RB1/INT1 RB1 INT1, Buffer.Type = TTL ST. RB1/INT1 RB1 INT1, Description. = External Interrupt 1.. RB2/INT2 RB2 INT2, Pin Number.DIP =",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n35. RB2/INT2 RB2 INT2, Pin Number.PLCC = 38. RB2/INT2 RB2 INT2, Pin Number.TQFP = 10. RB2/INT2 RB2 INT2, Pin Type. = I/O I. RB2/INT2 RB2 INT2, Buffer.Type = TTL ST. RB2/INT2 RB2 INT2, Description. = Digital I/O. External Interrupt 2.. RB3/CCP2 RB3 CCP2, Pin Number.DIP = 36. RB3/CCP2 RB3 CCP2, Pin Number.PLCC = 39. RB3/CCP2 RB3 CCP2, Pin Number.TQFP = 11. RB3/CCP2 RB3 CCP2, Pin Type. = I/O I/O. RB3/CCP2 RB3 CCP2, Buffer.Type = TTL ST. RB3/CCP2 RB3 CCP2, Description. = Digital I/O. Capture2 input, Compare2 output, PWM2 output..",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRB4, Pin Number.DIP = 37. RB4, Pin Number.PLCC = 41. RB4, Pin Number.TQFP = 14. RB4, Pin Type. = I/O. RB4, Buffer.Type = TTL. RB4, Description. = Digital I/O. Interrupt-on-change pin.. RB5/PGM RB5 PGM, Pin Number.DIP = 38. RB5/PGM RB5 PGM, Pin Number.PLCC = 42. RB5/PGM RB5 PGM, Pin Number.TQFP = 15. RB5/PGM RB5 PGM, Pin Type. = I/O I/O. RB5/PGM RB5 PGM, Buffer.Type = TTL ST. RB5/PGM RB5 PGM, Description. = Digital I/O. Interrupt-on-change pin. Low Voltage ICSP programming enable pin.. RB6/PGC RB6 PGC, Pin Number.DIP = 39. RB6/PGC RB6 PGC, Pin Number.PLCC = 43.",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRB6/PGC RB6 PGC, Pin Number.TQFP = 16. RB6/PGC RB6 PGC, Pin Type. = I/O I/O. RB6/PGC RB6 PGC, Buffer.Type = TTL ST. RB6/PGC RB6 PGC, Description. = Digital I/O. Interrupt-on-change pin. In-Circuit Debugger and ICSP programming clock pin.. RB7/PGD RB7 PGD, Pin Number.DIP = 40. RB7/PGD RB7 PGD, Pin Number.PLCC = 44. RB7/PGD RB7 PGD, Pin Number.TQFP = 17. RB7/PGD RB7 PGD, Pin Type. = I/O I/O. RB7/PGD RB7 PGD, Buffer.Type = TTL ST. RB7/PGD RB7 PGD, Description. = Digital I/O. Interrupt-on-change pin. In-Circuit Debugger and ICSP programming data pin.\nLegend: TTL = TTL compatible input",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nST = Schmitt Trigger input with CMOS levels\nO = Output\nOD = Open Drain (no P diode to VDD)\nCMOS = CMOS compatible input or output I = Input\nP = Power",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC0/T1OSO/T1CKI RC0 T1OSO T1CKI, Pin Number.DIP = 15. RC0/T1OSO/T1CKI RC0 T1OSO T1CKI, Pin Number.PLCC = 16. RC0/T1OSO/T1CKI RC0 T1OSO T1CKI, Pin Number.TQFP = 32. RC0/T1OSO/T1CKI RC0 T1OSO T1CKI, Pin.Type = I/O O I. RC0/T1OSO/T1CKI RC0 T1OSO T1CKI, Buffer.Type = ST - ST. RC0/T1OSO/T1CKI RC0 T1OSO T1CKI, Description = Digital I/O. Timer1 oscillator output. Timer1/Timer3 external clock input.. RC1/T1OSI/CCP2 RC1 T1OSI, Pin Number.DIP = 16. RC1/T1OSI/CCP2 RC1 T1OSI, Pin Number.PLCC = 18.",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC1/T1OSI/CCP2 RC1 T1OSI, Pin Number.TQFP = 35. RC1/T1OSI/CCP2 RC1 T1OSI, Pin.Type = I/O I I/O. RC1/T1OSI/CCP2 RC1 T1OSI, Buffer.Type = ST CMOS. RC1/T1OSI/CCP2 RC1 T1OSI, Description = Digital I/O. Timer1 oscillator input. Capture2 input, Compare2 output, PWM2 output.. RC2/CCP1 RC2 CCP1, Pin Number.DIP = 17. RC2/CCP1 RC2 CCP1, Pin Number.PLCC = 19. RC2/CCP1 RC2 CCP1, Pin Number.TQFP = 36. RC2/CCP1 RC2 CCP1, Pin.Type = I/O I/O. RC2/CCP1 RC2 CCP1, Buffer.Type = ST ST. RC2/CCP1 RC2 CCP1, Description",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= Digital I/O. Capture1 input/Compare1 output/PWM1 output.. RC3/SCK/SCL RC3 SCK, Pin Number.DIP = 18. RC3/SCK/SCL RC3 SCK, Pin Number.PLCC = 20. RC3/SCK/SCL RC3 SCK, Pin Number.TQFP = 37. RC3/SCK/SCL RC3 SCK, Pin.Type = I/O I/O. RC3/SCK/SCL RC3 SCK, Buffer.Type = ST ST. RC3/SCK/SCL RC3 SCK, Description = Digital I/O. Synchronous serial clock input/output for SPI mode.. SCL RC4/SDI/SDA RC4, Pin Number.DIP = 23. SCL RC4/SDI/SDA RC4, Pin Number.PLCC = 25. SCL RC4/SDI/SDA RC4, Pin Number.TQFP = 42. SCL RC4/SDI/SDA",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC4, Pin.Type = I/O I/O I I/O. SCL RC4/SDI/SDA RC4, Buffer.Type = ST ST ST. SCL RC4/SDI/SDA RC4, Description = Synchronous serial clock input/output for I 2 C mode. Digital I/O.. RC5/SDO RC5 SDO, Pin Number.DIP = 24. RC5/SDO RC5 SDO, Pin Number.PLCC = 26. RC5/SDO RC5 SDO, Pin Number.TQFP = 43. RC5/SDO RC5 SDO, Pin.Type = I/O O. RC5/SDO RC5 SDO, Buffer.Type = ST -. RC5/SDO RC5 SDO, Description = Digital I/O. SPI Data Out.. RC6/TX/CK RC6 TX, Pin Number.DIP = 25. RC6/TX/CK RC6 TX, Pin Number.PLCC = 27. RC6/TX/CK RC6 TX, Pin",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.TQFP = 44. RC6/TX/CK RC6 TX, Pin.Type = I/O O. RC6/TX/CK RC6 TX, Buffer.Type = ST -. RC6/TX/CK RC6 TX, Description = Digital I/O. USART Asynchronous Transmit.. CK RC7/RX/DT RC7, Pin Number.DIP = 26. CK RC7/RX/DT RC7, Pin Number.PLCC = 29. CK RC7/RX/DT RC7, Pin Number.TQFP = 1. CK RC7/RX/DT RC7, Pin.Type = I/O. CK RC7/RX/DT RC7, Buffer.Type = ST. CK RC7/RX/DT RC7, Description = USART Synchronous Clock (see related RX/DT). Digital I/O.. RX, Pin Number.DIP = . RX, Pin Number.PLCC = . RX, Pin Number.TQFP = . RX, Pin.Type = I/O",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nI I/O. RX, Buffer.Type = ST ST ST. RX, Description = USART Asynchronous Receive. USART Synchronous Data (see related TX/CK).\nLegend: TTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels O = Output OD = Open Drain (no P diode to VDD)\nCMOS = CMOS compatible input or output\nI = Input\nP = Power",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD0/PSP0, Pin Number.DIP = 19. RD0/PSP0, Pin Number.PLCC = 21. RD0/PSP0, Pin Number.TQFP = 38. RD0/PSP0, Pin.Type = I/O. RD0/PSP0, Buffer.Type = ST TTL. RD0/PSP0, Description = is enabled. Digital I/O. Parallel Slave Port Data.. RD1/PSP1, Pin Number.DIP = 20. RD1/PSP1, Pin Number.PLCC = 22. RD1/PSP1, Pin Number.TQFP = 39. RD1/PSP1, Pin.Type = I/O. RD1/PSP1, Buffer.Type = ST TTL. RD1/PSP1, Description = Digital I/O.. RD2/PSP2, Pin Number.DIP = 21. RD2/PSP2, Pin Number.PLCC = 23. RD2/PSP2, Pin Number.TQFP = 40.",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD2/PSP2, Pin.Type = I/O. RD2/PSP2, Buffer.Type = ST TTL. RD2/PSP2, Description = Digital I/O. Parallel Slave. RD3/PSP3, Pin Number.DIP = 22. RD3/PSP3, Pin Number.PLCC = 24. RD3/PSP3, Pin Number.TQFP = 41. RD3/PSP3, Pin.Type = I/O. RD3/PSP3, Buffer.Type = ST TTL. RD3/PSP3, Description = Digital I/O. Parallel Slave Port Data.. RD4/PSP4, Pin Number.DIP = 27. RD4/PSP4, Pin Number.PLCC = 30. RD4/PSP4, Pin Number.TQFP = 2. RD4/PSP4, Pin.Type = I/O. RD4/PSP4, Buffer.Type = ST TTL. RD4/PSP4, Description = Digital I/O. Parallel Slave Port.",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD5/PSP5, Pin Number.DIP = 28. RD5/PSP5, Pin Number.PLCC = 31. RD5/PSP5, Pin Number.TQFP = 3. RD5/PSP5, Pin.Type = I/O. RD5/PSP5, Buffer.Type = ST TTL. RD5/PSP5, Description = Digital I/O. Parallel Slave Port. RD6/PSP6, Pin Number.DIP = 29. RD6/PSP6, Pin Number.PLCC = 32. RD6/PSP6, Pin Number.TQFP = 4. RD6/PSP6, Pin.Type = I/O. RD6/PSP6, Buffer.Type = ST TTL. RD6/PSP6, Description = Digital I/O. Parallel Slave Port. RD7/PSP7, Pin Number.DIP = 30. RD7/PSP7, Pin Number.PLCC = 33. RD7/PSP7, Pin Number.TQFP = 5. RD7/PSP7,",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nPin.Type = I/O. RD7/PSP7, Buffer.Type = ST TTL. RD7/PSP7, Description = Digital I/O. Parallel Slave Port Data.. RE0/RD/AN5, Pin Number.DIP = 8. RE0/RD/AN5, Pin Number.PLCC = 9. RE0/RD/AN5, Pin Number.TQFP = 25. RE0/RD/AN5, Pin.Type = I/O. RE0/RD/AN5, Buffer.Type = . RE0/RD/AN5, Description = PORTE is a bi-directional I/O port.. AN5 RE1/WR/AN6 RE1, Pin Number.DIP = 9. AN5 RE1/WR/AN6 RE1, Pin Number.PLCC = 10. AN5 RE1/WR/AN6 RE1, Pin Number.TQFP = 26. AN5 RE1/WR/AN6 RE1, Pin.Type = I/O. AN5 RE1/WR/AN6 RE1, Buffer.Type =",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nAnalog ST. AN5 RE1/WR/AN6 RE1, Description = Analog input 5. Digital I/O.. AN6 RE2/CS/AN7 RE2 CS, Pin Number.DIP = 10. AN6 RE2/CS/AN7 RE2 CS, Pin Number.PLCC = 11. AN6 RE2/CS/AN7 RE2 CS, Pin Number.TQFP = 27. AN6 RE2/CS/AN7 RE2 CS, Pin.Type = I/O. AN6 RE2/CS/AN7 RE2 CS, Buffer.Type = Analog ST TTL. AN6 RE2/CS/AN7 RE2 CS, Description = (see CS and RD pins). Analog input 6.. AN7, Pin Number.DIP = 12, 31. AN7, Pin Number.PLCC = 13, 34. AN7, Pin Number.TQFP = 6, 29. AN7, Pin.Type = P. AN7, Buffer.Type = Analog -. AN7, Description = Analog input 7. Ground reference for logic and I/O",
    "TABLE 1-3: PIC18F4X2 PINOUT I/O DESCRIPTIONS  (CONTINUED)\npins.. VSS, Pin Number.DIP = . VSS, Pin Number.PLCC = 12, 35. VSS, Pin Number.TQFP = 7, 28. VSS, Pin.Type = . VSS, Buffer.Type = . VSS, Description = . VDD, Pin Number.DIP = 11, 32. VDD, Pin Number.PLCC = . VDD, Pin Number.TQFP = . VDD, Pin.Type = P. VDD, Buffer.Type = -. VDD, Description = Positive supply for logic and I/O pins.\nLegend: TTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI = Input P = Power\nO = Output\nOD = Open Drain (no P diode to VDD)",
    "2.1 Oscillator Types\nThe  PIC18FXX2  can  be  operated  in  eight  different Oscillator modes. The user can program three configuration bits (FOSC2, FOSC1, and FOSC0) to select one of these eight modes:\n1. LP\nLow Power Crystal\n2. XT\nCrystal/Resonator\n3. HS\nHigh Speed Crystal/Resonator\n4. HS + PLL\nHigh Speed Crystal/Resonator\nwith PLL enabled\n5. RC\nExternal Resistor/Capacitor\n6. RCIO\nExternal Resistor/Capacitor with I/O pin enabled\n7. EC\nExternal Clock\n8. ECIO\nExternal Clock with I/O pin enabled",
    "2.2 Crystal Oscillator/Ceramic Resonators\nIn XT, LP, HS or HS+PLL Oscillator modes, a crystal or ceramic  resonator  is  connected  to  the  OSC1  and OSC2 pins to establish  oscillation.  Figure 2-1  shows the pin connections.\nThe PIC18FXX2 oscillator design requires the use of a parallel cut crystal.",
    "Note:\nUse of a series cut crystal may give a fre- quency  out  of  the  crystal  manufacturers specifications.",
    "FIGURE 2-1:\nCRYSTAL/CERAMIC RESONATOR OPERATION (HS, XT OR LP CONFIGURATION)\nNote 1: See Table 2-1 and Table 2-2 for recommended values of C1 and C2.\n2: A series resistor (RS) may be required for AT strip cut crystals.\n3: RF varies with the Oscillator mode chosen.",
    "Ranges Tested:\nXT, Freq = 455 kHz 2.0 MHz 4.0 MHz. XT, C1 = 68 - 100 pF 15 - 68 pF 15 - 68 pF. XT, C2 = 68 - 100 pF 15 - 68 pF 15 - 68 pF. HS, Freq = 8.0 MHz 16.0 MHz. HS, C1 = 10 - 68 pF 10 - 22 pF. HS, C2 = 10 - 68 pF 10 - 22 pF\nThese values are for design guidance only.\nSee notes following this table.",
    "Ranges Tested:\n455 kHz, Resonators Used: = Panasonic EFO-A455K04B. 455 kHz, Resonators Used: = \u00b1 0.3%. 2.0 MHz, Resonators Used: = Murata Erie CSA2.00MG. 2.0 MHz, Resonators Used: = \u00b1 0.5%. 4.0 MHz, Resonators Used: = Murata Erie CSA4.00MG. 4.0 MHz, Resonators Used: = \u00b1 0.5%. 8.0 MHz, Resonators Used: = Murata Erie CSA8.00MT. 8.0 MHz, Resonators Used: = \u00b1 0.5%. 16.0 MHz, Resonators Used: = Murata Erie CSA16.00MX. 16.0 MHz, Resonators Used: = \u00b1 0.5%. All resonators used did not have built-in capacitors., Resonators Used: = All resonators used did not have built-in capacitors.. All resonators used did not have built-in capacitors., Resonators Used: = All resonators used",
    "Ranges Tested:\ndid not have built-in capacitors.\nNote 1: Higher capacitance increases the stability of  the  oscillator,  but  also  increases  the start-up time.\n2: When operating below 3V VDD, or when using  certain  ceramic  resonators  at  any voltage,  it may  be  necessary  to  use high-gain HS mode, try a lower frequency resonator, or switch to a crystal oscillator.\n3: Since each resonator/crystal has its own characteristics, the user should consult the resonator/crystal manufacturer for appropriate  values  of  external  components,  or verify oscillator performance.",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nLP, Ranges Tested:.Freq = 32.0 kHz. LP, Ranges Tested:.C1 = 33 pF. LP, Ranges Tested:.C2 = 33 pF. LP, Ranges Tested:.Freq = 200 kHz. LP, Ranges Tested:.C1 = 15 pF. LP, Ranges Tested:.C2 = 15 pF. XT, Ranges Tested:.Freq = 200 kHz. XT, Ranges Tested:.C1 = 22-68 pF. XT, Ranges Tested:.C2 = 22-68 pF. XT, Ranges Tested:.Freq = 1.0 MHz. XT, Ranges Tested:.C1 = 15 pF. XT, Ranges Tested:.C2 = 15 pF. XT, Ranges Tested:.Freq = 4.0 MHz. XT, Ranges Tested:.C1 = 15 pF. XT, Ranges Tested:.C2 = 15 pF. HS, Ranges Tested:.Freq = 4.0 MHz. HS, Ranges Tested:.C1 = 15 pF. HS, Ranges Tested:.C2 = 15",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\npF. HS, Ranges Tested:.Freq = 8.0 MHz. HS, Ranges Tested:.C1 = 15-33 pF. HS, Ranges Tested:.C2 = 15-33 pF. HS, Ranges Tested:.Freq = 20.0 MHz. HS, Ranges Tested:.C1 = 15-33 pF. HS, Ranges Tested:.C2 = 15-33 pF. HS, Ranges Tested:.Freq = 25.0 MHz. HS, Ranges Tested:.C1 = 15-33 pF. HS, Ranges Tested:.C2 = 15-33 pF\nThese values are for design guidance only. See notes following this table.",
    "Crystals Used\n32.0 kHz, 1 = Epson C-001R32.768K-A. 32.0 kHz, 2 = - 20 PPM. 200 kHz, 1 = STD XTL 200.000KHz. 200 kHz, 2 = - 20 PPM. 1.0 MHz, 1 = ECS ECS-10-13-1. 1.0 MHz, 2 = - 50 PPM. 4.0 MHz, 1 = ECS ECS-40-20-1. 4.0 MHz, 2 = - 50 PPM. 8.0 MHz, 1 = Epson CA-301 8.000M-C. 8.0 MHz, 2 = - 30 PPM. 20.0 MHz, 1 = Epson CA-301 20.000M-C. 20.0 MHz, 2 = - 30 PPM",
    "Crystals Used\nNote 1: Higher capacitance increases the stability of  the  oscillator,  but  also  increases  the start-up time.\n2: Rs may be required in HS mode, as well as XT mode, to avoid overdriving crystals with low drive level specification.\n3: Since each resonator/crystal has its own characteristics, the user should consult the resonator/crystal manufacturer for appropriate values of external components., or verify oscillator performance.\nAn external clock source may also be connected to the OSC1 pin in the HS, XT and LP modes, as shown in Figure 2-2.",
    "2.3 RC Oscillator\nFor timing-insensitive applications, the 'RC' and 'RCIO'  device  options  offer  additional  cost  savings. The RC oscillator frequency is a function of the supply voltage, the resistor (REXT) and capacitor (CEXT) values and the operating temperature. In addition to this, the oscillator frequency will vary from unit to unit due to normal process parameter variation. Furthermore, the difference in lead frame capacitance between package types  will  also  affect  the  oscillation  frequency,  especially for low CEXT values. The user also needs to take into  account  variation  due  to  tolerance  of  external  R and  C  components  used.  Figure 2-3  shows  how  the R/C combination is connected.\nIn  the  RC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic.\nNote:, 1 = If the oscillator frequency divided by 4 sig- nal is not required in the application, it is recommended to use RCIO mode to save current.",
    "FIGURE 2-3: RC OSCILLATOR MODE\nThe RCIO Oscillator mode functions like the RC mode, except that the OSC2 pin becomes an additional general  purpose  I/O  pin.  The  I/O  pin  becomes  bit  6  of PORTA (RA6).",
    "2.4 External Clock Input\nThe EC and ECIO Oscillator modes require an external clock  source  to  be  connected  to  the  OSC1  pin.  The feedback device between OSC1 and OSC2 is turned off in these modes to save current. There is no oscillator  start-up  time  required  after  a  Power-on  Reset  or after a recovery from SLEEP mode.\nIn  the  EC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic. Figure 2-4 shows the pin connections for the EC Oscillator mode.",
    "FIGURE 2-4: EXTERNAL CLOCK INPUT OPERATION (EC CONFIGURATION)\nThe ECIO Oscillator mode functions like the EC mode, except that the OSC2 pin becomes an additional general  purpose  I/O  pin.  The  I/O  pin  becomes  bit  6  of PORTA (RA6). Figure 2-5 shows the pin connections for the ECIO Oscillator mode.",
    "2.5 HS/PLL\nA Phase Locked Loop circuit is provided as a programmable  option  for  users  that  want  to  multiply  the  frequency of the incoming crystal oscillator signal by 4. For an input clock frequency of 10 MHz, the internal clock  frequency will be multiplied to  40 MHz. This is useful for customers who are concerned with EMI due to high frequency crystals.\nThe PLL can only be enabled when the oscillator configuration bits are programmed for HS mode. If they are programmed  for  any  other  mode,  the  PLL  is  not enabled and the system clock will come directly from OSC1.\nThe PLL is one of the modes of the FOSC<2:0> configuration  bits.  The  Oscillator  mode  is  specified  during device programming.\nA PLL lock timer is used to ensure that the PLL has locked  before  device  execution  starts.  The  PLL  lock timer has a time-out that is called TPLL.",
    "2.6 Oscillator Switching Feature\nThe PIC18FXX2 devices include a feature that allows the system clock source to be switched from the main oscillator to an alternate low frequency clock source. For the PIC18FXX2 devices, this alternate clock source is the Timer1 oscillator. If a low frequency crystal (32 kHz,  for  example)  has  been  attached  to  the  Timer1 oscillator  pins  and  the  Timer1  oscillator  has  been enabled, the device can switch to a Low Power Execu- tion  mode.  Figure 2-7  shows  a  block  diagram  of  the system clock sources. The clock switching feature is enabled  by  programming  the  Oscillator  Switching Enable (OSCSEN) bit in Configuration Register1H to a '0'.  Clock  switching  is  disabled  in  an  erased  device. See Section 11.0 for further details of the Timer1 oscillator. See  Section 19.0 for Configuration Register details.",
    "2.6.1 SYSTEM CLOCK SWITCH BIT\nThe system clock source switching is performed under software  control.  The  system  clock  switch  bit,  SCS (OSCCON<0>) controls the clock switching. When the SCS bit is '0', the system clock source comes from the main oscillator that is selected by the FOSC configuration bits in Configuration Register1H. When the SCS bit is  set,  the  system  clock  source  will  come  from  the Timer1 oscillator. The SCS bit is cleared on all forms of RESET.\nNote:\nThe Timer1 oscillator must be enabled and operating to switch the system clock source. The Timer1 oscillator is enabled by setting  the  T1OSCEN  bit  in  the  Timer1 control  register  (T1CON).  If  the  Timer1 oscillator is not enabled, then any write to the SCS bit will be ignored (SCS bit forced cleared) and the main oscillator will continue to be the system clock source.",
    "REGISTER 2-1: OSCCON REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = SCS\nbit 7\nbit 0\nbit  7-1 Unimplemented: Read as '0'\nbit  0 SCS: System Clock Switch bit\nWhen OSCSEN configuration bit = '0' and T1OSCEN bit is set:\n- 1 =  Switch to Timer1 oscillator/clock pin\n0 =  Use primary oscillator/clock input pin\nWhen OSCSEN and T1OSCEN are in other states:\nbit is forced clear",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "2.6.2 OSCILLATOR TRANSITIONS\nThe  PIC18FXX2  devices  contain  circuitry  to  prevent 'glitches' when switching between oscillator sources. Essentially, the circuitry waits for eight rising edges of the clock source that the processor is switching to. This ensures that the new clock source is stable and that its pulse  width  will  not  be  less  than  the  shortest  pulse width of the two clock sources.\nA timing diagram indicating the transition from the main oscillator to the Timer1 oscillator is shown in Figure 2-8. The Timer1 oscillator is assumed to be running all the time. After the SCS bit is set, the processor is frozen at the next occurring Q1 cycle. After eight synchronization cycles are counted from the Timer1 oscillator,  operation  resumes.  No  additional  delays  are required after the synchronization cycles.",
    "FIGURE 2-8: TIMING DIAGRAM FOR TRANSITION FROM OSC1 TO TIMER1 OSCILLATOR\nNote 1: Delay on internal system clock is eight oscillator cycles for synchronization.\nThe sequence of events that takes place when switching from the Timer1 oscillator to the main oscillator will depend on the mode of the main oscillator. In addition to  eight clock cycles of the main oscillator, additional delays may take place.\nIf the main oscillator is configured for an external crystal (HS, XT, LP), then the transition will take place after an oscillator start-up time (TOST) has occurred. A timing diagram, indicating the transition from the Timer1 oscillator to the main oscillator for HS, XT and LP modes, is shown in Figure 2-9.",
    "TIMING FOR TRANSITION BETWEEN TIMER1 AND OSC1 (HS, XT, LP)\nNote 1: TOST = 1024 TOSC (drawing not to scale).\nIf the main oscillator is configured for HS-PLL mode, an oscillator  start-up  time  (TOST)  plus  an  additional  PLL time-out (TPLL) will occur. The PLL time-out is typically 2 ms and allows the PLL to lock to the main oscillator frequency.  A  timing  diagram  indicating  the  transition from  the  Timer1  oscillator  to  the  main  oscillator  for HS-PLL mode is shown in Figure 2-10.",
    "FIGURE 2-10: TIMING FOR TRANSITION BETWEEN TIMER1 AND OSC1 (HS WITH PLL)\nNote 1: TOST = 1024 TOSC (drawing not to scale).\nIf the main oscillator is configured in the RC, RCIO, EC or ECIO modes, there is no oscillator start-up time-out. Operation  will  resume  after  eight  cycles  of  the  main oscillator have been counted. A timing diagram, indicating the transition from the Timer1 oscillator to the main oscillator for RC, RCIO, EC and ECIO modes, is shown in Figure 2-11.",
    "FIGURE 2-11: TIMING FOR TRANSITION BETWEEN TIMER1 AND OSC1 (RC, EC)\nNote 1: RC Oscillator mode assumed.",
    "2.7 Effects of SLEEP Mode on the On-Chip Oscillator\nWhen  the  device  executes  a SLEEP instruction,  the on-chip  clocks  and  oscillator  are  turned  off  and  the device is held at the beginning of an instruction cycle (Q1 state). With the oscillator off, the OSC1 and OSC2 signals  will  stop  oscillating.  Since  all  the  transistor switching currents have been removed, SLEEP mode achieves the lowest current consumption of the device (only leakage currents). Enabling any on-chip feature that will operate during SLEEP will increase the current consumed  during  SLEEP.  The  user  can  wake  from SLEEP  through  external  RESET,  Watchdog  Timer Reset, or through an interrupt.",
    "2.7 Effects of SLEEP Mode on the On-Chip Oscillator\nTABLE 2-3: OSC1 AND OSC2 PIN STATES IN SLEEP MODE\n\nRC, OSC1 Pin = Floating, external resistor should pull high. RC, OSC2 Pin = At logic low. RCIO, OSC1 Pin = Floating, external resistor should pull high. RCIO, OSC2 Pin = Configured as PORTA, bit 6. ECIO, OSC1 Pin = Floating. ECIO, OSC2 Pin = Configured as PORTA, bit 6. EC, OSC1 Pin = Floating. EC, OSC2 Pin = At logic low. LP, XT, and HS, OSC1 Pin = Feedback inverter disabled, at quiescent voltage level. LP, XT, and HS, OSC2 Pin = Feedback inverter disabled, at quiescent voltage level\nNote: See Table 3-1, in the 'Reset' section, for time-outs due to SLEEP and MCLR Reset.",
    "2.8 Power-up Delays\nPower up delays are controlled by two timers, so that no external RESET circuitry is required for most applications. The delays ensure that the device is kept in RESET, until the device power supply and clock are stable. For additional information on RESET operation, see Section 3.0.\nThe first timer is the Power-up Timer (PWRT), which optionally provides a fixed delay of 72 ms (nominal) on power-up only (POR and BOR). The second timer is the Oscillator Start-up Timer (OST), intended to keep the chip in RESET until the crystal oscillator is stable.",
    "2.8 Power-up Delays\nWith the PLL enabled (HS/PLL Oscillator mode), the time-out sequence following a Power-on Reset is different from other Oscillator modes. The time-out sequence  is  as  follows:  First,  the  PWRT  time-out  is invoked after a POR time delay has expired. Then, the Oscillator  Start-up  Timer  (OST)  is  invoked.  However, this is still not a sufficient amount of time to allow the PLL to lock  at  high  frequencies.  The  PWRT  timer  is used  to  provide  an  additional  fixed  2  ms  (nominal) time-out  to  allow  the  PLL  ample  time  to  lock  to  the incoming clock frequency.",
    "3.0 RESET\nThe PIC18FXXX differentiates between various kinds of RESET:\na) Power-on Reset (POR)\nb) MCLR Reset during normal operation\nc) MCLR Reset during SLEEP\nd) Watchdog  Timer  (WDT)  Reset  (during  normal operation)\ne) Programmable Brown-out Reset (BOR)\nf) RESET Instruction\ng) Stack Full Reset\nh) Stack Underflow Reset\nMost registers are unaffected by a RESET. Their status is unknown  on  POR  and  unchanged  by  all  other RESETS. The other registers are forced to a 'RESET state' on Power-on Reset, MCLR, WDT Reset, Brownout  Reset,  MCLR  Reset  during  SLEEP  and  by  the RESET instruction.\nMost  registers  are  not  affected  by  a  WDT  wake-up, since this is viewed as the resumption of normal operation. Status bits from the RCON register, RI, TO, PD, POR and BOR, are set or cleared differently in different RESET situations, as indicated in Table 3-2. These bits are  used  in  software  to  determine  the  nature  of  the RESET.  See  Table 3-3  for  a  full  description  of  the RESET states of all registers.",
    "3.0 RESET\nA simplified block diagram of the On-Chip Reset Circuit is shown in Figure 3-1.\nThe Enhanced MCU devices have a MCLR noise filter in  the  MCLR  Reset  path.  The  filter  will  detect  and ignore small pulses.\nThe  MCLR  pin  is  not  driven  low  by  any  internal RESETS, including the WDT.",
    "3.1 Power-On Reset (POR)\nA  Power-on  Reset  pulse  is  generated  on-chip  when VDD rise is detected. To take advantage of the POR circuitry, just tie the MCLR pin directly (or through a resistor) to VDD. This will eliminate external RC components usually needed to create a Power-on Reset delay. A minimum rise rate for VDD is specified (parameter D004). For a slow rise time, see Figure 3-2.\nWhen the device starts normal operation (i.e., exits the RESET condition), device operating parameters (voltage,  frequency,  temperature,  etc.)  must  be  met  to ensure operation. If these conditions are not met, the device  must  be  held  in  RESET  until  the  operating conditions are met.",
    "EXTERNAL POWER-ON RESET CIRCUIT (FOR SLOW VDD POWER-UP)\nNote 1: External  Power-on  Reset  circuit  is  required only  if  the  VDD  power-up  slope  is  too  slow. The  diode  D  helps  discharge  the  capacitor quickly when VDD powers down.\n2: R < 40 k \u2126 is recommended to make sure that the  voltage  drop  across  R  does  not  violate the device's electrical specification.\n3: R1 = 100 \u2126 to 1 k \u2126 will limit any current flowing into MCLR from external capacitor C, in the event of MCLR/VPP pin breakdown due to Electrostatic  Discharge  (ESD)  or  Electrical Overstress (EOS).",
    "3.2 Power-up Timer (PWRT)\nThe Power-up Timer provides a fixed nominal time-out (parameter 33) only on power-up from the POR. The Power-up Timer operates on an internal RC oscillator. The chip is  kept  in  RESET  as  long  as  the  PWRT  is active. The PWRT's time delay allows VDD to rise to an acceptable  level.  A  configuration  bit  is  provided  to enable/disable the PWRT.\nThe power-up time delay will vary from chip-to-chip due to  VDD,  temperature  and  process  variation.  See  DC parameter D033 for details.",
    "3.3 Oscillator Start-up Timer (OST)\nThe Oscillator Start-up Timer (OST) provides a 1024 oscillator  cycle  (from  OSC1  input)  delay  after  the PWRT delay is over (parameter 32). This ensures that the  crystal  oscillator  or  resonator  has  started  and stabilized.\nThe OST time-out is invoked only for XT, LP and HS modes and only on Power-on Reset or wake-up from SLEEP.",
    "3.4 PLL Lock Time-out\nWith the PLL enabled, the time-out sequence following a  Power-on  Reset  is  different  from  other  Oscillator modes. A portion of the Power-up Timer is used to provide a fixed time-out that is sufficient for the PLL to lock to the main oscillator frequency. This PLL lock time-out (TPLL)  is  typically  2  ms  and  follows  the  oscillator start-up time-out (OST).",
    "3.5 Brown-out Reset (BOR)\nA  configuration  bit,  BOREN,  can  disable  (if  clear/ programmed), or enable (if set) the Brown-out Reset circuitry. If VDD falls below parameter D005 for greater than  parameter 35,  the  brown-out  situation  will  reset the chip. A RESET may not occur if VDD falls below parameter D005 for less than parameter 35. The chip will remain in Brown-out Reset until VDD rises above BVDD.  If  the  Power-up  Timer  is  enabled,  it  will  be invoked after VDD rises above BVDD; it then will keep the chip in RESET  for  an  additional  time delay (parameter 33).  If  VDD  drops  below  BVDD  while  the Power-up Timer is running, the chip will go back into a Brown-out Reset and the Power-up Timer will be initialized. Once VDD rises above BVDD, the Power-up Timer will execute the additional time delay.",
    "3.6 Time-out Sequence\nOn  power-up,  the  time-out  sequence  is  as  follows: First,  PWRT  time-out  is  invoked  after  the  POR  time delay has expired. Then, OST is activated. The total time-out will vary based on oscillator configuration and the status of the PWRT. For example, in RC mode with the  PWRT  disabled,  there  will  be  no  time-out  at  all. Figure 3-3, Figure 3-4, Figure 3-5, Figure 3-6 and Figure 3-7 depict time-out sequences on power-up.\nSince the time-outs occur from the POR pulse, if MCLR is  kept  low  long  enough,  the  time-outs  will  expire. Bringing MCLR high will begin execution immediately (Figure 3-5). This is useful for testing purposes or to synchronize more than one PIC18FXXX device operating in parallel.\nTable 3-2  shows  the  RESET  conditions  for  some Special Function Registers, while Table 3-3 shows the RESET conditions for all the registers.",
    "TABLE 3-1: TIME-OUT IN VARIOUS SITUATIONS\nHS with PLL enabled (1), Power-up (2).PWRTE = 0 = 72 ms + 1024 TOSC + 2ms. HS with PLL enabled (1), Power-up (2).PWRTE = 1 = 1024 TOSC + 2 ms. HS with PLL enabled (1), Brown-out.Brown-out = 72 ms (2) + 1024 TOSC + 2 ms. HS with PLL enabled (1), Wake-up from SLEEP or Oscillator Switch.Wake-up from SLEEP or Oscillator Switch = 1024 TOSC + 2 ms. HS, XT, LP, Power-up (2).PWRTE = 0 = 72 ms + 1024 TOSC. HS, XT, LP, Power-up (2).PWRTE = 1 = 1024 TOSC. HS, XT, LP, Brown-out.Brown-out = 72 ms (2) + 1024 TOSC. HS, XT, LP, Wake-up from SLEEP or Oscillator Switch.Wake-up from SLEEP or Oscillator Switch =",
    "TABLE 3-1: TIME-OUT IN VARIOUS SITUATIONS\n1024 TOSC. EC, Power-up (2).PWRTE = 0 = 72 ms. EC, Power-up (2).PWRTE = 1 = -. EC, Brown-out.Brown-out = 72 ms (2). EC, Wake-up from SLEEP or Oscillator Switch.Wake-up from SLEEP or Oscillator Switch = -. External RC, Power-up (2).PWRTE = 0 = 72 ms. External RC, Power-up (2).PWRTE = 1 = -. External RC, Brown-out.Brown-out = 72 ms (2). External RC, Wake-up from SLEEP or Oscillator Switch.Wake-up from SLEEP or Oscillator Switch = -\nNote 1: 2 ms is the nominal time required for the 4x PLL to lock.\n2: 72 ms is the nominal power-up timer delay, if implemented.",
    "REGISTER 3-1: RCON REGISTER BITS AND POSITIONS\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R-1. R/W-0, 5 = R-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0\nNote 1: Refer to Section 4.14 (page 53) for bit definitions.",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nPower-on Reset, Program Counter = 0000h. Power-on Reset, RCON Register = 0--1 1100. Power-on Reset, RI = 1. Power-on Reset, TO = 1. Power-on Reset, PD = 1. Power-on Reset, POR = 0. Power-on Reset, BOR = 0. Power-on Reset, STKFUL = u. Power-on Reset, STKUNF = u. MCLR Reset during normal operation, Program Counter = 0000h. MCLR Reset during normal operation, RCON Register = 0--u uuuu. MCLR Reset during normal operation, RI = u. MCLR Reset during normal operation, TO = u. MCLR Reset during normal operation, PD = u. MCLR Reset during normal operation, POR = u. MCLR Reset during normal operation, BOR = u. MCLR Reset during normal operation, STKFUL = u. MCLR Reset during normal operation, STKUNF = u. Software Reset during normal operation, Program Counter = 0000h. Software Reset during normal operation, RCON Register =",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n0--0 uuuu. Software Reset during normal operation, RI = 0. Software Reset during normal operation, TO = u. Software Reset during normal operation, PD = u. Software Reset during normal operation, POR = u. Software Reset during normal operation, BOR = u. Software Reset during normal operation, STKFUL = u. Software Reset during normal operation, STKUNF = u. Stack Full Reset during normal operation, Program Counter = 0000h. Stack Full Reset during normal operation, RCON Register = 0--u uu11. Stack Full Reset during normal operation, RI = u. Stack Full Reset during normal operation, TO = u. Stack Full Reset during normal operation, PD = u. Stack Full Reset during normal operation, POR = u. Stack Full Reset during normal operation, BOR = u. Stack Full Reset during normal operation, STKFUL = u. Stack Full Reset during normal operation, STKUNF = 1. Stack Underflow Reset during normal operation, Program Counter = 0000h. Stack Underflow Reset during normal operation, RCON Register = 0--u uu11. Stack",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nUnderflow Reset during normal operation, RI = u. Stack Underflow Reset during normal operation, TO = u. Stack Underflow Reset during normal operation, PD = u. Stack Underflow Reset during normal operation, POR = u. Stack Underflow Reset during normal operation, BOR = u. Stack Underflow Reset during normal operation, STKFUL = 1. Stack Underflow Reset during normal operation, STKUNF = u. MCLR Reset during SLEEP, Program Counter = 0000h. MCLR Reset during SLEEP, RCON Register = 0--u 10uu. MCLR Reset during SLEEP, RI = u. MCLR Reset during SLEEP, TO = 1. MCLR Reset during SLEEP, PD = 0. MCLR Reset during SLEEP, POR = u. MCLR Reset during SLEEP, BOR = u. MCLR Reset during SLEEP, STKFUL = u. MCLR Reset during SLEEP, STKUNF = u. WDT Reset, Program Counter = 0000h. WDT Reset, RCON Register = 0--u 01uu. WDT Reset, RI = 1. WDT Reset, TO =",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n0. WDT Reset, PD = 1. WDT Reset, POR = u. WDT Reset, BOR = u. WDT Reset, STKFUL = u. WDT Reset, STKUNF = u. WDT Wake-up, Program Counter = PC + 2. WDT Wake-up, RCON Register = u--u 00uu. WDT Wake-up, RI = u. WDT Wake-up, TO = 0. WDT Wake-up, PD = 0. WDT Wake-up, POR = u. WDT Wake-up, BOR = u. WDT Wake-up, STKFUL = u. WDT Wake-up, STKUNF = u. Brown-out Reset, Program Counter = 0000h. Brown-out Reset, RCON Register = 0--1 11u0. Brown-out Reset, RI = 1. Brown-out Reset, TO = 1. Brown-out Reset, PD = 1. Brown-out Reset, POR = 1. Brown-out Reset, BOR = 0. Brown-out Reset,",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nSTKFUL = u. Brown-out Reset, STKUNF = u. Interrupt wake-up from SLEEP, Program Counter = PC + 2 (1). Interrupt wake-up from SLEEP, RCON Register = u--u 00uu. Interrupt wake-up from SLEEP, RI = u. Interrupt wake-up from SLEEP, TO = 1. Interrupt wake-up from SLEEP, PD = 0. Interrupt wake-up from SLEEP, POR = u. Interrupt wake-up from SLEEP, BOR = u. Interrupt wake-up from SLEEP, STKFUL = u. Interrupt wake-up from SLEEP, STKUNF = u\nLegend: u = unchanged, x = unknown, - = unimplemented bit, read as '0'\nNote 1: When the wake-up is due to an interrupt and the GIEH or GIEL bits are set, the PC is loaded with the interrupt vector ( 0x000008h or 0x000018h ).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTOSU, Applicable Devices = 242. TOSU, Applicable Devices = 442. TOSU, Applicable Devices = 252. TOSU, Applicable Devices = 452. TOSU, Power-on Reset, Brown-out Reset = ---0 0000. TOSU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. TOSU, Wake-up via WDT or Interrupt = ---0 uuuu (3). TOSH, Applicable Devices = 242. TOSH, Applicable Devices = 442. TOSH, Applicable Devices = 252. TOSH, Applicable Devices = 452. TOSH, Power-on Reset, Brown-out Reset = 0000 0000. TOSH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSH, Wake-up via WDT or Interrupt = uuuu uuuu (3). TOSL, Applicable Devices = 242. TOSL, Applicable Devices = 442. TOSL, Applicable Devices = 252. TOSL, Applicable Devices = 452. TOSL, Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n0000 0000. TOSL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSL, Wake-up via WDT or Interrupt = uuuu uuuu (3). STKPTR, Applicable Devices = 242. STKPTR, Applicable Devices = 442. STKPTR, Applicable Devices = 252. STKPTR, Applicable Devices = 452. STKPTR, Power-on Reset, Brown-out Reset = 00-0 0000. STKPTR, MCLR Resets WDT Reset RESET Instruction Stack Resets = uu-0 0000. STKPTR, Wake-up via WDT or Interrupt = uu-u uuuu (3). PCLATU, Applicable Devices = 242. PCLATU, Applicable Devices = 442. PCLATU, Applicable Devices = 252. PCLATU, Applicable Devices = 452. PCLATU, Power-on Reset, Brown-out Reset = ---0 0000. PCLATU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n0000. PCLATU, Wake-up via WDT or Interrupt = ---u uuuu. PCLATH, Applicable Devices = 242. PCLATH, Applicable Devices = 442. PCLATH, Applicable Devices = 252. PCLATH, Applicable Devices = 452. PCLATH, Power-on Reset, Brown-out Reset = 0000 0000. PCLATH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PCLATH, Wake-up via WDT or Interrupt = uuuu uuuu. PCL, Applicable Devices = 242. PCL, Applicable Devices = 442. PCL, Applicable Devices = 252. PCL, Applicable Devices = 452. PCL, Power-on Reset, Brown-out Reset = 0000 0000. PCL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PCL, Wake-up via WDT or Interrupt = PC + 2 (2). TBLPTRU, Applicable Devices = 242. TBLPTRU, Applicable Devices = 442. TBLPTRU, Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nDevices = 252. TBLPTRU, Applicable Devices = 452. TBLPTRU, Power-on Reset, Brown-out Reset = --00 0000. TBLPTRU, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. TBLPTRU, Wake-up via WDT or Interrupt = --uu uuuu. TBLPTRH, Applicable Devices = 242. TBLPTRH, Applicable Devices = 442. TBLPTRH, Applicable Devices = 252. TBLPTRH, Applicable Devices = 452. TBLPTRH, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRH, Wake-up via WDT or Interrupt = uuuu uuuu. TBLPTRL, Applicable Devices = 242. TBLPTRL, Applicable Devices = 442. TBLPTRL, Applicable Devices = 252. TBLPTRL, Applicable Devices = 452. TBLPTRL, Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nBrown-out Reset = 0000 0000. TBLPTRL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRL, Wake-up via WDT or Interrupt = uuuu uuuu. TABLAT, Applicable Devices = 242. TABLAT, Applicable Devices = 442. TABLAT, Applicable Devices = 252. TABLAT, Applicable Devices = 452. TABLAT, Power-on Reset, Brown-out Reset = 0000 0000. TABLAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TABLAT, Wake-up via WDT or Interrupt = uuuu uuuu. PRODH, Applicable Devices = 242. PRODH, Applicable Devices = 442. PRODH, Applicable Devices = 252. PRODH, Applicable Devices = 452. PRODH, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PRODH, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nuuuu. PRODL, Applicable Devices = 242. PRODL, Applicable Devices = 442. PRODL, Applicable Devices = 252. PRODL, Applicable Devices = 452. PRODL, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PRODL, Wake-up via WDT or Interrupt = uuuu uuuu. INTCON, Applicable Devices = 242. INTCON, Applicable Devices = 442. INTCON, Applicable Devices = 252. INTCON, Applicable Devices = 452. INTCON, Power-on Reset, Brown-out Reset = 0000 000x. INTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000u. INTCON, Wake-up via WDT or Interrupt = uuuu uuuu (1). INTCON2, Applicable Devices = 242. INTCON2, Applicable Devices = 442. INTCON2, Applicable Devices = 252. INTCON2, Applicable Devices = 452. INTCON2, Power-on",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nReset, Brown-out Reset = 1111 -1-1. INTCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 -1-1. INTCON2, Wake-up via WDT or Interrupt = uuuu -u-u (1). INTCON3, Applicable Devices = 242. INTCON3, Applicable Devices = 442. INTCON3, Applicable Devices = 252. INTCON3, Applicable Devices = 452. INTCON3, Power-on Reset, Brown-out Reset = 11-0 0-00. INTCON3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 11-0 0-00. INTCON3, Wake-up via WDT or Interrupt = uu-u u-uu (1). INDF0, Applicable Devices = 242. INDF0, Applicable Devices = 442. INDF0, Applicable Devices = 252. INDF0, Applicable Devices = 452. INDF0, Power-on Reset, Brown-out Reset = N/A. INDF0, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nN/A. INDF0, Wake-up via WDT or Interrupt = N/A. POSTINC0, Applicable Devices = 242. POSTINC0, Applicable Devices = 442. POSTINC0, Applicable Devices = 252. POSTINC0, Applicable Devices = 452. POSTINC0, Power-on Reset, Brown-out Reset = N/A. POSTINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC0, Wake-up via WDT or Interrupt = N/A. POSTDEC0, Applicable Devices = 242. POSTDEC0, Applicable Devices = 442. POSTDEC0, Applicable Devices = 252. POSTDEC0, Applicable Devices = 452. POSTDEC0, Power-on Reset, Brown-out Reset = N/A. POSTDEC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC0, Wake-up via WDT or Interrupt = N/A. PREINC0, Applicable Devices = 242. PREINC0, Applicable Devices = 442.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPREINC0, Applicable Devices = 252. PREINC0, Applicable Devices = 452. PREINC0, Power-on Reset, Brown-out Reset = N/A. PREINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC0, Wake-up via WDT or Interrupt = N/A. PLUSW0, Applicable Devices = 242. PLUSW0, Applicable Devices = 442. PLUSW0, Applicable Devices = 252. PLUSW0, Applicable Devices = 452. PLUSW0, Power-on Reset, Brown-out Reset = N/A. PLUSW0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW0, Wake-up via WDT or Interrupt = N/A. FSR0H, Applicable Devices = 242. FSR0H, Applicable Devices = 442 442. FSR0H, Applicable Devices = 252. FSR0H, Applicable Devices = 452. FSR0H, Power-on Reset, Brown-out Reset = ---- xxxx xxxx xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nFSR0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- uuuu uuuu uuuu. FSR0H, Wake-up via WDT or Interrupt = ---- uuuu uuuu uuuu. FSR0L, Applicable Devices = 242. FSR0L, Applicable Devices = . FSR0L, Applicable Devices = 252. FSR0L, Applicable Devices = 452. FSR0L, Power-on Reset, Brown-out Reset = . FSR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = . FSR0L, Wake-up via WDT or Interrupt = . WREG, Applicable Devices = 242. WREG, Applicable Devices = 442. WREG, Applicable Devices = 252. WREG, Applicable Devices = 452. WREG, Power-on Reset, Brown-out Reset = xxxx xxxx. WREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. WREG, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nuuuu uuuu. INDF1, Applicable Devices = 242. INDF1, Applicable Devices = 442. INDF1, Applicable Devices = 252. INDF1, Applicable Devices = 452. INDF1, Power-on Reset, Brown-out Reset = N/A. INDF1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF1, Wake-up via WDT or Interrupt = N/A. POSTINC1, Applicable Devices = 242. POSTINC1, Applicable Devices = 442. POSTINC1, Applicable Devices = 252. POSTINC1, Applicable Devices = 452. POSTINC1, Power-on Reset, Brown-out Reset = N/A. POSTINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC1, Wake-up via WDT or Interrupt = N/A. POSTDEC1, Applicable Devices = 242. POSTDEC1, Applicable Devices = 442. POSTDEC1, Applicable Devices = 252. POSTDEC1, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n452. POSTDEC1, Power-on Reset, Brown-out Reset = N/A. POSTDEC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC1, Wake-up via WDT or Interrupt = N/A. PREINC1, Applicable Devices = 242. PREINC1, Applicable Devices = 442. PREINC1, Applicable Devices = 252. PREINC1, Applicable Devices = 452. PREINC1, Power-on Reset, Brown-out Reset = N/A. PREINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC1, Wake-up via WDT or Interrupt = N/A. PLUSW1, Applicable Devices = 242. PLUSW1, Applicable Devices = 442. PLUSW1, Applicable Devices = 252. PLUSW1, Applicable Devices = 452. PLUSW1, Power-on Reset, Brown-out Reset = N/A. PLUSW1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW1,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nWake-up via WDT or Interrupt = N/A\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as '0', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector ( 0008h or 0018h ).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for RESET value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other Oscillator modes, they are disabled and read '0'.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read '0'.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFSR1H, Applicable Devices = 242. FSR1H, Applicable Devices = 442. FSR1H, Applicable Devices = 252. FSR1H, Applicable Devices = 452. FSR1H, Power-on Reset, Brown-out Reset = ---- xxxx. FSR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR1H, Wake-up via WDT or Interrupt = ---- uuuu. FSR1L, Applicable Devices = 242. FSR1L, Applicable Devices = 442. FSR1L, Applicable Devices = 252. FSR1L, Applicable Devices = 452. FSR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR1L, Wake-up via WDT or Interrupt = uuuu uuuu. BSR, Applicable Devices = 242. BSR, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n442. BSR, Applicable Devices = 252. BSR, Applicable Devices = 452. BSR, Power-on Reset, Brown-out Reset = ---- 0000. BSR, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. BSR, Wake-up via WDT or Interrupt = ---- uuuu. INDF2, Applicable Devices = 242. INDF2, Applicable Devices = 442. INDF2, Applicable Devices = 252. INDF2, Applicable Devices = 452. INDF2, Power-on Reset, Brown-out Reset = N/A. INDF2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF2, Wake-up via WDT or Interrupt = N/A. POSTINC2, Applicable Devices = 242. POSTINC2, Applicable Devices = 442. POSTINC2, Applicable Devices = 252. POSTINC2, Applicable Devices = 452. POSTINC2, Power-on Reset, Brown-out Reset = N/A.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPOSTINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC2, Wake-up via WDT or Interrupt = N/A. POSTDEC2, Applicable Devices = 242. POSTDEC2, Applicable Devices = 442. POSTDEC2, Applicable Devices = 252. POSTDEC2, Applicable Devices = 452. POSTDEC2, Power-on Reset, Brown-out Reset = N/A. POSTDEC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC2, Wake-up via WDT or Interrupt = N/A. PREINC2, Applicable Devices = 242. PREINC2, Applicable Devices = 442. PREINC2, Applicable Devices = 252. PREINC2, Applicable Devices = 452. PREINC2, Power-on Reset, Brown-out Reset = N/A. PREINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC2, Wake-up via WDT or Interrupt = N/A.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPLUSW2, Applicable Devices = 242. PLUSW2, Applicable Devices = 442. PLUSW2, Applicable Devices = 252. PLUSW2, Applicable Devices = 452. PLUSW2, Power-on Reset, Brown-out Reset = N/A. PLUSW2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW2, Wake-up via WDT or Interrupt = N/A. FSR2H, Applicable Devices = 242. FSR2H, Applicable Devices = 442. FSR2H, Applicable Devices = 252. FSR2H, Applicable Devices = 452. FSR2H, Power-on Reset, Brown-out Reset = ---- xxxx. FSR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR2H, Wake-up via WDT or Interrupt = ---- uuuu. FSR2L, Applicable Devices = 242. FSR2L, Applicable Devices = 442. FSR2L, Applicable Devices = 252.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFSR2L, Applicable Devices = 452. FSR2L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR2L, Wake-up via WDT or Interrupt = uuuu uuuu. STATUS, Applicable Devices = 242. STATUS, Applicable Devices = 442. STATUS, Applicable Devices = 252. STATUS, Applicable Devices = 452. STATUS, Power-on Reset, Brown-out Reset = ---x xxxx. STATUS, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---u uuuu. STATUS, Wake-up via WDT or Interrupt = ---u uuuu. TMR0H, Applicable Devices = 242. TMR0H, Applicable Devices = 442. TMR0H, Applicable Devices = 252. TMR0H, Applicable Devices = 452. TMR0H, Power-on Reset, Brown-out Reset = 0000 0000.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTMR0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR0H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR0L, Applicable Devices = 242. TMR0L, Applicable Devices = 442. TMR0L, Applicable Devices = 252. TMR0L, Applicable Devices = 452. TMR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR0L, Wake-up via WDT or Interrupt = uuuu uuuu. T0CON, Applicable Devices = 242. T0CON, Applicable Devices = 442. T0CON, Applicable Devices = 252. T0CON, Applicable Devices = 452. T0CON, Power-on Reset, Brown-out Reset = 1111 1111. T0CON, MCLR Resets WDT Reset RESET Instruction Stack",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets = 1111 1111. T0CON, Wake-up via WDT or Interrupt = uuuu uuuu. OSCCON, Applicable Devices = 242. OSCCON, Applicable Devices = 442. OSCCON, Applicable Devices = 252. OSCCON, Applicable Devices = 452. OSCCON, Power-on Reset, Brown-out Reset = ---- ---0. OSCCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- ---0. OSCCON, Wake-up via WDT or Interrupt = ---- ---u. LVDCON, Applicable Devices = 242. LVDCON, Applicable Devices = 442. LVDCON, Applicable Devices = 252. LVDCON, Applicable Devices = 452. LVDCON, Power-on Reset, Brown-out Reset = --00 0101. LVDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0101. LVDCON, Wake-up via WDT or Interrupt = --uu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDTCON, Applicable Devices = 242. WDTCON, Applicable Devices = 442. WDTCON, Applicable Devices = 252. WDTCON, Applicable Devices = 452. WDTCON, Power-on Reset, Brown-out Reset = ---- ---0. WDTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- ---0. WDTCON, Wake-up via WDT or Interrupt = ---- ---u. RCON (4), Applicable Devices = 242. RCON (4), Applicable Devices = 442. RCON (4), Applicable Devices = 252. RCON (4), Applicable Devices = 452. RCON (4), Power-on Reset, Brown-out Reset = 0--q 11qq. RCON (4), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0--q qquu. RCON (4), Wake-up via WDT or Interrupt = u--u qquu. TMR1H, Applicable Devices = 242.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTMR1H, Applicable Devices = 442. TMR1H, Applicable Devices = 252. TMR1H, Applicable Devices = 452. TMR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR1L, Applicable Devices = 242. TMR1L, Applicable Devices = 442. TMR1L, Applicable Devices = 252. TMR1L, Applicable Devices = 452. TMR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1L, Wake-up via WDT or Interrupt = uuuu uuuu. T1CON, Applicable Devices = 242. T1CON, Applicable Devices",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 442. T1CON, Applicable Devices = 252. T1CON, Applicable Devices = 452. T1CON, Power-on Reset, Brown-out Reset = 0-00 0000. T1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = u-uu uuuu. T1CON, Wake-up via WDT or Interrupt = u-uu uuuu. TMR2, Applicable Devices = 242. TMR2, Applicable Devices = 442. TMR2, Applicable Devices = 252. TMR2, Applicable Devices = 452. TMR2, Power-on Reset, Brown-out Reset = 0000 0000. TMR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TMR2, Wake-up via WDT or Interrupt = uuuu uuuu. PR2, Applicable Devices = 242. PR2, Applicable Devices = 442. PR2, Applicable Devices = 252. PR2, Applicable Devices = 452. PR2, Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = 1111 1111. PR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. PR2, Wake-up via WDT or Interrupt = 1111 1111. T2CON, Applicable Devices = 242. T2CON, Applicable Devices = 442. T2CON, Applicable Devices = 252. T2CON, Applicable Devices = 452. T2CON, Power-on Reset, Brown-out Reset = -000 0000. T2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. T2CON, Wake-up via WDT or Interrupt = -uuu uuuu. SSPBUF, Applicable Devices = 242. SSPBUF, Applicable Devices = 442. SSPBUF, Applicable Devices = 252. SSPBUF, Applicable Devices = 452. SSPBUF, Power-on Reset, Brown-out Reset = xxxx xxxx. SSPBUF, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nSSPBUF, Wake-up via WDT or Interrupt = uuuu uuuu. SSPADD, Applicable Devices = 242. SSPADD, Applicable Devices = 442. SSPADD, Applicable Devices = 252. SSPADD, Applicable Devices = 452. SSPADD, Power-on Reset, Brown-out Reset = 0000 0000. SSPADD, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPADD, Wake-up via WDT or Interrupt = uuuu uuuu. SSPSTAT, Applicable Devices = 242. SSPSTAT, Applicable Devices = 442. SSPSTAT, Applicable Devices = 252. SSPSTAT, Applicable Devices = 452. SSPSTAT, Power-on Reset, Brown-out Reset = 0000 0000. SSPSTAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPSTAT, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON1, Applicable Devices = 242. SSPCON1, Applicable Devices",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 442. SSPCON1, Applicable Devices = 252. SSPCON1, Applicable Devices = 452. SSPCON1, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPCON1, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON2, Applicable Devices = 242. SSPCON2, Applicable Devices = 442. SSPCON2, Applicable Devices = 252. SSPCON2, Applicable Devices = 452. SSPCON2, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPCON2, Wake-up via WDT or Interrupt = uuuu uuuu\n= value depends on condition.\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as '0', q Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector ( 0008h or 0018h ).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for RESET value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other Oscillator modes, they are disabled and read '0'.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read '0'.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADRESH, Applicable Devices = 242. ADRESH, Applicable Devices = 442. ADRESH, Applicable Devices = 252. ADRESH, Applicable Devices = 452. ADRESH, Power-on Reset, Brown-out Reset = xxxx xxxx. ADRESH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. ADRESH, Wake-up via WDT or Interrupt = uuuu uuuu. ADRESL, Applicable Devices = 242. ADRESL, Applicable Devices = 442. ADRESL, Applicable Devices = 252. ADRESL, Applicable Devices = 452. ADRESL, Power-on Reset, Brown-out Reset = xxxx xxxx. ADRESL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. ADRESL, Wake-up via WDT or Interrupt = uuuu uuuu. ADCON0, Applicable Devices = 242. ADCON0, Applicable Devices = 442. ADCON0, Applicable Devices = 252. ADCON0, Applicable Devices = 452.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADCON0, Power-on Reset, Brown-out Reset = 0000 00-0. ADCON0, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 00-0. ADCON0, Wake-up via WDT or Interrupt = uuuu uu-u. ADCON1, Applicable Devices = 242. ADCON1, Applicable Devices = 442. ADCON1, Applicable Devices = 252. ADCON1, Applicable Devices = 452. ADCON1, Power-on Reset, Brown-out Reset = 00-- 0000. ADCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 00-- 0000. ADCON1, Wake-up via WDT or Interrupt = uu-- uuuu. CCPR1H, Applicable Devices = 242. CCPR1H, Applicable Devices = 442. CCPR1H, Applicable Devices = 252. CCPR1H, Applicable Devices = 452. CCPR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR1H, MCLR Resets WDT Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRESET Instruction Stack Resets = uuuu uuuu. CCPR1H, Wake-up via WDT or Interrupt = uuuu uuuu. CCPR1L, Applicable Devices = 242. CCPR1L, Applicable Devices = 442. CCPR1L, Applicable Devices = 252. CCPR1L, Applicable Devices = 452. CCPR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR1L, Wake-up via WDT or Interrupt = uuuu uuuu. CCP1CON, Applicable Devices = 242. CCP1CON, Applicable Devices = 442. CCP1CON, Applicable Devices = 252. CCP1CON, Applicable Devices = 452. CCP1CON, Power-on Reset, Brown-out Reset = --00 0000. CCP1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. CCP1CON,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = --uu uuuu. CCPR2H, Applicable Devices = 242. CCPR2H, Applicable Devices = 442. CCPR2H, Applicable Devices = 252. CCPR2H, Applicable Devices = 452. CCPR2H, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR2H, Wake-up via WDT or Interrupt = uuuu uuuu. CCPR2L, Applicable Devices = 242. CCPR2L, Applicable Devices = 442. CCPR2L, Applicable Devices = 252. CCPR2L, Applicable Devices = 452. CCPR2L, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR2L, Wake-up via WDT or Interrupt = uuuu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nCCP2CON, Applicable Devices = 242. CCP2CON, Applicable Devices = 442. CCP2CON, Applicable Devices = 252. CCP2CON, Applicable Devices = 452. CCP2CON, Power-on Reset, Brown-out Reset = --00 0000. CCP2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. CCP2CON, Wake-up via WDT or Interrupt = --uu uuuu. TMR3H, Applicable Devices = 242. TMR3H, Applicable Devices = 442. TMR3H, Applicable Devices = 252. TMR3H, Applicable Devices = 452. TMR3H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR3H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR3H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR3L, Applicable Devices = 242.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTMR3L, Applicable Devices = 442. TMR3L, Applicable Devices = 252. TMR3L, Applicable Devices = 452. TMR3L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR3L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR3L, Wake-up via WDT or Interrupt = uuuu uuuu. T3CON, Applicable Devices = 242. T3CON, Applicable Devices = 442. T3CON, Applicable Devices = 252. T3CON, Applicable Devices = 452. T3CON, Power-on Reset, Brown-out Reset = 0000 0000. T3CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. T3CON, Wake-up via WDT or Interrupt = uuuu uuuu. SPBRG, Applicable Devices = 242. SPBRG, Applicable Devices = 442. SPBRG, Applicable Devices = 252.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nSPBRG, Applicable Devices = 452. SPBRG, Power-on Reset, Brown-out Reset = 0000 0000. SPBRG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SPBRG, Wake-up via WDT or Interrupt = uuuu uuuu. RCREG, Applicable Devices = 242. RCREG, Applicable Devices = 442. RCREG, Applicable Devices = 252. RCREG, Applicable Devices = 452. RCREG, Power-on Reset, Brown-out Reset = 0000 0000. RCREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. RCREG, Wake-up via WDT or Interrupt = uuuu uuuu. TXREG, Applicable Devices = 242. TXREG, Applicable Devices = 442. TXREG, Applicable Devices = 252. TXREG, Applicable Devices = 452. TXREG, Power-on Reset, Brown-out Reset = 0000 0000. TXREG, MCLR Resets WDT Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRESET Instruction Stack Resets = 0000 0000. TXREG, Wake-up via WDT or Interrupt = uuuu uuuu. TXSTA, Applicable Devices = 242. TXSTA, Applicable Devices = 442. TXSTA, Applicable Devices = 252. TXSTA, Applicable Devices = 452. TXSTA, Power-on Reset, Brown-out Reset = 0000 -010. TXSTA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 -010. TXSTA, Wake-up via WDT or Interrupt = uuuu -uuu. RCSTA, Applicable Devices = 242. RCSTA, Applicable Devices = 442. RCSTA, Applicable Devices = 252. RCSTA, Applicable Devices = 452. RCSTA, Power-on Reset, Brown-out Reset = 0000 000x. RCSTA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000x. RCSTA, Wake-up via WDT or Interrupt = uuuu uuuu. EEADR, Applicable Devices = 242. EEADR, Applicable Devices = 442.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nEEADR, Applicable Devices = 252. EEADR, Applicable Devices = 452. EEADR, Power-on Reset, Brown-out Reset = 0000 0000. EEADR, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. EEADR, Wake-up via WDT or Interrupt = uuuu uuuu. EEDATA, Applicable Devices = 242. EEDATA, Applicable Devices = 442. EEDATA, Applicable Devices = 252. EEDATA, Applicable Devices = 452. EEDATA, Power-on Reset, Brown-out Reset = 0000 0000. EEDATA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. EEDATA, Wake-up via WDT or Interrupt = uuuu uuuu. EECON1, Applicable Devices = 242. EECON1, Applicable Devices = 442. EECON1, Applicable Devices = 252. EECON1, Applicable Devices = 452. EECON1, Power-on Reset, Brown-out Reset = xx-0 x000.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nEECON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = uu-0 u000. EECON1, Wake-up via WDT or Interrupt = uu-0 u000. EECON2, Applicable Devices = 242. EECON2, Applicable Devices = 442. EECON2, Applicable Devices = 252. EECON2, Applicable Devices = 452. EECON2, Power-on Reset, Brown-out Reset = ---- ----. EECON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- ----. EECON2, Wake-up via WDT or Interrupt = ---- ----\n= value depends on condition.\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as '0', q Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector ( 0008h or 0018h ).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for RESET value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other Oscillator modes, they are disabled and read '0'.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read '0'.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nIPR2, Applicable Devices = 242. IPR2, Applicable Devices = 442. IPR2, Applicable Devices = 252. IPR2, Applicable Devices = 452. IPR2, Power-on Reset, Brown-out Reset = ---1 1111. IPR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---1 1111. IPR2, Wake-up via WDT or Interrupt = ---u uuuu. PIR2, Applicable Devices = 242. PIR2, Applicable Devices = 442. PIR2, Applicable Devices = 252. PIR2, Applicable Devices = 452. PIR2, Power-on Reset, Brown-out Reset = ---0 0000. PIR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. PIR2, Wake-up via WDT or Interrupt = ---u uuuu (1). PIE2, Applicable Devices = 242. PIE2, Applicable Devices = 442. PIE2, Applicable Devices = 252. PIE2, Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = 452. PIE2, Power-on Reset, Brown-out Reset = ---0 0000. PIE2, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. PIE2, Wake-up via WDT or Interrupt = ---u uuuu. IPR1, Applicable Devices = 242. IPR1, Applicable Devices = 442. IPR1, Applicable Devices = 252. IPR1, Applicable Devices = 452. IPR1, Power-on Reset, Brown-out Reset = 1111 1111. IPR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. IPR1, Wake-up via WDT or Interrupt = uuuu uuuu. IPR1, Applicable Devices = 242. IPR1, Applicable Devices = 442. IPR1, Applicable Devices = 252. IPR1, Applicable Devices = 452. IPR1, Power-on Reset, Brown-out Reset = -111 1111. IPR1, MCLR Resets WDT Reset RESET Instruction Stack",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets = -111 1111. IPR1, Wake-up via WDT or Interrupt = -uuu uuuu. PIR1, Applicable Devices = 242. PIR1, Applicable Devices = 442. PIR1, Applicable Devices = 252. PIR1, Applicable Devices = 452. PIR1, Power-on Reset, Brown-out Reset = 0000 0000. PIR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PIR1, Wake-up via WDT or Interrupt = uuuu uuuu (1). PIR1, Applicable Devices = 242. PIR1, Applicable Devices = 442. PIR1, Applicable Devices = 252. PIR1, Applicable Devices = 452. PIR1, Power-on Reset, Brown-out Reset = -000 0000. PIR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. PIR1, Wake-up via WDT or Interrupt = -uuu uuuu (1). PIE1, Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = 242. PIE1, Applicable Devices = 442. PIE1, Applicable Devices = 252. PIE1, Applicable Devices = 452. PIE1, Power-on Reset, Brown-out Reset = 0000 0000. PIE1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PIE1, Wake-up via WDT or Interrupt = uuuu uuuu. PIE1, Applicable Devices = 242. PIE1, Applicable Devices = 442. PIE1, Applicable Devices = 252. PIE1, Applicable Devices = 452. PIE1, Power-on Reset, Brown-out Reset = -000 0000. PIE1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. PIE1, Wake-up via WDT or Interrupt = -uuu uuuu. TRISE, Applicable Devices = 242. TRISE, Applicable Devices = 442. TRISE, Applicable Devices = 252. TRISE, Applicable Devices = 452. TRISE, Power-on Reset, Brown-out Reset = 0000 -111. TRISE, MCLR",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets WDT Reset RESET Instruction Stack Resets = 0000 -111. TRISE, Wake-up via WDT or Interrupt = uuuu -uuu. TRISD, Applicable Devices = 242. TRISD, Applicable Devices = 442. TRISD, Applicable Devices = 252. TRISD, Applicable Devices = 452. TRISD, Power-on Reset, Brown-out Reset = 1111 1111. TRISD, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISD, Wake-up via WDT or Interrupt = uuuu uuuu. TRISC, Applicable Devices = 242. TRISC, Applicable Devices = 442. TRISC, Applicable Devices = 252. TRISC, Applicable Devices = 452. TRISC, Power-on Reset, Brown-out Reset = 1111 1111. TRISC, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISC, Wake-up via WDT or Interrupt = uuuu uuuu. TRISB, Applicable Devices = 242. TRISB, Applicable Devices = 442.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTRISB, Applicable Devices = 252. TRISB, Applicable Devices = 452. TRISB, Power-on Reset, Brown-out Reset = 1111 1111. TRISB, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISB, Wake-up via WDT or Interrupt = uuuu uuuu. TRISA (5,6), Applicable Devices = 242. TRISA (5,6), Applicable Devices = 442. TRISA (5,6), Applicable Devices = 252. TRISA (5,6), Applicable Devices = 452. TRISA (5,6), Power-on Reset, Brown-out Reset = -111 1111 (5). TRISA (5,6), MCLR Resets WDT Reset RESET Instruction Stack Resets = -111 1111 (5). TRISA (5,6), Wake-up via WDT or Interrupt = -uuu uuuu (5). LATE, Applicable Devices = 242. LATE, Applicable Devices = 442. LATE, Applicable Devices = 252. LATE, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n452. LATE, Power-on Reset, Brown-out Reset = ---- -xxx. LATE, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- -uuu. LATE, Wake-up via WDT or Interrupt = ---- -uuu. LATD, Applicable Devices = 242. LATD, Applicable Devices = 442. LATD, Applicable Devices = 252. LATD, Applicable Devices = 452. LATD, Power-on Reset, Brown-out Reset = xxxx xxxx. LATD, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATD, Wake-up via WDT or Interrupt = uuuu uuuu. LATC, Applicable Devices = 242. LATC, Applicable Devices = 442. LATC, Applicable Devices = 252. LATC, Applicable Devices = 452. LATC, Power-on Reset, Brown-out Reset = xxxx xxxx. LATC, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. LATC, Wake-up via WDT or Interrupt = uuuu uuuu. LATB, Applicable Devices = 242. LATB, Applicable Devices = 442. LATB, Applicable Devices = 252. LATB, Applicable Devices = 452. LATB, Power-on Reset, Brown-out Reset = xxxx xxxx. LATB, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATB, Wake-up via WDT or Interrupt = uuuu uuuu. LATA (5,6), Applicable Devices = 242. LATA (5,6), Applicable Devices = 442. LATA (5,6), Applicable Devices = 252. LATA (5,6), Applicable Devices = 452. LATA (5,6), Power-on Reset, Brown-out Reset = -xxx xxxx (5). LATA (5,6), MCLR Resets WDT Reset RESET Instruction Stack Resets = -uuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu (5). LATA (5,6), Wake-up via WDT or Interrupt = -uuu uuuu (5). PORTE, Applicable Devices = 242. PORTE, Applicable Devices = 442. PORTE, Applicable Devices = 252. PORTE, Applicable Devices = 452. PORTE, Power-on Reset, Brown-out Reset = ---- -000. PORTE, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- -000. PORTE, Wake-up via WDT or Interrupt = ---- -uuu. PORTD, Applicable Devices = 242. PORTD, Applicable Devices = 442. PORTD, Applicable Devices = 252. PORTD, Applicable Devices = 452. PORTD, Power-on Reset, Brown-out Reset = xxxx xxxx. PORTD, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PORTD, Wake-up via WDT or Interrupt = uuuu uuuu. PORTC, Applicable Devices = 242. PORTC, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n442. PORTC, Applicable Devices = 252. PORTC, Applicable Devices = 452. PORTC, Power-on Reset, Brown-out Reset = xxxx xxxx. PORTC, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PORTC, Wake-up via WDT or Interrupt = uuuu uuuu. PORTB, Applicable Devices = 242. PORTB, Applicable Devices = 442. PORTB, Applicable Devices = 252. PORTB, Applicable Devices = 452. PORTB, Power-on Reset, Brown-out Reset = xxxx xxxx. PORTB, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PORTB, Wake-up via WDT or Interrupt = uuuu uuuu. PORTA (5,6), Applicable Devices = 242. PORTA (5,6), Applicable Devices = 442. PORTA (5,6), Applicable Devices = 252. PORTA (5,6), Applicable Devices = 452. PORTA",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(5,6), Power-on Reset, Brown-out Reset = -x0x 0000 (5). PORTA (5,6), MCLR Resets WDT Reset RESET Instruction Stack Resets = -u0u 0000 (5). PORTA (5,6), Wake-up via WDT or Interrupt = -uuu uuuu (5)",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as '0', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector ( 0008h or 0018h ).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for RESET value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other Oscillator modes, they are disabled and read '0'.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they are read '0'.",
    "FIGURE 3-4: TIME-OUT SEQUENCE ON POWER-UP (MCLR NOT TIED TO VDD): CASE 1\nFIGURE 3-5:\nTIME-OUT SEQUENCE ON POWER-UP (MCLR NOT TIED TO VDD): CASE 2",
    "FIGURE 3-7: TIME-OUT SEQUENCE  ON POR W/ PLL ENABLED (MCLR TIED TO VDD)\nNote:\nTOST = 1024 clock cycles.\nTPLL \u2248 2 ms max. First three stages of the PWRT timer.",
    "PIC18FXX2\nNOTES:",
    "4.0 MEMORY ORGANIZATION\nThere  are  three  memory  blocks  in  Enhanced  MCU devices. These memory blocks are:\nGLYPH<129> Program Memory\nGLYPH<129> Data RAM\nGLYPH<129> Data EEPROM\nData  and  program  memory  use  separate  busses, which allows for concurrent access of these blocks.\nAdditional  detailed  information  for  FLASH  program memory and Data EEPROM is provided in Section 5.0 and Section 6.0, respectively.",
    "4.1 Program Memory Organization\nA 21-bit program counter is capable of addressing the 2-Mbyte program memory space. Accessing a location between the physically implemented memory and the 2-Mbyte address will cause a read of all '0's (a NOP instruction).\nThe PIC18F252 and PIC18F452 each have 32 Kbytes of FLASH memory, while the PIC18F242 and PIC18F442 have 16 Kbytes of FLASH. This means that PIC18FX52 devices can store up to 16K of single word instructions, and PIC18FX42 devices can store up to 8K of single word instructions.\nThe  RESET  vector  address  is  at  0000h  and  the interrupt vector addresses are at 0008h and 0018h.\nFigure 4-1 shows  the Program  Memory  Map  for PIC18F242/442  devices  and  Figure 4-2  shows  the Program Memory Map for PIC18F252/452 devices.",
    "PROGRAM MEMORY MAP AND STACK FOR PIC18F442/242\nFIGURE 4-2:",
    "4.2 Return Address Stack\nThe return address stack allows any combination of up to  31  program  calls  and  interrupts  to  occur.  The  PC (Program Counter) is pushed onto the stack when a CALL or RCALL instruction is executed, or an interrupt is acknowledged. The PC value is pulled off the stack on  a RETURN, RETLW or  a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN or CALL instructions.\nThe stack operates as a 31-word by 21-bit RAM and a 5-bit stack pointer, with the stack pointer initialized to 00000b after all RESETS. There is no RAM associated with stack pointer 00000b. This is only a RESET value. During a CALL type instruction, causing a push onto the stack,  the  stack  pointer  is  first  incremented  and  the RAM location pointed to by the stack pointer is written with  the  contents  of  the  PC.  During  a RETURN type instruction, causing a pop from the stack, the contents of  the  RAM  location  pointed  to  by  the  STKPTR  are transferred  to  the  PC  and  then  the  stack  pointer  is decremented.",
    "4.2 Return Address Stack\nThe stack space is not part of either program or data space. The stack pointer is readable and writable, and the address on the top of the stack is readable and writable through SFR registers. Data can also be pushed to,  or  popped  from,  the  stack  using  the  top-of-stack SFRs. Status bits indicate if the stack pointer is at, or beyond the 31 levels provided.",
    "4.2.1 TOP-OF-STACK ACCESS\nThe top of the stack is  readable  and writable. Three register  locations,  TOSU,  TOSH  and  TOSL  hold  the contents  of  the stack  location pointed  to by  the STKPTR  register.  This  allows  users  to  implement  a software stack if necessary. After a CALL, RCALL or interrupt, the software can read the pushed value by reading the TOSU, TOSH and TOSL registers. These values can be placed on a user defined software stack. At  return  time,  the  software  can  replace  the  TOSU, TOSH and TOSL and do a return.\nThe user must disable the global interrupt enable bits during this time to prevent inadvertent stack operations.",
    "4.2.2 RETURN STACK POINTER (STKPTR)\nThe STKPTR register contains the stack pointer value, the  STKFUL (stack  full)  status  bit,  and  the  STKUNF (stack  underflow)  status  bits.  Register 4-1  shows  the STKPTR register. The value of the stack pointer can be 0 through 31. The stack pointer increments when values are pushed onto the stack and decrements when values are popped off the stack. At RESET, the stack pointer value will be 0. The user may read and write the stack pointer value. This feature can be used by a Real Time Operating System for return stack maintenance.\nAfter the PC is pushed onto the stack 31 times (without popping any values off the stack), the STKFUL bit is set. The STKFUL bit can only be cleared in software or by a POR.",
    "4.2.2 RETURN STACK POINTER (STKPTR)\nThe action that takes place when the stack becomes full depends on the state of the STVREN (Stack Overflow Reset Enable) configuration bit. Refer to Section 20.0 for a description of the device configuration bits. If STVREN is set (default), the 31st push will push the (PC + 2) value onto the stack, set the STKFUL bit, and reset the device. The STKFUL bit will remain set and the stack pointer will be set to '0'.\nIf STVREN is cleared, the STKFUL bit will be set on the 31st push and the stack pointer will increment to 31. Any additional pushes will not overwrite the 31st push, and STKPTR will remain at 31.\nWhen  the  stack  has  been  popped  enough  times  to unload the stack, the next pop will return a value of zero to  the  PC  and  sets  the  STKUNF  bit,  while  the  stack pointer remains at 0. The STKUNF bit will remain set until cleared in software or a POR occurs.\nNote:",
    "4.2.2 RETURN STACK POINTER (STKPTR)\nReturning a value of zero to the PC on an underflow  has  the  effect  of  vectoring  the program to the RESET vector, where the stack conditions can be verified and appropriate actions can be taken.",
    "STKPTR REGISTER\nR/C-0, 1 = R/C-0. R/C-0, 2 = U-0. R/C-0, 3 = R/W-0. R/C-0, 4 = R/W-0. R/C-0, 5 = R/W-0. R/C-0, 6 = R/W-0. R/C-0, 7 = R/W-0. STKOVF, 1 = STKUNF. STKOVF, 2 = -. STKOVF, 3 = SP4. STKOVF, 4 = SP3. STKOVF, 5 = SP2. STKOVF, 6 = SP1. STKOVF, 7 = SP0\nbit 7\nbit 0\nbit 7 (1)\nSTKOVF:\nStack Full Flag bit\n1 = Stack became full or overflowed\n0 = Stack has not become full or overflowed\nbit 6 (1)\nSTKUNF: Stack Underflow Flag bit\n1 = Stack underflow occurred\n0 = Stack underflow did not occur\nbit 5\nUnimplemented: Read as '0'\nbit 4-0 SP4:SP0:",
    "STKPTR REGISTER\nStack Pointer Location bits\nNote 1: Bit 7 and bit 6 can only be cleared in user software or by a POR.\n\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "4.2.4 STACK FULL/UNDERFLOW RESETS\nSince the Top-of-Stack (TOS) is readable and writable, the ability to push values onto the stack and pull values off the stack without disturbing normal program execution is a desirable option. To push the current PC value onto  the  stack,  a PUSH instruction  can  be  executed. This will increment the stack pointer and load the current PC value onto the stack. TOSU, TOSH and TOSL can then be modified to place a return address on the stack.\nThe ability to pull the TOS value off of the stack and replace  it  with  the  value  that  was  previously  pushed onto the stack, without disturbing normal execution, is achieved by using the POP instruction. The POP instruction  discards  the  current  TOS  by  decrementing  the stack  pointer.  The  previous  value  pushed  onto  the stack then becomes the TOS value.",
    "4.2.4 STACK FULL/UNDERFLOW RESETS\nThese resets are enabled by programming the STVREN configuration bit.  When  the  STVREN  bit  is disabled, a full or underflow condition will set the appropriate STKFUL or STKUNF bit, but not cause a device RESET.  When  the  STVREN  bit  is  enabled,  a  full  or underflow will set the appropriate STKFUL or STKUNF bit and then cause a device RESET. The STKFUL or STKUNF bits are only cleared by the user software or a POR Reset.",
    "4.3 Fast Register Stack\nA 'fast interrupt return' option is available for interrupts. A  Fast  Register  Stack  is  provided  for  the  STATUS, WREG and BSR registers and are only one in depth. The stack is not readable or writable and is loaded with the current value of the corresponding register when the processor vectors for an interrupt. The values in the registers are then loaded back into the working registers, if the FAST RETURN instruction is used to return from the interrupt.\nA low or high priority interrupt source will push values into  the  stack  registers.  If  both  low  and  high  priority interrupts  are  enabled,  the  stack  registers  cannot  be used reliably for low priority interrupts. If a high priority interrupt occurs while servicing a low priority interrupt, the stack register values stored by the low priority interrupt will be overwritten.\nIf high priority interrupts are not disabled during low priority  interrupts,  users  must  save  the  key  registers  in software during a low priority interrupt.\nIf no interrupts are used, the fast register stack can be used to restore the STATUS, WREG and BSR registers at the end of a subroutine call. To use the fast register stack for a subroutine call, a FAST  CALL instruction must be executed.",
    "4.3 Fast Register Stack\nExample 4-1 shows a source code example that uses the fast register stack.",
    "4.4 PCL, PCLATH and PCLATU\nThe program counter (PC) specifies the address of the instruction  to  fetch  for  execution.  The  PC  is  21-bits wide. The low byte is called the PCL register. This register is readable and writable. The high byte is called the PCH register. This register contains the PC<15:8> bits and is not directly readable or writable. Updates to the  PCH  register  may  be  performed  through  the PCLATH register. The upper byte is called PCU. This register contains the PC<20:16> bits and is not directly readable or writable. Updates to the PCU register may be performed through the PCLATU register.\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the LSB of PCL is fixed to a value of '0'. The PC  increments by 2 to address sequential instructions in the program memory.\nThe CALL, RCALL, GOTO and  program  branch instructions write to the program counter directly. For these instructions, the contents of PCLATH  and PCLATU are not transferred to the program counter.",
    "4.4 PCL, PCLATH and PCLATU\nThe contents of PCLATH and PCLATU will be transferred  to  the  program  counter  by  an  operation  that writes PCL. Similarly, the upper two bytes of the program  counter  will  be  transferred  to  PCLATH  and PCLATU by an operation that reads PCL. This is useful for computed offsets to the PC (see Section 4.8.1).",
    "4.5 Clocking Scheme/Instruction Cycle\nThe clock  input  (from  OSC1)  is  internally  divided  by four to generate four non-overlapping quadrature clocks, namely Q1, Q2, Q3 and Q4. Internally, the program  counter  (PC)  is  incremented  every  Q1,  the instruction  is  fetched  from  the  program  memory  and latched into the instruction register in Q4. The instruction is decoded and executed during the following Q1 through Q4. The clocks and instruction execution flow are shown in Figure 4-4.\nCALL, 1 = ;STATUS, WREG, BSR ;SAVED IN FAST REGISTER ;STACK. SUB1 RETURN, 1 = ;RESTORE VALUES SAVED ;IN FAST REGISTER STACK",
    "4.6 Instruction Flow/Pipelining\nAn 'Instruction  Cycle'  consists  of  four  Q  cycles  (Q1, Q2, Q3 and Q4). The instruction fetch and execute are pipelined such that  fetch takes  one  instruction cycle, while  decode  and  execute  takes  another  instruction cycle. However, due to the pipelining, each instruction effectively  executes  in  one  cycle.  If  an  instruction causes  the  program  counter  to  change  (e.g., GOTO ) then two cycles are required to complete the instruction (Example 4-2).\nA  fetch  cycle  begins  with  the  program  counter  (PC) incrementing in Q1.\nIn the execution cycle, the fetched instruction is latched into  the  'Instruction  Register'  (IR)  in  cycle  Q1.  This instruction  is  then  decoded  and  executed  during  the Q2, Q3, and Q4 cycles. Data memory is read during Q2 (operand  read)  and  written  during  Q4  (destination write).",
    "EXAMPLE 4-2: INSTRUCTION PIPELINE FLOW\nAll instructions are single cycle, except for any program branches. These take two cycles since the fetch instruction is 'flushed' from the pipeline while the new instruction is being fetched and then executed.",
    "4.7 Instructions in Program Memory\nThe program memory is addressed in bytes. Instructions are stored as two bytes or four bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSB ='0'). Figure 4-5 shows an example of how instruction words are stored in the program memory. To maintain alignment with instruction boundaries, the PC increments in steps of 2 and the LSB will always read '0' (see Section 4.4).\nThe CALL and GOTO instructions have an absolute program memory address embedded into the instruction. Since instructions are always stored on word boundaries,  the  data  contained  in  the  instruction  is  a  word address.  The  word  address  is  written  to  PC<20:1>, which accesses the desired byte address in program memory. Instruction  #2  in  Figure 4-5  shows  how  the instruction ' GOTO 000006h ' is encoded in the program memory. Program branch instructions which encode a relative  address  offset  operate  in  the  same  manner. The offset value stored in a branch instruction represents the number of single word instructions that the PC  will  be  offset  by.  Section 20.0  provides  further details of the instruction set.",
    "FIGURE 4-5: INSTRUCTIONS IN PROGRAM MEMORY\nLSB = 1, 1 = LSB = 0. LSB = 1, 2 = Word Address \u2193. , 1 = . , 2 = 000000h. , 1 = . , 2 = 000002h. , 1 = . , 2 = 000004h. , 1 = . , 2 = 000006h. 0Fh, 1 = 55h. 0Fh, 2 = 000008h. EFh, 1 = 03h. EFh, 2 = 00000Ah. F0h, 1 = 00h. F0h, 2 = 00000Ch. C1h, 1 = 23h. C1h, 2 = 00000Eh. F4h, 1 = 56h. F4h, 2 = 000010h. , 1 = . , 2 = 000012h. , 1 = . , 2 = 000014h",
    "4.7.1 TWO-WORD INSTRUCTIONS\nThe PIC18FXX2 devices have four two-word instructions: MOVFF, CALL, GOTO and LFSR . The second word of these instructions has the 4 MSBs set to 1's and is a special kind of NOP instruction. The lower 12 bits of the second word contain data to be used by the instruction.  If  the  first  word  of  the  instruction  is  executed, the data in the second word is accessed. If the second word of the instruction is executed by itself (first word was skipped), it will execute as a NOP . This action is necessary when the two-word instruction is preceded by a conditional instruction that changes the PC. A program example that demonstrates this concept is shown in Example 4-3. Refer to Section 20.0 for further details of the instruction set.",
    "EXAMPLE 4-3: TWO-WORD INSTRUCTIONS\n0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:.Source Code = ; is RAM location 0?. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE 1:.Source Code = ; No, execute 2-word instruction. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = .",
    "EXAMPLE 4-3: TWO-WORD INSTRUCTIONS\n1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; 2nd operand holds address of REG2. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:.Source Code = ; continue code. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE",
    "EXAMPLE 4-3: TWO-WORD INSTRUCTIONS\n1:.Object Code = Object Code. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. 0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:.Source Code = ; is RAM location 0?. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE",
    "EXAMPLE 4-3: TWO-WORD INSTRUCTIONS\n1:.Source Code = ; Yes. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; 2nd operand becomes NOP. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:.Source Code = ; continue code",
    "4.8.2 TABLE READS/TABLE WRITES\nLookup tables are implemented two ways. These are:\nGLYPH<129> Computed GOTO\nGLYPH<129> Table Reads",
    "4.8.1 COMPUTED GOTO\nA computed GOTO is accomplished by adding an offset to the program counter ( ADDWF PCL ).\nA  lookup  table  can  be  formed  with  an ADDWF  PCL instruction and a group of RETLW  0xnn instructions. WREG is loaded with an offset into the  table  before executing a call to that table. The first instruction of the called routine is the ADDWF PCL instruction. The next instruction executed will be one of the RETLW  0xnn instructions, that returns the value 0xnn to the calling function.\nThe offset value (value in WREG) specifies the number of bytes that the program counter should advance.\nIn  this  method,  only  one  data  byte  may  be  stored  in each  instruction  location  and  room  on  the  return address stack is required.",
    "Note:\nThe ADDWF PCL instruction  does  not update  PCLATH  and  PCLATU.  A  read operation  on PCL must  be  performed  to update PCLATH and PCLATU.\nA  better  method  of  storing  data  in  program  memory allows 2 bytes of data to be stored in each instruction location.\nLookup table data may be stored 2 bytes per program word by using table reads and writes. The table pointer (TBLPTR)  specifies  the  byte  address  and  the  table latch (TABLAT) contains the data that is read from, or written to program memory. Data is transferred to/from program memory, one byte at a time.\nA description of the Table Read/Table Write operation is shown in Section 3.0.",
    "4.9 Data Memory Organization\nThe data memory is implemented as static RAM. Each register  in  the  data  memory  has  a  12-bit  address, allowing up to 4096 bytes of data memory. Figure 4-6 and Figure 4-7 show the data memory organization for the PIC18FXX2 devices.\nThe data memory map is divided into as many as 16 banks that contain 256 bytes each. The lower 4 bits of the  Bank  Select  Register  (BSR<3:0>)  select  which bank will be accessed. The upper 4 bits for the BSR are not implemented.\nThe data memory contains Special Function Registers (SFR)  and  General  Purpose  Registers  (GPR).  The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratch pad operations in the user's application. The SFRs start at the last location of Bank 15 (0xFFF) and extend downwards. Any remaining space beyond the SFRs in the Bank may be implemented as GPRs. GPRs start at the first location of Bank 0 and grow upwards. Any read of an unimplemented location will read as '0's.",
    "4.9 Data Memory Organization\nThe entire data memory may be accessed directly or indirectly. Direct addressing may require the use of the BSR register. Indirect addressing requires the use of a File Select Register (FSRn) and a corresponding Indirect  File  Operand (INDFn). Each FSR holds a 12-bit address value that can be used to access any location in the Data Memory map without banking.\nThe instruction  set  and  architecture  allow  operations across all banks. This may be accomplished by indirect addressing or by the use of the MOVFF instruction. The MOVFF instruction  is  a  two-word/two-cycle  instruction that moves a value from one register to another.\nTo  ensure  that  commonly  used  registers  (SFRs  and select  GPRs)  can  be  accessed  in  a  single  cycle, regardless of the current BSR values, an Access Bank is implemented. A segment of Bank 0 and a segment of Bank  15  comprise  the  Access  RAM.  Section 4.10 provides a detailed description of the Access RAM.",
    "4.9.1 GENERAL PURPOSE REGISTER FILE\nThe register file can be accessed either directly or indirectly. Indirect addressing operates using a File Select Register and corresponding Indirect File Operand. The operation of indirect addressing is shown in Section 4.12.\nEnhanced MCU devices may have banked memory in the GPR area. GPRs are not initialized by a Power-on Reset and are unchanged on all other RESETS.\nData RAM is available for use as GPR registers by all instructions. The top half of Bank 15 (0xF80 to 0xFFF) contains SFRs. All other banks of data memory contain GPR registers, starting with Bank 0.",
    "4.9.2 SPECIAL FUNCTION REGISTERS\nThe Special Function Registers (SFRs) are registers used by the CPU and Peripheral Modules for controlling the desired operation of the device. These registers  are  implemented  as  static  RAM.  A  list  of  these registers is given in Table 4-1 and Table 4-2.\nThe SFRs can be classified into two sets; those associated with the 'core' function and those related to the peripheral  functions.  Those  registers  related  to  the 'core' are described in this section, while those related to the operation of the peripheral features are described in the section of that peripheral feature.\nThe SFRs are typically distributed among the peripherals whose functions they control.\nThe unused SFR locations will be unimplemented and read as '0's. See Table 4-1 for addresses for the SFRs.\nFIGURE 4-6:\nDATA MEMORY MAP FOR PIC18F242/442",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFFFh, Name = TOSU. FFFh, Address = FDFh. FFFh, Name = INDF2 (3). FFFh, Address = FBFh. FFFh, Name = CCPR1H. FFFh, Address = F9Fh. FFFh, Name = IPR1. FFEh, Name = TOSH. FFEh, Address = FDEh. FFEh, Name = POSTINC2 (3). FFEh, Address = FBEh. FFEh, Name = CCPR1L. FFEh, Address = F9Eh. FFEh, Name = PIR1. FFDh, Name = TOSL. FFDh, Address = FDDh. FFDh, Name = POSTDEC2 (3). FFDh, Address = FBDh. FFDh, Name = CCP1CON. FFDh, Address = F9Dh. FFDh, Name = PIE1. FFCh, Name = STKPTR. FFCh, Address = FDCh. FFCh, Name = PREINC2 (3). FFCh, Address = FBCh.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFFCh, Name = CCPR2H. FFCh, Address = F9Ch. FFCh, Name = -. FFBh, Name = PCLATU. FFBh, Address = FDBh. FFBh, Name = PLUSW2 (3). FFBh, Address = FBBh. FFBh, Name = CCPR2L. FFBh, Address = F9Bh. FFBh, Name = -. FFAh, Name = PCLATH. FFAh, Address = FDAh. FFAh, Name = FSR2H. FFAh, Address = FBAh. FFAh, Name = CCP2CON. FFAh, Address = F9Ah. FFAh, Name = -. FF9h, Name = PCL. FF9h, Address = FD9h. FF9h, Name = FSR2L. FF9h, Address = FB9h. FF9h, Name = -. FF9h, Address = F99h. FF9h, Name = -. FF8h, Name = TBLPTRU. FF8h, Address = FD8h. FF8h,",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nName = STATUS. FF8h, Address = FB8h. FF8h, Name = -. FF8h, Address = F98h. FF8h, Name = -. FF7h, Name = TBLPTRH. FF7h, Address = FD7h. FF7h, Name = TMR0H. FF7h, Address = FB7h. FF7h, Name = -. FF7h, Address = F97h. FF7h, Name = -. FF6h, Name = TBLPTRL. FF6h, Address = FD6h. FF6h, Name = TMR0L. FF6h, Address = FB6h. FF6h, Name = -. FF6h, Address = F96h. FF6h, Name = TRISE (2). FF5h, Name = TABLAT. FF5h, Address = FD5h. FF5h, Name = T0CON. FF5h, Address = FB5h. FF5h, Name = -. FF5h, Address =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nF95h. FF5h, Name = TRISD (2). FF4h, Name = PRODH. FF4h, Address = FD4h. FF4h, Name = -. FF4h, Address = FB4h. FF4h, Name = -. FF4h, Address = F94h. FF4h, Name = TRISC. FF3h, Name = PRODL. FF3h, Address = FD3h. FF3h, Name = OSCCON. FF3h, Address = FB3h. FF3h, Name = TMR3H. FF3h, Address = F93h. FF3h, Name = TRISB. FF2h, Name = INTCON. FF2h, Address = FD2h. FF2h, Name = LVDCON. FF2h, Address = FB2h. FF2h, Name = TMR3L. FF2h, Address = F92h. FF2h, Name = TRISA. FF1h, Name = INTCON2. FF1h, Address =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFD1h. FF1h, Name = WDTCON. FF1h, Address = FB1h. FF1h, Name = T3CON. FF1h, Address = F91h. FF1h, Name = -. FF0h, Name = INTCON3. FF0h, Address = FD0h. FF0h, Name = RCON. FF0h, Address = FB0h. FF0h, Name = -. FF0h, Address = F90h. FF0h, Name = -. FEFh, Name = INDF0 (3). FEFh, Address = FCFh. FEFh, Name = TMR1H. FEFh, Address = FAFh. FEFh, Name = SPBRG. FEFh, Address = F8Fh. FEFh, Name = -. FEEh, Name = POSTINC0 (3). FEEh, Address = FCEh. FEEh, Name = TMR1L. FEEh, Address = FAEh. FEEh, Name = RCREG.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFEEh, Address = F8Eh. FEEh, Name = -. FEDh, Name = POSTDEC0 (3). FEDh, Address = FCDh. FEDh, Name = T1CON. FEDh, Address = FADh. FEDh, Name = TXREG. FEDh, Address = F8Dh. FEDh, Name = LATE (2). FECh, Name = PREINC0 (3). FECh, Address = FCCh. FECh, Name = TMR2. FECh, Address = FACh. FECh, Name = TXSTA. FECh, Address = F8Ch. FECh, Name = LATD (2). FEBh, Name = PLUSW0 (3). FEBh, Address = FCBh. FEBh, Name = PR2. FEBh, Address = FABh. FEBh, Name = RCSTA. FEBh, Address = F8Bh. FEBh, Name = LATC. FEAh, Name = FSR0H. FEAh, Address = FCAh. FEAh, Name = T2CON. FEAh, Address = FAAh.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFEAh, Name = -. FEAh, Address = F8Ah. FEAh, Name = LATB. FE9h, Name = FSR0L. FE9h, Address = FC9h. FE9h, Name = SSPBUF. FE9h, Address = FA9h. FE9h, Name = EEADR. FE9h, Address = F89h. FE9h, Name = LATA. FE8h, Name = WREG. FE8h, Address = FC8h. FE8h, Name = SSPADD. FE8h, Address = FA8h. FE8h, Name = EEDATA. FE8h, Address = F88h. FE8h, Name = -. FE7h, Name = INDF1 (3). FE7h, Address = FC7h. FE7h, Name = SSPSTAT. FE7h, Address = FA7h. FE7h, Name = EECON2. FE7h, Address = F87h. FE7h, Name = -. FE6h, Name = POSTINC1",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\n(3). FE6h, Address = FC6h. FE6h, Name = SSPCON1. FE6h, Address = FA6h. FE6h, Name = EECON1. FE6h, Address = F86h. FE6h, Name = -. FE5h, Name = POSTDEC1 (3). FE5h, Address = FC5h. FE5h, Name = SSPCON2. FE5h, Address = FA5h. FE5h, Name = -. FE5h, Address = F85h. FE5h, Name = -. FE4h, Name = PREINC1 (3). FE4h, Address = FC4h. FE4h, Name = ADRESH. FE4h, Address = FA4h. FE4h, Name = -. FE4h, Address = F84h. FE4h, Name = PORTE (2). FE3h, Name = PLUSW1 (3). FE3h, Address = FC3h. FE3h, Name = ADRESL. FE3h, Address =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFA3h. FE3h, Name = -. FE3h, Address = F83h. FE3h, Name = PORTD (2). FE2h, Name = FSR1H. FE2h, Address = FC2h. FE2h, Name = ADCON0. FE2h, Address = FA2h. FE2h, Name = IPR2. FE2h, Address = F82h. FE2h, Name = PORTC. FE1h, Name = FSR1L. FE1h, Address = FC1h. FE1h, Name = ADCON1. FE1h, Address = FA1h. FE1h, Name = PIR2. FE1h, Address = F81h. FE1h, Name = PORTB. FE0h, Name = BSR. FE0h, Address = FC0h. FE0h, Name = -. FE0h, Address = FA0h. FE0h, Name = PIE2. FE0h, Address = F80h. FE0h, Name = PORTA",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nNote 1: Unimplemented registers are read as '0'.\n2: This register is not available on PIC18F2X2 devices.\n3: This is not a physical register.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nTOSU, Bit 7 = -. TOSU, Bit 6 = -. TOSU, Bit 5 = -. TOSU, Bit 4 = Top-of-Stack upper Byte (TOS<20:16>). TOSU, Bit 3 = Top-of-Stack upper Byte (TOS<20:16>). TOSU, Bit 2 = Top-of-Stack upper Byte (TOS<20:16>). TOSU, Bit 1 = Top-of-Stack upper Byte (TOS<20:16>). TOSU, Bit 0 = Top-of-Stack upper Byte (TOS<20:16>). TOSU, Value on POR, BOR = ---0. TOSU, Value on POR, BOR = 0000. TOSU, Details on page: = 37. TOSH, Bit 7 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 6 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 5 = Top-of-Stack High Byte (TOS<15:8>).",
    "TABLE 4-2: REGISTER FILE SUMMARY\nTOSH, Bit 4 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 3 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 2 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 1 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 0 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Value on POR, BOR = 0000. TOSH, Value on POR, BOR = 0000. TOSH, Details on page: = 37. TOSL, Bit 7 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 6 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 5 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 4 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 3",
    "TABLE 4-2: REGISTER FILE SUMMARY\n= Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 2 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 1 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 0 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Value on POR, BOR = 0000. TOSL, Value on POR, BOR = 0000. TOSL, Details on page: = 37. STKPTR, Bit 7 = STKFUL. STKPTR, Bit 6 = STKUNF. STKPTR, Bit 5 = -. STKPTR, Bit 4 = Return Stack Pointer. STKPTR, Bit 3 = Return Stack Pointer. STKPTR, Bit 2 = Return Stack Pointer. STKPTR, Bit 1 = Return Stack Pointer. STKPTR, Bit 0 = Return Stack Pointer. STKPTR, Value on POR, BOR = 00-0. STKPTR, Value on POR, BOR =",
    "TABLE 4-2: REGISTER FILE SUMMARY\n0000. STKPTR, Details on page: = 38. PCLATU, Bit 7 = -. PCLATU, Bit 6 = -. PCLATU, Bit 5 = -. PCLATU, Bit 4 = Holding Register for PC<20:16>. PCLATU, Bit 3 = Holding Register for PC<20:16>. PCLATU, Bit 2 = Holding Register for PC<20:16>. PCLATU, Bit 1 = Holding Register for PC<20:16>. PCLATU, Bit 0 = Holding Register for PC<20:16>. PCLATU, Value on POR, BOR = ---0. PCLATU, Value on POR, BOR = 0000. PCLATU, Details on page: = 39. PCLATH, Bit 7 = Holding Register for PC<15:8>. PCLATH, Bit 6 = Holding Register for PC<15:8>. PCLATH, Bit 5 = Holding Register for PC<15:8>. PCLATH, Bit 4 = Holding Register for PC<15:8>. PCLATH, Bit 3 = Holding Register for",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPC<15:8>. PCLATH, Bit 2 = Holding Register for PC<15:8>. PCLATH, Bit 1 = Holding Register for PC<15:8>. PCLATH, Bit 0 = Holding Register for PC<15:8>. PCLATH, Value on POR, BOR = 0000. PCLATH, Value on POR, BOR = 0000. PCLATH, Details on page: = 39. PCL, Bit 7 = PC Low Byte (PC<7:0>). PCL, Bit 6 = PC Low Byte (PC<7:0>). PCL, Bit 5 = PC Low Byte (PC<7:0>). PCL, Bit 4 = PC Low Byte (PC<7:0>). PCL, Bit 3 = PC Low Byte (PC<7:0>). PCL, Bit 2 = PC Low Byte (PC<7:0>). PCL, Bit 1 = PC Low Byte (PC<7:0>). PCL, Bit 0 = PC Low Byte (PC<7:0>). PCL, Value on POR,",
    "TABLE 4-2: REGISTER FILE SUMMARY\nBOR = 0000. PCL, Value on POR, BOR = 0000. PCL, Details on page: = 39. TBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit21 (2). TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on POR, BOR = --00. TBLPTRU, Value on POR, BOR = 0000. TBLPTRU, Details on page: = 58. TBLPTRH, Bit 7 = Program Memory Table Pointer High Byte",
    "TABLE 4-2: REGISTER FILE SUMMARY\n(TBLPTR<15:8>). TBLPTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Value on POR, BOR = 0000. TBLPTRH, Value on POR, BOR = 0000. TBLPTRH, Details on page: = 58. TBLPTRL, Bit 7 = Program Memory Table Pointer Low Byte",
    "TABLE 4-2: REGISTER FILE SUMMARY\n(TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Value on POR, BOR = 0000. TBLPTRL, Value on POR, BOR = 0000. TBLPTRL, Details on page: = 58. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table",
    "TABLE 4-2: REGISTER FILE SUMMARY\nLatch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on POR, BOR = 0000. TABLAT, Value on POR, BOR = 0000. TABLAT, Details on page: = 58. PRODH, Bit 7 = Product Register High Byte. PRODH, Bit 6 = Product Register High Byte. PRODH, Bit 5 = Product Register High Byte. PRODH, Bit 4 = Product Register High Byte. PRODH, Bit 3 = Product Register High Byte. PRODH, Bit 2 = Product Register High Byte. PRODH, Bit 1 = Product Register High Byte. PRODH, Bit 0 = Product Register High Byte. PRODH, Value on POR, BOR = xxxx. PRODH, Value on POR, BOR = xxxx. PRODH, Details on page: = 71. PRODL, Bit 7 = Product Register Low Byte. PRODL, Bit 6 = Product Register Low",
    "TABLE 4-2: REGISTER FILE SUMMARY\nByte. PRODL, Bit 5 = Product Register Low Byte. PRODL, Bit 4 = Product Register Low Byte. PRODL, Bit 3 = Product Register Low Byte. PRODL, Bit 2 = Product Register Low Byte. PRODL, Bit 1 = Product Register Low Byte. PRODL, Bit 0 = Product Register Low Byte. PRODL, Value on POR, BOR = xxxx. PRODL, Value on POR, BOR = xxxx. PRODL, Details on page: = 71. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Details on page: = 75. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nINTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = -. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = -. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111. INTCON2, Value on POR, BOR = -1-1. INTCON2, Details on page: = 76. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 11-0. INTCON3, Value on POR, BOR = 0-00. INTCON3, Details on page: = 77. INDF0, Bit 7 = Uses contents of FSR0 to address data memory",
    "TABLE 4-2: REGISTER FILE SUMMARY\n- value of FSR0 not changed (not a physical register). INDF0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Value on POR,",
    "TABLE 4-2: REGISTER FILE SUMMARY\nBOR = . INDF0, Value on POR, BOR = n/a. INDF0, Details on page: = 50. POSTINC0 POSTDEC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0 POSTDEC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0 POSTDEC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0 POSTDEC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0 POSTDEC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0 POSTDEC0, Bit 2 = Uses contents of FSR0",
    "TABLE 4-2: REGISTER FILE SUMMARY\nto address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0 POSTDEC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0 POSTDEC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0 POSTDEC0, Value on POR, BOR = n/a. POSTINC0 POSTDEC0, Value on POR, BOR = . POSTINC0 POSTDEC0, Details on page: = 50 50. PREINC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). PREINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). PREINC0, Bit 5 = Uses contents of FSR0 to address data memory - value",
    "TABLE 4-2: REGISTER FILE SUMMARY\nof FSR0 post-decremented (not a physical register). PREINC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). PREINC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). PREINC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). PREINC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). PREINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). PREINC0, Value on POR, BOR = . PREINC0, Value on POR, BOR = . PREINC0, Details on page: = 50. PLUSW0, Bit 7 = . PLUSW0, Bit 6",
    "TABLE 4-2: REGISTER FILE SUMMARY\n= . PLUSW0, Bit 5 = . PLUSW0, Bit 4 = . PLUSW0, Bit 3 = . PLUSW0, Bit 2 = . PLUSW0, Bit 1 = . PLUSW0, Bit 0 = . PLUSW0, Value on POR, BOR = n/a. PLUSW0, Value on POR, BOR = n/a. PLUSW0, Details on page: = . , Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses FSR0 to Offset by WREG.. , Bit 6 = contents of value in. , Bit 5 = address data. , Bit 4 = memory -. , Bit 3 = value of FSR0. , Bit 2 = (not a physical. , Bit 1 = register).. , Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses FSR0 to Offset by WREG.. , Value on POR, BOR = n/a. , Value on POR, BOR = . , Details on",
    "TABLE 4-2: REGISTER FILE SUMMARY\npage: = 50. FSR0H, Bit 7 = -. FSR0H, Bit 6 = -. FSR0H, Bit 5 = -. FSR0H, Bit 4 = -. FSR0H, Bit 3 = Indirect Data. FSR0H, Bit 2 = Memory. FSR0H, Bit 1 = Address Pointer. FSR0H, Bit 0 = 0 High Byte. FSR0H, Value on POR, BOR = ---- 0000. FSR0H, Value on POR, BOR = . FSR0H, Details on page: = 50. FSR0L, Bit 7 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 6 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 5 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 4 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 3 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 2 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 1 = Indirect Data Memory Address Pointer",
    "TABLE 4-2: REGISTER FILE SUMMARY\n0 Low Byte. FSR0L, Bit 0 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Value on POR, BOR = xxxx. FSR0L, Value on POR, BOR = xxxx. FSR0L, Details on page: = 50. WREG, Bit 7 = Working Register. WREG, Bit 6 = Working Register. WREG, Bit 5 = Working Register. WREG, Bit 4 = Working Register. WREG, Bit 3 = Working Register. WREG, Bit 2 = Working Register. WREG, Bit 1 = Working Register. WREG, Bit 0 = Working Register. WREG, Value on POR, BOR = xxxx xxxx. WREG, Value on POR, BOR = . WREG, Details on page: = n/a. INDF1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 5 = Uses contents of",
    "TABLE 4-2: REGISTER FILE SUMMARY\nFSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Value on POR, BOR = n/a. INDF1, Value on POR, BOR = . INDF1, Details on page: = 50. POSTINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1",
    "TABLE 4-2: REGISTER FILE SUMMARY\npost-incremented (not a physical register). POSTINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 0 = Uses contents of FSR1 to address data memory - value",
    "TABLE 4-2: REGISTER FILE SUMMARY\nof FSR1 post-incremented (not a physical register). POSTINC1, Value on POR, BOR = n/a. POSTINC1, Value on POR, BOR = . POSTINC1, Details on page: = 50. POSTDEC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 2 = Uses contents of",
    "TABLE 4-2: REGISTER FILE SUMMARY\nFSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Value on POR, BOR = n/a. POSTDEC1, Value on POR, BOR = . POSTDEC1, Details on page: = 50. PREINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register).",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPREINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Value on POR, BOR = n/a. PREINC1, Value on POR, BOR = . PREINC1, Details on page: = 50. PLUSW1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 (not a physical",
    "TABLE 4-2: REGISTER FILE SUMMARY\nregister). Offset by value in WREG.. PLUSW1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 (not a physical register). Offset by value in WREG.. PLUSW1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 (not a physical register). Offset by value in WREG.. PLUSW1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 (not a physical register). Offset by value in WREG.. PLUSW1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 (not a physical register). Offset by value in WREG.. PLUSW1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 (not a physical register). Offset by value in WREG.. PLUSW1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 (not a physical register). Offset by value in WREG.. PLUSW1, Bit 0 = Uses contents",
    "TABLE 4-2: REGISTER FILE SUMMARY\nof FSR1 to address data memory - value of FSR1 (not a physical register). Offset by value in WREG.. PLUSW1, Value on POR, BOR = n/a. PLUSW1, Value on POR, BOR = . PLUSW1, Details on page: = 50. FSR1H, Bit 7 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 6 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 5 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 4 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 3 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 2 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 1 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 0 = - - - - Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Value on POR, BOR =",
    "TABLE 4-2: REGISTER FILE SUMMARY\n----. FSR1H, Value on POR, BOR = 0000. FSR1H, Details on page: = 50. FSR1L, Bit 7 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 6 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 5 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 4 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 3 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 2 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 1 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 0 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Value on POR, BOR = xxxx. FSR1L, Value on POR, BOR = xxxx. FSR1L, Details on page: = 50. BSR, Bit 7 = - - - - Bank Select Register. BSR, Bit 6 = - - - - Bank Select Register. BSR, Bit 5 = - - - -",
    "TABLE 4-2: REGISTER FILE SUMMARY\nBank Select Register. BSR, Bit 4 = - - - - Bank Select Register. BSR, Bit 3 = - - - - Bank Select Register. BSR, Bit 2 = - - - - Bank Select Register. BSR, Bit 1 = - - - - Bank Select Register. BSR, Bit 0 = - - - - Bank Select Register. BSR, Value on POR, BOR = ----. BSR, Value on POR, BOR = 0000. BSR, Details on page: = 49. INDF2, Bit 7 = Uses FSR2 to. INDF2, Bit 6 = contents of. INDF2, Bit 5 = address data. INDF2, Bit 4 = memory -. INDF2, Bit 3 = value of FSR2. INDF2, Bit 2 = not changed. INDF2, Bit 1 = (not a physical. INDF2, Bit 0 = register). INDF2, Value on POR, BOR = n/a. INDF2, Value on POR, BOR = . INDF2, Details on page: = 50. POSTINC2, Bit 7 = Uses contents",
    "TABLE 4-2: REGISTER FILE SUMMARY\nof FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit",
    "TABLE 4-2: REGISTER FILE SUMMARY\n0 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Value on POR, BOR = . POSTINC2, Value on POR, BOR = n/a. POSTINC2, Details on page: = 50. POSTDEC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical",
    "TABLE 4-2: REGISTER FILE SUMMARY\nregister). POSTDEC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Value on POR, BOR = n/a. POSTDEC2, Value on POR, BOR = . POSTDEC2, Details on page: = 50. PREINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2",
    "TABLE 4-2: REGISTER FILE SUMMARY\npre-incremented (not a physical register). PREINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Value on POR, BOR = . PREINC2, Value on POR, BOR = n/a. PREINC2, Details on page: = 50. PLUSW2, Bit 7 = Uses contents of FSR2 to address",
    "TABLE 4-2: REGISTER FILE SUMMARY\ndata memory - value of FSR2 (not a physical register). Offset by value in WREG.. PLUSW2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 (not a physical register). Offset by value in WREG.. PLUSW2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 (not a physical register). Offset by value in WREG.. PLUSW2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 (not a physical register). Offset by value in WREG.. PLUSW2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 (not a physical register). Offset by value in WREG.. PLUSW2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 (not a physical register). Offset by value in WREG.. PLUSW2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 (not a physical register). Offset by value in",
    "TABLE 4-2: REGISTER FILE SUMMARY\nWREG.. PLUSW2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 (not a physical register). Offset by value in WREG.. PLUSW2, Value on POR, BOR = n/a. PLUSW2, Value on POR, BOR = . PLUSW2, Details on page: = 50. FSR2H, Bit 7 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 6 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 5 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 4 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 3 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 2 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 1 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Bit 0 = - - - - Indirect Data Memory Address Pointer 2 High. FSR2H, Value on",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPOR, BOR = . FSR2H, Value on POR, BOR = . FSR2H, Details on page: = 50. , Bit 7 = . , Bit 6 = . , Bit 5 = . , Bit 4 = . , Bit 3 = Byte. , Bit 2 = Byte. , Bit 1 = Byte. , Bit 0 = Byte. , Value on POR, BOR = ----. , Value on POR, BOR = 0000. , Details on page: = 50. FSR2L STATUS TMR0H, Bit 7 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS TMR0H, Bit 6 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS TMR0H, Bit 5 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS TMR0H, Bit 4 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC",
    "TABLE 4-2: REGISTER FILE SUMMARY\nC Timer0 Register High Byte. FSR2L STATUS TMR0H, Bit 3 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS TMR0H, Bit 2 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS TMR0H, Bit 1 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS TMR0H, Bit 0 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS TMR0H, Value on POR, BOR = xxxx xxxx ---x. FSR2L STATUS TMR0H, Value on POR, BOR = xxxx 0000 0000. FSR2L STATUS TMR0H, Details on page: = 52 105. TMR0L, Bit 7 = Timer0 Register Low Byte. TMR0L, Bit",
    "TABLE 4-2: REGISTER FILE SUMMARY\n6 = Timer0 Register Low Byte. TMR0L, Bit 5 = Timer0 Register Low Byte. TMR0L, Bit 4 = Timer0 Register Low Byte. TMR0L, Bit 3 = Timer0 Register Low Byte. TMR0L, Bit 2 = Timer0 Register Low Byte. TMR0L, Bit 1 = Timer0 Register Low Byte. TMR0L, Bit 0 = Timer0 Register Low Byte. TMR0L, Value on POR, BOR = xxxx. TMR0L, Value on POR, BOR = xxxx. TMR0L, Details on page: = 105. T0CON, Bit 7 = TMR0ON T08BIT T0CS. T0CON, Bit 6 = . T0CON, Bit 5 = . T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR =",
    "TABLE 4-2: REGISTER FILE SUMMARY\n1111. T0CON, Value on POR, BOR = 1111. T0CON, Details on page: = 103\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read '0' in all other Oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers and bits are reserved on the PIC18F2X2 devices; always maintain these clear.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nOSCCON, Bit 7 = -. OSCCON, Bit 6 = -. OSCCON, Bit 5 = -. OSCCON, Bit 4 = -. OSCCON, Bit 3 = -. OSCCON, Bit 2 = -. OSCCON, Bit 1 = -. OSCCON, Bit 0 = SCS. OSCCON, Value on POR, BOR = ---- ---0. OSCCON, Details on page: = 21. LVDCON, Bit 7 = -. LVDCON, Bit 6 = -. LVDCON, Bit 5 = IRVST. LVDCON, Bit 4 = LVDEN. LVDCON, Bit 3 = LVDL3. LVDCON, Bit 2 = LVDL2 LVDL1. LVDCON, Bit 1 = LVDL0. LVDCON, Bit 0 = --00. LVDCON, Value on POR, BOR = 0101. LVDCON, Details on page: = 191. WDTCON, Bit 7 = -. WDTCON, Bit 6 = -. WDTCON, Bit 5 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n-. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = - -. WDTCON, Bit 1 = SWDTE. WDTCON, Bit 0 = ----. WDTCON, Value on POR, BOR = ---0. WDTCON, Details on page: = 203. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD POR. RCON, Bit 1 = BOR. RCON, Bit 0 = 0--1. RCON, Value on POR, BOR = 11qq. RCON, Details on page: = 53, 28, 84. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = xxxx. TMR1H, Value on POR, BOR = xxxx. TMR1H, Details on page: = 107. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = xxxx. TMR1L, Value on POR, BOR = xxxx. TMR1L, Details on page: = 107. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nT1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC TMR1CS. T1CON, Bit 1 = TMR1ON. T1CON, Bit 0 = 0-00. T1CON, Value on POR, BOR = 0000. T1CON, Details on page: = 107. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = 0000. TMR2, Value on POR, BOR = 0000. TMR2, Details on page: = 111. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nPeriod Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = 1111. PR2, Value on POR, BOR = 1111. PR2, Details on page: = 112. T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON T2CKPS1. T2CON, Bit 1 = T2CKPS0. T2CON, Bit 0 = -000. T2CON, Value on POR, BOR = 0000. T2CON, Details on page: = 111. SSPBUF, Bit 7 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = SSP Receive Buffer/Transmit Register.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nSSPBUF, Bit 5 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 0 = xxxx. SSPBUF, Value on POR, BOR = xxxx. SSPBUF, Details on page: = 125. SSPADD, Bit 7 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 6 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 5 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 4 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nRegister in I 2 C Master mode.. SSPADD, Bit 3 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 2 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 1 = SSP Address Register in I 2 C Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 0 = 0000. SSPADD, Value on POR, BOR = 0000. SSPADD, Details on page: = 134. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W UA. SSPSTAT, Bit 1 = BF. SSPSTAT, Bit 0 = 0000. SSPSTAT, Value on POR, BOR = 0000. SSPSTAT, Details",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\non page: = 126. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 = SSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3 = SSPM3. SSPCON1, Bit 2 = SSPM2 SSPM1. SSPCON1, Bit 1 = SSPM0. SSPCON1, Bit 0 = 0000. SSPCON1, Value on POR, BOR = 0000. SSPCON1, Details on page: = 127. SSPCON2, Bit 7 = GCEN. SSPCON2, Bit 6 = ACKSTAT. SSPCON2, Bit 5 = ACKDT. SSPCON2, Bit 4 = ACKEN. SSPCON2, Bit 3 = RCEN. SSPCON2, Bit 2 = PEN RSEN. SSPCON2, Bit 1 = SEN. SSPCON2, Bit 0 = 0000. SSPCON2, Value on POR, BOR = 0000. SSPCON2, Details on page: = 137.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = xxxx. ADRESH, Value on POR, BOR = xxxx. ADRESH, Details on page: = 187,188. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nxxxx. ADRESL, Value on POR, BOR = xxxx. ADRESL, Details on page: = 187,188. ADCON0, Bit 7 = ADCS1. ADCON0, Bit 6 = ADCS0. ADCON0, Bit 5 = CHS2. ADCON0, Bit 4 = CHS1. ADCON0, Bit 3 = CHS0. ADCON0, Bit 2 = GO/DONE -. ADCON0, Bit 1 = ADON. ADCON0, Bit 0 = 0000. ADCON0, Value on POR, BOR = 00-0. ADCON0, Details on page: = 181. ADCON1, Bit 7 = ADFM. ADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 = -. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2 PCFG1. ADCON1, Bit 1 = PCFG0. ADCON1, Bit 0 = 00--. ADCON1, Value on POR, BOR =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n0000. ADCON1, Details on page: = 182. CCPR1H, Bit 7 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 6 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 5 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 4 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 3 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 2 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 1 = Capture/Compare/PWM Register1 High Byte. CCPR1H, Bit 0 = xxxx. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Details on page: = 121, 123. CCPR1L, Bit 7 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 6 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 5 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nCapture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 4 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 3 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 2 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 1 = Capture/Compare/PWM Register1 Low Byte. CCPR1L, Bit 0 = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Details on page: = 121, 123. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2 CCP1M1. CCP1CON, Bit 1 = CCP1M0. CCP1CON, Bit 0 = --00. CCP1CON, Value on",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nPOR, BOR = 0000. CCP1CON, Details on page: = 117. CCPR2H, Bit 7 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 6 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 5 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 4 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 3 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 2 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 1 = Capture/Compare/PWM Register2 High Byte. CCPR2H, Bit 0 = xxxx. CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Details on page: = 121, 123. CCPR2L, Bit 7 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 6 = Capture/Compare/PWM Register2 Low Byte. CCPR2L,",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nBit 5 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 4 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 3 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 2 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 1 = Capture/Compare/PWM Register2 Low Byte. CCPR2L, Bit 0 = xxxx. CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Details on page: = 121, 123. CCP2CON, Bit 7 = -. CCP2CON, Bit 6 = -. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2 CCP2M1. CCP2CON, Bit 1 = CCP2M0. CCP2CON, Bit 0 = --00. CCP2CON,",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nValue on POR, BOR = 0000. CCP2CON, Details on page: = 117. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit 2 = Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit 0 = xxxx. TMR3H, Value on POR, BOR = xxxx. TMR3H, Details on page: = 113. TMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte. TMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4 = Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register Low Byte.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nTMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = xxxx. TMR3L, Value on POR, BOR = xxxx. TMR3L, Details on page: = 113. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS TMR3ON. T3CON, Bit 0 = 0000. T3CON, Value on POR, BOR = 0000. T3CON, Details on page: = 113. SPBRG, Bit 7 = USART1 Baud Rate Generator. SPBRG, Bit 6 = USART1 Baud Rate Generator. SPBRG, Bit 5 = USART1 Baud Rate Generator.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nSPBRG, Bit 4 = USART1 Baud Rate Generator. SPBRG, Bit 3 = USART1 Baud Rate Generator. SPBRG, Bit 2 = USART1 Baud Rate Generator. SPBRG, Bit 1 = USART1 Baud Rate Generator. SPBRG, Bit 0 = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Details on page: = 168. RCREG, Bit 7 = USART1 Receive Register. RCREG, Bit 6 = USART1 Receive Register. RCREG, Bit 5 = USART1 Receive Register. RCREG, Bit 4 = USART1 Receive Register. RCREG, Bit 3 = USART1 Receive Register. RCREG, Bit 2 = USART1 Receive Register. RCREG, Bit 1 = USART1 Receive Register. RCREG, Bit 0 = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Details on page: = 175, 178, 180. TXREG, Bit 7 = USART1 Transmit Register. TXREG, Bit 6 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nUSART1 Transmit Register. TXREG, Bit 5 = USART1 Transmit Register. TXREG, Bit 4 = USART1 Transmit Register. TXREG, Bit 3 = USART1 Transmit Register. TXREG, Bit 2 = USART1 Transmit Register. TXREG, Bit 1 = USART1 Transmit Register. TXREG, Bit 0 = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Details on page: = 173, 176, 179. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH TRMT. TXSTA, Bit 1 = TX9D. TXSTA, Bit 0 = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Details on page: = 166. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nRCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Details on page: = 167. EEADR, Bit 7 = Data EEPROM Address Register. EEADR, Bit 6 = Data EEPROM Address Register. EEADR, Bit 5 = Data EEPROM Address Register. EEADR, Bit 4 = Data EEPROM Address Register. EEADR, Bit 3 = Data EEPROM Address Register. EEADR, Bit 2 = Data EEPROM Address Register. EEADR, Bit 1 = Data EEPROM Address Register. EEADR, Bit 0 = 0000. EEADR, Value on POR, BOR = 0000. EEADR, Details on page: = 65, 69. EEDATA, Bit 7 = Data EEPROM Data Register. EEDATA, Bit 6 = Data EEPROM Data Register. EEDATA, Bit 5 = Data EEPROM Data Register. EEDATA,",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nBit 4 = Data EEPROM Data Register. EEDATA, Bit 3 = Data EEPROM Data Register. EEDATA, Bit 2 = Data EEPROM Data Register. EEDATA, Bit 1 = Data EEPROM Data Register. EEDATA, Bit 0 = 0000. EEDATA, Value on POR, BOR = 0000. EEDATA, Details on page: = 69. EECON2, Bit 7 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = Data EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n----. EECON2, Value on POR, BOR = ----. EECON2, Details on page: = 65, 69. EECON1, Bit 7 = EEPGD CFGS - FREE WRERR WREN WR. EECON1, Bit 6 = EEPGD CFGS - FREE WRERR WREN WR. EECON1, Bit 5 = EEPGD CFGS - FREE WRERR WREN WR. EECON1, Bit 4 = EEPGD CFGS - FREE WRERR WREN WR. EECON1, Bit 3 = EEPGD CFGS - FREE WRERR WREN WR. EECON1, Bit 2 = EEPGD CFGS - FREE WRERR WREN WR. EECON1, Bit 1 = EEPGD CFGS - FREE WRERR WREN WR. EECON1, Bit 0 = RD xx-0. EECON1, Value on POR, BOR = x000. EECON1, Details on page: = 66\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nNote 1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read '0' in all other Oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers and bits are reserved on the PIC18F2X2 devices; always maintain these clear.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nIPR2, Bit 7 = -. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = ---1 1111. IPR2, Details on page: = 83. PIR2, Bit 7 = -. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = ---0 0000. PIR2, Details on page: = 79. PIE2, Bit 7 = -. PIE2, Bit 6 = -. PIE2, Bit",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = ---0 0000. PIE2, Details on page: = 81. IPR1, Bit 7 = PSPIP (3). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111 1111. IPR1, Details on page: = 82. PIR1, Bit 7 = PSPIF (3). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nTXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000 0000. PIR1, Details on page: = 78. PIE1, Bit 7 = PSPIE (3). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000 0000. PIE1, Details on page: = 80. TRISE (3), Bit 7 = IBF. TRISE (3), Bit 6 = OBF. TRISE (3), Bit 5 = IBOV. TRISE (3), Bit 4 = PSPMODE. TRISE (3), Bit 3 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n-. TRISE (3), Bit 2 = Data Direction bits for PORTE. TRISE (3), Bit 1 = Data Direction bits for PORTE. TRISE (3), Bit 0 = Data Direction bits for PORTE. TRISE (3), Value on POR, BOR = 0000 -111. TRISE (3), Details on page: = 98. TRISD (3), Bit 7 = Data Direction Control Register for PORTD. TRISD (3), Bit 6 = Data Direction Control Register for PORTD. TRISD (3), Bit 5 = Data Direction Control Register for PORTD. TRISD (3), Bit 4 = Data Direction Control Register for PORTD. TRISD (3), Bit 3 = Data Direction Control Register for PORTD. TRISD (3), Bit 2 = Data Direction Control Register for PORTD. TRISD (3), Bit 1 = Data Direction Control Register for PORTD. TRISD (3), Bit 0 = Data Direction Control Register for PORTD. TRISD (3), Value on POR, BOR = 1111 1111. TRISD (3), Details on page: = 96.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nTRISC, Bit 7 = Data Direction Control Register for PORTC. TRISC, Bit 6 = Data Direction Control Register for PORTC. TRISC, Bit 5 = Data Direction Control Register for PORTC. TRISC, Bit 4 = Data Direction Control Register for PORTC. TRISC, Bit 3 = Data Direction Control Register for PORTC. TRISC, Bit 2 = Data Direction Control Register for PORTC. TRISC, Bit 1 = Data Direction Control Register for PORTC. TRISC, Bit 0 = Data Direction Control Register for PORTC. TRISC, Value on POR, BOR = 1111 1111. TRISC, Details on page: = 93. TRISB, Bit 7 = Data Direction Control Register for PORTB. TRISB, Bit 6 = Data Direction Control Register for PORTB. TRISB, Bit 5 = Data Direction Control Register for PORTB. TRISB, Bit 4 = Data Direction Control Register for PORTB. TRISB, Bit 3 = Data Direction Control Register for PORTB. TRISB, Bit 2 = Data Direction Control Register for PORTB. TRISB, Bit 1 = Data Direction Control Register for PORTB. TRISB, Bit 0 = Data Direction Control Register",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nfor PORTB. TRISB, Value on POR, BOR = 1111 1111. TRISB, Details on page: = 90. TRISA, Bit 7 = -. TRISA, Bit 6 = TRISA6 (1). TRISA, Bit 5 = Data Direction Control Register for PORTA. TRISA, Bit 4 = Data Direction Control Register for PORTA. TRISA, Bit 3 = Data Direction Control Register for PORTA. TRISA, Bit 2 = Data Direction Control Register for PORTA. TRISA, Bit 1 = Data Direction Control Register for PORTA. TRISA, Bit 0 = Data Direction Control Register for PORTA. TRISA, Value on POR, BOR = -111 1111. TRISA, Details on page: = 87. LATE (3), Bit 7 = -. LATE (3), Bit 6 = -. LATE (3), Bit 5 = -. LATE (3), Bit 4 = -. LATE (3), Bit 3 = -. LATE (3), Bit 2 = Read PORTE Data Latch, Write PORTE Data Latch. LATE (3), Bit 1 = Read PORTE Data Latch, Write PORTE Data Latch.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nLATE (3), Bit 0 = Read PORTE Data Latch, Write PORTE Data Latch. LATE (3), Value on POR, BOR = ---- -xxx. LATE (3), Details on page: = 99. LATD (3), Bit 7 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 6 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 5 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 4 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 3 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 2 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 1 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Bit 0 = Read PORTD Data Latch, Write PORTD Data Latch. LATD (3), Value on POR, BOR = xxxx xxxx.",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nLATD (3), Details on page: = 95. LATC, Bit 7 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 6 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 5 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 4 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 3 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 2 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 1 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 0 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Value on POR, BOR = xxxx xxxx. LATC, Details on page: = 93. LATB, Bit 7 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 6 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 5 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n4 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 3 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 2 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 1 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 0 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Value on POR, BOR = xxxx xxxx. LATB, Details on page: = 90. LATA, Bit 7 = -. LATA, Bit 6 = LATA6 (1). LATA, Bit 5 = Read PORTA Data Latch, Write PORTA Data Latch (1). LATA, Bit 4 = Read PORTA Data Latch, Write PORTA Data Latch (1). LATA, Bit 3 = Read PORTA Data Latch, Write PORTA Data Latch (1). LATA, Bit 2 = Read PORTA Data Latch, Write PORTA Data Latch (1). LATA, Bit 1 = Read PORTA Data Latch, Write PORTA Data Latch (1).",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nLATA, Bit 0 = Read PORTA Data Latch, Write PORTA Data Latch (1). LATA, Value on POR, BOR = -xxx xxxx. LATA, Details on page: = 87. PORTE (3), Bit 7 = Read PORTE pins, Write PORTE Data Latch. PORTE (3), Bit 6 = Read PORTE pins, Write PORTE Data Latch. PORTE (3), Bit 5 = Read PORTE pins, Write PORTE Data Latch. PORTE (3), Bit 4 = Read PORTE pins, Write PORTE Data Latch. PORTE (3), Bit 3 = Read PORTE pins, Write PORTE Data Latch. PORTE (3), Bit 2 = Read PORTE pins, Write PORTE Data Latch. PORTE (3), Bit 1 = Read PORTE pins, Write PORTE Data Latch. PORTE (3), Bit 0 = Read PORTE pins, Write PORTE Data Latch. PORTE (3), Value on POR, BOR = ---- -000. PORTE (3), Details on page: = 99. PORTD (3), Bit 7 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Bit 6 = Read",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nPORTD pins, Write PORTD Data Latch. PORTD (3), Bit 5 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Bit 4 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Bit 3 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Bit 2 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Bit 1 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Bit 0 = Read PORTD pins, Write PORTD Data Latch. PORTD (3), Value on POR, BOR = xxxx xxxx. PORTD (3), Details on page: = 95. PORTC, Bit 7 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 6 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 5 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 4 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 3 = Read PORTC pins, Write PORTC Data",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\nLatch. PORTC, Bit 2 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 1 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 0 = Read PORTC pins, Write PORTC Data Latch. PORTC, Value on POR, BOR = xxxx xxxx. PORTC, Details on page: = 93. PORTB, Bit 7 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 6 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 5 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 4 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 3 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 2 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 1 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 0 = Read PORTB pins, Write PORTB Data Latch. PORTB, Value on POR, BOR = xxxx xxxx. PORTB, Details on page: = 90. PORTA, Bit 7 =",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n- RA6 (1) Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 6 = - RA6 (1) Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 5 = - RA6 (1) Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 4 = - RA6 (1) Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 3 = - RA6 (1) Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 2 = - RA6 (1) Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 1 = - RA6 (1) Read PORTA pins, Write PORTA Data Latch (1). PORTA, Bit 0 = - RA6 (1) Read PORTA pins, Write PORTA Data Latch (1). PORTA, Value on POR, BOR = -x0x 0000. PORTA, Details on page: = 87\nLegend:",
    "TABLE 4-2: REGISTER FILE SUMMARY (CONTINUED)\n- x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote\n1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read '0' in all other Oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers and bits are reserved on the PIC18F2X2 devices; always maintain these clear.",
    "4.10 Access Bank\nThe  Access  Bank  is  an  architectural  enhancement which is very useful for C compiler code optimization. The techniques used by the C compiler may also be useful for programs written in assembly.\nThis data memory region can be used for:\nGLYPH<129> Intermediate computational values\nGLYPH<129> Local variables of subroutines\nGLYPH<129> Faster context saving/switching of variables\nGLYPH<129> Common variables\nGLYPH<129> Faster evaluation/control of SFRs (no banking)\nThe Access Bank is comprised of the upper 128 bytes in Bank 15 (SFRs) and the lower 128 bytes in Bank 0. These two sections will be referred to as Access RAM High  and  Access  RAM  Low,  respectively.  Figure 4-6 and Figure 4-7 indicate the Access RAM areas.\nA bit in the instruction word specifies if the operation is to occur in the bank specified by the BSR register or in the Access Bank. This bit is denoted by the 'a' bit (for access bit).",
    "4.10 Access Bank\nWhen  forced  in  the  Access  Bank  (a  =  0),  the  last address  in  Access  RAM  Low  is  followed  by  the  first address in Access RAM High. Access RAM High maps the Special Function registers, so that these registers can be accessed without any software overhead. This is useful for testing status flags and modifying control bits.",
    "FIGURE 4-8: DIRECT ADDRESSING\nNote 1: For register file map detail, see Table 4-1.\n2: The access bit of the instruction can be used to force an override of the selected bank (BSR<3:0>) to the registers of the Access Bank.\n3: The MOVFF instruction embeds the entire 12-bit address in the instruction.",
    "4.11 Bank Select Register (BSR)\nThe need for a large general purpose memory space dictates a RAM banking scheme. The data memory is partitioned into sixteen  banks.  When  using  direct addressing,  the  BSR  should  be  configured  for  the desired bank.\nBSR<3:0> holds  the  upper  4  bits  of  the  12-bit  RAM address. The BSR<7:4> bits will always read '0's, and writes will have no effect.\nA MOVLB instruction has been provided in the instruction set to assist in selecting banks.\nIf the currently selected bank is not implemented, any read will return all '0's and all writes are ignored. The STATUS register bits will be set/cleared as appropriate for the instruction performed.\nEach  Bank  extends  up  to  FFh  (256  bytes).  All  data memory is implemented as static RAM.\nA MOVFF instruction ignores the BSR, since the 12-bit addresses are embedded into the instruction word.\nSection 4.12 provides a description of indirect addressing, which allows linear addressing of the entire RAM space.",
    "4.12 Indirect Addressing, INDF and FSR Registers\nIndirect addressing is a mode of addressing data memory, where the data memory address in the instruction is not fixed. An FSR register is used as a pointer to the data memory location that is to be read or written. Since this pointer is in RAM, the contents can be modified by the program. This can be useful for data tables in the data  memory  and  for  software  stacks.  Figure 4-9 shows the operation of indirect addressing. This shows the moving of the value to the data memory address specified by the value of the FSR register.\nIndirect  addressing  is  possible  by  using  one  of  the INDF registers. Any instruction using the INDF register actually  accesses  the  register  pointed  to  by  the  File Select Register, FSR. Reading the INDF register itself, indirectly (FSR = 0), will read 00h. Writing to the INDF register indirectly, results in a no operation. The FSR register contains a 12-bit address, which is shown in Figure 4-10.\nThe INDFn register is not a physical register. Addressing INDFn  actually  addresses  the  register  whose address is contained in the FSRn register (FSRn is a pointer). This is indirect addressing.",
    "4.12 Indirect Addressing, INDF and FSR Registers\nExample 4-4 shows a simple use of indirect addressing to clear the RAM in Bank1 (locations 100h-1FFh) in a minimum number of instructions.",
    "EXAMPLE 4-4: HOW TO CLEAR RAM (BANK1) USING INDIRECT ADDRESSING\nNEXT, 1 = LFSR CLRF. NEXT, 2 = FSR0 ,0x100 POSTINC0. NEXT, 3 = ; ; Clear INDF ; register and ; inc pointer. , 1 = BTFSS. , 2 = FSR0H,. , 3 = ; All done with ; Bank1?. , 1 = GOTO. , 2 = NEXT. , 3 = ; NO, clear next. CONTINUE, 1 = CONTINUE. CONTINUE, 2 = CONTINUE. CONTINUE, 3 = ; YES, continue\nThere  are  three indirect addressing  registers. To address the entire data memory space (4096 bytes), these registers are 12-bit wide. To store the 12-bits of addressing information, two 8-bit registers are required. These indirect addressing registers are:\n1. FSR0: composed of FSR0H:FSR0L\n2. FSR1: composed of FSR1H:FSR1L\n3. FSR2: composed of FSR2H:FSR2L",
    "EXAMPLE 4-4: HOW TO CLEAR RAM (BANK1) USING INDIRECT ADDRESSING\nIn  addition,  there  are  registers  INDF0,  INDF1  and INDF2, which are not physically implemented. Reading or writing to these registers activates indirect addressing, with the value in the corresponding FSR register being the address of the data. If an instruction writes a value to INDF0, the value will be written to the address pointed to by FSR0H:FSR0L. A read from INDF1 reads the data from the address pointed to by FSR1H:FSR1L. INDFn can be used in code anywhere an operand can be used.\nIf  INDF0,  INDF1  or  INDF2  are  read  indirectly  via  an FSR,  all  '0's  are  read  (zero  bit  is  set).  Similarly,  if INDF0, INDF1 or INDF2 are written to indirectly, the operation will be equivalent to a NOP instruction and the STATUS bits are not affected.",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nEach  FSR  register  has  an  INDF  register  associated with it, plus four additional register addresses. Performing an operation on one of these five registers determines  how  the  FSR  will  be  modified  during  indirect addressing.\nWhen data access is done to one of the five INDFn locations, the address selected will configure the FSRn register to:\nGLYPH<129> Do nothing to FSRn after an indirect access (no change) - INDFn\nGLYPH<129> Auto-decrement FSRn after an indirect access (post-decrement) - POSTDECn\nGLYPH<129> Auto-increment FSRn after an indirect access (post-increment) - POSTINCn\nGLYPH<129> Auto-increment FSRn before an indirect access (pre-increment) - PREINCn\nGLYPH<129> Use the value in the WREG register as an offset to FSRn. Do not modify the value of the WREG or the FSRn register after an indirect access (no change) - PLUSWn",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nWhen using the auto-increment or auto-decrement features,  the  effect  on  the  FSR  is  not  reflected  in  the STATUS register. For example, if the indirect address causes the FSR to equal '0', the Z bit will not be set.\nIncrementing  or  decrementing  an  FSR  affects  all  12 bits. That is, when FSRnL overflows from an increment, FSRnH will be incremented automatically.\nAdding these features allows the FSRn to be used as a stack pointer, in addition to its uses for table operations in data memory.\nEach FSR has an address associated with it that performs an indexed indirect access. When a data access to this INDFn location (PLUSWn) occurs, the FSRn is configured to add the signed value in the WREG register and the value in FSR to form the address before an indirect access. The FSR value is not changed.\nIf an FSR register contains a value that points to one of the INDFn, an indirect read will read 00h (zero bit is set), while an indirect write will be equivalent to a NOP (STATUS bits are not affected).",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nIf  an indirect addressing operation is done where the target  address  is  an  FSRnH  or  FSRnL  register,  the write operation will dominate over the preor post-increment/decrement functions.",
    "4.13 STATUS Register\nThe STATUS register, shown in Register 4-2, contains the arithmetic status of the ALU. The STATUS register can be the destination for any instruction, as with any other register. If the STATUS register is the destination for an instruction that affects the Z, DC, C, OV, or N bits, then the write to these five bits is disabled. These bits are set or cleared according to the device logic. Therefore,  the  result  of  an  instruction  with  the  STATUS register as destination may be different than intended.\nFor example, CLRF STATUS will clear the upper three bits and set the Z bit.   This leaves the STATUS register as 000u u1uu (where u = unchanged).\nIt  is  recommended,  therefore,  that  only BCF,  BSF, SWAPF,  MOVFF and MOVWF instructions are used to alter the STATUS register, because these instructions do not affect the Z, C, DC, OV, or N bits from the STATUS register.  For  other  instructions  not  affecting any status bits, see Table 20-2.\nNote:\nThe C and DC bits operate as a borrow and digit borrow bit respectively, in subtraction.",
    "REGISTER 4-2: STATUS REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-x. U-0, 4 = R/W-x. U-0, 5 = R/W-x. U-0, 6 = R/W-x. U-0, 7 = R/W-x. -, 1 = -. -, 2 = -. -, 3 = N. -, 4 = OV. -, 5 = Z. -, 6 = DC. -, 7 = C\nbit 7\nbit 0",
    "bit  4 N: Negative bit\nThis bit is used for signed arithmetic (2's complement). It indicates whether the result was negative (ALU MSB = 1).\n1 = Result was negative\n0 = Result was positive",
    "bit  3 OV: Overflow bit\nThis bit is used for signed arithmetic (2's complement). It indicates an overflow of the 7-bit magnitude, which causes the sign bit (bit7) to change state.\n1 = Overflow occurred for signed arithmetic (in this arithmetic operation)\n0 = No overflow occurred",
    "bit 2 Z: Zero bit\n1 = The result of an arithmetic or logic operation is zero\n0 = The result of an arithmetic or logic operation is not zero",
    "bit 1 DC:\nDigit carry/borrow bit\nFor ADDWF, ADDLW, SUBLW , and SUBWF instructions\n1 = A carry-out from the 4th low order bit of the result occurred\n0 = No carry-out from the 4th low order bit of the result\nNote:\nFor borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either the bit 4 or bit 3 of the source register.\nC: Carry/borrow bit\nFor ADDWF, ADDLW, SUBLW , and SUBWF instructions\n1 = A carry-out from the Most Significant bit of the result occurred\n0 = No carry-out from the Most Significant bit of the result occurred\nNote:\nFor borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either the high or low order bit of the source register.\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'",
    "bit 1 DC:\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "4.14 RCON Register\nThe Reset Control (RCON) register contains flag bits that  allow  differentiation  between  the  sources  of  a device RESET. These flags include the TO, PD, POR, BOR and RI bits. This register is readable and writable.\nNote 1: If the  BOREN  configuration  bit  is  set (Brown-out Reset enabled), the BOR bit is '1'  on a Power-on Reset. After a Brownout Reset has occurred, the BOR bit will be cleared, and must be set by firmware to indicate the occurrence of the next Brown-out Reset.\n2: It is recommended that the POR bit be set after a Power-on Reset has been detected,  so  that  subsequent  Power-on Resets may be detected.",
    "REGISTER 4-3: RCON REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R-1. R/W-0, 5 = R-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0",
    "bit  7 IPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (16CXXX Compatibility mode)\nbit  6-5 Unimplemented: Read as '0'",
    "bit  4\nRI: RESET Instruction Flag bit\n1 = The RESET instruction was not executed\n0 = The RESET instruction was executed causing a device RESET (must be set in software after a Brown-out Reset occurs)",
    "bit  3 TO: Watchdog Time-out Flag bit\n1 = After power-up, CLRWDT instruction, or SLEEP instruction\n0 = A WDT time-out occurred",
    "bit  2 PD: Power-down Detection Flag bit\n1 = After power-up or by the CLRWDT instruction\n0 = By execution of the SLEEP instruction\nbit  1 POR: Power-on Reset Status bit\n1 = A Power-on Reset has not occurred\n0 = A Power-on Reset occurred\n(must be set in software after a Power-on Reset occurs)",
    "bit  0 BOR: Brown-out Reset Status bit\n1 = A Brown-out Reset has not occurred\n0 = A Brown-out Reset occurred\n(must be set in software after a Brown-out Reset occurs)\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "PIC18FXX2\nNOTES:",
    "5.0 FLASH PROGRAM MEMORY\nThe  FLASH  Program  Memory  is  readable,  writable, and erasable during normal operation over the entire VDD range.\nA read from program memory is executed on one byte at a time. A write to program memory is executed on blocks of 8 bytes at a time. Program memory is erased in blocks of 64 bytes at a time. A bulk erase operation may not be issued from user code.\nWriting or erasing program memory will cease instruction fetches until  the operation is complete. The program memory cannot be accessed during the write or erase, therefore, code cannot execute. An internal programming  timer  terminates  program  memory  writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing  a  program  memory location  that  forms  an  invalid  instruction  results  in  a NOP .",
    "5.1 Table Reads and Table Writes\nIn order to read and write program memory, there are two operations that allow the processor to move bytes between  the  program  memory  space  and  the  data RAM:\nGLYPH<129> Table Read ( TBLRD )\nGLYPH<129> Table Write ( TBLWT )\nThe program memory space is 16-bits wide, while the data RAM space is 8-bits wide. Table Reads and Table Writes move data between these two memory spaces through an 8-bit register (TABLAT).\nTable  Read  operations  retrieve  data  from  program memory  and  places  it  into  the  data  RAM  space. Figure 5-1 shows the operation of a Table Read with program memory and data RAM.\nTable Write operations store data from the data memory  space  into  holding  registers  in  program  memory. The procedure to write the contents of the holding registers into program memory is detailed in Section 5.5, ''Writing to FLASH  Program  Memory'.  Figure 5-2 shows  the  operation  of  a  Table  Write  with  program memory and data RAM.",
    "5.1 Table Reads and Table Writes\nTable operations work with byte entities. A table block containing data, rather than program instructions, is not required to be word aligned. Therefore, a table block can start and end at any byte address. If a Table Write is  being  used  to  write  executable  code  into  program memory,  program  instructions  will  need  to  be  word aligned.",
    "5.2 Control Registers\nSeveral control registers are used in conjunction with the TBLRD and TBLWT instructions. These include the:\nThe FREE bit, when set, will allow a program memory erase operation. When the FREE bit is set, the erase operation is initiated on the next WR command. When FREE is clear, only writes are enabled.\nGLYPH<129> EECON1 register\nGLYPH<129> EECON2 register\nGLYPH<129> TABLAT register\nGLYPH<129> TBLPTR registers",
    "5.2.1 EECON1 AND EECON2 REGISTERS\nEECON1 is the control register for memory accesses.\nEECON2 is not a physical register. Reading EECON2 will read  all '0's. The  EECON2  register  is  used exclusively in the memory write and erase sequences.\nControl bit EEPGD determines if the access will be a program  or  data  EEPROM  memory  access.  When clear,  any  subsequent operations will operate on the data  EEPROM  memory.  When  set,  any  subsequent operations will operate on the program memory.\nControl bit CFGS determines if the access will be to the configuration  registers  or  to  program  memory/data EEPROM memory. When set, subsequent operations will  operate  on  configuration  registers,  regardless  of EEPGD (see 'Special Features of the CPU', Section 19.0). When clear, memory selection access is determined by EEPGD.",
    "5.2.1 EECON1 AND EECON2 REGISTERS\nThe WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear. The WRERR bit is set when a write operation is interrupted by a MCLR Reset or a WDT Time-out Reset during normal operation. In these  situations,  the  user  can  check  the WRERR bit and rewrite the location. It is necessary to reload  the  data  and  address  registers  (EEDATA  and EEADR), due to RESET values of zero.\nControl bit WR initiates write operations. This bit cannot be cleared, only set, in software. It is cleared in hardware  at  the  completion  of  the  write  operation.  The inability  to  clear  the  WR  bit  in  software  prevents  the accidental or premature termination of a write operation.",
    "Note:\nInterrupt flag bit EEIF, in the PIR2 register, is set when the write is complete. It must be cleared in software.",
    "REGISTER 5-1: EECON1 REGISTER (ADDRESS FA6h)\nR/W-x, 1 = R/W-x. R/W-x, 2 = U-0. R/W-x, 3 = R/W-0. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-0. R/W-x, 6 = R/S-0. R/W-x, 7 = R/S-0. EEPGD, 1 = CFGS. EEPGD, 2 = -. EEPGD, 3 = FREE. EEPGD, 4 = WRERR. EEPGD, 5 = WREN. EEPGD, 6 = WR. EEPGD, 7 = RD\nbit 7\nbit 0",
    "bit 7 EEPGD: FLASH Program or Data EEPROM Memory Select bit\n1 = Access FLASH Program memory\n0 = Access Data EEPROM memory",
    "bit 6 CFGS: FLASH Program/Data EE or Configuration Select bit\n1 = Access Configuration registers\n0 = Access FLASH Program or Data EEPROM memory",
    "bit 4 FREE: FLASH Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation)\n0 = Perform write only",
    "bit 3 WRERR: FLASH Program/Data EE Error Flag bit\n- 1 = A write operation is prematurely terminated\n(any RESET during self-timed programming in normal operation)\n- 0 = The write operation completed\nNote: When a WRERR occurs, the EEPGD and CFGS bits are not cleared. This allows tracing of the error condition.",
    "bit 2 WREN: FLASH Program/Data EE Write Enable bit\n1 = Allows write cycles\n0 = Inhibits write to the EEPROM",
    "bit 1 WR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle. (The operation is self timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle to the EEPROM is complete",
    "bit 0 RD: Read Control bit\n1 = Initiates an EEPROM read (Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared) in software. RD bit cannot be set when EEPGD = 1.)\n0 = Does not initiate an EEPROM read\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "5.2.2 TABLAT - TABLE LATCH REGISTER\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch is used to hold 8-bit data  during  data  transfers  between  program memory and data RAM.",
    "5.2.3 TBLPTR - TABLE POINTER REGISTER\nThe Table Pointer (TBLPTR) addresses a byte within the  program  memory.  The  TBLPTR  is  comprised  of three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL).  These  three  registers join to form a 22-bit wide pointer. The low order 21 bits allow the device to address up to 2 Mbytes of program memory space. The 22nd bit allows access to the Device ID, the User ID and the Configuration bits.",
    "5.2.4 TABLE POINTER BOUNDARIES\nTBLPTR is used in reads,  writes,  and  erases  of  the FLASH program memory.\nWhen a TBLRD is  executed,  all  22  bits  of  the  Table Pointer  determine  which  byte  is  read  from  program memory into TABLAT.\nWhen a TBLWT is executed, the three LSbs of the Table Pointer (TBLPTR<2:0>) determine which of the eight program memory holding registers is written to. When the timed write to program memory (long write) begins, the 19 MSbs of the Table Pointer, TBLPTR (TBLPTR<21:3>), will determine which program memory block of 8 bytes is written to. For more detail, see Section 5.5 ('Writing to FLASH Program Memory').\nThe table pointer, TBLPTR, is used by the TBLRD and TBLWT instructions. These instructions can update the TBLPTR in one of four ways based on the table operation. These operations are shown in Table 5-1. These operations  on  the  TBLPTR  only  affect  the  low  order 21 bits.",
    "5.2.4 TABLE POINTER BOUNDARIES\nWhen an erase of program memory is executed, the 16 MSbs of the Table Pointer (TBLPTR<21:6>) point to the 64-byte block that will be erased. The Least Significant bits (TBLPTR<5:0>) are ignored.\nFigure 5-3 describes the relevant boundaries of TBLPTR based on FLASH program memory operations.\nTABLE 5-1: TABLE POINTER OPERATIONS WITH TBLRD AND TBLWT INSTRUCTIONS\n\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write",
    "5.3 Reading the FLASH Program Memory\nThe TBLRD instruction is used to retrieve data from program memory and place into data RAM. Table Reads from  program  memory  are  performed  one  byte  at  a time.\nTBLPTR points to a byte address in program space. Executing TBLRD places  the  byte  pointed  to  into TABLAT. In addition, TBLPTR can be modified automatically for the next Table Read operation.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. Figure 5-4 shows  the  interface  between  the  internal  program memory and the TABLAT.",
    "EXAMPLE 5-1: READING A FLASH PROGRAM MEMORY WORD\n, 1 = MOVLW CODE_ADDR_UPPER MOVWF TBLPTRU MOVLW CODE_ADDR_HIGH MOVWF TBLPTRH MOVLW CODE_ADDR_LOW MOVWF TBLPTRL. READ_WORD, 1 = READ_WORD. , 1 = TBLRD*+ MOVF TABLAT, W MOVWF WORD_EVEN TBLRD*+ MOVF TABLAT, W MOVWF WORD_ODD",
    "5.4 Erasing FLASH Program memory\nThe minimum erase block is 32 words or 64 bytes. Only through the use of an external programmer, or through ICSP control can larger blocks of program memory be bulk  erased.  Word  erase  in  the  FLASH  array  is  not supported.\nWhen  initiating  an  erase  sequence  from  the  microcontroller itself, a block of 64 bytes of program memory is erased. The Most Significant 16 bits of the TBLPTR<21:6>  point  to the block being erased. TBLPTR<5:0> are ignored.\nThe EECON1 register commands the erase operation. The EEPGD bit must be set to point to the FLASH program memory. The WREN bit must be set to enable write operations. The FREE bit is set to select an erase operation.\nFor protection, the write initiate sequence for EECON2 must be used.",
    "5.4.1 FLASH PROGRAM MEMORY ERASE SEQUENCE\nThe sequence of events for erasing a block of internal program memory location is:\n1. Load  table  pointer  with  address  of  row  being erased.\n2. Set  EEPGD  bit  to  point  to  program  memory, clear CFGS bit to access program memory, set WREN bit to enable writes, and set FREE bit to enable the erase.\n3. Disable interrupts.\n4. Write 55h to EECON2.\n5. Write AAh to EECON2.\n6. Set  the  WR  bit.  This  will  begin  the  row  erase cycle.\n7. The  CPU  will  stall  for  duration  of  the  erase (about 2 ms using internal timer).\n8. Re-enable interrupts.\nA  long  write  is  necessary  for  erasing  the  internal FLASH. Instruction execution is halted while in a long write  cycle.  The  long  write  will  be  terminated  by  the internal programming timer.",
    "EXAMPLE 5-2: ERASING A FLASH PROGRAM MEMORY ROW\n, MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF = BSF BCF BSF BSF BCF. , CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL = EECON1,EEPGD EECON1,CFGS EECON1,WREN EECON1,FREE. , ; load TBLPTR with the ; address of the memory = ; point to FLASH program memory ; access FLASH program memory ; enable write to memory ; enable Row Erase operation. , MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF = MOVLW MOVWF. , CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL = EECON2 AAh EECON2. , ; load TBLPTR with the ; address of the memory = ; write 55h. , MOVLW MOVWF MOVLW MOVWF",
    "EXAMPLE 5-2: ERASING A FLASH PROGRAM MEMORY ROW\nMOVLW MOVWF = . , CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL = INTCON,GIE. , ; load TBLPTR with the ; address of the memory = ; disable interrupts. Required Sequence, MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF = . Required Sequence, CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL = 55h. Required Sequence, ; load TBLPTR with the ; address of the memory = . , MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF = MOVWF BSF. , CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL = EECON1,WR. , ; load TBLPTR with the ; address of the memory = ; write AAh. ,",
    "EXAMPLE 5-2: ERASING A FLASH PROGRAM MEMORY ROW\nMOVLW MOVWF MOVLW MOVWF MOVLW MOVWF = BSF. , CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL = INTCON,GIE. , ; load TBLPTR with the ; address of the memory = ; start erase (CPU stall) ; re-enable interrupts",
    "5.5 Writing to FLASH Program Memory\nThe minimum programming block is 4 words or 8 bytes. Word or byte programming is not supported.\nTable Writes are used internally to load the holding registers needed to program the FLASH memory. There are  8  holding  registers  used  by  the  Table  Writes  for programming.\noperations will essentially be short writes, because only the holding registers are written. At the end of updating 8 registers, the EECON1 register must be written to, to start the programming operation with a long write.\nThe long write is necessary for programming the internal FLASH. Instruction execution is halted while in a long write cycle. The long write will be terminated by the internal programming timer.\nSince the Table Latch (TABLAT) is only a single byte, the TBLWT instruction has to be executed 8 times for each  programming  operation.  All  of  the  Table  Write\nThe  EEPROM  on-chip  timer  controls  the  write  time. The write/erase voltages are generated by an on-chip charge pump rated to operate over the voltage range of the device for byte or word operations.",
    "5.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\nThe sequence of events for programming an internal program memory location should be:\n1. Read 64 bytes into RAM.\n2. Update data values in RAM as necessary.\n3. Load Table Pointer with address being erased.\n4. Do the row erase procedure.\n5. Load  Table  Pointer  with  address  of  first  byte being written.\n6. Write the first 8 bytes into the holding registers with auto-increment ( TBLWT*+ or TBLWT+* ).\n7. Set  EEPGD  bit  to  point  to  program  memory, clear the CFGS bit to access program memory, and set WREN to enable byte writes.\n8. Disable interrupts.\n9. Write 55h to EECON2.\n10. Write AAh to EECON2.\n11. Set the WR bit. This will begin the write cycle.\n12. The CPU will stall for duration of the write (about 2 ms using internal timer).\n13. Re-enable interrupts.\n14. Repeat steps 6-14 seven times, to write 64 bytes.\n15. Verify the memory (Table Read).",
    "5.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\nThis procedure will require about 18 ms to update one row of 64 bytes of memory. An example of the required code is given in Example 5-3.",
    "Note:\nBefore setting the WR bit, the table pointer address  needs  to  be  within  the  intended address range of the 8 bytes in the holding registers.",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\n, 1 = MOVLW. , 2 = D'64. , 3 = ;. , 4 = number of bytes in erase block. , 1 = MOVWF. , 2 = COUNTER. , 3 = . , 4 = . , 1 = MOVLW. , 2 = BUFFER_ADDR_HIGH. , 3 = ;. , 4 = point to buffer. , 1 = MOVWF. , 2 = FSR0H. , 3 = . , 4 = . , 1 = MOVLW. , 2 = BUFFER_ADDR_LOW. , 3 = . , 4 = . , 1 = MOVWF. , 2 = FSR0L. , 3 = . , 4 = . , 1 = MOVLW. , 2 = CODE_ADDR_UPPER. , 3 = ;. , 4 = Load TBLPTR with the base. , 1 = MOVWF. , 2 = TBLPTRU. , 3 = ;. , 4 = address of the memory block. , 1 = MOVLW. , 2 = CODE_ADDR_HIGH. , 3 = . , 4 = . ,",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\n1 = MOVWF. , 2 = TBLPTRH. , 3 = . , 4 = . , 1 = MOVLW. , 2 = CODE_ADDR_LOW. , 3 = . , 4 = . , 1 = MOVWF. , 2 = TBLPTRL. , 3 = . , 4 = . READ_BLOCK, 1 = . READ_BLOCK, 2 = . READ_BLOCK, 3 = . READ_BLOCK, 4 = . , 1 = TBLRD*+. , 2 = . , 3 = . , 4 = . , 1 = . , 2 = W. , 3 = ;. , 4 = read into TABLAT, and inc. , 1 = MOVF. , 2 = TABLAT,. , 3 = ;. , 4 = get data. , 1 = MOVWF. , 2 = POSTINC0. , 3 = ;. , 4 = store data. , 1 = DECFSZ. , 2 = COUNTER. , 3 = ;. , 4 = done?. , 1 = BRA. , 2 = READ_BLOCK. , 3 = ;. , 4 = repeat.",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\nMODIFY_WORD, 1 = . MODIFY_WORD, 2 = . MODIFY_WORD, 3 = . MODIFY_WORD, 4 = . , 1 = MOVLW. , 2 = DATA_ADDR_HIGH. , 3 = ;. , 4 = point to buffer. , 1 = MOVWF. , 2 = FSR0H. , 3 = . , 4 = . , 1 = MOVLW. , 2 = DATA_ADDR_LOW. , 3 = . , 4 = . , 1 = . , 2 = FSR0L. , 3 = . , 4 = . , 1 = MOVWF. , 2 = . , 3 = . , 4 = . , 1 = MOVLW. , 2 = NEW_DATA_LOW. , 3 = ;. , 4 = update. , 1 = MOVWF. , 2 = POSTINC0. , 3 = . , 4 = . , 1 = MOVLW. , 2 = NEW_DATA_HIGH. , 3 = . , 4 = . , 1 = MOVWF. , 2 = INDF0. , 3 = . , 4 =",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\n. ERASE_BLOCK, 1 = . ERASE_BLOCK, 2 = . ERASE_BLOCK, 3 = . ERASE_BLOCK, 4 = . , 1 = MOVLW. , 2 = CODE_ADDR_UPPER. , 3 = ;. , 4 = load TBLPTR with the base. , 1 = MOVWF. , 2 = TBLPTRU. , 3 = ;. , 4 = address of the memory block. , 1 = MOVLW. , 2 = CODE_ADDR_HIGH. , 3 = . , 4 = . , 1 = MOVWF. , 2 = TBLPTRH. , 3 = . , 4 = . , 1 = . , 2 = CODE_ADDR_LOW. , 3 = . , 4 = . , 1 = MOVLW. , 2 = . , 3 = . , 4 = . , 1 = MOVWF. , 2 = TBLPTRL. , 3 = . , 4 = . , 1 = BSF. , 2 = EECON1,EEPGD. , 3 = ;. , 4 = point to FLASH program memory. , 1 = BCF.",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\n, 2 = EECON1,CFGS. , 3 = ;. , 4 = access FLASH program memory. , 1 = BSF. , 2 = EECON1,WREN. , 3 = ; ;. , 4 = enable write to memory. , 1 = BSF. , 2 = EECON1,FREE. , 3 = . , 4 = enable Row Erase operation. , 1 = . , 2 = . , 3 = ;. , 4 = disable interrupts. , 1 = BCF. , 2 = INTCON,GIE. , 3 = . , 4 = . , 1 = MOVWF. , 2 = EECON2. , 3 = ;. , 4 = write 55h. , 1 = MOVLW. , 2 = AAh. , 3 = . , 4 = . , 1 = . , 2 = . , 3 = . , 4 = write AAh. , 1 = BSF. , 2 = EECON1,WR. , 3 = ;. , 4 = . , 1 = MOVWF. , 2 = EECON2. , 3 = . , 4 = . , 1 = . , 2 = .",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\n, 3 = ; ;. , 4 = start erase (CPU stall) re-enable interrupts. , 1 = WRITE_BUFFER_BACK MOVLW. , 2 = 8. , 3 = ;. , 4 = number of write buffer groups of 8 bytes. , 1 = . , 2 = COUNTER_HI. , 3 = . , 4 = . , 1 = . , 2 = BUFFER_ADDR_HIGH. , 3 = ;. , 4 = point to buffer. , 1 = MOVWF. , 2 = . , 3 = . , 4 = . , 1 = MOVLW. , 2 = . , 3 = . , 4 = . , 1 = MOVLW. , 2 = BUFFER_ADDR_LOW. , 3 = . , 4 = . , 1 = MOVWF. , 2 = FSR0L. , 3 = . , 4 = . PROGRAM_LOOP, 1 = . PROGRAM_LOOP, 2 = . PROGRAM_LOOP, 3 = . PROGRAM_LOOP, 4 = . , 1 = MOVLW. , 2 = COUNTER. , 3 = ;. , 4 = number of bytes in holding",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\nregister. WRITE_WORD_TO_HREGS, 1 = . WRITE_WORD_TO_HREGS, 2 = 8. WRITE_WORD_TO_HREGS, 3 = . WRITE_WORD_TO_HREGS, 4 = . MOVF, 1 = MOVWF. MOVF, 2 = POSTINC0, W. MOVF, 3 = ;. MOVF, 4 = get low byte of buffer data. , 1 = MOVWF. , 2 = TABLAT. , 3 = ;. , 4 = present data to table latch. , 1 = TBLWT+*. , 2 = . , 3 = . , 4 = ; write data, perform a short write. , 1 = DECFSZ. , 2 = COUNTER. , 3 = ;. , 4 = to internal TBLWT holding register.. BRA, 1 = . BRA, 2 = WRITE_WORD_TO_HREGS. BRA, 3 = . BRA, 4 = ; loop until buffers are full",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\nPROGRAM_MEMORY, 1 = PROGRAM_MEMORY. PROGRAM_MEMORY, 2 = PROGRAM_MEMORY. , 1 = BSF. , 2 = EECON1,EEPGD ; point to FLASH program memory. , 1 = BCF. , 2 = EECON1,CFGS ; access FLASH program memory. , 1 = BSF. , 2 = EECON1,WREN ; enable write to memory. , 1 = BCF. , 2 = INTCON,GIE ; disable interrupts. , 1 = MOVLW. , 2 = 55h. Required, 1 = MOVWF. Required, 2 = EECON2 ; write. Sequence, 1 = MOVLW. Sequence, 2 = AAh. , 1 = MOVWF. , 2 = EECON2 ;. , 1 = BSF. , 2 = EECON1,WR ; start program (CPU stall). , 1 = BSF. , 2 = INTCON,GIE ; re-enable interrupts. , 1 = DECFSZ. , 2 = COUNTER_HI ; loop until. , 1 = BRA. , 2 = PROGRAM_LOOP. , 1",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\n= BCF. , 2 = EECON1,WREN ; disable write to",
    "5.5.2 WRITE VERIFY\nDepending  on  the  application,  good  programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "5.5.4 PROTECTION AGAINST SPURIOUS WRITES\nTo protect against spurious writes to FLASH program memory, the write initiate sequence must also be followed. See 'Special Features of the CPU' (Section 19.0) for more detail.",
    "5.6 FLASH Program Operation During Code Protection\nIf a write is terminated by an unplanned event, such as loss of power or an unexpected RESET, the memory location just programmed should be verified and reprogrammed if needed.The WRERR bit is set when a write operation is interrupted by a MCLR Reset, or a WDT Time-out Reset during normal operation. In these situations, users can check the WRERR bit and rewrite the location.\nSee 'Special Features of the CPU' (Section 19.0) for details on code protection of FLASH program memory.",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nFF8h, Name = TBLPTRU. FF8h, Bit 7 = -. FF8h, Bit 6 = -. FF8h, Bit 5 = bit21. FF8h, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). FF8h, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). FF8h, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). FF8h, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). FF8h, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). FF8h, Value on: POR, BOR = --00 0000. FF8h, Value on All Other RESETS = --00 0000. FF7h, Name = TBPLTRH. FF7h, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). FF7h, Bit 6 = Program Memory Table Pointer High Byte",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n(TBLPTR<15:8>). FF7h, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). FF7h, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). FF7h, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). FF7h, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). FF7h, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). FF7h, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). FF7h, Value on: POR, BOR = 0000 0000. FF7h, Value on All Other RESETS = 0000 0000. FF6h, Name = TBLPTRL. FF6h, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). FF6h, Bit 6 = Program Memory Table Pointer High Byte",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n(TBLPTR<7:0>). FF6h, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). FF6h, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). FF6h, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). FF6h, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). FF6h, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). FF6h, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). FF6h, Value on: POR, BOR = 0000 0000. FF6h, Value on All Other RESETS = 0000 0000. FF5h, Name = TABLAT. FF5h, Bit 7 = Program Memory Table Latch. FF5h, Bit 6 = Program Memory Table Latch. FF5h, Bit 5 = Program Memory Table Latch. FF5h, Bit 4 = Program Memory Table Latch.",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nFF5h, Bit 3 = Program Memory Table Latch. FF5h, Bit 2 = Program Memory Table Latch. FF5h, Bit 1 = Program Memory Table Latch. FF5h, Bit 0 = Program Memory Table Latch. FF5h, Value on: POR, BOR = 0000 0000. FF5h, Value on All Other RESETS = 0000 0000. FF2h, Name = INTCON. FF2h, Bit 7 = GIE/ GIEH. FF2h, Bit 6 = PEIE/ GIEL. FF2h, Bit 5 = TMR0IE. FF2h, Bit 4 = INTE. FF2h, Bit 3 = RBIE. FF2h, Bit 2 = TMR0IF. FF2h, Bit 1 = INTF. FF2h, Bit 0 = RBIF. FF2h, Value on: POR, BOR = 0000 000x. FF2h, Value on All Other RESETS = 0000 000u. FA7h, Name = EECON2. FA7h, Bit 7 = EEPROM Control Register2 (not a physical register).",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nFA7h, Bit 6 = EEPROM Control Register2 (not a physical register). FA7h, Bit 5 = EEPROM Control Register2 (not a physical register). FA7h, Bit 4 = EEPROM Control Register2 (not a physical register). FA7h, Bit 3 = EEPROM Control Register2 (not a physical register). FA7h, Bit 2 = EEPROM Control Register2 (not a physical register). FA7h, Bit 1 = EEPROM Control Register2 (not a physical register). FA7h, Bit 0 = EEPROM Control Register2 (not a physical register). FA7h, Value on: POR, BOR = -. FA7h, Value on All Other RESETS = -. FA6h, Name = EECON1. FA6h, Bit 7 = EEPGD. FA6h, Bit 6 = CFGS. FA6h, Bit 5 = -. FA6h, Bit 4 = FREE. FA6h, Bit 3 = WRERR. FA6h, Bit 2 = WREN. FA6h, Bit 1 = WR.",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nFA6h, Bit 0 = RD. FA6h, Value on: POR, BOR = xx-0 x000. FA6h, Value on All Other RESETS = uu-0 u000. FA2h, Name = IPR2. FA2h, Bit 7 = -. FA2h, Bit 6 = -. FA2h, Bit 5 = -. FA2h, Bit 4 = EEIP. FA2h, Bit 3 = BCLIP. FA2h, Bit 2 = LVDIP. FA2h, Bit 1 = TMR3IP. FA2h, Bit 0 = CCP2IP. FA2h, Value on: POR, BOR = ---1 1111. FA2h, Value on All Other RESETS = ---1 1111. FA1h, Name = PIR2. FA1h, Bit 7 = -. FA1h, Bit 6 = -. FA1h, Bit 5 = -. FA1h, Bit 4 = EEIF. FA1h, Bit 3 = BCLIF. FA1h, Bit 2 =",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nLVDIF. FA1h, Bit 1 = TMR3IF. FA1h, Bit 0 = CCP2IF. FA1h, Value on: POR, BOR = ---0 0000. FA1h, Value on All Other RESETS = ---0 0000. FA0h, Name = PIE2. FA0h, Bit 7 = -. FA0h, Bit 6 = -. FA0h, Bit 5 = -. FA0h, Bit 4 = EEIE. FA0h, Bit 3 = BCLIE. FA0h, Bit 2 = LVDIE. FA0h, Bit 1 = TMR3IE. FA0h, Bit 0 = CCP2IE. FA0h, Value on: POR, BOR = ---0 0000. FA0h, Value on All Other RESETS = ---0 0000\nLegend: x = unknown, u = unchanged, r = reserved, -= unimplemented read as '0'. Shaded cells are not used during FLASH/EEPROM access.",
    "PIC18FXX2\nNOTES:",
    "6.0 DATA EEPROM MEMORY\nThe  Data  EEPROM  is  readable  and  writable  during normal operation over the entire VDD range. The data memory  is  not  directly  mapped  in  the  register  file space. Instead, it is  indirectly  addressed through  the Special Function Registers (SFR).\nThere  are  four  SFRs  used  to  read  and  write  the program and data EEPROM memory. These registers are:\nGLYPH<129> EECON1\nGLYPH<129> EECON2\nGLYPH<129> EEDATA\nGLYPH<129> EEADR\nThe EEPROM data memory allows byte read and write. When interfacing to the data memory block, EEDATA holds the 8-bit data for read/write and EEADR holds the address  of  the  EEPROM  location  being  accessed. These devices have 256 bytes of data EEPROM with an address range from 0h to FFh.",
    "6.0 DATA EEPROM MEMORY\nThe EEPROM data memory is rated for high  erase/ write cycles. A byte write automatically erases the location and writes the new data (erase-before-write). The write time is controlled by an on-chip timer. The write time will vary with voltage and temperature, as well as from  chip  to  chip.  Please  refer  to  parameter D122 (Electrical Characteristics, Section 22.0) for exact limits.",
    "6.1 EEADR\nThe address register can address up to a maximum of 256 bytes of data EEPROM.",
    "6.2 EECON1 and EECON2 Registers\nEECON1 is the control register for EEPROM memory accesses.\nEECON2 is not a physical register. Reading EECON2 will read  all '0's. The  EECON2  register  is  used exclusively in the EEPROM write sequence.\nControl bits RD and WR initiate read and write operations, respectively. These bits cannot be cleared, only set, in software. They are cleared in hardware at the completion of the read or write operation. The inability to clear the WR bit in software prevents the accidental or premature termination of a write operation.\nThe WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear. The WRERR bit is set when a write operation is interrupted by a MCLR Reset, or a WDT Time-out Reset during normal operation. In these  situations,  the  user  can  check  the WRERR bit and rewrite the location. It is necessary to reload  the  data  and  address  registers  (EEDATA  and EEADR),  due  to  the  RESET  condition  forcing  the contents of the registers to zero.\nNote:",
    "6.2 EECON1 and EECON2 Registers\nInterrupt flag bit, EEIF in the PIR2 register, is  set  when write is complete. It must be cleared in software.",
    "REGISTER 6-1: EECON1 REGISTER (ADDRESS FA6h)\nR/W-x, 1 = R/W-x. R/W-x, 2 = U-0. R/W-x, 3 = R/W-0. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-0. R/W-x, 6 = R/S-0. R/W-x, 7 = R/S-0. EEPGD, 1 = CFGS. EEPGD, 2 = -. EEPGD, 3 = FREE. EEPGD, 4 = WRERR. EEPGD, 5 = WREN. EEPGD, 6 = WR. EEPGD, 7 = RD\nbit 7\nbit 0\nEEPGD: FLASH Program or Data EEPROM Memory Select bit\n1 = Access FLASH Program memory\n0 = Access Data EEPROM memory\nCFGS: FLASH Program/Data EE or Configuration Select bit\n1 = Access Configuration or Calibration registers\n0 = Access FLASH Program or Data EEPROM memory",
    "bit 4 FREE: FLASH Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation)\n0 = Perform write only\nWRERR:\nFLASH Program/Data EE Error Flag bit\n- 1 = A write operation is prematurely terminated\n(any MCLR or any WDT Reset during self-timed programming in normal operation)\n- 0 = The write operation completed\nNote:\nWhen a WRERR occurs, the EEPGD or FREE bits are not cleared. This allows tracing of the error condition.",
    "bit 2 WREN: FLASH Program/Data EE Write Enable bit\n1 = Allows write cycles\n0 = Inhibits write to the EEPROM",
    "bit 1 WR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle. (The operation is self-timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle to the EEPROM is complete",
    "bit 0 RD: Read Control bit\n1\n= Initiates an EEPROM read (Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared) in software. RD bit cannot be set when EEPGD = 1.)\n0 = Does not initiate an EEPROM read\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 7",
    "bit 6\nbit 3",
    "6.3 Reading the Data EEPROM Memory\nTo read a data memory location, the user must write the address to the EEADR register, clear the EEPGD control bit (EECON1<7>),  clear  the  CFGS  control  bit\n(EECON1<6>), and then set control bit RD (EECON1<0>). The data is available for the very next instruction  cycle;  therefore,  the  EEDATA register can be read by the next instruction. EEDATA will hold this value until another read operation, or until it is written to by the user (during a write operation).",
    "EXAMPLE 6-1: DATA EEPROM READ\nMOVLW, 1 = DATA_EE_ADDR ;. MOVWF, 1 = EEADR ; Data Memory Address to read. BCF, 1 = EECON1, EEPGD ; Point to DATA memory. BCF, 1 = EECON1, CFGS ; Access program FLASH or Data EEPROM memory. BSF, 1 = EECON1, RD ; EEPROM Read. MOVF, 1 = EEDATA, W ; W = EEDATA",
    "6.4 Writing to the Data EEPROM Memory\ncution (i.e., runaway programs). The WREN bit should be kept clear  at  all  times,  except  when  updating  the EEPROM. The WREN bit is not cleared by hardware.\nTo write an EEPROM data location, the address must first be written to the EEADR register and the data written  to  the  EEDATA  register.  Then  the  sequence  in Example 6-2 must be followed to initiate the write cycle.\nThe write will not initiate if the above sequence is not exactly followed (write 55h to EECON2, write AAh to EECON2, then set WR bit) for each byte. It is strongly recommended that  interrupts  be  disabled  during  this code segment.\nAdditionally, the WREN bit in EECON1 must be set to enable  writes.  This  mechanism  prevents  accidental writes to data EEPROM due to unexpected code exe-\nAfter  a  write  sequence  has  been initiated,  EECON1, EEADR and EDATA cannot be modified. The WR bit will be inhibited from being set unless the WREN bit is set. The WREN bit must be set on a previous instruction. Both WR and WREN cannot be set with the same instruction.",
    "6.4 Writing to the Data EEPROM Memory\nAt  the  completion  of  the  write  cycle,  the  WR  bit  is cleared in hardware and the EEPROM Write Complete Interrupt  Flag  bit  (EEIF)  is  set.  The  user  may  either enable  this  interrupt,  or  poll  this  bit.  EEIF  must  be cleared by software.",
    "EXAMPLE 6-2: DATA EEPROM WRITE\n, 1 = MOVLW MOVWF MOVLW MOVWF BCF BCF BSF. , 2 = DATA_EE_ADDR EEADR DATA_EE_DATA EEDATA EECON1, EEPGD EECON1, CFGS EECON1, WREN. , 3 = ; ; Data Memory Address to read ; ; Data Memory Value to write ; Point to DATA memory ; Access program FLASH or Data EEPROM memory ; Enable writes. Required Sequence, 1 = BCF MOVLW MOVWF MOVLW. Required Sequence, 2 = INTCON, GIE 55h EECON2 AAh. Required Sequence, 3 = ; Disable interrupts ; ; Write 55h ;. Required Sequence, 1 = MOVWF BSF. Required Sequence, 2 = EECON2 EECON1, INTCON,. Required Sequence, 3 = ; Write AAh ; Set WR bit to begin write ; Enable interrupts. Required Sequence, 1 = . . .. Required Sequence, 2 = . Required Sequence, 3 = ; user code execution. Required Sequence, 1 = BCF. Required Sequence, 2 =",
    "EXAMPLE 6-2: DATA EEPROM WRITE\nEECON1, WREN. Required Sequence, 3 = ; Disable writes on write complete (EEIF set)",
    "6.5 Write Verify\nDepending  on  the  application,  good  programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "6.6 Protection Against Spurious Write\nThere are conditions when the device may not want to write to the data EEPROM memory. To protect against spurious EEPROM writes, various mechanisms have been built-in. On power-up, the WREN bit is cleared. Also,  the  Power-up  Timer  (72  ms  duration)  prevents EEPROM write.\nThe write initiate sequence and the WREN bit together help  prevent  an  accidental  write  during  brown-out, power glitch, or software malfunction.",
    "6.7 Operation During Code Protect\nData  EEPROM  memory  has  its  own  code  protect mechanism. External Read and Write operations are disabled if either of these mechanisms are enabled.\nThe microcontroller itself can both read and write to the internal  Data EEPROM, regardless of the state of the code protect configuration bit. Refer to 'Special Features of the CPU' (Section 19.0) for additional information.",
    "6.8 Using the Data EEPROM\nThe data EEPROM is a high endurance, byte addressable array that has been optimized for the storage of frequently  changing  information  (e.g.,  program  variables or other data that are updated often). Frequently changing values will typically be updated more often than specification D124. If this is not the case, an array refresh must be performed. For this reason, variables that change infrequently (such as constants, IDs, calibration,  etc.)  should  be  stored  in  FLASH  program memory.\nA  simple  data  EEPROM  refresh  routine  is  shown  in Example 6-3.",
    "Note:\nIf data EEPROM is only used to store con- stants and/or data that changes rarely, an array  refresh  is  likely  not  required.  See specification D124.",
    "EXAMPLE 6-3: DATA EEPROM REFRESH ROUTINE\n, 1 = clrf. , 2 = EEADR. , 3 = ;. , 4 = Start at address 0. , 1 = bcf. , 2 = EECON1,CFGS. , 3 = ;. , 4 = Set for memory. , 1 = bcf. , 2 = EECON1,EEPGD. , 3 = ;. , 4 = Set for Data EEPROM. , 1 = bcf. , 2 = INTCON,GIE. , 3 = ;. , 4 = Disable interrupts. , 1 = bsf. , 2 = EECON1,WREN. , 3 = ;. , 4 = Enable writes. Loop, 1 = . Loop, 2 = . Loop, 3 = ;. Loop, 4 = Loop to refresh array. , 1 = bsf. , 2 = EECON1,RD. , 3 = ;. , 4 = Read current address. , 1 = movlw. , 2 = 55h. , 3 = ;. , 4 = . , 1 = movwf. , 2 = EECON2. , 3 = ;. , 4 = Write 55h. ,",
    "EXAMPLE 6-3: DATA EEPROM REFRESH ROUTINE\n1 = movlw. , 2 = AAh. , 3 = ;. , 4 = . , 1 = movwf. , 2 = EECON2. , 3 = ;. , 4 = Write AAh. , 1 = bsf. , 2 = EECON1,WR. , 3 = ;. , 4 = Set WR bit to begin write. , 1 = btfsc. , 2 = EECON1,WR. , 3 = ;. , 4 = Wait for write to complete. , 1 = bra. , 2 = $-2. , 3 = . , 4 = . , 1 = incfsz. , 2 = EEADR,F. , 3 = ;. , 4 = Increment address. , 1 = bra. , 2 = Loop. , 3 = ;. , 4 = Not zero, do it again. , 1 = bcf. , 2 = EECON1,WREN. , 3 = ;. , 4 = Disable writes. , 1 = bsf. , 2 = INTCON,GIE. , 3 = ;. , 4 = Enable interrupts",
    "REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nFF2h, Name = INTCON. FF2h, Bit 7 = GIE/ GIEH. FF2h, Bit 6 = PEIE/ GIEL. FF2h, Bit 5 = T0IE. FF2h, Bit 4 = INTE. FF2h, Bit 3 = RBIE. FF2h, Bit 2 = T0IF. FF2h, Bit 1 = INTF. FF2h, Bit 0 = RBIF. FF2h, Value on: POR, BOR = 0000 000x. FF2h, Value on All Other RESETS = 0000 000u. FA9h, Name = EEADR. FA9h, Bit 7 = EEPROM Address Register. FA9h, Bit 6 = EEPROM Address Register. FA9h, Bit 5 = EEPROM Address Register. FA9h, Bit 4 = EEPROM Address Register. FA9h, Bit 3 = EEPROM Address Register. FA9h, Bit 2 = EEPROM Address Register. FA9h, Bit 1 = EEPROM Address Register. FA9h, Bit 0 = EEPROM Address Register. FA9h,",
    "REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nValue on: POR, BOR = 0000 0000. FA9h, Value on All Other RESETS = 0000 0000. FA8h, Name = EEDATA. FA8h, Bit 7 = EEPROM Data Register. FA8h, Bit 6 = EEPROM Data Register. FA8h, Bit 5 = EEPROM Data Register. FA8h, Bit 4 = EEPROM Data Register. FA8h, Bit 3 = EEPROM Data Register. FA8h, Bit 2 = EEPROM Data Register. FA8h, Bit 1 = EEPROM Data Register. FA8h, Bit 0 = EEPROM Data Register. FA8h, Value on: POR, BOR = 0000 0000. FA8h, Value on All Other RESETS = 0000 0000. FA7h, Name = EECON2. FA7h, Bit 7 = EEPROM Control Register2 (not a physical register). FA7h, Bit 6 = EEPROM Control Register2 (not a physical register). FA7h, Bit 5 = EEPROM Control Register2 (not a physical register).",
    "REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nFA7h, Bit 4 = EEPROM Control Register2 (not a physical register). FA7h, Bit 3 = EEPROM Control Register2 (not a physical register). FA7h, Bit 2 = EEPROM Control Register2 (not a physical register). FA7h, Bit 1 = EEPROM Control Register2 (not a physical register). FA7h, Bit 0 = EEPROM Control Register2 (not a physical register). FA7h, Value on: POR, BOR = -. FA7h, Value on All Other RESETS = -. FA6h, Name = EECON1. FA6h, Bit 7 = EEPGD. FA6h, Bit 6 = CFGS. FA6h, Bit 5 = -. FA6h, Bit 4 = FREE. FA6h, Bit 3 = WRERR. FA6h, Bit 2 = WREN. FA6h, Bit 1 = WR. FA6h, Bit 0 = RD. FA6h, Value on: POR, BOR = xx-0 x000. FA6h, Value on All Other RESETS = uu-0",
    "REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nu000. FA2h, Name = IPR2. FA2h, Bit 7 = -. FA2h, Bit 6 = -. FA2h, Bit 5 = -. FA2h, Bit 4 = EEIP. FA2h, Bit 3 = BCLIP. FA2h, Bit 2 = LVDIP. FA2h, Bit 1 = TMR3IP. FA2h, Bit 0 = CCP2IP. FA2h, Value on: POR, BOR = ---1 1111. FA2h, Value on All Other RESETS = ---1 1111. FA1h, Name = PIR2. FA1h, Bit 7 = -. FA1h, Bit 6 = -. FA1h, Bit 5 = -. FA1h, Bit 4 = EEIF. FA1h, Bit 3 = BCLIF. FA1h, Bit 2 = LVDIF. FA1h, Bit 1 = TMR3IF. FA1h, Bit 0 = CCP2IF. FA1h, Value on: POR, BOR = ---0 0000.",
    "REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nFA1h, Value on All Other RESETS = ---0 0000. FA0h, Name = PIE2. FA0h, Bit 7 = -. FA0h, Bit 6 = -. FA0h, Bit 5 = -. FA0h, Bit 4 = EEIE. FA0h, Bit 3 = BCLIE. FA0h, Bit 2 = LVDIE. FA0h, Bit 1 = TMR3IE. FA0h, Bit 0 = CCP2IE. FA0h, Value on: POR, BOR = ---0 0000. FA0h, Value on All Other RESETS = ---0 0000\nLegend:\nx = unknown, u = unchanged, r = reserved, -= unimplemented, read as '0'.\nShaded cells are not used during FLASH/EEPROM access.",
    "PIC18FXX2\nNOTES:",
    "7.1 Introduction\nAn 8 x 8 hardware multiplier is included in the ALU of the  PIC18FXX2  devices.  By  making  the  multiply  a hardware operation, it completes in a single instruction cycle. This is an unsigned multiply that gives a 16-bit result. The result is stored into the 16-bit product register  pair  (PRODH:PRODL).  The  multiplier  does  not affect any flags in the ALUSTA register.\nMaking the 8 x 8 multiplier execute in a single cycle gives the following advantages:\nGLYPH<129> Higher computational throughput\nGLYPH<129> Reduces code size requirements for multiply algorithms\nThe performance increase allows the device to be used in  applications  previously  reserved  for  Digital  Signal Processors.\nTable 7-1 shows a performance comparison between enhanced devices using the single cycle hardware multiply,  and  performing  the  same  function  without  the hardware multiply.\n\nTABLE 7-1: PERFORMANCE COMPARISON",
    "7.1 Introduction\n8 x 8 unsigned, Multiply Method = Without hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 13. 8 x 8 unsigned, Cycles (Max). = 69. 8 x 8 unsigned, Time.@40 MHz = 6.9 \u00b5 s. 8 x 8 unsigned, Time.@10 MHz = 27.6 \u00b5 s. 8 x 8 unsigned, Time.@4MHz = 69 \u00b5 s. 8 x 8 unsigned, Multiply Method = Hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 1. 8 x 8 unsigned, Cycles (Max). = 1. 8 x 8 unsigned, Time.@40 MHz = 100 ns. 8 x 8 unsigned, Time.@10 MHz = 400 ns. 8 x 8 unsigned, Time.@4MHz = 1 \u00b5 s. 8 x 8 signed, Multiply Method = Without hardware multiply. 8 x 8 signed, Program Memory (Words). = 33. 8 x 8 signed, Cycles (Max). = 91. 8 x 8 signed, Time.@40 MHz = 9.1 \u00b5 s. 8 x 8 signed, Time.@10 MHz = 36.4 \u00b5 s.",
    "7.1 Introduction\n8 x 8 signed, Time.@4MHz = 91 \u00b5 s. 8 x 8 signed, Multiply Method = Hardware multiply. 8 x 8 signed, Program Memory (Words). = 6. 8 x 8 signed, Cycles (Max). = 6. 8 x 8 signed, Time.@40 MHz = 600 ns. 8 x 8 signed, Time.@10 MHz = 2.4 \u00b5 s. 8 x 8 signed, Time.@4MHz = 6 \u00b5 s. 16 x 16 unsigned, Multiply Method = Without hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 21. 16 x 16 unsigned, Cycles (Max). = 242. 16 x 16 unsigned, Time.@40 MHz = 24.2 \u00b5 s. 16 x 16 unsigned, Time.@10 MHz = 96.8 \u00b5 s. 16 x 16 unsigned, Time.@4MHz = 242 \u00b5 s. 16 x 16 unsigned, Multiply Method = Hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 24. 16 x 16 unsigned, Cycles (Max). = 24. 16 x 16 unsigned, Time.@40 MHz = 2.4 \u00b5",
    "7.1 Introduction\ns. 16 x 16 unsigned, Time.@10 MHz = 9.6 \u00b5 s. 16 x 16 unsigned, Time.@4MHz = 24 \u00b5 s. 16 x 16 signed, Multiply Method = Without hardware multiply. 16 x 16 signed, Program Memory (Words). = 52. 16 x 16 signed, Cycles (Max). = 254. 16 x 16 signed, Time.@40 MHz = 25.4 \u00b5 s. 16 x 16 signed, Time.@10 MHz = 102.6 \u00b5 s. 16 x 16 signed, Time.@4MHz = 254 \u00b5 s. 16 x 16 signed, Multiply Method = Hardware multiply. 16 x 16 signed, Program Memory (Words). = 36. 16 x 16 signed, Cycles (Max). = 36. 16 x 16 signed, Time.@40 MHz = 3.6 \u00b5 s. 16 x 16 signed, Time.@10 MHz = 14.4 \u00b5 s. 16 x 16 signed, Time.@4MHz = 36 \u00b5 s",
    "7.2 Operation\nExample 7-1  shows  the  sequence  to  do  an  8  x  8 unsigned  multiply.  Only  one  instruction  is  required when one argument of the multiply is already loaded in the WREG register.",
    "EXAMPLE 7-2: 8 x 8 SIGNED MULTIPLY ROUTINE\nExample 7-2 shows the sequence to do an 8 x 8 signed multiply. To account for the sign bits of the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.\nEXAMPLE 7-1: 8 x 8 UNSIGNED MULTIPLY ROUTINE\nMOVF, 1 = ARG1, W. MOVF, 2 = ;. MULWF, 1 = ARG2. MULWF, 2 = ; ARG1 * ARG2 ->. , 1 = . , 2 = ; PRODH:PRODL",
    "EXAMPLE 7-2: 8 x 8 SIGNED MULTIPLY ROUTINE\nMOVF MULWF, 1 = ARG1, ARG2. MOVF MULWF, 2 = W. MOVF MULWF, 3 = ; ARG1 * ARG2 -> PRODH:PRODL. BTFSC SUBWF, 1 = ARG2, PRODH,. BTFSC SUBWF, 2 = SB. BTFSC SUBWF, 3 = ; Test Sign Bit ; PRODH = PRODH. MOVF BTFSC SUBWF, 1 = ARG2, W ARG1, PRODH, F. MOVF BTFSC SUBWF, 2 = SB. MOVF BTFSC SUBWF, 3 = ; Test Sign Bit ; PRODH = PRODH ; - ARG2\nExample 7-3  shows  the  sequence  to  do  a  16  x  16 unsigned  multiply.  Equation 7-1  shows  the  algorithm that is used. The 32-bit result is stored in four registers, RES3:RES0.\nEQUATION 7-1:\n16 x 16 UNSIGNED MULTIPLICATION ALGORITHM",
    "EXAMPLE 7-2: 8 x 8 SIGNED MULTIPLY ROUTINE\nRES3:RES0, 1 = ARG1H:ARG1L \u2022 ARG2H:ARG2L (ARG1H \u2022 ARG2H \u2022 2 16 ) + (ARG1H \u2022 ARG2L \u2022 2 8 ) + (ARG1L \u2022 ARG2H \u2022 2 8 ) + (ARG1L \u2022 ARG2L)",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF MULWF, 1 = ARG1L, ARG2L. MOVF MULWF, 2 = W. MOVF MULWF, 3 = . MOVF MULWF, 4 = . MOVFF, 1 = PRODH,. MOVFF, 2 = RES1. MOVFF, 3 = ;. MOVFF, 4 = PRODH:PRODL ;. MOVFF, 1 = PRODL,. MOVFF, 2 = RES0. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1H * ARG2H ->. MOVFF, 1 = PRODH,. MOVFF, 2 = RES3. MOVFF, 3 = ;. MOVFF, 4 =",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\n. MOVFF, 1 = PRODL,. MOVFF, 2 = RES2. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1L * ARG2H ->. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF, 1 = RES1,. ADDWF, 2 = F. ADDWF, 3 = ;. ADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = products. ADDWFC, 1 = RES2,. ADDWFC, 2 = F. ADDWFC, 3 =",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\n;. ADDWFC, 4 = . CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . MULWF, 1 = ARG2L. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1H * ARG2L -> PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = ;. ADDWF, 1 = RES1,. ADDWF, 2 = F. ADDWF, 3 = ;. ADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = products. ADDWFC, 1 = RES2,. ADDWFC, 2 = F.",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nADDWFC, 3 = ;. ADDWFC, 4 = . CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = . CLRF, 4 = ;. ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = \nExample 7-4  shows  the  sequence  to  do  a  16  x  16 signed  multiply.  Equation 7-2  shows  the  algorithm used.  The  32-bit  result  is  stored  in  four  registers, RES3:RES0. To account for the sign bits of the arguments, each argument pairs Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "RES3:RES0\n= ARG1H:ARG1L   ARG2H:ARG2L \u2022\n= (ARG1H   ARG2H   2 16 ) + \u2022 \u2022\n(ARG1H   ARG2L   2 8 ) +\n\u2022\n\u2022\n(ARG1L   ARG2H   2 8 ) + \u2022 \u2022\n(ARG1L   ARG2L) + \u2022\n(-1 \u2022 ARG2H<7>   ARG1H:ARG1L   2 16 ) + \u2022 \u2022\n(-1 \u2022 ARG1H<7>   ARG2H:ARG2L   2 16 ) \u2022 \u2022",
    "16 x 16 SIGNED MULTIPLY ROUTINE\nMULWF, ARG1L, = ARG2L. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1L * ARG2L -> PRODH:PRODL. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES1. MOVFF,  = ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES0. MOVFF,  = ;. MOVFF,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1H * ARG2H -> PRODH:PRODL. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES3. MOVFF,",
    "16 x 16 SIGNED MULTIPLY ROUTINE\n= ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES2. MOVFF,  = ;. MOVFF,  = . MOVF, ARG1L, = ARG1L,. MOVF, W = W. MOVF,  = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1L * ARG2H -> PRODH:PRODL. MOVF, ARG1L, = PRODL,. MOVF, W = W. MOVF,  = ;. MOVF,  = . ADDWF, ARG1L, = RES1,. ADDWF, W = F. ADDWF,  = ;. ADDWF,  = Add cross. MOVF, ARG1L, = PRODH,. MOVF, W = W. MOVF,  = ;. MOVF,",
    "16 x 16 SIGNED MULTIPLY ROUTINE\n= products. ADDWFC, ARG1L, = RES2,. ADDWFC, W = F. ADDWFC,  = ;. ADDWFC,  = . CLRF, ARG1L, = WREG. CLRF, W = . CLRF,  = ;. CLRF,  = . ADDWFC, ARG1L, = RES3,. ADDWFC, W = F. ADDWFC,  = ;. ADDWFC,  = . MOVF MULWF, ARG1L, = ARG1H, ARG2L. MOVF MULWF, W = W. MOVF MULWF,  = ; ;. MOVF MULWF,  = ARG1H * ARG2L -> PRODH:PRODL. MOVF, ARG1L, = PRODL,. MOVF, W = W. MOVF,  = ;. MOVF,",
    "16 x 16 SIGNED MULTIPLY ROUTINE\n= . ADDWF MOVF, ARG1L, = RES1, PRODH,. ADDWF MOVF, W = F W. ADDWF MOVF,  = ; ;. ADDWF MOVF,  = Add cross products. ADDWFC CLRF, ARG1L, = RES2, WREG. ADDWFC CLRF, W = F. ADDWFC CLRF,  = ;. ADDWFC CLRF,  = . ; BTFSS, ARG1L, = RES3, ARG2H,. ; BTFSS, W = F. ; BTFSS,  = ;. ; BTFSS,  = . ADDWFC, ARG1L, = . ADDWFC, W = 7. ADDWFC,  = ;. ADDWFC,  = ARG2H:ARG2L neg?. BRA MOVF, ARG1L, = SIGN_ARG1. BRA MOVF, W = W. BRA MOVF,  = ;. BRA MOVF,",
    "16 x 16 SIGNED MULTIPLY ROUTINE\n= no, check ARG1. SUBWF MOVF, ARG1L, = ARG1L, RES2. SUBWF MOVF, W = . SUBWF MOVF,  = ; ;. SUBWF MOVF,  = . ; SIGN_ARG1 BTFSS BRA, ARG1L, = ARG1H,. ; SIGN_ARG1 BTFSS BRA, W = W. ; SIGN_ARG1 BTFSS BRA,  = ;. ; SIGN_ARG1 BTFSS BRA,  = ARG1H:ARG1L neg?. SUBWFB, ARG1L, = RES3 ARG1H,. SUBWFB, W = . SUBWFB,  = ;. SUBWFB,  = no, done. MOVF, ARG1L, = ARG2L,. MOVF, W = W. MOVF,  = . MOVF,",
    "16 x 16 SIGNED MULTIPLY ROUTINE\n= . SUBWF MOVF, ARG1L, = RES2. SUBWF MOVF, W = 7 CONT_CODE. SUBWF MOVF,  = ;. SUBWF MOVF,  = . SUBWFB, ARG1L, = RES3. SUBWFB, W = . SUBWFB,  = ; ;. SUBWFB,  = . ; CONT_CODE, ARG1L, = ARG2H,. ; CONT_CODE, W = . ; CONT_CODE,  = . ; CONT_CODE,  = . , ARG1L, = . , W = W. ,  = . ,  = . , ARG1L, = . , W = . ,  = ;. ,  = ",
    "8.0 INTERRUPTS\nThe PIC18FXX2 devices have multiple interrupt sources  and  an  interrupt  priority  feature  that  allows each  interrupt  source  to  be  assigned  a  high  priority level or a low priority level. The high priority interrupt vector is at 000008h and the low priority interrupt vector is at 000018h. High priority interrupt events will override any low priority interrupts that may be in progress.\nThere  are  ten  registers  which  are  used  to  control interrupt operation. These registers are:\nGLYPH<129> RCON\nGLYPH<129> INTCON\nGLYPH<129> INTCON2\nGLYPH<129> INTCON3\nGLYPH<129> PIR1, PIR2\nGLYPH<129> PIE1, PIE2\nGLYPH<129> IPR1, IPR2\nIt is recommended that the Microchip header files supplied  with  MPLAB fi IDE  be  used  for  the  symbolic  bit names in these registers. This allows the assembler/ compiler to automatically take care of the placement of these bits within the specified register.\nEach interrupt source, except INT0, has three bits to control its operation. The functions of these bits are:",
    "8.0 INTERRUPTS\nGLYPH<129> Flag bit to indicate that an interrupt event occurred\nGLYPH<129> Enable bit that allows program execution to branch to the interrupt vector address when the flag bit is set\nGLYPH<129> Priority bit to select high priority or low priority\nThe interrupt priority feature is enabled by setting the IPEN bit (RCON<7>). When  interrupt priority is enabled, there are two bits which enable interrupts globally.  Setting  the  GIEH  bit  (INTCON<7>)  enables  all interrupts that have the priority bit set. Setting the GIEL bit  (INTCON<6>) enables all interrupts that have the priority bit cleared. When the interrupt flag, enable bit and appropriate global interrupt enable bit are set, the interrupt will vector immediately to address 000008h or 000018h,  depending  on  the  priority  level.  Individual interrupts can be disabled through their corresponding enable bits.",
    "8.0 INTERRUPTS\nWhen the IPEN bit is cleared (default state), the interrupt priority feature is disabled and interrupts are compatible with PICmicro fi mid-range devices. In Compatibility mode, the interrupt priority bits for each source  have  no  effect.  INTCON<6>  is  the  PEIE  bit, which enables/disables all peripheral interrupt sources. INTCON<7> is the GIE bit, which enables/disables all interrupt  sources.  All  interrupts  branch  to  address 000008h in Compatibility mode.\nWhen an interrupt is responded to, the Global Interrupt Enable bit is cleared to disable further interrupts. If the IPEN bit is cleared, this is the GIE bit. If interrupt priority levels are used, this will be either the GIEH or GIEL bit. High  priority  interrupt  sources  can  interrupt  a  low priority interrupt.\nThe return address is pushed onto the stack and the PC  is loaded with the interrupt vector address (000008h or 000018h). Once in the Interrupt Service Routine,  the  source(s)  of  the  interrupt  can  be  determined by polling the  interrupt  flag  bits.  The  interrupt flag bits must be cleared in software before re-enabling interrupts to avoid recursive interrupts.",
    "8.0 INTERRUPTS\nThe 'return  from  interrupt'  instruction, RETFIE ,  exits the interrupt routine and sets the GIE bit (GIEH or GIEL if priority levels are used), which re-enables interrupts.\nFor external interrupt events, such as the INT pins or the PORTB input change interrupt, the interrupt latency will be  three  to  four  instruction  cycles.  The  exact latency is the same for one or two-cycle instructions. Individual interrupt flag bits are set, regardless of the status of their corresponding enable bit or the GIE bit.",
    "Note:\nDo not use the MOVFF instruction to modify any of the Interrupt control registers while any interrupt  is  enabled.  Doing  so  may cause erratic microcontroller behavior.",
    "8.1 INTCON Registers\nThe INTCON Registers are readable and writable registers,  which contain various enable, priority and flag bits.\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its  corresponding enable bit or the global enable  bit.  User  software  should  ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.",
    "REGISTER 8-1: INTCON REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-x. GIE/GIEH, 1 = PEIE/GIEL. GIE/GIEH, 2 = TMR0IE. GIE/GIEH, 3 = INT0IE. GIE/GIEH, 4 = RBIE. GIE/GIEH, 5 = TMR0IF. GIE/GIEH, 6 = INT0IF. GIE/GIEH, 7 = RBIF\nbit 7\nbit 0",
    "bit 7 GIE/GIEH: Global Interrupt Enable bit\nWhen IPEN = 0:\n1 = Enables all unmasked interrupts\n0 = Disables all interrupts",
    "When IPEN = 1:\n1 = Enables all high priority interrupts\n0 = Disables all interrupts",
    "When IPEN = 0:\n1 = Enables all unmasked peripheral interrupts\n0 = Disables all peripheral interrupts",
    "When IPEN = 1:\n1 = Enables all low priority peripheral interrupts\n0 = Disables all low priority peripheral interrupts\nTMR0IE:\nTMR0 Overflow Interrupt Enable bit\n1 = Enables the TMR0 overflow interrupt\n0 = Disables the TMR0 overflow interrupt",
    "bit 4 INT0IE: INT0 External Interrupt Enable bit\n1 = Enables the INT0 external interrupt\n0 = Disables the INT0 external interrupt",
    "bit 3 RBIE: RB Port Change Interrupt Enable bit\n1 = Enables the RB port change interrupt\n0 = Disables the RB port change interrupt\nbit 2 TMR0IF: TMR0 Overflow Interrupt Flag bit\n1 = TMR0 register has overflowed (must be cleared in software)\n0 = TMR0 register did not overflow\nbit 1 INT0IF: INT0 External Interrupt Flag bit\n1 = The INT0 external interrupt occurred (must be cleared in software)\n0 = The INT0 external interrupt did not occur",
    "bit 0 RBIF: RB Port Change Interrupt Flag bit\n1 = At least one of the RB7:RB4 pins changed state (must be cleared in software)\n0 = None of the RB7:RB4 pins have changed state\nNote:\nA mismatch condition will continue to set this bit. Reading PORTB will end the mismatch condition and allow the bit to be cleared.\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 5",
    "INTCON2 REGISTER\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-1. R/W-1, 3 = R/W-1. R/W-1, 4 = U-0. R/W-1, 5 = R/W-1. R/W-1, 6 = U-0. R/W-1, 7 = R/W-1. RBPU, 1 = INTEDG0. RBPU, 2 = INTEDG1. RBPU, 3 = INTEDG2. RBPU, 4 = -. RBPU, 5 = TMR0IP. RBPU, 6 = -. RBPU, 7 = RBIP\nbit 7\nbit 0\nRBPU : PORTB Pull-up Enable bit",
    "INTCON2 REGISTER\n1 = All PORTB pull-ups are disabled\n0 = PORTB pull-ups are enabled by individual port latch values\nbit 6 INTEDG0 :External Interrupt0 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 5 INTEDG1 : External Interrupt1 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 4 INTEDG2 : External Interrupt2 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 3 Unimplemented: Read as '0'\nbit 2 TMR0IP : TMR0 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 1 Unimplemented: Read as '0'\nbit 0 RBIP : RB Port Change Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "Legend:\nR = Readable bit\n- n = Value at POR\nW = Writable bit\nU = Unimplemented bit, read as '0'\n'1' = Bit is set\n'0' = Bit is cleared x = Bit is unknown\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.\nbit 7",
    "REGISTER 8-3: INTCON3 REGISTER\nR/W-1, 1 = R/W-1. R/W-1, 2 = U-0. R/W-1, 3 = R/W-0. R/W-1, 4 = R/W-0. R/W-1, 5 = U-0. R/W-1, 6 = R/W-0. R/W-1, 7 = R/W-0. INT2IP, 1 = INT1IP. INT2IP, 2 = -. INT2IP, 3 = INT2IE. INT2IP, 4 = INT1IE. INT2IP, 5 = -. INT2IP, 6 = INT2IF. INT2IP, 7 = INT1IF\nbit 7\nbit 0\nbit 7 INT2IP: INT2 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nINT1IP: INT1 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5 Unimplemented: Read as '0'\nbit 4 INT2IE: INT2 External Interrupt Enable bit\n1 = Enables the INT2 external interrupt\n0 = Disables the INT2 external interrupt",
    "bit 3 INT1IE: INT1 External Interrupt Enable bit\n1 = Enables the INT1 external interrupt\n0 = Disables the INT1 external interrupt",
    "bit 2 Unimplemented: Read as '0'\nbit 1 INT2IF: INT2 External Interrupt Flag bit\n1 = The INT2 external interrupt occurred (must be cleared in software)\n0 = The INT2 external interrupt did not occur",
    "bit 0 INT1IF: INT1 External Interrupt Flag bit\n1 = The INT1 external interrupt occurred (must be cleared in software)\n0 = The INT1 external interrupt did not occur",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.\nbit 6",
    "8.2 PIR Registers\nNote\nThe PIR registers contain the individual flag bits for the peripheral interrupts. Due to the number of peripheral interrupt  sources,  there  are  two  Peripheral  Interrupt Flag Registers (PIR1, PIR2).\n1: Interrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit, GIE (INTCON<7>).\n2: User software should ensure the appropriate interrupt flag bits are cleared prior to enabling an interrupt, and after servicing that interrupt.",
    "REGISTER 8-4: PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PSPIF (1), 1 = ADIF. PSPIF (1), 2 = RCIF. PSPIF (1), 3 = TXIF. PSPIF (1), 4 = SSPIF. PSPIF (1), 5 = CCP1IF. PSPIF (1), 6 = TMR2IF. PSPIF (1), 7 = TMR1IF\nbit 7\nbit 0\nbit 7 PSPIF (1) : Parallel Slave Port Read/Write Interrupt Flag bit\n1 = A read or a write operation has taken place (must be cleared in software)\n0 = No read or write has occurred",
    "bit 6 ADIF : A/D Converter Interrupt Flag bit\n- 1 = An A/D conversion completed (must be cleared in software)\n0 = The A/D conversion is not complete\nbit 5 RCIF : USART Receive Interrupt Flag bit\n1 = The USART receive buffer, RCREG, is full (cleared when RCREG is read)\n0 = The USART receive buffer is empty\nbit 4 TXIF : USART Transmit Interrupt Flag bit (see Section 16.0 for details on TXIF functionality)\n1 = The USART transmit buffer, TXREG, is empty (cleared when TXREG is written)\n0 = The USART transmit buffer is full\nbit 3 SSPIF : Master Synchronous Serial Port Interrupt Flag bit\n1 = The transmission/reception is complete (must be cleared in software)\n0 = Waiting to transmit/receive",
    "bit 2 CCP1IF : CCP1 Interrupt Flag bit\nCapture mode:\n1 = A TMR1 register capture occurred (must be cleared in software)\n0 = No TMR1 register capture occurred",
    "Compare mode:\n1 = A TMR1 register compare match occurred (must be cleared in software)\n0 = No TMR1 register compare match occurred",
    "PWM mode:\nUnused in this mode",
    "bit 1 TMR2IF: TMR2 to PR2 Match Interrupt Flag bit\n1 = TMR2 to PR2 match occurred (must be cleared in software)\n0 = No TMR2 to PR2 match occurred",
    "bit 0 TMR1IF: TMR1 Overflow Interrupt Flag bit\n1 = TMR1 register overflowed (must be cleared in software)\n0 =  MR1 register did not overflow\nNote 1: This bit is reserved on PIC18F2X2 devices; always maintain this bit clear.\n\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 8-5: PIR2: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 2\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = EEIF. -, 4 = BCLIF. -, 5 = LVDIF. -, 6 = TMR3IF. -, 7 = CCP2IF\nbit 7\nbit 0",
    "bit 7-5 Unimplemented: Read as '0'\nbit 4\nEEIF : Data EEPROM/FLASH Write Operation Interrupt Flag bit\n1 = The Write operation is complete (must be cleared in software)\n0 = The Write operation is not complete, or has not been started\nbit 3 BCLIF : Bus Collision Interrupt Flag bit\n1 = A bus collision occurred (must be cleared in software)\n0 = No bus collision occurred",
    "bit 2 LVDIF\n: Low Voltage Detect Interrupt Flag bit\n1 = A low voltage condition occurred (must be cleared in software)\n0 = The device voltage is above the Low Voltage Detect trip point",
    "bit 1\nTMR3IF : TMR3 Overflow Interrupt Flag bit\n1 = TMR3 register overflowed (must be cleared in software)\n0 = TMR3 register did not overflow\nbit 0\nCCP2IF : CCPx Interrupt Flag bit\nCapture mode:\n1 = A TMR1 register capture occurred (must be cleared in software)\n0 = No TMR1 register capture occurred",
    "Compare mode:\n1 = A TMR1 register compare match occurred (must be cleared in software)\n0 = No TMR1 register compare match occurred",
    "PWM mode:\nUnused in this mode",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "8.3 PIE Registers\nThe PIE registers contain the individual enable bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are two Peripheral Interrupt Enable Registers (PIE1, PIE2). When IPEN = 0, the  PEIE  bit  must  be  set  to  enable  any  of  these peripheral interrupts.",
    "REGISTER 8-6: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PSPIE (1), 1 = ADIE. PSPIE (1), 2 = RCIE. PSPIE (1), 3 = TXIE. PSPIE (1), 4 = SSPIE. PSPIE (1), 5 = CCP1IE. PSPIE (1), 6 = TMR2IE. PSPIE (1), 7 = TMR1IE\nbit 7\nbit 0\nbit 7\nPSPIE (1) : Parallel Slave Port Read/Write Interrupt Enable bit\n1 = Enables the PSP read/write interrupt\n0 = Disables the PSP read/write interrupt",
    "bit 6 ADIE : A/D Converter Interrupt Enable bit\n1 = Enables the A/D interrupt\n0 = Disables the A/D interrupt\nbit 5\nRCIE : USART Receive Interrupt Enable bit\n1 = Enables the USART receive interrupt\n0 = Disables the USART receive interrupt\nbit 4\nTXIE : USART Transmit Interrupt Enable bit\n1 = Enables the USART transmit interrupt\n0 = Disables the USART transmit interrupt\nbit 3\nSSPIE : Master Synchronous Serial Port Interrupt Enable bit\n1 = Enables the MSSP interrupt\n0 = Disables the MSSP interrupt",
    "bit 2\nCCP1IE : CCP1 Interrupt Enable bit\n1 = Enables the CCP1 interrupt\n0 = Disables the CCP1 interrupt",
    "bit 1\nTMR2IE : TMR2 to PR2 Match Interrupt Enable bit\n1 = Enables the TMR2 to PR2 match interrupt\n0 = Disables the TMR2 to PR2 match interrupt\nbit 0\nTMR1IE : TMR1 Overflow Interrupt Enable bit\n1 = Enables the TMR1 overflow interrupt\n0 = Disables the TMR1 overflow interrupt\nNote 1: This bit is reserved on PIC18F2X2 devices; always maintain this bit clear.\n\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 8-7:\nbit 3\nbit 2",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = EEIE. -, 4 = BCLIE. -, 5 = LVDIE. -, 6 = TMR3IE. -, 7 = CCP2IE\nbit 7\nbit 0",
    "bit 7-5 Unimplemented: Read as '0'\nbit 4 EEIE : Data EEPROM/FLASH Write Operation Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nBCLIE : Bus Collision Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nLVDIE : Low Voltage Detect Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nTMR3IE : TMR3 Overflow Interrupt Enable bit\n1 = Enables the TMR3 overflow interrupt\n0 = Disables the TMR3 overflow interrupt\nCCP2IE : CCP2 Interrupt Enable bit\n1 = Enables the CCP2 interrupt\n0 = Disables the CCP2 interrupt\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "8.4 IPR Registers\nThe IPR registers contain the individual priority bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are two Peripheral Interrupt Priority Registers (IPR1, IPR2). The operation of the  priority  bits requires  that  the  Interrupt  Priority Enable (IPEN) bit be set.",
    "REGISTER 8-8: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-1. R/W-1, 3 = R/W-1. R/W-1, 4 = R/W-1. R/W-1, 5 = R/W-1. R/W-1, 6 = R/W-1. R/W-1, 7 = R/W-1. PSPIP (1), 1 = ADIP. PSPIP (1), 2 = RCIP. PSPIP (1), 3 = TXIP. PSPIP (1), 4 = SSPIP. PSPIP (1), 5 = CCP1IP. PSPIP (1), 6 = TMR2IP. PSPIP (1), 7 = TMR1IP\nbit 7\nbit 0\nbit 7\nPSPIP (1) : Parallel Slave Port Read/Write Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6 ADIP : A/D Converter Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 8-8: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nbit 5\nRCIP : USART Receive Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4\nTXIP : USART Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nSSPIP : Master Synchronous Serial Port Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nCCP1IP : CCP1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nTMR2IP : TMR2 to PR2 Match Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 0 TMR1IP : TMR1 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority\nNote 1: This bit is reserved on PIC18F2X2 devices; always maintain this bit set.\n\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nU-0\nU-0\nU-0\nR/W-1\nR/W-1\nR/W-1\nR/W-1\n-\n-\n-\nEEIP\nBCLIP\nLVDIP\nbit 7\nbit 7-5\nUnimplemented: Read as '0'\nbit 4\nEEIP : Data EEPROM/FLASH Write Operation Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nBCLIP : Bus Collision Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nLVDIP : Low Voltage Detect Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nTMR3IP : TMR3 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nCCP2IP : CCP2 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "Legend:\nR = Readable bit\n- n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown\nTMR3IP\nR/W-1\nCCP2IP\nbit 0",
    "8.5 RCON Register\nThe RCON register contains the bit which is used to enable prioritized interrupts (IPEN).\nREGISTER 8-10:\nRCON REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R-1. R/W-0, 5 = R-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0\nbit 7\nIPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (16CXXX Compatibility mode)\nbit 6-5\nUnimplemented: Read as '0'\nbit 4\nRI:\nRESET Instruction Flag bit\nFor details of bit operation, see Register 4-3\nbit 3\nTO:",
    "8.5 RCON Register\nWatchdog Time-out Flag bit\nFor details of bit operation, see Register 4-3\nbit 2\nPD: Power-down Detection Flag bit\nFor details of bit operation, see Register 4-3\nbit 1\nPOR: Power-on Reset Status bit\nFor details of bit operation, see Register 4-3\nbit 0\nBOR:\nBrown-out Reset Status bit\nFor details of bit operation, see Register 4-3\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "8.6 INT0 Interrupt\nExternal  interrupts  on  the  RB0/INT0,  RB1/INT1  and RB2/INT2 pins are edge triggered: either rising, if the corresponding INTEDGx bit is set in the INTCON2 register, or falling, if the INTEDGx bit is clear. When a valid edge appears on the RBx/INTx pin, the corresponding flag bit INTxF is set. This interrupt can be disabled by clearing the corresponding enable bit INTxE. Flag bit INTxF must be cleared in software in the Interrupt Service Routine before re-enabling the interrupt. All external interrupts (INT0, INT1 and INT2) can wake-up the processor  from  SLEEP,  if  bit  INTxE  was  set  prior  to going into SLEEP. If the global interrupt enable bit GIE is set, the processor will branch to the interrupt vector following wake-up.\nInterrupt priority for INT1 and INT2 is determined by the value  contained  in  the  interrupt  priority  bits,  INT1IP (INTCON3<6>) and INT2IP (INTCON3<7>). There is no priority bit associated with INT0. It is always a high priority interrupt source.",
    "8.7 TMR0 Interrupt\nIn 8-bit mode  (which  is  the  default),  an  overflow (FFh \u2192 00h)  in  the  TMR0  register  will  set  flag  bit TMR0IF. In 16-bit mode, an overflow (FFFFh \u2192 0000h) in the TMR0H:TMR0L registers will set flag bit TMR0IF. The  interrupt  can  be  enabled/disabled  by  setting/ clearing enable bit T0IE (INTCON<5>). Interrupt priority for Timer0 is determined by the value contained in the interrupt priority bit TMR0IP (INTCON2<2>). See Section 10.0 for further details on the Timer0 module.",
    "8.8 PORTB Interrupt-on-Change\nAn input change  on  PORTB<7:4> sets  flag bit RBIF (INTCON<0>). The interrupt can be enabled/disabled by  setting/clearing  enable  bit,  RBIE  (INTCON<3>). Interrupt  priority  for  PORTB  interrupt-on-change  is determined  by  the  value  contained  in  the  interrupt priority bit, RBIP (INTCON2<0>).",
    "8.9 Context Saving During Interrupts\nDuring an interrupt, the return PC value is saved on the stack. Additionally, the WREG, STATUS and BSR registers are saved on the fast return stack. If a fast return from  interrupt  is  not  used  (See  Section 4.3),  the  user may need to save the WREG, STATUS and BSR registers  in  software.  Depending  on  the  user's  application, other registers may also need to be saved. Equation 8-1 saves  and  restores  the  WREG,  STATUS  and  BSR registers during an Interrupt Service Routine.",
    "SAVING STATUS, WREG AND BSR REGISTERS IN RAM\nMOVWF MOVFF MOVFF ;, 1 = W_TEMP STATUS, STATUS_TEMP BSR, BSR_TEMP. MOVWF MOVFF MOVFF ;, 2 = ; W_TEMP is in virtual bank ; STATUS_TEMP located anywhere ; BSR located anywhere. ; USER, 1 = ISR CODE. ; USER, 2 = . MOVFF, 1 = BSR_TEMP, BSR. MOVFF, 2 = ; Restore BSR. MOVF, 1 = W_TEMP, W. MOVF, 2 = ; Restore WREG. MOVFF, 1 = STATUS_TEMP,STATUS. MOVFF, 2 = ; Restore STATUS",
    "PIC18FXX2\nNOTES:",
    "9.0 I/O PORTS\nDepending on the device selected, there are either five ports  or  three  ports  available.  Some  pins  of  the  I/O ports  are  multiplexed  with  an  alternate  function  from the peripheral features on the device. In general, when a peripheral is enabled, that pin may not be used as a general purpose I/O pin.\nEach port has three registers for its operation. These registers are:\nGLYPH<129> TRIS register (data direction register)\nGLYPH<129> PORT register (reads the levels on the pins of the device)\nGLYPH<129> LAT register (output latch)\nThe data latch (LAT register) is useful for read-modifywrite  operations  on  the  value  that  the  I/O  pins  are driving.",
    "9.1 PORTA, TRISA and LATA Registers\nPORTA is a 7-bit wide, bi-directional port. The corresponding Data Direction register is  TRISA.  Setting  a TRISA bit (= 1) will make the corresponding PORTA pin an input (i.e., put the corresponding output driver in a Hi-Impedance mode). Clearing a TRISA bit (= 0) will make the corresponding PORTA pin an output (i.e., put the contents of the output latch on the selected pin).\nReading the  PORTA register reads the  status  of  the pins, whereas writing to it will write to the port latch.\nThe  Data  Latch register (LATA)  is also memory mapped.  Read-modify-write  operations  on  the  LATA register reads and writes the latched output value for PORTA.\nThe  RA4  pin  is  multiplexed  with  the  Timer0  module clock input to become the RA4/T0CKI pin. The RA4/ T0CKI pin is a Schmitt Trigger input and an open drain output. All other RA port pins have TTL input levels and full CMOS output drivers.",
    "9.1 PORTA, TRISA and LATA Registers\nThe  other  PORTA  pins  are  multiplexed  with  analog inputs  and  the  analog  VREF+  and  VREF-  inputs.  The operation of each pin is selected by clearing/setting the control  bits  in  the  ADCON1  register  (A/D  Control Register1).\nNote:, 1 = On a Power-on Reset, RA5 and RA3:RA0 are configured as analog inputs and read as '0'. RA6 and RA4 are configured as digital inputs.\nThe  TRISA  register  controls  the  direction  of  the  RA pins, even when they are being used as analog inputs. The user must ensure the bits in the TRISA register are maintained set when using them as analog inputs.",
    "INITIALIZING PORTA\nCLRF PORTA, 1 = ; Initialize PORTA by ; clearing output ; data latches. CLRF LATA, 1 = ; Alternate method ; to clear output ; data latches. MOVLW 0x07 MOVWF ADCON1 MOVLW 0xCF, 1 = ; Configure A/D ; for digital inputs ; Value used to ; initialize data. MOVWF TRISA, 1 = ; Set RA<3:0> as inputs ; RA<5:4> as outputs",
    "FIGURE 9-1: BLOCK DIAGRAM OF RA3:RA0 AND RA5 PINS\nNote 1: I/O pins have protection diodes to VDD and VSS.",
    "TABLE 9-1: PORTA FUNCTIONS\nRA0/AN0, Bit# = bit0. RA0/AN0, Buffer = TTL. RA0/AN0, Function = Input/output or analog input.. RA1/AN1, Bit# = bit1. RA1/AN1, Buffer = TTL. RA1/AN1, Function = Input/output or analog input.. RA2/AN2/VREF-, Bit# = bit2. RA2/AN2/VREF-, Buffer = TTL. RA2/AN2/VREF-, Function = Input/output or analog input or VREF-.. RA3/AN3/VREF+, Bit# = bit3. RA3/AN3/VREF+, Buffer = TTL. RA3/AN3/VREF+, Function = Input/output or analog input or VREF+.. RA4/T0CKI, Bit# = bit4. RA4/T0CKI, Buffer = ST. RA4/T0CKI, Function = Input/output or external clock input for Timer0. Output is open drain type..",
    "TABLE 9-1: PORTA FUNCTIONS\nRA5/SS/AN4/LVDIN, Bit# = bit5. RA5/SS/AN4/LVDIN, Buffer = TTL. RA5/SS/AN4/LVDIN, Function = Input/output or slave select input for synchronous serial port or analog input, or low voltage detect input.. OSC2/CLKO/RA6, Bit# = bit6. OSC2/CLKO/RA6, Buffer = TTL. OSC2/CLKO/RA6, Function = OSC2 or clock output or I/O pin.\nLegend: TTL = TTL input, ST = Schmitt Trigger input",
    "TABLE 9-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nPORTA, Bit 7 = -. PORTA, Bit 6 = RA6. PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR = -x0x 0000. PORTA, Value on All Other RESETS = -u0u 0000. LATA, Bit 7 = -. LATA, Bit 6 = LATA Data Output Register. LATA, Bit 5 = LATA Data Output Register. LATA, Bit 4 = LATA Data Output Register. LATA, Bit 3 = LATA Data Output Register. LATA, Bit 2 = LATA Data Output Register. LATA, Bit 1 = LATA Data Output Register. LATA, Bit 0 = . LATA, Value on POR, BOR = -xxx xxxx. LATA, Value on All Other RESETS = -uuu uuuu. TRISA, Bit 7 = -. TRISA, Bit 6 = PORTA Data",
    "TABLE 9-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nDirection Register. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = . TRISA, Value on POR, BOR = -111 1111. TRISA, Value on All Other RESETS = -111 1111. ADCON1, Bit 7 = ADFM. ADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 = -. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = 00-- 0000. ADCON1, Value on All Other RESETS = 00-- 0000",
    "TABLE 9-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nLegend: x = unknown, u = unchanged, - = unimplemented locations read as '0'. Shaded cells are not used by PORTA.",
    "9.2 PORTB, TRISB and LATB Registers\nPORTB is an 8-bit wide, bi-directional port. The corresponding Data Direction register is  TRISB.  Setting  a TRISB bit (= 1) will make the corresponding PORTB pin an input (i.e., put the corresponding output driver in a Hi-Impedance mode). Clearing a TRISB bit (= 0) will make the corresponding PORTB pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATB)  is also memory mapped.  Read-modify-write  operations  on  the  LATB register reads and writes the latched output value for PORTB.",
    "EXAMPLE 9-2: INITIALIZING PORTB\nCLRF, 1 = PORTB. CLRF, 2 = ; Initialize PORTB by ; clearing output ; data latches. CLRF, 1 = LATB. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0xCF. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISB. MOVWF, 2 = ; Set RB<3:0> as inputs ; RB<5:4> as outputs ; RB<7:6> as inputs\nEach of the PORTB pins has a weak internal pull-up. A single control bit can turn on all the pull-ups. This is performed  by  clearing  bit  RBPU  (INTCON2<7>).  The weak pull-up is automatically turned off when the port pin  is configured  as  an  output.  The  pull-ups  are disabled on a Power-on Reset.\nNote: On  a  Power-on  Reset,  these  pins  are configured as digital inputs.",
    "EXAMPLE 9-2: INITIALIZING PORTB\nFour of the PORTB pins, RB7:RB4, have an interrupton-change feature. Only pins configured as inputs can cause  this  interrupt  to  occur  (i.e.,  any  RB7:RB4  pin configured as an output is excluded from the interrupton-change comparison). The input pins (of RB7:RB4) are  compared  with  the  old  value  latched  on  the  last read of PORTB. The 'mismatch' outputs of RB7:RB4 are OR'ed together to generate the RB Port Change Interrupt with flag bit, RBIF (INTCON<0>).\nThis interrupt can wake the device from SLEEP. The user,  in  the  Interrupt  Service  Routine,  can  clear  the interrupt in the following manner:\na) Any  read  or  write  of  PORTB  (except  with  the MOVFF instruction). This will end the mismatch condition.\nb) Clear flag bit RBIF.\nA mismatch condition will continue to set flag bit RBIF. Reading PORTB will end the mismatch condition and allow flag bit RBIF to be cleared.",
    "EXAMPLE 9-2: INITIALIZING PORTB\nThe interrupt-on-change  feature  is  recommended  for wake-up on key depression operation and operations where PORTB is only used for the interrupt-on-change feature. Polling of PORTB is not recommended while using the interrupt-on-change feature.\nRB3  can  be  configured by the configuration bit CCP2MX as the alternate peripheral pin for the CCP2 module (CCP2MX=' 0 ').",
    "FIGURE 9-4: BLOCK DIAGRAM OF RB7:RB4 PINS\nNote 1: I/O pins have diode protection to VDD and VSS.\n2: To enable weak pull-ups, set the appropriate TRIS bit(s) and clear the RBPU bit (INTCON2<7>).\nNote 1: While  in  Low  Voltage  ICSP  mode,  the RB5 pin can no longer be used as a general purpose I/O pin, and should be held low  during  normal  operation  to  protect against inadvertent ICSP mode entry.\n2: When using Low Voltage ICSP programming (LVP), the pull-up on RB5 becomes disabled. If TRISB  bit 5 is cleared, thereby setting RB5 as an output, LATB bit  5  must  also  be  cleared  for  proper operation.",
    "TABLE 9-3: PORTB FUNCTIONS\nRB0/INT0, Bit# = bit0. RB0/INT0, Buffer = TTL/ST (1). RB0/INT0, Function = Input/output pin or external interrupt input0. Internal software programmable weak pull-up.. RB1/INT1, Bit# = bit1. RB1/INT1, Buffer = TTL/ST (1). RB1/INT1, Function = Input/output pin or external interrupt input1. Internal software programmable weak pull-up.. RB2/INT2, Bit# = bit2. RB2/INT2, Buffer = TTL/ST (1). RB2/INT2, Function = Input/output pin or external interrupt input2. Internal software programmable weak pull-up.. RB3/CCP2 (3), Bit# = bit3. RB3/CCP2 (3), Buffer = TTL/ST (4). RB3/CCP2 (3), Function = Input/output pin or Capture2 input/Compare2 output/PWM output when CCP2MX configuration bit is enabled. Internal software programmable weak",
    "TABLE 9-3: PORTB FUNCTIONS\npull-up.. RB4, Bit# = bit4. RB4, Buffer = TTL. RB4, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up.. RB5/PGM (5), Bit# = bit5. RB5/PGM (5), Buffer = TTL/ST (2). RB5/PGM (5), Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Low voltage ICSP enable pin.. RB6/PGC, Bit# = bit6. RB6/PGC, Buffer = TTL/ST (2). RB6/PGC, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Serial programming clock.. RB7/PGD, Bit# = bit7. RB7/PGD, Buffer = TTL/ST (2). RB7/PGD, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Serial programming",
    "TABLE 9-3: PORTB FUNCTIONS\ndata.\nLegend:  TTL = TTL input, ST = Schmitt Trigger input\nNote\n1: This buffer is a Schmitt Trigger input when configured as the external interrupt.\n2: This buffer is a Schmitt Trigger input when used in Serial Programming mode.\n3: A device configuration bit selects which I/O pin the CCP2 pin is multiplexed on.\n4: This buffer is a Schmitt Trigger input when configured as the CCP2 input.\n5: Low Voltage ICSP Programming (LVP) is enabled by default, which disables the RB5 I/O function. LVP must be disabled to enable RB5 as an I/O pin and allow maximum compatibility to the other 28-pin and 40-pin mid-range devices.",
    "TABLE 9-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nPORTB, Bit 7 = RB7. PORTB, Bit 6 = RB6. PORTB, Bit 5 = RB5. PORTB, Bit 4 = RB4. PORTB, Bit 3 = RB3. PORTB, Bit 2 = RB2. PORTB, Bit 1 = RB1. PORTB, Bit 0 = RB0. PORTB, Value on POR, BOR = xxxx. PORTB, Value on All Other RESETS = xxxx. PORTB, Value on All Other RESETS = uuuu. PORTB, Value on All Other RESETS = uuuu. LATB, Bit 7 = LATB Data Output Register. LATB, Bit 6 = LATB Data Output Register. LATB, Bit 5 = LATB Data Output Register. LATB, Bit 4 = LATB Data Output Register. LATB, Bit 3 = LATB Data Output Register. LATB, Bit 2 = LATB Data Output Register. LATB, Bit 1 = LATB Data Output Register. LATB, Bit 0 = LATB Data Output Register. LATB,",
    "TABLE 9-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nValue on POR, BOR = xxxx. LATB, Value on All Other RESETS = xxxx. LATB, Value on All Other RESETS = uuuu. LATB, Value on All Other RESETS = uuuu. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR = 1111. TRISB, Value on All Other RESETS = 1111. TRISB, Value on All Other RESETS = 1111. TRISB, Value on All Other RESETS = 1111. INTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit",
    "TABLE 9-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\n4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on All Other RESETS = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = -. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = -. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111. INTCON2, Value on All Other RESETS = -1-1. INTCON2, Value on All Other RESETS = 1111. INTCON2, Value on All Other RESETS =",
    "TABLE 9-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\n-1-1. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 11-0. INTCON3, Value on All Other RESETS = 0-00. INTCON3, Value on All Other RESETS = 11-0. INTCON3, Value on All Other RESETS = 0-00\nLegend: x = unknown, u = unchanged. Shaded cells are not used by PORTB.",
    "9.3 PORTC, TRISC and LATC Registers\nPORTC is an 8-bit wide, bi-directional port. The corresponding Data Direction register is  TRISC.  Setting a TRISC bit (= 1) will make the corresponding PORTC pin an input (i.e., put the corresponding output driver in a Hi-Impedance mode). Clearing a TRISC bit (= 0) will make the corresponding PORTC pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATC)  is  also memory mapped.  Read-modify-write  operations  on  the  LATC register reads and writes the latched output value for PORTC.\nPORTC is multiplexed with several peripheral functions (Table 9-5).  PORTC  pins  have  Schmitt  Trigger  input buffers.\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTC pin. Some peripherals override the TRIS bit to make a pin an output,  while  other  peripherals  override  the  TRIS  bit  to make a pin an input. The user should refer to the corresponding  peripheral  section  for  the  correct  TRIS  bit settings.",
    "9.3 PORTC, TRISC and LATC Registers\nThe pin override value is not loaded into the TRIS register. This allows read-modify-write of the TRIS register, without concern due to peripheral overrides.\nRC1  is normally configured by configuration bit, CCP2MX, as the default peripheral pin  of  the CCP2 module (default/erased state, CCP2MX = ' 1 ').\nCLRF PORTC, 9-3: INITIALIZING PORTC = ; Initialize PORTC by ; clearing output ; data latches. CLRF LATC, 9-3: INITIALIZING PORTC = ; Alternate method ; to clear output ; data latches. MOVLW 0xCF, 9-3: INITIALIZING PORTC = ; Value used to ; initialize data ; direction. MOVWF TRISC, 9-3: INITIALIZING PORTC = ; Set RC<3:0> as inputs ; RC<5:4> as outputs ; RC<7:6> as inputs\nNote:, 1 = On a Power-on Reset, these pins are configured as digital inputs.",
    "TABLE 9-5: PORTC FUNCTIONS\nRC0/T1OSO/T1CKI, Bit# = bit0. RC0/T1OSO/T1CKI, Buffer Type = ST. RC0/T1OSO/T1CKI, Function = Input/output port pin or Timer1 oscillator output/Timer1 clock input.. RC1/T1OSI/CCP2, Bit# = bit1. RC1/T1OSI/CCP2, Buffer Type = ST. RC1/T1OSI/CCP2, Function = Input/output port pin, Timer1 oscillator input, or Capture2 input/ Compare2 output/PWM output when CCP2MX configuration bit is set.. RC2/CCP1, Bit# = bit2. RC2/CCP1, Buffer Type = ST. RC2/CCP1, Function = Input/output port pin or Capture1 input/Compare1 output/PWM1 output.. RC3/SCK/SCL, Bit# = bit3. RC3/SCK/SCL, Buffer Type = ST. RC3/SCK/SCL, Function = RC3 can",
    "TABLE 9-5: PORTC FUNCTIONS\nalso be the synchronous serial clock for both SPI and I 2 C modes.. RC4/SDI/SDA, Bit# = bit4. RC4/SDI/SDA, Buffer Type = ST. RC4/SDI/SDA, Function = RC4 can also be the SPI Data In (SPI mode) or Data I/O (I 2 C mode).. RC5/SDO, Bit# = bit5. RC5/SDO, Buffer Type = ST. RC5/SDO, Function = Input/output port pin or Synchronous Serial Port data output.. RC6/TX/CK, Bit# = bit6. RC6/TX/CK, Buffer Type = ST. RC6/TX/CK, Function = Input/output port pin, Addressable USART Asynchronous Transmit, or Addressable USART Synchronous Clock.. RC7/RX/DT, Bit# = bit7. RC7/RX/DT, Buffer Type = ST. RC7/RX/DT, Function = Input/output port pin, Addressable USART",
    "TABLE 9-5: PORTC FUNCTIONS\nAsynchronous Receive, or Addressable USART Synchronous Data.\nLegend: ST = Schmitt Trigger input",
    "TABLE 9-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nPORTC, Bit 7 = RC7. PORTC, Bit 6 = RC6. PORTC, Bit 5 = RC5. PORTC, Bit 4 = RC4. PORTC, Bit 3 = RC3. PORTC, Bit 2 = RC2. PORTC, Bit 1 = RC1 RC0. PORTC, Bit 0 = xxxx xxxx. PORTC, Value on POR, BOR = uuuu. PORTC, Value on All Other RESETS = uuuu. LATC, Bit 7 = LATC Data Output Register. LATC, Bit 6 = LATC Data Output Register. LATC, Bit 5 = LATC Data Output Register. LATC, Bit 4 = LATC Data Output Register. LATC, Bit 3 = LATC Data Output Register. LATC, Bit 2 = LATC Data Output Register. LATC, Bit 1 = LATC Data Output Register. LATC, Bit 0 = xxxx. LATC, Value on POR, BOR = xxxx. LATC, Value on All Other RESETS = uuuu uuuu. TRISC, Bit 7 = PORTC Data Direction Register.",
    "TABLE 9-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nTRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on All Other RESETS = 1111 1111\nLegend: x = unknown, u = unchanged",
    "9.4 PORTD, TRISD and LATD Registers\nThis  section  is  applicable  only  to  the  PIC18F4X2 devices.\nPORTD is an 8-bit wide, bi-directional port. The corresponding Data Direction register is  TRISD.  Setting a TRISD bit (= 1) will make the corresponding PORTD pin an input (i.e., put the corresponding output driver in a Hi-Impedance mode). Clearing a TRISD bit (= 0) will make the corresponding PORTD pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATD)  is  also memory mapped.  Read-modify-write  operations  on  the  LATD register reads and writes the latched output value for PORTD.\nPORTD is an 8-bit port with Schmitt Trigger input buffers. Each pin is individually configurable as an input or output.\nNote:, 1 = On a Power-on Reset, these pins are configured as digital inputs.",
    "9.4 PORTD, TRISD and LATD Registers\nPORTD can be configured as an 8-bit wide microprocessor port  (parallel  slave  port)  by  setting  control  bit PSPMODE (TRISE<4>). In this mode, the input buffers are TTL. See Section 9.6 for additional information on the Parallel Slave Port (PSP).",
    "EXAMPLE 9-4: INITIALIZING PORTD\nCLRF, 1 = PORTD. CLRF, 2 = ; Initialize PORTD by ; clearing output ; data latches. CLRF, 1 = LATD. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0xCF. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISD. MOVWF, 2 = ; Set RD<3:0> as inputs ; RD<5:4> as outputs ; RD<7:6> as inputs",
    "FIGURE 9-8: PORTD BLOCK DIAGRAM IN I/O PORT MODE\nNote 1: I/O pins have diode protection to VDD and VSS.",
    "PIC18FXX2\nTABLE 9-7:",
    "PORTD FUNCTIONS\nRD0/PSP0, Bit# = bit0. RD0/PSP0, Buffer Type = ST/TTL (1). RD0/PSP0, Function = Input/output port pin or parallel slave port bit0.. RD1/PSP1, Bit# = bit1. RD1/PSP1, Buffer Type = ST/TTL (1). RD1/PSP1, Function = Input/output port pin or parallel slave port bit1.. RD2/PSP2, Bit# = bit2. RD2/PSP2, Buffer Type = ST/TTL (1). RD2/PSP2, Function = Input/output port pin or parallel slave port bit2.. RD3/PSP3, Bit# = bit3. RD3/PSP3, Buffer Type = ST/TTL (1). RD3/PSP3, Function = Input/output port pin or parallel slave port bit3.. RD4/PSP4, Bit# = bit4. RD4/PSP4, Buffer Type = ST/TTL (1). RD4/PSP4, Function =",
    "PORTD FUNCTIONS\nInput/output port pin or parallel slave port bit4.. RD5/PSP5, Bit# = bit5. RD5/PSP5, Buffer Type = ST/TTL (1). RD5/PSP5, Function = Input/output port pin or parallel slave port bit5.. RD6/PSP6, Bit# = bit6. RD6/PSP6, Buffer Type = ST/TTL (1). RD6/PSP6, Function = Input/output port pin or parallel slave port bit6.. RD7/PSP7, Bit# = bit7. RD7/PSP7, Buffer Type = ST/TTL (1). RD7/PSP7, Function = Input/output port pin or parallel slave port bit7.\nLegend:  ST = Schmitt Trigger input,  TTL = TTL input\nNote 1: Input buffers are Schmitt Triggers when in I/O mode and TTL buffer when in Parallel Slave Port mode.",
    "TABLE 9-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nPORTD, Bit 7 = RD7. PORTD, Bit 6 = RD6. PORTD, Bit 5 = RD5. PORTD, Bit 4 = RD4. PORTD, Bit 3 = RD3. PORTD, Bit 2 = RD2. PORTD, Bit 1 = RD1. PORTD, Bit 0 = RD0. PORTD, Value on POR, BOR = xxxx. PORTD, Value on POR, BOR = xxxx. PORTD, Value on All Other RESETS = uuuu. PORTD, Value on All Other RESETS = uuuu. LATD, Bit 7 = LATD Data Output Register. LATD, Bit 6 = LATD Data Output Register. LATD, Bit 5 = LATD Data Output Register. LATD, Bit 4 = LATD Data Output Register. LATD, Bit 3 = LATD Data Output Register. LATD, Bit 2 = LATD Data Output Register. LATD, Bit 1 = LATD Data Output Register. LATD, Bit 0 = LATD Data Output Register. LATD,",
    "TABLE 9-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nValue on POR, BOR = xxxx. LATD, Value on POR, BOR = xxxx. LATD, Value on All Other RESETS = uuuu. LATD, Value on All Other RESETS = uuuu. TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Value on POR, BOR = 1111. TRISD, Value on POR, BOR = 1111. TRISD, Value on All Other RESETS = 1111. TRISD, Value on All Other RESETS = 1111. TRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 = PSPMODE. TRISE,",
    "TABLE 9-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nBit 3 = -. TRISE, Bit 2 = PORTE Data Direction bits. TRISE, Bit 1 = PORTE Data Direction bits. TRISE, Bit 0 = PORTE Data Direction bits. TRISE, Value on POR, BOR = 0000. TRISE, Value on POR, BOR = -111. TRISE, Value on All Other RESETS = 0000. TRISE, Value on All Other RESETS = -111\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'. Shaded cells are not used by PORTD. -",
    "9.5 PORTE, TRISE and LATE Registers\nThis  section  is  only  applicable  to  the  PIC18F4X2 devices.\nPORTE is a 3-bit wide, bi-directional port. The corresponding Data Direction register is  TRISE.  Setting  a TRISE bit (= 1) will make the corresponding PORTE pin an input (i.e., put the corresponding output driver in a Hi-Impedance mode). Clearing a TRISE bit (= 0) will make the corresponding PORTE pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATE)  is also memory mapped.  Read-modify-write  operations  on  the  LATE register reads and writes the latched output value for PORTE.\nPORTE has three  pins  (RE0/RD/AN5,  RE1/WR/AN6 and RE2/CS/AN7) which are individually configurable as inputs or outputs. These pins have Schmitt Trigger input buffers.\nRegister 9-1  shows  the  TRISE  register,  which  also controls the parallel slave port operation.\nPORTE pins are multiplexed with analog inputs. When selected as an analog input, these pins will read as '0's.",
    "9.5 PORTE, TRISE and LATE Registers\nTRISE controls the direction of the RE pins, even when they are being used as analog inputs. The user must make sure to keep the pins configured as inputs when using them as analog inputs.\nNote: On  a  Power-on  Reset,  these  pins  are configured as analog inputs.",
    "EXAMPLE 9-5: INITIALIZING PORTE\nCLRF, 1 = PORTE. CLRF, 2 = ; Initialize PORTE by ; clearing output ; data latches. CLRF, 1 = LATE. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF MOVLW, 1 = 0x07 ADCON1 0x05. MOVLW MOVWF MOVLW, 2 = ; Configure A/D ; for digital inputs ; Value used to ; initialize data. MOVWF, 1 = TRISE. MOVWF, 2 = ; Set RE<0> as inputs ; RE<1> as outputs ; RE<2> as inputs",
    "FIGURE 9-9: PORTE BLOCK DIAGRAM IN I/O PORT MODE\nNote 1: I/O pins have diode protection to VDD and VSS.",
    "REGISTER 9-1:\nTRISE REGISTER",
    "REGISTER 9-1:\n, R-0 = IBF. , R-0 = OBF. , R/W-0 = IBOV. , R/W-0 = PSPMODE. , U-0 = -. , R/W-1 = TRISE2. , R/W-1 = TRISE1. , R/W-1 = TRISE0. , R-0 = bit 7. , R-0 = . , R/W-0 = . , R/W-0 = . , U-0 = . , R/W-1 = . , R/W-1 = . , R/W-1 = bit 0. bit 7, R-0 = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 7, R-0 = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 7, R/W-0 = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word",
    "REGISTER 9-1:\nhas been received. bit 7, R/W-0 = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 7, U-0 = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 7, R/W-1 = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 7, R/W-1 = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 7, R/W-1 = IBF: Input Buffer Full Status bit 1 = A word has been received and waiting to be read by the CPU 0 = No word has been received. bit 6, R-0 = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, R-0 = OBF : Output Buffer Full Status",
    "REGISTER 9-1:\nbit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, R/W-0 = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, R/W-0 = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, U-0 = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, R/W-1 = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, R/W-1 = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 6, R/W-1 = OBF : Output Buffer Full Status bit 1 = The output buffer still holds a previously written word 0 = The output buffer has been read. bit 5, R-0 = IBOV :",
    "REGISTER 9-1:\nInput Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read (must be cleared in software) 0 = No overflow occurred. bit 5, R-0 = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read (must be cleared in software) 0 = No overflow occurred. bit 5, R/W-0 = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read (must be cleared in software) 0 = No overflow occurred. bit 5, R/W-0 = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read (must be cleared in software) 0 = No overflow occurred. bit 5, U-0 = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read (must be cleared in software) 0 = No",
    "REGISTER 9-1:\noverflow occurred. bit 5, R/W-1 = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read (must be cleared in software) 0 = No overflow occurred. bit 5, R/W-1 = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read (must be cleared in software) 0 = No overflow occurred. bit 5, R/W-1 = IBOV : Input Buffer Overflow Detect bit (in Microprocessor mode) 1 = A write occurred when a previously input word has not been read (must be cleared in software) 0 = No overflow occurred. bit 4, R-0 = PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, R-0 = PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, R/W-0 = PSPMODE : Parallel Slave Port Mode Select bit 1 =",
    "REGISTER 9-1:\nParallel Slave Port mode 0 = General purpose I/O mode. bit 4, R/W-0 = PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, U-0 = PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, R/W-1 = PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, R/W-1 = PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 4, R/W-1 = PSPMODE : Parallel Slave Port Mode Select bit 1 = Parallel Slave Port mode 0 = General purpose I/O mode. bit 3, R-0 = Unimplemented: Read as '0'. bit 3, R-0 = Unimplemented: Read as '0'. bit 3, R/W-0 = Unimplemented: Read as '0'. bit 3, R/W-0 =",
    "REGISTER 9-1:\nUnimplemented: Read as '0'. bit 3, U-0 = Unimplemented: Read as '0'. bit 3, R/W-1 = Unimplemented: Read as '0'. bit 3, R/W-1 = Unimplemented: Read as '0'. bit 3, R/W-1 = Unimplemented: Read as '0'. bit 2, R-0 = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 2, R-0 = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 2, R/W-0 = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 2, R/W-0 = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 2, U-0 = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 2, R/W-1 = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 2, R/W-1 = TRISE2 :",
    "REGISTER 9-1:\nRE2 Direction Control bit 1 = Input 0 = Output. bit 2, R/W-1 = TRISE2 : RE2 Direction Control bit 1 = Input 0 = Output. bit 1, R-0 = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, R-0 = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, R/W-0 = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, R/W-0 = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, U-0 = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, R/W-1 = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, R/W-1 = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 1, R/W-1 = TRISE1 : RE1 Direction Control bit 1 = Input 0 = Output. bit 0, R-0 = TRISE0 : RE0 Direction Control bit 1 = Input 0",
    "REGISTER 9-1:\n= Output. bit 0, R-0 = TRISE0 : RE0 Direction Control bit 1 = Input 0 = Output. bit 0, R/W-0 = TRISE0 : RE0 Direction Control bit 1 = Input 0 = Output. bit 0, R/W-0 = TRISE0 : RE0 Direction Control bit 1 = Input 0 = Output. bit 0, U-0 = TRISE0 : RE0 Direction Control bit 1 = Input 0 = Output. bit 0, R/W-1 = TRISE0 : RE0 Direction Control bit 1 = Input 0 = Output. bit 0, R/W-1 = TRISE0 : RE0 Direction Control bit 1 = Input 0 = Output. bit 0, R/W-1 = TRISE0 : RE0 Direction Control bit 1 = Input 0 = Output. , R-0 = Legend:. , R-0 = Legend:. , R/W-0 = Legend:. , R/W-0 = Legend:. , U-0 = Legend:. , R/W-1 = Legend:. , R/W-1 = Legend:. , R/W-1 = Legend:",
    "TABLE 9-9: PORTE FUNCTIONS\n\nLegend:  ST = Schmitt Trigger input,  TTL = TTL input",
    "TABLE 9-9: PORTE FUNCTIONS\nRE0/RD/AN5, Bit# = bit0. RE0/RD/AN5, Buffer Type = ST/TTL (1). RE0/RD/AN5, Function = Input/output port pin or read control input in Parallel Slave Port mode or analog input: RD 1 = Not a read operation 0 = Read operation. Reads PORTD register (if chip selected).. RE1/WR/AN6, Bit# = bit1. RE1/WR/AN6, Buffer Type = ST/TTL (1). RE1/WR/AN6, Function = Input/output port pin or write control input in Parallel Slave Port mode or analog input: WR 1 = Not a write operation 0 = Write operation. Writes PORTD register (if chip selected).. RE2/CS/AN7, Bit# = bit2. RE2/CS/AN7, Buffer Type = ST/TTL (1). RE2/CS/AN7, Function = Input/output port pin or chip select control input in Parallel Slave Port mode or analog input: CS 1 = Device is not selected 0 = Device is selected",
    "TABLE 9-9: PORTE FUNCTIONS\nNote 1: Input buffers are Schmitt Triggers when in I/O mode and TTL buffers when in Parallel Slave Port mode.",
    "TABLE 9-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nPORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = -. PORTE, Bit 2 = RE2. PORTE, Bit 1 = RE1. PORTE, Bit 0 = RE0. PORTE, Value on POR, BOR = ----. PORTE, Value on POR, BOR = -000. PORTE, Value on All Other RESETS = ---- -000. LATE, Bit 7 = -. LATE, Bit 6 = -. LATE, Bit 5 = -. LATE, Bit 4 = -. LATE, Bit 3 = -. LATE, Bit 2 = LATE Data Output Register. LATE, Bit 1 = LATE Data Output Register. LATE, Bit 0 = LATE Data Output Register. LATE, Value on POR, BOR = ----. LATE, Value on POR, BOR = -xxx. LATE, Value on All Other RESETS = ---- -uuu. TRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 =",
    "TABLE 9-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nPSPMODE. TRISE, Bit 3 = -. TRISE, Bit 2 = PORTE Data Direction bits. TRISE, Bit 1 = PORTE Data Direction bits. TRISE, Bit 0 = PORTE Data Direction bits. TRISE, Value on POR, BOR = 0000. TRISE, Value on POR, BOR = -111. TRISE, Value on All Other RESETS = 0000 -111. ADCON1, Bit 7 = ADFM. ADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 = -. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = 00--. ADCON1, Value on POR, BOR = 0000. ADCON1, Value on All Other RESETS = 00-- 0000",
    "TABLE 9-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'. Shaded cells are not used by PORTE. -",
    "9.6 Parallel Slave Port\nThe Parallel Slave Port is implemented on the 40-pin devices only (PIC18F4X2).\nPORTD operates as an 8-bit wide Parallel Slave Port, or  microprocessor  port  when  control  bit,  PSPMODE (TRISE<4>) is set. It is asynchronously readable and writable by the external world through RD control input pin, RE0/RD and WR control input pin, RE1/WR.",
    "9.6 Parallel Slave Port\nIt can directly interface to an 8-bit microprocessor data bus. The external microprocessor can read or write the PORTD latch as an 8-bit latch. Setting bit PSPMODE enables port pin RE0/RD to be the RD input, RE1/WR to  be  the  WR  input  and  RE2/CS  to  be  the  CS  (chip select) input. For this functionality, the corresponding data direction bits of the TRISE register (TRISE<2:0>) must be configured as inputs (set). The A/D port configuration bits PCFG2:PCFG0 (ADCON1<2:0>) must be set, which will configure pins RE2:RE0 as digital I/O.\nA write to the PSP occurs when both the CS and WR lines are first detected low. A read from the PSP occurs when both the CS and RD lines are first detected low.",
    "9.6 Parallel Slave Port\nThe  PORTE  I/O  pins  become  control  inputs  for  the microprocessor port when bit PSPMODE (TRISE<4>) is set. In this mode, the user must make sure that the TRISE<2:0> bits are set (pins are configured as digital inputs), and the ADCON1 is configured for digital I/O. In this mode, the input buffers are TTL.\nFIGURE 9-11:",
    "PARALLEL SLAVE PORT WRITE WAVEFORMS\nFIGURE 9-10:\nPORTD AND PORTE BLOCK DIAGRAM (PARALLEL SLAVE PORT)",
    "TABLE 9-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nPORTD, Bit 7 = Port Data Latch when written; Port pins when read. PORTD, Bit 6 = Port Data Latch when written; Port pins when read. PORTD, Bit 5 = Port Data Latch when written; Port pins when read. PORTD, Bit 4 = Port Data Latch when written; Port pins when read. PORTD, Bit 3 = Port Data Latch when written; Port pins when read. PORTD, Bit 2 = Port Data Latch when written; Port pins when read. PORTD, Bit 1 = Port Data Latch when written; Port pins when read. PORTD, Bit 0 = Port Data Latch when written; Port pins when read. PORTD, Value on POR, BOR = xxxx. PORTD, Value on POR, BOR = xxxx. PORTD, Value on All Other RESETS = uuuu. PORTD, Value on All Other RESETS = uuuu. LATD, Bit 7 = LATD Data Output bits. LATD, Bit 6 = LATD Data Output bits. LATD, Bit 5 = LATD Data Output bits. LATD, Bit 4 = LATD Data",
    "TABLE 9-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nOutput bits. LATD, Bit 3 = LATD Data Output bits. LATD, Bit 2 = LATD Data Output bits. LATD, Bit 1 = LATD Data Output bits. LATD, Bit 0 = LATD Data Output bits. LATD, Value on POR, BOR = xxxx. LATD, Value on POR, BOR = xxxx. LATD, Value on All Other RESETS = uuuu. LATD, Value on All Other RESETS = uuuu. TRISD, Bit 7 = PORTD Data Direction bits. TRISD, Bit 6 = PORTD Data Direction bits. TRISD, Bit 5 = PORTD Data Direction bits. TRISD, Bit 4 = PORTD Data Direction bits. TRISD, Bit 3 = PORTD Data Direction bits. TRISD, Bit 2 = PORTD Data Direction bits. TRISD, Bit 1 = PORTD Data Direction bits. TRISD, Bit 0 = PORTD Data Direction bits. TRISD, Value on POR, BOR = 1111. TRISD, Value on POR, BOR = 1111. TRISD, Value",
    "TABLE 9-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\non All Other RESETS = 1111. TRISD, Value on All Other RESETS = 1111. PORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = -. PORTE, Bit 2 = RE2. PORTE, Bit 1 = RE1. PORTE, Bit 0 = RE0. PORTE, Value on POR, BOR = ----. PORTE, Value on POR, BOR = -000. PORTE, Value on All Other RESETS = ----. PORTE, Value on All Other RESETS = -000. LATE, Bit 7 = -. LATE, Bit 6 = -. LATE, Bit 5 = -. LATE, Bit 4 = -. LATE, Bit 3 = -. LATE, Bit 2 = LATE Data Output bits. LATE, Bit 1 = LATE Data Output bits. LATE, Bit 0 = LATE Data Output bits. LATE, Value on POR, BOR = ----. LATE, Value on POR, BOR = -xxx. LATE, Value on All Other RESETS = ----. LATE, Value on All Other",
    "TABLE 9-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nRESETS = -uuu. TRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 = PSPMODE. TRISE, Bit 3 = -. TRISE, Bit 2 = PORTE Data Direction bits. TRISE, Bit 1 = PORTE Data Direction bits. TRISE, Bit 0 = PORTE Data Direction bits. TRISE, Value on POR, BOR = 0000. TRISE, Value on POR, BOR = -111. TRISE, Value on All Other RESETS = 0000. TRISE, Value on All Other RESETS = -111. INTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IF. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR,",
    "TABLE 9-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nBOR = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on All Other RESETS = 0000. PIR1, Value on All Other RESETS = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 =",
    "TABLE 9-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nTMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on All Other RESETS = 0000. PIE1, Value on All Other RESETS = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on All Other RESETS = 0000. IPR1, Value on All Other RESETS = 0000. ADCON1, Bit 7 = ADFM. ADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 =",
    "TABLE 9-11: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n-. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = 00--. ADCON1, Value on POR, BOR = 0000. ADCON1, Value on All Other RESETS = 00--. ADCON1, Value on All Other RESETS = 0000\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'. Shaded cells are not used by the Parallel Slave Port. -",
    "PIC18FXX2\nNOTES:",
    "10.0 TIMER0 MODULE\nThe Timer0 module has the following features:\nGLYPH<129> Software selectable as an 8-bit or 16-bit timer/ counter\nGLYPH<129> Readable and writable\nGLYPH<129> Dedicated 8-bit software programmable prescaler\nGLYPH<129> Clock source selectable to be external or internal\nGLYPH<129> Interrupt-on-overflow from FFh to 00h in 8-bit mode and FFFFh to 0000h in 16-bit mode\nGLYPH<129> Edge select for external clock",
    "REGISTER 10-1: T0CON: TIMER0 CONTROL REGISTER\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-1. R/W-1, 3 = R/W-1. R/W-1, 4 = R/W-1. R/W-1, 5 = R/W-1. R/W-1, 6 = R/W-1. R/W-1, 7 = R/W-1. TMR0ON, 1 = T08BIT. TMR0ON, 2 = T0CS. TMR0ON, 3 = T0SE. TMR0ON, 4 = PSA. TMR0ON, 5 = T0PS2. TMR0ON, 6 = T0PS1. TMR0ON, 7 = T0PS0\nbit 7\nbit 0\nTMR0ON:\nTimer0 On/Off Control bit\n1 = Enables Timer0\n0 = Stops Timer0\nT08BIT : Timer0 8-bit/16-bit Control bit",
    "REGISTER 10-1: T0CON: TIMER0 CONTROL REGISTER\n1 = Timer0 is configured as an 8-bit timer/counter\n0 = Timer0 is configured as a 16-bit timer/counter\nT0CS : Timer0 Clock Source Select bit\n- 1 = Transition on T0CKI pin\n0 = Internal instruction cycle clock (CLKO)\nT0SE : Timer0 Source Edge Select bit\n- 1 = Increment on high-to-low transition on T0CKI pin\n0 = Increment on low-to-high transition on T0CKI pin\nPSA : Timer0 Prescaler Assignment bit\n1 = TImer0 prescaler is NOT assigned. Timer0 clock input bypasses prescaler.\n0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.\nT0PS2:T0PS0\n: Timer0 Prescaler Select bits\n111 = 1:256 prescale value\n110 = 1:128 prescale value\n101 = 1:64 prescale value\n100 = 1:32 prescale value\n011 = 1:16 prescale value\n010 = 1:8   prescale value\n001 = 1:4   prescale value",
    "REGISTER 10-1: T0CON: TIMER0 CONTROL REGISTER\n000 = 1:2   prescale value",
    "Legend:\nR = Readable bit\n- n = Value at POR\nbit 7\nbit 6",
    "bit 5\nbit 4",
    "bit 3\nbit 2-0\nFigure 10-1  shows  a  simplified  block  diagram  of  the Timer0 module in 8-bit mode and Figure 10-2 shows a simplified block diagram of the Timer0 module in 16-bit mode.\nThe T0CON register (Register 10-1) is a readable and writable register that controls all the aspects of Timer0, including the prescale selection.\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "10.1 Timer0 Operation\nTimer0 can operate as a timer or as a counter.\nTimer  mode  is  selected  by  clearing  the  T0CS  bit.  In Timer mode, the Timer0 module will increment every instruction cycle (without prescaler). If the TMR0L register is written, the increment is inhibited for the following two instruction cycles. The user can work around this by writing an adjusted value to the TMR0L register.\nCounter mode is selected by setting the T0CS bit. In Counter mode, Timer0 will increment, either on every rising or falling edge of pin RA4/T0CKI. The incrementing  edge  is  determined  by  the  Timer0  Source  Edge Select bit (T0SE). Clearing the T0SE bit selects the rising edge. Restrictions on the external clock input are discussed below.\nWhen an external clock input is used for Timer0, it must meet certain requirements. The requirements ensure the external clock can be synchronized with the internal phase clock (TOSC). Also, there is a delay in the actual incrementing of Timer0 after synchronization.",
    "10.2 Prescaler\nAn 8-bit counter is available as a prescaler for the Timer0 module. The prescaler is not readable or writable.\nThe PSA  and T0PS2:T0PS0  bits determine the prescaler assignment and prescale ratio.\nClearing bit PSA will assign the prescaler to the Timer0 module. When the prescaler is assigned to the Timer0 module,  prescale  values  of  1:2,  1:4,...,  1:256  are selectable.\nWhen assigned to the Timer0 module, all instructions writing  to  the  TMR0L  register  (e.g., CLRF TMR0, MOVWF  TMR0,  BSF  TMR0,  x ....etc.)  will  clear  the prescaler count.",
    "10.2.1 SWITCHING PRESCALER ASSIGNMENT\nThe prescaler assignment is fully under software control, (i.e., it can be changed 'on-the-fly' during program execution).",
    "10.3 Timer0 Interrupt\nThe TMR0 interrupt is generated when the TMR0 register overflows from FFh to 00h in 8-bit mode, or FFFFh to 0000h in 16-bit mode. This overflow sets the TMR0IF bit. The  interrupt  can  be  masked  by  clearing  the TMR0IE bit. The TMR0IE bit must be cleared in software by the Timer0 module Interrupt Service Routine before  re-enabling  this  interrupt.  The  TMR0  interrupt cannot awaken the processor from SLEEP, since the timer is shut-off during SLEEP.",
    "10.4 16-Bit Mode Timer Reads and Writes\nTMR0H  is  not  the  high  byte  of  the  timer/counter  in 16-bit mode, but is actually a buffered version of the high byte of Timer0 (refer to Figure 10-2). The high byte of the Timer0 counter/timer is not directly readable nor writable.  TMR0H is  updated  with  the  contents  of  the high byte of Timer0 during a read of TMR0L. This provides  the  ability  to  read  all  16-bits  of  Timer0  without having to verify that the read of the high and low byte were valid due to a rollover between successive reads of the high and low byte.\nA write to the high byte of Timer0 must also take place through the TMR0H buffer register. Timer0 high byte is updated  with  the  contents  of  TMR0H  when  a  write occurs to TMR0L. This allows all 16-bits of Timer0 to be updated at once.",
    "Note:\nWriting  to  TMR0L  when  the  prescaler  is assigned to Timer0 will clear the prescaler count,  but  will  not  change  the  prescaler assignment.",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH TIMER0\n\nLegend: x = unknown, u = unchanged,   = unimplemented locations read as '0'. Shaded cells are not used by Timer0. -",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0L, Bit 7 = Timer0 Module Low Byte Register. TMR0L, Bit 6 = Timer0 Module Low Byte Register. TMR0L, Bit 5 = Timer0 Module Low Byte Register. TMR0L, Bit 4 = Timer0 Module Low Byte Register. TMR0L, Bit 3 = Timer0 Module Low Byte Register. TMR0L, Bit 2 = Timer0 Module Low Byte Register. TMR0L, Bit 1 = Timer0 Module Low Byte Register. TMR0L, Bit 0 = Timer0 Module Low Byte Register. TMR0L, Value on POR, BOR = xxxx. TMR0L, Value on All Other RESETS = xxxx. TMR0L, Value on All Other RESETS = uuuu. TMR0L, Value on All Other RESETS = uuuu. TMR0H, Bit 7 = Timer0 Module High Byte Register. TMR0H, Bit 6 = Timer0 Module High Byte Register. TMR0H, Bit 5 = Timer0 Module High Byte Register.",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0H, Bit 4 = Timer0 Module High Byte Register. TMR0H, Bit 3 = Timer0 Module High Byte Register. TMR0H, Bit 2 = Timer0 Module High Byte Register. TMR0H, Bit 1 = Timer0 Module High Byte Register. TMR0H, Bit 0 = Timer0 Module High Byte Register. TMR0H, Value on POR, BOR = 0000. TMR0H, Value on All Other RESETS = 0000. TMR0H, Value on All Other RESETS = 0000. TMR0H, Value on All Other RESETS = 0000. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON,",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH TIMER0\nValue on All Other RESETS = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = 1111. T0CON, Value on All Other RESETS = 1111. T0CON, Value on All Other RESETS = 1111. T0CON, Value on All Other RESETS = 1111. TRISA, Bit 7 = -. TRISA, Bit 6 = PORTA Data Direction Register. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH TIMER0\n= PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = -111. TRISA, Value on All Other RESETS = 1111. TRISA, Value on All Other RESETS = -111. TRISA, Value on All Other RESETS = 1111",
    "PIC18FXX2\nNOTES:",
    "11.0 TIMER1 MODULE\nThe  Timer1  module  timer/counter  has  the  following features:\nGLYPH<129> 16-bit timer/counter (two 8-bit registers; TMR1H and TMR1L)\nGLYPH<129> Readable and writable (both registers)\nGLYPH<129> Internal or external clock select\nGLYPH<129> Interrupt-on-overflow from FFFFh to 0000h\nGLYPH<129> RESET from CCP module special event trigger",
    "REGISTER 11-1: T1CON: TIMER1 CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. RD16, 1 = -. RD16, 2 = T1CKPS1. RD16, 3 = T1CKPS0. RD16, 4 = T1OSCEN. RD16, 5 = T1SYNC. RD16, 6 = TMR1CS. RD16, 7 = TMR1ON\nbit 7\nbit 0",
    "bit 7\nRD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register Read/Write of Timer1 in one 16-bit operation\n0 = Enables register Read/Write of Timer1 in two 8-bit operations",
    "bit 5-4 T1CKPS1:T1CKPS0 : Timer1 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value",
    "bit 3\nT1OSCEN: Timer1 Oscillator Enable bit\n1 = Timer1 Oscillator is enabled\n0 = Timer1 Oscillator is shut-off\nThe oscillator inverter and feedback resistor are turned off to eliminate power drain.",
    "bit 2 T1SYNC: Timer1 External Clock Input Synchronization Select bit\nWhen TMR1CS = 1:\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR1CS = 0:\nThis bit is ignored. Timer1 uses the internal clock when TMR1CS = 0.",
    "bit 1 TMR1CS: Timer1 Clock Source Select bit\n1 = External clock from pin RC0/T1OSO/T13CKI (on the rising edge)\n0 = Internal clock (FOSC/4)",
    "bit 0 TMR1ON: Timer1 On bit\n1 = Enables Timer1\n0 = Stops Timer1\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nFigure 11-1 is a simplified block diagram of the Timer1 module.\nRegister 11-1 details the Timer1 control register. This register  controls  the  Operating  mode  of  the  Timer1 module, and contains the Timer1 oscillator enable bit (T1OSCEN).  Timer1  can  be  enabled  or  disabled  by setting or clearing control bit TMR1ON (T1CON<0>).",
    "11.1 Timer1 Operation\nTimer1 can operate in one of these modes:\nGLYPH<129> As a timer\nGLYPH<129> As a synchronous counter\nGLYPH<129> As an asynchronous counter\nThe Operating mode is determined by the clock select bit, TMR1CS (T1CON<1>).\nWhen TMR1CS = 0, Timer1 increments every instruction cycle. When TMR1CS = 1, Timer1 increments on every  rising  edge  of  the  external  clock  input  or  the Timer1 oscillator, if enabled.\nWhen the Timer1 oscillator is enabled (T1OSCEN is set),  the  RC1/T1OSI  and  RC0/T1OSO/T1CKI  pins become  inputs.  That  is,  the  TRISC<1:0>  value  is ignored, and the pins are read as '0'.\nTimer1  also  has  an  internal  'RESET  input'.  This RESET  can  be generated by the CCP  module (Section 14.0).",
    "FIGURE 11-2: TIMER1 BLOCK DIAGRAM: 16-BIT READ/WRITE MODE\nNote 1: When enable bit T1OSCEN is cleared, the inverter and feedback resistor are turned off. This eliminates power drain.",
    "11.2 Timer1 Oscillator\nA crystal oscillator circuit is built-in between pins T1OSI (input) and T1OSO (amplifier output). It is enabled by setting control bit T1OSCEN (T1CON<3>). The oscillator is a low power oscillator rated up to 200 kHz. It will continue to run during SLEEP. It is primarily intended for  a  32  kHz  crystal.  Table 11-1  shows  the  capacitor selection for the Timer1 oscillator.\nThe user must provide a software time delay to ensure proper start-up of the Timer1 oscillator.",
    "TABLE 11-1: CAPACITOR SELECTION FOR THE ALTERNATE OSCILLATOR\nLP, Freq = 32 kHz. LP, C1 = TBD (1). LP, C2 = TBD (1). Crystal to be Tested:, Freq = Crystal to be Tested:. Crystal to be Tested:, C1 = Crystal to be Tested:. Crystal to be Tested:, C2 = Crystal to be Tested:. 32.768 kHz, Freq = Epson C-001R32.768K-A. 32.768 kHz, C1 = Epson C-001R32.768K-A. 32.768 kHz, C2 = \u00b1 20 PPM\nNote 1: Microchip  suggests  33  pF  as  a  starting point in validating the oscillator circuit.\n2: Higher capacitance increases the stability of  the  oscillator,  but  also  increases  the start-up time.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer for appropriate values of external components.\n4: Capacitor values are for design guidance only.",
    "11.3 Timer1 Interrupt\nThe TMR1 Register pair (TMR1H:TMR1L) increments from  0000h  to  FFFFh  and  rolls  over  to  0000h.  The TMR1 Interrupt, if enabled, is generated on overflow, which is latched in interrupt flag bit TMR1IF (PIR1<0>). This  interrupt  can  be  enabled/disabled  by  setting/ clearing TMR1 interrupt enable bit, TMR1IE (PIE1<0>).",
    "11.4 Resetting Timer1 using a CCP Trigger Output\nIf the CCP module is configured in Compare mode to generate a 'special event trigger' (CCP1M3:CCP1M0 = 1011 ), this signal will reset Timer1 and start an A/D conversion (if the A/D module is enabled).\nNote:, 1 = The special event triggers from the CCP1 module will not set interrupt flag bit TMR1IF (PIR1<0>).\nTimer1 must be configured for either Timer or Synchronized Counter mode to take advantage of this feature. If  Timer1  is  running  in  Asynchronous  Counter mode, this RESET operation may not work.\nIn  the  event  that  a  write  to  Timer1  coincides  with  a special  event  trigger  from  CCP1,  the  write  will  take precedence.\nIn this mode of operation, the CCPR1H:CCPR1L registers  pair  effectively  becomes  the  period  register  for Timer1.",
    "11.5 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured for 16-bit reads and writes (see Figure 11-2). When the RD16 control bit (T1CON<7>) is set, the address for TMR1H is mapped to a buffer register for the high byte of Timer1. A read from TMR1L will load the contents of the high byte of Timer1 into the Timer1 high byte buffer. This provides the user with the ability to accurately read all 16-bits of Timer1 without having to determine whether a read of the high byte followed by a read of the low byte is valid, due to a rollover between reads.\nA write to the high byte of Timer1 must also take place through the TMR1H buffer register. Timer1 high byte is updated  with  the  contents  of  TMR1H  when  a  write occurs to TMR1L. This allows a user to write all 16 bits to both the high and low bytes of Timer1 at once.",
    "11.5 Timer1 16-Bit Read/Write Mode\nThe high byte of Timer1 is not directly readable or writable in this mode. All reads and writes must take place through the Timer1 high byte buffer register. Writes to TMR1H  do  not  clear the Timer1 prescaler. The prescaler is only cleared on writes to TMR1L.",
    "TABLE 11-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR",
    "TABLE 11-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\n= 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on All Other RESETS = 0000. PIR1, Value on All Other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on All Other RESETS = 0000. PIE1, Value on All Other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit",
    "TABLE 11-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\n2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on All Other RESETS = 0000. IPR1, Value on All Other RESETS = 0000. TMR1L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of",
    "TABLE 11-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nthe 16-bit TMR1 Register. TMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on All Other RESETS = uuuu. TMR1L, Value on All Other RESETS = uuuu. TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register.",
    "TABLE 11-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nTMR1H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on All Other RESETS = uuuu. TMR1H, Value on All Other RESETS = uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 =",
    "TABLE 11-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nT1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00. T1CON, Value on POR, BOR = 0000. T1CON, Value on All Other RESETS = u-uu. T1CON, Value on All Other RESETS = uuuu\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'. Shaded cells are not used by the Timer1 module. -\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18F2X2 devices; always maintain these bits clear.",
    "12.0 TIMER2 MODULE\nThe Timer2 module timer has the following features:\nGLYPH<129> 8-bit timer (TMR2 register)\nGLYPH<129> 8-bit period register (PR2)\nGLYPH<129> Readable and writable (both registers)\nGLYPH<129> Software programmable prescaler (1:1, 1:4, 1:16)\nGLYPH<129> Software programmable postscaler (1:1 to 1:16)\nGLYPH<129> Interrupt on TMR2 match of PR2\nGLYPH<129> SSP module optional use of TMR2 output to generate clock shift",
    "12.1 Timer2 Operation\nTimer2  can  be  used  as  the  PWM  time-base  for  the PWM mode of the CCP module. The TMR2 register is readable  and  writable,  and  is  cleared  on  any  device RESET. The input clock (FOSC/4) has a prescale option of 1:1, 1:4 or 1:16, selected by control bits T2CKPS1:T2CKPS0 (T2CON<1:0>). The match output  of  TMR2  goes  through  a  4-bit  postscaler  (which gives  a  1:1  to  1:16  scaling  inclusive)  to  generate  a TMR2 interrupt (latched in flag bit TMR2IF, (PIR1<1>)).\nTimer2 has a control register shown in Register 12-1. Timer2 can be shut-off by clearing control bit TMR2ON (T2CON<2>) to minimize power consumption. Figure 12-1 is a simplified block diagram of the Timer2 module. Register 12-1 shows the Timer2 control register. The prescaler and postscaler selection of Timer2 are controlled by this register.",
    "12.1 Timer2 Operation\nThe  prescaler  and  postscaler  counters  are  cleared when any of the following occurs:\nGLYPH<129> a write to the TMR2 register\nGLYPH<129> a write to the T2CON register\nGLYPH<129> any device RESET (Power-on Reset, MCLR Reset, Watchdog Timer Reset, or Brown-out Reset)\nTMR2 is not cleared when T2CON is written.",
    "REGISTER 12-1: T2CON: TIMER2 CONTROL REGISTER\n-, R/W-0 = TOUTPS3. -, R/W-0 = TOUTPS2. -, R/W-0 = TOUTPS1. -, R/W-0 = TOUTPS0. -, R/W-0 = TMR2ON. -, R/W-0 = T2CKPS1. -, R/W-0 = T2CKPS0\nbit 7\nbit 0\nbit 7 Unimplemented: Read as '0'\nbit 6-3 TOUTPS3:TOUTPS0 : Timer2 Output Postscale Select bits\n0000 = 1:1 Postscale\n0001 = 1:2 Postscale\nGLYPH<129>\nGLYPH<129>\nGLYPH<129>\n1111 = 1:16 Postscale bit 2 TMR2ON : Timer2 On bit\n1 = Timer2 is on\n0 = Timer2 is off\nT2CKPS1:T2CKPS0 : Timer2 Clock Prescale Select bits\n00 = Prescaler is 1\n01 = Prescaler is 4\n1x = Prescaler is 16",
    "REGISTER 12-1: T2CON: TIMER2 CONTROL REGISTER\nLegend:\nR = Readable bit\n- n = Value at POR\nbit 1-0\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "12.2 Timer2 Interrupt\nThe Timer2 module has an 8-bit period register, PR2. Timer2 increments from 00h until it matches PR2 and then resets to 00h on the next increment cycle. PR2 is a readable and writable register. The PR2 register is initialized to FFh upon RESET.",
    "12.3 Output of TMR2\nThe output of TMR2 (before the postscaler) is fed to the Synchronous Serial Port module, which optionally uses it to generate the shift clock.",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n= 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on All Other RESETS = 0000. PIR1, Value on All Other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on All Other RESETS = 0000. PIE1, Value on All Other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on All Other RESETS = 0000. IPR1, Value on All Other RESETS = 0000. TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR, BOR = 0000. TMR2, Value on All Other RESETS = 0000.",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nTMR2, Value on All Other RESETS = 0000. T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. T2CON, Value on All Other RESETS = -000. T2CON, Value on All Other RESETS = 0000. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nPeriod Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR, BOR = 1111. PR2, Value on All Other RESETS = 1111. PR2, Value on All Other RESETS = 1111\nLegend:\nx = unknown, u = unchanged,   = unimplemented read as '0'.  Shaded cells are not used by the Timer2 module. -\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18F2X2 devices; always maintain these bits clear.",
    "13.0 TIMER3 MODULE\nThe  Timer3  module  timer/counter  has  the  following features:\nGLYPH<129> 16-bit timer/counter (two 8-bit registers; TMR3H and TMR3L)\nGLYPH<129> Readable and writable (both registers)\nGLYPH<129> Internal or external clock select\nGLYPH<129> Interrupt-on-overflow from FFFFh to 0000h\nGLYPH<129> RESET from CCP module trigger\nFigure 13-1 is a simplified block diagram of the Timer3 module.\nRegister 13-1 shows the Timer3 control register. This register  controls  the  Operating  mode  of  the  Timer3 module and sets the CCP clock source.\nRegister 11-1 shows the Timer1 control register. This register  controls  the  Operating  mode  of  the  Timer1 module,  as  well  as  contains  the  Timer1  oscillator enable bit (T1OSCEN), which can be a clock source for Timer3.",
    "REGISTER 13-1: T3CON: TIMER3 CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. RD16, 1 = T3CCP2. RD16, 2 = T3CKPS1. RD16, 3 = T3CKPS0. RD16, 4 = T3CCP1. RD16, 5 = T3SYNC. RD16, 6 = TMR3CS. RD16, 7 = TMR3ON\nbit 7\nbit 0",
    "bit 7 RD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register Read/Write of Timer3 in one 16-bit operation\n0 = Enables register Read/Write of Timer3 in two 8-bit operations\nT3CCP2:T3CCP1: Timer3 and Timer1 to CCPx Enable bits\n1x = Timer3 is the clock source for compare/capture CCP modules\n01 = Timer3 is the clock source for compare/capture of CCP2,\nTimer1 is the clock source for compare/capture of CCP1\n00 = Timer1 is the clock source for compare/capture CCP modules bit 5-4 T3CKPS1:T3CKPS0 : Timer3 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value\nT3SYNC: Timer3 External Clock Input Synchronization Control bit\n(Not usable if the system clock comes from Timer1/Timer3)\nWhen TMR3CS = 1:\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input",
    "bit 7 RD16: 16-bit Read/Write Mode Enable bit\nWhen TMR3CS = 0:\nThis bit is ignored. Timer3 uses the internal clock when TMR3CS = 0.",
    "bit 1 TMR3CS: Timer3 Clock Source Select bit\n- 1 = External clock input from Timer1 oscillator or T1CKI\n(on the rising edge after the first falling edge)\n- 0 = Internal clock (FOSC/4)",
    "bit 0 TMR3ON: Timer3 On bit\n1 = Enables Timer3\n0 = Stops Timer3",
    "Legend:\nR = Readable bit\n- n = Value at POR\nbit 6-3",
    "bit 2\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "13.1 Timer3 Operation\nTimer3 can operate in one of these modes:\nGLYPH<129> As a timer\nGLYPH<129> As a synchronous counter\nGLYPH<129> As an asynchronous counter\nThe Operating mode is determined by the clock select bit, TMR3CS (T3CON<1>).\nWhen TMR3CS = 0, Timer3 increments every instruction cycle. When TMR3CS = 1, Timer3 increments on every rising edge of the Timer1 external clock input or the Timer1 oscillator, if enabled.\nWhen the Timer1 oscillator is enabled (T1OSCEN is set),  the  RC1/T1OSI  and  RC0/T1OSO/T1CKI  pins become  inputs.  That  is,  the  TRISC<1:0>  value  is ignored, and the pins are read as '0'.\nTimer3 also has an internal 'RESET input'. This RESET can be generated by the CCP module (Section 14.0).",
    "FIGURE 13-1: TIMER3 BLOCK DIAGRAM\nNote 1: When enable bit T1OSCEN is cleared, the inverter and feedback resistor are turned off. This eliminates power drain.",
    "FIGURE 13-2: TIMER3 BLOCK DIAGRAM CONFIGURED IN 16-BIT READ/WRITE MODE\nNote 1: When the T1OSCEN bit is cleared, the inverter and feedback resistor are turned off. This eliminates power drain.",
    "13.2 Timer1 Oscillator\nThe Timer1 oscillator may be used as the clock source for Timer3. The Timer1 oscillator is enabled by setting the T1OSCEN (T1CON<3>) bit. The oscillator is a low power oscillator rated up to 200 KHz. See Section 11.0 for further details.",
    "13.4 Resetting Timer3 Using a CCP Trigger Output\nIf the CCP module is configured in Compare mode to generate a 'special event trigger' (CCP1M3:CCP1M0 = 1011 ), this signal will reset Timer3.\nNote: The special event triggers  from  the  CCP module will not set interrupt flag bit, TMR3IF (PIR1<0>).\nThe TMR3 Register pair (TMR3H:TMR3L) increments from  0000h  to  FFFFh  and  rolls  over  to  0000h.  The TMR3 Interrupt, if enabled, is generated on overflow, which is latched in interrupt flag bit, TMR3IF (PIR2<1>). This interrupt can be enabled/disabled by setting/clearing  TMR3  interrupt  enable  bit,  TMR3IE (PIE2<1>).",
    "13.4 Resetting Timer3 Using a CCP Trigger Output\nTimer3 must be configured for either Timer or Synchronized Counter mode to take advantage of this feature. If  Timer3  is  running  in  Asynchronous  Counter mode, this RESET operation may not work. In the event that a write to Timer3 coincides with a special event trigger from CCP1, the write will take precedence. In this mode of operation, the CCPR1H:CCPR1L  registers  pair effectively becomes the period register for Timer3.",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. PIR2, Bit 7 = -. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = ---0.",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nPIR2, Value on POR, BOR = 0000. PIR2, Value on All Other RESETS = ---0. PIR2, Value on All Other RESETS = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = ---0. PIE2, Value on POR, BOR = 0000. PIE2, Value on All Other RESETS = ---0. PIE2, Value on All Other RESETS = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 =",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nTMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = ---1. IPR2, Value on POR, BOR = 1111. IPR2, Value on All Other RESETS = ---1. IPR2, Value on All Other RESETS = 1111. TMR3L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register.",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nTMR3L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on All Other RESETS = uuuu. TMR3L, Value on All Other RESETS = uuuu. TMR3H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 3 = Holding Register",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nfor the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on All Other RESETS = uuuu. TMR3H, Value on All Other RESETS = uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 =",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nTMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00. T1CON, Value on POR, BOR = 0000. T1CON, Value on All Other RESETS = u-uu. T1CON, Value on All Other RESETS = uuuu. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000. T3CON, Value on POR, BOR = 0000. T3CON, Value on All Other RESETS = uuuu. T3CON, Value on All Other RESETS = uuuu",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'.  Shaded cells are not used by the Timer1 module. -",
    "PIC18FXX2\nNOTES:",
    "14.0 CAPTURE/COMPARE/PWM (CCP) MODULES\nEach CCP (Capture/Compare/PWM) module contains a 16-bit register which can operate as a 16-bit Capture register,  as  a  16-bit  Compare  register  or  as  a  PWM Master/Slave  Duty  Cycle  register.  Table 14-1  shows the timer resources of the CCP Module modes.\nThe operation of CCP1 is identical to that of CCP2, with the exception of the special event trigger. Therefore, operation of a CCP module in the following sections is described with respect to CCP1.\nTable 14-2 shows the interaction of the CCP modules.",
    "REGISTER 14-1: CCP1CON REGISTER/CCP2CON REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = DCxB1. -, 3 = DCxB0. -, 4 = CCPxM3. -, 5 = CCPxM2. -, 6 = CCPxM1. -, 7 = CCPxM0\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as '0'\nbit 5-4 DCxB1:DCxB0 : PWM Duty Cycle bit1 and bit0\nCapture mode:\nUnused\nCompare mode:\nUnused\nPWM mode:",
    "REGISTER 14-1: CCP1CON REGISTER/CCP2CON REGISTER\nThese bits are the two LSbs (bit1 and bit0) of the 10-bit PWM duty cycle. The upper eight bits (DCx9:DCx2) of the duty cycle are found in CCPRxL.",
    "bit 3-0 CCPxM3:CCPxM0 : CCPx Mode Select bits\n0000 = Capture/Compare/PWM disabled (resets CCPx module)\n0001 = Reserved\n0010 = Compare mode, toggle output on match (CCPxIF bit is set)\n0011 = Reserved\n0100 = Capture mode, every falling edge\n0101 = Capture mode, every rising edge\n0110 = Capture mode, every 4th rising edge\n0111 = Capture mode, every 16th rising edge\n1000 = Compare mode,\nInitialize CCP pin Low, on compare match force CCP pin High (CCPIF bit is set)\n1001 = Compare mode,\nInitialize CCP pin High, on compare match force CCP pin Low (CCPIF bit is set)\n1010 = Compare mode,\nGenerate software interrupt on compare match (CCPIF bit is set, CCP pin is unaffected)\n1011 = Compare mode,\nTrigger special event (CCPIF bit is set)\n11xx = PWM mode",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "14.1 CCP1 Module\nCapture/Compare/PWM Register 1 (CCPR1) is comprised of two 8-bit registers: CCPR1L (low byte) and CCPR1H (high byte). The CCP1CON register controls the operation of CCP1. All are readable and writable.\nTABLE 14-1: CCP MODE - TIMER RESOURCE\n\nCapture Compare PWM, Timer Resource = Timer1 or Timer3 Timer1 or Timer3 Timer2",
    "TABLE 14-2: INTERACTION OF TWO CCP MODULES\nCapture, CCPy Mode = Capture. Capture, Interaction = TMR1 or TMR3 time-base. Time-base can be different for each CCP.. Capture, CCPy Mode = Compare. Capture, Interaction = The compare could be configured for the special event trigger, which clears either TMR1 or TMR3 depending upon which time-base is used.. Compare, CCPy Mode = Compare. Compare, Interaction = The compare(s) could be configured for the special event trigger, which clears TMR1 or TMR3 depending upon which time-base is used.. PWM, CCPy Mode = PWM. PWM, Interaction = The PWMs will have the same frequency and update rate (TMR2 interrupt).. PWM, CCPy Mode = Capture. PWM, Interaction = None. PWM, CCPy Mode = Compare. PWM, Interaction = None",
    "14.2 CCP2 Module\nCapture/Compare/PWM  Register2  (CCPR2)  is  comprised of two 8-bit registers: CCPR2L (low byte) and CCPR2H (high byte). The CCP2CON register controls the operation of CCP2. All are readable and writable.",
    "14.3 Capture Mode\nIn Capture  mode,  CCPR1H:CCPR1L  captures  the 16-bit value of the TMR1 or TMR3 registers when an event occurs on pin RC2/CCP1. An event is defined as one of the following:\nGLYPH<129> every falling edge\nGLYPH<129> every rising edge\nGLYPH<129> every 4th rising edge\nGLYPH<129> every 16th rising edge\nThe event is selected by control bits CCP1M3:CCP1M0 (CCP1CON<3:0>). When a capture is made, the interrupt request flag bit CCP1IF (PIR1<2>) is set; it must be cleared in software. If another capture occurs before the value in register CCPR1 is read, the old captured value is overwritten by the new captured value.",
    "14.3.1 CCP PIN CONFIGURATION\nIn Capture  mode,  the  RC2/CCP1  pin  should  be configured as an input by setting the TRISC<2> bit.\nNote:, 1 = If the RC2/CCP1 is configured as an out- put, a write to the port can cause a capture condition.",
    "14.3.2 TIMER1/TIMER3 MODE SELECTION\nThe timers that are to be used with the capture feature (either Timer1 and/or Timer3) must be running in Timer mode  or  Synchronized  Counter  mode.  In  Asynchronous  Counter  mode,  the  capture  operation  may  not work.   The timer to be used with each CCP module is selected in the T3CON register.",
    "14.3.3 SOFTWARE INTERRUPT\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user should keep bit CCP1IE (PIE1<2>) clear to avoid false interrupts and should clear the flag bit, CCP1IF, following any such change in Operating mode.",
    "14.3.4 CCP PRESCALER\nThere  are  four  prescaler  settings,  specified  by  bits CCP1M3:CCP1M0.  Whenever  the  CCP  module  is turned off or the CCP module is not in Capture mode, the prescaler counter is cleared. This means that any RESET will clear the prescaler counter.\nSwitching from one capture prescaler to another may generate an interrupt. Also, the prescaler counter will not be cleared, therefore, the first capture may be from a non-zero prescaler. Example 14-1 shows the recommended method for switching between capture prescalers. This example also clears the prescaler counter and will not generate the 'false' interrupt.",
    "EXAMPLE 14-1: CHANGING BETWEEN CAPTURE PRESCALERS\nCLRF\nCCP1CON, F\n; Turn CCP module off\nMOVLW  NEW_CAPT_PS ; Load WREG with the\n; new prescaler mode\n; value and CCP ON\nMOVWF  CCP1CON\n; Load CCP1CON with\n; this value",
    "14.4 Compare Mode\nIn Compare mode, the 16-bit CCPR1 (CCPR2) register value is constantly compared against either the TMR1 register  pair  value,  or  the  TMR3  register  pair  value. When a match occurs, the RC2/CCP1 (RC1/CCP2) pin is:\nGLYPH<129> driven High\nGLYPH<129> driven Low\nGLYPH<129> toggle output (High to Low or Low to High)\nGLYPH<129> remains unchanged\nThe action on the pin is based on the value of control bits  CCP1M3:CCP1M0  (CCP2M3:CCP2M0).  At  the same time, interrupt flag bit CCP1IF (CCP2IF) is set.",
    "14.4.1 CCP PIN CONFIGURATION\nThe user must configure the CCPx pin as an output by clearing the appropriate TRISC bit.\nNote:, 1 = Clearing the CCP1CON register will force the RC2/CCP1 compare output latch to the default low level. This is not the PORTC I/O data latch.",
    "14.4.2 TIMER1/TIMER3 MODE SELECTION\nTimer1 and/or Timer3 must be running in Timer mode or Synchronized Counter mode if the CCP module is using the compare feature. In Asynchronous Counter mode, the compare operation may not work.",
    "14.4.3 SOFTWARE INTERRUPT MODE\nWhen generate software interrupt is chosen, the CCP1 pin is not affected. Only a CCP interrupt is generated (if enabled).",
    "14.4.4 SPECIAL EVENT TRIGGER\nIn this mode, an internal hardware trigger is generated, which may be used to initiate an action.\nThe special  event  trigger  output  of  CCP1  resets  the TMR1 register pair. This allows the CCPR1 register to effectively be a 16-bit programmable period register for Timer1.\nThe special  trigger  output  of  CCPx  resets  either  the TMR1 or TMR3 register pair.  Additionally,  the  CCP2 Special Event Trigger will start an A/D conversion if the A/D module is enabled.",
    "Note:\nThe special event trigger from the CCP2 module will not set the Timer1 or Timer3 interrupt flag bits.",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on All Other RESETS = 0000 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000 0000. PIR1, Value on All Other RESETS = 0000",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000 0000. PIE1, Value on All Other RESETS = 0000 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000 0000. IPR1, Value on All Other RESETS = 0000",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n0000. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111 1111. TRISC, Value on All Other RESETS = 1111 1111. TMR1L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register.",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Value on POR, BOR = xxxx xxxx. TMR1L, Value on All Other RESETS = uuuu uuuu. TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 4 = Holding",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nRegister for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Value on POR, BOR = xxxx xxxx. TMR1H, Value on All Other RESETS = uuuu uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00 0000. T1CON, Value on All Other RESETS = u-uu uuuu. CCPR1L, Bit 7 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 6 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 5 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 4 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 3 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 2 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 1 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 0 = Capture/Compare/PWM Register1 (LSB). CCPR1L,",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nValue on POR, BOR = xxxx xxxx. CCPR1L, Value on All Other RESETS = uuuu uuuu. CCPR1H, Bit 7 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 6 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 5 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 4 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 3 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 2 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 1 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 0 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Value on POR, BOR = xxxx xxxx. CCPR1H, Value on All Other RESETS =",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nuuuu uuuu. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = --00 0000. CCP1CON, Value on All Other RESETS = --00 0000. CCPR2L, Bit 7 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 6 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 5 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 4 = Capture/Compare/PWM Register2 (LSB).",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCPR2L, Bit 3 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 2 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 1 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 0 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Value on POR, BOR = xxxx xxxx. CCPR2L, Value on All Other RESETS = uuuu uuuu. CCPR2H, Bit 7 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 6 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 5 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 4 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 3 = Capture/Compare/PWM Register2 (MSB).",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nCCPR2H, Bit 2 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 1 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 0 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Value on POR, BOR = xxxx xxxx. CCPR2H, Value on All Other RESETS = uuuu uuuu. CCP2CON, Bit 7 = -. CCP2CON, Bit 6 = -. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Value on POR, BOR = --00 0000. CCP2CON, Value on All Other RESETS = --00",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n0000. PIR2, Bit 7 = -. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIE. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = ---0 0000. PIR2, Value on All Other RESETS = ---0 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIF. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = ---0 0000. PIE2, Value on All Other RESETS = ---0 0000. IPR2, Bit 7 =",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n-. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = ---1 1111. IPR2, Value on All Other RESETS = ---1 1111. TMR3L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 3 = Holding Register for the Least Significant Byte of the",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n16-bit TMR3 Register. TMR3L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Value on POR, BOR = xxxx xxxx. TMR3L, Value on All Other RESETS = uuuu uuuu. TMR3H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register.",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Value on POR, BOR = xxxx xxxx. TMR3H, Value on All Other RESETS = uuuu uuuu. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON,",
    "TABLE 14-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nBit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000 0000. T3CON, Value on All Other RESETS = uuuu uuuu\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'. Shaded cells are not used by Capture and Timer1. -\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18F2x2 devices; always maintain these bits clear.",
    "14.5 PWM Mode\nIn Pulse Width Modulation (PWM) mode, the CCP1 pin produces up to a 10-bit resolution PWM output. Since the CCP1 pin is multiplexed with the PORTC data latch, the TRISC<2> bit must be cleared to make the CCP1 pin an output.\nNote:, 1 = Clearing the CCP1CON register will force the CCP1 PWM output latch to the default low level. This is not the PORTC I/O data latch.\nFigure 14-3  shows  a  simplified  block  diagram  of  the CCP module in PWM mode.\nFor a step-by-step procedure on how to set up the CCP module for PWM operation, see Section 14.5.3.",
    "FIGURE 14-3: SIMPLIFIED PWM BLOCK DIAGRAM\nA PWM output (Figure 14-4) has a time-base (period) and a time that the output stays high (duty cycle). The frequency  of  the  PWM  is  the  inverse  of  the  period (1/period).",
    "14.5.1 PWM PERIOD\nThe  PWM  period  is  specified  by  writing  to  the  PR2 register. The PWM period can be calculated using the following formula:\n<!-- formula-not-decoded -->\nPWM frequency is defined as 1 / [PWM period].\nWhen TMR2 is equal to PR2, the following three events occur on the next increment cycle:\nGLYPH<129> TMR2 is cleared\nGLYPH<129> The CCP1 pin is set (exception: if PWM duty cycle = 0%, the CCP1 pin will not be set)\nGLYPH<129> The PWM duty cycle is latched from CCPR1L into CCPR1H\nNote:\nThe Timer2 postscaler (see Section 12.0) is  not  used  in  the  determination  of  the PWM frequency. The postscaler could be used  to  have  a  servo  update  rate  at  a different frequency than the PWM output.",
    "14.5.2 PWM DUTY CYCLE\nThe  PWM  duty  cycle  is  specified  by  writing  to  the CCPR1L register and to the CCP1CON<5:4> bits. Up to 10-bit resolution is available. The CCPR1L contains the eight MSbs and the CCP1CON<5:4> contains the two LSbs. This 10-bit value is represented by CCPR1L:CCP1CON<5:4>.  The  following  equation  is used to calculate the PWM duty cycle in time:\nPWM duty cycle    = (CCPR1L:CCP1CON<5:4>) GLYPH<129> TOSC GLYPH<129> (TMR2 prescale value)\nCCPR1L and CCP1CON<5:4> can be written to at any time,  but  the  duty  cycle  value  is  not  latched  into CCPR1H until after a match between PR2 and TMR2 occurs  (i.e.,  the  period  is  complete).  In  PWM  mode, CCPR1H is a read only register.",
    "14.5.2 PWM DUTY CYCLE\nThe  CCPR1H  register  and  a  2-bit  internal  latch  are used to double buffer the PWM duty cycle. This double buffering is essential for glitchless PWM operation.\nWhen the CCPR1H and 2-bit latch match TMR2 concatenated with an internal 2-bit Q clock or 2 bits of the TMR2 prescaler, the CCP1 pin is cleared.\nThe maximum PWM resolution (bits) for a given PWM frequency is given by the equation:\n<!-- formula-not-decoded -->\nNote:\nIf the PWM duty cycle value is longer than the PWM period, the CCP1 pin will not be cleared.",
    "14.5.3 SETUP FOR PWM OPERATION\nThe following steps should be taken when configuring the CCP module for PWM operation:\n1. Set the PWM period by writing to the PR2 register.\n3. Make the CCP1 pin an output by clearing the TRISC<2> bit.\n4. Set the TMR2 prescale value and enable Timer2 by writing to T2CON.\n5. Configure the CCP1 module for PWM operation.\n2. Set  the  PWM  duty  cycle  by  writing  to  the CCPR1L register and CCP1CON<5:4> bits.",
    "TABLE 14-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\nTimer Prescaler (1, 4, 16), 2.44 kHz = 16. Timer Prescaler (1, 4, 16), 9.77 kHz = 4. Timer Prescaler (1, 4, 16), 39.06 kHz = 1. Timer Prescaler (1, 4, 16), 156.25 kHz = 1. Timer Prescaler (1, 4, 16), 312.50 kHz = 1. Timer Prescaler (1, 4, 16), 416.67 kHz = 1. PR2 Value, 2.44 kHz = 0xFF. PR2 Value, 9.77 kHz = 0xFF. PR2 Value, 39.06 kHz = 0xFF. PR2 Value, 156.25 kHz = 0x3F. PR2 Value, 312.50 kHz = 0x1F. PR2 Value, 416.67 kHz = 0x17. Maximum Resolution (bits), 2.44 kHz = 14. Maximum Resolution (bits), 9.77 kHz = 12. Maximum Resolution (bits), 39.06 kHz = 10. Maximum Resolution (bits),",
    "TABLE 14-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\n156.25 kHz = 8. Maximum Resolution (bits), 312.50 kHz = 7. Maximum Resolution (bits), 416.67 kHz = 6.58",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on All Other RESETS = 0000. PIR1, Value on All Other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on All Other RESETS = 0000. PIE1, Value on All Other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on All Other RESETS = 0000. IPR1, Value on All Other RESETS = 0000. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on All Other RESETS = 1111. TRISC, Value on All Other RESETS = 1111. TMR2, Bit 7",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR, BOR = 0000. TMR2, Value on All Other RESETS = 0000. TMR2, Value on All Other RESETS = 0000. PR2, Bit 7 = Timer2 Module Period Register. PR2, Bit 6 = Timer2 Module Period Register. PR2, Bit 5 = Timer2 Module Period Register. PR2, Bit 4 = Timer2 Module Period Register. PR2, Bit 3 = Timer2 Module Period Register. PR2, Bit 2 = Timer2 Module Period Register. PR2, Bit 1 = Timer2 Module Period Register.",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nPR2, Bit 0 = Timer2 Module Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR, BOR = 1111. PR2, Value on All Other RESETS = 1111. PR2, Value on All Other RESETS = 1111. T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. T2CON, Value on All Other RESETS = -000. T2CON, Value on All Other RESETS = 0000. CCPR1L, Bit 7 = Capture/Compare/PWM Register1 (LSB).",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCPR1L, Bit 6 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 5 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 4 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 3 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 2 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 1 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 0 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on All Other RESETS = uuuu. CCPR1L, Value on All Other RESETS = uuuu. CCPR1H, Bit 7 = Capture/Compare/PWM Register1 (MSB).",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCPR1H, Bit 6 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 5 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 4 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 3 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 2 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 1 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 0 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on All Other RESETS = uuuu. CCPR1H, Value on All Other RESETS = uuuu. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -.",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = --00. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on All Other RESETS = --00. CCP1CON, Value on All Other RESETS = 0000. CCPR2L, Bit 7 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 6 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 5 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 4 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 3 =",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCapture/Compare/PWM Register2 (LSB). CCPR2L, Bit 2 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 1 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Bit 0 = Capture/Compare/PWM Register2 (LSB). CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on All Other RESETS = uuuu. CCPR2L, Value on All Other RESETS = uuuu. CCPR2H, Bit 7 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 6 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 5 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 4 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 3 =",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCapture/Compare/PWM Register2 (MSB). CCPR2H, Bit 2 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 1 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Bit 0 = Capture/Compare/PWM Register2 (MSB). CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on All Other RESETS = uuuu. CCPR2H, Value on All Other RESETS = uuuu. CCP2CON, Bit 7 = -. CCP2CON, Bit 6 = -. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 =",
    "TABLE 14-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCP2M0. CCP2CON, Value on POR, BOR = --00. CCP2CON, Value on POR, BOR = 0000. CCP2CON, Value on All Other RESETS = --00. CCP2CON, Value on All Other RESETS = 0000\nLegend: x = unknown, u = unchanged, - = unimplemented, read as '0'. Shaded cells are not used by PWM and Timer2.\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18F2X2 devices; always maintain these bits clear.",
    "PIC18FXX2\nNOTES:",
    "15.1 Master SSP (MSSP) Module Overview\nThe Master Synchronous Serial Port (MSSP) module is a serial interface useful for communicating with other peripheral or microcontroller devices. These peripheral devices may be serial EEPROMs, shift registers, display drivers, A/D converters, etc. The MSSP module can operate in one of two modes:\nGLYPH<129> Serial Peripheral Interface (SPI)\nGLYPH<129> Inter-Integrated Circuit (I C) 2\n-Full Master mode\n-Slave mode (with general address call)\nThe  I 2 C  interface  supports  the  following  modes  in hardware:\nGLYPH<129> Master mode\nGLYPH<129> Multi-Master mode\nGLYPH<129> Slave mode",
    "15.2 Control Registers\nThe  MSSP  module  has  three  associated  registers. These  include  a  status  register  (SSPSTAT)  and  two control registers (SSPCON1 and SSPCON2). The use of these registers and their individual configuration bits differ  significantly,  depending  on  whether  the  MSSP module is operated in SPI or I 2 C mode.\nAdditional  details  are  provided  under  the  individual sections.",
    "15.3 SPI Mode\nThe SPI mode allows 8-bits of data to be synchronously transmitted and received, simultaneously. All four modes of  SPI  are  supported.  To  accomplish  communication, typically three pins are used:\nGLYPH<129> Serial Data Out (SDO) - RC5/SDO\nGLYPH<129> Serial Data In (SDI) - RC4/SDI/SDA\nGLYPH<129> Serial Clock (SCK) - RC3/SCK/SCL/LVDIN\nAdditionally, a fourth pin may be used when in a Slave mode of operation:\n- GLYPH<129> Slave Select (SS) - RA5/SS/AN4\nFigure 15-1  shows  the  block  diagram  of  the  MSSP module when operating in SPI mode.",
    "15.3.1 REGISTERS\nThe  MSSP  module  has  four  registers  for  SPI  mode operation. These are:\nGLYPH<129> MSSP Control Register1 (SSPCON1)\nGLYPH<129> MSSP Status Register (SSPSTAT)\nGLYPH<129> Serial Receive/Transmit Buffer (SSPBUF)\nGLYPH<129> MSSP Shift Register (SSPSR) - Not directly accessible\nSSPCON1 and SSPSTAT are the control and status registers in SPI mode operation. The SSPCON1 register  is  readable  and  writable.  The  lower  6  bits  of  the SSPSTAT  are  read  only.  The  upper  two  bits  of  the SSPSTAT are read/write.\nSSPSR is the shift register used for shifting data in or out. SSPBUF is the buffer register to which data bytes are written to or read from.\nIn receive operations, SSPSR and SSPBUF together create  a  double  buffered  receiver.  When  SSPSR receives a complete byte, it is transferred to SSPBUF and the SSPIF interrupt is set.",
    "15.3.1 REGISTERS\nDuring transmission, the SSPBUF is not double buffered. A write to SSPBUF will write to both SSPBUF and SSPSR.",
    "REGISTER 15-1: SSPSTAT: MSSP STATUS REGISTER (SPI MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P. SMP, 4 = S. SMP, 5 = R/W. SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "bit 7 SMP: Sample bit\nSPI Master mode:\n1 = Input data sampled at end of data output time\n0 = Input data sampled at middle of data output time\nSPI Slave mode:\nSMP must be cleared when SPI is used in Slave mode",
    "When CKP = 0:\n1 = Data transmitted on rising edge of SCK\n0 = Data transmitted on falling edge of SCK",
    "When CKP = 1:\n1 = Data transmitted on falling edge of SCK\n0 = Data transmitted on rising edge of SCK",
    "bit 5 D/A: Data/Address bit\nUsed in I C mode only 2",
    "bit 4 P: STOP bit\nUsed in I 2 C mode only. This bit is cleared when the MSSP module is disabled, SSPEN is cleared.",
    "bit 3 S: START bit\nUsed in I C mode only 2",
    "bit 2 R/W: Read/Write bit information\nUsed in I C mode only 2",
    "bit 1 UA: Update Address\nUsed in I C mode only 2",
    "bit 0 BF: Buffer Full Status bit (Receive mode only)\n1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 15-2: SSPCON1: MSSP CONTROL REGISTER1 (SPI MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. WCOL, 1 = SSPOV. WCOL, 2 = SSPEN. WCOL, 3 = CKP. WCOL, 4 = SSPM3. WCOL, 5 = SSPM2. WCOL, 6 = SSPM1. WCOL, 7 = SSPM0\nbit 7\nbit 0",
    "bit 7 WCOL: Write Collision Detect bit (Transmit mode only)\n- 1 = The SSPBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision",
    "bit 6 SSPOV: Receive Overflow Indicator bit\nSPI Slave mode:\n- 1 = A new byte is received while the SSPBUF register is still holding the previous data. In case of overflow, the data in SSPSR is lost. Overflow can only occur in Slave mode.The user must read the SSPBUF, even if only transmitting data, to avoid setting overflow (must be cleared in software).",
    "0 = No overflow\nNote:\nIn  Master  mode,  the  overflow  bit  is  not  set  since  each  new  reception  (and transmission) is initiated by writing to the SSPBUF register.",
    "bit 5 SSPEN: Synchronous Serial Port Enable bit\n1 = Enables serial port and configures SCK, SDO, SDI, and SS as  serial port pins\n0 = Disables serial port and configures these pins as I/O port pins\nNote: When enabled, these pins must be properly configured as input or output.",
    "bit 4 CKP: Clock Polarity Select bit\n1 = IDLE state for clock is a high level\n0 = IDLE state for clock is a low level",
    "bit 3-0 SSPM3:SSPM0: Synchronous Serial Port Mode Select bits\n0101 = SPI Slave mode, clock = SCK pin, SS pin control disabled, SS can be used as I/O pin 0100 = SPI Slave mode, clock = SCK pin, SS pin control enabled\n0011 = SPI Master mode, clock = TMR2 output/2\n0010 = SPI Master mode, clock = FOSC/64\n0001 = SPI Master mode, clock = FOSC/16\n0000 = SPI Master mode, clock = FOSC/4\nNote:\nBit combinations not specifically listed here are either reserved, or implemented in I 2 C mode only.\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, read = '0' = Bit is cleared. - n = Value at POR, as '0' = x = Bit is unknown",
    "15.3.2 OPERATION\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control  bits  (SSPCON1<5:0>)  and  SSPSTAT<7:6>. These control bits allow the following to be specified:\nGLYPH<129> Master mode (SCK is the clock output)\nGLYPH<129> Slave mode (SCK is the clock input)\nGLYPH<129> Clock Polarity (IDLE state of SCK)\nGLYPH<129> Data input sample phase (middle or end of data output time)\nGLYPH<129> Clock edge (output data on rising/falling edge of SCK)\nGLYPH<129> Clock Rate (Master mode only)\nGLYPH<129> Slave Select mode (Slave mode only)",
    "15.3.2 OPERATION\nThe MSSP consists of a transmit/receive Shift Register (SSPSR) and a buffer register (SSPBUF). The SSPSR shifts the data in and out of the device, MSb first. The SSPBUF holds the data that was written to the SSPSR, until the received data is ready. Once the 8 bits of data have been received, that byte is moved to the SSPBUF register. Then the buffer full detect bit, BF (SSPSTAT<0>), and the interrupt flag bit, SSPIF, are set. This double buffering of the received data (SSPBUF) allows the next byte to start reception before reading the data that was just received. Any write to the\nSSPBUF register during transmission/reception of data will be ignored, and the write collision detect bit, WCOL (SSPCON1<7>), will be set. User software must clear the WCOL bit so that it can be determined if the following write(s) to the SSPBUF  register completed successfully.",
    "15.3.2 OPERATION\nWhen the application software is expecting to receive valid data, the SSPBUF should be read before the next byte of data to transfer is written to the SSPBUF. Buffer full  bit,  BF  (SSPSTAT<0>),  indicates  when  SSPBUF has been loaded with the received data (transmission is complete). When the SSPBUF is read, the BF bit is cleared. This data may be irrelevant if the SPI is only a transmitter.  Generally,  the  MSSP Interrupt is  used to determine when the transmission/reception has completed. The SSPBUF must be read and/or written. If the interrupt method is not going to be used, then software polling can be done to ensure that a write collision does not  occur.  Example 15-1  shows  the  loading  of  the SSPBUF (SSPSR) for data transmission.\nThe SSPSR is not directly readable or  writable,  and can only be accessed by addressing the SSPBUF register. Additionally, the MSSP status register (SSPSTAT) indicates the various status conditions.",
    "EXAMPLE 15-1: LOADING THE SSPBUF (SSPSR) REGISTER\nLOOP, 1 = BTFSS BRA. LOOP, 2 = SSPSTAT,. LOOP, 3 = BF ;Has data been received(transmit complete)?. , 1 = . , 2 = LOOP. , 3 = ;No. , 1 = MOVF. , 2 = SSPBUF, W. , 3 = ;WREG reg = contents of SSPBUF. , 1 = MOVWF. , 2 = RXDATA. , 3 = ;Save in user RAM, if data is meaningful. , 1 = MOVF. , 2 = TXDATA, W. , 3 = ;W reg = contents of TXDATA. , 1 = MOVWF. , 2 = SSPBUF. , 3 = ;New data to xmit",
    "15.3.3 ENABLING SPI I/O\nTo  enable  the  serial  port,  SSP  Enable  bit,  SSPEN (SSPCON1<5>), must be set. To reset or reconfigure SPI  mode,  clear the SSPEN  bit,  re-initialize the SSPCON registers, and then set the SSPEN bit. This configures the SDI, SDO, SCK, and SS pins as serial port pins. For the pins to behave as the serial port function,  some must have their data direction bits (in the TRIS register) appropriately programmed. That is:\nGLYPH<129> SDI is automatically controlled by the SPI module\nGLYPH<129> SDO must have TRISC<5> bit cleared\nGLYPH<129> SCK (Master mode) must have TRISC<3> bit cleared\nGLYPH<129> SCK (Slave mode) must have TRISC<3> bit set\nGLYPH<129> SS must have TRISC<4> bit set",
    "15.3.4 TYPICAL CONNECTION\nFigure 15-2 shows a typical connection between two microcontrollers. The  master controller (Processor 1) initiates the data transfer by sending the SCK signal. Data is shifted out of both shift registers on their programmed  clock  edge,  and  latched  on  the  opposite edge  of  the  clock.  Both  processors  should  be  programmed to the same Clock Polarity (CKP), then both controllers would send and receive data at the same time. Whether the data is meaningful (or dummy data) depends  on  the  application  software.  This  leads  to three scenarios for data transmission:\nGLYPH<129> Master sends data - Slave sends dummy data\nGLYPH<129> Master sends data - Slave sends data\nGLYPH<129> Master sends dummy data - Slave sends data\nAny  serial  port  function  that  is  not  desired  may  be overridden  by  programming  the  corresponding  data direction (TRIS) register to the opposite value.",
    "15.3.5 MASTER MODE\nThe master can initiate the data transfer at any time because it controls the SCK. The master determines when  the  slave (Processor 2, Figure 15-2) is to broadcast data by the software protocol.\nIn  Master  mode,  the  data  is  transmitted/received  as soon as the SSPBUF register is written to. If the SPI is only  going  to  receive,  the  SDO  output  could  be  disabled (programmed as an input). The SSPSR register will continue to shift in the signal present on the SDI pin at the programmed  clock  rate.  As  each  byte is received, it will be loaded into the SSPBUF register as if  a  normal  received  byte  (interrupts  and  status  bits appropriately  set).  This  could  be  useful  in  receiver applications as a 'Line Activity Monitor' mode.\nFigure 15-3, Figure 15-5, and Figure 15-6, where the MSB is transmitted first. In Master mode, the SPI clock rate (bit rate) is user programmable to be one of the following:",
    "15.3.5 MASTER MODE\nGLYPH<129> FOSC/4 (or TCY)\nGLYPH<129> FOSC/16 (or 4 GLYPH<129> T CY)\nGLYPH<129> FOSC/64 (or 16 GLYPH<129> T CY)\nGLYPH<129> Timer2 output/2\nThis  allows  a  maximum  data  rate  (at  40  MHz)  of 10.00 Mbps.\nThe clock polarity is selected by appropriately programming  the  CKP  bit  (SSPCON1<4>).  This  then,  would give  waveforms  for  SPI  communication  as  shown  in\nFigure 15-3  shows  the  waveforms  for  Master  mode. When the CKE bit is set, the SDO data is valid before there is a clock edge on SCK. The change of the input sample is shown based on the state of the SMP bit. The time  when  the  SSPBUF  is  loaded  with  the  received data is shown.\nFIGURE 15-3: SPI MODE WAVEFORM (MASTER MODE)",
    "15.3.6 SLAVE MODE\nIn Slave mode, the data is transmitted and received as the external clock pulses appear on SCK. When the last bit is latched, the SSPIF interrupt flag bit is set.\nWhile in Slave mode, the external clock is supplied by the external clock source on the SCK pin. This external clock must meet the minimum high and low times as specified in the electrical specifications.\nWhile in SLEEP mode, the slave can transmit/receive data. When a byte is received, the device will wake-up from sleep.",
    "15.3.7 SLAVE SELECT SYNCHRONIZATION\nlonger  driven,  even  if  in  the  middle  of  a  transmitted byte, and becomes a floating output. External pull-up/ pull-down resistors may be desirable, depending on the application.\nNote 1: When the SPI is in Slave mode with SS pin control enabled  (SSPCON<3:0>  = 0100 ), the SPI module will reset if the SS pin is set to VDD.\n2: If the SPI is used in Slave mode with CKE set,  then  the  SS  pin  control  must  be enabled.\nWhen the SPI module resets, the bit counter is forced to 0. This can be done by either forcing the SS pin to a high level or clearing the SSPEN bit.\nThe SS pin allows  a  Synchronous Slave mode.  The SPI must be in Slave mode with SS pin control enabled (SSPCON1<3:0> = 04h). The pin must not be driven low for the SS pin to function as an input. The Data Latch must be high. When the SS pin is low, transmission  and  reception  are  enabled  and  the  SDO  pin  is driven. When the SS pin goes high, the SDO pin is no",
    "15.3.7 SLAVE SELECT SYNCHRONIZATION\nTo emulate two-wire communication, the SDO pin can be connected to the SDI pin. When the SPI needs to operate as a receiver the SDO pin can be configured as an input.  This  disables  transmissions from  the  SDO. The SDI can always be left as an input (SDI function), since it cannot create a bus conflict.",
    "PIC18FXX2\nFIGURE 15-6:\nSPI MODE WAVEFORM (SLAVE MODE WITH CKE = 1)",
    "15.3.8 SLEEP OPERATION\nIn Master mode, all module clocks are halted and the transmission/reception will remain in that state until the device wakes from SLEEP. After the device returns to Normal  mode,  the  module  will  continue  to  transmit/ receive data.\nIn Slave mode, the SPI transmit/receive shift register operates asynchronously to the device. This allows the device to  be placed  in SLEEP mode and data to be shifted into the  SPI  transmit/receive  shift  register. When all 8 bits have been received, the MSSP interrupt flag bit will be set and if enabled, will wake the device from SLEEP.",
    "15.3.10 BUS MODE COMPATIBILITY\nTable 15-1 shows the compatibility between the standard SPI modes and the states the CKP and CKE control bits.",
    "TABLE 15-1: SPI BUS MODES\n0, 0, Control Bits State.CKP = 0. 0, 0, Control Bits State.CKE = 1. 0, 1, Control Bits State.CKP = 0. 0, 1, Control Bits State.CKE = 0. 1, 0, Control Bits State.CKP = 1. 1, 0, Control Bits State.CKE = 1. 1, 1, Control Bits State.CKP = 1. 1, 1, Control Bits State.CKE = 0\nA RESET disables the MSSP module and terminates the current transfer.\nThere is also a SMP bit which controls when the data is sampled.",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000.",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nPIR1, Value on POR, BOR = 0000. PIR1, Value on All Other RESETS = 0000. PIR1, Value on All Other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on All Other RESETS = 0000. PIE1, Value on All Other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP.",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nIPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on All Other RESETS = 0000. IPR1, Value on All Other RESETS = 0000. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on All Other RESETS = 1111. TRISC, Value on All Other RESETS = 1111. SSPBUF, Bit 7 = Synchronous Serial Port Receive",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nBuffer/Transmit Register. SSPBUF, Bit 6 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 5 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 4 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 3 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 2 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 1 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 0 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Value on POR, BOR = xxxx. SSPBUF, Value on POR, BOR = xxxx. SSPBUF, Value on All Other RESETS = uuuu. SSPBUF, Value on All Other RESETS = uuuu. SSPCON, Bit 7 = WCOL. SSPCON, Bit 6 = SSPOV. SSPCON, Bit 5 = SSPEN. SSPCON, Bit",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH SPI OPERATION\n4 = CKP. SSPCON, Bit 3 = SSPM3. SSPCON, Bit 2 = SSPM2. SSPCON, Bit 1 = SSPM1. SSPCON, Bit 0 = SSPM0. SSPCON, Value on POR, BOR = 0000. SSPCON, Value on POR, BOR = 0000. SSPCON, Value on All Other RESETS = 0000. SSPCON, Value on All Other RESETS = 0000. TRISA, Bit 7 = -. TRISA, Bit 6 = PORTA Data Direction Register. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = -111. TRISA, Value on POR, BOR = 1111. TRISA, Value on All Other RESETS = -111. TRISA, Value on All Other RESETS",
    "TABLE 15-2: REGISTERS ASSOCIATED WITH SPI OPERATION\n= 1111. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Value on POR, BOR = 0000. SSPSTAT, Value on POR, BOR = 0000. SSPSTAT, Value on All Other RESETS = 0000. SSPSTAT, Value on All Other RESETS = 0000\nLegend: x = unknown, u = unchanged,   = unimplemented, read as '0'. Shaded cells are not used by the MSSP in SPI mode. -\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18C2X2 devices; always maintain these bits clear.",
    "15.4 I 2 C Mode\nThe MSSP module in I 2 C  mode  fully  implements  all master and slave functions (including general call support) and provides interrupts on START and STOP bits in hardware to determine a free bus (multi-master function).  The  MSSP  module  implements  the  Standard mode  specifications, as well as 7-bit and  10-bit addressing.\nTwo pins are used for data transfer:\nGLYPH<129> Serial clock (SCL) - RC3/SCK/SCL\nGLYPH<129> Serial data (SDA) - RC4/SDI/SDA\nThe user must configure these pins as inputs or outputs through the TRISC<4:3> bits.",
    "15.4.1 REGISTERS\nThe MSSP module has six registers for I 2 C operation. These are:\nGLYPH<129> MSSP Control Register1 (SSPCON1)\nGLYPH<129> MSSP Control Register2 (SSPCON2)\nGLYPH<129> MSSP Status Register (SSPSTAT)\nGLYPH<129> Serial Receive/Transmit Buffer (SSPBUF)\nGLYPH<129> MSSP Shift Register (SSPSR) - Not directly accessible\nGLYPH<129> MSSP Address Register (SSPADD)\nSSPCON, SSPCON2 and SSPSTAT  are  the  control and  status  registers in I 2 C mode  operation.  The SSPCON and SSPCON2 registers are readable and writable.  The  lower  6  bits  of  the  SSPSTAT  are  read only.  The  upper  two  bits  of  the  SSPSTAT  are  read/ write.\nSSPSR is the shift register used for shifting data in or out. SSPBUF is the buffer register to which data bytes are written to or read from.",
    "15.4.1 REGISTERS\nSSPADD  register  holds  the  slave  device  address when the SSP is configured in I 2 C Slave mode. When the  SSP  is  configured  in  Master  mode,  the  lower seven bits of SSPADD act as the baud rate generator reload value.\nIn receive operations, SSPSR and SSPBUF together, create  a  double  buffered  receiver.  When  SSPSR receives a complete byte, it is transferred to SSPBUF and the SSPIF interrupt is set.\nDuring transmission, the SSPBUF is not double buffered. A write to SSPBUF will write to both SSPBUF and SSPSR.",
    "REGISTER 15-3: SSPSTAT: MSSP STATUS REGISTER (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P. SMP, 4 = S. SMP, 5 = R/W. SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "bit 7 SMP: Slew Rate Control bit\nIn Master or Slave mode:\n1 = Slew rate control disabled for Standard Speed mode (100 kHz and 1 MHz)\n0 = Slew rate control enabled for High Speed mode (400 kHz)",
    "bit 6 CKE: SMBus Select bit\nIn Master or Slave mode:\n1 = Enable SMBus specific inputs\n0 = Disable SMBus specific inputs",
    "bit 5 D/A: Data/Address bit\nIn Master mode:\nReserved\nIn Slave mode:\n1 = Indicates that the last byte received or transmitted was data\n0 = Indicates that the last byte received or transmitted was address",
    "bit 4 P: STOP bit\n1 = Indicates that a STOP bit has been detected last\n0 = STOP bit was not detected last\nNote:\nThis bit is cleared on RESET and when SSPEN is cleared.",
    "bit 3 S: START bit\n1 = Indicates that a start bit has been detected last\n0 = START bit was not detected last\nNote: This bit is cleared on RESET and when SSPEN is cleared.",
    "In Slave mode:\n1 = Read\n0 = Write\nNote:\nThis bit holds the R/W bit information following the last address match. This bit is only valid from the address match to the next START bit, STOP bit, or not ACK bit.",
    "In Master mode:\n1 = Transmit is in progress\n0 = Transmit is not in progress\nNote:\nORing this bit with SEN, RSEN, PEN, RCEN, or ACKEN will indicate if the MSSP is in IDLE mode.",
    "bit 1 UA: Update Address (10-bit Slave mode only)\n1 = Indicates that the user needs to update the address in the SSPADD register\n0 = Address does not need to be updated",
    "bit 0 BF: Buffer Full Status bit\nIn Transmit mode:\n1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty",
    "In Receive mode:\n1 = Data transmit in progress (does not include the ACK and STOP bits), SSPBUF is full\n0 = Data transmit complete (does not include the ACK and STOP bits), SSPBUF is empty",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 15-4: SSPCON1: MSSP CONTROL REGISTER1 (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. WCOL, 1 = SSPOV. WCOL, 2 = SSPEN. WCOL, 3 = CKP. WCOL, 4 = SSPM3. WCOL, 5 = SSPM2. WCOL, 6 = SSPM1. WCOL, 7 = SSPM0\nbit 7\nbit 0",
    "In Master Transmit mode:\n1 = A write to the SSPBUF register was attempted while the I 2 C conditions were not valid for a transmission to be started (must be cleared in software)\n0 = No collision",
    "In Slave Transmit mode:\n1 = The SSPBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision\nIn Receive mode (Master or Slave modes):\nThis is a 'don't care' bit",
    "bit 6 SSPOV: Receive Overflow Indicator bit\nIn Receive mode:\n1 = A byte is received while the SSPBUF register is still holding the previous byte (must be cleared in software)\n0 = No overflow\nIn Transmit mode:\nThis is a 'don't care' bit in Transmit mode",
    "bit 5 SSPEN:\nSynchronous Serial Port Enable bit\n1 = Enables the serial port and configures the SDA and SCL pins as the serial port pins\n0 = Disables serial port and configures these pins as I/O port pins\nNote: When enabled, the SDA and SCL pins must be properly configured as input or output.",
    "bit 4 CKP: SCK Release Control bit\nIn Slave mode:\n1 = Release clock\n0 = Holds clock low (clock stretch), used to ensure data setup time",
    "In Master mode:\nUnused in this mode",
    "bit 3-0 SSPM3:SSPM0: Synchronous Serial Port Mode Select bits\n1111 = I\n2 C Slave mode, 10-bit address with START and STOP bit interrupts enabled\n1110 = I 2 C Slave mode, 7-bit address with START and STOP bit interrupts enabled\n1011 = I 2 C Firmware Controlled Master mode (Slave IDLE)\n1000 = I 2 C Master mode, clock = FOSC / (4 * (SSPADD+1))\n0111 = I 2 C Slave mode, 10-bit address\n0110 = I 2 C Slave mode, 7-bit address\nNote: Bit combinations not specifically listed here are either reserved, or implemented in SPI mode only.",
    "bit 3-0 SSPM3:SSPM0: Synchronous Serial Port Mode Select bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 15-5: SSPCON2: MSSP CONTROL REGISTER 2 (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. GCEN, 1 = ACKSTAT. GCEN, 2 = ACKDT. GCEN, 3 = ACKEN. GCEN, 4 = RCEN. GCEN, 5 = PEN. GCEN, 6 = RSEN. GCEN, 7 = SEN\nbit 7\nbit 0\nbit 7 GCEN: General Call Enable bit (Slave mode only)\n1 = Enable interrupt when a general call address (0000h) is received in the SSPSR\n0 = General call address disabled",
    "bit 6 ACKSTAT: Acknowledge Status bit (Master Transmit mode only)\n1 = Acknowledge was not received from slave\n0 = Acknowledge was received from slave",
    "bit 5 ACKDT: Acknowledge Data bit (Master Receive mode only)\n1 = Not Acknowledge\n0 = Acknowledge\nNote:\nValue that will be transmitted when the user initiates an Acknowledge sequence at the end of a receive.",
    "bit 4 ACKEN: Acknowledge Sequence Enable bit (Master Receive mode only)\n1 = Initiate Acknowledge sequence on SDA and SCL pins, and transmit ACKDT data bit.\nAutomatically cleared by hardware.\n0 = Acknowledge sequence IDLE",
    "bit 3 RCEN: Receive Enable bit (Master mode only)\n1 = Enables Receive mode for I 2 C\n0 = Receive IDLE\nPEN:\nSTOP Condition Enable bit (Master mode only)\n1 = Initiate STOP condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = STOP condition IDLE",
    "bit 1 RSEN: Repeated START Condition Enabled bit (Master mode only)\n1 = Initiate Repeated START condition on SDA and SCL pins.\nAutomatically cleared by hardware.\n0 = Repeated START condition IDLE",
    "In Master mode:\n1 = Initiate START condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = START condition IDLE",
    "In Slave mode:\n1 = Clock stretching is enabled for both Slave Transmit and Slave Receive (stretch enabled)\n0 = Clock stretching is enabled for slave transmit only (Legacy mode)\nNote:\nFor bits ACKEN, RCEN, PEN, RSEN, SEN:  If the I 2 C module is not in the IDLE mode, this bit may not be set (no spooling) and the SSPBUF may not be written (or writes to the SSPBUF are disabled).\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown\nbit 2",
    "15.4.2 OPERATION\nThe  MSSP  module  functions  are  enabled  by  setting MSSP Enable bit, SSPEN (SSPCON<5>).\nThe SSPCON1 register allows control of the I 2 C operation. Four mode selection bits (SSPCON<3:0>) allow one of the following I 2 C modes to be selected:\nGLYPH<129> I 2 C Master mode, clock = OSC/4 (SSPADD +1)\nGLYPH<129> I 2 C Slave mode (7-bit address)\nGLYPH<129> I 2 C Slave mode (10-bit address)\nGLYPH<129> I 2 C Slave mode (7-bit address), with START and STOP bit interrupts enabled\nGLYPH<129> I 2 C Slave mode (10-bit address), with START and STOP bit interrupts enabled\nGLYPH<129> I 2 C Firmware controlled master operation, slave is IDLE",
    "15.4.2 OPERATION\nSelection  of  any  I 2 C  mode,  with  the  SSPEN  bit  set, forces the SCL and SDA pins to be open drain, provided these pins are programmed to inputs by setting the appropriate TRISC bits. To guarantee proper operation of the module, pull-up resistors must be provided externally to the SCL and SDA pins.",
    "15.4.3 SLAVE MODE\nIn Slave mode, the SCL and SDA pins must be configured as inputs (TRISC<4:3> set). The MSSP module will override the input state with the output data when required (slave-transmitter).\nThe I 2 C Slave mode hardware will always generate an interrupt  on  an  address  match.  Through  the  mode select  bits,  the  user  can  also  choose  to  interrupt  on START and STOP bits\nWhen an address is matched or the data transfer after an address match is received, the hardware automatically will generate the Acknowledge (ACK) pulse and load  the  SSPBUF  register  with  the  received  value currently in the SSPSR register.\nAny combination of the following conditions will cause the MSSP module not to give this ACK pulse:\nGLYPH<129> The buffer full bit BF (SSPSTAT<0>) was set before the transfer was received.\nGLYPH<129> The overflow bit SSPOV (SSPCON<6>) was set before the transfer was received.",
    "15.4.3 SLAVE MODE\nIn  this  case,  the  SSPSR register value is not loaded into the SSPBUF, but bit SSPIF (PIR1<3>) is set. The BF bit is cleared by reading the SSPBUF register, while bit SSPOV is cleared through software.\nThe SCL clock input must have a minimum high and low for proper operation. The high and low times of the I 2 C  specification,  as  well  as  the  requirement  of  the MSSP module, are shown in timing parameter 100 and parameter 101.",
    "15.4.3.1 Addressing\nOnce the MSSP module has been enabled, it waits for a START condition to occur. Following the START condition, the 8-bits are shifted into the SSPSR register. All incoming bits are sampled with the rising edge of the clock (SCL) line. The value of register SSPSR<7:1> is compared to the value of the  SSPADD register. The address is compared on the falling edge of the eighth clock (SCL) pulse. If the addresses match, and the BF and SSPOV bits are clear, the following events occur:\n1. The  SSPSR  register  value  is  loaded  into  the SSPBUF register.\n2. The buffer full bit BF is set.\n3. An ACK pulse is generated.\n4. MSSP interrupt flag bit, SSPIF (PIR1<3>) is set (interrupt is generated if enabled) on the falling edge of the ninth SCL pulse.",
    "15.4.3.1 Addressing\nIn 10-bit Address mode, two address bytes need to be received  by  the  slave.  The  five  Most  Significant  bits (MSbs) of the first address byte specify if this is a 10-bit address. Bit R/W (SSPSTAT<2>) must specify a write so  the  slave  device  will  receive  the  second  address byte. For a 10-bit address, the first byte would equal ' 11110  A9  A8  0 ',  where ' A9 '  and  ' A8 '  are the two MSbs of the address. The sequence of events for 10-bit address is as follows, with steps 7  through 9 for the slave-transmitter:",
    "15.4.3.1 Addressing\n1. Receive first (high) byte of Address (bits SSPIF, BF and bit UA (SSPSTAT<1>) are set).\n2. Update the SSPADD register with second (low) byte of Address (clears bit UA and releases the SCL line).\n3. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.\n4. Receive  second  (low)  byte  of  Address  (bits SSPIF, BF, and UA are set).\n5. Update the SSPADD register with the first (high) byte of Address. If match releases SCL line, this will clear bit UA.\n6. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.\n7. Receive Repeated START condition.\n8. Receive first (high) byte of Address (bits SSPIF and BF are set).\n9. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.",
    "15.4.3.2 Reception\nWhen the R/W bit of the address byte is clear and an address  match  occurs,  the  R/W  bit  of  the  SSPSTAT register is cleared. The received address is loaded into the  SSPBUF  register  and  the  SDA  line  is  held  low (ACK).\nWhen the address byte overflow condition exists, then the no Acknowledge (ACK) pulse is given. An overflow condition is defined as either bit BF (SSPSTAT<0>) is set, or bit SSPOV (SSPCON1<6>) is set.\nAn MSSP interrupt is generated for each data transfer byte. Flag bit SSPIF (PIR1<3>) must be cleared in software. The SSPSTAT register is used to determine the status of the byte.\nIf  SEN  is  enabled  (SSPCON1<0>=1),  RC3/SCK/SCL will be held low (clock stretch) following each data transfer.  The  clock  must  be  released  by  setting  bit  CKP (SSPCON<4>). See Section 15.4.4 ('Clock Stretching'), for more detail.",
    "15.4.3.3 Transmission\nWhen the R/W bit of the incoming address byte is set and  an  address  match  occurs,  the  R/W  bit  of  the SSPSTAT  register  is  set.  The  received  address  is loaded into the SSPBUF register. The ACK pulse will be sent on the ninth bit and pin RC3/SCK/SCL is held low, regardless of SEN  (see 'Clock Stretching', Section 15.4.4, for more detail). By stretching the clock, the master will be unable to assert another clock pulse until the slave is done preparing the transmit data.The transmit data must be loaded into the SSPBUF register, which also loads the SSPSR register. Then pin RC3/ SCK/SCL  should  be  enabled  by  setting  bit  CKP (SSPCON1<4>). The eight data bits are shifted out on the falling edge of the SCL input. This ensures that the SDA  signal is valid during the SCL high time (Figure 15-9).",
    "15.4.3.3 Transmission\nThe ACK pulse from the master-receiver is latched on the rising edge of the ninth SCL input pulse. If the SDA line is  high (not ACK), then the data transfer is complete.  In  this  case,  when  the  ACK  is  latched  by  the slave, the slave logic is reset (resets SSPSTAT register) and the slave monitors for another occurrence of the START bit. If the SDA line was low (ACK), the next transmit data must be loaded into the SSPBUF register. Again, pin RC3/SCK/SCL must be enabled by setting bit CKP.\nAn MSSP interrupt is generated for each data transfer byte. The SSPIF bit must be cleared in software and the SSPSTAT register is used to determine the status of the byte. The SSPIF bit is set on the falling edge of the ninth clock pulse.",
    "15.4.4 CLOCK STRETCHING\nBoth 7- and 10-bit Slave modes implement automatic clock stretching during a transmit sequence.\nThe SEN bit (SSPCON2<0>) allows clock stretching to be  enabled  during  receives.  Setting  SEN  will  cause the  SCL  pin  to  be  held  low  at  the  end  of  each  data receive sequence.",
    "15.4.4.1 Clock Stretching for 7-bit Slave Receive Mode (SEN = 1)\nIn 7-bit Slave Receive mode, on the falling edge of the ninth clock at the end of the ACK sequence, if the BF bit is set, the CKP bit in the SSPCON1 register is automatically  cleared,  forcing  the  SCL  output  to  be  held low. The CKP being cleared to '0' will assert the SCL line  low.  The  CKP  bit  must  be  set  in  the  user's  ISR before reception is allowed to continue. By holding the SCL line low, the user has time to service the ISR and read the contents of the SSPBUF before the master device can initiate another receive sequence. This will prevent buffer overruns from occurring (see Figure 15-13).",
    "15.4.4.1 Clock Stretching for 7-bit Slave Receive Mode (SEN = 1)\nNote 1: If the  user  reads  the  contents  of  the SSPBUF  before  the  falling  edge  of  the ninth  clock,  thus  clearing  the  BF  bit,  the CKP  bit  will  not  be  cleared  and  clock stretching will not occur.\n2: The  CKP  bit  can  be  set  in  software, regardless of the state of the BF bit. The user should be careful to clear the BF bit in the ISR before the next receive sequence, in order to prevent an overflow condition.",
    "15.4.4.2 Clock Stretching for 10-bit Slave Receive Mode (SEN = 1)\nIn  10-bit  Slave  Receive  mode,  during  the  address sequence,  clock  stretching  automatically  takes  place but CKP is not cleared. During this time, if the UA bit is set  after  the  ninth  clock,  clock  stretching  is  initiated. The UA bit is set after receiving the upper byte of the 10-bit address, and following the receive of the second byte of the 10-bit address with the R/W bit cleared to '0'. The release of the clock line occurs upon updating SSPADD.  Clock  stretching  will  occur  on  each  data receive sequence as described in 7-bit mode.",
    "Note:\nIf the user polls the UA bit and clears it by updating the SSPADD register before the falling edge of the ninth clock occurs, and if the user hasn't cleared the BF bit by reading the SSPBUF register before that time, then the CKP bit will still NOT be asserted low.  Clock  stretching  on  the  basis  of  the state of the BF bit only occurs during a data sequence, not an address sequence.",
    "15.4.4.3 Clock Stretching for 7-bit Slave Transmit Mode\n7-bit Slave Transmit mode implements clock stretching by  clearing  the  CKP  bit  after  the  falling  edge  of  the ninth clock, if the BF  bit is clear. This occurs, regardless of the state of the SEN bit.\nThe user's ISR must set the CKP bit before transmission  is  allowed  to  continue.  By  holding  the  SCL  line low, the user has time to service the ISR and load the contents of the SSPBUF before the master device can initiate another transmit sequence (see Figure 15-9).\nNote 1: If the user loads the contents of SSPBUF, setting the BF bit before the falling edge of the  ninth  clock,  the  CKP  bit  will  not  be cleared and clock stretching will not occur.\n2: The  CKP  bit  can  be  set  in  software, regardless of the state of the BF bit.",
    "15.4.4.4 Clock Stretching for 10-bit Slave Transmit Mode\nIn 10-bit Slave Transmit mode, clock stretching is controlled during the first two address sequences by the state of the UA bit, just as it is in 10-bit Slave Receive mode. The first two addresses are followed by a third address sequence, which contains the high order bits of the 10-bit address and the R/W bit set to '1'. After the third address sequence is performed, the UA bit is not  set,  the  module  is  now  configured  in  Transmit mode, and clock stretching is controlled by the BF flag, as in 7-bit Slave Transmit mode (see Figure 15-11).",
    "15.4.4.5 Clock Synchronization and the CKP bit\nIf a user clears the CKP bit, the SCL output is forced to '0'. Setting the CKP bit will not assert the SCL output low until the SCL output is already sampled low. If the user  attempts  to  drive  SCL  low,  the  CKP  bit  will  not assert the SCL line until an external I 2 C master device has already asserted the SCL line. The SCL output will remain  low  until  the  CKP  bit  is  set,  and  all  other devices  on  the  I 2 C  bus  have  de-asserted  SCL.  This ensures that a write to the CKP bit will not violate the minimum high time requirement for SCL (see Figure 15-12).",
    "15.4.5 GENERAL CALL ADDRESS SUPPORT\nThe addressing procedure for the I 2 C bus is such that the first byte after the START condition usually determines which device will be the slave addressed by the master.  The  exception  is  the  general  call  address, which can address all devices. When this address is used,  all  devices  should,  in  theory,  respond  with  an Acknowledge.\nThe  general  call  address  is  one  of  eight  addresses reserved for specific purposes by the I 2 C protocol. It consists of all 0's with R/W = 0.\nThe general call address is recognized when the General Call Enable bit (GCEN) is enabled (SSPCON2<7> set).  Following a START bit detect, 8-bits are shifted into the SSPSR and the address is compared against the SSPADD. It is also compared to the general call address and fixed in hardware.\nIf  the  general  call  address  matches,  the  SSPSR  is transferred to the SSPBUF, the BF flag bit is set (eighth bit), and on the falling edge of the ninth bit (ACK bit), the SSPIF interrupt flag bit is set.",
    "15.4.5 GENERAL CALL ADDRESS SUPPORT\nWhen the interrupt is serviced, the source for the interrupt  can  be  checked  by  reading  the  contents  of  the SSPBUF. The value can be used to determine if the address was device specific or a general call address.\nIn 10-bit mode, the SSPADD is required to be updated for the second half of the address to match, and the UA bit is set (SSPSTAT<1>). If the general call address is sampled when the GCEN bit is set, while the slave is configured  in  10-bit  Address  mode,  then  the  second half of the address is not necessary, the UA bit will not be set, and the slave will begin receiving data after the Acknowledge (Figure 15-15).",
    "15.4.6 MASTER MODE\nMaster  mode  is  enabled  by  setting  and  clearing  the appropriate SSPM bits in SSPCON1 and by setting the SSPEN bit. In Master mode, the SCL and SDA lines are manipulated by the MSSP hardware.\nMaster  mode  of  operation  is  supported  by  interrupt generation on the detection of the START and STOP conditions.  The  STOP  (P)  and  START  (S)  bits  are cleared from a RESET or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set or the bus is IDLE, with both the S and P bits clear.\nIn Firmware Controlled Master mode, user code conducts  all  I 2 C  bus  operations  based  on  START  and STOP bit conditions.\nOnce  Master  mode  is  enabled,  the  user  has  six options.\n1. Assert a START condition on SDA and SCL.\n2. Assert  a  Repeated  START  condition  on  SDA and SCL.\n3. Write to the SSPBUF register initiating transmission of data/address.\n4. Configure the I 2 C port to receive data.\n5. Generate an Acknowledge condition at the end of a received byte of data.\n6. Generate a STOP condition on SDA and SCL.",
    "Note:\nThe MSSP Module, when configured in I 2 C Master mode, does not allow queueing of events. For instance, the user is not allowed to initiate a START condition and immediately write the SSPBUF register to initiate transmission  before  the  START condition  is  complete.  In  this  case,  the SSPBUF  will  not  be  written  to  and  the WCOL bit will be set, indicating that a write to the SSPBUF did not occur.\nThe following events will cause SSP interrupt flag bit, SSPIF, to be set (SSP interrupt if enabled):\nGLYPH<129> START condition\nGLYPH<129> STOP condition\nGLYPH<129> Data transfer byte transmitted/received\nGLYPH<129> Acknowledge Transmit\nGLYPH<129> Repeated START",
    "15.4.6.1 I 2 C Master Mode Operation\nThe  master  device  generates  all  of  the  serial  clock pulses and the START and STOP conditions.   A transfer is ended with a STOP condition or with a Repeated START condition. Since the Repeated START condition is also the beginning of the next serial transfer, the I 2 C bus will not be released.\nIn Master  Transmitter  mode,  serial  data  is  output through SDA, while SCL outputs the serial clock. The first byte transmitted contains the slave address of the receiving device (7 bits) and the Read/Write (R/W) bit. In this case, the R/W bit will be logic '0'. Serial data is transmitted 8 bits at a time. After each byte is transmitted, an Acknowledge bit is received. START and STOP conditions are output to indicate the beginning and the end of a serial transfer.",
    "15.4.6.1 I 2 C Master Mode Operation\nIn Master Receive mode, the first byte transmitted contains  the  slave  address  of  the  transmitting  device (7 bits) and the R/W bit. In this case, the R/W bit will be logic '1'. Thus, the first byte transmitted is a 7-bit slave address followed by a '1' to indicate receive bit. Serial data is received via SDA, while SCL outputs the serial clock. Serial data is received 8 bits at a time. After each byte  is  received,  an  Acknowledge  bit  is  transmitted. START and  STOP  conditions  indicate  the  beginning and end of transmission.\nThe baud rate generator used for the SPI mode operation is used to set the SCL clock frequency for either 100  kHz,  400  kHz  or  1  MHz  I 2 C  operation.  See Section 15.4.7  ('Baud  Rate  Generator'),  for  more detail.\nA typical transmit sequence would go as follows:",
    "15.4.6.1 I 2 C Master Mode Operation\n1. The user generates a START condition by setting the START enable bit, SEN (SSPCON2<0>).\n2. SSPIF is set. The MSSP module will wait the required  start  time  before  any  other  operation takes place.\n3. The  user  loads  the  SSPBUF  with  the  slave address to transmit.\n4. Address is shifted out the SDA pin until all 8 bits are transmitted.\n5. The MSSP Module shifts in the ACK bit from the slave device and  writes its value into the SSPCON2 register (SSPCON2<6>).\n6. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.\n7. The user loads the SSPBUF with eight bits of data.\n8. Data is shifted out the SDA pin until all 8 bits are transmitted.\n9. The MSSP Module shifts in the ACK bit from the slave device and  writes its value into the SSPCON2 register (SSPCON2<6>).\n10. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.",
    "15.4.6.1 I 2 C Master Mode Operation\n11. The user generates a STOP condition by setting the STOP enable bit PEN (SSPCON2<2>).\n12. Interrupt is generated once the STOP condition is complete.",
    "15.4.7 BAUD RATE GENERATOR\nIn  I 2 C  Master  mode,  the  baud  rate  generator  (BRG) reload  value  is  placed  in  the  lower  7  bits  of  the SSPADD register (Figure 15-17). When a write occurs to SSPBUF, the baud rate generator will automatically begin counting. The BRG counts down to 0 and stops until another reload has taken place. The BRG count is decremented twice per instruction cycle (TCY) on the Q2 and Q4 clocks. In I 2 C  Master  mode,  the  BRG  is reloaded automatically.\nOnce the given operation is complete (i.e., transmission of the last data bit is followed by ACK), the internal clock will automatically stop counting and the SCL pin will remain in its last state.\nTable 15-3 demonstrates clock rates based on instruction  cycles  and  the  BRG  value  loaded  into SSPADD.",
    "TABLE 15-3: I 2 C CLOCK RATE W/BRG\n10 MHz, FCY*2 = 20 MHz. 10 MHz, BRG Value = 19h. 10 MHz, FSCL (2) (2 Rollovers of BRG) = 400 kHz (1). 10 MHz, FCY*2 = 20 MHz. 10 MHz, BRG Value = 20h. 10 MHz, FSCL (2) (2 Rollovers of BRG) = 312.5 kHz. 10 MHz, FCY*2 = 20 MHz. 10 MHz, BRG Value = 3Fh. 10 MHz, FSCL (2) (2 Rollovers of BRG) = 100 kHz. 4 MHz, FCY*2 = 8 MHz. 4 MHz, BRG Value = 0Ah. 4 MHz, FSCL (2) (2 Rollovers of BRG) = 400 kHz (1). 4 MHz, FCY*2 = 8 MHz. 4 MHz, BRG Value = 0Dh. 4 MHz, FSCL (2) (2 Rollovers of BRG) = 308 kHz. 4 MHz, FCY*2 = 8 MHz. 4 MHz, BRG Value = 28h. 4",
    "TABLE 15-3: I 2 C CLOCK RATE W/BRG\nMHz, FSCL (2) (2 Rollovers of BRG) = 100 kHz. 1 MHz, FCY*2 = 2 MHz. 1 MHz, BRG Value = 03h. 1 MHz, FSCL (2) (2 Rollovers of BRG) = 333 kHz (1). 1 MHz, FCY*2 = 2 MHz. 1 MHz, BRG Value = 0Ah. 1 MHz, FSCL (2) (2 Rollovers of BRG) = 100kHz. 1 MHz, FCY*2 = 2 MHz. 1 MHz, BRG Value = 00h. 1 MHz, FSCL (2) (2 Rollovers of BRG) = 1 MHz (1)\nNote 1: The I 2 C interface does not conform to the 400 kHz I 2 C specification (which applies to rates greater than 100 kHz) in all details, but may be used with care where higher rates are required by the application.\n2: Actual frequency will depend on bus conditions. Theoretically, bus conditions will add rise time and extend low time of clock period, producing the effective frequency.",
    "15.4.7.1 Clock Arbitration\nClock arbitration occurs when the master, during any receive, transmit or Repeated START/STOP condition, de-asserts  the  SCL  pin  (SCL  allowed  to  float  high). When the SCL pin is allowed to float high, the baud rate generator (BRG) is suspended from counting until the SCL pin is actually sampled high. When the SCL pin is sampled high, the baud rate generator is reloaded with the  contents  of  SSPADD<6:0>  and  begins  counting. This ensures that the SCL high time will always be at least one BRG rollover count, in the event that the clock is held low by an external device (Figure 15-18).",
    "15.4.8 I 2 C MASTER MODE START CONDITION TIMING\nTo initiate a START condition, the user sets the START condition enable bit, SEN (SSPCON2<0>). If the SDA and SCL pins are sampled high, the baud rate generator is reloaded with the contents of SSPADD<6:0> and starts its count. If SCL and SDA are both sampled high when the  baud  rate  generator  times  out  (TBRG),  the SDA pin is  driven  low.  The  action  of  the  SDA  being driven low, while SCL is high, is the START condition and causes the S bit (SSPSTAT<3>) to be set. Following this, the baud rate generator is reloaded with the contents  of  SSPADD<6:0>  and  resumes  its  count. When the baud rate generator times out (TBRG), the SEN bit (SSPCON2<0>) will be automatically cleared by  hardware,  the  baud  rate  generator  is  suspended, leaving the SDA line held low and the START condition is complete.",
    "Note:\nIf at the beginning of the START condition, the  SDA and SCL pins are already sampled low, or if during the START condition the  SCL  line  is  sampled  low  before  the SDA  line  is  driven  low,  a  bus  collision occurs,  the  Bus  Collision  Interrupt  Flag, BCLIF  is  set, the START  condition  is aborted, and the I 2 C module is reset into its IDLE state.",
    "15.4.8.1 WCOL Status Flag\nIf the user writes the SSPBUF  when  a  START sequence is in progress, the WCOL is set and the contents  of  the  buffer  are  unchanged  (the  write  doesn't occur).\nNote:, 1 = Because queueing of events is not allowed, writing to the lower 5 bits of SSPCON2 is disabled until the START condition is complete.",
    "15.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nA Repeated START condition occurs when the RSEN bit  (SSPCON2<1>) is programmed high and the I 2 C logic module is in the IDLE state. When the RSEN bit is set, the SCL pin is asserted low. When the SCL pin is sampled low, the baud rate generator is loaded with the contents of SSPADD<5:0> and begins counting. The SDA pin is released (brought high) for one baud rate generator count (TBRG). When the baud rate generator times out, if SDA is sampled high, the SCL pin will be de-asserted  (brought  high).  When  SCL  is  sampled high, the baud rate generator is reloaded with the contents of SSPADD<6:0> and begins counting. SDA and SCL must be sampled high for one TBRG. This action is then followed by assertion of the SDA pin (SDA = 0) for one TBRG ,  while SCL is high. Following this, the RSEN bit",
    "15.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\n(SSPCON2<1>) will be automatically cleared and the baud rate generator will not be reloaded, leaving the SDA pin held low. As soon as a START condition is detected on the SDA  and  SCL  pins,  the  S bit (SSPSTAT<3>) will be set. The SSPIF bit will not be set until the baud rate generator has timed out.\nNote 1: If  RSEN is programmed while any other event is in progress, it will not take effect.\n2: A bus collision during the Repeated START condition occurs if:\nGLYPH<129> SDA is sampled low when SCL goes from low to high.\nGLYPH<129> SCL goes low before SDA is asserted low. This may indicate that another master is attempting to transmit a data \"1\".",
    "FIGURE 15-20: REPEAT START CONDITION WAVEFORM\nImmediately  following  the  SSPIF  bit  getting  set,  the user may write the SSPBUF with the 7-bit address in 7-bit mode, or the default first address in 10-bit mode. After the first eight bits are transmitted and an ACK is received, the user may then transmit an additional eight bits of address (10-bit mode) or eight bits of data (7-bit mode).",
    "15.4.9.1 WCOL Status Flag\nIf the  user  writes  the  SSPBUF  when  a  Repeated START sequence is in progress, the WCOL is set and the  contents  of  the  buffer  are  unchanged  (the  write doesn't occur).",
    "Note:\nBecause queueing of events is not allowed,  writing  of  the  lower  5  bits  of SSPCON2 is disabled until the Repeated START condition is complete.",
    "15.4.10 I 2 C MASTER MODE TRANSMISSION\nTransmission  of  a  data  byte,  a  7-bit  address,  or  the other half of a 10-bit address is accomplished by simply writing a value to the SSPBUF register. This action will set the buffer full flag bit, BF, and allow the baud rate generator to begin counting and start the next transmission. Each bit of address/data will be shifted out onto the SDA pin after the falling edge of SCL is asserted (see data hold time specification parameter 106). SCL is held low for one baud rate generator rollover count (TBRG). Data should be valid before SCL is released high (see data setup time specification parameter 107). When the SCL pin is released high, it is held that way for TBRG. The data on the SDA pin must remain stable for that duration and some hold time after the next falling edge of SCL. After the eighth bit is shifted out (the falling edge of the eighth clock), the BF flag is cleared and the master releases SDA. This allows the slave device  being  addressed  to  respond  with  an  ACK  bit during the ninth bit time if an address match occurred or if data was received properly.",
    "15.4.10 I 2 C MASTER MODE TRANSMISSION\nThe status of ACK is written  into the  ACKDT bit on the falling edge of the ninth clock. If the master receives an Acknowledge, the Acknowledge status bit, ACKSTAT, is cleared. If not, the bit is set. After the ninth clock, the SSPIF bit is set and  the  master  clock  (baud  rate  generator)  is  suspended  until  the  next  data  byte  is  loaded  into  the SSPBUF,  leaving SCL  low  and  SDA  unchanged (Figure 15-21).",
    "15.4.10 I 2 C MASTER MODE TRANSMISSION\nAfter the write to the SSPBUF, each bit of address will be shifted out on the falling edge of SCL until all seven address bits and the R/W bit are completed. On the falling edge of the eighth clock, the master will de-assert the  SDA  pin,  allowing  the  slave  to  respond  with  an Acknowledge. On the falling edge of the ninth clock, the master will sample the SDA pin to see if the address was recognized by a slave. The status of the ACK bit is loaded into the ACKSTAT status bit (SSPCON2<6>). Following the falling edge of the ninth clock transmission of the address, the SSPIF is set, the BF flag is cleared and the baud rate generator is turned off until another write to the SSPBUF takes place, holding SCL low and allowing SDA to float.",
    "15.4.10.1 BF Status Flag\nIn  Transmit  mode,  the  BF  bit  (SSPSTAT<0>)  is  set when the CPU writes to SSPBUF and is cleared when all 8 bits are shifted out.",
    "15.4.10.2 WCOL Status Flag\nIf  the  user  writes  the  SSPBUF  when  a  transmit  is already in progress (i.e., SSPSR is still shifting out a data byte), the WCOL is set and the contents of the buffer are unchanged (the write doesn't occur).\nWCOL must be cleared in software.",
    "15.4.10.3 ACKSTAT Status Flag\nIn Transmit mode, the ACKSTAT bit (SSPCON2<6>) is cleared when the slave has sent an Acknowledge (ACK = 0), and is set when the slave does not Acknowledge (ACK = 1). A slave sends an Acknowledge when it has recognized  its  address  (including  a  general  call)  or when the slave has properly received its data.",
    "15.4.11 I 2 C MASTER MODE RECEPTION\nMaster mode reception is enabled by programming the receive enable bit, RCEN (SSPCON2<3>).\nNote:\nIn the MSSP module, the RCEN bit must be  set  after  the  ACK  sequence  or  the RCEN bit will be disregarded.\nThe baud rate generator begins counting, and on each rollover, the state of the SCL pin changes (high to low/ low to high) and data is shifted into the SSPSR. After the falling edge of the eighth clock, the receive enable flag is automatically  cleared,  the  contents  of  the SSPSR are loaded into the SSPBUF, the BF flag bit is set, the SSPIF flag bit is set and the baud rate generator is suspended from counting, holding SCL low. The MSSP is now in IDLE state, awaiting  the  next  command. When the buffer is read by the CPU, the BF flag bit is automatically cleared. The user can then send an Acknowledge bit at the end of reception, by setting the Acknowledge sequence enable bit, ACKEN (SSPCON2<4>).",
    "15.4.11.1 BF Status Flag\nIn receive operation, the BF bit is set when an address or data byte is loaded into SSPBUF from SSPSR. It is cleared when the SSPBUF register is read.",
    "15.4.11.2 SSPOV Status Flag\nIn receive operation, the SSPOV bit is set when 8 bits are  received  into  the  SSPSR  and  the  BF  flag  bit  is already set from a previous reception.",
    "15.4.11.3 WCOL Status Flag\nIf the  user  writes  the  SSPBUF  when  a  receive  is already in progress (i.e., SSPSR is still shifting in a data byte), the WCOL bit is set and the contents of the buffer are unchanged (the write doesn't occur).",
    "15.4.12 ACKNOWLEDGE SEQUENCE TIMING\nAn  Acknowledge  sequence  is  enabled  by  setting  the Acknowledge sequence enable bit, ACKEN (SSPCON2<4>). When this  bit  is  set,  the  SCL  pin  is pulled low and the contents of the Acknowledge data bit are presented on the SDA pin. If the user wishes to generate an Acknowledge, then the ACKDT bit should be cleared. If not, the user should set the ACKDT bit before starting an Acknowledge sequence. The baud rate generator then counts for one rollover period (TBRG) and the SCL pin is de-asserted (pulled high). When the SCL pin is sampled high (clock arbitration), the baud rate generator counts for TBRG. The SCL pin is then pulled low. Following this, the ACKEN bit is automatically cleared, the baud rate generator is turned off and the MSSP module then goes into IDLE mode (Figure 15-23).",
    "15.4.12.1 WCOL Status Flag\nIf  the  user  writes  the  SSPBUF  when  an  Acknowledge sequence is in progress, then WCOL is set and the contents of the buffer are unchanged (the write doesn't occur).",
    "15.4.13 STOP CONDITION TIMING\nA STOP bit is asserted on the SDA pin at the end of a receive/transmit by setting the STOP sequence enable bit, PEN (SSPCON2<2>). At the end of a receive/transmit the SCL line is held low after the falling edge of the ninth clock. When the PEN bit is set, the master will assert the SDA line low. When the SDA line is sampled low,  the  baud  rate  generator  is  reloaded  and  counts down to 0. When the baud rate generator times out, the SCL pin will be brought high, and one TBRG (baud rate generator  rollover  count)  later,  the  SDA  pin  will  be de-asserted. When the SDA pin is sampled high while SCL is high, the P bit (SSPSTAT<4>) is set. A TBRG later,  the PEN bit is cleared and the SSPIF bit is set (Figure 15-24).",
    "15.4.13.1 WCOL Status Flag\nIf the user writes the SSPBUF when a STOP sequence is in progress, then the WCOL bit is set and the contents  of  the  buffer  are  unchanged  (the  write  doesn't occur).",
    "15.4.14 SLEEP OPERATION\nWhile  in  SLEEP  mode,  the  I 2 C  module  can  receive addresses  or  data,  and  when  an  address  match  or complete  byte  transfer  occurs,  wake  the  processor from SLEEP (if the MSSP interrupt is enabled).",
    "15.4.15 EFFECT OF A RESET\nA RESET disables the MSSP module and terminates the current transfer.",
    "15.4.16 MULTI-MASTER MODE\nIn  Multi-Master mode, the interrupt generation on the detection of the START and STOP conditions allows the determination of when the bus is free. The STOP (P) and START (S) bits are cleared from a RESET or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit (SSPSTAT<4>) is set, or the bus is idle with both the S and P bits clear. When the bus is busy, enabling the SSP interrupt will generate the interrupt when the STOP condition occurs.\nIn multi-master operation, the SDA line must be monitored  for  arbitration,  to  see  if  the  signal  level  is  the expected  output  level.  This  check  is  performed  in hardware, with the result placed in the BCLIF bit.\nThe states where arbitration can be lost are:\nGLYPH<129> Address Transfer\nGLYPH<129> Data Transfer\nGLYPH<129> A START Condition\nGLYPH<129> A Repeated START Condition\nGLYPH<129> An Acknowledge Condition",
    "15.4.17 MULTI -MASTER COMMUNICATION, BUS COLLISION, AND BUS ARBITRATION\nMulti-Master mode support is achieved by bus arbitration. When the master outputs address/data bits onto the SDA pin, arbitration takes place when the master outputs  a  '1'  on  SDA,  by  letting  SDA  float  high  and another master asserts a '0'.   When the SCL pin floats high,  data  should  be  stable.  If  the  expected  data  on SDA is a '1' and the data sampled on the SDA pin = '0', then a bus collision has taken place. The master will set the Bus Collision Interrupt Flag BCLIF and reset the I 2 C port to its IDLE state (Figure 15-25).\nIf  a  transmit  was  in  progress  when  the  bus  collision occurred,  the  transmission  is  halted,  the  BF  flag  is cleared, the SDA and SCL lines are de-asserted, and the SSPBUF can be written to. When the user services the bus collision Interrupt Service Routine, and if the I 2 C bus is free, the user can resume communication by asserting a START condition.",
    "15.4.17 MULTI -MASTER COMMUNICATION, BUS COLLISION, AND BUS ARBITRATION\nIf a START, Repeated START, STOP, or Acknowledge condition  was  in  progress  when  the  bus  collision occurred, the condition is aborted, the SDA and SCL lines are de-asserted, and the respective control bits in the SSPCON2 register are cleared. When the user services the bus collision Interrupt Service Routine, and if the I 2 C bus is free, the user can resume communication by asserting a START condition.\nThe master will continue to monitor the SDA and SCL pins. If a STOP condition occurs, the SSPIF bit will be set.\nA write  to  the  SSPBUF  will  start  the  transmission  of data  at  the  first  data  bit,  regardless  of  where  the transmitter left off when the bus collision occurred.\nIn Multi-Master mode, the interrupt generation on the detection of  START and STOP conditions allows the determination of when the bus is free. Control of the I 2 C bus can be taken when the P bit is set in the SSPSTAT register, or the bus is IDLE and the S and P bits are cleared.",
    "15.4.17.1 Bus Collision During a START Condition\nDuring a START condition, a bus collision occurs if:\na) SDA or SCL are sampled low at the beginning of the START condition (Figure 15-26).\nb) SCL is sampled low before SDA is asserted low (Figure 15-27).\nDuring a START condition, both the SDA and the SCL pins are monitored.\nIf the SDA pin is already low, or the SCL pin is already low, then all of the following occur:\nGLYPH<129> the START condition is aborted,\nGLYPH<129> the BCLIF flag is set, and\nGLYPH<129> the MSSP module is reset to its IDLE state (Figure 15-26).\nThe START condition begins with the SDA and SCL pins de-asserted. When the SDA pin is sampled high, the baud rate generator is loaded from SSPADD<6:0> and counts down to 0. If the SCL pin is sampled low while SDA is high, a bus collision occurs, because it is assumed that another master is attempting to drive a data '1' during the START condition.",
    "15.4.17.1 Bus Collision During a START Condition\nIf  the  SDA  pin  is  sampled  low  during  this  count,  the BRG  is  reset  and  the  SDA  line  is  asserted  early (Figure 15-28). If, however, a '1' is sampled on the SDA pin, the SDA pin is asserted low at the end of the BRG count. The baud rate generator is then reloaded and counts down to 0, and during this time, if the SCL pins are sampled as '0', a bus collision does not occur. At the end of the BRG count, the SCL pin is asserted low.\nNote:\nThe reason that bus collision is not a factor during  a  START  condition  is  that  no  two bus masters can assert a START condition at the exact same time.    Therefore, one master will always assert SDA before the other. This condition does not cause a bus collision, because the two masters must be allowed to arbitrate the first address following the START condition. If the address is the  same,  arbitration  must  be  allowed  to continue  into  the  data  portion,  Repeated START or STOP conditions.",
    "15.4.17.2 Bus Collision During a Repeated START Condition\nDuring  a  Repeated  START condition, a  bus  collision occurs if:\na) A low level is sampled on SDA when SCL goes from low level to high level.\nb) SCL goes low before SDA is asserted low, indicating  that  another  master  is  attempting  to transmit a data '1'.\nWhen the user de-asserts SDA and the pin is allowed to  float  high,  the  BRG  is  loaded  with  SSPADD<6:0> and counts down to 0. The SCL pin is then de-asserted, and when sampled high, the SDA pin is sampled.\nIf SDA is low, a bus collision has occurred (i.e., another master is attempting to transmit a data '0', Figure 15-29).  If  SDA  is  sampled  high,  the  BRG  is reloaded and begins counting. If SDA goes from high to low before the BRG times out, no bus collision occurs because no two masters can assert SDA at exactly the same time.",
    "15.4.17.2 Bus Collision During a Repeated START Condition\nIf SCL goes from high to low before the BRG times out and SDA has not already been asserted, a bus collision occurs.  In  this  case,  another  master  is  attempting  to transmit a data '1' during the Repeated  START condition, Figure 15-30.\nIf, at the end of the BRG time-out both SCL and SDA are still high, the SDA pin is driven low and the BRG is reloaded and begins counting. At the end of the count, regardless of the status of the SCL pin, the SCL pin is driven  low  and  the  Repeated  START  condition  is complete.",
    "15.4.17.3 Bus Collision During a STOP Condition\nBus collision occurs during a STOP condition if:\na) After  the  SDA  pin  has  been  de-asserted  and allowed to float high, SDA is sampled low after the BRG has timed out.\nb) After the SCL  pin is de-asserted, SCL  is sampled low before SDA goes high.",
    "PIC18FXX2\nThe  STOP  condition  begins  with  SDA  asserted  low. When SDA is sampled low, the SCL pin is allowed to float. When the pin is sampled high (clock arbitration), the baud rate generator is loaded with SSPADD<6:0> and counts down to 0. After the BRG times out, SDA is sampled. If  SDA is  sampled low, a bus collision has occurred. This is due to another master attempting to drive a data '0' (Figure 15-31). If the SCL pin is sampled low before SDA is allowed to float high, a bus collision occurs. This is another case of another master attempting to drive a data '0' (Figure 15-32).",
    "FIGURE 15-31: BUS COLLISION DURING A STOP CONDITION (CASE 1)\nSDA\nSCL\nBCLIF\nPEN\nP\nSSPIF\nTBRG\nTBRG\nTBRG\nSDA asserted low\nSDA sampled low after TBRG, Set BCLIF\n'0'\n'0'",
    "FIGURE 15-32: BUS COLLISION DURING A STOP CONDITION (CASE 2)\nSDA\nSCL\nBCLIF\nPEN\nP\nSSPIF\nTBRG\nTBRG\nTBRG\nAssert SDA\nSCL goes low before SDA goes high Set BCLIF\n'0'\n'0'",
    "PIC18FXX2\nNOTES:",
    "16.0 ADDRESSABLE UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (USART)\nThe  Universal  Synchronous  Asynchronous  Receiver Transmitter (USART) module is one of the two serial I/O modules. (USART is also known as a Serial Communications Interface or SCI.) The USART can be configured as a full duplex asynchronous system that can communicate with peripheral devices, such as CRT terminals and personal computers, or it can be configured as a half-duplex synchronous system that can communicate  with  peripheral  devices,  such  as  A/D  or  D/A integrated circuits, serial EEPROMs, etc.\nThe USART can be configured in the following modes:\nGLYPH<129> Asynchronous (full-duplex)\nGLYPH<129> Synchronous - Master (half-duplex)\nGLYPH<129> Synchronous - Slave (half-duplex)\nIn order to configure pins RC6/TX/CK and RC7/RX/DT as the Universal Synchronous Asynchronous Receiver Transmitter:",
    "16.0 ADDRESSABLE UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (USART)\nGLYPH<129> bit SPEN (RCSTA<7>) must be set (= 1),\nGLYPH<129> bit TRISC<6> must be cleared (= 0), and\nGLYPH<129> bit TRISC<7> must be set (=1).\nRegister 16-1 shows the Transmit Status and Control Register (TXSTA) and Register 16-2 shows the Receive Status and Control Register (RCSTA).",
    "REGISTER 16-1: TXSTA: TRANSMIT STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = U-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R-1. R/W-0, 7 = R/W-0. CSRC, 1 = TX9. CSRC, 2 = TXEN. CSRC, 3 = SYNC. CSRC, 4 = -. CSRC, 5 = BRGH. CSRC, 6 = TRMT. CSRC, 7 = TX9D\nbit 7\nbit 0",
    "bit 7 CSRC: Clock Source Select bit\nAsynchronous mode:\nDon't care\nSynchronous mode:\n- 1 = Master mode (clock generated internally from BRG)\n0 = Slave mode (clock from external source)",
    "bit 6 TX9 : 9-bit Transmit Enable bit\n1 = Selects 9-bit transmission\n0 = Selects 8-bit transmission",
    "bit 5 TXEN : Transmit Enable bit\n1 = Transmit enabled\n0 = Transmit disabled",
    "bit 4 SYNC : USART Mode Select bit\n1 = Synchronous mode\n0 = Asynchronous mode",
    "bit 2 BRGH : High Baud Rate Select bit\nAsynchronous mode:\n1 = High speed\n0 = Low speed\nSynchronous mode:\nUnused in this mode bit 1 TRMT : Transmit Shift Register Status bit\n1 = TSR empty\n0 = TSR full",
    "bit 0 TX9D: 9th bit of Transmit Data\nCan be Address/Data bit or a parity bit.\nLegend:\nR = Readable bit\n- n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "REGISTER 16-2: RCSTA: RECEIVE STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-x. SPEN, 1 = RX9. SPEN, 2 = SREN. SPEN, 3 = CREN. SPEN, 4 = ADDEN. SPEN, 5 = FERR. SPEN, 6 = OERR. SPEN, 7 = RX9D\nbit 7\nbit 0",
    "bit 7 SPEN:\nSerial Port Enable bit\n1 = Serial port enabled (configures RX/DT and TX/CK pins as serial port pins)\n0 = Serial port disabled",
    "bit 6 RX9 : 9-bit Receive Enable bit\n- 1 = Selects 9-bit reception\n0 = Selects 8-bit reception",
    "bit 5 SREN : Single Receive Enable bit\nAsynchronous mode:\nDon't care\nSynchronous mode - Master:\n1 = Enables single receive\n0 = Disables single receive\nThis bit is cleared after reception is complete.\nSynchronous mode - Slave:\nDon't care",
    "bit 4 CREN : Continuous Receive Enable bit\nAsynchronous mode:\n1 = Enables receiver\n0 = Disables receiver",
    "Synchronous mode:\n1 = Enables continuous receive until enable bit CREN is cleared (CREN overrides SREN)\n0 = Disables continuous receive",
    "bit 3 ADDEN : Address Detect Enable bit\nAsynchronous mode 9-bit (RX9 = 1):\n- 1 = Enables address detection, enable interrupt and load of the receive buffer\nwhen RSR<8> is set\n- 0 = Disables address detection, all bytes are received, and ninth bit can be used as parity bit",
    "bit 2 FERR : Framing Error bit\n1 = Framing error (can be updated by reading RCREG register and receive next valid byte)\n0 = No framing error",
    "bit 1 OERR : Overrun Error bit\n1 = Overrun error (can be cleared by clearing bit CREN)\n0 = No overrun error\nRX9D: 9th bit of Received Data\nThis can be Address/Data bit or a parity bit, and must be calculated by user firmware.\nLegend:\nR = Readable bit\n- n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown bit 0",
    "16.1 USART Baud Rate Generator (BRG)\nThe BRG supports both the Asynchronous and Synchronous modes of the USART. It is a dedicated 8-bit baud rate generator. The SPBRG register controls the period of a free running 8-bit timer. In Asynchronous mode, bit BRGH (TXSTA<2>) also controls the baud rate.  In  Synchronous  mode,  bit  BRGH  is  ignored. Table 16-1  shows the formula for computation of the baud rate for different USART modes, which only apply in Master mode (internal clock).\nGiven the desired baud rate and Fosc, the nearest integer  value  for  the  SPBRG  register  can  be  calculated using the formula in Table 16-1. From this, the error in baud rate can be determined.\nExample 16-1 shows the calculation of the baud rate error for the following conditions:\nGLYPH<129> FOSC = 16 MHz\nGLYPH<129> Desired Baud Rate = 9600\nGLYPH<129> BRGH = 0\nGLYPH<129> SYNC = 0",
    "16.1 USART Baud Rate Generator (BRG)\nIt  may  be  advantageous  to  use  the  high  baud  rate (BRGH  =  1)  even  for  slower  baud  clocks.  This  is because the FOSC/(16(X + 1)) equation can reduce the baud rate error in some cases.\nWriting a new value to the SPBRG register causes the BRG timer to be reset (or cleared). This ensures the BRG  does  not  wait for a timer overflow before outputting the new baud rate.",
    "16.1.1 SAMPLING\nThe data on the RC7/RX/DT pin is sampled three times by a majority detect circuit to determine if a high or a low level is present at the RX pin.",
    "EXAMPLE 16-1: CALCULATING BAUD RATE ERROR\nDesired Baud Rate, 1 = =. Desired Baud Rate, 2 = FOSC / (64 (X + 1)). Solving for X:, 1 = . Solving for X:, 2 = . X, 1 = =. X, 2 = ( (FOSC / Desired Baud Rate) / 64 ) - 1. X, 1 = =. X, 2 = ((16000000 / 9600) / 64) - 1. X, 1 = =. X, 2 = [25.042] = 25. Calculated Baud Rate, 1 = =. Calculated Baud Rate, 2 = 16000000 / (64 (25 + 1)). , 1 = =. , 2 = 9615. Error, 1 = =. Error, 2 = (Calculated Baud Rate - Desired Baud Rate). , 1 = . , 2 = Desired Baud Rate. , 1 = =. , 2 = (9615 - 9600) / 9600. , 1 = =. , 2 = 0.16%",
    "TABLE 16-1: BAUD RATE FORMULA\n0 1, BRGH = 0 (Low Speed) = (Asynchronous) Baud Rate = FOSC/(64(X+1)) (Synchronous) Baud Rate = FOSC/(4(X+1)). 0 1, BRGH = 1 (High Speed) = Baud Rate = FOSC/(16(X+1)) N/A\nLegend: X = value in SPBRG (0 to 255)",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nTXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on All Other RESETS = 0000. TXSTA, Value on All Other RESETS = -010. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on All Other RESETS = 0000. RCSTA,",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nValue on All Other RESETS = -00x. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on All Other RESETS = 0000. SPBRG, Value on All Other RESETS = 0000\nLegend: x = unknown, - = unimplemented, read as '0'. Shaded cells are not used by the BRG.",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n0.3, FOSC = 40 MHz.KBAUD = NA. 0.3, FOSC = 40 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 33 MHz.KBAUD = NA. 0.3, 33 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 25 MHz.KBAUD = NA. 0.3, 25 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 20 MHz.KBAUD = NA. 0.3, 20 MHz.% ERROR = -. 0.3, SPBRG value (decimal).SPBRG value (decimal) = -. 1.2, FOSC = 40 MHz.KBAUD = NA. 1.2, FOSC = 40 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 33 MHz.KBAUD = NA. 1.2, 33 MHz.% ERROR = -.",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n1.2, SPBRG value.(decimal) = -. 1.2, 25 MHz.KBAUD = NA. 1.2, 25 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 20 MHz.KBAUD = NA. 1.2, 20 MHz.% ERROR = -. 1.2, SPBRG value (decimal).SPBRG value (decimal) = -. 2.4, FOSC = 40 MHz.KBAUD = NA. 2.4, FOSC = 40 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 33 MHz.KBAUD = NA. 2.4, 33 MHz.% ERROR = -. 2.4, SPBRG value.(decimal) = -. 2.4, 25 MHz.KBAUD = NA. 2.4, 25 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 20 MHz.KBAUD = NA. 2.4, 20",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\nMHz.% ERROR = -. 2.4, SPBRG value (decimal).SPBRG value (decimal) = -. 9.6, FOSC = 40 MHz.KBAUD = NA. 9.6, FOSC = 40 MHz.% ERROR = -. 9.6, SPBRG value (decimal). = -. 9.6, 33 MHz.KBAUD = NA. 9.6, 33 MHz.% ERROR = -. 9.6, SPBRG value.(decimal) = -. 9.6, 25 MHz.KBAUD = NA. 9.6, 25 MHz.% ERROR = -. 9.6, SPBRG value (decimal). = -. 9.6, 20 MHz.KBAUD = NA. 9.6, 20 MHz.% ERROR = -. 9.6, SPBRG value (decimal).SPBRG value (decimal) = -. 19.2, FOSC = 40 MHz.KBAUD = NA. 19.2, FOSC = 40 MHz.% ERROR = -. 19.2, SPBRG value",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n(decimal). = -. 19.2, 33 MHz.KBAUD = NA. 19.2, 33 MHz.% ERROR = -. 19.2, SPBRG value.(decimal) = -. 19.2, 25 MHz.KBAUD = NA. 19.2, 25 MHz.% ERROR = -. 19.2, SPBRG value (decimal). = -. 19.2, 20 MHz.KBAUD = NA. 19.2, 20 MHz.% ERROR = -. 19.2, SPBRG value (decimal).SPBRG value (decimal) = -. 76.8, FOSC = 40 MHz.KBAUD = 76.92. 76.8, FOSC = 40 MHz.% ERROR = +0.16. 76.8, SPBRG value (decimal). = 129. 76.8, 33 MHz.KBAUD = 77.10. 76.8, 33 MHz.% ERROR = +0.39. 76.8, SPBRG value.(decimal) = 106. 76.8, 25 MHz.KBAUD = 77.16.",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n76.8, 25 MHz.% ERROR = +0.47. 76.8, SPBRG value (decimal). = 80. 76.8, 20 MHz.KBAUD = 76.92. 76.8, 20 MHz.% ERROR = +0.16. 76.8, SPBRG value (decimal).SPBRG value (decimal) = 64. 96, FOSC = 40 MHz.KBAUD = 96.15. 96, FOSC = 40 MHz.% ERROR = +0.16. 96, SPBRG value (decimal). = 103. 96, 33 MHz.KBAUD = 95.93. 96, 33 MHz.% ERROR = -0.07. 96, SPBRG value.(decimal) = 85. 96, 25 MHz.KBAUD = 96.15. 96, 25 MHz.% ERROR = +0.16. 96, SPBRG value (decimal). = 64. 96, 20 MHz.KBAUD = 96.15. 96, 20 MHz.% ERROR = +0.16. 96, SPBRG value (decimal).SPBRG value",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n(decimal) = 51. 300, FOSC = 40 MHz.KBAUD = 303.03. 300, FOSC = 40 MHz.% ERROR = +1.01. 300, SPBRG value (decimal). = 32. 300, 33 MHz.KBAUD = 294.64. 300, 33 MHz.% ERROR = -1.79. 300, SPBRG value.(decimal) = 27. 300, 25 MHz.KBAUD = 297.62. 300, 25 MHz.% ERROR = -0.79. 300, SPBRG value (decimal). = 20. 300, 20 MHz.KBAUD = 294.12. 300, 20 MHz.% ERROR = -1.96. 300, SPBRG value (decimal).SPBRG value (decimal) = 16. 500, FOSC = 40 MHz.KBAUD = 500. 500, FOSC = 40 MHz.% ERROR = 0. 500, SPBRG value (decimal). = 19. 500, 33 MHz.KBAUD = 485.30. 500, 33 MHz.% ERROR = -2.94. 500,",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\nSPBRG value.(decimal) = 16. 500, 25 MHz.KBAUD = 480.77. 500, 25 MHz.% ERROR = -3.85. 500, SPBRG value (decimal). = 12. 500, 20 MHz.KBAUD = 500. 500, 20 MHz.% ERROR = 0. 500, SPBRG value (decimal).SPBRG value (decimal) = 9. HIGH, FOSC = 40 MHz.KBAUD = 10000. HIGH, FOSC = 40 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 33 MHz.KBAUD = 8250. HIGH, 33 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 25 MHz.KBAUD = 6250. HIGH, 25 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 20 MHz.KBAUD = 5000. HIGH, 20 MHz.% ERROR = -. HIGH, SPBRG value (decimal).SPBRG value (decimal) = 0. LOW,",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\nFOSC = 40 MHz.KBAUD = 39.06. LOW, FOSC = 40 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 33 MHz.KBAUD = 32.23. LOW, 33 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 25 MHz.KBAUD = 24.41. LOW, 25 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 20 MHz.KBAUD = 19.53. LOW, 20 MHz.% ERROR = -. LOW, SPBRG value (decimal).SPBRG value (decimal) = 255",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n0.3, FOSC = 16 MHz.KBAUD = NA. 0.3, FOSC = 16 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 10 MHz.KBAUD = NA. 0.3, 10 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 7.15909 MHz.KBAUD = NA. 0.3, 7.15909 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 5.0688 MHz.KBAUD = NA. 0.3, 5.0688 MHz.% ERROR = -. 0.3, SPBRG value (decimal).SPBRG value (decimal) = -. 1.2, FOSC = 16 MHz.KBAUD = NA. 1.2, FOSC = 16 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 10",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\nMHz.KBAUD = NA. 1.2, 10 MHz.% ERROR = -. 1.2, SPBRG value.(decimal) = -. 1.2, 7.15909 MHz.KBAUD = NA. 1.2, 7.15909 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 5.0688 MHz.KBAUD = NA. 1.2, 5.0688 MHz.% ERROR = -. 1.2, SPBRG value (decimal).SPBRG value (decimal) = -. 2.4, FOSC = 16 MHz.KBAUD = NA. 2.4, FOSC = 16 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 10 MHz.KBAUD = NA. 2.4, 10 MHz.% ERROR = -. 2.4, SPBRG value.(decimal) = -. 2.4, 7.15909 MHz.KBAUD = NA. 2.4,",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n7.15909 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 5.0688 MHz.KBAUD = NA. 2.4, 5.0688 MHz.% ERROR = -. 2.4, SPBRG value (decimal).SPBRG value (decimal) = -. 9.6, FOSC = 16 MHz.KBAUD = NA. 9.6, FOSC = 16 MHz.% ERROR = -. 9.6, SPBRG value (decimal). = -. 9.6, 10 MHz.KBAUD = NA. 9.6, 10 MHz.% ERROR = -. 9.6, SPBRG value.(decimal) = -. 9.6, 7.15909 MHz.KBAUD = 9.62. 9.6, 7.15909 MHz.% ERROR = +0.23. 9.6, SPBRG value (decimal). = 185. 9.6, 5.0688 MHz.KBAUD = 9.60. 9.6,",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n5.0688 MHz.% ERROR = 0. 9.6, SPBRG value (decimal).SPBRG value (decimal) = 131. 19.2, FOSC = 16 MHz.KBAUD = 19.23. 19.2, FOSC = 16 MHz.% ERROR = +0.16. 19.2, SPBRG value (decimal). = 207. 19.2, 10 MHz.KBAUD = 19.23. 19.2, 10 MHz.% ERROR = +0.16. 19.2, SPBRG value.(decimal) = 129. 19.2, 7.15909 MHz.KBAUD = 19.24. 19.2, 7.15909 MHz.% ERROR = +0.23. 19.2, SPBRG value (decimal). = 92. 19.2, 5.0688 MHz.KBAUD = 19.20. 19.2, 5.0688 MHz.% ERROR = 0. 19.2, SPBRG value (decimal).SPBRG value (decimal) = 65. 76.8,",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\nFOSC = 16 MHz.KBAUD = 76.92. 76.8, FOSC = 16 MHz.% ERROR = +0.16. 76.8, SPBRG value (decimal). = 51. 76.8, 10 MHz.KBAUD = 75.76. 76.8, 10 MHz.% ERROR = -1.36. 76.8, SPBRG value.(decimal) = 32. 76.8, 7.15909 MHz.KBAUD = 77.82. 76.8, 7.15909 MHz.% ERROR = +1.32. 76.8, SPBRG value (decimal). = 22. 76.8, 5.0688 MHz.KBAUD = 74.54. 76.8, 5.0688 MHz.% ERROR = -2.94. 76.8, SPBRG value (decimal).SPBRG value (decimal) = 16. 96, FOSC = 16 MHz.KBAUD = 95.24. 96, FOSC = 16 MHz.% ERROR = -0.79. 96, SPBRG value",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n(decimal). = 41. 96, 10 MHz.KBAUD = 96.15. 96, 10 MHz.% ERROR = +0.16. 96, SPBRG value.(decimal) = 25. 96, 7.15909 MHz.KBAUD = 94.20. 96, 7.15909 MHz.% ERROR = -1.88. 96, SPBRG value (decimal). = 18. 96, 5.0688 MHz.KBAUD = 97.48. 96, 5.0688 MHz.% ERROR = +1.54. 96, SPBRG value (decimal).SPBRG value (decimal) = 12. 300, FOSC = 16 MHz.KBAUD = 307.70. 300, FOSC = 16 MHz.% ERROR = +2.56. 300, SPBRG value (decimal). = 12. 300, 10 MHz.KBAUD = 312.50. 300, 10 MHz.% ERROR = +4.17. 300, SPBRG value.(decimal) = 7. 300, 7.15909 MHz.KBAUD =",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n298.35. 300, 7.15909 MHz.% ERROR = -0.57. 300, SPBRG value (decimal). = 5. 300, 5.0688 MHz.KBAUD = 316.80. 300, 5.0688 MHz.% ERROR = +5.60. 300, SPBRG value (decimal).SPBRG value (decimal) = 3. 500, FOSC = 16 MHz.KBAUD = 500. 500, FOSC = 16 MHz.% ERROR = 0. 500, SPBRG value (decimal). = 7. 500, 10 MHz.KBAUD = 500. 500, 10 MHz.% ERROR = 0. 500, SPBRG value.(decimal) = 4. 500, 7.15909 MHz.KBAUD = 447.44. 500, 7.15909 MHz.% ERROR = -10.51. 500, SPBRG value (decimal). = 3. 500, 5.0688 MHz.KBAUD = 422.40. 500, 5.0688 MHz.% ERROR = -15.52.",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n500, SPBRG value (decimal).SPBRG value (decimal) = 2. HIGH, FOSC = 16 MHz.KBAUD = 4000. HIGH, FOSC = 16 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 10 MHz.KBAUD = 2500. HIGH, 10 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 7.15909 MHz.KBAUD = 1789.80. HIGH, 7.15909 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 5.0688 MHz.KBAUD = 1267.20. HIGH, 5.0688 MHz.% ERROR = -. HIGH, SPBRG value (decimal).SPBRG value (decimal) = 0. LOW, FOSC = 16 MHz.KBAUD = 15.63. LOW, FOSC = 16 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 10 MHz.KBAUD =",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n9.77. LOW, 10 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 7.15909 MHz.KBAUD = 6.99. LOW, 7.15909 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 5.0688 MHz.KBAUD = 4.95. LOW, 5.0688 MHz.% ERROR = -. LOW, SPBRG value (decimal).SPBRG value (decimal) = 255",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n0.3, FOSC = 4 MHz.KBAUD = NA. 0.3, FOSC = 4 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 3.579545 MHz.KBAUD = NA. 0.3, 3.579545 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 1 MHz.KBAUD = NA. 0.3, 1 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 32.768 kHz.KBAUD = 0.30. 0.3, 32.768 kHz.% ERROR = +1.14. 0.3, SPBRG value (decimal).SPBRG value (decimal) = 26. 1.2, FOSC = 4 MHz.KBAUD = NA. 1.2, FOSC = 4 MHz.% ERROR = -. 1.2, SPBRG value.(decimal) = -.",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n1.2, 3.579545 MHz.KBAUD = NA. 1.2, 3.579545 MHz.% ERROR = -. 1.2, SPBRG value.(decimal) = -. 1.2, 1 MHz.KBAUD = 1.20. 1.2, 1 MHz.% ERROR = +0.16. 1.2, SPBRG value (decimal). = 207. 1.2, 32.768 kHz.KBAUD = 1.17. 1.2, 32.768 kHz.% ERROR = -2.48. 1.2, SPBRG value (decimal).SPBRG value (decimal) = 6. 2.4, FOSC = 4 MHz.KBAUD = NA. 2.4, FOSC = 4 MHz.% ERROR = -. 2.4, SPBRG value.(decimal) = -. 2.4, 3.579545 MHz.KBAUD = NA. 2.4, 3.579545 MHz.% ERROR = -. 2.4, SPBRG",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\nvalue.(decimal) = -. 2.4, 1 MHz.KBAUD = 2.40. 2.4, 1 MHz.% ERROR = +0.16. 2.4, SPBRG value (decimal). = 103. 2.4, 32.768 kHz.KBAUD = 2.73. 2.4, 32.768 kHz.% ERROR = +13.78. 2.4, SPBRG value (decimal).SPBRG value (decimal) = 2. 9.6, FOSC = 4 MHz.KBAUD = 9.62. 9.6, FOSC = 4 MHz.% ERROR = +0.16. 9.6, SPBRG value.(decimal) = 103. 9.6, 3.579545 MHz.KBAUD = 9.62. 9.6, 3.579545 MHz.% ERROR = +0.23. 9.6, SPBRG value.(decimal) = 92. 9.6, 1 MHz.KBAUD = 9.62. 9.6, 1 MHz.% ERROR =",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n+0.16. 9.6, SPBRG value (decimal). = 25. 9.6, 32.768 kHz.KBAUD = 8.20. 9.6, 32.768 kHz.% ERROR = -14.67. 9.6, SPBRG value (decimal).SPBRG value (decimal) = 0. 19.2, FOSC = 4 MHz.KBAUD = 19.23. 19.2, FOSC = 4 MHz.% ERROR = +0.16. 19.2, SPBRG value.(decimal) = 51. 19.2, 3.579545 MHz.KBAUD = 19.04. 19.2, 3.579545 MHz.% ERROR = -0.83. 19.2, SPBRG value.(decimal) = 46. 19.2, 1 MHz.KBAUD = 19.23. 19.2, 1 MHz.% ERROR = +0.16. 19.2, SPBRG value (decimal). = 12. 19.2, 32.768 kHz.KBAUD = NA.",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n19.2, 32.768 kHz.% ERROR = -. 19.2, SPBRG value (decimal).SPBRG value (decimal) = -. 76.8, FOSC = 4 MHz.KBAUD = 76.92. 76.8, FOSC = 4 MHz.% ERROR = +0.16. 76.8, SPBRG value.(decimal) = 12. 76.8, 3.579545 MHz.KBAUD = 74.57. 76.8, 3.579545 MHz.% ERROR = -2.90. 76.8, SPBRG value.(decimal) = 11. 76.8, 1 MHz.KBAUD = 83.33. 76.8, 1 MHz.% ERROR = +8.51. 76.8, SPBRG value (decimal). = 2. 76.8, 32.768 kHz.KBAUD = NA. 76.8, 32.768 kHz.% ERROR = -. 76.8, SPBRG value (decimal).SPBRG value (decimal) = -. 96,",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\nFOSC = 4 MHz.KBAUD = 1000. 96, FOSC = 4 MHz.% ERROR = +4.17. 96, SPBRG value.(decimal) = 9. 96, 3.579545 MHz.KBAUD = 99.43. 96, 3.579545 MHz.% ERROR = +3.57. 96, SPBRG value.(decimal) = 8. 96, 1 MHz.KBAUD = 83.33. 96, 1 MHz.% ERROR = -13.19. 96, SPBRG value (decimal). = 2. 96, 32.768 kHz.KBAUD = NA. 96, 32.768 kHz.% ERROR = -. 96, SPBRG value (decimal).SPBRG value (decimal) = -. 300, FOSC = 4 MHz.KBAUD = 333.33. 300, FOSC = 4 MHz.% ERROR = +11.11. 300, SPBRG value.(decimal) = 2. 300, 3.579545 MHz.KBAUD = 298.30. 300,",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\n3.579545 MHz.% ERROR = -0.57. 300, SPBRG value.(decimal) = 2. 300, 1 MHz.KBAUD = 250. 300, 1 MHz.% ERROR = -16.67. 300, SPBRG value (decimal). = 0. 300, 32.768 kHz.KBAUD = NA. 300, 32.768 kHz.% ERROR = -. 300, SPBRG value (decimal).SPBRG value (decimal) = -. 500, FOSC = 4 MHz.KBAUD = 500. 500, FOSC = 4 MHz.% ERROR = 0. 500, SPBRG value.(decimal) = 1. 500, 3.579545 MHz.KBAUD = 447.44. 500, 3.579545 MHz.% ERROR = -10.51. 500, SPBRG value.(decimal) = 1. 500, 1 MHz.KBAUD = NA. 500, 1 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500, 32.768",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\nkHz.KBAUD = NA. 500, 32.768 kHz.% ERROR = -. 500, SPBRG value (decimal).SPBRG value (decimal) = -. HIGH, FOSC = 4 MHz.KBAUD = 1000. HIGH, FOSC = 4 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 3.579545 MHz.KBAUD = 894.89. HIGH, 3.579545 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 1 MHz.KBAUD = 250. HIGH, 1 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 32.768 kHz.KBAUD = 8.20. HIGH, 32.768 kHz.% ERROR = -. HIGH, SPBRG value (decimal).SPBRG value (decimal) = 0. LOW, FOSC = 4 MHz.KBAUD = 3.91. LOW, FOSC = 4 MHz.% ERROR = -. LOW,",
    "TABLE 16-3: BAUD RATES FOR SYNCHRONOUS MODE\nSPBRG value.(decimal) = 255. LOW, 3.579545 MHz.KBAUD = 3.50. LOW, 3.579545 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 1 MHz.KBAUD = 0.98. LOW, 1 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 32.768 kHz.KBAUD = 0.03. LOW, 32.768 kHz.% ERROR = -. LOW, SPBRG value (decimal).SPBRG value (decimal) = 255",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n0.3, FOSC = 40 MHz.KBAUD = NA. 0.3, FOSC = 40 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 33 MHz.KBAUD = NA. 0.3, 33 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 25 MHz.KBAUD = NA. 0.3, 25 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 20 MHz.KBAUD = NA. 0.3, 20 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 1.2, FOSC = 40 MHz.KBAUD = NA. 1.2, FOSC = 40 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 33 MHz.KBAUD = NA. 1.2, 33 MHz.% ERROR = -.",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n1.2, SPBRG value.(decimal) = -. 1.2, 25 MHz.KBAUD = NA. 1.2, 25 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 20 MHz.KBAUD = NA. 1.2, 20 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 2.4, FOSC = 40 MHz.KBAUD = NA. 2.4, FOSC = 40 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 33 MHz.KBAUD = 2.40. 2.4, 33 MHz.% ERROR = -0.07. 2.4, SPBRG value.(decimal) = 214. 2.4, 25 MHz.KBAUD = 2.40. 2.4, 25 MHz.% ERROR = -0.15. 2.4, SPBRG value (decimal). = 162. 2.4, 20",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nMHz.KBAUD = 2.40. 2.4, 20 MHz.% ERROR = +0.16. 2.4, SPBRG value (decimal). = 129. 9.6, FOSC = 40 MHz.KBAUD = 9.62. 9.6, FOSC = 40 MHz.% ERROR = +0.16. 9.6, SPBRG value (decimal). = 64. 9.6, 33 MHz.KBAUD = 9.55. 9.6, 33 MHz.% ERROR = -0.54. 9.6, SPBRG value.(decimal) = 53. 9.6, 25 MHz.KBAUD = 9.53. 9.6, 25 MHz.% ERROR = -0.76. 9.6, SPBRG value (decimal). = 40. 9.6, 20 MHz.KBAUD = 9.47. 9.6, 20 MHz.% ERROR = -1.36. 9.6, SPBRG value (decimal). = 32. 19.2, FOSC = 40",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nMHz.KBAUD = 18.94. 19.2, FOSC = 40 MHz.% ERROR = -1.36. 19.2, SPBRG value (decimal). = 32. 19.2, 33 MHz.KBAUD = 19.10. 19.2, 33 MHz.% ERROR = -0.54. 19.2, SPBRG value.(decimal) = 26. 19.2, 25 MHz.KBAUD = 19.53. 19.2, 25 MHz.% ERROR = +1.73. 19.2, SPBRG value (decimal). = 19. 19.2, 20 MHz.KBAUD = 19.53. 19.2, 20 MHz.% ERROR = +1.73. 19.2, SPBRG value (decimal). = 15. 76.8, FOSC = 40 MHz.KBAUD = 78.13. 76.8, FOSC = 40 MHz.% ERROR = +1.73. 76.8, SPBRG value (decimal). = 7. 76.8, 33",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nMHz.KBAUD = 73.66. 76.8, 33 MHz.% ERROR = -4.09. 76.8, SPBRG value.(decimal) = 6. 76.8, 25 MHz.KBAUD = 78.13. 76.8, 25 MHz.% ERROR = +1.73. 76.8, SPBRG value (decimal). = 4. 76.8, 20 MHz.KBAUD = 78.13. 76.8, 20 MHz.% ERROR = +1.73. 76.8, SPBRG value (decimal). = 3. 96, FOSC = 40 MHz.KBAUD = 89.29. 96, FOSC = 40 MHz.% ERROR = -6.99. 96, SPBRG value (decimal). = 6. 96, 33 MHz.KBAUD = 103.13. 96, 33 MHz.% ERROR = +7.42. 96, SPBRG value.(decimal) = 4. 96, 25 MHz.KBAUD = 97.66. 96, 25 MHz.% ERROR =",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n+1.73. 96, SPBRG value (decimal). = 3. 96, 20 MHz.KBAUD = 104.17. 96, 20 MHz.% ERROR = +8.51. 96, SPBRG value (decimal). = 2. 300, FOSC = 40 MHz.KBAUD = 312.50. 300, FOSC = 40 MHz.% ERROR = +4.17. 300, SPBRG value (decimal). = 1. 300, 33 MHz.KBAUD = 257.81. 300, 33 MHz.% ERROR = -14.06. 300, SPBRG value.(decimal) = 1. 300, 25 MHz.KBAUD = NA. 300, 25 MHz.% ERROR = -. 300, SPBRG value (decimal). = -. 300, 20 MHz.KBAUD = 312.50. 300, 20 MHz.% ERROR = +4.17. 300, SPBRG value (decimal). = 0. 500, FOSC = 40 MHz.KBAUD = 625. 500, FOSC = 40 MHz.%",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nERROR = +25.00. 500, SPBRG value (decimal). = 0. 500, 33 MHz.KBAUD = NA. 500, 33 MHz.% ERROR = -. 500, SPBRG value.(decimal) = -. 500, 25 MHz.KBAUD = NA. 500, 25 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500, 20 MHz.KBAUD = NA. 500, 20 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. HIGH, FOSC = 40 MHz.KBAUD = 625. HIGH, FOSC = 40 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 33 MHz.KBAUD = 515.63. HIGH, 33 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 25 MHz.KBAUD = 390.63. HIGH, 25 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 20",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nMHz.KBAUD = 312.50. HIGH, 20 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. LOW, FOSC = 40 MHz.KBAUD = 2.44. LOW, FOSC = 40 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 33 MHz.KBAUD = 2.01. LOW, 33 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 25 MHz.KBAUD = 1.53. LOW, 25 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 20 MHz.KBAUD = 1.22. LOW, 20 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n0.3, FOSC = 16 MHz.KBAUD = NA. 0.3, FOSC = 16 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 10 MHz.KBAUD = NA. 0.3, 10 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 7.15909 MHz.KBAUD = NA. 0.3, 7.15909 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 5.0688 MHz.KBAUD = NA. 0.3, 5.0688 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 1.2, FOSC = 16 MHz.KBAUD = 1.20. 1.2, FOSC = 16 MHz.% ERROR = +0.16. 1.2, SPBRG value (decimal). = 207.",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n1.2, 10 MHz.KBAUD = 1.20. 1.2, 10 MHz.% ERROR = +0.16. 1.2, SPBRG value.(decimal) = 129. 1.2, 7.15909 MHz.KBAUD = 1.20. 1.2, 7.15909 MHz.% ERROR = +0.23. 1.2, SPBRG value (decimal). = 92. 1.2, 5.0688 MHz.KBAUD = 1.20. 1.2, 5.0688 MHz.% ERROR = 0. 1.2, SPBRG value.(decimal) = 65. 2.4, FOSC = 16 MHz.KBAUD = 2.40. 2.4, FOSC = 16 MHz.% ERROR = +0.16. 2.4, SPBRG value (decimal). = 103. 2.4, 10 MHz.KBAUD = 2.40. 2.4, 10 MHz.% ERROR = +0.16. 2.4, SPBRG",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nvalue.(decimal) = 64. 2.4, 7.15909 MHz.KBAUD = 2.38. 2.4, 7.15909 MHz.% ERROR = -0.83. 2.4, SPBRG value (decimal). = 46. 2.4, 5.0688 MHz.KBAUD = 2.40. 2.4, 5.0688 MHz.% ERROR = 0. 2.4, SPBRG value.(decimal) = 32. 9.6, FOSC = 16 MHz.KBAUD = 9.62. 9.6, FOSC = 16 MHz.% ERROR = +0.16. 9.6, SPBRG value (decimal). = 25. 9.6, 10 MHz.KBAUD = 9.77. 9.6, 10 MHz.% ERROR = +1.73. 9.6, SPBRG value.(decimal) = 15. 9.6, 7.15909 MHz.KBAUD = 9.32. 9.6, 7.15909 MHz.%",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nERROR = -2.90. 9.6, SPBRG value (decimal). = 11. 9.6, 5.0688 MHz.KBAUD = 9.90. 9.6, 5.0688 MHz.% ERROR = +3.13. 9.6, SPBRG value.(decimal) = 7. 19.2, FOSC = 16 MHz.KBAUD = 19.23. 19.2, FOSC = 16 MHz.% ERROR = +0.16. 19.2, SPBRG value (decimal). = 12. 19.2, 10 MHz.KBAUD = 19.53. 19.2, 10 MHz.% ERROR = +1.73. 19.2, SPBRG value.(decimal) = 7. 19.2, 7.15909 MHz.KBAUD = 18.64. 19.2, 7.15909 MHz.% ERROR = -2.90. 19.2, SPBRG value (decimal). = 5. 19.2, 5.0688 MHz.KBAUD",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n= 19.80. 19.2, 5.0688 MHz.% ERROR = +3.13. 19.2, SPBRG value.(decimal) = 3. 76.8, FOSC = 16 MHz.KBAUD = 83.33. 76.8, FOSC = 16 MHz.% ERROR = +8.51. 76.8, SPBRG value (decimal). = 2. 76.8, 10 MHz.KBAUD = 78.13. 76.8, 10 MHz.% ERROR = +1.73. 76.8, SPBRG value.(decimal) = 1. 76.8, 7.15909 MHz.KBAUD = 111.86. 76.8, 7.15909 MHz.% ERROR = +45.65. 76.8, SPBRG value (decimal). = 0. 76.8, 5.0688 MHz.KBAUD = 79.20. 76.8, 5.0688 MHz.% ERROR = +3.13. 76.8, SPBRG",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nvalue.(decimal) = 0. 96, FOSC = 16 MHz.KBAUD = 83.33. 96, FOSC = 16 MHz.% ERROR = -13.19. 96, SPBRG value (decimal). = 2. 96, 10 MHz.KBAUD = 78.13. 96, 10 MHz.% ERROR = -18.62. 96, SPBRG value.(decimal) = 1. 96, 7.15909 MHz.KBAUD = NA. 96, 7.15909 MHz.% ERROR = -. 96, SPBRG value (decimal). = -. 96, 5.0688 MHz.KBAUD = NA. 96, 5.0688 MHz.% ERROR = -. 96, SPBRG value.(decimal) = -. 300, FOSC = 16 MHz.KBAUD = 250. 300, FOSC = 16 MHz.% ERROR = -16.67. 300, SPBRG value (decimal). = 0. 300, 10 MHz.KBAUD = 156.25. 300, 10",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nMHz.% ERROR = -47.92. 300, SPBRG value.(decimal) = 0. 300, 7.15909 MHz.KBAUD = NA. 300, 7.15909 MHz.% ERROR = -. 300, SPBRG value (decimal). = -. 300, 5.0688 MHz.KBAUD = NA. 300, 5.0688 MHz.% ERROR = -. 300, SPBRG value.(decimal) = -. 500, FOSC = 16 MHz.KBAUD = NA. 500, FOSC = 16 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500, 10 MHz.KBAUD = NA. 500, 10 MHz.% ERROR = -. 500, SPBRG value.(decimal) = -. 500, 7.15909 MHz.KBAUD = NA. 500, 7.15909 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500, 5.0688 MHz.KBAUD = NA.",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n500, 5.0688 MHz.% ERROR = -. 500, SPBRG value.(decimal) = -. HIGH, FOSC = 16 MHz.KBAUD = 250. HIGH, FOSC = 16 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 10 MHz.KBAUD = 156.25. HIGH, 10 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 7.15909 MHz.KBAUD = 111.86. HIGH, 7.15909 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 5.0688 MHz.KBAUD = 79.20. HIGH, 5.0688 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. LOW, FOSC = 16 MHz.KBAUD = 0.98. LOW, FOSC = 16 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 10",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nMHz.KBAUD = 0.61. LOW, 10 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 7.15909 MHz.KBAUD = 0.44. LOW, 7.15909 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 5.0688 MHz.KBAUD = 0.31. LOW, 5.0688 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n0.3, FOSC = 4 MHz.KBAUD = 0.30. 0.3, FOSC = 4 MHz.% ERROR = -0.16. 0.3, SPBRG value (decimal). = 207. 0.3, 3.579545 MHz.KBAUD = 0.30. 0.3, 3.579545 MHz.% ERROR = +0.23. 0.3, SPBRG.value (decimal) = 185. 0.3, 1 MHz.KBAUD = 0.30. 0.3, 1 MHz.% ERROR = +0.16. 0.3, SPBRG value (decimal). = 51. 0.3, 32.768 kHz.KBAUD = 0.26. 0.3, 32.768 kHz.% ERROR = -14.67. 0.3, SPBRG value (decimal).SPBRG value (decimal) = 1. 1.2, FOSC = 4 MHz.KBAUD = 1.20. 1.2, FOSC = 4",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nMHz.% ERROR = +1.67. 1.2, SPBRG value (decimal). = 51. 1.2, 3.579545 MHz.KBAUD = 1.19. 1.2, 3.579545 MHz.% ERROR = -0.83. 1.2, SPBRG.value (decimal) = 46. 1.2, 1 MHz.KBAUD = 1.20. 1.2, 1 MHz.% ERROR = +0.16. 1.2, SPBRG value (decimal). = 12. 1.2, 32.768 kHz.KBAUD = NA. 1.2, 32.768 kHz.% ERROR = -. 1.2, SPBRG value (decimal).SPBRG value (decimal) = -. 2.4, FOSC = 4 MHz.KBAUD = 2.40. 2.4, FOSC = 4 MHz.% ERROR = +1.67. 2.4, SPBRG value (decimal). = 25. 2.4,",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n3.579545 MHz.KBAUD = 2.43. 2.4, 3.579545 MHz.% ERROR = +1.32. 2.4, SPBRG.value (decimal) = 22. 2.4, 1 MHz.KBAUD = 2.23. 2.4, 1 MHz.% ERROR = -6.99. 2.4, SPBRG value (decimal). = 6. 2.4, 32.768 kHz.KBAUD = NA. 2.4, 32.768 kHz.% ERROR = -. 2.4, SPBRG value (decimal).SPBRG value (decimal) = -. 9.6, FOSC = 4 MHz.KBAUD = 8.93. 9.6, FOSC = 4 MHz.% ERROR = -6.99. 9.6, SPBRG value (decimal). = 6. 9.6, 3.579545 MHz.KBAUD = 9.32. 9.6, 3.579545 MHz.% ERROR =",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n-2.90. 9.6, SPBRG.value (decimal) = 5. 9.6, 1 MHz.KBAUD = 7.81. 9.6, 1 MHz.% ERROR = -18.62. 9.6, SPBRG value (decimal). = 1. 9.6, 32.768 kHz.KBAUD = NA. 9.6, 32.768 kHz.% ERROR = -. 9.6, SPBRG value (decimal).SPBRG value (decimal) = -. 19.2, FOSC = 4 MHz.KBAUD = 20.83. 19.2, FOSC = 4 MHz.% ERROR = +8.51. 19.2, SPBRG value (decimal). = 2. 19.2, 3.579545 MHz.KBAUD = 18.64. 19.2, 3.579545 MHz.% ERROR = -2.90. 19.2, SPBRG.value (decimal) = 2. 19.2, 1 MHz.KBAUD =",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n15.63. 19.2, 1 MHz.% ERROR = -18.62. 19.2, SPBRG value (decimal). = 0. 19.2, 32.768 kHz.KBAUD = NA. 19.2, 32.768 kHz.% ERROR = -. 19.2, SPBRG value (decimal).SPBRG value (decimal) = -. 76.8, FOSC = 4 MHz.KBAUD = 62.50. 76.8, FOSC = 4 MHz.% ERROR = -18.62. 76.8, SPBRG value (decimal). = 0. 76.8, 3.579545 MHz.KBAUD = 55.93. 76.8, 3.579545 MHz.% ERROR = -27.17. 76.8, SPBRG.value (decimal) = 0. 76.8, 1 MHz.KBAUD = NA. 76.8, 1 MHz.% ERROR = -. 76.8, SPBRG value (decimal). = -. 76.8,",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n32.768 kHz.KBAUD = NA. 76.8, 32.768 kHz.% ERROR = -. 76.8, SPBRG value (decimal).SPBRG value (decimal) = -. 96, FOSC = 4 MHz.KBAUD = NA. 96, FOSC = 4 MHz.% ERROR = -. 96, SPBRG value (decimal). = -. 96, 3.579545 MHz.KBAUD = NA. 96, 3.579545 MHz.% ERROR = -. 96, SPBRG.value (decimal) = -. 96, 1 MHz.KBAUD = NA. 96, 1 MHz.% ERROR = -. 96, SPBRG value (decimal). = -. 96, 32.768 kHz.KBAUD = NA. 96, 32.768 kHz.% ERROR = -. 96, SPBRG value (decimal).SPBRG value (decimal) = -. 300, FOSC = 4 MHz.KBAUD = NA. 300, FOSC = 4 MHz.%",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\nERROR = -. 300, SPBRG value (decimal). = -. 300, 3.579545 MHz.KBAUD = NA. 300, 3.579545 MHz.% ERROR = -. 300, SPBRG.value (decimal) = -. 300, 1 MHz.KBAUD = NA. 300, 1 MHz.% ERROR = -. 300, SPBRG value (decimal). = -. 300, 32.768 kHz.KBAUD = NA. 300, 32.768 kHz.% ERROR = -. 300, SPBRG value (decimal).SPBRG value (decimal) = -. 500, FOSC = 4 MHz.KBAUD = NA. 500, FOSC = 4 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500, 3.579545 MHz.KBAUD = NA. 500, 3.579545 MHz.% ERROR = -. 500, SPBRG.value (decimal) = -. 500, 1 MHz.KBAUD = NA. 500,",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n1 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500, 32.768 kHz.KBAUD = NA. 500, 32.768 kHz.% ERROR = -. 500, SPBRG value (decimal).SPBRG value (decimal) = -. HIGH, FOSC = 4 MHz.KBAUD = 62.50. HIGH, FOSC = 4 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 3.579545 MHz.KBAUD = 55.93. HIGH, 3.579545 MHz.% ERROR = -. HIGH, SPBRG.value (decimal) = 0. HIGH, 1 MHz.KBAUD = 15.63. HIGH, 1 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 32.768 kHz.KBAUD = 0.51. HIGH, 32.768 kHz.% ERROR = -. HIGH, SPBRG value (decimal).SPBRG value (decimal)",
    "TABLE 16-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 0)\n= 0. LOW, FOSC = 4 MHz.KBAUD = 0.24. LOW, FOSC = 4 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 3.579545 MHz.KBAUD = 0.22. LOW, 3.579545 MHz.% ERROR = -. LOW, SPBRG.value (decimal) = 255. LOW, 1 MHz.KBAUD = 0.06. LOW, 1 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 32.768 kHz.KBAUD = 0.002. LOW, 32.768 kHz.% ERROR = -. LOW, SPBRG value (decimal).SPBRG value (decimal) = 255",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n0.3, FOSC = 40 MHz.KBAUD = NA. 0.3, FOSC = 40 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 33 MHz.KBAUD = NA. 0.3, 33 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 25 MHz.KBAUD = NA. 0.3, 25 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 20 MHz.KBAUD = NA. 0.3, 20 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 1.2, FOSC = 40 MHz.KBAUD = NA. 1.2, FOSC = 40 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 33 MHz.KBAUD = NA. 1.2, 33 MHz.% ERROR = -.",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n1.2, SPBRG value (decimal). = -. 1.2, 25 MHz.KBAUD = NA. 1.2, 25 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 20 MHz.KBAUD = NA. 1.2, 20 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 2.4, FOSC = 40 MHz.KBAUD = NA. 2.4, FOSC = 40 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 33 MHz.KBAUD = NA. 2.4, 33 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 25 MHz.KBAUD = NA. 2.4, 25 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 20 MHz.KBAUD = NA. 2.4, 20",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nMHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 9.6, FOSC = 40 MHz.KBAUD = NA. 9.6, FOSC = 40 MHz.% ERROR = -. 9.6, SPBRG value (decimal). = -. 9.6, 33 MHz.KBAUD = 9.60. 9.6, 33 MHz.% ERROR = -0.07. 9.6, SPBRG value (decimal). = 214. 9.6, 25 MHz.KBAUD = 9.59. 9.6, 25 MHz.% ERROR = -0.15. 9.6, SPBRG value (decimal). = 162. 9.6, 20 MHz.KBAUD = 9.62. 9.6, 20 MHz.% ERROR = +0.16. 9.6, SPBRG value (decimal). = 129. 19.2, FOSC = 40 MHz.KBAUD = 19.23. 19.2, FOSC = 40 MHz.% ERROR =",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n+0.16. 19.2, SPBRG value (decimal). = 129. 19.2, 33 MHz.KBAUD = 19.28. 19.2, 33 MHz.% ERROR = +0.39. 19.2, SPBRG value (decimal). = 106. 19.2, 25 MHz.KBAUD = 19.30. 19.2, 25 MHz.% ERROR = +0.47. 19.2, SPBRG value (decimal). = 80. 19.2, 20 MHz.KBAUD = 19.23. 19.2, 20 MHz.% ERROR = +0.16. 19.2, SPBRG value (decimal). = 64. 76.8, FOSC = 40 MHz.KBAUD = 75.76. 76.8, FOSC = 40 MHz.% ERROR = -1.36. 76.8, SPBRG value (decimal). = 32. 76.8, 33 MHz.KBAUD = 76.39. 76.8, 33 MHz.% ERROR = -0.54.",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n76.8, SPBRG value (decimal). = 26. 76.8, 25 MHz.KBAUD = 78.13. 76.8, 25 MHz.% ERROR = +1.73. 76.8, SPBRG value (decimal). = 19. 76.8, 20 MHz.KBAUD = 78.13. 76.8, 20 MHz.% ERROR = +1.73. 76.8, SPBRG value (decimal). = 15. 96, FOSC = 40 MHz.KBAUD = 96.15. 96, FOSC = 40 MHz.% ERROR = +0.16. 96, SPBRG value (decimal). = 25. 96, 33 MHz.KBAUD = 98.21. 96, 33 MHz.% ERROR = +2.31. 96, SPBRG value (decimal). = 20. 96, 25 MHz.KBAUD = 97.66. 96, 25 MHz.% ERROR = +1.73. 96, SPBRG value (decimal). = 15. 96, 20 MHz.KBAUD =",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n96.15. 96, 20 MHz.% ERROR = +0.16. 96, SPBRG value (decimal). = 12. 300, FOSC = 40 MHz.KBAUD = 312.50. 300, FOSC = 40 MHz.% ERROR = +4.17. 300, SPBRG value (decimal). = 7. 300, 33 MHz.KBAUD = 294.64. 300, 33 MHz.% ERROR = -1.79. 300, SPBRG value (decimal). = 6. 300, 25 MHz.KBAUD = 312.50. 300, 25 MHz.% ERROR = +4.17. 300, SPBRG value (decimal). = 4. 300, 20 MHz.KBAUD = 312.50. 300, 20 MHz.% ERROR = +4.17. 300, SPBRG value (decimal). = 3. 500, FOSC = 40 MHz.KBAUD = 500. 500, FOSC = 40 MHz.% ERROR = 0. 500, SPBRG value (decimal). = 4. 500, 33",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nMHz.KBAUD = 515.63. 500, 33 MHz.% ERROR = +3.13. 500, SPBRG value (decimal). = 3. 500, 25 MHz.KBAUD = 520.83. 500, 25 MHz.% ERROR = +4.17. 500, SPBRG value (decimal). = 2. 500, 20 MHz.KBAUD = 416.67. 500, 20 MHz.% ERROR = -16.67. 500, SPBRG value (decimal). = 2. HIGH, FOSC = 40 MHz.KBAUD = 2500. HIGH, FOSC = 40 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 33 MHz.KBAUD = 2062.50. HIGH, 33 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 25 MHz.KBAUD = 1562.50. HIGH, 25 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 20 MHz.KBAUD =",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n1250. HIGH, 20 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. LOW, FOSC = 40 MHz.KBAUD = 9.77. LOW, FOSC = 40 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 33 MHz.KBAUD = 8,06. LOW, 33 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 25 MHz.KBAUD = 6.10. LOW, 25 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 20 MHz.KBAUD = 4.88. LOW, 20 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n0.3, FOSC = 16 MHz.KBAUD = NA. 0.3, FOSC = 16 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 10 MHz.KBAUD = NA. 0.3, 10 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 7.15909 MHz.KBAUD = NA. 0.3, 7.15909 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 5.0688 MHz.KBAUD = NA. 0.3, 5.0688 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 1.2, FOSC = 16 MHz.KBAUD = NA. 1.2, FOSC = 16 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 10",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nMHz.KBAUD = NA. 1.2, 10 MHz.% ERROR = -. 1.2, SPBRG value.(decimal) = -. 1.2, 7.15909 MHz.KBAUD = NA. 1.2, 7.15909 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 5.0688 MHz.KBAUD = NA. 1.2, 5.0688 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 2.4, FOSC = 16 MHz.KBAUD = NA. 2.4, FOSC = 16 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 10 MHz.KBAUD = NA. 2.4, 10 MHz.% ERROR = -. 2.4, SPBRG value.(decimal) = -. 2.4, 7.15909 MHz.KBAUD = 2.41.",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n2.4, 7.15909 MHz.% ERROR = +0.23. 2.4, SPBRG value (decimal). = 185. 2.4, 5.0688 MHz.KBAUD = 2.40. 2.4, 5.0688 MHz.% ERROR = 0. 2.4, SPBRG value (decimal). = 131. 9.6, FOSC = 16 MHz.KBAUD = 9.62. 9.6, FOSC = 16 MHz.% ERROR = +0.16. 9.6, SPBRG value (decimal). = 103. 9.6, 10 MHz.KBAUD = 9.62. 9.6, 10 MHz.% ERROR = +0.16. 9.6, SPBRG value.(decimal) = 64. 9.6, 7.15909 MHz.KBAUD = 9.52. 9.6, 7.15909 MHz.% ERROR = -0.83. 9.6, SPBRG value (decimal). = 46. 9.6,",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n5.0688 MHz.KBAUD = 9.60. 9.6, 5.0688 MHz.% ERROR = 0. 9.6, SPBRG value (decimal). = 32. 19.2, FOSC = 16 MHz.KBAUD = 19.23. 19.2, FOSC = 16 MHz.% ERROR = +0.16. 19.2, SPBRG value (decimal). = 51. 19.2, 10 MHz.KBAUD = 18.94. 19.2, 10 MHz.% ERROR = -1.36. 19.2, SPBRG value.(decimal) = 32. 19.2, 7.15909 MHz.KBAUD = 19.45. 19.2, 7.15909 MHz.% ERROR = +1.32. 19.2, SPBRG value (decimal). = 22. 19.2, 5.0688 MHz.KBAUD = 18.64. 19.2, 5.0688 MHz.% ERROR = -2.94. 19.2,",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nSPBRG value (decimal). = 16. 76.8, FOSC = 16 MHz.KBAUD = 76.92. 76.8, FOSC = 16 MHz.% ERROR = +0.16. 76.8, SPBRG value (decimal). = 12. 76.8, 10 MHz.KBAUD = 78.13. 76.8, 10 MHz.% ERROR = +1.73. 76.8, SPBRG value.(decimal) = 7. 76.8, 7.15909 MHz.KBAUD = 74.57. 76.8, 7.15909 MHz.% ERROR = -2.90. 76.8, SPBRG value (decimal). = 5. 76.8, 5.0688 MHz.KBAUD = 79.20. 76.8, 5.0688 MHz.% ERROR = +3.13. 76.8, SPBRG value (decimal). = 3. 96, FOSC = 16 MHz.KBAUD = 100. 96, FOSC = 16 MHz.%",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nERROR = +4.17. 96, SPBRG value (decimal). = 9. 96, 10 MHz.KBAUD = 89.29. 96, 10 MHz.% ERROR = -6.99. 96, SPBRG value.(decimal) = 6. 96, 7.15909 MHz.KBAUD = 89.49. 96, 7.15909 MHz.% ERROR = -6.78. 96, SPBRG value (decimal). = 4. 96, 5.0688 MHz.KBAUD = 105.60. 96, 5.0688 MHz.% ERROR = +10.00. 96, SPBRG value (decimal). = 2. 300, FOSC = 16 MHz.KBAUD = 333.33. 300, FOSC = 16 MHz.% ERROR = +11.11. 300, SPBRG value (decimal). = 2. 300, 10 MHz.KBAUD = 312.50. 300, 10 MHz.% ERROR = +4.17. 300, SPBRG value.(decimal) = 1.",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n300, 7.15909 MHz.KBAUD = 447.44. 300, 7.15909 MHz.% ERROR = +49.15. 300, SPBRG value (decimal). = 0. 300, 5.0688 MHz.KBAUD = 316.80. 300, 5.0688 MHz.% ERROR = +5.60. 300, SPBRG value (decimal). = 0. 500, FOSC = 16 MHz.KBAUD = 500. 500, FOSC = 16 MHz.% ERROR = 0. 500, SPBRG value (decimal). = 1. 500, 10 MHz.KBAUD = 625. 500, 10 MHz.% ERROR = +25.00. 500, SPBRG value.(decimal) = 0. 500, 7.15909 MHz.KBAUD = 447.44. 500, 7.15909 MHz.% ERROR = -10.51. 500, SPBRG value (decimal). = 0. 500, 5.0688 MHz.KBAUD = NA. 500,",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n5.0688 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. HIGH, FOSC = 16 MHz.KBAUD = 1000. HIGH, FOSC = 16 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 10 MHz.KBAUD = 625. HIGH, 10 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 7.15909 MHz.KBAUD = 447.44. HIGH, 7.15909 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 5.0688 MHz.KBAUD = 316.80. HIGH, 5.0688 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. LOW, FOSC = 16 MHz.KBAUD = 3.91. LOW, FOSC = 16 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 10",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nMHz.KBAUD = 2.44. LOW, 10 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 7.15909 MHz.KBAUD = 1.75. LOW, 7.15909 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 5.0688 MHz.KBAUD = 1.24. LOW, 5.0688 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n0.3, FOSC = 4 MHz.KBAUD = NA. 0.3, FOSC = 4 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 3.579545 MHz.KBAUD = NA. 0.3, 3.579545 MHz.% ERROR = -. 0.3, SPBRG 1 MHz.value (decimal) = -. 0.3, SPBRG 1 MHz.KBAUD = 0.30. 0.3, SPBRG.% ERROR = +0.16. 0.3, SPBRG.value (decimal) = 207. 0.3, 32.768 kHz.KBAUD = 0.29. 0.3, 32.768 kHz.% ERROR = -2.48. 0.3, SPBRG value (decimal).SPBRG value (decimal) = 6. 1.2, FOSC = 4 MHz.KBAUD = 1.20. 1.2, FOSC = 4 MHz.% ERROR =",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n+0.16. 1.2, SPBRG value (decimal). = 207. 1.2, 3.579545 MHz.KBAUD = 1.20. 1.2, 3.579545 MHz.% ERROR = +0.23. 1.2, SPBRG 1 MHz.value (decimal) = 185. 1.2, SPBRG 1 MHz.KBAUD = 1.20. 1.2, SPBRG.% ERROR = +0.16. 1.2, SPBRG.value (decimal) = 51. 1.2, 32.768 kHz.KBAUD = 1.02. 1.2, 32.768 kHz.% ERROR = -14.67. 1.2, SPBRG value (decimal).SPBRG value (decimal) = 1. 2.4, FOSC = 4 MHz.KBAUD = 2.40. 2.4, FOSC = 4 MHz.% ERROR = +0.16. 2.4, SPBRG value (decimal). = 103.",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n2.4, 3.579545 MHz.KBAUD = 2.41. 2.4, 3.579545 MHz.% ERROR = +0.23. 2.4, SPBRG 1 MHz.value (decimal) = 92. 2.4, SPBRG 1 MHz.KBAUD = 2.40. 2.4, SPBRG.% ERROR = +0.16. 2.4, SPBRG.value (decimal) = 25. 2.4, 32.768 kHz.KBAUD = 2.05. 2.4, 32.768 kHz.% ERROR = -14.67. 2.4, SPBRG value (decimal).SPBRG value (decimal) = 0. 9.6, FOSC = 4 MHz.KBAUD = 9.62. 9.6, FOSC = 4 MHz.% ERROR = +0.16. 9.6, SPBRG value (decimal). = 25. 9.6, 3.579545 MHz.KBAUD = 9.73.",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n9.6, 3.579545 MHz.% ERROR = +1.32. 9.6, SPBRG 1 MHz.value (decimal) = 22. 9.6, SPBRG 1 MHz.KBAUD = 8.93. 9.6, SPBRG.% ERROR = -6.99. 9.6, SPBRG.value (decimal) = 6. 9.6, 32.768 kHz.KBAUD = NA. 9.6, 32.768 kHz.% ERROR = -. 9.6, SPBRG value (decimal).SPBRG value (decimal) = -. 19.2, FOSC = 4 MHz.KBAUD = 19.23. 19.2, FOSC = 4 MHz.% ERROR = +0.16. 19.2, SPBRG value (decimal). = 12. 19.2, 3.579545 MHz.KBAUD = 18.64. 19.2, 3.579545 MHz.% ERROR = -2.90. 19.2, SPBRG",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n1 MHz.value (decimal) = 11. 19.2, SPBRG 1 MHz.KBAUD = 20.83. 19.2, SPBRG.% ERROR = +8.51. 19.2, SPBRG.value (decimal) = 2. 19.2, 32.768 kHz.KBAUD = NA. 19.2, 32.768 kHz.% ERROR = -. 19.2, SPBRG value (decimal).SPBRG value (decimal) = -. 76.8, FOSC = 4 MHz.KBAUD = NA. 76.8, FOSC = 4 MHz.% ERROR = -. 76.8, SPBRG value (decimal). = -. 76.8, 3.579545 MHz.KBAUD = 74.57. 76.8, 3.579545 MHz.% ERROR = -2.90. 76.8, SPBRG 1 MHz.value (decimal) = 2. 76.8, SPBRG 1 MHz.KBAUD = 62.50. 76.8,",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nSPBRG.% ERROR = -18.62. 76.8, SPBRG.value (decimal) = 0. 76.8, 32.768 kHz.KBAUD = NA. 76.8, 32.768 kHz.% ERROR = -. 76.8, SPBRG value (decimal).SPBRG value (decimal) = -. 96, FOSC = 4 MHz.KBAUD = NA. 96, FOSC = 4 MHz.% ERROR = -. 96, SPBRG value (decimal). = -. 96, 3.579545 MHz.KBAUD = 111.86. 96, 3.579545 MHz.% ERROR = +16.52. 96, SPBRG 1 MHz.value (decimal) = 1. 96, SPBRG 1 MHz.KBAUD = NA. 96, SPBRG.% ERROR = -. 96, SPBRG.value (decimal) = -. 96, 32.768 kHz.KBAUD = NA. 96, 32.768 kHz.% ERROR = -. 96,",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nSPBRG value (decimal).SPBRG value (decimal) = -. 300, FOSC = 4 MHz.KBAUD = NA. 300, FOSC = 4 MHz.% ERROR = -. 300, SPBRG value (decimal). = -. 300, 3.579545 MHz.KBAUD = 223.72. 300, 3.579545 MHz.% ERROR = -25.43. 300, SPBRG 1 MHz.value (decimal) = 0. 300, SPBRG 1 MHz.KBAUD = NA. 300, SPBRG.% ERROR = -. 300, SPBRG.value (decimal) = -. 300, 32.768 kHz.KBAUD = NA. 300, 32.768 kHz.% ERROR = -. 300, SPBRG value (decimal).SPBRG value (decimal) = -. 500, FOSC = 4 MHz.KBAUD = NA. 500, FOSC = 4 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500,",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n3.579545 MHz.KBAUD = NA. 500, 3.579545 MHz.% ERROR = -. 500, SPBRG 1 MHz.value (decimal) = -. 500, SPBRG 1 MHz.KBAUD = NA. 500, SPBRG.% ERROR = -. 500, SPBRG.value (decimal) = -. 500, 32.768 kHz.KBAUD = NA. 500, 32.768 kHz.% ERROR = -. 500, SPBRG value (decimal).SPBRG value (decimal) = -. HIGH, FOSC = 4 MHz.KBAUD = 250. HIGH, FOSC = 4 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 3.579545 MHz.KBAUD = 55.93. HIGH, 3.579545 MHz.% ERROR = -. HIGH, SPBRG 1 MHz.value (decimal) = 0. HIGH, SPBRG 1 MHz.KBAUD = 62.50. HIGH,",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\nSPBRG.% ERROR = -. HIGH, SPBRG.value (decimal) = 0. HIGH, 32.768 kHz.KBAUD = 2.05. HIGH, 32.768 kHz.% ERROR = -. HIGH, SPBRG value (decimal).SPBRG value (decimal) = 0. LOW, FOSC = 4 MHz.KBAUD = 0.98. LOW, FOSC = 4 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 3.579545 MHz.KBAUD = 0.22. LOW, 3.579545 MHz.% ERROR = -. LOW, SPBRG 1 MHz.value (decimal) = 255. LOW, SPBRG 1 MHz.KBAUD = 0.24. LOW, SPBRG.% ERROR = -. LOW, SPBRG.value (decimal) = 255. LOW, 32.768 kHz.KBAUD = 0.008. LOW, 32.768 kHz.% ERROR = -. LOW, SPBRG value",
    "TABLE 16-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH = 1)\n(decimal).SPBRG value (decimal) = 255",
    "16.2 USART Asynchronous Mode\nIn this mode, the USART uses standard non-return-tozero (NRZ) format (one START bit, eight or nine data bits and one STOP bit). The most common data format is 8-bits. An on-chip dedicated 8-bit baud rate generator can be used to derive standard baud rate frequencies  from  the  oscillator.  The  USART  transmits  and receives  the  LSb  first.  The  USART's  transmitter  and receiver  are  functionally  independent,  but  use  the same data format and baud rate. The baud rate generator produces a clock, either x16 or x64 of the bit shift rate, depending on bit BRGH (TXSTA<2>). Parity is not supported by the hardware, but can be implemented in software (and stored as the ninth data bit). Asynchronous mode is stopped during SLEEP.\nAsynchronous mode is selected by clearing bit SYNC (TXSTA<4>).\nThe  USART  Asynchronous  module  consists  of  the following important elements:",
    "16.2 USART Asynchronous Mode\nGLYPH<129> Baud Rate Generator\nGLYPH<129> Sampling Circuit\nGLYPH<129> Asynchronous Transmitter\nGLYPH<129> Asynchronous Receiver",
    "16.2.1 USART ASYNCHRONOUS TRANSMITTER\nflag  bit  TXIF  (PIR1<4>)  is  set.  This  interrupt  can  be enabled/disabled  by  setting/clearing  enable  bit  TXIE ( PIE1<4>). Flag bit TXIF will be set, regardless of the state of enable bit TXIE and cannot be cleared in software. It will reset only when new data is loaded into the TXREG register. While flag bit TXIF indicated the status of the TXREG  register, another bit, TRMT (TXSTA<1>), shows the status of the TSR register. Status bit TRMT is a read-only bit, which is set when the TSR register is empty. No interrupt logic is tied to this bit, so the user has to poll this bit in order to determine if the TSR register is empty.\nNote, 1 = 1: The TSR register is not mapped in data memory, so it is not available to the user.. , 1 = 2: Flag bit TXIF is set when enable bit TXEN is set.\nTo set up an asynchronous transmission:",
    "16.2.1 USART ASYNCHRONOUS TRANSMITTER\n1. Initialize the SPBRG register for the appropriate baud rate. If a high speed baud rate is desired, set bit BRGH (Section 16.1).\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit TXIE.\n4. If  9-bit  transmission is desired, set transmit bit TX9. Can be used as address/data bit.\nThe  USART  transmitter  block  diagram  is  shown  in Figure 16-1. The heart of the transmitter is the Transmit (serial) Shift Register (TSR). The shift register obtains its data from the read/write transmit buffer, TXREG. The TXREG register is loaded with data in software. The TSR register is not loaded until the STOP bit has been transmitted  from  the  previous  load.  As  soon  as  the STOP bit is transmitted, the TSR is loaded with new data from the TXREG register (if available). Once the TXREG register transfers the data to the TSR register (occurs in one TCY), the TXREG register is empty and",
    "16.2.1 USART ASYNCHRONOUS TRANSMITTER\n5. Enable  the  transmission  by  setting  bit  TXEN, which will also set bit TXIF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Load data to the TXREG  register (starts transmission).\nNote:\nTXIF is not cleared immediately upon loading  data  into  the  transmit  buffer  TXREG. The flag bit becomes valid in the second instruction cycle following the load instruction.",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on All Other RESETS = 0000. PIR1, Value on All Other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on All Other RESETS = 0000. PIE1, Value on All Other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on All Other RESETS = 0000. IPR1, Value on All Other RESETS = 0000. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on All Other RESETS = 0000. RCSTA, Value on All Other RESETS = -00x. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register.",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nTXREG, Bit 5 = USART Transmit Register. TXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on All Other RESETS = 0000. TXREG, Value on All Other RESETS = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on All Other RESETS = 0000. TXSTA,",
    "TABLE 16-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nValue on All Other RESETS = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on All Other RESETS = 0000. SPBRG, Value on All Other RESETS = 0000\nLegend: x = unknown, - = unimplemented locations read as '0'.\nShaded cells are not used for Asynchronous Transmission.\nNote1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18F2X2 devices; always maintain these bits clear.",
    "16.2.2 USART ASYNCHRONOUS RECEIVER\nThe receiver block diagram is  shown in Figure 16-4. The data is received on the RC7/RX/DT pin and drives the  data  recovery  block.  The  data  recovery  block  is actually a high speed shifter operating at x16 times the baud rate, whereas the main receive serial shifter operates  at  the  bit  rate  or  at  FOSC.  This  mode  would typically be used in RS-232 systems.\nTo set up an Asynchronous Reception:",
    "16.2.2 USART ASYNCHRONOUS RECEIVER\n1. Initialize the SPBRG register for the appropriate baud rate. If a high speed baud rate is desired, set bit BRGH (Section 16.1).\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit RCIE.\n4. If 9-bit reception is desired, set bit RX9.\n5. Enable the reception by setting bit CREN.\n6. Flag bit RCIF will be set when reception is complete and an interrupt will be generated if enable bit RCIE was set.\n7. Read the RCSTA register to get the ninth bit (if enabled)  and  determine  if  any  error  occurred during reception.\n8. Read  the  8-bit  received  data  by  reading  the RCREG register.\n9. If any error occurred, clear the error by clearing enable bit CREN.",
    "16.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\nThis mode would typically be used in RS-485 systems. To  set  up  an  Asynchronous  Reception  with  Address Detect Enable:",
    "16.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize the SPBRG register for the appropriate baud rate. If a high speed baud rate is required, set the BRGH bit.\n2. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n3. If interrupts are required, set the RCEN bit and select the desired priority level with the RCIP bit.\n4. Set the RX9 bit to enable 9-bit reception.\n5. Set the ADDEN bit to enable address detect.\n6. Enable reception by setting the CREN bit.\n7. The RCIF bit will be set when reception is complete. The interrupt will be acknowledged if the RCIE and GIE bits are set.\n8. Read the  RCSTA  register  to  determine  if  any error occurred during reception, as well as read bit 9 of data (if applicable).\n9. Read RCREG to determine if the device is being addressed.\n10. If any error occurred, clear the CREN bit.\n11. If  the  device  has  been  addressed,  clear  the ADDEN bit  to  allow  all  received  data  into  the receive buffer and interrupt the CPU.",
    "16.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n10. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "FIGURE 16-5: ASYNCHRONOUS RECEPTION\nRX (pin) Reg Rcv Buffer Rcv Shift Read Rcv Buffer Reg RCREG RCIF (Interrupt OERR bit CREN, 1 = START bit bit7/8 bit1 bit0 bit7/8 bit0 STOP bit START bit START bit bit7/8 STOP bit STOP bit. Reg, 1 = Word 1 Word 2. , 1 = RCREG RCREG. Flag), 1 = . Note:, 1 = This timing diagram shows three words appearing on the RXinput. The RCREG(receive buffer) is read after the third word, causing the OERR (overrun) bit to be set.",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on All Other RESETS = 0000. PIR1, Value on All Other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on All Other RESETS = 0000. PIE1, Value on All Other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on All Other RESETS = 0000. IPR1, Value on All Other RESETS = 0000. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on All Other RESETS = 0000. RCSTA, Value on All Other RESETS = -00x. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register.",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nRCREG, Bit 5 = USART Receive Register. RCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on All Other RESETS = 0000. RCREG, Value on All Other RESETS = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on All Other RESETS = 0000. TXSTA,",
    "TABLE 16-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nValue on All Other RESETS = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on All Other RESETS = 0000. SPBRG, Value on All Other RESETS = 0000\nLegend: x\n= unknown, - = unimplemented locations read as '0'.\nShaded cells are not used for Asynchronous Reception.\nNote1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18F2X2 devices; always maintain these bits clear.",
    "16.3 USART Synchronous Master Mode\nIn Synchronous Master mode, the data is transmitted in a half-duplex manner (i.e., transmission and reception do not occur at the same time). When transmitting data, the reception is inhibited and vice versa. Synchronous mode is entered by setting bit SYNC (TXSTA<4>). In addition, enable bit SPEN (RCSTA<7>) is set in order to configure the RC6/TX/CK and RC7/RX/DT I/O pins to  CK  (clock)  and  DT  (data)  lines,  respectively.  The Master mode indicates that the processor transmits the master  clock  on  the  CK  line.  The  Master  mode  is entered by setting bit CSRC (TXSTA<7>).",
    "16.3.1 USART SYNCHRONOUS MASTER TRANSMISSION\n(PIE1<4>). Flag bit TXIF will be set, regardless of the state of enable bit TXIE, and cannot be cleared in software. It will reset only when new data is loaded into the TXREG register. While flag bit TXIF indicates the status of the TXREG register, another bit TRMT (TXSTA<1>) shows the status of the TSR register. TRMT is a read only bit, which is set when the TSR is empty. No interrupt logic is tied to this bit, so the user has to poll this bit in order to determine if the TSR register is empty. The TSR is not mapped in data memory, so it is not available to the user.\nTo set up a Synchronous Master Transmission:\n1. Initialize the SPBRG register for the appropriate baud rate (Section 16.1).\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN, and CSRC.",
    "16.3.1 USART SYNCHRONOUS MASTER TRANSMISSION\nThe  USART  transmitter  block  diagram  is  shown  in Figure 16-1. The heart of the transmitter is the Transmit (serial) Shift Register (TSR). The shift register obtains its  data  from  the  read/write  transmit  buffer  register TXREG.  The  TXREG  register  is  loaded  with  data  in software. The TSR register is not loaded until the last bit  has  been  transmitted  from  the  previous  load.  As soon as the last bit is transmitted, the TSR is loaded with new data from the TXREG (if available). Once the TXREG register transfers the data to the TSR register (occurs in one TCYCLE), the TXREG is empty and interrupt  bit  TXIF  (PIR1<4>)  is  set.  The  interrupt  can  be enabled/disabled  by  setting/clearing  enable  bit  TXIE",
    "16.3.1 USART SYNCHRONOUS MASTER TRANSMISSION\n3. If interrupts are desired, set enable bit TXIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable the transmission by setting bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREG register.",
    "Note:\nTXIF is not cleared immediately upon loading  data  into  the  transmit  buffer  TXREG. The flag bit becomes valid in the second instruction cycle following the load instruction.",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on All Other RESETS = 0000. PIR1, Value on All Other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on All Other RESETS = 0000. PIE1, Value on All Other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on All Other RESETS = 0000. IPR1, Value on All Other RESETS = 0000. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on All Other RESETS = 0000. RCSTA, Value on All Other RESETS = -00x. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register.",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nTXREG, Bit 5 = USART Transmit Register. TXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on All Other RESETS = 0000. TXREG, Value on All Other RESETS = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on All Other RESETS = 0000. TXSTA,",
    "TABLE 16-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nValue on All Other RESETS = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on All Other RESETS = 0000. SPBRG, Value on All Other RESETS = 0000\nLegend: x = unknown, - = unimplemented, read as '0'.\nShaded cells are not used for Synchronous Master Transmission.\nNote1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18F2X2 devices; always maintain these bits clear.",
    "16.3.2 USART SYNCHRONOUS MASTER RECEPTION\nOnce  Synchronous  mode  is  selected,  reception  is enabled by setting either enable bit SREN (RCSTA<5>), or enable bit CREN (RCSTA<4>). Data is sampled on the RC7/RX/DT pin on the falling edge of the clock. If enable bit SREN is set, only a single word is received. If enable bit CREN is set, the reception is continuous until CREN is cleared. If both bits are set, then CREN takes precedence.\nTo set up a Synchronous Master Reception:",
    "16.3.2 USART SYNCHRONOUS MASTER RECEPTION\n1. Initialize the SPBRG register for the appropriate baud rate (Section 16.1).\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN and CSRC.\n4. If interrupts are desired, set enable bit RCIE.\n5. If 9-bit reception is desired, set bit RX9.\n6. If  a  single reception is required, set bit SREN. For continuous reception, set bit CREN.\n7. Interrupt flag bit RCIF will be set when reception is complete and an interrupt will be generated if the enable bit RCIE was set.\n8. Read the RCSTA register to get the ninth bit (if enabled)  and  determine  if  any  error  occurred during reception.\n9. Read  the  8-bit  received  data  by  reading  the RCREG register.\n10. If any error occurred, clear the error by clearing bit CREN.\n3. Ensure bits CREN and SREN are clear.\n11. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on All Other RESETS = 0000. PIR1, Value on All Other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on All Other RESETS = 0000. PIE1, Value on All Other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on All Other RESETS = 0000. IPR1, Value on All Other RESETS = 0000. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on All Other RESETS = 0000. RCSTA, Value on All Other RESETS = -00x. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register.",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nRCREG, Bit 5 = USART Receive Register. RCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on All Other RESETS = 0000. RCREG, Value on All Other RESETS = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on All Other RESETS = 0000. TXSTA,",
    "TABLE 16-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nValue on All Other RESETS = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on All Other RESETS = 0000. SPBRG, Value on All Other RESETS = 0000\nLegend: x = unknown, - = unimplemented, read as '0'. Shaded cells are not used for Synchronous Master Reception.\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18F2X2 devices; always maintain these bits clear.",
    "16.4 USART Synchronous Slave Mode\nSynchronous Slave mode differs from the Master mode in the fact that the shift clock is supplied externally at the RC6/TX/CK pin (instead of being supplied internally in Master mode). This allows the device to transfer or receive  data  while  in  SLEEP  mode.  Slave  mode  is entered by clearing bit CSRC (TXSTA<7>).",
    "16.4.1 USART SYNCHRONOUS SLAVE TRANSMIT\nThe operation of the Synchronous Master and Slave modes are identical, except in the case of the SLEEP mode.\nIf  two  words  are  written  to  the  TXREG  and  then  the SLEEP instruction is executed, the following will occur:\na) The  first  word  will  immediately  transfer  to  the TSR register and transmit.\nb) The second word will remain in TXREG register.\nc) Flag bit TXIF will not be set.\nd) When the first word has been shifted out of TSR, the  TXREG  register  will  transfer  the  second word to the TSR and flag bit TXIF will now be set.\ne) If enable bit TXIE is set, the interrupt will wake the  chip  from  SLEEP.  If  the  global  interrupt  is enabled, the program will branch to the interrupt vector.",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on All Other RESETS = 0000. PIR1, Value on All Other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on All Other RESETS = 0000. PIE1, Value on All Other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on All Other RESETS = 0000. IPR1, Value on All Other RESETS = 0000. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on All Other RESETS = 0000. RCSTA, Value on All Other RESETS = -00x. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register.",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nTXREG, Bit 5 = USART Transmit Register. TXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on All Other RESETS = 0000. TXREG, Value on All Other RESETS = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on All Other RESETS = 0000. TXSTA,",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nValue on All Other RESETS = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on All Other RESETS = 0000. SPBRG, Value on All Other RESETS = 0000\nLegend: x\n= unknown, - = unimplemented, read as '0'. Shaded cells are not used for Synchronous Slave Transmission.\nNote1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18F2X2 devices; always maintain these bits clear.",
    "TABLE 16-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nTo set up a Synchronous Slave Transmission:\n1. Enable the synchronous slave serial port by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. Clear bits CREN and SREN.\n3. If interrupts are desired, set enable bit TXIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable  the  transmission  by  setting  enable  bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREG register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "16.4.2 USART SYNCHRONOUS SLAVE RECEPTION\nThe operation of the Synchronous Master and Slave modes is identical, except in the case of the SLEEP mode and bit SREN, which is a 'don't care' in Slave mode.\nIf  receive is enabled by setting bit CREN prior to the SLEEP instruction, then a word may be received during SLEEP.  On  completely  receiving  the  word,  the  RSR register  will  transfer  the  data  to  the  RCREG register, and if enable bit RCIE bit is set, the interrupt generated will wake the chip from SLEEP. If the global interrupt is enabled, the program will branch to the interrupt vector.\nTo set up a Synchronous Slave Reception:",
    "16.4.2 USART SYNCHRONOUS SLAVE RECEPTION\n1. Enable  the  synchronous  master  serial  port  by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. If interrupts are desired, set enable bit RCIE.\n3. If 9-bit reception is desired, set bit RX9.\n4. To enable reception, set enable bit CREN.\n5. Flag bit RCIF will be set when reception is complete. An interrupt will be generated if enable bit RCIE was set.\n6. Read the RCSTA register to get the ninth bit (if enabled)  and  determine  if  any  error  occurred during reception.\n7. Read  the  8-bit  received  data  by  reading  the RCREG register.\n8. If any error occurred, clear the error by clearing bit CREN.\n9. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 16-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on All Other RESETS = 0000. INTCON, Value on All Other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 16-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on All Other RESETS = 0000. PIR1, Value on All Other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on All Other RESETS = 0000. PIE1, Value on All Other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 16-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0000. IPR1, Value on POR, BOR = 0000. IPR1, Value on All Other RESETS = 0000. IPR1, Value on All Other RESETS = 0000. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = -00x. RCSTA, Value on All Other RESETS = 0000. RCSTA, Value on All Other RESETS = -00x. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register.",
    "TABLE 16-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nRCREG, Bit 5 = USART Receive Register. RCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on All Other RESETS = 0000. RCREG, Value on All Other RESETS = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on All Other RESETS = 0000. TXSTA,",
    "TABLE 16-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nValue on All Other RESETS = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on All Other RESETS = 0000. SPBRG, Value on All Other RESETS = 0000\nLegend: x = unknown, - = unimplemented, read as '0'. Shaded cells are not used for Synchronous Slave Reception.\nNote1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18F2X2 devices; always maintain these bits clear.",
    "17.0 COMPATIBLE 10-BIT ANALOG-TO-DIGITAL CONVERTER (A/D) MODULE\nThe Analog-to-Digital (A/D) converter module has five inputs  for  the  PIC18F2X2  devices  and  eight  for  the PIC18F4X2  devices.  This  module  has  the  ADCON0 and ADCON1 register definitions that are compatible with the mid-range A/D module.\nThe A/D allows conversion of an analog input signal to a corresponding 10-bit digital number.\nThe  A/D  module  has  four  registers.  These  registers are:\nGLYPH<129> A/D Result High Register (ADRESH)\nGLYPH<129> A/D Result Low Register (ADRESL)\nGLYPH<129> A/D Control Register 0 (ADCON0)\nGLYPH<129> A/D Control Register 1 (ADCON1)\nThe  ADCON0 register,  shown  in  Register 17-1,  controls  the  operation of  the A/D  module. The ADCON1 register, shown in Register 17-2, configures the functions of the port pins.",
    "REGISTER 17-1: ADCON0 REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = U-0. R/W-0, 7 = R/W-0. ADCS1, 1 = ADCS0. ADCS1, 2 = CHS2. ADCS1, 3 = CHS1. ADCS1, 4 = CHS0. ADCS1, 5 = GO/DONE. ADCS1, 6 = -. ADCS1, 7 = ADON\nbit 7\nbit 0",
    "bit 7-6 ADCS1:ADCS0: A/D Conversion Clock Select bits (ADCON0 bits in bold )\n0, ADCON0 <ADCS1:ADCS0> = 00. 0, Clock Conversion = FOSC/2. 0, ADCON0 <ADCS1:ADCS0> = 01. 0, Clock Conversion = FOSC/8. 0, ADCON0 <ADCS1:ADCS0> = 10. 0, Clock Conversion = FOSC/32. 0, ADCON0 <ADCS1:ADCS0> = 11. 0, Clock Conversion = FRC (clock derived from the internal A/D RC oscillator). 1, ADCON0 <ADCS1:ADCS0> = 00. 1, Clock Conversion = FOSC/4. 1, ADCON0 <ADCS1:ADCS0> = 01. 1, Clock Conversion = FOSC/16. 1, ADCON0 <ADCS1:ADCS0> = 10. 1, Clock Conversion = FOSC/64. 1, ADCON0 <ADCS1:ADCS0> = 11. 1, Clock Conversion",
    "bit 7-6 ADCS1:ADCS0: A/D Conversion Clock Select bits (ADCON0 bits in bold )\n= FRC (clock derived from the internal A/D RC oscillator)",
    "bit 5-3 CHS2:CHS0: Analog Channel Select bits\n000\n= channel 0, (AN0)\n001 = channel 1, (AN1)\n010 = channel 2, (AN2)\n011 = channel 3, (AN3)\n100 = channel 4, (AN4)\n101 = channel 5, (AN5)\n110 = channel 6, (AN6)\n111\n= channel 7, (AN7)\nNote: The PIC18F2X2 devices do not implement the full 8 A/D channels; the unimplemented selections are reserved. Do not select any unimplemented channel.",
    "bit 2 GO/DONE: A/D Conversion Status bit\nWhen ADON = 1:\n1 = A/D conversion in progress (setting this bit starts the A/D conversion which is automatically cleared by hardware when the A/D conversion is complete)\n0 = A/D conversion not in progress",
    "bit 0 ADON: A/D On bit\n1 = A/D converter module is powered up\n0 = A/D converter module is shut-off and consumes no operating current\nLegend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 17-2: ADCON1 REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = U-0. R/W-0, 3 = U-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. ADFM, 1 = ADCS2. ADFM, 2 = -. ADFM, 3 = -. ADFM, 4 = PCFG3. ADFM, 5 = PCFG2. ADFM, 6 = PCFG1. ADFM, 7 = PCFG0\nbit 7\nbit 0",
    "bit 7 ADFM: A/D Result Format Select bit\n1 = Right justified. Six (6) Most Significant bits of ADRESH are read as '0'.\n0 = Left justified. Six (6) Least Significant bits of ADRESL are read as '0'.",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\n0, ADCON0 <ADCS1:ADCS0> = 00. 0, Clock Conversion = FOSC/2. 0, ADCON0 <ADCS1:ADCS0> = 01. 0, Clock Conversion = FOSC/8. 0, ADCON0 <ADCS1:ADCS0> = 10. 0, Clock Conversion = FOSC/32. 0, ADCON0 <ADCS1:ADCS0> = 11. 0, Clock Conversion = FRC (clock derived from the internal A/D RC oscillator). 1, ADCON0 <ADCS1:ADCS0> = 00. 1, Clock Conversion = FOSC/4. 1, ADCON0 <ADCS1:ADCS0> = 01. 1, Clock Conversion = FOSC/16. 1, ADCON0 <ADCS1:ADCS0> = 10. 1, Clock Conversion = FOSC/64. 1, ADCON0 <ADCS1:ADCS0> = 11. 1, Clock Conversion = FRC (clock derived",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\nfrom the internal A/D RC oscillator)",
    "bit 5-4 Unimplemented: Read as '0'\nbit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits",
    "bit 5-4 Unimplemented: Read as '0'\n0000, AN7 = A. 0000, AN6 = A. 0000, AN5 = A. 0000, AN4 = A. 0000, AN3 = A. 0000, AN2 = A. 0000, AN1 = A. 0000, AN0 = A. 0000, VREF+ = VDD. 0000, VREF- = VSS. 0000, C / R = 8 / 0. 0001, AN7 = A. 0001, AN6 = A. 0001, AN5 = A. 0001, AN4 = A. 0001, AN3 = VREF+. 0001, AN2 = A. 0001, AN1 = A. 0001, AN0 = A. 0001, VREF+ = AN3. 0001, VREF- = VSS. 0001, C / R = 7 / 1. 0010, AN7 = D. 0010, AN6 = D. 0010, AN5 = D. 0010, AN4 = A. 0010, AN3 = A. 0010, AN2 = A.",
    "bit 5-4 Unimplemented: Read as '0'\n0010, AN1 = A. 0010, AN0 = A. 0010, VREF+ = VDD. 0010, VREF- = VSS. 0010, C / R = 5 / 0. 0011, AN7 = D. 0011, AN6 = D. 0011, AN5 = D. 0011, AN4 = A. 0011, AN3 = VREF+. 0011, AN2 = A. 0011, AN1 = A. 0011, AN0 = A. 0011, VREF+ = AN3. 0011, VREF- = VSS. 0011, C / R = 4 / 1. 0100, AN7 = D. 0100, AN6 = D. 0100, AN5 = D. 0100, AN4 = D. 0100, AN3 = A. 0100, AN2 = D. 0100, AN1 = A. 0100, AN0 = A. 0100, VREF+ = VDD. 0100, VREF- = VSS. 0100, C / R = 3 / 0.",
    "bit 5-4 Unimplemented: Read as '0'\n0101, AN7 = D. 0101, AN6 = D. 0101, AN5 = D. 0101, AN4 = D. 0101, AN3 = VREF+. 0101, AN2 = D. 0101, AN1 = A. 0101, AN0 = A. 0101, VREF+ = AN3. 0101, VREF- = VSS. 0101, C / R = 2 / 1. 011x, AN7 = D. 011x, AN6 = D. 011x, AN5 = D. 011x, AN4 = D. 011x, AN3 = D. 011x, AN2 = D. 011x, AN1 = D. 011x, AN0 = D. 011x, VREF+ = -. 011x, VREF- = -. 011x, C / R = 0 / 0. 1000, AN7 = A. 1000, AN6 = A. 1000, AN5 = A. 1000, AN4 = A. 1000, AN3 = VREF+. 1000,",
    "bit 5-4 Unimplemented: Read as '0'\nAN2 = VREF-. 1000, AN1 = A. 1000, AN0 = A. 1000, VREF+ = AN3. 1000, VREF- = AN2. 1000, C / R = 6 / 2. 1001, AN7 = D. 1001, AN6 = D. 1001, AN5 = A. 1001, AN4 = A. 1001, AN3 = A. 1001, AN2 = A. 1001, AN1 = A. 1001, AN0 = A. 1001, VREF+ = VDD. 1001, VREF- = VSS. 1001, C / R = 6 / 0. 1010, AN7 = D. 1010, AN6 = D. 1010, AN5 = A. 1010, AN4 = A. 1010, AN3 = VREF+. 1010, AN2 = A. 1010, AN1 = A. 1010, AN0 = A. 1010, VREF+ = AN3. 1010, VREF- = VSS. 1010, C / R = 5 / 1.",
    "bit 5-4 Unimplemented: Read as '0'\n1011, AN7 = D. 1011, AN6 = D. 1011, AN5 = A. 1011, AN4 = A. 1011, AN3 = VREF+. 1011, AN2 = VREF-. 1011, AN1 = A. 1011, AN0 = A. 1011, VREF+ = AN3. 1011, VREF- = AN2. 1011, C / R = 4 / 2. 1100, AN7 = D. 1100, AN6 = D. 1100, AN5 = D. 1100, AN4 = A. 1100, AN3 = VREF+. 1100, AN2 = VREF-. 1100, AN1 = A. 1100, AN0 = A. 1100, VREF+ = AN3. 1100, VREF- = AN2. 1100, C / R = 3 / 2. 1101, AN7 = D. 1101, AN6 = D. 1101, AN5 = D. 1101, AN4 = D. 1101, AN3 = VREF+. 1101, AN2 = VREF-.",
    "bit 5-4 Unimplemented: Read as '0'\n1101, AN1 = A. 1101, AN0 = A. 1101, VREF+ = AN3. 1101, VREF- = AN2. 1101, C / R = 2 / 2. 1110, AN7 = D. 1110, AN6 = D. 1110, AN5 = D. 1110, AN4 = D. 1110, AN3 = D. 1110, AN2 = D. 1110, AN1 = D. 1110, AN0 = A. 1110, VREF+ = VDD. 1110, VREF- = VSS. 1110, C / R = 1 / 0. 1111, AN7 = D. 1111, AN6 = D. 1111, AN5 = D. 1111, AN4 = D. 1111, AN3 = VREF+. 1111, AN2 = VREF-. 1111, AN1 = D. 1111, AN0 = A. 1111, VREF+ = AN3. 1111, VREF- = AN2. 1111, C / R = 1 / 2",
    "bit 5-4 Unimplemented: Read as '0'\nA = Analog input    D = Digital I/O\nC/R = # of analog input channels / # of A/D voltage references\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown\nNote: On any device RESET, the port pins that are multiplexed with analog functions (ANx) are forced to be an analog input.\nThe analog reference voltage is software selectable to either the device's positive and negative supply voltage (VDD and VSS), or the voltage level on the RA3/AN3/ VREF+ pin and RA2/AN2/VREF- pin.\nThe A/D converter has a unique feature of being able to operate while the device is in SLEEP mode. To operate  in  SLEEP,  the  A/D  conversion  clock  must  be derived from the A/D's internal RC oscillator.",
    "bit 5-4 Unimplemented: Read as '0'\nThe output of the sample and hold is the input into the converter,  which  generates  the  result  via  successive approximation.\nA device RESET forces all registers  to  their  RESET state. This forces the A/D module to be turned off and any conversion is aborted.",
    "FIGURE 17-1: A/D BLOCK DIAGRAM\n- * These channels are implemented only on the PIC18F4X2 devices.\nEach port pin associated with the A/D converter can be configured  as  an  analog  input  (RA3  can  also  be  a voltage reference) or as a digital I/O.\nThe ADRESH and ADRESL registers contain the result of  the  A/D  conversion.  When  the  A/D  conversion  is complete,  the  result  is loaded  into  the ADRESH/ ADRESL registers, the GO/DONE bit (ADCON0<2>) is cleared, and A/D interrupt flag bit, ADIF is set. The block diagram of the A/D module is shown in Figure 17-1.\nThe value that is in the ADRESH/ADRESL registers is not  modified  for  a  Power-on  Reset.  The  ADRESH/ ADRESL registers will  contain  unknown  data  after  a Power-on Reset.",
    "FIGURE 17-1: A/D BLOCK DIAGRAM\nAfter the A/D module has been configured as desired, the selected channel must be acquired before the conversion  is  started.  The  analog  input  channels  must have  their  corresponding  TRIS  bits  selected  as  an input. To determine acquisition time, see Section 17.1. After this acquisition time has elapsed, the A/D conversion  can  be  started.  The  following  steps  should  be followed for doing an A/D conversion:",
    "FIGURE 17-1: A/D BLOCK DIAGRAM\n1. Configure the A/D module:\nGLYPH<129> Configure analog pins, voltage reference and digital I/O (ADCON1)\nGLYPH<129> Select A/D input channel (ADCON0)\nGLYPH<129> Select A/D conversion clock (ADCON0)\nGLYPH<129> Turn on A/D module (ADCON0)\n2. Configure A/D interrupt (if desired):\nGLYPH<129> Clear ADIF bit\nGLYPH<129> Set ADIE bit\nGLYPH<129> Set GIE bit\nGLYPH<129> Set PEIE bit\n3. Wait the required acquisition time.\n4. Start conversion:\nGLYPH<129> Set GO/DONE bit (ADCON0)\n5. Wait for A/D conversion to complete, by either:\nGLYPH<129> Polling for the GO/DONE bit to be cleared (interrupts disabled)\nOR",
    "FIGURE 17-1: A/D BLOCK DIAGRAM\nGLYPH<129> Waiting for the A/D interrupt\n6. Read A/D Result registers (ADRESH/ADRESL); clear bit ADIF if required.\n7. For next conversion, go to step 1 or step 2 as required.  The  A/D  conversion  time  per  bit  is defined  as  TAD.  A  minimum  wait  of  2  TAD  is required before the next acquisition starts.",
    "17.1 A/D Acquisition Requirements\nFor the A/D converter to meet its specified accuracy, the charge holding capacitor (CHOLD) must be allowed to fully charge to the input channel voltage level. The analog  input  model  is  shown  in  Figure 17-2.  The source  impedance  (RS)  and  the  internal  sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD. The sampling switch (RSS) impedance varies over the device voltage (VDD). The source impedance affects the offset voltage at the analog input (due to pin leakage current). The maximum  recommended  impedance  for  analog sources is 2.5 k \u2126 .  After  the  analog input channel  is selected  (changed),  this  acquisition  must  be  done before the conversion can be started.\nNote:, 1 = When the conversion is started, the hold- ing capacitor is disconnected from the input pin.",
    "FIGURE 17-2: ANALOG INPUT MODEL\nTo calculate the minimum acquisition time, Equation 17-1  may  be  used.  This  equation  assumes that 1/2 LSb error is used (1024 steps for the A/D). The 1/2 LSb error is the maximum error allowed for the A/D to meet its specified resolution.",
    "EQUATION 17-1: A CQUISITION TIME\nT ACQ = Amplifier Settling Time + Holding Capacitor Charging Time + Temperature Coefficient = TAMP + TC + TCOFF",
    "EQUATION 17-2: A/D MINIMUM CHARGING TIME\n```\nVHOLD  = (VREF - (VREF/2048)) GLYPH<129> (1 - e (-Tc/CHOLD(RIC + RSS + RS)) or TC = -(120 pF)(1 k \u2126 + RSS + RS) ln(1/2048)\n```\nExample 17-1 shows the calculation  of  the  minimum required  acquisition  time,  TACQ.  This  calculation  is based  on  the  following  application  system  assumptions:\nGLYPH<129> CHOLD =\n120 pF\nGLYPH<129> Rs\n= 2.5 k\n\u2126\nGLYPH<129> Conversion Error \u2264 1/2 LSb\nGLYPH<129> VDD\n=\n5V \u2192 Rss = 7 k \u2126\nGLYPH<129> Temperature = 50 C (system max.)\n\u00b0\nGLYPH<129> VHOLD =\n0V @ time = 0",
    "EXAMPLE 17-1: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\n```\nTACQ = TAMP + TC + TCOFF Temperature coefficient is only required for temperatures > 25 C. \u00b0 TACQ = 2 \u00b5 s + TC + [(Temp - 25 C)(0.05 \u00b0 \u00b5 s/ \u00b0 C)] TC = -CHOLD (RIC + RSS + RS) ln(1/2048) -120 pF (1 k \u2126 + 7 k \u2126 + 2.5 k \u2126 ) ln(0.0004883) -120 pF (10.5 k \u2126 ) ln(0.0004883) -1.26 \u00b5 s (-7.6246) 9.61 \u00b5 s TACQ = 2 \u00b5 s + 9.61 \u00b5 s + [(50 \u00b0 C - 25 C)(0.05 \u00b0 \u00b5 s/ \u00b0 C)] 11.61 \u00b5 s + 1.25 \u00b5 s 12.86 \u00b5 s\n```\n```\n)\n```",
    "17.2 Selecting the A/D Conversion Clock\nThe A/D conversion time per bit is defined as TAD. The A/D conversion requires 12 TAD per 10-bit conversion. The  source  of  the  A/D  conversion  clock  is  software selectable. The seven possible options for TAD are:\nGLYPH<129> 2 TOSC\nGLYPH<129> 4 TOSC\nGLYPH<129> 8 TOSC\nGLYPH<129> 16 TOSC\nGLYPH<129> 32 TOSC\nGLYPH<129> 64 TOSC\nGLYPH<129> Internal A/D module RC oscillator (2-6 \u00b5 s)\nFor correct A/D conversions, the A/D conversion clock (TAD) must be selected to ensure a minimum TAD time of 1.6 \u00b5 s.",
    "17.3 Configuring Analog Port Pins\nThe ADCON1, TRISA and TRISE registers control the operation  of  the  A/D  port  pins.  The  port  pins  that  are desired as analog inputs, must have their corresponding TRIS bits set (input). If the TRIS bit is cleared (output), the digital output level (VOH or VOL) will be converted.\nThe A/D operation is independent of the state of the CHS2:CHS0 bits and the TRIS bits.\n- Note 1: When reading the port register, all pins configured as analog input channels will read as cleared (a low level). Pins configured as digital  inputs  will  convert  an  analog  input. Analog levels on a digitally configured input will not affect the conversion accuracy.\nTable 17-1 shows the resultant TAD times derived from the  device  operating  frequencies  and  the  A/D  clock source selected.\n- 2: Analog levels on any pin that is defined as a  digital  input  (including  the  AN4:AN0 pins) may cause the input buffer to consume current that is out of  the  device's specification.",
    "TABLE 17-1: TAD vs. DEVICE OPERATING FREQUENCIES\n2 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 000. 2 TOSC, Maximum Device Frequency.PIC18FXX2 = 1.25 MHz. 2 TOSC, Maximum Device Frequency.PIC18LFXX2 = 666 kHz. 4 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 100. 4 TOSC, Maximum Device Frequency.PIC18FXX2 = 2.50 MHz. 4 TOSC, Maximum Device Frequency.PIC18LFXX2 = 1.33 MHz. 8 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 001. 8 TOSC, Maximum Device Frequency.PIC18FXX2 = 5.00 MHz. 8 TOSC, Maximum Device Frequency.PIC18LFXX2 = 2.67 MHz. 16 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 101. 16 TOSC, Maximum Device Frequency.PIC18FXX2 = 10.00 MHz. 16 TOSC, Maximum Device Frequency.PIC18LFXX2 = 5.33 MHz. 32 TOSC, AD Clock",
    "TABLE 17-1: TAD vs. DEVICE OPERATING FREQUENCIES\nSource (T AD).ADCS2:ADCS0 = 010. 32 TOSC, Maximum Device Frequency.PIC18FXX2 = 20.00 MHz. 32 TOSC, Maximum Device Frequency.PIC18LFXX2 = 10.67 MHz. 64 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 110. 64 TOSC, Maximum Device Frequency.PIC18FXX2 = 40.00 MHz. 64 TOSC, Maximum Device Frequency.PIC18LFXX2 = 21.33 MHz. RC, AD Clock Source (T AD).ADCS2:ADCS0 = 011. RC, Maximum Device Frequency.PIC18FXX2 = -. RC, Maximum Device Frequency.PIC18LFXX2 = -",
    "17.4 A/D Conversions\nFigure 17-3 shows the operation of the A/D converter after the GO bit has been set. Clearing the GO/DONE bit  during  a  conversion  will  abort  the  current  conversion. The A/D result register pair will NOT be updated with  the  partially  completed  A/D  conversion  sample. That is, the ADRESH:ADRESL registers will continue to contain the value of the last completed conversion\n(or the last value written to the ADRESH:ADRESL registers). After the A/D conversion is aborted, a 2 TAD wait is required before the next acquisition is started. After this 2 TAD wait, acquisition on the selected channel is automatically started. The GO/DONE bit can then be set to start the conversion.\nNote: The GO/DONE bit should NOT be  set  in the same instruction that turns on the A/D.\nFIGURE 17-3: A/D CONVERSION TAD CYCLES",
    "17.4.1 A/D RESULT REGISTERS\nThe  ADRESH:ADRESL  register  pair  is  the  location where the 10-bit A/D result is loaded at the completion of the A/D conversion. This register pair is 16-bits wide. The A/D module gives the flexibility to left or right justify the 10-bit result in  the 16-bit  result register.  The A/D\nFormat  Select  bit  (ADFM)  controls  this  justification. Figure 17-4 shows the operation of the A/D result justification. The extra bits are loaded with '0's. When an A/D  result  will not  overwrite  these  locations  (A/D disable), these registers may be used as two general purpose 8-bit registers.",
    "17.5 Use of the CCP2 Trigger\nAn A/D conversion can be started by the 'special event trigger'  of  the  CCP2  module.  This  requires  that  the CCP2M3:CCP2M0  bits  (CCP2CON<3:0>)  be  programmed as 1011 and that the A/D module is enabled (ADON bit is set).  When the trigger  occurs,  the GO/ DONE bit will be set, starting the A/D conversion, and the  Timer1  (or  Timer3)  counter  will  be  reset  to  zero. Timer1 (or Timer3) is reset to automatically repeat the A/D acquisition period with minimal software overhead\n(moving  ADRESH/ADRESL  to  the  desired  location). The appropriate analog input channel must be selected and the minimum acquisition done before the 'special event trigger' sets the GO/DONE  bit (starts a conversion).\nIf the A/D module is not enabled (ADON is cleared), the 'special  event  trigger'  will  be  ignored  by  the  A/D module,  but  will  still  reset  the  Timer1  (or  Timer3) counter.",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR All = 0000. INTCON, Value on POR, BOR All = 000x. INTCON, Value on Other RESETS = 0000. INTCON, Value on Other RESETS = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR All =",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\n0000. PIR1, Value on POR, BOR All = 0000. PIR1, Value on Other RESETS = 0000. PIR1, Value on Other RESETS = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR All = 0000. PIE1, Value on POR, BOR All = 0000. PIE1, Value on Other RESETS = 0000. PIE1, Value on Other RESETS = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR All = 0000. IPR1, Value on POR, BOR All = 0000. IPR1, Value on Other RESETS = 0000. IPR1, Value on Other RESETS = 0000. PIR2, Bit 7 = -. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR All = ---0. PIR2, Value on POR, BOR All = 0000. PIR2, Value on Other RESETS = ---0. PIR2, Value on Other RESETS = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 =",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\n-. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR All = ---0. PIE2, Value on POR, BOR All = 0000. PIE2, Value on Other RESETS = ---0. PIE2, Value on Other RESETS = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR All = ---1. IPR2, Value on POR, BOR All = 1111. IPR2, Value on Other RESETS =",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\n---1. IPR2, Value on Other RESETS = 0000. ADRESH, Bit 7 = A/D Result Register. ADRESH, Bit 6 = A/D Result Register. ADRESH, Bit 5 = A/D Result Register. ADRESH, Bit 4 = A/D Result Register. ADRESH, Bit 3 = A/D Result Register. ADRESH, Bit 2 = A/D Result Register. ADRESH, Bit 1 = A/D Result Register. ADRESH, Bit 0 = A/D Result Register. ADRESH, Value on POR, BOR All = xxxx. ADRESH, Value on POR, BOR All = xxxx. ADRESH, Value on Other RESETS = uuuu. ADRESH, Value on Other RESETS = uuuu. ADRESL, Bit 7 = A/D Result Register. ADRESL, Bit 6 = A/D Result Register. ADRESL, Bit 5 = A/D Result Register. ADRESL, Bit 4 = A/D Result Register. ADRESL, Bit 3 = A/D Result Register. ADRESL, Bit 2 = A/D",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nResult Register. ADRESL, Bit 1 = A/D Result Register. ADRESL, Bit 0 = A/D Result Register. ADRESL, Value on POR, BOR All = xxxx. ADRESL, Value on POR, BOR All = xxxx. ADRESL, Value on Other RESETS = uuuu. ADRESL, Value on Other RESETS = uuuu. ADCON0, Bit 7 = ADCS1. ADCON0, Bit 6 = ADCS0. ADCON0, Bit 5 = CHS2. ADCON0, Bit 4 = CHS1. ADCON0, Bit 3 = CHS0. ADCON0, Bit 2 = GO/DONE. ADCON0, Bit 1 = -. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR All = 0000. ADCON0, Value on POR, BOR All = 00-0. ADCON0, Value on Other RESETS = 0000. ADCON0, Value on Other RESETS = 00-0. ADCON1, Bit 7 = ADFM.",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 = -. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR All = ----. ADCON1, Value on POR, BOR All = -000. ADCON1, Value on Other RESETS = ----. ADCON1, Value on Other RESETS = -000. PORTA, Bit 7 = -. PORTA, Bit 6 = RA6. PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR All = --0x. PORTA, Value on POR, BOR All = 0000. PORTA, Value on Other",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nRESETS = --0u. PORTA, Value on Other RESETS = 0000. TRISA, Bit 7 = -. TRISA, Bit 6 = PORTA Data Direction Register. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR All = --11. TRISA, Value on POR, BOR All = 1111. TRISA, Value on Other RESETS = --11. TRISA, Value on Other RESETS = 1111. PORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = -. PORTE, Bit 2 = RE2. PORTE, Bit 1 = RE1. PORTE, Bit 0 = RE0. PORTE, Value on POR, BOR All = ----. PORTE, Value on",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nPOR, BOR All = -000. PORTE, Value on Other RESETS = ----. PORTE, Value on Other RESETS = -000. LATE, Bit 7 = -. LATE, Bit 6 = -. LATE, Bit 5 = -. LATE, Bit 4 = -. LATE, Bit 3 = -. LATE, Bit 2 = LATE2. LATE, Bit 1 = LATE1. LATE, Bit 0 = LATE0. LATE, Value on POR, BOR All = ----. LATE, Value on POR, BOR All = -xxx. LATE, Value on Other RESETS = ----. LATE, Value on Other RESETS = -uuu. TRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 = PSPMODE. TRISE, Bit 3 = -. TRISE, Bit 2 = PORTE Data Direction bits. TRISE, Bit 1 = PORTE Data Direction bits. TRISE, Bit 0 = PORTE Data Direction bits. TRISE, Value on POR, BOR All = 0000. TRISE, Value on",
    "TABLE 17-2: SUMMARY OF A/D REGISTERS\nPOR, BOR All = -111. TRISE, Value on Other RESETS = 0000. TRISE, Value on Other RESETS = -111\nLegend: x = unknown, u = unchanged, - = unimplemented, read as '0'.  Shaded cells are not used for A/D conversion.\nNote 1: The PSPIF, PSPIE and PSPIP bits are reserved on the PIC18F2X2 devices; always maintain these bits clear.",
    "18.0 LOW VOLTAGE DETECT\nIn  many  applications,  the  ability  to  determine  if  the device voltage (VDD) is below a specified voltage level is  a  desirable  feature.  A  window  of  operation  for  the application can be created, where the application software can do 'housekeeping tasks' before the device voltage  exits  the  valid  operating  range.  This  can  be done using the Low Voltage Detect module.\nThe Low Voltage Detect circuitry is completely under software control. This allows the circuitry to be 'turned off' by  the  software,  which  minimizes  the  current consumption for the device.\nThis  module  is  a  software  programmable  circuitry, where  a  device  voltage  trip  point  can  be  specified. When the voltage of the device becomes lower then the specified point, an interrupt flag is set. If the interrupt is enabled, the program execution will branch to the interrupt vector address and the software can then respond to that interrupt source.",
    "18.0 LOW VOLTAGE DETECT\nFigure 18-1 shows a possible application voltage curve (typically for batteries). Over time, the device voltage decreases. When the device voltage equals voltage VA, the  LVD  logic  generates  an  interrupt.  This  occurs  at time  TA.  The  application  software  then  has  the  time, until the device voltage is no longer in valid operating range, to shutdown the system. Voltage point VB is the minimum  valid  operating  voltage  specification.  This occurs at time TB. The difference TB - TA is the total time for shutdown.",
    "FIGURE 18-1: TYPICAL LOW VOLTAGE DETECT APPLICATION\nThe  block  diagram  for  the  LVD  module  is  shown  in Figure 18-2.  A  comparator  uses  an  internally  generated  reference  voltage  as  the  set  point.  When  the selected tap output of the device voltage crosses the set point (is lower than), the LVDIF bit is set.\nEach  node  in  the  resistor  divider  represents  a  'trip point' voltage. The 'trip point' voltage is the minimum supply voltage level at which the device can operate before the LVD module asserts an interrupt. When the supply  voltage  is  equal  to  the  trip  point,  the  voltage tapped  off  of  the  resistor  array  is  equal  to  the  1.2V internal  reference  voltage  generated  by  the  voltage reference module. The comparator then generates an interrupt  signal  setting  the  LVDIF  bit.  This  voltage  is software programmable to any one of 16 values (see Figure 18-2). The trip point is selected by programming the LVDL3:LVDL0 bits (LVDCON<3:0>).",
    "FIGURE 18-2: LOW VOLTAGE DETECT (LVD) BLOCK DIAGRAM\nThe LVD module has an additional feature that allows the user to supply the trip voltage to the module from an  external  source.  This  mode  is  enabled  when  bits LVDL3:LVDL0 are set to 1111 . In this state, the comparator input is multiplexed from the external input pin,\nLVDIN (Figure 18-3). This gives users flexibility, because it allows them to configure the Low Voltage Detect  interrupt  to  occur  at  any  voltage  in  the  valid operating range.",
    "18.1 Control Register\nThe Low Voltage Detect Control register controls the operation of the Low Voltage Detect circuitry.",
    "REGISTER 18-1: LVDCON REGISTER\nU-0, 1 = U-0. U-0, 2 = R-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-1. U-0, 6 = R/W-0. U-0, 7 = R/W-1. -, 1 = -. -, 2 = IRVST. -, 3 = LVDEN. -, 4 = LVDL3. -, 5 = LVDL2. -, 6 = LVDL1. -, 7 = LVDL0\nbit 7\nbit 0",
    "bit 7-6 Unimplemented: Read as '0'\nbit 5\nIRVST: Internal Reference Voltage Stable Flag bit\n1 = Indicates that the Low Voltage Detect logic will generate the interrupt flag at the specified voltage range\n0 = Indicates that the Low Voltage Detect logic will not generate the interrupt flag at the specified voltage range and the LVD interrupt should not be enabled",
    "bit 4 LVDEN: Low Voltage Detect Power Enable bit\n- 1 = Enables LVD, powers up LVD circuit\n0 = Disables LVD, powers down LVD circuit\nLVDL3:LVDL0: Low Voltage Detection Limit bits\n1111 = External analog input is used (input comes from the LVDIN pin)\n1110 = 4.5V - 4.77V\n1101 = 4.2V - 4.45V\n1100 = 4.0V - 4.24V\n1011 = 3.8V - 4.03V\n1010 = 3.6V - 3.82V\n1001 = 3.5V - 3.71V\n1000 = 3.3V - 3.50V\n0111 = 3.0V - 3.18V\n0110 = 2.8V - 2.97V\n0101 = 2.7V - 2.86V\n0100 = 2.5V - 2.65V\n0011 = 2.4V - 2.54V\n0010 = 2.2V - 2.33V\n0001 = 2.0V - 2.12V\n0000 = Reserved\nNote:",
    "bit 4 LVDEN: Low Voltage Detect Power Enable bit\nLVDL3:LVDL0 modes which result in a trip point below the valid operating voltage of the device are not tested.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 3-0",
    "18.2 Operation\nDepending on the power source for the device voltage, the voltage normally decreases relatively slowly. This means that the LVD module does not need to be constantly  operating.  To  decrease  the  current  requirements, the LVD circuitry only needs to be enabled for short  periods,  where  the  voltage  is  checked.  After doing the check, the LVD module may be disabled.\nEach time that the LVD module is enabled, the circuitry requires some time to stabilize. After the circuitry has stabilized, all status flags may be cleared. The module will then indicate the proper state of the system.\nThe  following  steps  are  needed  to  set  up  the  LVD module:",
    "18.2 Operation\n1. Write the value to the LVDL3:LVDL0  bits (LVDCON register),  which  selects  the  desired LVD Trip Point.\n2. Ensure  that  LVD  interrupts  are  disabled  (the LVDIE bit is cleared or the GIE bit is cleared).\n3. Enable the LVD module (set the LVDEN bit in the LVDCON register).\n4. Wait for the LVD module to stabilize (the IRVST bit to become set).\n5. Clear  the  LVD  interrupt  flag,  which  may  have falsely  become  set  until  the  LVD  module  has stabilized (clear the LVDIF bit).\n6. Enable the LVD interrupt (set the LVDIE and the GIE bits).\nFigure 18-4  shows  typical  waveforms  that  the  LVD module may be used to detect.",
    "18.2.1 REFERENCE VOLTAGE SET POINT\nThe Internal Reference Voltage of the LVD module may be used by other internal  circuitry (the  Programmable Brown-out Reset). If these circuits are disabled (lower current consumption), the reference voltage circuit requires a time to become stable before a low voltage condition can be reliably detected. This time is invariant of system clock speed. This start-up time is specified in electrical  specification  parameter  36.  The  low  voltage interrupt flag will not be enabled until a stable reference voltage is reached. Refer to the waveform in Figure 18-4.",
    "18.2.2 CURRENT CONSUMPTION\nWhen the module is enabled, the LVD comparator and voltage divider are enabled and will consume static current. The voltage divider can be tapped from multiple places in the resistor array. Total current consumption, when  enabled,  is  specified  in  electrical  specification parameter #D022B.",
    "18.3 Operation During SLEEP\nWhen enabled, the LVD circuitry continues to operate during  SLEEP.  If  the  device  voltage  crosses  the  trip point, the LVDIF bit will be set and the device will wakeup  from  SLEEP.  Device  execution  will  continue  from the  interrupt  vector  address  if  interrupts  have  been globally enabled.",
    "18.4 Effects of a RESET\nA device RESET forces all registers to their RESET state. This forces the LVD module to be turned off.",
    "PIC18FXX2\nNOTES:",
    "19.0 SPECIAL FEATURES OF THE CPU\nThere are several features intended to maximize system  reliability,  minimize  cost  through  elimination  of external components, provide power saving Operating modes and offer code protection. These are:\nGLYPH<129> OSC Selection\nGLYPH<129> RESET\n-Power-on Reset (POR)\n-Power-up Timer (PWRT)\n-Oscillator Start-up Timer (OST)\n-Brown-out Reset (BOR)\nGLYPH<129> Interrupts\nGLYPH<129> Watchdog Timer (WDT)\nGLYPH<129> SLEEP\nGLYPH<129> Code Protection\nGLYPH<129> ID Locations\nGLYPH<129> In-Circuit Serial Programming",
    "19.0 SPECIAL FEATURES OF THE CPU\nAll PIC18FXX2 devices have a Watchdog Timer, which is  permanently  enabled  via  the  configuration  bits  or software controlled. It runs off its own RC oscillator for added reliability. There are two timers that offer necessary delays on power-up. One is the Oscillator Start-up Timer (OST), intended to keep the chip in RESET until the crystal oscillator is stable. The other is the Powerup  Timer  (PWRT),  which  provides  a  fixed  delay  on power-up only,  designed  to  keep  the  part  in  RESET while the power supply stabilizes. With these two timers on-chip, most applications need no external RESET circuitry.\nSLEEP mode is designed to offer a very low current Power-down  mode.  The  user  can  wake-up  from SLEEP  through  external  RESET,  Watchdog  Timer Wake-up  or  through  an  interrupt.  Several  oscillator options are also made available to allow the part to fit the application. The RC oscillator option saves system cost, while the LP crystal option saves power. A set of configuration bits are used to select various options.",
    "19.1 Configuration Bits\nThe configuration bits can be programmed (read as '0'), or  left  unprogrammed  (read  as  '1'),  to  select  various device configurations. These bits are mapped starting at program memory location 300000h.\nThe user will note that address 300000h is beyond the user program memory space. In fact, it belongs to the configuration  memory  space  (300000h  -  3FFFFFh), which can only be accessed using Table Reads and Table Writes.\nProgramming the configuration registers is done in a manner  similar  to  programming  the  FLASH  memory (see Section 5.5.1). The only difference is the configuration  registers  are  written  a  byte  at  a  time.  The sequence  of  events  for  programming  configuration registers is:",
    "19.1 Configuration Bits\n1. Load table pointer with address of configuration register being written.\n2. Write a single byte using the TBLWT instruction.\n3. Set EEPGD to point to program memory, set the CFGS bit to access configuration registers, and set WREN to enable byte writes.\n4. Disable interrupts.\n5. Write 55h to EECON2.\n6. Write AAh to EECON2.\n7. Set the WR bit. This will begin the write cycle.\n8. CPU will stall for duration of write (approximately 2 ms using internal timer).\n9. Execute a NOP .\n10. Re-enable interrupts.",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\n300001h, File Name = CONFIG1H. 300001h, Bit 7 = -. 300001h, Bit 6 = -. 300001h, Bit 5 = OSCSEN. 300001h, Bit 4 = -. 300001h, Bit 3 = -. 300001h, Bit 2 = FOSC2. 300001h, Bit 1 = FOSC1. 300001h, Bit 0 = FOSC0. 300001h, Default/ Unprogrammed Value = --1- -111. 300002h, File Name = CONFIG2L. 300002h, Bit 7 = -. 300002h, Bit 6 = -. 300002h, Bit 5 = -. 300002h, Bit 4 = -. 300002h, Bit 3 = BORV1. 300002h, Bit 2 = BORV0. 300002h, Bit 1 = BOREN. 300002h, Bit 0 = PWRTEN. 300002h, Default/ Unprogrammed Value = ---- 1111. 300003h, File Name",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\n= CONFIG2H. 300003h, Bit 7 = -. 300003h, Bit 6 = -. 300003h, Bit 5 = -. 300003h, Bit 4 = -. 300003h, Bit 3 = WDTPS2. 300003h, Bit 2 = WDTPS1. 300003h, Bit 1 = WDTPS0. 300003h, Bit 0 = WDTEN. 300003h, Default/ Unprogrammed Value = ---- 1111. 300005h, File Name = CONFIG3H. 300005h, Bit 7 = -. 300005h, Bit 6 = -. 300005h, Bit 5 = -. 300005h, Bit 4 = -. 300005h, Bit 3 = -. 300005h, Bit 2 = -. 300005h, Bit 1 = -. 300005h, Bit 0 = CCP2MX. 300005h, Default/ Unprogrammed Value = ---- ---1. 300006h, File Name =",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\nCONFIG4L. 300006h, Bit 7 = DEBUG. 300006h, Bit 6 = -. 300006h, Bit 5 = -. 300006h, Bit 4 = -. 300006h, Bit 3 = -. 300006h, Bit 2 = LVP. 300006h, Bit 1 = -. 300006h, Bit 0 = STVREN. 300006h, Default/ Unprogrammed Value = 1--- -1-1. 300008h, File Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = CP3. 300008h, Bit 2 = CP2. 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300008h, Default/ Unprogrammed Value = ---- 1111. 300009h, File Name =",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\nCONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -. 300009h, Bit 0 = -. 300009h, Default/ Unprogrammed Value = 11-- ----. 30000Ah, File Name = CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -. 30000Ah, Bit 4 = -. 30000Ah, Bit 3 = WRT3. 30000Ah, Bit 2 = WRT2. 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Ah, Default/ Unprogrammed Value = ---- 1111. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD.",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\n30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Bh, Default/ Unprogrammed Value = 111- ----. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = EBTR3. 30000Ch, Bit 2 = EBTR2. 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Ch, Default/ Unprogrammed Value = ---- 1111. 30000Dh, File Name = CONFIG7H. 30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -.",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\n30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -. 30000Dh, Default/ Unprogrammed Value = -1-- ----. 3FFFFEh, File Name = DEVID1. 3FFFFEh, Bit 7 = DEV2. 3FFFFEh, Bit 6 = DEV1. 3FFFFEh, Bit 5 = DEV0. 3FFFFEh, Bit 4 = REV4. 3FFFFEh, Bit 3 = REV3. 3FFFFEh, Bit 2 = REV2. 3FFFFEh, Bit 1 = REV1. 3FFFFEh, Bit 0 = REV0. 3FFFFEh, Default/ Unprogrammed Value = (1). 3FFFFFh, File Name = DEVID2. 3FFFFFh, Bit 7 = DEV10. 3FFFFFh, Bit 6 = DEV9. 3FFFFFh, Bit 5 = DEV8. 3FFFFFh, Bit 4 = DEV7.",
    "TABLE 19-1: CONFIGURATION BITS AND DEVICE IDS\n3FFFFFh, Bit 3 = DEV6. 3FFFFFh, Bit 2 = DEV5. 3FFFFFh, Bit 1 = DEV4. 3FFFFFh, Bit 0 = DEV3. 3FFFFFh, Default/ Unprogrammed Value = 0000 0100\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition.\nShaded cells are unimplemented, read as '0'.\nNote 1: See Register 19-12 for DEVID1 values.",
    "REGISTER 19-1: CONFIGURATION REGISTER 1 HIGH (CONFIG1H: BYTE ADDRESS 300001h)\nU-0, 1 = U-0. U-0, 2 = R/P-1. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = OSCSEN. -, 3 = -. -, 4 = -. -, 5 = FOSC2. -, 6 = FOSC1. -, 7 = FOSC0\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as '0'\nbit 5\nOSCSEN : Oscillator System Clock Switch Enable bit\n1 = Oscillator system clock switch option is disabled (main oscillator is source)\n0 = Oscillator system clock switch option is enabled (oscillator switching is enabled)\nbit 4-3 Unimplemented: Read as '0'",
    "bit 2-0 FOSC2:FOSC0 : Oscillator Selection bits\n111 = RC oscillator w/ OSC2 configured as RA6\n110 = HS oscillator with PLL enabled/Clock frequency = (4 x FOSC)\n101 = EC oscillator w/ OSC2 configured as RA6\n100 = EC oscillator w/ OSC2 configured as divide-by-4 clock output\n011 = RC oscillator\n010 = HS oscillator\n001 = XT oscillator\n000 = LP oscillator",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "CONFIGURATION REGISTER 2 LOW (CONFIG2L: BYTE ADDRESS 300002h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = BORV1. -, 5 = BORV0. -, 6 = BOREN. -, 7 = PWRTEN\nbit 7\nbit 0",
    "bit 7-4 Unimplemented: Read as '0'\nbit 3-2\nBORV1:BORV0:\nBrown-out Reset Voltage bits\n11 = VBOR set to 2.5V\n10 = VBOR set to 2.7V\n01 = VBOR set to 4.2V\n00 = VBOR set to 4.5V",
    "bit 1 BOREN: Brown-out Reset Enable bit\n1 = Brown-out Reset enabled\n0 = Brown-out Reset disabled",
    "bit 0\nPWRTEN: Power-up Timer Enable bit\n1 = PWRT disabled\n0 = PWRT enabled\nLegend:, 1 = Legend:. R = Readable bit P = Programmable bit, 1 = U = Unimplemented bit, read as '0'. - n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 19-3: CONFIGURATION REGISTER 2 HIGH (CONFIG2H: BYTE ADDRESS 300003h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = WDTPS2. -, 5 = WDTPS1. -, 6 = WDTPS0. -, 7 = WDTEN\nbit 7\nbit 0\nbit 7-4\nUnimplemented: Read as '0'\nbit 3-1 WDTPS2:WDTPS0: Watchdog Timer Postscale Select bits\n111 = 1:128\n110 = 1:64\n101 = 1:32\n100 = 1:16\n011 = 1:8\n010 = 1:4\n001 = 1:2\n000 = 1:1",
    "bit 0 WDTEN: Watchdog Timer Enable bit\n1 = WDT enabled\n0 = WDT disabled (control is placed on the SWDTEN bit)\nLegend:, 1 = Legend:. R = Readable bit P = Programmable, 1 = U = Unimplemented bit, read as '0'. - n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 19-4: CONFIGURATION REGISTER 3 HIGH (CONFIG3H: BYTE ADDRESS 300005h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = CCP2MX\nbit 7\nbit 0",
    "bit 7-1 Unimplemented: Read as '0'\nbit 0\nCCP2MX: CCP2 Mux bit\n1 = CCP2 input/output is multiplexed with RC1\n0 = CCP2 input/output is multiplexed with RB3",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 19-5: CONFIGURATION REGISTER 4 LOW (CONFIG4L: BYTE ADDRESS 300006h)\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = R/P-1. R/P-1, 6 = U-0. R/P-1, 7 = R/P-1. BKBUG, 1 = -. BKBUG, 2 = -. BKBUG, 3 = -. BKBUG, 4 = -. BKBUG, 5 = LVP. BKBUG, 6 = -. BKBUG, 7 = STVREN\nbit 7\nbit 0\nbit 7 DEBUG:\nBackground Debugger Enable bit\n1 = Background Debugger disabled. RB6 and RB7 configured as general purpose I/O pins.\n0 = Background Debugger enabled. RB6 and RB7 are dedicated to In-Circuit Debug.\nbit 6-3 Unimplemented: Read as '0'",
    "REGISTER 19-5: CONFIGURATION REGISTER 4 LOW (CONFIG4L: BYTE ADDRESS 300006h)\nbit 2 LVP: Low Voltage ICSP Enable bit\n1 = Low Voltage ICSP enabled\n0 = Low Voltage ICSP disabled\nbit 1 Unimplemented: Read as '0'\nbit 0 STVREN: Stack Full/Underflow Reset Enable bit\n1 = Stack Full/Underflow will cause RESET\n0 = Stack Full/Underflow will not cause RESET",
    "Legend:\nR = Readable bit\nC = Clearable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 19-6: CONFIGURATION REGISTER 5 LOW (CONFIG5L: BYTE ADDRESS 300008h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = CP3 (1). -, 5 = CP2 (1). -, 6 = CP1. -, 7 = CP0\nbit 7\nbit 0",
    "bit 7-4 Unimplemented: Read as '0'\nbit 3 CP3: Code Protection bit (1)\n1 = Block 3 (006000-007FFFh) not code protected\n0 = Block 3 (006000-007FFFh) code protected",
    "bit 2 CP2: Code Protection bit (1)\n1 = Block 2 (004000-005FFFh) not code protected\n0 = Block 2 (004000-005FFFh) code protected",
    "bit 1 CP1: Code Protection bit\n1 = Block 1 (002000-003FFFh) not code protected\n0 = Block 1 (002000-003FFFh) code protected",
    "bit 0 CP0: Code Protection bit\n1 = Block 0 (000200-001FFFh) not code protected\n0 = Block 0 (000200-001FFFh) code protected\nNote 1: Unimplemented in PIC18FX42 devices; maintain this bit set.\n\nLegend:, 1 = Legend:. R = Readable bit C = Clearable bit, 1 = U = Unimplemented bit, read as '0'. - n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 19-7: CONFIGURATION REGISTER 5 HIGH (CONFIG5H: BYTE ADDRESS 300009h)\nR/C-1, 1 = R/C-1. R/C-1, 2 = U-0. R/C-1, 3 = U-0. R/C-1, 4 = U-0. R/C-1, 5 = U-0. R/C-1, 6 = U-0. R/C-1, 7 = U-0. CPD, 1 = CPB. CPD, 2 = -. CPD, 3 = -. CPD, 4 = -. CPD, 5 = -. CPD, 6 = -. CPD, 7 = -\nbit 7\nbit 0",
    "bit 7 CPD: Data EEPROM Code Protection bit\n1 = Data EEPROM not code protected\n0 = Data EEPROM code protected",
    "bit 6 CPB: Boot Block Code Protection bit\n1 = Boot Block (000000-0001FFh) not code protected\n0 = Boot Block (000000-0001FFh) code protected",
    "bit 5-0 Unimplemented: Read as '0'\nLegend:, 1 = Legend:. R = Readable bit C = Clearable bit, 1 = U = Unimplemented bit, read as '0'. - n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 19-8: CONFIGURATION REGISTER 6 LOW (CONFIG6L: BYTE ADDRESS 30000Ah)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = WRT3 (1). -, 5 = WRT2 (1). -, 6 = WRT1. -, 7 = WRT0\nbit 7\nbit 0",
    "bit 7-4 Unimplemented: Read as '0'\nbit 3 WRT3: Write Protection bit (1)\n1 = Block 3 (006000-007FFFh) not write protected\n0 = Block 3 (006000-007FFFh) write protected",
    "bit 2 WRT2: Write Protection bit (1)\n1 = Block 2 (004000-005FFFh) not write protected\n0 = Block 2 (004000-005FFFh) write protected",
    "bit 1 WRT1: Write Protection bit\n1 = Block 1 (002000-003FFFh) not write protected\n0 = Block 1 (002000-003FFFh) write protected",
    "bit 0 WRT0: Write Protection bit\n1 = Block 0 (000200h-001FFFh) not write protected\n0 = Block 0 (000200h-001FFFh) write protected\nNote 1: Unimplemented in PIC18FX42 devices; maintain this bit set.\n\nLegend:, 1 = Legend:. R = Readable bit C = Clearable bit, 1 = U = Unimplemented bit, read as '0'. - n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 19-9: CONFIGURATION REGISTER 6 HIGH (CONFIG6H: BYTE ADDRESS 30000Bh)\nR/C-1, 1 = R/C-1. R/C-1, 2 = C-1. R/C-1, 3 = U-0. R/C-1, 4 = U-0. R/C-1, 5 = U-0. R/C-1, 6 = U-0. R/C-1, 7 = U-0. WRTD, 1 = WRTB. WRTD, 2 = WRTC. WRTD, 3 = -. WRTD, 4 = -. WRTD, 5 = -. WRTD, 6 = -. WRTD, 7 = -\nbit 7\nbit 0",
    "bit 7 WRTD: Data EEPROM Write Protection bit\n1 = Data EEPROM not write protected\n0 = Data EEPROM write protected",
    "bit 6 WRTB: Boot Block Write Protection bit\n1 = Boot Block (000000-0001FFh) not write protected\n0 = Boot Block (000000-0001FFh) write protected",
    "bit 5 WRTC: Configuration Register Write Protection bit\n1 = Configuration registers (300000-3000FFh) not write protected\n0 = Configuration registers (300000-3000FFh) write protected\nNote: This bit is read only, and cannot be changed in User mode.",
    "bit 4-0 Unimplemented: Read as '0'\nLegend:\nR = Readable bit\nC =Clearable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 19-10: CONFIGURATION REGISTER 7 LOW (CONFIG7L: BYTE ADDRESS 30000Ch)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = EBTR3 (1). -, 5 = EBTR2 (1). -, 6 = EBTR1. -, 7 = EBTR0\nbit 7\nbit 0",
    "bit 3\nEBTR3: Table Read Protection bit (1)\n1 = Block 3 (006000-007FFFh) not protected from Table Reads executed in other blocks\n0 = Block 3 (006000-007FFFh) protected from Table Reads executed in other blocks\nbit 2 EBTR2: Table Read Protection bit (1)\n1 = Block 2 (004000-005FFFh) not protected from Table Reads executed in other blocks\n0 = Block 2 (004000-005FFFh) protected from Table Reads executed in other blocks",
    "bit 1 EBTR1: Table Read Protection bit\n1 = Block 1 (002000-003FFFh) not protected from Table Reads executed in other blocks\n0 = Block 1 (002000-003FFFh) protected from Table Reads executed in other blocks\nbit 0 EBTR0: Table Read Protection bit\n1 = Block 0 (000200h-001FFFh) not protected from Table Reads executed in other blocks\n0 = Block 0 (000200h-001FFFh) protected from Table Reads executed in other blocks\nNote 1: Unimplemented in PIC18FX42 devices; maintain this bit set.\n\nLegend:, 1 = Legend:. R = Readable bit C = Clearable bit, 1 = U = Unimplemented bit, read as '0'. - n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 19-11: CONFIGURATION REGISTER 7 HIGH (CONFIG7H: BYTE ADDRESS 30000Dh)\nU-0, 1 = R/C-1. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = U-0. -, 1 = EBTRB. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = -\nbit 7\nbit 0",
    "bit 7 Unimplemented: Read as '0'\n- bit 6 EBTRB:\nBoot Block Table Read Protection bit\n1 = Boot Block (000000-0001FFh) not protected from Table Reads executed in other blocks\n0 = Boot Block (000000-0001FFh) protected from Table Reads executed in other blocks",
    "bit 5-0 Unimplemented: Read as '0'\nLegend:, 1 = Legend:. R = Readable bit C =Clearable bit, 1 = U = Unimplemented bit, read as '0'. - n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 19-12: DEVICE ID REGISTER 1 FOR PIC18FXX2 (DEVID1: BYTE ADDRESS 3FFFFEh)\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV2, 1 = DEV1. DEV2, 2 = DEV0. DEV2, 3 = REV4. DEV2, 4 = REV3. DEV2, 5 = REV2. DEV2, 6 = REV1. DEV2, 7 = REV0\nbit 7\nbit 0",
    "bit 7-5 DEV2:DEV0: Device ID bits\n000 = PIC18F252\n001 = PIC18F452\n100 = PIC18F242\n101 = PIC18F442",
    "bit 4-0 REV4:REV0: Revision ID bits\nThese bits are used to indicate the device revision.",
    "Legend:\nR = Readable bit\nP =Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 19-13: DEVICE ID REGISTER 2 FOR PIC18FXX2 (DEVID2: BYTE ADDRESS 3FFFFFh)\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV10, 1 = DEV9. DEV10, 2 = DEV8. DEV10, 3 = DEV7. DEV10, 4 = DEV6. DEV10, 5 = DEV5. DEV10, 6 = DEV4. DEV10, 7 = DEV3\nbit 7\nbit 0",
    "bit 7-0 DEV10:DEV3: Device ID bits\nThese bits are used with the DEV2:DEV0 bits in the Device ID Register 1 to identify the part number.",
    "Legend:\nR = Readable bit\nP =Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "19.2 Watchdog Timer (WDT)\nThe Watchdog Timer is a free running on-chip RC oscillator, which does not require any external components. This RC oscillator is separate from the RC oscillator of the OSC1/CLKI pin. That means that the WDT will run, even if the clock on the OSC1/CLKI and OSC2/CLKO/ RA6 pins of the device has been stopped, for example, by execution of a SLEEP instruction.\nDuring normal operation, a WDT time-out generates a device RESET (Watchdog Timer Reset). If the device is in SLEEP mode, a WDT time-out causes the device to wake-up and continue with normal operation (Watchdog Timer Wake-up). The TO bit in the RCON register will be cleared upon a WDT time-out.\nThe Watchdog Timer is enabled/disabled by a device configuration bit. If the WDT is enabled, software execution may not disable this function. When the WDTEN configuration bit is cleared, the SWDTEN bit enables/ disables the operation of the WDT.",
    "19.2 Watchdog Timer (WDT)\nThe WDT time-out period values may be found in the Electrical Specifications (Section 22.0) under parameter  D031.  Values  for  the  WDT  postscaler  may  be assigned using the configuration bits.\nNote:, 1 = The CLRWDT and SLEEP instructions clear the WDT and the postscaler, if assigned to the WDTand prevent it from timing out and generating a device RESET condition.\nNote:\nWhen  a CLRWDT instruction  is  executed and the postscaler is assigned to the WDT, the postscaler count will be cleared, but the postscaler assignment is not changed.",
    "19.2.1 CONTROL REGISTER\nRegister 19-14 shows the WDTCON register. This is a readable and writable register, which contains a control bit  that  allows  software  to  override  the  WDT  enable configuration bit,  only  when  the  configuration  bit  has disabled the WDT.",
    "REGISTER 19-14: WDTCON REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = SWDTEN\nbit 7\nbit 0",
    "bit 7-1 Unimplemented : Read as '0'\nbit 0\nSWDTEN: Software Controlled Watchdog Timer Enable bit\n1 = Watchdog Timer is on\n0 = Watchdog Timer is turned off if the WDTEN configuration bit in the configuration register = '0'\nLegend:, 1 = Legend:. R = Readable bit, 1 = W=Writable bit. U = Unimplemented bit, read as '0', 1 = - n = Value at POR",
    "19.2.2 WDT POSTSCALER\nThe WDT has a postscaler that can extend the WDT Reset period. The postscaler is selected at the time of the  device  programming,  by  the  value  written  to  the CONFIG2H configuration register.",
    "TABLE 19-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nCONFIG2H, Bit 7 = -. CONFIG2H, Bit 6 = -. CONFIG2H, Bit 5 = -. CONFIG2H, Bit 4 = -. CONFIG2H, Bit 3 = WDTPS2. CONFIG2H, Bit 2 = WDTPS2. CONFIG2H, Bit 1 = WDTPS0. CONFIG2H, Bit 0 = WDTEN. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. WDTCON, Bit 7 = -. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTEN",
    "TABLE 19-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nLegend: Shaded cells are not used by the Watchdog Timer.",
    "19.3 Power-down Mode (SLEEP)\nPower-down mode is entered by executing a SLEEP instruction.\nIf  enabled,  the  Watchdog  Timer  will  be  cleared,  but keeps running, the PD bit (RCON<3>) is cleared, the TO (RCON<4>) bit is set, and the oscillator driver is turned off. The I/O ports maintain the status they had before  the SLEEP instruction  was  executed  (driving high, low or hi-impedance).\nFor lowest current consumption in this mode, place all I/O pins at either VDD or VSS, ensure no external circuitry is drawing current from the I/O pin, power-down the A/D and disable external clocks. Pull all I/O pins that are hi-impedance inputs, high or low externally, to avoid switching currents caused by floating inputs. The T0CKI input should also be at VDD or VSS for lowest current  consumption.  The  contribution  from  on-chip pull-ups on PORTB should be considered.\nThe MCLR pin must be at a logic high level (VIHMC).",
    "19.3.1 WAKE-UP FROM SLEEP\nThe device can wake-up from SLEEP through one of the following events:\n1. External RESET input on MCLR pin.\n2. Watchdog Timer Wake-up (if WDT was enabled).\n3. Interrupt  from  INT  pin,  RB  port  change  or  a Peripheral Interrupt.\nThe following peripheral interrupts can wake the device from SLEEP:\n1. PSP read or write.\n2. TMR1 interrupt.   Timer1 must be operating as an asynchronous counter.\n3. TMR3 interrupt.   Timer3 must be operating as an asynchronous counter.\n4. CCP Capture mode interrupt.\n5. Special event trigger (Timer1 in Asynchronous mode using an external clock).\n6. MSSP (START/STOP) bit detect interrupt.\n7. MSSP transmit or receive in Slave mode (SPI/I 2 C).\n8. USART RX or TX (Synchronous Slave mode).\n9. A/D conversion (when A/D clock source is RC).\n10. EEPROM write operation complete.\n11. LVD interrupt.",
    "19.3.1 WAKE-UP FROM SLEEP\nOther  peripherals  cannot  generate  interrupts,  since during SLEEP, no on-chip clocks are present.\nExternal MCLR Reset will cause a device RESET. All other events are considered a continuation of program execution and will cause a 'wake-up'. The TO and PD bits in the RCON register can be used to determine the cause of the device RESET. The PD bit, which is set on power-up, is cleared when SLEEP is invoked. The TO bit is cleared, if a WDT time-out occurred (and caused wake-up).",
    "19.3.1 WAKE-UP FROM SLEEP\nWhen the SLEEP instruction is being executed, the next instruction (PC + 2) is pre-fetched. For the device to wake-up through an interrupt event, the corresponding interrupt enable bit must be set (enabled). Wake-up is regardless of the state of the GIE bit. If the GIE bit is clear (disabled), the device continues execution at the instruction after the SLEEP instruction. If the GIE bit is set (enabled), the device executes the instruction after the SLEEP instruction and then branches to the interrupt  address.  In  cases  where  the  execution  of  the instruction  following SLEEP is  not  desirable,  the user should have a NOP after the SLEEP instruction.",
    "19.3.2 WAKE-UP USING INTERRUPTS\nWhen global interrupts are disabled (GIE cleared) and any interrupt  source  has  both  its  interrupt  enable  bit and interrupt flag bit set, one of the following will occur:\nGLYPH<129> If an interrupt condition (interrupt flag bit and interrupt enable bits are set) occurs before the execution of a SLEEP instruction, the SLEEP instruction will complete as a NOP . Therefore, the WDT and WDT postscaler will not be cleared, the TO bit will not be set and PD bits will not be cleared.\nGLYPH<129> If the interrupt condition occurs during or after the execution of a SLEEP instruction, the device will immediately wake-up from SLEEP. The SLEEP instruction will be completely executed before the wake-up. Therefore, the WDT and WDT postscaler will be cleared, the TO bit will be set and the PD bit will be cleared.\nEven if the flag bits were checked before executing a SLEEP instruction,  it  may  be  possible  for  flag  bits  to become set before the SLEEP instruction completes. To determine whether a SLEEP instruction executed, test the PD bit. If the PD bit is set, the SLEEP instruction was executed as a NOP .",
    "19.3.2 WAKE-UP USING INTERRUPTS\nTo ensure that the WDT is cleared, a CLRWDT instruction should be executed before a SLEEP instruction.",
    "FIGURE 19-2: WAKE-UP FROM SLEEP THROUGH INTERRUPT (1,2)\nNote\n1: XT, HS or LP Oscillator mode assumed.\n2: GIE = '1' assumed. In this case, after wake-up, the processor jumps to the interrupt routine. If GIE = '0', execution will continue in-line.\n3: TOST = 1024 TOSC (drawing not to scale). This delay will not occur for RC and EC Osc modes.\n4: CLKO is not available in these Osc modes, but shown here for timing reference.",
    "19.4 Program Verification and Code Protection\nThe  overall  structure  of  the  code  protection  on  the PIC18 FLASH devices differs significantly from other PICmicro devices.\nEach of the five blocks has three code protection bits associated with them. They are:\nGLYPH<129> Code Protect bit (CPn)\nGLYPH<129> Write Protect bit (WRTn)\nGLYPH<129> External Block Table Read bit (EBTRn)\nThe user program memory is divided into five blocks. One of these is a boot block of 512 bytes. The remainder of the memory is divided into four blocks on binary boundaries.\nFigure 19-3 shows the program memory organization for  16-  and  32-Kbyte  devices,  and  the  specific  code protection bit  associated with each block. The actual locations of the bits are summarized in Table 19-3.",
    "FIGURE 19-3: CODE PROTECTED PROGRAM MEMORY FOR PIC18F2XX/4XX\nBoot Block, MEMORY SIZE/DEVICE.32 Kbytes (PIC18FX52) = Boot Block. Boot Block, Address Range = 000000h 0001FFh. Boot Block, Block Code Protection.Controlled By: = CPB, WRTB, EBTRB. Block 0, MEMORY SIZE/DEVICE.32 Kbytes (PIC18FX52) = Block 0. Block 0, Address Range = 000200h 001FFFh. Block 0, Block Code Protection.Controlled By: = CP0, WRT0, EBTR0. Block 1, MEMORY SIZE/DEVICE.32 Kbytes (PIC18FX52) = Block 1. Block 1, Address Range = 002000h 003FFFh. Block 1, Block Code Protection.Controlled By: = CP1, WRT1, EBTR1. Unimplemented Read 0's, MEMORY SIZE/DEVICE.32 Kbytes (PIC18FX52) = Block 2. Unimplemented Read 0's, Address Range = 004000h 005FFFh.",
    "FIGURE 19-3: CODE PROTECTED PROGRAM MEMORY FOR PIC18F2XX/4XX\nUnimplemented Read 0's, Block Code Protection.Controlled By: = CP2, WRT2, EBTR2. Unimplemented Read 0's, MEMORY SIZE/DEVICE.32 Kbytes (PIC18FX52) = Block 3. Unimplemented Read 0's, Address Range = 006000h 007FFFh. Unimplemented Read 0's, Block Code Protection.Controlled By: = CP3, WRT3, EBTR3. Unimplemented Read 0's, MEMORY SIZE/DEVICE.32 Kbytes (PIC18FX52) = Unimplemented Read 0's. Unimplemented Read 0's, Address Range = (Unimplemented Memory Space). Unimplemented Read 0's, Block Code Protection.Controlled By: = (Unimplemented Memory Space)",
    "TABLE 19-3: SUMMARY OF CODE PROTECTION REGISTERS\n300008h, File Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = CP3. 300008h, Bit 2 = CP2. 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -. 300009h, Bit 0 = -. 30000Ah, File Name = CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -. 30000Ah, Bit 4 = -.",
    "TABLE 19-3: SUMMARY OF CODE PROTECTION REGISTERS\n30000Ah, Bit 3 = WRT3. 30000Ah, Bit 2 = WRT2. 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = EBTR3. 30000Ch, Bit 2 = EBTR2. 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Dh, File Name = CONFIG7H.",
    "TABLE 19-3: SUMMARY OF CODE PROTECTION REGISTERS\n30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -\nLegend:  Shaded cells are unimplemented.",
    "19.4.1 PROGRAM MEMORY CODE PROTECTION\nThe user memory may be read to or written from any location using the Table Read and Table Write instructions.  The device ID may be read with Table Reads. The configuration  registers  may  be  read  and  written with the Table Read and Table Write instructions.\noutside  of  that  block  is  not  allowed  to  read,  and  will result in reading '0's. Figures 19-4 through 19-6 illustrate Table Write and Table Read protection.\nNote:\nIn User mode, the CPn bits have no direct effect. CPn bits inhibit external reads and writes. A block of user memory  may  be  protected  from  Table  Writes  if  the WRTn configuration bit is ' 0 '.  The EBTRn bits control Table  Reads.  For  a  block  of  user  memory  with  the EBTRn bit set  to  ' 0', a  T able  Read  instruction  that executes from within that block is allowed to read. A Table  Read  instruction  that  executes  from  a  location",
    "19.4.1 PROGRAM MEMORY CODE PROTECTION\nCode protection bits may only be written to a '0' from a '1' state. It is not possible to write a '1' to a bit in the '0' state. Code protection bits are only set to '1' by a full chip erase or block erase function. The full chip erase and block erase functions can only be initiated via ICSP or an external programmer.",
    "FIGURE 19-4: TABLE WRITE (WRTn) DISALLOWED\nTBLPTR = 000FFF PC = 001FFE, Program Memory = TBLWT *. TBLPTR = 000FFF PC = 001FFE, Program Memory = 000000h 0001FFh 000200h 001FFFh 002000h 003FFFh 004000h 005FFFh 006000h. TBLPTR = 000FFF PC = 001FFE, Configuration Bit Settings = WRTB,EBTRB WRT0,EBTR0 = 01. PC = 004FFE, Program Memory = TBLWT *. PC = 004FFE, Program Memory = 007FFFh. PC = 004FFE, Configuration Bit Settings = WRT2,EBTR2 = 11 WRT3,EBTR3 = 11. Results: All Table Writes disabled to Blockn whenever WRTn = '0'., Program Memory = Results: All Table Writes disabled to Blockn whenever WRTn = '0'.. Results: All Table Writes disabled to Blockn whenever WRTn = '0'., Program Memory = Results: All Table Writes disabled to Blockn whenever",
    "FIGURE 19-4: TABLE WRITE (WRTn) DISALLOWED\nWRTn = '0'.. Results: All Table Writes disabled to Blockn whenever WRTn = '0'., Configuration Bit Settings = Results: All Table Writes disabled to Blockn whenever WRTn = '0'.",
    "FIGURE 19-5: EXTERNAL BLOCK TABLE READ (EBTRn) DISALLOWED\nTBLPTR = 000FFF, Program Memory = 000000h 0001FFh 000200h. TBLPTR = 000FFF, Configuration Bit Settings = WRT0,EBTR0 = 10. PC = 002FFE, Program Memory = TBLRD *. PC = 002FFE, Configuration Bit Settings = WRT1,EBTR1 = 11 WRT2,EBTR2 = 11 WRT3,EBTR3 = 11. Results: All Table Reads from external blocks to Blockn are disabled whenever EBTRn = '0'. TABLAT register returns a value of '0'., Program Memory = Results: All Table Reads from external blocks to Blockn are disabled whenever EBTRn = '0'. TABLAT register returns a value of '0'.. Results: All Table Reads from external blocks to Blockn are disabled whenever EBTRn = '0'. TABLAT register returns a value of '0'., Configuration Bit Settings = Results: All Table Reads from external blocks to Blockn are disabled whenever EBTRn = '0'. TABLAT register returns a value",
    "FIGURE 19-5: EXTERNAL BLOCK TABLE READ (EBTRn) DISALLOWED\nof '0'.",
    "FIGURE 19-6: EXTERNAL BLOCK TABLE READ (EBTRn) ALLOWED\nTBLPTR = 000FFF, Program Memory = . TBLPTR = 000FFF, Configuration Bit Settings = WRT0,EBTR0 = 10. PC = 001FFE, Program Memory = 001FFFh 002000h 003FFFh 004000h 005FFFh 006000h TBLRD *. PC = 001FFE, Configuration Bit Settings = WRT1,EBTR1 = 11 WRT2,EBTR2 = 11 WRT3,EBTR3 = 11. Results: Table Reads permitted within Blockn, even when EBTRBn = '0'. TABLAT register returns the value of the data at the location, Program Memory = . Results: Table Reads permitted within Blockn, even when EBTRBn = '0'. TABLAT register returns the value of the data at the location, Configuration Bit Settings = TBLPTR.",
    "19.4.2 DATA EEPROM CODE PROTECTION\nThe entire  Data EEPROM is protected from external reads and writes by two bits: CPD and WRTD. CPD inhibits  external  reads  and  writes  of  Data  EEPROM. WRTD inhibits external writes to Data EEPROM. The CPU can continue to read and write Data EEPROM regardless of the protection bit settings.",
    "19.4.3 CONFIGURATION REGISTER PROTECTION\nThe configuration registers can be write protected. The WRTC bit controls protection of the configuration registers. In User mode, the WRTC bit is readable only. WRTC can only be written via ICSP or an external programmer.",
    "19.5 ID Locations\nEight memory locations (200000h - 200007h) are designated  as  ID  locations,  where  the  user  can  store checksum or other code identification numbers. These locations are accessible during normal execution through the TBLRD and TBLWT instructions, or during program/verify. The ID locations can be read when the device is code protected.\nThe sequence for programming the ID locations is similar to programming the FLASH memory (see Section 5.5.1).",
    "19.6 In-Circuit Serial Programming\nPIC18FXXX  microcontrollers can be serially programmed while in the end application circuit. This is simply done with two lines for clock and data, and three other  lines  for  power,  ground  and  the  programming voltage. This allows customers to manufacture boards with  unprogrammed  devices,  and  then  program  the microcontroller just before shipping the product. This also  allows  the  most  recent  firmware  or  a  custom firmware to be programmed.",
    "19.7 In-Circuit Debugger\nWhen the DEBUG bit in configuration register CONFIG4L  is  programmed  to  a  '0',  the  In-Circuit Debugger functionality is enabled. This function allows simple debugging functions when used with MPLAB fi IDE. When the microcontroller has this feature enabled, some of the resources are not available for general  use.  Table 19-4  shows  which  features  are consumed by the background debugger.\nTABLE 19-4: DEBUGGER RESOURCES\n\nStack, RB6, RB7 = 2 levels. Program Memory, RB6, RB7 = 512 bytes. Data Memory, RB6, RB7 = 10 bytes\nTo use the In-Circuit Debugger function of the microcontroller, the design must implement In-Circuit Serial Programming connections to MCLR/VPP, VDD, GND, RB7  and  RB6.  This  will  interface  to  the  In-Circuit Debugger module available from Microchip or one of the third party development tool companies.",
    "19.8 Low Voltage ICSP Programming\nThe LVP bit configuration register CONFIG4L enables low voltage ICSP programming. This mode allows the microcontroller  to  be  programmed  via  ICSP  using  a VDD source in the operating voltage range. This only means that VPP does not have to be brought to VIHH, but can instead be left at the normal operating voltage. In this mode, the RB5/PGM pin is dedicated to the programming function and ceases to be a general purpose I/O  pin.  During  programming,  VDD  is  applied  to  the MCLR/VPP pin. To enter Programming mode, VDD must be applied to the RB5/PGM, provided the LVP bit is set. The LVP bit defaults to a ('1') from the factory.",
    "19.8 Low Voltage ICSP Programming\nNote 1: The High Voltage Programming mode is always available, regardless of the state of  the  LVP  bit,  by  applying  VIHH  to  the MCLR pin.\n2: While in low voltage ICSP mode, the RB5 pin can no longer be used as a general purpose I/O pin, and should be held low during normal operation to protect against inadvertent ICSP mode entry.\n3: When using low voltage ICSP programming (LVP), the pull-up on RB5 becomes disabled. If TRISB  bit 5 is cleared, thereby setting RB5 as an output, LATB bit  5  must  also  be  cleared  for  proper operation.\nIf Low Voltage Programming mode is not used, the LVP bit can be programmed to a '0' and RB5/PGM becomes a digital I/O pin. However, the LVP bit may only be programmed when programming is entered with VIHH on MCLR/VPP.\nIt should be noted that once the LVP bit is programmed to 0, only the High Voltage Programming mode is available and only High Voltage Programming mode can be used to program the device.",
    "19.8 Low Voltage ICSP Programming\nWhen using low voltage ICSP, the part must be supplied 4.5V to 5.5V, if a bulk erase will be executed. This includes reprogramming of the code protect bits from an on-state to off-state. For all other cases of low voltage ICSP, the part may be programmed at the normal operating voltage. This means unique user IDs, or user code can be reprogrammed or added.",
    "20.0 INSTRUCTION SET SUMMARY\nThe PIC18FXXX instruction set adds many enhancements to the previous PICmicro instruction sets, while maintaining  an  easy  migration  from  these  PICmicro instruction sets.\nMost instructions are a single program memory word (16-bits),  but  there  are  three  instructions  that  require two program memory locations.\nEach single word instruction is a 16-bit word divided into an OPCODE, which specifies the instruction type and one or more operands, which further specify the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\nGLYPH<129> Byte-oriented operations\nGLYPH<129> Bit-oriented operations\nGLYPH<129> Literal operations\nGLYPH<129> Control operations\nThe PIC18FXXX instruction set summary in Table 20-2 lists byte-oriented , bit-oriented , literal and control operations. Table 20-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The destination of the result (specified by 'd')\n3. The accessed memory (specified by 'a')",
    "20.0 INSTRUCTION SET SUMMARY\nThe  file  register  designator  'f'  specifies  which  file register is to be used by the instruction.\nThe  destination  designator  'd'  specifies  where  the result of the operation is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result  is  placed  in  the  file  register  specified  in  the instruction.\nAll bit-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The bit in the file register (specified by 'b')\n3. The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\nGLYPH<129> A literal value to be loaded into a file register (specified by 'k')\nGLYPH<129> The desired FSR register to load the literal value into (specified by 'f')\nGLYPH<129> No operand required (specified by '-')",
    "20.0 INSTRUCTION SET SUMMARY\nThe control instructions may use some of the following operands:\nGLYPH<129> A program memory address (specified by 'n')\nGLYPH<129> The mode of the Call or Return instructions (specified by 's')\nGLYPH<129> The mode of the Table Read and Table Write instructions (specified by 'm')\nGLYPH<129> No operand required (specified by '-')\nAll instructions are a single word, except for three double-word  instructions.  These  three  instructions  were made double-word instructions so that all the required information is available in these 32 bits. In the second word, the 4-MSbs are 1's. If this second word is executed as an instruction (by itself), it will execute as a NOP .\nAll  single  word  instructions  are  executed  in  a  single instruction cycle, unless a conditional test is true or the program counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles with the additional instruction cycle(s) executed as a NOP .\nThe double-word instructions execute in two instruction cycles.",
    "20.0 INSTRUCTION SET SUMMARY\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \u00b5 s. If a conditional test is true or the program counter is changed as a result of an instruction,  the  instruction  execution  time  is  2 \u00b5 s. Two-word branch instructions (if true) would take 3 \u00b5 s.\nFigure 20-1 shows the general formats that the instructions can have.\nAll  examples  use  the  format 'nnh' to  represent  a hexadecimal number, where 'h' signifies a hexadecimal digit.\nThe  Instruction  Set  Summary,  shown  in  Table 20-2, lists the instructions recognized  by  the  Microchip Assembler (MPASM TM ).\nSection 20.1 provides a description of each instruction.",
    "TABLE 20-1: OPCODE FIELD DESCRIPTIONS\na, Description = RAM access bit a = 0: RAM location in Access RAM (BSR register is ignored) a = 1: RAM bank is specified by BSR register. bbb, Description = Bit address within an 8-bit file register (0 to 7). BSR, Description = Bank Select Register. Used to select the current RAM bank.. d, Description = Destination select bit; d = 0: store result in WREG, d = 1: store result in file register f.. dest, Description = Destination either the WREG register or the specified register file location. f, Description = 8-bit Register file address (0x00 to 0xFF). fs, Description = 12-bit Register file address (0x000 to 0xFFF). This is the source address.. fd, Description = 12-bit Register file address (0x000 to 0xFFF). This is the destination address.. k, Description = Literal field, constant data or label (may be either an 8-bit, 12-bit or a 20-bit value). label, Description = Label name. mm, Description = The mode of",
    "TABLE 20-1: OPCODE FIELD DESCRIPTIONS\nthe TBLPTR register for the Table Read and Table Write instructions. Only used with Table Read and Table Write instructions:. *, Description = No Change to register (such as TBLPTR with Table reads and writes). *+, Description = Post-Increment register (such as TBLPTR with Table reads and writes). *-, Description = Post-Decrement register (such as TBLPTR with Table reads and writes). +*, Description = Pre-Increment register (such as TBLPTR with Table reads and writes). n, Description = The relative address (2's complement number) for relative branch instructions, or the direct address for Call/Branch and Return instructions. PRODH, Description = Product of Multiply high byte. PRODL, Description = Product of Multiply low byte. s, Description = Fast Call/Return mode select bit. s = 0: do not update into/from shadow registers s = 1: certain registers loaded into/from shadow registers (Fast mode). u, Description = Unused or Unchanged. WREG, Description = Working register (accumulator). x, Description = Don't care (0 or",
    "TABLE 20-1: OPCODE FIELD DESCRIPTIONS\n1) The assembler will generate code with x = 0. It is the recommended form of use for compatibility with all Microchip software tools.. TBLPTR, Description = 21-bit Table Pointer (points to a Program Memory location). TABLAT, Description = 8-bit Table Latch. TOS, Description = Top-of-Stack. PC, Description = Program Counter. PCL, Description = Program Counter Low Byte. PCH, Description = Program Counter High Byte. PCLATH, Description = Program Counter High Byte Latch. PCLATU, Description = Program Counter Upper Byte Latch. GIE, Description = Global Interrupt Enable bit. WDT, Description = Watchdog Timer. TO, Description = Time-out bit. PD, Description = Power-down bit. C, DC, Z, OV,, Description = N ALU status bits Carry, Digit Carry, Zero, Overflow, Negative. [ ], Description = Optional. ( ), Description = Contents. \u2192, Description = Assigned to. < > \u2208, Description = Register bit field In the set of. italics, Description = User defined term (font is courier)",
    "FIGURE 20-1: GENERAL FORMAT FOR INSTRUCTIONS\nd = 0 for result destination to be WREG OPCODE d a f (FILE #) d = 1 for result destination to be file a = 0 to force Access Bank Bit-oriented file register operations 15 12 11 9 8 7 OPCODE b (BIT #) a f (FILE #) b = 3-bit position of bit in file register (f) Byte to Byte move operations (2-word) 15 12 11 0 OPCODE f (Source FILE #) a = 1 for BSR to select bank f = 8-bit file register address a = 0 to force Access Bank a = 1 for BSR to select bank f = 8-bit file register address 15 12 11 0 1111 f (Destination FILE #) f = 12-bit file register address, Example Instruction = register register (f) ADDWF MYREG, W, B. k = 8-bit immediate value CALL, GOTO and Branch operations 15 8 7 OPCODE n<7:0> n = 20-bit immediate value 15 12 11 1111 n<19:8> (literal) Control operations 15 8 7 OPCODE n<7:0> 15 12 11 S, Example Instruction = . 0",
    "FIGURE 20-1: GENERAL FORMAT FOR INSTRUCTIONS\n(literal) 0, Example Instruction = GOTO Label. (literal), Example Instruction = . 0 0 n<19:8> (literal) 15 0 S = Fast bit, Example Instruction = CALL MYFUNC. 11 10 OPCODE, Example Instruction = . , Example Instruction = BRA MYFUNC. n<10:0> (literal), Example Instruction = . 15 8 7, Example Instruction = . n<7:0> (literal), Example Instruction = BC MYFUNC. OPCODE, Example Instruction = . , Example Instruction = 0",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nBYTE-ORIENTED FILE REGISTER OPERATIONS, Mnemonic,.Operands = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Description.Description = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Cycles.Cycles = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Status.Affected = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Notes.Notes = BYTE-ORIENTED FILE REGISTER OPERATIONS. ADDWF, Mnemonic,.Operands = f, d, a. ADDWF, Description.Description = Add WREG and f. ADDWF, Cycles.Cycles = 1. ADDWF, 16-Bit Instruction Word.MSb = 0010.",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nADDWF, 16-Bit Instruction Word.MSb = 01da0. ADDWF, 16-Bit Instruction Word.MSb = ffff. ADDWF, 16-Bit Instruction Word.LSb = ffff. ADDWF, Status.Affected = C, DC, Z, OV, N. ADDWF, Notes.Notes = 1, 2. ADDWFC, Mnemonic,.Operands = f, d, a. ADDWFC, Description.Description = Add WREG and Carry bit to f. ADDWFC, Cycles.Cycles = 1. ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word.MSb = 0da. ADDWFC, 16-Bit Instruction Word.MSb = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status.Affected = C, DC, Z, OV, N. ADDWFC, Notes.Notes = 1, 2. ANDWF, Mnemonic,.Operands = f, d, a. ANDWF,",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nDescription.Description = AND WREG with f. ANDWF, Cycles.Cycles = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001. ANDWF, 16-Bit Instruction Word.MSb = 01da. ANDWF, 16-Bit Instruction Word.MSb = ffff. ANDWF, 16-Bit Instruction Word.LSb = ffff. ANDWF, Status.Affected = Z, N. ANDWF, Notes.Notes = 1,2. CLRF, Mnemonic,.Operands = f, a. CLRF, Description.Description = Clear f. CLRF, Cycles.Cycles = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word.MSb = 101a. CLRF, 16-Bit Instruction Word.MSb = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status.Affected = Z. CLRF, Notes.Notes = 2. COMF, Mnemonic,.Operands = f, d, a. COMF, Description.Description =",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nComplement f. COMF, Cycles.Cycles = 1. COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction Word.MSb = 11da. COMF, 16-Bit Instruction Word.MSb = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status.Affected = Z, N. COMF, Notes.Notes = 1, 2. CPFSEQ, Mnemonic,.Operands = f, a. CPFSEQ, Description.Description = Compare f with WREG, skip =. CPFSEQ, Cycles.Cycles = 1 (2 or 3). CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word.MSb = 001a. CPFSEQ, 16-Bit Instruction Word.MSb = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status.Affected = None. CPFSEQ, Notes.Notes = 4. CPFSGT,",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nMnemonic,.Operands = f, a. CPFSGT, Description.Description = Compare f with WREG, skip >. CPFSGT, Cycles.Cycles = 1 (2 or 3). CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word.MSb = 010a. CPFSGT, 16-Bit Instruction Word.MSb = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT, Status.Affected = None. CPFSGT, Notes.Notes = 4. CPFSLT, Mnemonic,.Operands = f, a. CPFSLT, Description.Description = Compare f with WREG, skip <. CPFSLT, Cycles.Cycles = 1 (2 or 3). CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word.MSb = 000a. CPFSLT, 16-Bit Instruction Word.MSb = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff.",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nCPFSLT, Status.Affected = None. CPFSLT, Notes.Notes = 1, 2. DECF, Mnemonic,.Operands = f, d, a. DECF, Description.Description = Decrement f. DECF, Cycles.Cycles = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word.MSb = 01da. DECF, 16-Bit Instruction Word.MSb = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status.Affected = C, DC, Z, OV, N. DECF, Notes.Notes = 1, 2, 3, 4. DECFSZ, Mnemonic,.Operands = f, d, a. DECFSZ, Description.Description = Decrement f, Skip if 0. DECFSZ, Cycles.Cycles = 1 (2 or 3). DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word.MSb = 11da. DECFSZ, 16-Bit Instruction",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nWord.MSb = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status.Affected = None. DECFSZ, Notes.Notes = 1, 2, 3, 4. DCFSNZ, Mnemonic,.Operands = f, d, a. DCFSNZ, Description.Description = Decrement f, Skip if Not 0. DCFSNZ, Cycles.Cycles = 1 (2 or 3). DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word.MSb = 11da. DCFSNZ, 16-Bit Instruction Word.MSb = ffff. DCFSNZ, 16-Bit Instruction Word.LSb = ffff. DCFSNZ, Status.Affected = None. DCFSNZ, Notes.Notes = 1, 2. INCF, Mnemonic,.Operands = f, d, a. INCF, Description.Description = Increment f. INCF, Cycles.Cycles = 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF,",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\n16-Bit Instruction Word.MSb = 10da. INCF, 16-Bit Instruction Word.MSb = ffff. INCF, 16-Bit Instruction Word.LSb = ffff. INCF, Status.Affected = C, DC, Z, OV, N. INCF, Notes.Notes = 1, 2, 3, 4. INCFSZ, Mnemonic,.Operands = f, d, a. INCFSZ, Description.Description = Increment f, Skip if 0. INCFSZ, Cycles.Cycles = 1 (2 or 3). INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word.MSb = 11da. INCFSZ, 16-Bit Instruction Word.MSb = ffff. INCFSZ, 16-Bit Instruction Word.LSb = ffff. INCFSZ, Status.Affected = None. INCFSZ, Notes.Notes = 4. INFSNZ, Mnemonic,.Operands = f, d, a. INFSNZ, Description.Description = Increment f, Skip if Not",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\n0. INFSNZ, Cycles.Cycles = 1 (2 or 3). INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ, 16-Bit Instruction Word.MSb = 10da. INFSNZ, 16-Bit Instruction Word.MSb = ffff. INFSNZ, 16-Bit Instruction Word.LSb = ffff. INFSNZ, Status.Affected = None. INFSNZ, Notes.Notes = 1, 2. IORWF, Mnemonic,.Operands = f, d, a. IORWF, Description.Description = Inclusive OR WREG with f. IORWF, Cycles.Cycles = 1. IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word.MSb = 00da. IORWF, 16-Bit Instruction Word.MSb = ffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status.Affected = Z, N. IORWF, Notes.Notes = 1, 2.",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nMOVF, Mnemonic,.Operands = f, d, a. MOVF, Description.Description = Move f. MOVF, Cycles.Cycles = 1. MOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word.MSb = 00da. MOVF, 16-Bit Instruction Word.MSb = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status.Affected = Z, N. MOVF, Notes.Notes = 1. MOVFF, Mnemonic,.Operands = f s , f d. MOVFF, Description.Description = Move f s (source) to 1st word f d (destination) 2nd word. MOVFF, Cycles.Cycles = 2. MOVFF, 16-Bit Instruction Word.MSb = 1100 1111. MOVFF, 16-Bit Instruction Word.MSb = ffff ffff. MOVFF, 16-Bit Instruction Word.MSb = ffff ffff. MOVFF, 16-Bit Instruction Word.LSb =",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nffff ffff. MOVFF, Status.Affected = None. MOVFF, Notes.Notes = . MOVWF, Mnemonic,.Operands = f, a. MOVWF, Description.Description = Move WREG to f. MOVWF, Cycles.Cycles = 1. MOVWF, 16-Bit Instruction Word.MSb = 0110. MOVWF, 16-Bit Instruction Word.MSb = 111a. MOVWF, 16-Bit Instruction Word.MSb = ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff. MOVWF, Status.Affected = None. MOVWF, Notes.Notes = . MULWF, Mnemonic,.Operands = f, a. MULWF, Description.Description = Multiply WREG with f. MULWF, Cycles.Cycles = 1. MULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word.MSb = 001a. MULWF, 16-Bit Instruction",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nWord.MSb = ffff. MULWF, 16-Bit Instruction Word.LSb = ffff. MULWF, Status.Affected = None. MULWF, Notes.Notes = . NEGF, Mnemonic,.Operands = f, a. NEGF, Description.Description = Negate f. NEGF, Cycles.Cycles = 1. NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word.MSb = 110a. NEGF, 16-Bit Instruction Word.MSb = ffff. NEGF, 16-Bit Instruction Word.LSb = ffff. NEGF, Status.Affected = C, DC, Z, OV, N. NEGF, Notes.Notes = 1, 2. RLCF, Mnemonic,.Operands = f, d, a. RLCF, Description.Description = Rotate Left f through Carry. RLCF, Cycles.Cycles = 1. RLCF, 16-Bit Instruction Word.MSb = 0011. RLCF, 16-Bit Instruction Word.MSb = 01da.",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nRLCF, 16-Bit Instruction Word.MSb = ffff. RLCF, 16-Bit Instruction Word.LSb = ffff. RLCF, Status.Affected = C, Z, N. RLCF, Notes.Notes = . RLNCF, Mnemonic,.Operands = f, d, a. RLNCF, Description.Description = Rotate Left f (No Carry). RLNCF, Cycles.Cycles = 1. RLNCF, 16-Bit Instruction Word.MSb = 0100. RLNCF, 16-Bit Instruction Word.MSb = 01da. RLNCF, 16-Bit Instruction Word.MSb = ffff. RLNCF, 16-Bit Instruction Word.LSb = ffff. RLNCF, Status.Affected = Z, N. RLNCF, Notes.Notes = . RRCF, Mnemonic,.Operands = f, d, a. RRCF, Description.Description = Rotate Right f through Carry. RRCF, Cycles.Cycles = . RRCF, 16-Bit Instruction",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nWord.MSb = 0011. RRCF, 16-Bit Instruction Word.MSb = 00da. RRCF, 16-Bit Instruction Word.MSb = ffff. RRCF, 16-Bit Instruction Word.LSb = ffff. RRCF, Status.Affected = . RRCF, Notes.Notes = 1, 2. RRNCF, Mnemonic,.Operands = f, d, a. RRNCF, Description.Description = Rotate Right f (No Carry). RRNCF, Cycles.Cycles = 1 1. RRNCF, 16-Bit Instruction Word.MSb = 0100. RRNCF, 16-Bit Instruction Word.MSb = 00da. RRNCF, 16-Bit Instruction Word.MSb = ffff. RRNCF, 16-Bit Instruction Word.LSb = ffff. RRNCF, Status.Affected = C, Z, N. RRNCF, Notes.Notes = . , Mnemonic,.Operands = . , Description.Description = . , Cycles.Cycles = . , 16-Bit Instruction Word.MSb = 0110.",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\n, 16-Bit Instruction Word.MSb = . , 16-Bit Instruction Word.MSb = ffff. , 16-Bit Instruction Word.LSb = . , Status.Affected = Z, N. , Notes.Notes = . SETF, Mnemonic,.Operands = f, a. SETF, Description.Description = Set f. SETF, Cycles.Cycles = 1. SETF, 16-Bit Instruction Word.MSb = . SETF, 16-Bit Instruction Word.MSb = 100a. SETF, 16-Bit Instruction Word.MSb = . SETF, 16-Bit Instruction Word.LSb = ffff. SETF, Status.Affected = None. SETF, Notes.Notes = . SUBFWB, Mnemonic,.Operands = f, d, a. SUBFWB, Description.Description = Subtract f from WREG with borrow. SUBFWB, Cycles.Cycles = 1. SUBFWB, 16-Bit Instruction Word.MSb = 0101. SUBFWB, 16-Bit Instruction Word.MSb = 01da.",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nSUBFWB, 16-Bit Instruction Word.MSb = ffff. SUBFWB, 16-Bit Instruction Word.LSb = ffff. SUBFWB, Status.Affected = C, DC, Z, OV, N. SUBFWB, Notes.Notes = 1, 2. SUBWF, Mnemonic,.Operands = f, d, a. SUBWF, Description.Description = Subtract WREG from f. SUBWF, Cycles.Cycles = 1. SUBWF, 16-Bit Instruction Word.MSb = 0101. SUBWF, 16-Bit Instruction Word.MSb = 11da. SUBWF, 16-Bit Instruction Word.MSb = ffff. SUBWF, 16-Bit Instruction Word.LSb = ffff. SUBWF, Status.Affected = C, DC, Z, OV, N. SUBWF, Notes.Notes = . SUBWFB, Mnemonic,.Operands = f, d, a. SUBWFB, Description.Description = Subtract WREG from f with borrow. SUBWFB,",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nCycles.Cycles = 1. SUBWFB, 16-Bit Instruction Word.MSb = 0101. SUBWFB, 16-Bit Instruction Word.MSb = 10da. SUBWFB, 16-Bit Instruction Word.MSb = ffff. SUBWFB, 16-Bit Instruction Word.LSb = ffff. SUBWFB, Status.Affected = C, DC, Z, OV, N. SUBWFB, Notes.Notes = 1, 2. SWAPF, Mnemonic,.Operands = f, d, a. SWAPF, Description.Description = Swap nibbles in. SWAPF, Cycles.Cycles = 1. SWAPF, 16-Bit Instruction Word.MSb = 0011. SWAPF, 16-Bit Instruction Word.MSb = 10da. SWAPF, 16-Bit Instruction Word.MSb = ffff. SWAPF, 16-Bit Instruction Word.LSb = ffff. SWAPF, Status.Affected = None. SWAPF, Notes.Notes = 4. TSTFSZ, Mnemonic,.Operands = f, a. TSTFSZ, Description.Description = f Test",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nf, skip if 0. TSTFSZ, Cycles.Cycles = 1 (2 or 3). TSTFSZ, 16-Bit Instruction Word.MSb = 0110. TSTFSZ, 16-Bit Instruction Word.MSb = 011a. TSTFSZ, 16-Bit Instruction Word.MSb = ffff. TSTFSZ, 16-Bit Instruction Word.LSb = ffff. TSTFSZ, Status.Affected = None. TSTFSZ, Notes.Notes = 1, 2. XORWF f, d, a, Mnemonic,.Operands = . XORWF f, d, a, Description.Description = Exclusive OR WREG with f. XORWF f, d, a, Cycles.Cycles = 1. XORWF f, d, a, 16-Bit Instruction Word.MSb = 0001. XORWF f, d, a, 16-Bit Instruction Word.MSb = 10da. XORWF f, d, a, 16-Bit Instruction Word.MSb = ffff. XORWF f, d, a, 16-Bit Instruction",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nWord.LSb = ffff. XORWF f, d, a, Status.Affected = Z, N. XORWF f, d, a, Notes.Notes = . BIT-ORIENTED FILE REGISTER OPERATIONS, Mnemonic,.Operands = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Description.Description = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Cycles.Cycles = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.LSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Status.Affected = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Notes.Notes = BIT-ORIENTED FILE REGISTER OPERATIONS. BCF, Mnemonic,.Operands = f, b, a.",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nBCF, Description.Description = Bit Clear f. BCF, Cycles.Cycles = 1. BCF, 16-Bit Instruction Word.MSb = 1001. BCF, 16-Bit Instruction Word.MSb = bbba. BCF, 16-Bit Instruction Word.MSb = ffff. BCF, 16-Bit Instruction Word.LSb = ffff. BCF, Status.Affected = None. BCF, Notes.Notes = 1, 2. BSF, Mnemonic,.Operands = f, b, a. BSF, Description.Description = Bit Set f. BSF, Cycles.Cycles = 1. BSF, 16-Bit Instruction Word.MSb = 1000. BSF, 16-Bit Instruction Word.MSb = bbba. BSF, 16-Bit Instruction Word.MSb = ffff. BSF, 16-Bit Instruction Word.LSb = ffff. BSF, Status.Affected = None. BSF, Notes.Notes = 1, 2. BTFSC, Mnemonic,.Operands = f, b, a. BTFSC, Description.Description = Bit Test",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nf, Skip if Clear. BTFSC, Cycles.Cycles = 1 (2 or 3). BTFSC, 16-Bit Instruction Word.MSb = 1011. BTFSC, 16-Bit Instruction Word.MSb = bbba. BTFSC, 16-Bit Instruction Word.MSb = ffff. BTFSC, 16-Bit Instruction Word.LSb = ffff. BTFSC, Status.Affected = None. BTFSC, Notes.Notes = 3, 4. BTFSS, Mnemonic,.Operands = f, b, a. BTFSS, Description.Description = Bit Test f, Skip if Set. BTFSS, Cycles.Cycles = 1 (2 or 3). BTFSS, 16-Bit Instruction Word.MSb = 1010. BTFSS, 16-Bit Instruction Word.MSb = bbba. BTFSS, 16-Bit Instruction Word.MSb = ffff. BTFSS, 16-Bit Instruction Word.LSb = ffff. BTFSS, Status.Affected = None. BTFSS, Notes.Notes = 3, 4.",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nBTG, Mnemonic,.Operands = f, d, a. BTG, Description.Description = Bit Toggle f. BTG, Cycles.Cycles = 1. BTG, 16-Bit Instruction Word.MSb = 0111. BTG, 16-Bit Instruction Word.MSb = bbba. BTG, 16-Bit Instruction Word.MSb = ffff. BTG, 16-Bit Instruction Word.LSb = ffff. BTG, Status.Affected = None. BTG, Notes.Notes = 1, 2",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET\nNote 1: When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is '1' for a pin configured as input and is driven low by an external device, the data will be written back with a '0'.\n2: If this instruction is executed on the TMR0 register (and, where applicable, d = 1), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP , unless the first word of the instruction retrieves the information embedded in these 16-bits. This ensures that all program memory locations have a valid instruction.\n5: If the Table Write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nCONTROL OPERATIONS, Mnemonic,.Operands = CONTROL OPERATIONS. CONTROL OPERATIONS, Description = CONTROL OPERATIONS. CONTROL OPERATIONS, Cycles. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, Status Affected. = CONTROL OPERATIONS. CONTROL OPERATIONS, Notes. = CONTROL OPERATIONS. BC, Mnemonic,.Operands = n. BC, Description = Branch if Carry. BC, Cycles. = 1 (2). BC, 16-Bit Instruction Word.MSb = 1110. BC, 16-Bit Instruction Word.MSb = 0010. BC, 16-Bit Instruction Word. = nnnn. BC, 16-Bit Instruction Word.LSb = nnnn. BC, Status Affected. = None. BC, Notes. = . BN, Mnemonic,.Operands = n. BN, Description = Branch if Negative. BN, Cycles. = 1 (2). BN,",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n16-Bit Instruction Word.MSb = 1110. BN, 16-Bit Instruction Word.MSb = 0110. BN, 16-Bit Instruction Word. = nnnn. BN, 16-Bit Instruction Word.LSb = nnnn. BN, Status Affected. = None. BN, Notes. = . BNC, Mnemonic,.Operands = n. BNC, Description = Branch if Not Carry. BNC, Cycles. = 1 (2). BNC, 16-Bit Instruction Word.MSb = 1110. BNC, 16-Bit Instruction Word.MSb = 0011. BNC, 16-Bit Instruction Word. = nnnn. BNC, 16-Bit Instruction Word.LSb = nnnn. BNC, Status Affected. = None. BNC, Notes. = . BNN, Mnemonic,.Operands = n. BNN, Description = Branch if Not Negative. BNN, Cycles. = 1 (2). BNN, 16-Bit Instruction Word.MSb = 1110. BNN, 16-Bit Instruction Word.MSb =",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n0111. BNN, 16-Bit Instruction Word. = nnnn. BNN, 16-Bit Instruction Word.LSb = nnnn. BNN, Status Affected. = None. BNN, Notes. = . BNOV, Mnemonic,.Operands = n. BNOV, Description = Branch if Not Overflow. BNOV, Cycles. = 1 (2). BNOV, 16-Bit Instruction Word.MSb = 1110. BNOV, 16-Bit Instruction Word.MSb = 0101. BNOV, 16-Bit Instruction Word. = nnnn. BNOV, 16-Bit Instruction Word.LSb = nnnn. BNOV, Status Affected. = None. BNOV, Notes. = . BNZ, Mnemonic,.Operands = n. BNZ, Description = Branch if Not Zero. BNZ, Cycles. = 2. BNZ, 16-Bit Instruction Word.MSb = 1110. BNZ, 16-Bit Instruction Word.MSb = 0001. BNZ, 16-Bit Instruction Word. = nnnn. BNZ, 16-Bit",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nInstruction Word.LSb = nnnn. BNZ, Status Affected. = None. BNZ, Notes. = . BOV, Mnemonic,.Operands = n. BOV, Description = Branch if Overflow. BOV, Cycles. = 1 (2). BOV, 16-Bit Instruction Word.MSb = 1110. BOV, 16-Bit Instruction Word.MSb = 0100. BOV, 16-Bit Instruction Word. = nnnn. BOV, 16-Bit Instruction Word.LSb = nnnn. BOV, Status Affected. = None. BOV, Notes. = . BRA, Mnemonic,.Operands = n. BRA, Description = Branch Unconditionally. BRA, Cycles. = 1 (2). BRA, 16-Bit Instruction Word.MSb = 1101. BRA, 16-Bit Instruction Word.MSb = 0nnn. BRA, 16-Bit Instruction Word. = nnnn. BRA, 16-Bit Instruction Word.LSb = nnnn. BRA, Status Affected. = None. BRA, Notes. = .",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nBZ, Mnemonic,.Operands = n. BZ, Description = Branch if Zero. BZ, Cycles. = 1 (2). BZ, 16-Bit Instruction Word.MSb = 1110. BZ, 16-Bit Instruction Word.MSb = 0000. BZ, 16-Bit Instruction Word. = nnnn. BZ, 16-Bit Instruction Word.LSb = nnnn. BZ, Status Affected. = None. BZ, Notes. = . CALL, Mnemonic,.Operands = n, s. CALL, Description = Call subroutine1st word 2nd word. CALL, Cycles. = 2. CALL, 16-Bit Instruction Word.MSb = 1110 1111. CALL, 16-Bit Instruction Word.MSb = 110s kkkk. CALL, 16-Bit Instruction Word. = kkkk kkkk. CALL, 16-Bit Instruction Word.LSb = kkkk kkkk. CALL, Status Affected. = None. CALL, Notes. = . CLRWDT, Mnemonic,.Operands = -.",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nCLRWDT, Description = Clear Watchdog Timer. CLRWDT, Cycles. = 1. CLRWDT, 16-Bit Instruction Word.MSb = 0000. CLRWDT, 16-Bit Instruction Word.MSb = 0000. CLRWDT, 16-Bit Instruction Word. = 0000. CLRWDT, 16-Bit Instruction Word.LSb = 0100. CLRWDT, Status Affected. = TO, PD. CLRWDT, Notes. = . DAW, Mnemonic,.Operands = -. DAW, Description = Decimal Adjust WREG. DAW, Cycles. = 1. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word.LSb = 0111. DAW, Status Affected. = C. DAW, Notes. = . GOTO, Mnemonic,.Operands = n. GOTO, Description = Go to address1st word 2nd",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nword. GOTO, Cycles. = 2. GOTO, 16-Bit Instruction Word.MSb = 1110. GOTO, 16-Bit Instruction Word.MSb = 1111. GOTO, 16-Bit Instruction Word. = kkkk. GOTO, 16-Bit Instruction Word.LSb = kkkk. GOTO, Status Affected. = None. GOTO, Notes. = . NOP, Mnemonic,.Operands = -. NOP, Description = . NOP, Cycles. = . NOP, 16-Bit Instruction Word.MSb = 1111. NOP, 16-Bit Instruction Word.MSb = kkkk. NOP, 16-Bit Instruction Word. = kkkk. NOP, 16-Bit Instruction Word.LSb = kkkk. NOP, Status Affected. = . NOP, Notes. = . , Mnemonic,.Operands = . , Description = No Operation. , Cycles. = 1. , 16-Bit Instruction Word.MSb = 0000. , 16-Bit Instruction Word.MSb = 0000. , 16-Bit Instruction",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nWord. = 0000. , 16-Bit Instruction Word.LSb = 0000. , Status Affected. = None. , Notes. = . NOP, Mnemonic,.Operands = -. NOP, Description = No Operation. NOP, Cycles. = 1. NOP, 16-Bit Instruction Word.MSb = 1111. NOP, 16-Bit Instruction Word.MSb = xxxx. NOP, 16-Bit Instruction Word. = xxxx. NOP, 16-Bit Instruction Word.LSb = xxxx. NOP, Status Affected. = None. NOP, Notes. = 4. POP, Mnemonic,.Operands = -. POP, Description = Pop top of return stack (TOS). POP, Cycles. = 1. POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word.LSb = 0110. POP, Status Affected. = None. POP, Notes. = . PUSH,",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nMnemonic,.Operands = -. PUSH, Description = Push top of return stack (TOS). PUSH, Cycles. = 1. PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word. = 0000. PUSH, 16-Bit Instruction Word.LSb = 0101. PUSH, Status Affected. = None. PUSH, Notes. = . RCALL, Mnemonic,.Operands = n. RCALL, Description = Relative Call. RCALL, Cycles. = 2. RCALL, 16-Bit Instruction Word.MSb = 1101. RCALL, 16-Bit Instruction Word.MSb = 1nnn. RCALL, 16-Bit Instruction Word. = nnnn. RCALL, 16-Bit Instruction Word.LSb = nnnn. RCALL, Status Affected. = None. RCALL, Notes. = . RESET, Mnemonic,.Operands = . RESET, Description = Software device RESET. RESET, Cycles. = 1. RESET, 16-Bit Instruction Word.MSb",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= 0000. RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word. = 1111. RESET, 16-Bit Instruction Word.LSb = 1111. RESET, Status Affected. = All. RESET, Notes. = . RETFIE, Mnemonic,.Operands = s. RETFIE, Description = Return from interrupt enable. RETFIE, Cycles. = 2. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word. = 0001. RETFIE, 16-Bit Instruction Word.LSb = 000s. RETFIE, Status Affected. = GIE/GIEH, PEIE/GIEL. RETFIE, Notes. = . RETLW, Mnemonic,.Operands = k. RETLW, Description = Return with literal in WREG. RETLW, Cycles. = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nInstruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected. = None. RETLW, Notes. = . RETURN, Mnemonic,.Operands = s. RETURN, Description = Return from Subroutine. RETURN, Cycles. = 2. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word. = 0001. RETURN, 16-Bit Instruction Word.LSb = 001s. RETURN, Status Affected. = None. RETURN, Notes. = . SLEEP, Mnemonic,.Operands = -. SLEEP, Description = Go into Standby mode. SLEEP, Cycles. = 1. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word. = 0000. SLEEP, 16-Bit Instruction Word.LSb = 0011. SLEEP, Status",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nAffected. = TO, PD. SLEEP, Notes. = \nNote 1: When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is '1' for a pin configured as input and is driven low by an external device, the data will be written back with a '0'.\n2: If this instruction is executed on the TMR0 register (and, where applicable, d = 1), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP , unless the first word of the instruction retrieves the information embedded in these 16-bits. This ensures that all program memory locations have a valid instruction.\n5: If the Table Write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nLITERAL OPERATIONS, Mnemonic,.Operands = LITERAL OPERATIONS. LITERAL OPERATIONS, Description.Description = LITERAL OPERATIONS. LITERAL OPERATIONS, Cycles.Cycles = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, Status Affected.Status Affected = LITERAL OPERATIONS. LITERAL OPERATIONS, Notes.Notes = LITERAL OPERATIONS. ADDLW, Mnemonic,.Operands = k. ADDLW, Description.Description = Add literal and WREG. ADDLW, Cycles.Cycles = 1. ADDLW, 16-Bit Instruction Word.MSb = 0000. ADDLW, 16-Bit Instruction Word.MSb = 1111. ADDLW, 16-Bit Instruction Word. = kkkk. ADDLW, 16-Bit Instruction Word.LSb = kkkk. ADDLW, Status Affected.Status Affected = C, DC, Z, OV, N. ADDLW,",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nNotes.Notes = . ANDLW, Mnemonic,.Operands = k. ANDLW, Description.Description = AND literal with WREG. ANDLW, Cycles.Cycles = 1. ANDLW, 16-Bit Instruction Word.MSb = 0000. ANDLW, 16-Bit Instruction Word.MSb = 1011. ANDLW, 16-Bit Instruction Word. = kkkk. ANDLW, 16-Bit Instruction Word.LSb = kkkk. ANDLW, Status Affected.Status Affected = Z, N. ANDLW, Notes.Notes = . IORLW, Mnemonic,.Operands = k. IORLW, Description.Description = Inclusive OR literal with WREG. IORLW, Cycles.Cycles = 1. IORLW, 16-Bit Instruction Word.MSb = 0000. IORLW, 16-Bit Instruction Word.MSb = 1001. IORLW, 16-Bit Instruction Word. = kkkk. IORLW, 16-Bit Instruction Word.LSb = kkkk. IORLW, Status Affected.Status",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nAffected = Z, N. IORLW, Notes.Notes = . LFSR, Mnemonic,.Operands = f, k. LFSR, Description.Description = Move literal (12-bit) 2nd word to FSRx 1st word. LFSR, Cycles.Cycles = 2. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word. = 00ff. LFSR, 16-Bit Instruction Word.LSb = kkkk. LFSR, Status Affected.Status Affected = None. LFSR, Notes.Notes = . MOVLB, Mnemonic,.Operands = k. MOVLB, Description.Description = Move literal to BSR<3:0>. MOVLB, Cycles.Cycles = 1. MOVLB, 16-Bit Instruction Word.MSb = 1111 0000. MOVLB, 16-Bit Instruction Word.MSb = 0000 0001. MOVLB, 16-Bit Instruction Word. =",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nkkkk 0000. MOVLB, 16-Bit Instruction Word.LSb = kkkk kkkk. MOVLB, Status Affected.Status Affected = None. MOVLB, Notes.Notes = . MOVLW, Mnemonic,.Operands = k. MOVLW, Description.Description = Move literal to WREG. MOVLW, Cycles.Cycles = 1. MOVLW, 16-Bit Instruction Word.MSb = 0000. MOVLW, 16-Bit Instruction Word.MSb = 1110. MOVLW, 16-Bit Instruction Word. = kkkk. MOVLW, 16-Bit Instruction Word.LSb = kkkk. MOVLW, Status Affected.Status Affected = None. MOVLW, Notes.Notes = . MULLW, Mnemonic,.Operands = k. MULLW, Description.Description = Multiply literal with WREG. MULLW, Cycles.Cycles = 1. MULLW, 16-Bit Instruction Word.MSb = 0000. MULLW, 16-Bit",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nInstruction Word.MSb = 1101. MULLW, 16-Bit Instruction Word. = kkkk. MULLW, 16-Bit Instruction Word.LSb = kkkk. MULLW, Status Affected.Status Affected = None. MULLW, Notes.Notes = . RETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected.Status Affected = None. RETLW, Notes.Notes = . SUBLW, Mnemonic,.Operands = k. SUBLW, Description.Description = Subtract WREG from literal. SUBLW, Cycles.Cycles = 1. SUBLW, 16-Bit Instruction Word.MSb = 0000.",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nSUBLW, 16-Bit Instruction Word.MSb = 1000. SUBLW, 16-Bit Instruction Word. = kkkk. SUBLW, 16-Bit Instruction Word.LSb = kkkk. SUBLW, Status Affected.Status Affected = C, DC, Z, OV, N. SUBLW, Notes.Notes = . XORLW, Mnemonic,.Operands = k. XORLW, Description.Description = Exclusive OR literal with WREG. XORLW, Cycles.Cycles = 1. XORLW, 16-Bit Instruction Word.MSb = 0000. XORLW, 16-Bit Instruction Word.MSb = 1010. XORLW, 16-Bit Instruction Word. = kkkk. XORLW, 16-Bit Instruction Word.LSb = kkkk. XORLW, Status Affected.Status Affected = Z, N. XORLW, Notes.Notes = . DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Mnemonic,.Operands = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS,",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nDescription.Description = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Cycles.Cycles = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.LSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Status Affected.Status Affected = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Notes.Notes = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. TBLRD*, Mnemonic,.Operands = TBLRD*. TBLRD*, Description.Description = Table Read. TBLRD*, Cycles.Cycles = 2. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nWord. = 0000. TBLRD*, 16-Bit Instruction Word.LSb = 1000. TBLRD*, Status Affected.Status Affected = None. TBLRD*, Notes.Notes = . TBLRD*+, Mnemonic,.Operands = TBLRD*+. TBLRD*+, Description.Description = Table Read with post-increment. TBLRD*+, Cycles.Cycles = . TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected.Status Affected = None. TBLRD*+, Notes.Notes = . TBLRD*-, Mnemonic,.Operands = TBLRD*-. TBLRD*-, Description.Description = Table Read with post-decrement. TBLRD*-, Cycles.Cycles = .",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nTBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word.LSb = 1010. TBLRD*-, Status Affected.Status Affected = None. TBLRD*-, Notes.Notes = . TBLRD+*, Mnemonic,.Operands = TBLRD+*. TBLRD+*, Description.Description = Table Read with pre-increment. TBLRD+*, Cycles.Cycles = . TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected.Status Affected = None. TBLRD+*, Notes.Notes = .",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nTBLWT*, Mnemonic,.Operands = TBLWT*. TBLWT*, Description.Description = Table Write. TBLWT*, Cycles.Cycles = 2 (5). TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word.LSb = 1100. TBLWT*, Status Affected.Status Affected = None. TBLWT*, Notes.Notes = . TBLWT*+, Mnemonic,.Operands = TBLWT*+. TBLWT*+, Description.Description = Table Write with post-increment. TBLWT*+, Cycles.Cycles = . TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+,",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n16-Bit Instruction Word.LSb = 1101. TBLWT*+, Status Affected.Status Affected = None. TBLWT*+, Notes.Notes = . TBLWT*-, Mnemonic,.Operands = TBLWT*-. TBLWT*-, Description.Description = Table Write with post-decrement. TBLWT*-, Cycles.Cycles = . TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word.LSb = 1110. TBLWT*-, Status Affected.Status Affected = None. TBLWT*-, Notes.Notes = . TBLWT+*, Mnemonic,.Operands = TBLWT+*. TBLWT+*, Description.Description = Table Write with pre-increment. TBLWT+*, Cycles.Cycles = . TBLWT+*, 16-Bit",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nInstruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word.LSb = 1111. TBLWT+*, Status Affected.Status Affected = None. TBLWT+*, Notes.Notes = ",
    "TABLE 20-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nNote 1: When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is '1' for a pin configured as input and is driven low by an external device, the data will be written back with a '0'.\n2: If this instruction is executed on the TMR0 register (and, where applicable, d = 1), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP , unless the first word of the instruction retrieves the information embedded in these 16-bits. This ensures that all program memory locations have a valid instruction.\n5: If the Table Write starts the write cycle to internal memory, the write will continue until terminated.",
    "20.1 Instruction Set\nADDLW\nADD literal to W\nSyntax:\n[ label ]  ADDLW     k\nOperands:\n0 \u2264 k \u2264 255\nOperation:\n(W) + k \u2192 W\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0000\n1111\nkkkk\nkkkk\nDescription:\nThe contents of W are added to the 8-bit literal 'k' and the result is placed in W.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral 'k'\nProcess\nData\nWrite to W\nExample:\nADDLW\n0x15\nBefore Instruction\nW\n=\n0x10\nAfter Instruction\nW = 0x25",
    "20.1 Instruction Set\nSyntax:, ADD Wto f = [ label ] ADDWF. Syntax:, ADD Wto f = [ label ] ADDWF. Syntax:, ADD Wto f = f [,d [,a]. Syntax:, ADD Wto f = f [,d [,a]. Operands:, ADD Wto f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wto f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wto f = . Operands:, ADD Wto f = . Operation:, ADD Wto f = (W) + (f) \u2192 dest. Operation:, ADD Wto f = (W) + (f) \u2192 dest. Operation:, ADD Wto f = . Operation:, ADD Wto f = . Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:, ADD Wto f = . Status",
    "20.1 Instruction Set\nAffected:, ADD Wto f = . Encoding:, ADD Wto f = 0010. Encoding:, ADD Wto f = 01da. Encoding:, ADD Wto f = ffff. Encoding:, ADD Wto f = ffff. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR is used.. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR is used.. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is 0, the result is stored in W. If 'd' is 1, the result is",
    "20.1 Instruction Set\nstored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR is used.. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR is used.. Words:, ADD Wto f = . Words:, ADD Wto f = 1. Words:, ADD Wto f = . Words:, ADD Wto f = . Cycles:, ADD Wto f = 1. Cycles:, ADD Wto f = . Cycles:, ADD Wto f = . Cycles:, ADD Wto f = . Q Cycle Activity:, ADD Wto f = Q Cycle Activity:. Q Cycle Activity:, ADD Wto f = Q Cycle Activity:. Q Cycle Activity:, ADD Wto f = Q Cycle Activity:. Q Cycle Activity:, ADD Wto f = Q Cycle",
    "20.1 Instruction Set\nActivity:. Q1, ADD Wto f = Q2. Q1, ADD Wto f = Q3. Q1, ADD Wto f = . Q1, ADD Wto f = Q4. Decode, ADD Wto f = . Decode, ADD Wto f = Read register 'f'. Decode, ADD Wto f = Process Data. Decode, ADD Wto f = Write to destination. , ADD Wto f = . , ADD Wto f = ADDWF. , ADD Wto f = REG, 0,. , ADD Wto f = . Example:, ADD Wto f = . Example:, ADD Wto f = . Example:, ADD Wto f = . Example:, ADD Wto f = . Instruction, ADD Wto f = . Instruction, ADD Wto f = 0x17. Instruction, ADD Wto f = . Instruction, ADD Wto f = . REG =, ADD Wto f = . REG =, ADD Wto f = 0xC2. REG =, ADD Wto f = . REG =, ADD Wto f = . Instruction, ADD Wto f = . Instruction, ADD Wto f",
    "20.1 Instruction Set\n= . Instruction, ADD Wto f = . Instruction, ADD Wto f = . After, ADD Wto f = . After, ADD Wto f = . After, ADD Wto f = . After, ADD Wto f = . , ADD Wto f = . , ADD Wto f = 0xC2. , ADD Wto f = . , ADD Wto f = . REG, ADD Wto f = . REG, ADD Wto f = . REG, ADD Wto f = . REG, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . Before, ADD Wto f = . Before, ADD Wto f = . Before, ADD Wto f = . Before, ADD Wto f = . =, ADD Wto f = . =, ADD Wto f = . =, ADD Wto f = . =, ADD Wto f = . , ADD Wto f = . , ADD",
    "20.1 Instruction Set\nWto f = 0xD9. , ADD Wto f = . , ADD Wto f = . , ADD Wto f = =. , ADD Wto f = . , ADD Wto f = . , ADD Wto f = . , ADD Wto f = =. , ADD Wto f = . , ADD Wto f = . , ADD Wto f = ",
    "PIC18FXX2\nADDWFC, 1 = ADDWFC. ADDWFC, 2 = ADD Wand Carry bit to f. ADDWFC, 3 = ADD Wand Carry bit to f. ADDWFC, 4 = ADD Wand Carry bit to f. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] ADDWFC. Syntax:, 3 = [ label ] ADDWFC. Syntax:, 4 = f [,d [,a]. Operands:, 1 = Operands:. Operands:, 2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 4 = . Operation:, 1 = Operation:. Operation:, 2 = (W) + (f) + (C) \u2192 dest. Operation:, 3 = (W) + (f) + (C) \u2192 dest. Operation:, 4 = (W) + (f) + (C) \u2192 dest. Status Affected:, 1 = Status Affected:. Status Affected:, 2 =",
    "PIC18FXX2\nN,OV, C, DC, Z. Status Affected:, 3 = N,OV, C, DC, Z. Status Affected:, 4 = N,OV, C, DC, Z. Encoding:, 1 = Encoding:. Encoding:, 2 = 0010. Encoding:, 3 = 00da. Encoding:, 4 = ffff. Description:, 1 = Description:. Description:, 2 = Add W, the Carry Flag and data memory location 'f'. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed in data memory loca- tion 'f'. If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR will not be overridden.. Description:, 3 = Add W, the Carry Flag and data memory location 'f'. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed in data memory loca- tion 'f'. If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the",
    "PIC18FXX2\nBSR will not be overridden.. Description:, 4 = Add W, the Carry Flag and data memory location 'f'. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed in data memory loca- tion 'f'. If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR will not be overridden.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read register 'f'. , 3 = Process Data. , 4 = Write",
    "PIC18FXX2\nto",
    "Example:\nADDWFC\nREG, 0, 1",
    "Before Instruction\nCarry bit\n=\n1\nREG\n=\n0x02\nW\n=\n0x4D\nAfter Instruction\nCarry bit\n=\n0\nREG\n=\n0x02\nW\n=\n0x50",
    "Before Instruction\nSyntax:, AND literal with W = [ label ] ANDLW. Syntax:, AND literal with W = [ label ] ANDLW. Syntax:, AND literal with W = k. Syntax:, AND literal with W = . Operands:, AND literal with W = 0 \u2264 k \u2264 255. Operands:, AND literal with W = 0 \u2264 k \u2264 255. Operands:, AND literal with W = . Operands:, AND literal with W = . Operation:, AND literal with W = (W) .AND. k \u2192 W. Operation:, AND literal with W = (W) .AND. k \u2192 W. Operation:, AND literal with W = . Operation:, AND literal with W = . Status Affected:, AND literal with W = N,Z. Status Affected:, AND literal with W = N,Z. Status Affected:, AND literal with W = . Status Affected:, AND literal with W = . Encoding:, AND literal with W = 0000. Encoding:, AND literal with W = 1011. Encoding:, AND literal with W = kkkk. Encoding:, AND literal with W = kkkk. Description:, AND literal with W = The",
    "Before Instruction\ncontents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Words:, AND literal with W = 1. Words:, AND literal with W = . Words:, AND literal with W = . Words:, AND literal with W = . Cycles:, AND literal with W = 1. Cycles:, AND literal with W = . Cycles:, AND literal with W = . Cycles:, AND literal with W = . Q Cycle Activity:, AND literal with W = . Q Cycle Activity:, AND literal with W = . Q Cycle Activity:, AND literal with W = . Q Cycle Activity:, AND literal with W = . Q1, AND literal with W = Q2. Q1, AND literal with",
    "Before Instruction\nW = Q3. Q1, AND literal with W = Q4. Q1, AND literal with W = Q4. Decode, AND literal with W = Read literal 'k'. Decode, AND literal with W = Process Data. Decode, AND literal with W = Write to W. Decode, AND literal with W = Write to W. Example:, AND literal with W = ANDLW. Example:, AND literal with W = 0x5F. Example:, AND literal with W = . Example:, AND literal with W = . Before Instruction, AND literal with W = Before Instruction. Before Instruction, AND literal with W = . Before Instruction, AND literal with W = . Before Instruction, AND literal with W = . W, AND literal with W = = 0xA3. W, AND literal with W = . W, AND literal with W = . W, AND literal with W = . After Instruction, AND literal with W = After Instruction. After Instruction, AND literal with W = . After Instruction, AND literal with W = . After Instruction, AND literal with W = . W, AND literal with W = = 0x03. W, AND literal with W = . W,",
    "Before Instruction\nAND literal with W = . W, AND literal with W = ",
    "Before Instruction\nSyntax:, AND Wwith f = [ label ] ANDWF. Syntax:, AND Wwith f = [ label ] ANDWF. Syntax:, AND Wwith f = f [,d [,a]. Syntax:, AND Wwith f = f [,d [,a]. Operands:, AND Wwith f = 0 \u2264 f \u2264 255. Operands:, AND Wwith f = 0 \u2264 f \u2264 255. Operands:, AND Wwith f = 0 \u2264 f \u2264 255. Operands:, AND Wwith f = 0 \u2264 f \u2264 255. , AND Wwith f = d \u2208 [0,1]. , AND Wwith f = d \u2208 [0,1]. , AND Wwith f = d \u2208 [0,1]. , AND Wwith f = d \u2208 [0,1]. , AND Wwith f = a \u2208 [0,1]. , AND Wwith f = a \u2208 [0,1]. , AND Wwith f = a \u2208 [0,1]. , AND Wwith f = a \u2208 [0,1]. Operation:, AND Wwith f = (W) .AND. (f) \u2192",
    "Before Instruction\ndest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Status Affected:, AND Wwith f = N,Z. Status Affected:, AND Wwith f = N,Z. Status Affected:, AND Wwith f = N,Z. Status Affected:, AND Wwith f = N,Z. Encoding:, AND Wwith f = 0001. Encoding:, AND Wwith f = 01da. Encoding:, AND Wwith f = ffff. Encoding:, AND Wwith f = ffff\nDescription:\nThe contents of W are AND'ed with register 'f'. If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR will not be overridden (default).\nWords:\nCycles:\nQ Cycle Activity:",
    "Before Instruction\nQ1\nDecode\n1\n1\nQ2\nRead register 'f'",
    "Example:\nANDWF\nBefore Instruction\nW\n=\n0x17\nREG\n=\n0xC2\nAfter Instruction\nW\n=\n0x02\nREG\n=\n0xC2\nQ3\nProcess Data\nREG, 0, 0\nQ4\nWrite to destination",
    "Branch if Carry\nSyntax:\n[ label ]  BC    n\nOperands:\n-128 \u2264 n \u2264 127\nOperation:\nif carry bit is '1' (PC) + 2 + 2n \u2192 PC\nStatus Affected:\nNone\nEncoding:\n1110\n0010\nnnnn\nnnnn\nDescription:\nIf the Carry bit is '1', then the program will branch.\nThe 2's complement number '2n' is added to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is then a two-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity: If Jump:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'n'\nProcess\nData\nWrite to PC\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nIf No Jump:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal\n'n'\nProcess Data\nNo\noperation\nExample:\nHERE\nBC 5\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf Carry\n=\n1;\nPC\n=\naddress (HERE+12)\nIf Carry\n=\n0;\nPC\n=\naddress (HERE+2)",
    "Bit Clear f\nSyntax:\n[ label ]  BCF     f,b[,a]\nOperands:\n0 \u2264 f \u2264 255\n0 \u2264 b \u2264 7\na \u2208 [0,1]\nOperation:\n0 \u2192 f<b>\nStatus Affected:\nNone\nEncoding:\n1001\nbbba\nffff\nffff\nDescription:\nBit 'b' in register 'f' is cleared. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite\nregister 'f'\nExample:\nBCF\nFLAG_REG,  7, 0\nBefore Instruction FLAG_REG = 0xC7 After Instruction FLAG_REG = 0x47",
    "Bit Clear f\n, Branch if Negative = . , Branch if Negative = [ label ] BN n. , Branch if Negative = [ label ] BN n. , Branch if Negative = [ label ] BN n. , Branch if Negative = [ label ] BN n. , Branch if Negative = [ label ] BN n. Operands:, Branch if Negative = Operands:. Operands:, Branch if Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Negative = -128 \u2264 n \u2264 127. Operation:, Branch if Negative = Operation:. Operation:, Branch if Negative = if negative bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Negative = if negative bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Negative = if negative bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Negative = if negative bit is '1' (PC) + 2 +",
    "Bit Clear f\n2n \u2192 PC. Operation:, Branch if Negative = if negative bit is '1' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if Negative = Status Affected:. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Encoding:, Branch if Negative = Encoding:. Encoding:, Branch if Negative = 1110. Encoding:, Branch if Negative = 1110. Encoding:, Branch if Negative = 0110. Encoding:, Branch if Negative = nnnn. Encoding:, Branch if Negative = nnnn. Description:, Branch if Negative = Description:. Description:, Branch if Negative = If the Negative bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is",
    "Bit Clear f\n'1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the",
    "Bit Clear f\nPC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Words:, Branch if Negative = Words:. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Cycles:, Branch if Negative = Cycles:. Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Q Cycle Activity: If Jump:, Branch if Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Negative = Q",
    "Bit Clear f\nCycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Negative = Q Cycle Activity: If Jump:. , Branch if Negative = Q1 Q2. , Branch if Negative = Q1 Q2. , Branch if Negative = Q3. , Branch if Negative = Q3. , Branch if Negative = Q4. , Branch if Negative = Q4. , Branch if Negative = Decode Read literal 'n'. , Branch if Negative = Decode Read literal 'n'. , Branch if Negative = Process. , Branch if Negative = Process. , Branch if Negative = Write to PC. , Branch if Negative = Write to PC. , Branch if Negative = No operation No operation. , Branch if Negative = No operation No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. If No Jump:, Branch if Negative = If No Jump:. If No Jump:, Branch if Negative = If No Jump:. If No Jump:, Branch if Negative = If No Jump:. If No Jump:, Branch if Negative = If No Jump:. If No Jump:, Branch if Negative",
    "Bit Clear f\n= If No Jump:. If No Jump:, Branch if Negative = If No Jump:. , Branch if Negative = Q1 Q2. , Branch if Negative = Q1 Q2. , Branch if Negative = Q3. , Branch if Negative = Q3. , Branch if Negative = Q4. , Branch if Negative = Q4. , Branch if Negative = Decode Read 'n'. , Branch if Negative = Decode Read 'n'. , Branch if Negative = literal Process Data. , Branch if Negative = literal Process Data. , Branch if Negative = No operation. , Branch if Negative = No operation. Example:, Branch if Negative = Example:. Example:, Branch if Negative = HERE BN. Example:, Branch if Negative = HERE BN. Example:, Branch if Negative = Jump. Example:, Branch if Negative = Jump. Example:, Branch if Negative = . Before Instruction, Branch if Negative = Before Instruction. Before Instruction, Branch if Negative = Before Instruction. Before Instruction, Branch if Negative = . Before Instruction, Branch if Negative = . Before Instruction, Branch if Negative = address (HERE). Before Instruction, Branch if Negative = address (HERE). , Branch if Negative = After Instruction",
    "Bit Clear f\nIf Negative = PC =. , Branch if Negative = After Instruction If Negative = PC =. , Branch if Negative = 1; address. , Branch if Negative = 1; address. , Branch if Negative = (Jump). , Branch if Negative = (Jump). , Branch if Negative = If Negative = PC =. , Branch if Negative = If Negative = PC =. , Branch if Negative = 0; address. , Branch if Negative = 0; address. , Branch if Negative = (HERE+2). , Branch if Negative = (HERE+2)",
    "Bit Clear f\nSyntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operation:, Branch if Not Carry = if carry bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if carry bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if carry bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if carry bit is '0' (PC) + 2",
    "Bit Clear f\n+ 2n \u2192 PC. Operation:, Branch if Not Carry = if carry bit is '0' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Encoding:, Branch if Not Carry = 1110. Encoding:, Branch if Not Carry = 0011. Encoding:, Branch if Not Carry = nnnn. Encoding:, Branch if Not Carry = nnnn. Encoding:, Branch if Not Carry = nnnn. Description:, Branch if Not Carry = If the Carry bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is '0', then the program will branch. The 2's complement number",
    "Bit Clear f\n'2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the",
    "Bit Clear f\nnew address will be PC+2+2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q1, Branch if Not Carry = Q2",
    "Bit Clear f\nQ3. Q1, Branch if Not Carry = Q2 Q3. Q1, Branch if Not Carry = Q2 Q3. Q1, Branch if Not Carry = Q4. Q1, Branch if Not Carry = Q4. Decode, Branch if Not Carry = Read literal Process. Decode, Branch if Not Carry = Read literal Process. Decode, Branch if Not Carry = Read literal Process. Decode, Branch if Not Carry = Write to PC. Decode, Branch if Not Carry = Write to PC. No operation, Branch if Not Carry = No operation No operation. No operation, Branch if Not Carry = No operation No operation. No operation, Branch if Not Carry = No operation No operation. No operation, Branch if Not Carry = No operation. No operation, Branch if Not Carry = No operation. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. Q1, Branch if Not",
    "Bit Clear f\nCarry = Q2 Q3. Q1, Branch if Not Carry = Q2 Q3. Q1, Branch if Not Carry = Q2 Q3. Q1, Branch if Not Carry = Q4. Q1, Branch if Not Carry = Q4. Decode, Branch if Not Carry = Read literal 'n' Process Data. Decode, Branch if Not Carry = Read literal 'n' Process Data. Decode, Branch if Not Carry = Read literal 'n' Process Data. Decode, Branch if Not Carry = No operation. Decode, Branch if Not Carry = No operation. Example: HERE, Branch if Not Carry = Example: HERE. Example: HERE, Branch if Not Carry = BNC. Example: HERE, Branch if Not Carry = Jump. Example: HERE, Branch if Not Carry = Jump. Example: HERE, Branch if Not Carry = . Before Instruction, Branch if Not Carry = Before Instruction. Before Instruction, Branch if Not Carry = . Before Instruction, Branch if Not Carry = . Before Instruction, Branch if Not Carry = . Before Instruction, Branch if Not Carry = . PC =, Branch if Not Carry = PC =. PC =, Branch if Not Carry = . PC =, Branch",
    "Bit Clear f\nif Not Carry = address (HERE). PC =, Branch if Not Carry = address (HERE). PC =, Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = 1;. , Branch if Not Carry = address (Jump). , Branch if Not Carry = address (Jump). , Branch if Not Carry = . If Carry = PC =, Branch if Not Carry = If Carry = PC =. If Carry = PC =, Branch if Not Carry = . If Carry = PC =, Branch if Not Carry = address (HERE+2). If Carry = PC =, Branch if Not Carry = address (HERE+2). If Carry = PC =, Branch if Not Carry = ",
    "Bit Clear f\nSyntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operation:, Branch if Not Negative = if negative bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Negative = if negative bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Negative = if negative bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Negative = if negative bit is '0' (PC) + 2",
    "Bit Clear f\n+ 2n \u2192 PC. Operation:, Branch if Not Negative = if negative bit is '0' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 0111. Encoding:, Branch if Not Negative = nnnn. Encoding:, Branch if Not Negative = nnnn. Description:, Branch if Not Negative = If the Negative bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is '0', then the program will branch. The 2's complement number '2n'",
    "Bit Clear f\nis added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be",
    "Bit Clear f\nPC+2+2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Jump:, Branch if Not Negative = Jump:. Jump:, Branch",
    "Bit Clear f\nif Not Negative = Jump:. Jump:, Branch if Not Negative = Jump:. Jump:, Branch if Not Negative = Jump:. Jump:, Branch if Not Negative = Jump:. Q1 Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNN Jump, Branch if Not Negative = Q1 Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNN Jump. Q1 Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNN Jump, Branch if Not Negative = Q1 Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNN Jump. Q1 Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNN Jump, Branch if Not Negative = Q1 Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNN Jump. Q1 Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNN Jump, Branch if Not Negative = Q1 Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNN Jump. Q1 Q2 Q3 Q4 Read literal 'n' Process Data No operation",
    "Bit Clear f\nHERE BNN Jump, Branch if Not Negative = Q1 Q2 Q3 Q4 Read literal 'n' Process Data No operation HERE BNN Jump. Decode Example:, Branch if Not Negative = Decode Example:. Decode Example:, Branch if Not Negative = Decode Example:. Decode Example:, Branch if Not Negative = Decode Example:. Decode Example:, Branch if Not Negative = Decode Example:. Decode Example:, Branch if Not Negative = Decode Example:. Before Instruction, Branch if Not Negative = Before Instruction. Before Instruction, Branch if Not Negative = Before Instruction. Before Instruction, Branch if Not Negative = Before Instruction. Before Instruction, Branch if Not Negative = Before Instruction. Before Instruction, Branch if Not Negative = Before Instruction. PC =, Branch if Not Negative = PC =. PC =, Branch if Not Negative = PC =. PC =, Branch if Not Negative = address (HERE). PC =, Branch if Not Negative = address (HERE). PC =, Branch if Not Negative = address (HERE). After Instruction, Branch if Not Negative = After Instruction. After Instruction, Branch if Not Negative = After Instruction. After Instruction, Branch if Not Negative =",
    "Bit Clear f\n. After Instruction, Branch if Not Negative = . After Instruction, Branch if Not Negative = . If Negative = 0;, Branch if Not Negative = If Negative = 0;. If Negative = 0;, Branch if Not Negative = If Negative = 0;. If Negative = 0;, Branch if Not Negative = If Negative = 0;. If Negative = 0;, Branch if Not Negative = If Negative = 0;. If Negative = 0;, Branch if Not Negative = If Negative = 0;. , Branch if Not Negative = . , Branch if Not Negative = (Jump). , Branch if Not Negative = (Jump). , Branch if Not Negative = (Jump). , Branch if Not Negative = (Jump). , Branch if Not Negative = . , Branch if Not Negative = address. , Branch if Not Negative = address. , Branch if Not Negative = address. , Branch if Not Negative = address. PC =, Branch if Not Negative = PC =. PC =, Branch if Not Negative = . PC =, Branch if Not Negative = . PC =, Branch if Not Negative = . PC =, Branch if Not Negative = . , Branch if Not Negative = . , Branch if Not Negative = 1;.",
    "Bit Clear f\n, Branch if Not Negative = 1;. , Branch if Not Negative = 1;. , Branch if Not Negative = 1;. , Branch if Not Negative = . , Branch if Not Negative = =. , Branch if Not Negative = =. , Branch if Not Negative = =. , Branch if Not Negative = =. If Negative, Branch if Not Negative = If Negative. If Negative, Branch if Not Negative = (HERE+2). If Negative, Branch if Not Negative = (HERE+2). If Negative, Branch if Not Negative = (HERE+2). If Negative, Branch if Not Negative = (HERE+2). , Branch if Not Negative = . , Branch if Not Negative = = address. , Branch if Not Negative = = address. , Branch if Not Negative = = address. , Branch if Not Negative = = address. PC, Branch if Not Negative = PC. PC, Branch if Not Negative = PC. PC, Branch if Not Negative = PC. PC, Branch if Not Negative = PC. PC, Branch if Not Negative = PC",
    "PIC18FXX2\nSyntax:, BNOV = Syntax:. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Operands:, BNOV = Operands:. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operation:, BNOV = Operation:. Operation:, Branch if Not Overflow = if overflow bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Overflow = if overflow bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Overflow = if overflow bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not",
    "PIC18FXX2\nOverflow = if overflow bit is '0' (PC) + 2 + 2n \u2192 PC. Status Affected:, BNOV = Status Affected:. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Encoding:, BNOV = Encoding:. Encoding:, Branch if Not Overflow = 1110. Encoding:, Branch if Not Overflow = 1110. Encoding:, Branch if Not Overflow = 0101. Encoding:, Branch if Not Overflow = nnnn. Description:, BNOV = Description:. Description:, Branch if Not Overflow = If the Overflow bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is '0', then the program will branch.",
    "PIC18FXX2\nThe 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Words:, BNOV = Words:. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1.",
    "PIC18FXX2\nWords:, Branch if Not Overflow = 1. Cycles:, BNOV = Cycles:. Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Q Cycle Activity: If Jump:, BNOV = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Overflow = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Overflow = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Overflow = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Overflow = Q Cycle Activity: If Jump:. , BNOV = Q1. , Branch if Not Overflow = Q2. , Branch if Not Overflow = Q2. , Branch if Not Overflow = Q3. , Branch if Not Overflow = Q3. , BNOV = Decode. , Branch if Not Overflow = Read literal 'n'. ,",
    "PIC18FXX2\nBranch if Not Overflow = Read literal 'n'. , Branch if Not Overflow = Process Data. , Branch if Not Overflow = Process Data. , BNOV = No operation. , Branch if Not Overflow = No operation. , Branch if Not Overflow = No operation. , Branch if Not Overflow = No operation. , Branch if Not Overflow = No operation. If No Jump:, BNOV = If No Jump:. If No Jump:, Branch if Not Overflow = If No Jump:. If No Jump:, Branch if Not Overflow = If No Jump:. If No Jump:, Branch if Not Overflow = If No Jump:. If No Jump:, Branch if Not Overflow = If No Jump:. , BNOV = Q1. , Branch if Not Overflow = Q2. , Branch if Not Overflow = Q2. , Branch if Not Overflow = Q3. , Branch if Not Overflow = Q3. , BNOV = Decode. , Branch if Not Overflow = Read literal 'n'. , Branch if Not Overflow = Read literal 'n'. , Branch if Not Overflow = Process Data. , Branch if Not",
    "PIC18FXX2\nOverflow = Process Data. Example:, BNOV = Example:. Example:, Branch if Not Overflow = HERE. Example:, Branch if Not Overflow = BNOV Jump. Example:, Branch if Not Overflow = BNOV Jump. Example:, Branch if Not Overflow = BNOV Jump. Before Instruction, BNOV = Before Instruction. Before Instruction, Branch if Not Overflow = Before Instruction. Before Instruction, Branch if Not Overflow = . Before Instruction, Branch if Not Overflow = . Before Instruction, Branch if Not Overflow = . , BNOV = If Overflow =. , Branch if Not Overflow = If Overflow =. , Branch if Not Overflow = 0; address (Jump). , Branch if Not Overflow = 0; address (Jump). , Branch if Not Overflow = 0; address (Jump). , BNOV = PC = If Overflow = PC =. , Branch if Not Overflow = PC = If Overflow = PC =. , Branch if Not Overflow = 1; address (HERE+2). , Branch if Not Overflow = 1; address (HERE+2). , Branch if Not Overflow = 1; address",
    "PIC18FXX2\n(HERE+2)",
    "PIC18FXX2\nSyntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Operands:, Branch if Not Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Not Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Not Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Not Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Not Zero = -128 \u2264 n \u2264 127. Operation:, Branch if Not Zero = if zero bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Zero = if zero bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Zero = if zero bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Zero = if zero bit is '0' (PC)",
    "PIC18FXX2\n+ 2 + 2n \u2192 PC. Operation:, Branch if Not Zero = if zero bit is '0' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Encoding:, Branch if Not Zero = 1110. Encoding:, Branch if Not Zero = 0001. Encoding:, Branch if Not Zero = nnnn. Encoding:, Branch if Not Zero = nnnn. Encoding:, Branch if Not Zero = nnnn. Description:, Branch if Not Zero = If the Zero bit is '0', then the pro- gram will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is '0', then the pro- gram will branch. The",
    "PIC18FXX2\n2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is '0', then the pro- gram will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is '0', then the pro- gram will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is '0', then the pro- gram will branch. The 2's complement number '2n' is added to the PC. Since the",
    "PIC18FXX2\nPC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity:",
    "PIC18FXX2\nIf Jump:. Q1, Branch if Not Zero = Q2 Q3. Q1, Branch if Not Zero = Q2 Q3. Q1, Branch if Not Zero = Q2 Q3. Q1, Branch if Not Zero = Q4. Q1, Branch if Not Zero = Q4. Decode, Branch if Not Zero = Read literal Process. Decode, Branch if Not Zero = Read literal Process. Decode, Branch if Not Zero = Read literal Process. Decode, Branch if Not Zero = Write to PC. Decode, Branch if Not Zero = Write to PC. No operation, Branch if Not Zero = No operation No operation. No operation, Branch if Not Zero = No operation No operation. No operation, Branch if Not Zero = No operation No operation. No operation, Branch if Not Zero = No operation. No operation, Branch if Not Zero = No operation. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:,",
    "PIC18FXX2\nBranch if Not Zero = If No Jump:. Q1, Branch if Not Zero = Q2 Q3. Q1, Branch if Not Zero = Q2 Q3. Q1, Branch if Not Zero = Q2 Q3. Q1, Branch if Not Zero = Q4. Q1, Branch if Not Zero = Q4. Decode, Branch if Not Zero = Read literal 'n' Process Data. Decode, Branch if Not Zero = Read literal 'n' Process Data. Decode, Branch if Not Zero = Read literal 'n' Process Data. Decode, Branch if Not Zero = No operation. Decode, Branch if Not Zero = No operation. Example: HERE, Branch if Not Zero = Example: HERE. Example: HERE, Branch if Not Zero = BNZ. Example: HERE, Branch if Not Zero = Jump. Example: HERE, Branch if Not Zero = Jump. Example: HERE, Branch if Not Zero = Jump. Before Instruction PC, Branch if Not Zero = =. Before Instruction PC, Branch if Not Zero = address. Before Instruction PC, Branch if Not Zero = (HERE). Before Instruction PC, Branch if Not Zero = (HERE). Before Instruction PC,",
    "PIC18FXX2\nBranch if Not Zero = (HERE). After Instruction If Zero, Branch if Not Zero = =. After Instruction If Zero, Branch if Not Zero = 0; address. After Instruction If Zero, Branch if Not Zero = . After Instruction If Zero, Branch if Not Zero = . After Instruction If Zero, Branch if Not Zero = . PC = If Zero =, Branch if Not Zero = PC = If Zero =. PC = If Zero =, Branch if Not Zero = . PC = If Zero =, Branch if Not Zero = (Jump). PC = If Zero =, Branch if Not Zero = (Jump). PC = If Zero =, Branch if Not Zero = (Jump). PC, Branch if Not Zero = 1; = address (HERE+2). PC, Branch if Not Zero = 1; = address (HERE+2). PC, Branch if Not Zero = 1; = address (HERE+2). PC, Branch if Not Zero = 1; = address (HERE+2). PC, Branch if Not Zero = 1; = address (HERE+2)\nBRA",
    "Unconditional Branch\nSyntax:\n[ label ]  BRA    n\nOperands:\n-1024 \u2264 n \u2264 1023\nOperation:\n(PC) + 2 + 2n \u2192 PC\nStatus Affected:\nNone\nEncoding:\n1101\n0nnn\nnnnn\nnnnn\nDescription:\nAdd the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is a two-cycle instruction.\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal\n'n'\nProcess\nData\nWrite to PC\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nBefore Instruction PC, HERE = =. Before Instruction PC, BRA = address. Before Instruction PC, Jump = (HERE). After Instruction PC, HERE = =. After Instruction PC, BRA = address. After Instruction PC, Jump = (Jump)",
    "Unconditional Branch\nSyntax:, Bit Set f = [ label ] BSF. Syntax:, Bit Set f = [ label ] BSF. Syntax:, Bit Set f = f,b[,a]. Syntax:, Bit Set f = f,b[,a]. Syntax:, Bit Set f = f,b[,a]. Operands:, Bit Set f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Set f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Set f = . Operands:, Bit Set f = . Operands:, Bit Set f = . Operation:, Bit Set f = 1 \u2192 f<b>. Operation:, Bit Set f = 1 \u2192 f<b>. Operation:, Bit Set f = . Operation:, Bit Set f = . Operation:, Bit Set f = . Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = . Status Affected:, Bit Set f = . Status Affected:, Bit Set f = . Encoding:,",
    "Unconditional Branch\nBit Set f = 1000. Encoding:, Bit Set f = bbba. Encoding:, Bit Set f = . Encoding:, Bit Set f = ffff. Encoding:, Bit Set f = ffff. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is 0 Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is 0 Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is 0 Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is 0 Access Bank will",
    "Unconditional Branch\nbe selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is 0 Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value.. Words:, Bit Set f = 1. Words:, Bit Set f = 1. Words:, Bit Set f = . Words:, Bit Set f = . Words:, Bit Set f = . Cycles:, Bit Set f = 1. Cycles:, Bit Set f = 1. Cycles:, Bit Set f = . Cycles:, Bit Set f = . Cycles:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q1, Bit Set f = Q2. Q1, Bit Set f = Q2. Q1, Bit Set f",
    "Unconditional Branch\n= Q3. Q1, Bit Set f = Q3. Q1, Bit Set f = Q4. Decode, Bit Set f = Read register 'f'. Decode, Bit Set f = Read register 'f'. Decode, Bit Set f = Process Data. Decode, Bit Set f = Process Data. Decode, Bit Set f = Write register 'f'. Example: BSF, Bit Set f = Example: BSF. Example: BSF, Bit Set f = FLAG_REG,. Example: BSF, Bit Set f = FLAG_REG,. Example: BSF, Bit Set f = 7,. Example: BSF, Bit Set f = 1. Before Instruction FLAG_REG =, Bit Set f = Before Instruction FLAG_REG =. Before Instruction FLAG_REG =, Bit Set f = . Before Instruction FLAG_REG =, Bit Set f = . Before Instruction FLAG_REG =, Bit Set f = . Before Instruction FLAG_REG =, Bit Set f = ",
    "PIC18FXX2\nBTFSC",
    "Bit Test File, Skip if Clear\nSyntax:\n[ label ]  BTFSC   f,b[,a]\nOperands:\n0 \u2264 f \u2264 255\n0 \u2264 b \u2264 7\na \u2208 [0,1]\nOperation:\nskip if (f<b>) = 0\nStatus Affected:\nNone\nEncoding:\n1011\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register 'f' is 0, then the next instruction is skipped.\nIf bit 'b' is 0, then the next instruction fetched during the current instruction is executed instead, making this a two-\nexecution is discarded, and a NOP cycle instruction. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:\nIf skip:\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE\nFALSE\nTRUE\nBTFSC",
    "Bit Test File, Skip if Clear\n:\n:\nFLAG, 1, 0\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf FLAG<1>\n=\n0;\nPC\n=\naddress (TRUE)\nIf FLAG<1>\n=\n1;\nPC\n=\naddress (FALSE)\nBTFSS\nBit Test File, Skip if Set\nSyntax:\n[ label ]  BTFSS  f,b[,a]\nOperands:\n0 \u2264 f \u2264 255\n0 \u2264 b \u2264 7\na \u2208 [0,1]\nOperation:\nskip if (f<b>) = 1\nStatus Affected:\nNone\nEncoding:\n1010\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register 'f' is 1, then the next instruction is skipped. If bit 'b' is 1, then the next instruction fetched during the current instruc- tion execution, is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:",
    "Bit Test File, Skip if Clear\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nIf skip:\nQ1\nNo\nQ2\nNo\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE\nFALSE\nTRUE\nBTFSS\n:\n:\nFLAG, 1, 0\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf FLAG<1>\n=\n0;\nPC\n=\naddress (FALSE)\nIf FLAG<1>\n=\n1;\nPC\n=\naddress (TRUE)\nQ4\nNo operation",
    "Q Cycle Activity:\nSyntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Operands:, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operation:, Bit Toggle f = (f<b>) \u2192 f<b>. Operation:, Bit Toggle f = (f<b>) \u2192 f<b>. Operation:, Bit Toggle f = (f<b>) \u2192 f<b>.",
    "Q Cycle Activity:\nOperation:, Bit Toggle f = (f<b>) \u2192 f<b>. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Encoding:, Bit Toggle f = 0111. Encoding:, Bit Toggle f = bbba. Encoding:, Bit Toggle f = ffff. Encoding:, Bit Toggle f = ffff. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Bit Toggle f = Bit",
    "Q Cycle Activity:\n'b' in data memory location 'f' is inverted. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Q Cycle Activity:, Bit Toggle f = Q Cycle Activity:. Q Cycle Activity:, Bit Toggle f = Q Cycle Activity:. Q Cycle Activity:, Bit Toggle f = Q Cycle Activity:. Q Cycle",
    "Q Cycle Activity:\nActivity:, Bit Toggle f = Q Cycle Activity:. Q1, Bit Toggle f = Q2. Q1, Bit Toggle f = Q3. Q1, Bit Toggle f = Q4. Q1, Bit Toggle f = Q4. Decode, Bit Toggle f = Read register 'f'. Decode, Bit Toggle f = Process Data. Decode, Bit Toggle f = Write register 'f'. Decode, Bit Toggle f = Write register 'f'. Example:, Bit Toggle f = BTG. Example:, Bit Toggle f = PORTC, 4,. Example:, Bit Toggle f = 0. Example:, Bit Toggle f = . Before Instruction: PORTC = After, Bit Toggle f = 0111 Instruction:. Before Instruction: PORTC = After, Bit Toggle f = 0101 [0x75]. Before Instruction: PORTC = After, Bit Toggle f = . Before Instruction: PORTC = After, Bit Toggle f = ",
    "Branch if Overflow\nSyntax:\n[ label ]  BOV    n\nOperands:\n-128 \u2264 n \u2264 127\nOperation:\nif overflow bit is '1' (PC) + 2 + 2n \u2192 PC\nStatus Affected:\nNone\nEncoding:\n1110\n0100\nnnnn\nnnnn\nDescription:\nIf the Overflow bit is '1', then the program will branch.\nThe 2's complement number '2n' is added to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is then a two-cycle instruction.\nWords:\n1\nCycles:\n1(2)\nQ Cycle Activity: If Jump:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal\n'n'\nProcess\nData\nWrite to PC\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nIf No Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation\nExample:\nHERE\nBOV Jump\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf Overflow\n=\n1;\nPC\n=\naddress\n(Jump)\nIf Overflow\n=\n0;\nPC\n=\naddress (HERE+2)",
    "PIC18FXX2\nBZ",
    "Branch if Zero\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nQ Cycle Activity:\nIf Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nIf No Jump:\nQ1\nDecode\nQ2\nRead literal\nQ3\nProcess\nQ4\nNo\n'n'\nData operation\nExample:\nHERE\nBZ\nJump\nBefore Instruction\nPC\n=\naddress\n(HERE)\nAfter Instruction\nIf Zero\n=\n1;\nPC\n=\naddress\n(Jump)\nIf Zero\n=\n0;\nPC\n=\naddress\n(HERE+2)\n[ label ]  BZ    n\n-128 \u2264 n \u2264 127\nif Zero bit is '1' (PC) + 2 + 2n \u2192 PC\nNone\n1110\n0000\nnnnn nnnn\nIf the Zero bit is '1', then the program will branch.\nThe 2's complement number '2n' is added to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is then a two-cycle instruction.\n1",
    "Branch if Zero\n1(2)",
    "Branch if Zero\nSyntax:, Subroutine Call = [ label ] CALL k [,s]. Syntax:, Subroutine Call = [ label ] CALL k [,s]. Syntax:, Subroutine Call = [ label ] CALL k [,s]. Syntax:, Subroutine Call = [ label ] CALL k [,s]. Operands:, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands:, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands:, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands:, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operation:, Subroutine Call = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS,. Operation:, Subroutine Call = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS,. Operation:, Subroutine Call =",
    "Branch if Zero\n(PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS,. Operation:, Subroutine Call = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS,. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = 110s k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = kkkk 0 kkkk 8",
    "Branch if Zero\nDescription:\nSubroutine call of entire 2 Mbyte memory range.  First, return address (PC+ 4) is pushed onto the return stack.  If 's' = 1, the W, STATUS and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS.  If 's' = 0, no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.\nWords:\n2\nCycles:\n2\nQ Cycle Activity:\nDecode, Q2 = Read literal 'k'<7:0>,. Decode, Q3 = Push PC to stack. Decode, Q4 = Read literal 'k'<19:8>, Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE\nCALL   THERE,1",
    "Branch if Zero\nAfter Instruction, Before Instruction.= = After Instruction. After Instruction, Before Instruction.address = After Instruction. After Instruction, Before Instruction.(HERE) = After Instruction. PC, Before Instruction.= = =. PC, Before Instruction.address = address. PC, Before Instruction.(HERE) = (THERE). TOS, Before Instruction.= = =. TOS, Before Instruction.address = address. TOS, Before Instruction.(HERE) = (HERE + 4). WS, Before Instruction.= = =. WS, Before Instruction.address = W. WS, Before Instruction.(HERE) = . BSRS, Before Instruction.= = =. BSRS, Before Instruction.address = BSR. BSRS, Before Instruction.(HERE) = . STATUSS=, Before Instruction.= = . STATUSS=, Before Instruction.address = STATUS. STATUSS=, Before Instruction.(HERE) = ",
    "Branch if Zero\nSyntax:, Clear f = [ label ] CLRF. Syntax:, Clear f = f [,a]. Syntax:, Clear f = . Syntax:, Clear f = . Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Clear f = . Operands:, Clear f = . Operation:, Clear f = 000h \u2192 f 1 \u2192 Z. Operation:, Clear f = 000h \u2192 f 1 \u2192 Z. Operation:, Clear f = . Operation:, Clear f = . Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = . Status Affected:, Clear f = . Encoding:, Clear f = 0110. Encoding:, Clear f = 101a. Encoding:, Clear f = . Encoding:, Clear f = ffff. Description:, Clear f = Clears the contents of the specified register. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as",
    "Branch if Zero\nper the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = . Words:, Clear f = . Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = . Cycles:, Clear f = . Q Cycle Activity:, Clear",
    "Branch if Zero\nf = Q Cycle Activity:. Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q1, Clear f = Q2. Q1, Clear f = Q3. Q1, Clear f = . Q1, Clear f = Q4. Decode, Clear f = Read register 'f'. Decode, Clear f = . Decode, Clear f = Process Data. Decode, Clear f = Write register 'f'. Example:, Clear f = CLRF. Example:, Clear f = FLAG_REG,1. Example:, Clear f = . Example:, Clear f = . Before Instruction, Clear f = . Before Instruction, Clear f = . Before Instruction, Clear f = . Before Instruction, Clear f = . FLAG_REG After, Clear f = =. FLAG_REG After, Clear f = . FLAG_REG After, Clear f = . FLAG_REG After, Clear f = . Instruction FLAG_REG, Clear f = . Instruction FLAG_REG, Clear f = . Instruction FLAG_REG, Clear f = . Instruction FLAG_REG, Clear f = . , Clear f = . , Clear f =",
    "Branch if Zero\n0x00. , Clear f = . , Clear f = . , Clear f = =. , Clear f = . , Clear f = . , Clear f = . , Clear f = . , Clear f = 0x5A. , Clear f = 0x5A. , Clear f = 0x5A",
    "PIC18FXX2\nSyntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT postscaler,. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT postscaler,. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT postscaler,. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT postscaler,. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT",
    "PIC18FXX2\npostscaler,. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0100. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set..",
    "PIC18FXX2\nDescription:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear",
    "PIC18FXX2\nWatchdog Timer = Q Cycle Activity:. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = Q4. Q1, Clear Watchdog Timer = Q4. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = No operation. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Before Instruction WDT Counter, Clear Watchdog Timer = Before Instruction WDT Counter. Before Instruction WDT Counter, Clear Watchdog Timer = =. Before Instruction WDT Counter, Clear Watchdog Timer = ?. Before Instruction WDT Counter, Clear Watchdog Timer = . Before Instruction WDT Counter, Clear Watchdog Timer = .",
    "PIC18FXX2\nAfter Instruction WDT, Clear Watchdog Timer = After Instruction WDT. After Instruction WDT, Clear Watchdog Timer = = =. After Instruction WDT, Clear Watchdog Timer = 0x00 0. After Instruction WDT, Clear Watchdog Timer = 0x00 0. After Instruction WDT, Clear Watchdog Timer = 0x00 0. TO, Clear Watchdog Timer = TO. TO, Clear Watchdog Timer = =. TO, Clear Watchdog Timer = 1. TO, Clear Watchdog Timer = 1. TO, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = PD. PD, Clear Watchdog Timer = =. PD, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = 1",
    "PIC18FXX2\nCOMF, 1 = COMF. COMF, 2 = Complement f. COMF, 3 = Complement f. COMF, 4 = Complement f. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] COMF. Syntax:, 3 = [ label ] COMF. Syntax:, 4 = f [,d [,a]. Operands:, 1 = Operands:. Operands:, 2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 4 = . Operation:, 1 = Operation:. Operation:, 2 = \u2192 dest ( f ). Operation:, 3 = \u2192 dest ( f ). Operation:, 4 = . Status Affected:, 1 = Status Affected:. Status Affected:, 2 = N, Z. Status Affected:, 3 = . Status Affected:, 4 = . Encoding:, 1 = Encoding:. Encoding:, 2 = 0001. Encoding:, 3 = 11da. Encoding:, 4 = ffff.",
    "PIC18FXX2\nDescription:, 1 = Description:. Description:, 2 = The contents of register 'f' are com- plemented. If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value. Description:, 3 = The contents of register 'f' are com- plemented. If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value. Description:, 4 = The contents of register 'f' are com- plemented. If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in register 'f'",
    "PIC18FXX2\n(default). If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = . Words:, 4 = . Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = . Cycles:, 4 = . Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read register 'f'. , 3 = Process Data. , 4 = . Example:, 1 = Example:. Example:, 2 = COMF. Example:, 3 = REG, 0,. Example:, 4 = 0. Before Instruction, 1 = Before Instruction. Before Instruction, 2 = Before Instruction. Before Instruction, 3 = . Before",
    "PIC18FXX2\nInstruction, 4 = . , 1 = REG. , 2 = = 0x13. , 3 = . , 4 = . After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. After Instruction, 3 = . After Instruction, 4 = . , 1 = REG W. , 2 = = 0x13. , 3 = . , 4 = ",
    "Compare f with W, skip if f = W\nSyntax:\n[ label ]   CPFSEQ    f [,a]\nOperands:\n0 \u2264 f \u2264 255\na \u2208 [0,1]\nOperation:\n(f) - (W),\nskip if (f) = (W)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n001a\nffff\nffff\nDescription:\nCompares the contents of data memory location 'f' to the contents of W by performing an unsigned subtraction.\nIf 'f' = W  then the fetched instruc- , tion is discarded and a NOP is exe- cuted instead, making this a two- cycle instruction. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:\nQ1\nDecode\nIf skip:\nQ1\nNo\nQ2\nQ3\nQ4\nRead register 'f'\nQ2\nNo\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:",
    "Compare f with W, skip if f = W\nQ1\nQ2\nQ3\nNo operation\nQ4\nNo operation\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE     CPFSEQ REG, 0\nNEQUAL   :\nEQUAL    :\nBefore Instruction\nPC Address\n=\nHERE\nW\n=\n?\nREG\n=\n?\nAfter Instruction\nIf REG\n=\nW;\nPC\n=\nAddress (EQUAL)\nIf REG\n\u2260\nW;\nPC\n=\nAddress (NEQUAL)",
    "Compare f with W, skip if f = W\nSyntax:, Compare f with W, skip if f > W = [ label ] CPFSGT. Syntax:, Compare f with W, skip if f > W = [ label ] CPFSGT. Syntax:, Compare f with W, skip if f > W = f [,a]. Syntax:, Compare f with W, skip if f > W = f [,a]. Operands:, Compare f with W, skip if f > W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, skip if f > W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, skip if f > W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, skip if f > W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Compare f with W, skip if f > W = (f) - ( W), skip if (f) > (W) (unsigned comparison). Operation:, Compare f with W, skip if f > W =",
    "Compare f with W, skip if f = W\n(f) - ( W), skip if (f) > (W) (unsigned comparison). Operation:, Compare f with W, skip if f > W = (f) - ( W), skip if (f) > (W) (unsigned comparison). Operation:, Compare f with W, skip if f > W = (f) - ( W), skip if (f) > (W) (unsigned comparison). Status Affected:, Compare f with W, skip if f > W = None. Status Affected:, Compare f with W, skip if f > W = None. Status Affected:, Compare f with W, skip if f > W = None. Status Affected:, Compare f with W, skip if f > W = None. Encoding:, Compare f with W, skip if f > W = 0110. Encoding:, Compare f with W, skip if f > W = 010a. Encoding:, Compare f with W, skip if f > W = ffff. Encoding:, Compare f with W, skip if f > W = ffff. Description:, Compare f with W, skip if f > W = Compares",
    "Compare f with W, skip if f = W\nthe contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value. Description:, Compare f with W, skip if f > W = Compares the contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value. Description:, Compare f with W, skip if f > W = Compares the contents of data memory location 'f' to",
    "Compare f with W, skip if f = W\nthe contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value. Description:, Compare f with W, skip if f > W = Compares the contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value. Words:, Compare f with W, skip if f > W = 1. Words:, Compare f with W, skip if f > W = 1. Words:,",
    "Compare f with W, skip if f = W\nCompare f with W, skip if f > W = 1. Words:, Compare f with W, skip if f > W = 1. Cycles:, Compare f with W, skip if f > W = 1(2). Cycles:, Compare f with W, skip if f > W = 1(2). Cycles:, Compare f with W, skip if f > W = 1(2). Cycles:, Compare f with W, skip if f > W = 1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:\nQ1\nDecode\nQ2\nQ3\nQ4\nRead register 'f'\nProcess\nData\nNo operation\nIf skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nIf skip and followed by 2-word instruction:",
    "Compare f with W, skip if f = W\nNo operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE      CPFSGT REG, 0\nNGREATER  :\nGREATER   :\nBefore Instruction\nPC\n=\nAddress (HERE)\nW\n=\n?\nAfter Instruction\nIf REG\n>\nW;\nPC\n=\nAddress (GREATER)\nIf REG\n\u2264\nW;\nPC\n=\nAddress\n(NGREATER)\nWords:\nCycles:",
    "PIC18FXX2\nSyntax:, Compare f with W, skip if f < W = [ label ] CPFSLT f [,a]. Syntax:, Compare f with W, skip if f < W = [ label ] CPFSLT f [,a]. Syntax:, Compare f with W, skip if f < W = [ label ] CPFSLT f [,a]. Syntax:, Compare f with W, skip if f < W = [ label ] CPFSLT f [,a]. Operands:, Compare f with W, skip if f < W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, skip if f < W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, skip if f < W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, skip if f < W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Compare f with W, skip if f < W = (f) - ( W), skip if (f) < (W) (unsigned",
    "PIC18FXX2\ncomparison). Operation:, Compare f with W, skip if f < W = (f) - ( W), skip if (f) < (W) (unsigned comparison). Operation:, Compare f with W, skip if f < W = (f) - ( W), skip if (f) < (W) (unsigned comparison). Operation:, Compare f with W, skip if f < W = (f) - ( W), skip if (f) < (W) (unsigned comparison). Status Affected:, Compare f with W, skip if f < W = None. Status Affected:, Compare f with W, skip if f < W = None. Status Affected:, Compare f with W, skip if f < W = None. Status Affected:, Compare f with W, skip if f < W = None. Encoding:, Compare f with W, skip if f < W = 0110. Encoding:, Compare f with W, skip if f < W = 000a. Encoding:, Compare f with W, skip if f < W = ffff. Encoding:, Compare f with W, skip if f < W = ffff\nDescription:",
    "PIC18FXX2\nCompares the contents of data memory location 'f' to the contents of W by performing an unsigned subtraction.\nIf the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is 0, the Access Bank will be selected. If 'a' is 1, the BSR will not be overridden (default).\n1\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nskip:, Q2.Read register 'f' = skip:. skip:, Q3.Process Data = skip:. skip:, Q4.No operation = skip:. Q1, Q2.Read register 'f' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.No operation = Q4. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.No operation = No operation. skip and followed by 2-word instruction:, Q2.Read register 'f' = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3.Process Data = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4.No operation = skip and followed by 2-word instruction:. Q1, Q2.Read register 'f' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.No operation = Q4. No operation, Q2.Read register 'f' = No operation.",
    "Q Cycle Activity:\nNo operation, Q3.Process Data = No operation. No operation, Q4.No operation = No operation. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.No operation = No operation. Example:, Q2.Read register 'f' = HERE. Example:, Q3.Process Data = CPFSLT REG,. Example:, Q4.No operation = 1. Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3.Process Data = Before Instruction. Before Instruction, Q4.No operation = Before Instruction. PC W, Q2.Read register 'f' = =. PC W, Q3.Process Data = Address (HERE). PC W, Q4.No operation = . After Instruction, Q2.Read register 'f' = After Instruction. After Instruction, Q3.Process Data = After Instruction. After Instruction, Q4.No operation = After Instruction. If REG PC, Q2.Read register 'f' = < =. If REG PC, Q3.Process Data = W; Address (LESS).",
    "Q Cycle Activity:\nIf REG PC, Q4.No operation = . If REG, Q2.Read register 'f' = \u2265. If REG, Q3.Process Data = W;. If REG, Q4.No operation = . , Q2.Read register 'f' = =. , Q3.Process Data = (NLESS). , Q4.No operation = . PC, Q2.Read register 'f' = . PC, Q3.Process Data = Address. PC, Q4.No operation = ",
    "PIC18FXX2\nSyntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1] then (W<3:0>) + 6 \u2192 W<3:0>; else ( W<3:0>) \u2192 W<3:0>;. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1] then (W<3:0>) + 6 \u2192 W<3:0>; else ( W<3:0>) \u2192 W<3:0>;. Operation:, Decimal Adjust WRegister = If [W<3:0>",
    "PIC18FXX2\n>9] or [DC = 1] then (W<3:0>) + 6 \u2192 W<3:0>; else ( W<3:0>) \u2192 W<3:0>;. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1] then (W<3:0>) + 6 \u2192 W<3:0>; else ( W<3:0>) \u2192 W<3:0>;. If ( else, Decimal Adjust WRegister = [W<7:4> >9] or [C = 1] then W<7:4>) + 6 \u2192 W<7:4>; \u2192. If ( else, Decimal Adjust WRegister = [W<7:4> >9] or [C = 1] then W<7:4>) + 6 \u2192 W<7:4>; \u2192. If ( else, Decimal Adjust WRegister = [W<7:4> >9] or [C = 1] then W<7:4>) + 6 \u2192 W<7:4>; \u2192. If ( else,",
    "PIC18FXX2\nDecimal Adjust WRegister = [W<7:4> >9] or [C = 1] then W<7:4>) + 6 \u2192 W<7:4>; \u2192. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0111. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addi- tion of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addi- tion of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW",
    "PIC18FXX2\nadjusts the eight-bit value in W, resulting from the earlier addi- tion of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addi- tion of two variables (each in packed BCD format) and produces a correct packed BCD result.. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q1, Decimal Adjust WRegister",
    "PIC18FXX2\n= Q2. Q1, Decimal Adjust WRegister = Q2. Q1, Decimal Adjust WRegister = Q3. Q1, Decimal Adjust WRegister = Q4. Decode, Decimal Adjust WRegister = Read register W. Decode, Decimal Adjust WRegister = Read register W. Decode, Decimal Adjust WRegister = Process Data. Decode, Decimal Adjust WRegister = Write W. Example1:, Decimal Adjust WRegister = DAW. Example1:, Decimal Adjust WRegister = DAW. Example1:, Decimal Adjust WRegister = . Example1:, Decimal Adjust WRegister = . Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = . Before Instruction, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = =. W, Decimal Adjust WRegister = 0xA5. W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = =. C, Decimal Adjust WRegister = 0. C, Decimal Adjust WRegister = .",
    "PIC18FXX2\nC, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = =. DC, Decimal Adjust WRegister = 0. DC, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = . After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = . After Instruction, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = =. W, Decimal Adjust WRegister = 0x05. W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = =. C, Decimal Adjust WRegister = 1. C, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = =. DC, Decimal Adjust WRegister = 0. DC, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = . Example 2:, Decimal Adjust WRegister = Example 2:. Example 2:, Decimal Adjust WRegister = Example 2:. Example 2:, Decimal Adjust WRegister = . Example 2:,",
    "PIC18FXX2\nDecimal Adjust WRegister = . Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = . Before Instruction, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = =. W, Decimal Adjust WRegister = 0xCE. W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = =. C, Decimal Adjust WRegister = 0. C, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = =. DC, Decimal Adjust WRegister = 0. DC, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = . After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = . After Instruction, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = =. W, Decimal Adjust WRegister = 0x34. W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = .",
    "PIC18FXX2\nC DC, Decimal Adjust WRegister = = =. C DC, Decimal Adjust WRegister = 1 0. C DC, Decimal Adjust WRegister = . C DC, Decimal Adjust WRegister = ",
    "PIC18FXX2\nSyntax:, Decrement f = [ label ] DECF f [,d [,a]. Syntax:,  = . Syntax:,  = . Syntax:,  = . Syntax:,  = . Syntax:,  = . Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:,  = . Operands:,  = . Operands:,  = . Operands:,  = . Operands:,  = . Operation:, Decrement f = (f) - 1 \u2192 dest. Operation:,  = . Operation:,  = . Operation:,  = . Operation:,  = . Operation:,  = . Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Encoding:, Decrement f = 0000. Encoding:,  = 01da. Encoding:,  = . Encoding:,  = ffff. Encoding:,  = ffff. Encoding:,",
    "PIC18FXX2\n= . Description:, Decrement f = Decrement register 'f'. If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:,  = . Description:,  = . Description:,  = . Description:,  = . Description:,  = . Words:, Decrement f = 1. Words:,  = . Words:,  = . Words:,  = . Words:,  = . Words:,  = . Cycles:, Decrement f = 1. Cycles:,  = . Cycles:,  = . Cycles:,  = . Cycles:,  = . Cycles:,  = . Q Cycle Activity:, Decrement f = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,",
    "PIC18FXX2\n= . Q1, Decrement f = Q2. Q1,  = . Q1,  = Q3. Q1,  = . Q1,  = Q4. Q1,  = . Decode, Decrement f = register. Decode,  = Read 'f'. Decode,  = Process Data. Decode,  = . Decode,  = Write to destination. Decode,  = . Example:, Decrement f = . Example:,  = DECF. Example:,  = CNT, 1,. Example:,  = . Example:,  = . Example:,  = . Before Instruction, Decrement f = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = 0. Before Instruction,  = . Before Instruction,  = . CNT = Z =, Decrement f = . CNT = Z =,  = 0. CNT = Z =,  = . CNT = Z =,  = . CNT = Z =,  = . CNT = Z =,  = . CNT, Decrement f = . CNT,  = . CNT,  = . CNT,  = . CNT,  = . CNT,",
    "PIC18FXX2\n= . , Decrement f = . ,  = 1. ,  = . ,  = . ,  = . ,  = . Z, Decrement f = . Z,  = . Z,  = . Z,  = . Z,  = . Z,  = . , Decrement f = =. ,  = . ,  = . ,  = . ,  = . ,  = . After, Decrement f = . After,  = . After,  = . After,  = . After,  = . After,  = . , Decrement f = =. ,  = . ,  = . ,  = . ,  = . ,  = . , Decrement f = . ,  = 0x00. ,  = . ,  = . ,  = . ,  = . , Decrement f = . ,  = . ,  = . ,  = . ,  = . ,  = 0x01. , Decrement f = Instruction. ,  = . ,  = . ,  = . ,  = . ,  = ",
    "PIC18FXX2\nSyntax:, Decrement f, skip if 0 = [ label ] DECFSZ. Syntax:, Decrement f, skip if 0 = [ label ] DECFSZ. Syntax:, Decrement f, skip if 0 = f [,d [,a]]. Syntax:, Decrement f, skip if 0 = f [,d [,a]]. Operands:, Decrement f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, Decrement f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, Decrement f, skip if 0 = . Operands:, Decrement f, skip if 0 = . Operation:, Decrement f, skip if 0 = (f) - 1 \u2192 dest, skip if result = 0. Operation:, Decrement f, skip if 0 = (f) - 1 \u2192 dest, skip if result = 0. Operation:, Decrement f, skip if 0 = . Operation:, Decrement f, skip if 0 = . Status Affected:, Decrement",
    "PIC18FXX2\nf, skip if 0 = None. Status Affected:, Decrement f, skip if 0 = . Status Affected:, Decrement f, skip if 0 = . Status Affected:, Decrement f, skip if 0 = . Encoding:, Decrement f, skip if 0 = 0010. Encoding:, Decrement f, skip if 0 = 11da. Encoding:, Decrement f, skip if 0 = ffff. Encoding:, Decrement f, skip if 0 = ffff\nDescription:\nThe contents of register 'f' are decremented. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If the result is 0, the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:",
    "PIC18FXX2\n3 cycles if skip and followed by a 2-word instruction.",
    "PIC18FXX2\nskip:, Q2.Read register 'f' = skip:. skip:, Q3.Process Data = skip:. skip:, Q4.Write to destination = skip:. Q1, Q2.Read register 'f' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.Write to destination = Q4. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.Write to destination = No operation. skip and followed by 2-word instruction:, Q2.Read register 'f' = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3.Process Data = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4.Write to destination = skip and followed by 2-word instruction:. Q1, Q2.Read register 'f' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.Write to destination = Q4. No operation, Q2.Read register",
    "PIC18FXX2\n'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.Write to destination = No operation. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.Write to destination = No operation. Example:, Q2.Read register 'f' = HERE. Example:, Q3.Process Data = DECFSZ GOTO. Example:, Q4.Write to destination = CNT, 1, 1 LOOP. , Q2.Read register 'f' = CONTINUE. , Q3.Process Data = CONTINUE. , Q4.Write to destination = CONTINUE. Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3.Process Data = Before Instruction. Before Instruction, Q4.Write to destination = Before Instruction. PC, Q2.Read register 'f' = = Address. PC, Q3.Process Data = (HERE). PC, Q4.Write to destination = . After Instruction, Q2.Read register 'f' = After Instruction. After Instruction, Q3.Process Data = After",
    "PIC18FXX2\nInstruction. After Instruction, Q4.Write to destination = After Instruction. CNT, Q2.Read register 'f' = = CNT - 1. CNT, Q3.Process Data = . CNT, Q4.Write to destination = . If CNT, Q2.Read register 'f' = = 0; = Address. If CNT, Q3.Process Data = . If CNT, Q4.Write to destination = . If CNT PC, Q2.Read register 'f' = \u2260 0; = Address. If CNT PC, Q3.Process Data = (CONTINUE) (HERE+2). If CNT PC, Q4.Write to destination = ",
    "PIC18FXX2\nSyntax:, Decrement f, skip if not 0 = [ label ] DCFSNZ f [,d. Syntax:, Decrement f, skip if not 0 = [ label ] DCFSNZ f [,d. Syntax:, Decrement f, skip if not 0 = [ label ] DCFSNZ f [,d. Syntax:, Decrement f, skip if not 0 = [,a]. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operation:, Decrement f, skip if not 0 = (f) - 1 \u2192 dest, skip if result \u2260 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \u2192",
    "PIC18FXX2\ndest, skip if result \u2260 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \u2192 dest, skip if result \u2260 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \u2192 dest, skip if result \u2260 0. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Encoding:, Decrement f, skip if not 0 = 0100. Encoding:, Decrement f, skip if not 0 = 11da. Encoding:, Decrement f, skip if not 0 = ffff. Encoding:, Decrement f, skip if not 0 = ffff\nDescription:",
    "PIC18FXX2\nThe contents of register 'f' are decremented. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If the result is not 0, the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a twocycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\nCycles:",
    "Q Cycle Activity:\nQ1\nDecode\nIf skip:\nQ1\nNo\n1\n1(2)\nNote:\nQ2\n3 cycles if skip and followed by a 2-word instruction.\nQ3\nQ4\nRead register 'f'\nQ2\nNo\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE    DCFSNZ  TEMP, 1, 0\nZERO    :\nNZERO   :\nBefore Instruction\nTEMP\n=\n?\nAfter Instruction\nTEMP\n=\nTEMP - 1,\nIf TEMP\n=\n0;\nPC\n=\nAddress\n(ZERO)\nIf TEMP\n\u2260\n0;\nPC\n=\nAddress\n(NZERO)\nWrite to destination\nQ4\nNo operation",
    "PIC18FXX2\nSyntax:, GOTO = Syntax:. Syntax:, Unconditional Branch = [ label ] GOTO. Syntax:, Unconditional Branch = [ label ] GOTO. Syntax:, Unconditional Branch = k. Operands:, GOTO = Operands:. Operands:, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operands:, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operands:, Unconditional Branch = . Operation:, GOTO = Operation:. Operation:, Unconditional Branch = k \u2192 PC<20:1>. Operation:, Unconditional Branch = k \u2192 PC<20:1>. Operation:, Unconditional Branch = . Status Affected:, GOTO = Status Affected:. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = . Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), GOTO = Encoding: 1st word (k<7:0>) 2nd word(k<19:8>). Encoding: 1st word",
    "PIC18FXX2\n(k<7:0>) 2nd word(k<19:8>), Unconditional Branch = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = 1111 k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = k 7 kkk kkkk. Description:, GOTO = Description:. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2 Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2 Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2 Mbyte memory range. The 20-bit value 'k' is",
    "PIC18FXX2\nloaded into PC<20:1>. GOTO is always a two-cycle instruction.. Words:, GOTO = Words:. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = . Cycles:, GOTO = Cycles:. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = . Q Cycle Activity:, GOTO = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. , GOTO = Q1. , Unconditional Branch = Q2. , Unconditional Branch = Q3. , Unconditional Branch = . , GOTO = Decode. , Unconditional Branch = Read literal 'k'<7:0>,. , Unconditional Branch = No operation. , Unconditional Branch = No operation. , GOTO = No operation. , Unconditional Branch = No operation. , Unconditional Branch =",
    "PIC18FXX2\nNo operation. , Unconditional Branch = No operation. Example:, GOTO = Example:. Example:, Unconditional Branch = GOTO THERE. Example:, Unconditional Branch = GOTO THERE. Example:, Unconditional Branch = . After Instruction PC = Address (THERE), GOTO = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), Unconditional Branch = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), Unconditional Branch = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), Unconditional Branch = ",
    "PIC18FXX2\nSyntax:, Increment f = [ label ] INCF. Syntax:, Increment f = [ label ] INCF. Syntax:, Increment f = [ label ] INCF. Syntax:, Increment f = f [,d [,a]. Syntax:, Increment f = f [,d [,a]. Operands:, Increment f = 0 \u2264 f \u2264 255 \u2208. Operands:, Increment f = 0 \u2264 f \u2264 255 \u2208. Operands:, Increment f = 0 \u2264 f \u2264 255 \u2208. Operands:, Increment f = . Operands:, Increment f = . Operation:, Increment f = (f) + 1 \u2192 dest. Operation:, Increment f = (f) + 1 \u2192 dest. Operation:, Increment f = (f) + 1 \u2192 dest. Operation:, Increment f = . Operation:, Increment f = . Status Affected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f = C, DC, N, OV,",
    "PIC18FXX2\nZ. Status Affected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f = . Status Affected:, Increment f = . Encoding:, Increment f = 0010. Encoding:, Increment f = 0010. Encoding:, Increment f = 10da. Encoding:, Increment f = ffff. Encoding:, Increment f = ffff. Description:, Increment f = The contents of register 'f' are incremented. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Increment f = The contents of register 'f' are incremented. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f'",
    "PIC18FXX2\n(default). If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Increment f = The contents of register 'f' are incremented. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Increment f = The contents of register 'f' are incremented. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value (default)..",
    "PIC18FXX2\nDescription:, Increment f = The contents of register 'f' are incremented. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Words:, Increment f = 1. Words:, Increment f = 1. Words:, Increment f = 1. Words:, Increment f = . Words:, Increment f = . Cycles:, Increment f = 1. Cycles:, Increment f = 1. Cycles:, Increment f = 1. Cycles:, Increment f = . Cycles:, Increment f = . Q Cycle Activity:, Increment f = Q Cycle Activity:. Q Cycle Activity:, Increment f = Q Cycle Activity:. Q Cycle Activity:, Increment f = Q Cycle Activity:. Q Cycle Activity:, Increment f =",
    "PIC18FXX2\n. Q Cycle Activity:, Increment f = . Q1, Increment f = . Q1, Increment f = Q2. Q1, Increment f = Q3. Q1, Increment f = . Q1, Increment f = Q4. Decode, Increment f = Read register. Decode, Increment f = 'f'. Decode, Increment f = Process Data. Decode, Increment f = . Decode, Increment f = Write to destination. Example:, Increment f = INCF. Example:, Increment f = . Example:, Increment f = CNT, 1,. Example:, Increment f = 0. Example:, Increment f = . Before Instruction, Increment f = Before Instruction. Before Instruction, Increment f = Before Instruction. Before Instruction, Increment f = Before Instruction. Before Instruction, Increment f = Before Instruction. Before Instruction, Increment f = Before Instruction. CNT, Increment f = = =. CNT, Increment f = 0xFF.",
    "PIC18FXX2\nCNT, Increment f = . CNT, Increment f = . CNT, Increment f = . , Increment f = . , Increment f = 0. , Increment f = . , Increment f = . , Increment f = . , Increment f = Z C. , Increment f = . , Increment f = . , Increment f = . , Increment f = . After Instruction, Increment f = After Instruction. After Instruction, Increment f = After Instruction. After Instruction, Increment f = After Instruction. After Instruction, Increment f = After Instruction. After Instruction, Increment f = After Instruction. , Increment f = =. , Increment f = 0x00. , Increment f = . , Increment f = . , Increment f = . , Increment f = CNT Z. , Increment f = . , Increment f = . , Increment f = . , Increment f = . , Increment f = C. , Increment f = = 1 = 1",
    "PIC18FXX2\n=. , Increment f = . , Increment f = . , Increment f = . DC, Increment f = . DC, Increment f = . DC, Increment f = . DC, Increment f = . DC, Increment f = ",
    "PIC18FXX2\nSyntax:, Increment f, skip if 0 = [ label ] INCFSZ. Syntax:, Increment f, skip if 0 = [ label ] INCFSZ. Syntax:, Increment f, skip if 0 = f [,d [,a]. Syntax:, Increment f, skip if 0 = f [,d [,a]. Operands:, Increment f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Increment f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Increment f, skip if 0 = . Operands:, Increment f, skip if 0 = . Operation:, Increment f, skip if 0 = (f) + 1 \u2192 dest, skip if result = 0. Operation:, Increment f, skip if 0 = (f) + 1 \u2192 dest, skip if result = 0. Operation:, Increment f, skip if 0 = . Operation:, Increment f, skip if 0 = . Status Affected:, Increment f, skip if",
    "PIC18FXX2\n0 = None. Status Affected:, Increment f, skip if 0 = None. Status Affected:, Increment f, skip if 0 = . Status Affected:, Increment f, skip if 0 = . Encoding:, Increment f, skip if 0 = 0011. Encoding:, Increment f, skip if 0 = 11da. Encoding:, Increment f, skip if 0 = ffff. Encoding:, Increment f, skip if 0 = ffff\nDescription:\nThe contents of register 'f' are incremented. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f'. (default) If the result is 0, the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)",
    "PIC18FXX2\nNote: 3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nDecode\nIf skip:\nQ1\nNo\nQ2\nQ3\nQ4\nRead register 'f'\nQ2\nNo\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE    INCFSZ   CNT, 1, 0\nNZERO   :\nZERO    :\nBefore Instruction, 1 = Before Instruction. Before Instruction, 2 = Before Instruction. PC, 1 = =. PC, 2 = Address (HERE). After Instruction, 1 = After Instruction. After Instruction, 2 = . CNT, 1 = =. CNT, 2 = CNT + 1. If CNT, 1 = =. If CNT, 2 = 0;. PC, 1 = =. PC, 2 = Address (ZERO). If CNT, 1 = \u2260. If CNT, 2 = 0;. PC, 1 = =. PC, 2 = Address (NZERO)\nWrite to destination\nQ4\nNo operation",
    "PIC18FXX2\nSyntax:, Increment f, skip if not 0 = [ label ] INFSNZ. Syntax:, Increment f, skip if not 0 = [ label ] INFSNZ. Syntax:, Increment f, skip if not 0 = f [,d [,a]. Syntax:, Increment f, skip if not 0 = f [,d [,a]. Operands:, Increment f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Increment f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Increment f, skip if not 0 = . Operands:, Increment f, skip if not 0 = . Operation:, Increment f, skip if not 0 = (f) + 1 \u2192 dest, skip if result \u2260 0. Operation:, Increment f, skip if not 0 = (f) + 1 \u2192 dest, skip if result \u2260 0. Operation:, Increment f, skip if not 0 = . Operation:, Increment f, skip if not 0 =",
    "PIC18FXX2\n. Status Affected:, Increment f, skip if not 0 = None. Status Affected:, Increment f, skip if not 0 = None. Status Affected:, Increment f, skip if not 0 = . Status Affected:, Increment f, skip if not 0 = . Encoding:, Increment f, skip if not 0 = 0100. Encoding:, Increment f, skip if not 0 = 10da. Encoding:, Increment f, skip if not 0 = ffff. Encoding:, Increment f, skip if not 0 = ffff\nDescription:",
    "PIC18FXX2\nThe contents of register 'f' are incremented. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If the result is not 0, the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a twocycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\nCycles:",
    "Q Cycle Activity:\nQ1\nDecode\nIf skip:\nQ1\nNo\n1\n1(2)\nNote:\nQ2\n3 cycles if skip and followed by a 2-word instruction.\nQ3\nQ4\nRead register 'f'\nQ2\nNo\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE    INFSNZ  REG, 1, 0\nZERO\nNZERO",
    "Q Cycle Activity:\nBefore Instruction, 1 = Before Instruction. Before Instruction, 2 = Before Instruction. Before Instruction, 3 = Before Instruction. PC, 1 = =. PC, 2 = Address. PC, 3 = (HERE). After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. After Instruction, 3 = After Instruction. REG, 1 = =. REG, 2 = REG + 1. REG, 3 = . If REG, 1 = \u2260. If REG, 2 = 0;. If REG, 3 = . PC, 1 = =. PC, 2 = Address. PC, 3 = (NZERO). If REG, 1 = =. If REG, 2 = 0;. If REG, 3 = . PC, 1 = =. PC, 2 = Address. PC, 3 = (ZERO)\nWrite to destination\nQ4\nNo operation",
    "PIC18FXX2\nIORLW",
    "Inclusive OR literal with W\nSyntax:\n[ label ]    IORLW   k\nOperands:\n0 \u2264 k \u2264 255\nOperation:\n(W) .OR. k \u2192 W\nStatus Affected:\nN, Z\nEncoding:\n0000\n1001\nkkkk\nkkkk\nDescription:\nThe contents of W are OR'ed with the eight-bit literal 'k'. The result is placed in W.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral 'k'\nProcess Data\nWrite to W\nExample:\nIORLW\n0x35\nBefore Instruction\nW\n=\n0x9A\nAfter Instruction\nW\n=\n0xBF",
    "Inclusive OR W with f\nSyntax:\n[ label ]    IORWF     f [,d [,a]\nOperands:\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\nOperation:\n(W) .OR. (f) \u2192 dest\nStatus Affected:\nN, Z\nEncoding:\n0001\n00da\nffff\nffff\nDescription:\nInclusive OR W with register 'f'. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess Data\nWrite to\ndestination",
    "Example:\nIORWF  RESULT, 0, 1\nBefore Instruction\nRESULT = 0x13\nW\n= 0x91\nAfter Instruction\nRESULT =\n0x13\nW\n=\n0x93\nLFSR\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "Load FSR\n[ label ]    LFSR   f,k\n0\nf\n2\n0 \u2264 k \u2264 4095\n\u2264\n\u2264\nk \u2192 FSRf\nNone\n1110\n1110\n00ff k 11 kkk\n1111\n0000\nk 7 kkk kkkk\nThe 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.\n2\n2\nQ Cycle Activity:\nDecode, Q2 = Read literal 'k' MSB. Decode, Q3 = Process Data. Decode, Q4 = Write literal 'k' MSB to FSRfH. Decode, Q2 = Read literal 'k' LSB. Decode, Q3 = Process Data. Decode, Q4 = Write literal 'k' to FSRfL\nExample:\nLFSR 2, 0x3AB\nAfter Instruction\nFSR2H\n= 0x03\nFSR2L\n=\n0xAB",
    "PIC18FXX2\nSyntax:, Move f = [ label ]. Syntax:, Move f = MOVF. Syntax:, Move f = f [,d [,a]. Syntax:, Move f = . Operands:, Move f = 0 \u2264 f \u2264 255. Operands:, Move f = 0 \u2264 f \u2264 255. Operands:, Move f = 0 \u2264 f \u2264 255. Operands:, Move f = 0 \u2264 f \u2264 255. , Move f = d \u2208 [0,1]. , Move f = d \u2208 [0,1]. , Move f = d \u2208 [0,1]. , Move f = d \u2208 [0,1]. , Move f = a \u2208 [0,1]. , Move f = a \u2208 [0,1]. , Move f = a \u2208 [0,1]. , Move f = a \u2208 [0,1]. Operation:, Move f = f \u2192 dest. Operation:, Move f = f \u2192 dest. Operation:, Move f = f \u2192 dest. Operation:, Move f = f \u2192 dest. Status Affected:, Move f = N, Z. Status Affected:, Move f",
    "PIC18FXX2\n= N, Z. Status Affected:, Move f = N, Z. Status Affected:, Move f = N, Z. Encoding:, Move f = 0101. Encoding:, Move f = 00da. Encoding:, Move f = ffff. Encoding:, Move f = ffff\nDescription:\nThe contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256 byte bank. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write W",
    "PIC18FXX2\nBefore Instruction, MOVF = Before Instruction. Before Instruction, REG, 0, = . REG, MOVF = =. REG, REG, 0, = 0x22. W, MOVF = =. W, REG, 0, = 0xFF. After Instruction, MOVF = After Instruction. After Instruction, REG, 0, = . REG, MOVF = =. REG, REG, 0, = 0x22. W, MOVF = =. W, REG, 0, = 0x22",
    "PIC18FXX2\nSyntax:, Move f to f = [ label ] MOVFF f s ,f d. Syntax:, Move f to f = [ label ] MOVFF f s ,f d. Syntax:, Move f to f = [ label ] MOVFF f s ,f d. Syntax:, Move f to f = [ label ] MOVFF f s ,f d. Operands:, Move f to f = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, Move f to f = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, Move f to f = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, Move f to f = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operation:, Move f to f = (f s ) \u2192 f d. Operation:, Move f to f = (f s ) \u2192 f d. Operation:, Move f to f = (f s ) \u2192 f d. Operation:, Move f to f = (f s ) \u2192 f d. Status",
    "PIC18FXX2\nAffected:, Move f to f = None. Status Affected:, Move f to f = None. Status Affected:, Move f to f = None. Status Affected:, Move f to f = None. Encoding: 1st word (source), Move f to f = 1100. Encoding: 1st word (source), Move f to f = ffff. Encoding: 1st word (source), Move f to f = ffff. Encoding: 1st word (source), Move f to f = ffff s. 2nd word (destin.), Move f to f = 1111. 2nd word (destin.), Move f to f = ffff. 2nd word (destin.), Move f to f = ffff. 2nd word (destin.), Move f to f = ffff d\nDescription:",
    "PIC18FXX2\nThe contents of source register 'f s ' are moved to destination register 'f d '.  Location of source 'f s ' can be anywhere in the 4096 byte data space (000h to FFFh), and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W (a useful special situation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port).\nThe MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.\nNote:\nThe MOVFF instruction should not be used to modify interrupt settings while any interrupt is enabled. See Section 8.0 for more information.\nWords:\n2\nCycles:\n2 (3)\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode, 1 = Read register 'f' (src). Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f' (dest)\nExample:",
    "PIC18FXX2\nMOVFF   REG1, REG2\nBefore Instruction\nREG1\n=\n0x33\nREG2\n=\n0x11\nAfter Instruction\nREG1\n=\n0x33,\nREG2\n=\n0x33",
    "PIC18FXX2\nSyntax:, Move literal to low nibble in BSR = [ label ] MOVLB. Syntax:, Move literal to low nibble in BSR = . Syntax:, Move literal to low nibble in BSR = k. Syntax:, Move literal to low nibble in BSR = . Operands:, Move literal to low nibble in BSR = 0 \u2264 k \u2264 255. Operands:, Move literal to low nibble in BSR = . Operands:, Move literal to low nibble in BSR = . Operands:, Move literal to low nibble in BSR = . Operation:, Move literal to low nibble in BSR = k \u2192 BSR. Operation:, Move literal to low nibble in BSR = . Operation:, Move literal to low nibble in BSR = . Operation:, Move literal to low nibble in BSR = . Status Affected:, Move literal to low nibble in BSR = None. Status Affected:, Move literal to low nibble in BSR = . Status Affected:, Move literal to low nibble in BSR = . Status Affected:, Move literal to low nibble in BSR = .",
    "PIC18FXX2\nEncoding:, Move literal to low nibble in BSR = 0000. Encoding:, Move literal to low nibble in BSR = 0001. Encoding:, Move literal to low nibble in BSR = kkkk. Encoding:, Move literal to low nibble in BSR = kkkk. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Words:, Move literal to low nibble in BSR = 1. Words:, Move literal to low nibble in BSR = . Words:, Move literal to low nibble in BSR = . Words:, Move literal to",
    "PIC18FXX2\nlow nibble in BSR = . Cycles:, Move literal to low nibble in BSR = 1. Cycles:, Move literal to low nibble in BSR = . Cycles:, Move literal to low nibble in BSR = . Cycles:, Move literal to low nibble in BSR = . Q Cycle Activity:, Move literal to low nibble in BSR = . Q Cycle Activity:, Move literal to low nibble in BSR = . Q Cycle Activity:, Move literal to low nibble in BSR = . Q Cycle Activity:, Move literal to low nibble in BSR = . Q1, Move literal to low nibble in BSR = Q2. Q1, Move literal to low nibble in BSR = Q3. Q1, Move literal to low nibble in BSR = Q4. Q1, Move literal to low nibble in BSR = Q4. Decode, Move literal to low nibble in BSR = Read literal 'k'. Decode, Move literal to low nibble in BSR = Process Data. Decode, Move literal to low nibble in BSR = Write literal 'k' to BSR.",
    "PIC18FXX2\nDecode, Move literal to low nibble in BSR = Write literal 'k' to BSR. Example:, Move literal to low nibble in BSR = MOVLB. Example:, Move literal to low nibble in BSR = 5. Example:, Move literal to low nibble in BSR = . Example:, Move literal to low nibble in BSR = . Before Instruction BSR register, Move literal to low nibble in BSR = =. Before Instruction BSR register, Move literal to low nibble in BSR = 0x02. Before Instruction BSR register, Move literal to low nibble in BSR = . Before Instruction BSR register, Move literal to low nibble in BSR = . After Instruction BSR register, Move literal to low nibble in BSR = =. After Instruction BSR register, Move literal to low nibble in BSR = 0x05. After Instruction BSR register, Move literal to low nibble in BSR = . After Instruction BSR register, Move literal to low nibble in BSR = ",
    "PIC18FXX2\nSyntax:, Move literal to W = [ label ]. Syntax:, Move literal to W = MOVLW. Syntax:, Move literal to W = k. Syntax:, Move literal to W = . Operands:, Move literal to W = 0 \u2264 k \u2264 255. Operands:, Move literal to W = 0 \u2264 k \u2264 255. Operands:, Move literal to W = 0 \u2264 k \u2264 255. Operands:, Move literal to W = 0 \u2264 k \u2264 255. Operation:, Move literal to W = k \u2192 W. Operation:, Move literal to W = k \u2192 W. Operation:, Move literal to W = k \u2192 W. Operation:, Move literal to W = k \u2192 W. Status Affected:, Move literal to W = None. Status Affected:, Move literal to W = None. Status Affected:, Move literal to W = None. Status Affected:, Move literal to W = None. Encoding:, Move literal to W = 0000. Encoding:, Move literal to W = 1110. Encoding:, Move literal to W = kkkk kkkk. Encoding:, Move literal to W = . Description:, Move literal to W = The",
    "PIC18FXX2\neight-bit literal 'k' is loaded into W.. Description:, Move literal to W = The eight-bit literal 'k' is loaded into W.. Description:, Move literal to W = The eight-bit literal 'k' is loaded into W.. Description:, Move literal to W = The eight-bit literal 'k' is loaded into W.. Words:, Move literal to W = 1. Words:, Move literal to W = 1. Words:, Move literal to W = 1. Words:, Move literal to W = 1. Cycles:, Move literal to W = 1. Cycles:, Move literal to W = 1. Cycles:, Move literal to W = 1. Cycles:, Move literal to W = 1. Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q1, Move literal to W = Q2. Q1, Move literal to W = Q3. Q1, Move literal to W =",
    "PIC18FXX2\nQ4. Q1, Move literal to W = . Decode, Move literal to W = Read literal 'k'. Decode, Move literal to W = Process Data. Decode, Move literal to W = Write to W. Decode, Move literal to W = . Example:, Move literal to W = MOVLW. Example:, Move literal to W = 0x5A. Example:, Move literal to W = . Example:, Move literal to W = . After Instruction, Move literal to W = After Instruction. After Instruction, Move literal to W = After Instruction. After Instruction, Move literal to W = After Instruction. After Instruction, Move literal to W = After Instruction",
    "PIC18FXX2\nSyntax:, Move Wto f = [ label ] MOVWF. Syntax:, Move Wto f = [ label ] MOVWF. Syntax:, Move Wto f = [ label ] MOVWF. Syntax:, Move Wto f = f [,a]. Syntax:, Move Wto f = f [,a]. Operands:, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Move Wto f = . Operands:, Move Wto f = . Operation:, Move Wto f = (W) \u2192 f. Operation:, Move Wto f = (W) \u2192 f. Operation:, Move Wto f = (W) \u2192 f. Operation:, Move Wto f = . Operation:, Move Wto f = . Status Affected:, Move Wto f = None. Status Affected:, Move Wto f = None. Status Affected:, Move Wto",
    "PIC18FXX2\nf = None. Status Affected:, Move Wto f = . Status Affected:, Move Wto f = . Encoding:, Move Wto f = 0110. Encoding:, Move Wto f = 111a. Encoding:, Move Wto f = ffff. Encoding:, Move Wto f = ffff. Encoding:, Move Wto f = ffff. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256 byte bank. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256 byte bank. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Move Wto f = Move data from Wto register 'f'.",
    "PIC18FXX2\nLocation 'f' can be anywhere in the 256 byte bank. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256 byte bank. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256 byte bank. If 'a' is 0, the Access Bank will be selected, over- riding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Words:, Move Wto f = 1. Words:, Move Wto f = 1. Words:, Move Wto f = 1. Words:, Move Wto f =",
    "PIC18FXX2\n. Words:, Move Wto f = . Cycles:, Move Wto f = 1. Cycles:, Move Wto f = 1. Cycles:, Move Wto f = 1. Cycles:, Move Wto f = . Cycles:, Move Wto f = . Q Cycle Activity:, Move Wto f = Q Cycle Activity:. Q Cycle Activity:, Move Wto f = Q Cycle Activity:. Q Cycle Activity:, Move Wto f = Q Cycle Activity:. Q Cycle Activity:, Move Wto f = . Q Cycle Activity:, Move Wto f = . Q1, Move Wto f = Q2. Q1, Move Wto f = Q2. Q1, Move Wto f = Q3. Q1, Move Wto f = Q3. Q1, Move Wto f = Q4. Decode, Move Wto f = Read register 'f'. Decode, Move Wto f = Read register 'f'. Decode, Move Wto f = Process Data. Decode, Move Wto f = Process Data. Decode, Move Wto f = Write register 'f'. Example:, Move Wto f",
    "PIC18FXX2\n= MOVWF. Example:, Move Wto f = REG,. Example:, Move Wto f = 0. Example:, Move Wto f = . Example:, Move Wto f = . Before Instruction, Move Wto f = Before Instruction. Before Instruction, Move Wto f = Before Instruction. Before Instruction, Move Wto f = Before Instruction. Before Instruction, Move Wto f = Before Instruction. Before Instruction, Move Wto f = Before Instruction. W, Move Wto f = =. W, Move Wto f = 0x4F. W, Move Wto f = . W, Move Wto f = . W, Move Wto f = . REG, Move Wto f = =. REG, Move Wto f = 0xFF. REG, Move Wto f = . REG, Move Wto f = . REG, Move Wto f = . After Instruction, Move Wto f = After Instruction. After Instruction, Move Wto f = After Instruction. After Instruction, Move Wto f = After Instruction. After Instruction, Move Wto f = After Instruction. After Instruction, Move Wto f = After Instruction. W REG, Move Wto f",
    "PIC18FXX2\n= = =. W REG, Move Wto f = 0x4F 0x4F. W REG, Move Wto f = . W REG, Move Wto f = . W REG, Move Wto f = \nMULLW",
    "Multiply Literal with W\nSyntax:\n[ label ]    MULLW     k\nOperands:\n0 \u2264 k \u2264 255\nOperation:\n(W) x k \u2192 PRODH:PRODL\nStatus Affected:\nNone\nEncoding:\n0000\n1101\nkkkk\nkkkk\nDescription:\nAn unsigned multiplication is car- ried out between the contents of W and the 8-bit literal 'k'. The 16-bit result is placed in PRODH:PRODL register pair. PRODH contains the high byte. W is unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this opera- tion. A zero result is possible but not detected.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral 'k'\nProcess Data\nWrite registers PRODH: PRODL",
    "Example:\nMULLW   0xC4\nBefore Instruction\nW\n=\n0xE2\nPRODH\n=\n?\nPRODL\n=\n?\nAfter Instruction\nW\n= 0xE2\nPRODH\n=\n0xAD\nPRODL\n=\n0x08",
    "Example:\nSyntax:, Multiply Wwith f = [ label ] MULWF. Syntax:, Multiply Wwith f = [ label ] MULWF. Syntax:, Multiply Wwith f = [ label ] MULWF. Syntax:, Multiply Wwith f = f [,a]. Syntax:, Multiply Wwith f = f [,a]. Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W)",
    "Example:\nx (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Encoding:, Multiply Wwith f = 0000. Encoding:, Multiply Wwith f = 0000. Encoding:, Multiply Wwith f = 001a. Encoding:, Multiply Wwith f = ffff. Encoding:, Multiply Wwith f = ffff. Description:, Multiply Wwith f = An unsigned multiplication is car- ried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither overflow nor",
    "Example:\ncarry is possible in this opera- tion. A zero result is possible but not detected. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Multiply Wwith f = An unsigned multiplication is car- ried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this opera- tion. A zero result is possible but not detected. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Multiply Wwith f = An unsigned multiplication is car- ried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair.",
    "Example:\nPRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this opera- tion. A zero result is possible but not detected. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Multiply Wwith f = An unsigned multiplication is car- ried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this opera- tion. A zero result is possible but not detected. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Multiply Wwith f = An unsigned multiplication is car- ried out between the",
    "Example:\ncontents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this opera- tion. A zero result is possible but not detected. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Decode, Multiply Wwith f = . Decode, Multiply Wwith f = . Decode,",
    "Example:\nMultiply Wwith f = . Decode, Multiply Wwith f = . Decode, Multiply Wwith f = . Q1, Multiply Wwith f = Q2 Q3 Q4 Read register 'f' Process Data Write registers PRODH: PRODL MULWF REG, 1. Q1, Multiply Wwith f = Q2 Q3 Q4 Read register 'f' Process Data Write registers PRODH: PRODL MULWF REG, 1. Q1, Multiply Wwith f = Q2 Q3 Q4 Read register 'f' Process Data Write registers PRODH: PRODL MULWF REG, 1. Q1, Multiply Wwith f = Q2 Q3 Q4 Read register 'f' Process Data Write registers PRODH: PRODL MULWF REG, 1. Q1, Multiply Wwith f = Q2 Q3 Q4 Read register 'f' Process Data Write registers PRODH: PRODL MULWF REG, 1. W, Multiply Wwith f = =. W, Multiply Wwith f = . W, Multiply Wwith f = 0xC4. W, Multiply Wwith f = .",
    "Example:\nW, Multiply Wwith f = . REG, Multiply Wwith f = =. REG, Multiply Wwith f = . REG, Multiply Wwith f = 0xB5. REG, Multiply Wwith f = . REG, Multiply Wwith f = . PRODH, Multiply Wwith f = =. PRODH, Multiply Wwith f = . PRODH, Multiply Wwith f = . PRODH, Multiply Wwith f = . PRODH, Multiply Wwith f = . PRODL, Multiply Wwith f = =. PRODL, Multiply Wwith f = ? ?. PRODL, Multiply Wwith f = ? ?. PRODL, Multiply Wwith f = ? ?. PRODL, Multiply Wwith f = ? ?. After Instruction, Multiply Wwith f = . After Instruction, Multiply Wwith f = . After Instruction, Multiply Wwith f = . After Instruction, Multiply Wwith f = . After Instruction, Multiply Wwith f = . W REG, Multiply Wwith f = = =. W REG, Multiply Wwith f = . W REG, Multiply Wwith f = 0xC4",
    "Example:\n0xB5. W REG, Multiply Wwith f = . W REG, Multiply Wwith f = . PRODH, Multiply Wwith f = =. PRODH, Multiply Wwith f = . PRODH, Multiply Wwith f = . PRODH, Multiply Wwith f = . PRODH, Multiply Wwith f = . , Multiply Wwith f = . , Multiply Wwith f = 0x8A 0x94. , Multiply Wwith f = 0x8A 0x94. , Multiply Wwith f = 0x8A 0x94. , Multiply Wwith f = 0x8A 0x94. PRODL, Multiply Wwith f = =. PRODL, Multiply Wwith f = . PRODL, Multiply Wwith f = . PRODL, Multiply Wwith f = . PRODL, Multiply Wwith f = ",
    "Example:\nSyntax:, Negate f = [ label ]. Syntax:, Negate f = NEGF. Syntax:, Negate f = f [,a]. Syntax:, Negate f = . Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = . Operands:, Negate f = . Operation:, Negate f = ( f ) + 1 \u2192 f. Operation:, Negate f = ( f ) + 1 \u2192 f. Operation:, Negate f = . Operation:, Negate f = . Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = . Status Affected:, Negate f = . Encoding:, Negate f = 0110. Encoding:, Negate f = 110a. Encoding:, Negate f = ffff. Encoding:, Negate f = ffff. Description:, Negate f = Location",
    "Example:\n'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a'",
    "Example:\nis 0, the Access Bank will be selected, overriding the BSRvalue. If 'a' = 1, then the bank will be selected as per the BSR value.. Words:, Negate f = 1. Words:, Negate f = . Words:, Negate f = . Words:, Negate f = . Cycles:, Negate f = 1. Cycles:, Negate f = . Cycles:, Negate f = . Cycles:, Negate f = . Q Cycle Activity:, Negate f = Q Cycle Activity:. Q Cycle Activity:, Negate f = Q Cycle Activity:. Q Cycle Activity:, Negate f = Q Cycle Activity:. Q Cycle Activity:, Negate f = Q Cycle Activity:. Q1, Negate f = Q2. Q1, Negate f = Q3. Q1, Negate f = . Q1, Negate f = Q4. Example:, Negate f = NEGF. Example:, Negate f = REG,. Example:, Negate f = 1. Example:, Negate f = . Before Instruction REG =, Negate f = 0011. Before Instruction REG =, Negate",
    "Example:\nf = 1010. Before Instruction REG =, Negate f = [0x3A]. Before Instruction REG =, Negate f = . After Instruction REG =, Negate f = 1100. After Instruction REG =, Negate f = 0110. After Instruction REG =, Negate f = [0xC6]. After Instruction REG =, Negate f = ",
    "PIC18FXX2\nSyntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Operands:, No Operation = None. Operands:, No Operation = None. Operands:, No Operation = None. Operands:, No Operation = None. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Encoding:, No Operation = 0000 1111. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Words:, No Operation = 1. Words:,",
    "PIC18FXX2\nNo Operation = 1. Words:, No Operation = 1. Words:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Q Cycle Activity: Q1, No Operation = Q2. Q Cycle Activity: Q1, No Operation = Q3. Q Cycle Activity: Q1, No Operation = . Q Cycle Activity: Q1, No Operation = Q4. Decode, No Operation = No operation. Decode, No Operation = No operation. Decode, No Operation = . Decode, No Operation = No operation\nExample:\nNone.",
    "PIC18FXX2\nSyntax:, Pop Top of Return Stack = [ label ] POP. Syntax:, Pop Top of Return Stack = [ label ] POP. Syntax:, Pop Top of Return Stack = [ label ] POP. Syntax:, Pop Top of Return Stack = [ label ] POP. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return",
    "PIC18FXX2\nStack = 0000. Encoding:, Pop Top of Return Stack = 0110. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previ- ous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previ- ous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previ- ous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previ- ous value that was pushed",
    "PIC18FXX2\nonto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Q Cycle Activity: Q1, Pop Top of Return Stack = . Q Cycle Activity: Q1, Pop Top of Return Stack = . Q Cycle Activity: Q1, Pop Top of Return Stack = . Q Cycle Activity: Q1, Pop Top of Return Stack = . , Pop Top of Return Stack = Q2. , Pop Top of Return Stack = Q3. , Pop Top of Return Stack = . , Pop Top of Return Stack = Q4. Decode, Pop Top of Return Stack = . Decode, Pop Top of Return Stack = No operation. Decode, Pop Top of Return Stack = POP TOS value. Decode, Pop Top of Return",
    "PIC18FXX2\nStack = No operation. Example:, Pop Top of Return Stack = POP. Example:, Pop Top of Return Stack = . Example:, Pop Top of Return Stack = . Example:, Pop Top of Return Stack = . , Pop Top of Return Stack = GOTO. , Pop Top of Return Stack = NEW. , Pop Top of Return Stack = . , Pop Top of Return Stack = . Before Instruction, Pop Top of Return Stack = Before Instruction. Before Instruction, Pop Top of Return Stack = . Before Instruction, Pop Top of Return Stack = . Before Instruction, Pop Top of Return Stack = . TOS, Pop Top of Return Stack = . TOS, Pop Top of Return Stack = =. TOS, Pop Top of Return Stack = 0031A2h. TOS, Pop Top of Return Stack = . Stack (1 level down), Pop Top of Return Stack = Stack (1 level down). Stack (1 level down), Pop Top of Return Stack = =. Stack (1 level down), Pop Top of Return Stack = 014332h. Stack (1 level down), Pop Top of Return Stack = . After Instruction TOS PC, Pop Top of Return Stack = . After Instruction",
    "PIC18FXX2\nTOS PC, Pop Top of Return Stack = = =. After Instruction TOS PC, Pop Top of Return Stack = 014332h NEW. After Instruction TOS PC, Pop Top of Return Stack = ",
    "PIC18FXX2\nSyntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operation:, Push Top of Return Stack = (PC+2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC+2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC+2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC+2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC+2) \u2192 TOS. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of",
    "PIC18FXX2\nReturn Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0101. Encoding:, Push Top of Return Stack = . Description:, Push Top of Return Stack = The PC+2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows to implement a software stack by modifying TOS, and then push it onto the return stack.. Description:, Push Top of Return Stack = The PC+2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows to implement a software stack by modifying TOS, and then push it onto the return stack.. Description:, Push Top of Return Stack = The PC+2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows to implement a software stack by modifying TOS,",
    "PIC18FXX2\nand then push it onto the return stack.. Description:, Push Top of Return Stack = The PC+2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows to implement a software stack by modifying TOS, and then push it onto the return stack.. Description:, Push Top of Return Stack = The PC+2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows to implement a software stack by modifying TOS, and then push it onto the return stack.. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Q Cycle Activity:, Push Top of Return Stack = Q Cycle",
    "PIC18FXX2\nActivity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q1, Push Top of Return Stack = . Q1, Push Top of Return Stack = Q2. Q1, Push Top of Return Stack = Q3. Q1, Push Top of Return Stack = Q4. Q1, Push Top of Return Stack = . Decode, Push Top of Return Stack = PUSH PC+2 onto return stack. Decode, Push Top of Return Stack = PUSH PC+2 onto return stack. Decode, Push Top of Return Stack = No operation. Decode, Push Top of Return Stack = No operation. Decode, Push Top of Return Stack = . Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Before Instruction, Push Top",
    "PIC18FXX2\nof Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. TOS, Push Top of Return Stack = TOS. TOS, Push Top of Return Stack = TOS. TOS, Push Top of Return Stack = = 00345Ah = 000124h. TOS, Push Top of Return Stack = = 00345Ah = 000124h. TOS, Push Top of Return Stack = = 00345Ah = 000124h. After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = 000126h. After Instruction, Push Top of Return Stack = 000126h. After Instruction, Push Top of Return Stack = 000126h. PC TOS, Push Top of Return Stack = PC TOS. PC TOS, Push Top of Return Stack = PC TOS. PC TOS, Push Top of Return Stack = 000126h. PC",
    "PIC18FXX2\nTOS, Push Top of Return Stack = 000126h. PC TOS, Push Top of Return Stack = 000126h. Stack (1 level down), Push Top of Return Stack = Stack (1 level down). Stack (1 level down), Push Top of Return Stack = Stack (1 level down). Stack (1 level down), Push Top of Return Stack = 00345Ah. Stack (1 level down), Push Top of Return Stack = 00345Ah. Stack (1 level down), Push Top of Return Stack = 00345Ah\nRCALL",
    "Relative Call\nSyntax:\n[ label ]  RCALL    n\nOperands:\n-1024\n\u2264\nn\n\u2264\n1023\nOperation:\n(PC) + 2 \u2192 TOS,\n(PC) + 2 + 2n\n\u2192\nPC\nStatus Affected:\nNone\nEncoding:\n1101\n1nnn\nnnnn\nnnnn\nDescription:\nSubroutine call with a jump up to 1K from the current location.  First, return address (PC+2) is pushed onto the stack.  Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is a two-cycle instruction.\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'n'\nPush PC to stack\nProcess Data\nWrite to PC\nNo operation\nNo\noperation\nNo operation\nNo operation",
    "Example:\nHERE\nRCALL Jump\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nAfter Instruction\nPC\n=\nAddress\n(Jump)\nTOS =\nAddress\n(HERE+2)",
    "PIC18FXX2\nSyntax:, Reset = [ label ] RESET. Syntax:, Reset = [ label ] RESET. Syntax:, Reset = [ label ] RESET. Syntax:, Reset = [ label ] RESET. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Encoding:, Reset = 0000. Encoding:, Reset = 0000. Encoding:, Reset = 1111. Encoding:, Reset = 1111. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR",
    "PIC18FXX2\nReset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q1, Reset = Q2. Q1, Reset = Q3. Q1, Reset = Q3. Q1, Reset = Q4. Decode, Reset = Start reset. Decode, Reset = No operation. Decode, Reset = No operation. Decode, Reset = No operation. Example:, Reset = RESET. Example:, Reset = RESET. Example:, Reset = RESET. Example:, Reset = RESET. After Instruction, Reset = After Instruction. After",
    "PIC18FXX2\nInstruction, Reset = After Instruction. After Instruction, Reset = After Instruction. After Instruction, Reset = After Instruction. Registers = Flags* =, Reset = Registers = Flags* =. Registers = Flags* =, Reset = Reset Value Reset Value. Registers = Flags* =, Reset = Reset Value Reset Value. Registers = Flags* =, Reset = Reset Value Reset Value",
    "PIC18FXX2\nRETFIE, 1 = RETFIE. RETFIE, 2 = Return from Interrupt. RETFIE, 3 = Return from Interrupt. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] RETFIE [s]. Syntax:, 3 = [ label ] RETFIE [s]. Operands:, 1 = Operands:. Operands:, 2 = s \u2208 [0,1]. Operands:, 3 = s \u2208 [0,1]. Operation:, 1 = Operation:. Operation:, 2 = (TOS) \u2192 PC, 1 \u2192 GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 STATUS, (BSRS) \u2192 BSR,. Operation:, 3 = (TOS) \u2192 PC, 1 \u2192 GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 STATUS, (BSRS) \u2192 BSR,. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = GIE/GIEH, PEIE/GIEL.. Status",
    "PIC18FXX2\nAffected:, 3 = GIE/GIEH, PEIE/GIEL.. Encoding:, 1 = Encoding:. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Description:, 1 = Description:. Description:, 2 = Return from Interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0, no update of these registers occurs (default).. Description:, 3 = Return from Interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0, no update of these registers occurs (default).. Words:, 1 =",
    "PIC18FXX2\nWords:. Words:, 2 = 1. Words:, 3 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 2. Cycles:, 3 = 2. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 1 = Decode. , 2 = No operation. , 3 = No operation. , 1 = No operation. , 2 = No operation. , 3 = No operation\nExample:\nRETFIE  1\nAfter Interrupt\nPC\n=\nTOS\nW\n=\nWS\nBSR\n=\nBSRS\nSTATUS\n=\nSTATUSS\nGIE/GIEH, PEIE/GIEL\n=\n1",
    "PIC18FXX2\nSyntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Operands:, Return Literal to W = 0 \u2264 k \u2264 255. Operands:, Return Literal to W = 0 \u2264 k \u2264 255. Operands:, Return Literal to W = 0 \u2264 k \u2264 255. Operation:, Return Literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Encoding:, Return Literal to W = 0000. Encoding:, Return Literal to W = 1100. Encoding:, Return Literal to W = kkkk kkkk.",
    "PIC18FXX2\nDescription:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to",
    "PIC18FXX2\nW = Q Cycle Activity:. Q1, Return Literal to W = Q2. Q1, Return Literal to W = Q3. Q1, Return Literal to W = Q4. Decode, Return Literal to W = Read literal 'k'. Decode, Return Literal to W = Process Data. Decode, Return Literal to W = pop PC from stack, Write to W. No operation, Return Literal to W = No operation. No operation, Return Literal to W = No operation. No operation, Return Literal to W = No operation",
    "Example:\nCALL TABLE\n; W contains table\n; offset value\n; W now has\n; table value\n:\nTABLE\nADDWF PCL\n; W = offset\nRETLW k0\n; Begin table\nRETLW k1\n;\n:\n:\nRETLW kn\n; End of table",
    "Before Instruction\nW\n=\n0x07\nAfter Instruction\nW\n=\nvalue of kn\nRETURN\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:",
    "Return from Subroutine\n[ label ]    RETURN   [s]\ns \u2208 [0,1]\n(TOS) \u2192 PC, if s = 1\n(WS)\n\u2192\nW,\n(STATUSS)\n\u2192\nSTATUS,\n(BSRS)\n\u2192\nBSR,\nPCLATU, PCLATH are unchanged\nNone\n0000\n0000\n0001\n001s\nDescription:\nReturn from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's'= 1, the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0, no update of these registers occurs (default).\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nDecode, Q2 = No operation. Decode, Q3 = Process Data. Decode, Q4 = pop PC from stack. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nRETURN\nAfter Interrupt PC = TOS",
    "PIC18FXX2\nSyntax:, Rotate Left f through Carry = [ label ] RLCF f. Syntax:, Rotate Left f through Carry = . Syntax:, Rotate Left f through Carry = [,d [,a]. Syntax:, Rotate Left f through Carry = [,d [,a]. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n+1>, (f<7>) \u2192 C, (C) \u2192 dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n+1>,",
    "PIC18FXX2\n(f<7>) \u2192 C, (C) \u2192 dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n+1>, (f<7>) \u2192 C, (C) \u2192 dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n+1>, (f<7>) \u2192 C, (C) \u2192 dest<0>. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Encoding:, Rotate Left f through Carry = 0011. Encoding:, Rotate Left f through Carry = 01da. Encoding:, Rotate Left f through Carry = ffff. Encoding:, Rotate Left f through Carry = ffff. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry Flag. If 'd' is",
    "PIC18FXX2\n0, the result is placed in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry Flag. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry Flag. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is",
    "PIC18FXX2\n0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry Flag. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' = 1, then the bank will be selected as per the BSR value (default).. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Q Cycle Activity: Q1, Rotate Left f through Carry = . Q",
    "PIC18FXX2\nCycle Activity: Q1, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = . Decode, Rotate Left f through Carry = Q2 Read 'f'. Decode, Rotate Left f through Carry = Q3. Decode, Rotate Left f through Carry = Q3. Decode, Rotate Left f through Carry = Q4. , Rotate Left f through Carry = register. , Rotate Left f through Carry = Process Data. , Rotate Left f through Carry = Process Data. , Rotate Left f through Carry = Write to destination. Example:, Rotate Left f through Carry = RLCF. Example:, Rotate Left f through Carry = REG,. Example:, Rotate Left f through Carry = 0,. Example:, Rotate Left f through Carry = 0. Before Instruction REG = 1110 0110 C = 0, Rotate Left f through Carry = Before Instruction REG = 1110 0110 C = 0. Before Instruction REG = 1110 0110 C = 0, Rotate Left f through Carry = Before Instruction REG = 1110 0110 C = 0. Before Instruction REG = 1110 0110 C =",
    "PIC18FXX2\n0, Rotate Left f through Carry = Before Instruction REG = 1110 0110 C = 0. Before Instruction REG = 1110 0110 C = 0, Rotate Left f through Carry = Before Instruction REG = 1110 0110 C = 0. After REG, Rotate Left f through Carry = Instruction = 1110. After REG, Rotate Left f through Carry = 0110. After REG, Rotate Left f through Carry = . After REG, Rotate Left f through Carry = . W C, Rotate Left f through Carry = = 1100 = 1. W C, Rotate Left f through Carry = 1100. W C, Rotate Left f through Carry = . W C, Rotate Left f through Carry = \nRLNCF",
    "Rotate Left f (no carry)\nSyntax:\n[ label ]\nRLNCF     f [,d [,a]\nOperands:\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\nOperation:\n(f<n>) \u2192 dest<n+1>,\n(f<7>) \u2192 dest<0>\nStatus Affected:\nN, Z\nEncoding:\n0100\n01da\nffff\nffff\nDescription:\nThe contents of register 'f' are rotated one bit to the left. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite to\ndestination",
    "Example:\nRLNCF\nREG, 1, 0\nBefore Instruction\nREG\n=\n1010 1011\nAfter Instruction\nREG\n=\n0101 0111\nregister f",
    "Example:\nSyntax:, Rotate Right f through Carry = [ label ] RRCF. Syntax:, Rotate Right f through Carry = [ label ] RRCF. Syntax:, Rotate Right f through Carry = f [,d [,a]. Syntax:, Rotate Right f through Carry = f [,d [,a]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255. Operands:, Rotate Right f through Carry = . Operands:, Rotate Right f through Carry = . , Rotate Right f through Carry = d \u2208 [0,1]. , Rotate Right f through Carry = d \u2208 [0,1]. , Rotate Right f through Carry = . , Rotate Right f through Carry = . , Rotate Right f through Carry = a \u2208 [0,1]. , Rotate Right f through Carry = a \u2208 [0,1]. , Rotate Right f through Carry = . , Rotate Right f through Carry = . Operation:, Rotate Right f through Carry = (f<n>) \u2192 dest<n-1>,. Operation:, Rotate Right f through Carry = (f<n>)",
    "Example:\n\u2192 dest<n-1>,. Operation:, Rotate Right f through Carry = . Operation:, Rotate Right f through Carry = . , Rotate Right f through Carry = (f<0>) \u2192 C,. , Rotate Right f through Carry = (f<0>) \u2192 C,. , Rotate Right f through Carry = . , Rotate Right f through Carry = . , Rotate Right f through Carry = (C) \u2192 dest<7>. , Rotate Right f through Carry = (C) \u2192 dest<7>. , Rotate Right f through Carry = . , Rotate Right f through Carry = . Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = . Status Affected:, Rotate Right f through Carry = . Status Affected:, Rotate Right f through Carry = . Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 00da. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff\nDescription:",
    "Example:\nThe contents of register 'f' are rotated one bit to the right through the Carry Flag. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\n1\n1\nQ2\nRead register 'f'\nQ3\nProcess\nData\nExample:\nRRCF\nREG, 0, 0\nBefore Instruction\nREG\n=\n1110 0110\nC\n=\n0\nAfter Instruction\nREG\n=\n1110 0110\nW\n=\n0111 0011\nC\n=\n0\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\nQ4\nWrite to destination",
    "Example:\nSyntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]. Operands:, Rotate Right f (no carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (no carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (no carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1].",
    "Example:\nOperands:, Rotate Right f (no carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (no carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (no carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Right f (no carry) = (f<n>) \u2192 dest<n-1>, (f<0>) \u2192 dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \u2192 dest<n-1>, (f<0>) \u2192 dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \u2192 dest<n-1>, (f<0>) \u2192 dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \u2192 dest<n-1>, (f<0>) \u2192 dest<7>.",
    "Example:\nOperation:, Rotate Right f (no carry) = (f<n>) \u2192 dest<n-1>, (f<0>) \u2192 dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \u2192 dest<n-1>, (f<0>) \u2192 dest<7>. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Encoding:, Rotate Right f (no carry) = 0100. Encoding:, Rotate Right f (no carry) = 00da. Encoding:, Rotate Right f (no carry) = ffff. Encoding:, Rotate Right f (no carry) = ffff. Encoding:, Rotate Right f (no carry) = . Encoding:, Rotate Right f (no carry) = .",
    "Example:\nDescription:, Rotate Right f (no carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f (no carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f (no carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is 0, the result is placed in W. If",
    "Example:\n'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f (no carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f (no carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If",
    "Example:\n'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f (no carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. , Rotate Right f (no carry) = register f. , Rotate Right f (no carry) = register f. , Rotate Right f (no carry) = register f. , Rotate Right f (no carry) = register f. , Rotate Right f (no carry) = register f. , Rotate Right f (no carry) = register f. Words:, Rotate Right f (no carry) = 1. Words:, Rotate Right f (no carry) = 1. Words:, Rotate Right f (no carry) = 1. Words:, Rotate Right f (no carry) = 1.",
    "Example:\nWords:, Rotate Right f (no carry) = 1. Words:, Rotate Right f (no carry) = 1. Cycles:, Rotate Right f (no carry) = 1. Cycles:, Rotate Right f (no carry) = 1. Cycles:, Rotate Right f (no carry) = 1. Cycles:, Rotate Right f (no carry) = 1. Cycles:, Rotate Right f (no carry) = 1. Cycles:, Rotate Right f (no carry) = 1. Q Cycle Activity:, Rotate Right f (no carry) = . Q Cycle Activity:, Rotate Right f (no carry) = . Q Cycle Activity:, Rotate Right f (no carry) = . Q Cycle Activity:, Rotate Right f (no carry) = . Q Cycle Activity:, Rotate Right f (no carry) = . Q Cycle Activity:, Rotate Right f (no carry) = . Q1, Rotate Right f (no carry) = . Q1, Rotate Right f (no carry) = . Q1, Rotate Right f (no carry) = . Q1, Rotate Right f (no carry) = . Q1, Rotate Right f (no carry) = . Q1, Rotate Right f",
    "Example:\n(no carry) = . Decode, Rotate Right f (no carry) = Q2 Q3 Q4 Read register 'f' Process Data Write to destination. Decode, Rotate Right f (no carry) = Q2 Q3 Q4 Read register 'f' Process Data Write to destination. Decode, Rotate Right f (no carry) = Q2 Q3 Q4 Read register 'f' Process Data Write to destination. Decode, Rotate Right f (no carry) = Q2 Q3 Q4 Read register 'f' Process Data Write to destination. Decode, Rotate Right f (no carry) = Q2 Q3 Q4 Read register 'f' Process Data Write to destination. Decode, Rotate Right f (no carry) = Q2 Q3 Q4 Read register 'f' Process Data Write to destination. Example 1:, Rotate Right f (no carry) = RRNCF REG,. Example 1:, Rotate Right f (no carry) = 1,. Example 1:, Rotate Right f (no carry) = 0. Example 1:, Rotate Right f (no carry) = . Example 1:, Rotate Right f (no carry) = . Example 1:, Rotate Right f",
    "Example:\n(no carry) = . Before Instruction, Rotate Right f (no carry) = Before Instruction. Before Instruction, Rotate Right f (no carry) = Before Instruction. Before Instruction, Rotate Right f (no carry) = Before Instruction. Before Instruction, Rotate Right f (no carry) = Before Instruction. Before Instruction, Rotate Right f (no carry) = Before Instruction. Before Instruction, Rotate Right f (no carry) = Before Instruction. REG, Rotate Right f (no carry) = = 1101. REG, Rotate Right f (no carry) = 0111. REG, Rotate Right f (no carry) = . REG, Rotate Right f (no carry) = . REG, Rotate Right f (no carry) = . REG, Rotate Right f (no carry) = . After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. REG, Rotate Right f (no carry)",
    "Example:\n= =. REG, Rotate Right f (no carry) = 1011 REG, 0,. REG, Rotate Right f (no carry) = 0. REG, Rotate Right f (no carry) = . REG, Rotate Right f (no carry) = . REG, Rotate Right f (no carry) = . Example 2: Before Instruction, Rotate Right f (no carry) = Example 2: Before Instruction. Example 2: Before Instruction, Rotate Right f (no carry) = Example 2: Before Instruction. Example 2: Before Instruction, Rotate Right f (no carry) = Example 2: Before Instruction. Example 2: Before Instruction, Rotate Right f (no carry) = Example 2: Before Instruction. Example 2: Before Instruction, Rotate Right f (no carry) = Example 2: Before Instruction. Example 2: Before Instruction, Rotate Right f (no carry) = Example 2: Before Instruction. W, Rotate Right f (no carry) = =. W, Rotate Right f (no carry) = . W, Rotate Right f (no carry) = . W, Rotate Right f (no carry) = . W, Rotate Right f (no carry) = . W, Rotate Right f (no carry) = . After",
    "Example:\nInstruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. W, Rotate Right f (no carry) = =. W, Rotate Right f (no carry) = 1011. W, Rotate Right f (no carry) = . W, Rotate Right f (no carry) = . W, Rotate Right f (no carry) = . W, Rotate Right f (no carry) = . REG, Rotate Right f (no carry) = =. REG, Rotate Right f (no carry) = 0111. REG, Rotate Right f (no carry) = . REG, Rotate Right f (no carry) = . REG, Rotate Right f (no carry) = . REG, Rotate Right f (no carry) = ",
    "Example:\nSyntax:, Set f = [ label ] SETF f [,a]. Syntax:, Set f = [ label ] SETF f [,a]. Syntax:, Set f = [ label ] SETF f [,a]. Syntax:, Set f = [ label ] SETF f [,a]. Syntax:, Set f = [ label ] SETF f [,a]. Operands:, Set f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Set f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Set f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Set f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Set f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Set f = FFh \u2192 f. Operation:, Set f = FFh \u2192 f. Operation:, Set f = FFh \u2192 f. Operation:, Set f = FFh \u2192 f. Operation:, Set f = FFh \u2192 f. Status Affected:, Set f = None. Status Affected:, Set",
    "Example:\nf = None. Status Affected:, Set f = None. Status Affected:, Set f = None. Status Affected:, Set f = None. Encoding:, Set f = 0110. Encoding:, Set f = 100a. Encoding:, Set f = 100a. Encoding:, Set f = ffff. Encoding:, Set f = ffff. Description:, Set f = The contents of the specified regis- ter are set to FFh. If 'a' is 0, the Access Bank will be selected, over- riding the BSRvalue. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Set f = The contents of the specified regis- ter are set to FFh. If 'a' is 0, the Access Bank will be selected, over- riding the BSRvalue. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Set f = The contents of the specified regis- ter are set to FFh. If 'a' is 0, the Access Bank will be selected, over- riding the BSRvalue. If 'a'",
    "Example:\nis 1, then the bank will be selected as per the BSR value (default).. Description:, Set f = The contents of the specified regis- ter are set to FFh. If 'a' is 0, the Access Bank will be selected, over- riding the BSRvalue. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Set f = The contents of the specified regis- ter are set to FFh. If 'a' is 0, the Access Bank will be selected, over- riding the BSRvalue. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Words:, Set f = 1. Words:, Set f = 1. Words:, Set f = 1. Words:, Set f = 1. Words:, Set f = 1. Cycles:, Set f = 1. Cycles:, Set f = 1. Cycles:, Set f = 1. Cycles:, Set f = 1. Cycles:, Set f = 1. Q Cycle Activity:, Set f = . Q Cycle Activity:, Set f = . Q Cycle",
    "Example:\nActivity:, Set f = . Q Cycle Activity:, Set f = . Q Cycle Activity:, Set f = . Q1, Set f = Q2. Q1, Set f = Q2. Q1, Set f = Q3. Q1, Set f = Q3. Q1, Set f = Q4. Decode, Set f = Read register 'f'. Decode, Set f = Read register 'f'. Decode, Set f = Process Data. Decode, Set f = Process Data. Decode, Set f = Write register 'f'. Example:, Set f = SETF. Example:, Set f = . Example:, Set f = REG,1. Example:, Set f = . Example:, Set f = . Before Instruction, Set f = Before Instruction. Before Instruction, Set f = Before Instruction. Before Instruction, Set f = Before Instruction. Before Instruction, Set f = Before Instruction. Before Instruction, Set f = Before Instruction. REG, Set f = =. REG, Set f = 0x5A. REG, Set f = . REG, Set f = . REG, Set f = . After Instruction REG =, Set f = After Instruction",
    "Example:\nREG =. After Instruction REG =, Set f = 0xFF. After Instruction REG =, Set f = . After Instruction REG =, Set f = . After Instruction REG =, Set f = ",
    "PIC18FXX2\nSLEEP, 1 = SLEEP. SLEEP, 2 = Enter SLEEP mode. SLEEP, 3 = Enter SLEEP mode. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] SLEEP. Syntax:, 3 = [ label ] SLEEP. Operands:, 1 = Operands:. Operands:, 2 = None. Operands:, 3 = None. Operation:, 1 = Operation:. Operation:, 2 = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Operation:, 3 = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = TO, PD. Status Affected:, 3 = TO, PD. Encoding:, 1 = Encoding:. Encoding:, 2 = 0000. Encoding:, 3 = 0000 0000. Description:, 1 = Description:. Description:, 2 = The power-down status bit (PD) is cleared. The time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into SLEEP mode with the",
    "PIC18FXX2\noscillator stopped.. Description:, 3 = The power-down status bit (PD) is cleared. The time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into SLEEP mode with the oscillator stopped.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = 1. Q Cycle Activity:, 1 = Q1. Q Cycle Activity:, 2 = Q2. Q Cycle Activity:, 3 = Q3. , 1 = Decode. , 2 = No operation. , 3 = Process Data",
    "Example:\nSLEEP\nBefore Instruction\nTO\n=\n?\nPD\n=\n?\nAfter Instruction\nTO\n=\n1 \u2020\nPD\n=\n0\n- \u2020   If WDT causes wake-up, this bit is cleared.",
    "Example:\nSyntax:, Subtract f from Wwith borrow = [ label ] SUBFWB. Syntax:, Subtract f from Wwith borrow = [ label ] SUBFWB. Syntax:, Subtract f from Wwith borrow = [ label ] SUBFWB. Syntax:, Subtract f from Wwith borrow = f [,d [,a]. Syntax:, Subtract f from Wwith borrow = f [,d [,a]. Operands:, Subtract f from Wwith borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract f from Wwith borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract f from Wwith borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract f from Wwith borrow = . Operands:, Subtract f from Wwith borrow = . Operation:, Subtract f from Wwith borrow = (W) - (f) - (C) \u2192",
    "Example:\ndest. Operation:, Subtract f from Wwith borrow = (W) - (f) - (C) \u2192 dest. Operation:, Subtract f from Wwith borrow = (W) - (f) - (C) \u2192 dest. Operation:, Subtract f from Wwith borrow = . Operation:, Subtract f from Wwith borrow = . Status Affected:, Subtract f from Wwith borrow = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith borrow = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith borrow = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith borrow = . Status Affected:, Subtract f from Wwith borrow = . Encoding:, Subtract f from Wwith borrow = 0101. Encoding:, Subtract f from Wwith borrow = 01da. Encoding:, Subtract f from Wwith borrow = ffff. Encoding:, Subtract f from Wwith borrow = ffff. Encoding:, Subtract f from Wwith borrow",
    "Example:\n= ffff. Description:, Subtract f from Wwith borrow = Subtract register 'f' and carry flag (borrow) from W(2's complement method). If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored in register 'f' (default). If 'a' is 0, the Access Bankwill beselected, overriding the BSR value. If 'a' is 1, then the bank will be selected as. Description:, Subtract f from Wwith borrow = Subtract register 'f' and carry flag (borrow) from W(2's complement method). If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored in register 'f' (default). If 'a' is 0, the Access Bankwill beselected, overriding the BSR value. If 'a' is 1, then the bank will be selected as. Description:, Subtract f from Wwith borrow = Subtract register 'f' and carry flag (borrow) from W(2's complement",
    "Example:\nmethod). If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored in register 'f' (default). If 'a' is 0, the Access Bankwill beselected, overriding the BSR value. If 'a' is 1, then the bank will be selected as. Description:, Subtract f from Wwith borrow = Subtract register 'f' and carry flag (borrow) from W(2's complement method). If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored in register 'f' (default). If 'a' is 0, the Access Bankwill beselected, overriding the BSR value. If 'a' is 1, then the bank will be selected as. Description:, Subtract f from Wwith borrow = Subtract register 'f' and carry flag (borrow) from W(2's complement method). If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored in register 'f' (default). If",
    "Example:\n'a' is 0, the Access Bankwill beselected, overriding the BSR value. If 'a' is 1, then the bank will be selected as. Words:, Subtract f from Wwith borrow = 1. Words:, Subtract f from Wwith borrow = 1. Words:, Subtract f from Wwith borrow = 1. Words:, Subtract f from Wwith borrow = . Words:, Subtract f from Wwith borrow = . Cycles:, Subtract f from Wwith borrow = 1. Cycles:, Subtract f from Wwith borrow = 1. Cycles:, Subtract f from Wwith borrow = 1. Cycles:, Subtract f from Wwith borrow = . Cycles:, Subtract f from Wwith borrow = . Q1 Decode, Subtract f from Wwith borrow = Q2 Read register 'f' Process Data. Q1 Decode, Subtract f from Wwith borrow = Q2 Read register 'f' Process Data. Q1 Decode, Subtract f from Wwith borrow = Q3. Q1 Decode, Subtract f from Wwith borrow =",
    "Example:\nQ4 Write to. Q1 Decode, Subtract f from Wwith borrow = Q4 Write to. Example 1:, Subtract f from Wwith borrow = SUBFWB. Example 1:, Subtract f from Wwith borrow = SUBFWB. Example 1:, Subtract f from Wwith borrow = REG, 1,. Example 1:, Subtract f from Wwith borrow = . Example 1:, Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = = 3. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = = 2. W,",
    "Example:\nSubtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = = 1. C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . After Instruction REG, Subtract f from Wwith borrow = = FF. After Instruction REG, Subtract f from Wwith borrow = . After Instruction REG, Subtract f from Wwith borrow = . After Instruction REG, Subtract f from Wwith borrow = . After Instruction REG, Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = = 0 1. , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z,",
    "Example:\nSubtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = =. N, Subtract f from Wwith borrow = ; result is. N, Subtract f from Wwith borrow = negative. N, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = . Example 2:, Subtract f from Wwith borrow = SUBFWB. Example 2:, Subtract f from Wwith borrow = REG,. Example 2:, Subtract f from Wwith borrow = 0,. Example 2:, Subtract f from Wwith borrow = . Example 2:, Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = . Before Instruction, Subtract f from",
    "Example:\nWwith borrow = . REG, Subtract f from Wwith borrow = 2. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = = = 5. W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = = 1. C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow",
    "Example:\n= . REG, Subtract f from Wwith borrow = = 2. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = = 3 = 1 = =. W C, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = ; result is. , Subtract f from Wwith borrow = positive. , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . Example 3:, Subtract f from Wwith borrow = . Example 3:, Subtract f from Wwith borrow = . Example 3:, Subtract f from Wwith borrow = . Example 3:, Subtract f from Wwith borrow = . Example 3:,",
    "Example:\nSubtract f from Wwith borrow = . SUBFWB REG, 1, 0, Subtract f from Wwith borrow = SUBFWB REG, 1, 0. SUBFWB REG, 1, 0, Subtract f from Wwith borrow = SUBFWB REG, 1, 0. SUBFWB REG, 1, 0, Subtract f from Wwith borrow = SUBFWB REG, 1, 0. SUBFWB REG, 1, 0, Subtract f from Wwith borrow = SUBFWB REG, 1, 0. SUBFWB REG, 1, 0, Subtract f from Wwith borrow = SUBFWB REG, 1, 0. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. REG, Subtract f from Wwith borrow = = 1. REG, Subtract f from Wwith borrow",
    "Example:\n= . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = 2. W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = = = 0. C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = After Instruction. REG, Subtract f from Wwith borrow = = 0. REG,",
    "Example:\nSubtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = = 2. W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . C Z, Subtract f from Wwith borrow = = 1 =. C Z, Subtract f from Wwith borrow = ; result is. C Z, Subtract f from Wwith borrow = zero. C Z, Subtract f from Wwith borrow = . C Z, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = = 0. N, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = ",
    "Example:\nSyntax:, Subtract Wfrom literal = [ label ] SUBLW. Syntax:, Subtract Wfrom literal = [ label ] SUBLW. Syntax:, Subtract Wfrom literal = . Syntax:, Subtract Wfrom literal = . Operands:, Subtract Wfrom literal = 0 \u2264 k \u2264 255. Operands:, Subtract Wfrom literal = 0 \u2264 k \u2264 255. Operands:, Subtract Wfrom literal = . Operands:, Subtract Wfrom literal = . Operation:, Subtract Wfrom literal = k - (W) \u2192 W. Operation:, Subtract Wfrom literal = k - (W) \u2192 W. Operation:, Subtract Wfrom literal = . Operation:, Subtract Wfrom literal = . Status Affected:, Subtract Wfrom literal = N, OV, C, DC,. Status Affected:, Subtract Wfrom literal = Z. Status Affected:, Subtract Wfrom literal = . Status Affected:, Subtract Wfrom literal = . Encoding:, Subtract",
    "Example:\nWfrom literal = 0000. Encoding:, Subtract Wfrom literal = 1000. Encoding:, Subtract Wfrom literal = kkkk. Encoding:, Subtract Wfrom literal = kkkk. Description:, Subtract Wfrom literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Words:, Subtract Wfrom literal = 1. Words:, Subtract Wfrom literal = 1. Words:, Subtract Wfrom literal = . Words:, Subtract Wfrom literal = . Cycles:, Subtract Wfrom literal = 1. Cycles:, Subtract",
    "Example:\nWfrom literal = 1. Cycles:, Subtract Wfrom literal = . Cycles:, Subtract Wfrom literal = . Q Cycle Activity:, Subtract Wfrom literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom literal = Q Cycle Activity:. Q1, Subtract Wfrom literal = Q2. Q1, Subtract Wfrom literal = Q2. Q1, Subtract Wfrom literal = Q3. Q1, Subtract Wfrom literal = Q4. Decode, Subtract Wfrom literal = Read literal 'k'. Decode, Subtract Wfrom literal = Read literal 'k'. Decode, Subtract Wfrom literal = Process Data. Decode, Subtract Wfrom literal = Write to W. Example 1:, Subtract Wfrom literal = SUBLW. Example 1:, Subtract Wfrom literal = SUBLW.",
    "Example:\nExample 1:, Subtract Wfrom literal = . Example 1:, Subtract Wfrom literal = . 0x02 Before Instruction, Subtract Wfrom literal = 0x02 Before Instruction. 0x02 Before Instruction, Subtract Wfrom literal = 0x02 Before Instruction. 0x02 Before Instruction, Subtract Wfrom literal = 0x02 Before Instruction. 0x02 Before Instruction, Subtract Wfrom literal = 0x02 Before Instruction. W, Subtract Wfrom literal = . W, Subtract Wfrom literal = 1. W, Subtract Wfrom literal = . W, Subtract Wfrom literal = . C, Subtract Wfrom literal = = =. C, Subtract Wfrom literal = ?. C, Subtract Wfrom literal = . C, Subtract Wfrom literal = . After Instruction, Subtract Wfrom literal = After Instruction. After Instruction, Subtract Wfrom literal = After Instruction. After Instruction, Subtract Wfrom literal = After Instruction. After Instruction, Subtract",
    "Example:\nWfrom literal = After Instruction. W, Subtract Wfrom literal = =. W, Subtract Wfrom literal = 1. W, Subtract Wfrom literal = . W, Subtract Wfrom literal = . C, Subtract Wfrom literal = =. C, Subtract Wfrom literal = 1 ; result is. C, Subtract Wfrom literal = . C, Subtract Wfrom literal = . Z, Subtract Wfrom literal = =. Z, Subtract Wfrom literal = 0. Z, Subtract Wfrom literal = . Z, Subtract Wfrom literal = . N, Subtract Wfrom literal = =. N, Subtract Wfrom literal = 0. N, Subtract Wfrom literal = . N, Subtract Wfrom literal = . Example 2:, Subtract Wfrom literal = SUBLW. Example 2:, Subtract Wfrom literal = SUBLW. Example 2:, Subtract Wfrom literal = 0x02. Example 2:, Subtract Wfrom",
    "Example:\nliteral = 0x02. Before Instruction, Subtract Wfrom literal = Before Instruction. Before Instruction, Subtract Wfrom literal = Before Instruction. Before Instruction, Subtract Wfrom literal = Before Instruction. Before Instruction, Subtract Wfrom literal = Before Instruction. W, Subtract Wfrom literal = =. W, Subtract Wfrom literal = 2. W, Subtract Wfrom literal = . W, Subtract Wfrom literal = . C, Subtract Wfrom literal = =. C, Subtract Wfrom literal = ?. C, Subtract Wfrom literal = . C, Subtract Wfrom literal = . After Instruction, Subtract Wfrom literal = After Instruction. After Instruction, Subtract Wfrom literal = After Instruction. After Instruction, Subtract Wfrom literal = After Instruction. After Instruction, Subtract Wfrom literal = After Instruction. W, Subtract Wfrom literal = =. W, Subtract Wfrom literal = 0. W, Subtract Wfrom literal = . W, Subtract Wfrom",
    "Example:\nliteral = . C, Subtract Wfrom literal = =. C, Subtract Wfrom literal = 1 ; result is. C, Subtract Wfrom literal = . C, Subtract Wfrom literal = . Z N, Subtract Wfrom literal = = =. Z N, Subtract Wfrom literal = 1 0. Z N, Subtract Wfrom literal = . Z N, Subtract Wfrom literal = . 3:, Subtract Wfrom literal = . 3:, Subtract Wfrom literal = . 3:, Subtract Wfrom literal = . 3:, Subtract Wfrom literal = . Example SUBLW, Subtract Wfrom literal = Example SUBLW. Example SUBLW, Subtract Wfrom literal = Example SUBLW. Example SUBLW, Subtract Wfrom literal = 0x02. Example SUBLW, Subtract Wfrom literal = 0x02. Before Instruction, Subtract Wfrom literal = Before Instruction. Before Instruction, Subtract Wfrom literal = Before Instruction. Before",
    "Example:\nInstruction, Subtract Wfrom literal = Before Instruction. Before Instruction, Subtract Wfrom literal = Before Instruction. W, Subtract Wfrom literal = =. W, Subtract Wfrom literal = 3. W, Subtract Wfrom literal = . W, Subtract Wfrom literal = . C, Subtract Wfrom literal = =. C, Subtract Wfrom literal = ?. C, Subtract Wfrom literal = . C, Subtract Wfrom literal = . After Instruction, Subtract Wfrom literal = After Instruction. After Instruction, Subtract Wfrom literal = After Instruction. After Instruction, Subtract Wfrom literal = After Instruction. After Instruction, Subtract Wfrom literal = After Instruction. W, Subtract Wfrom literal = =. W, Subtract Wfrom literal = FF. W, Subtract Wfrom literal = ; (2's complement). W, Subtract Wfrom literal = ; (2's complement). C, Subtract Wfrom literal = =. C, Subtract",
    "Example:\nWfrom literal = 0 ; result is negative. C, Subtract Wfrom literal = . C, Subtract Wfrom literal = . Z, Subtract Wfrom literal = =. Z, Subtract Wfrom literal = 0. Z, Subtract Wfrom literal = . Z, Subtract Wfrom literal = . N, Subtract Wfrom literal = =. N, Subtract Wfrom literal = 1. N, Subtract Wfrom literal = . N, Subtract Wfrom literal = ",
    "PIC18FXX2\nSyntax:, Subtract Wfrom f = [ label ] SUBWF. Syntax:, Subtract Wfrom f = [ label ] SUBWF. Syntax:, Subtract Wfrom f = f [,d [,a]. Syntax:, Subtract Wfrom f = f [,d [,a]. Operands:, Subtract Wfrom f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f = . Operands:, Subtract Wfrom f = . Operation:, Subtract Wfrom f = (f) - (W) \u2192 dest. Operation:, Subtract Wfrom f = (f) - (W) \u2192 dest. Operation:, Subtract Wfrom f = . Operation:, Subtract Wfrom f = . Status Affected:, Subtract Wfrom f = N, OV,",
    "PIC18FXX2\nC, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = . Status Affected:, Subtract Wfrom f = . Encoding:, Subtract Wfrom f = 0101. Encoding:, Subtract Wfrom f = 11da. Encoding:, Subtract Wfrom f = ffff. Encoding:, Subtract Wfrom f = ffff. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in regis- ter 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method).",
    "PIC18FXX2\nIf 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in regis- ter 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in regis- ter 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in regis-",
    "PIC18FXX2\nter 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = . Words:, Subtract Wfrom f = . Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = . Cycles:, Subtract Wfrom f = . Q Cycle Activity:, Subtract Wfrom f = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom f = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom f = . Q Cycle Activity:, Subtract Wfrom f = . Q1, Subtract Wfrom f = Q2. Q1, Subtract Wfrom f = Q2. Q1, Subtract",
    "PIC18FXX2\nWfrom f = Q3 Q4. Q1, Subtract Wfrom f = Q3 Q4. Decode, Subtract Wfrom f = Read register 'f'. Decode, Subtract Wfrom f = Read register 'f'. Decode, Subtract Wfrom f = Process Data Write to destination. Decode, Subtract Wfrom f = Process Data Write to destination. Example 1:, Subtract Wfrom f = SUBWF REG,. Example 1:, Subtract Wfrom f = SUBWF REG,. Example 1:, Subtract Wfrom f = . Example 1:, Subtract Wfrom f = . Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = . Before Instruction, Subtract Wfrom f = . REG, Subtract Wfrom f = 3. REG, Subtract Wfrom f = 3. REG, Subtract Wfrom f = . REG, Subtract Wfrom",
    "PIC18FXX2\nf = . W, Subtract Wfrom f = 2. W, Subtract Wfrom f = 2. W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = . , Subtract Wfrom f = ?. , Subtract Wfrom f = ?. , Subtract Wfrom f = . , Subtract Wfrom f = . After Instruction, Subtract Wfrom f = 1. After Instruction, Subtract Wfrom f = 1. After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . W, Subtract Wfrom f = 2 ;. W, Subtract Wfrom f = 2 ;. W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = 1. C, Subtract",
    "PIC18FXX2\nWfrom f = 1. C, Subtract Wfrom f = result is positive. C, Subtract Wfrom f = result is positive. Z N, Subtract Wfrom f = 0 0. Z N, Subtract Wfrom f = 0 0. Z N, Subtract Wfrom f = . Z N, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = SUBWF. Example 2:, Subtract Wfrom f = REG,. Example 2:, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = . Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = . Before Instruction, Subtract Wfrom f = . REG, Subtract Wfrom f = 2. REG, Subtract Wfrom f = 2. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W, Subtract Wfrom f",
    "PIC18FXX2\n= 2. W, Subtract Wfrom f = 2. W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = ?. C, Subtract Wfrom f = ?. C, Subtract Wfrom f = . C, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = 2. After Instruction, Subtract Wfrom f = 2. After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . W, Subtract Wfrom f = 0. W, Subtract Wfrom f = 0. W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = ;. C, Subtract Wfrom f = result is zero. C, Subtract Wfrom f = . C, Subtract Wfrom f = . Z N, Subtract Wfrom f = 1 1. Z N, Subtract Wfrom f",
    "PIC18FXX2\n= 1 1. Z N, Subtract Wfrom f = . Z N, Subtract Wfrom f = . Example 3:, Subtract Wfrom f = 0. Example 3:, Subtract Wfrom f = REG,. Example 3:, Subtract Wfrom f = . Example 3:, Subtract Wfrom f = . , Subtract Wfrom f = SUBWF 1. , Subtract Wfrom f = SUBWF 1. , Subtract Wfrom f = . , Subtract Wfrom f = . Before Instruction REG =, Subtract Wfrom f = . Before Instruction REG =, Subtract Wfrom f = . Before Instruction REG =, Subtract Wfrom f = . Before Instruction REG =, Subtract Wfrom f = . W, Subtract Wfrom f = = 2. W, Subtract Wfrom f = = 2. W, Subtract Wfrom f = . W, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . After Instruction,",
    "PIC18FXX2\nSubtract Wfrom f = . After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . REG, Subtract Wfrom f = FFh. REG, Subtract Wfrom f = ;(2's complement). REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W, Subtract Wfrom f = = 2. W, Subtract Wfrom f = = 2. W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = =. C, Subtract Wfrom f = result is negative. C, Subtract Wfrom f = . C, Subtract Wfrom f = . Z, Subtract Wfrom f = 0 ;. Z, Subtract Wfrom f = 0 ;. Z, Subtract Wfrom f = . Z, Subtract Wfrom f = . , Subtract Wfrom f = 0. , Subtract Wfrom f =",
    "PIC18FXX2\n0. , Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = 1. , Subtract Wfrom f = 1. , Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = =. , Subtract Wfrom f = =. , Subtract Wfrom f = . , Subtract Wfrom f = . N, Subtract Wfrom f = . N, Subtract Wfrom f = . N, Subtract Wfrom f = . N, Subtract Wfrom f = . , Subtract Wfrom f = =. , Subtract Wfrom f = =. , Subtract Wfrom f = . , Subtract Wfrom f = ",
    "Subtract W from f with Borrow\nSyntax:\n[ label ] SUBWFB    f [,d [,a]\nOperands:\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\nOperation:\n(f) - (W) - (C) \u2192 dest\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0101\n10da\nffff\nffff\nDescription:\nSubtract W and the carry flag (borrow) from register 'f' (2's complement method). If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:",
    "Subtract W from f with Borrow\nExample 1:, Q2.Read register = Example 1:. Example 1:, 'f' = SUBWFB. Example 1:, Q3.Process Data = REG, 1, 0. Example 1:, Q4.Write to destination = . Before Instruction, Q2.Read register = Before Instruction. Before Instruction, 'f' = . Before Instruction, Q3.Process Data = . Before Instruction, Q4.Write to destination = . REG, Q2.Read register = =. REG, 'f' = 0x19. REG, Q3.Process Data = (0001. REG, Q4.Write to destination = 1001). W, Q2.Read register = =. W, 'f' = 0x0D. W, Q3.Process Data = (0000. W, Q4.Write to destination = 1101). C, Q2.Read register = =. C, 'f' = 1. C, Q3.Process Data = . C, Q4.Write to destination = . After Instruction, Q2.Read register = After Instruction. After Instruction, 'f' = . After Instruction,",
    "Subtract W from f with Borrow\nQ3.Process Data = . After Instruction, Q4.Write to destination = . REG, Q2.Read register = =. REG, 'f' = 0x0C. REG, Q3.Process Data = (0000. REG, Q4.Write to destination = 1011). W, Q2.Read register = =. W, 'f' = 0x0D. W, Q3.Process Data = (0000. W, Q4.Write to destination = 1101). C, Q2.Read register = =. C, 'f' = 1. C, Q3.Process Data = . C, Q4.Write to destination = . Z, Q2.Read register = =. Z, 'f' = 0. Z, Q3.Process Data = . Z, Q4.Write to destination = . N, Q2.Read register = =. N, 'f' = 0. N, Q3.Process Data = ; result is positive. N, Q4.Write to destination = ; result is positive. Example 2:, Q2.Read register = Example 2:. Example 2:,",
    "Subtract W from f with Borrow\n'f' = SUBWFB. Example 2:, Q3.Process Data = REG, 0, 0. Example 2:, Q4.Write to destination = . Before Instruction, Q2.Read register = Before Instruction. Before Instruction, 'f' = Before Instruction. Before Instruction, Q3.Process Data = . Before Instruction, Q4.Write to destination = . REG, Q2.Read register = =. REG, 'f' = 0x1B. REG, Q3.Process Data = (0001. REG, Q4.Write to destination = 1011). W, Q2.Read register = =. W, 'f' = 0x1A. W, Q3.Process Data = (0001. W, Q4.Write to destination = 1010). C, Q2.Read register = =. C, 'f' = 0. C, Q3.Process Data = . C, Q4.Write to destination = . After Instruction, Q2.Read register = After Instruction. After Instruction, 'f' = . After Instruction, Q3.Process Data = . After Instruction, Q4.Write to destination =",
    "Subtract W from f with Borrow\n. REG, Q2.Read register = =. REG, 'f' = 0x1B. REG, Q3.Process Data = (0001. REG, Q4.Write to destination = 1011). W, Q2.Read register = =. W, 'f' = 0x00. W, Q3.Process Data = . W, Q4.Write to destination = . C, Q2.Read register = =. C, 'f' = 1. C, Q3.Process Data = . C, Q4.Write to destination = . Z, Q2.Read register = =. Z, 'f' = 1. Z, Q3.Process Data = ; result is zero. Z, Q4.Write to destination = . N, Q2.Read register = =. N, 'f' = 0. N, Q3.Process Data = . N, Q4.Write to destination = . Example 3:, Q2.Read register = Example 3:. Example 3:, 'f' = SUBWFB. Example 3:, Q3.Process Data = REG, 1,. Example 3:,",
    "Subtract W from f with Borrow\nQ4.Write to destination = . Before Instruction, Q2.Read register = Before Instruction. Before Instruction, 'f' = Before Instruction. Before Instruction, Q3.Process Data = . Before Instruction, Q4.Write to destination = . REG, Q2.Read register = =. REG, 'f' = 0x03. REG, Q3.Process Data = (0000. REG, Q4.Write to destination = 0011). W, Q2.Read register = =. W, 'f' = 0x0E. W, Q3.Process Data = (0000 1101). W, Q4.Write to destination = . C, Q2.Read register = =. C, 'f' = 1. C, Q3.Process Data = . C, Q4.Write to destination = . After Instruction, Q2.Read register = After Instruction. After Instruction, 'f' = After Instruction. After Instruction, Q3.Process Data = . After Instruction, Q4.Write to destination = . REG, Q2.Read register = =. REG, 'f' = 0xF5. REG,",
    "Subtract W from f with Borrow\nQ3.Process Data = (1111 0100) ; [2's comp]. REG, Q4.Write to destination = . W, Q2.Read register = =. W, 'f' = 0x0E. W, Q3.Process Data = (0000 1101). W, Q4.Write to destination = . C, Q2.Read register = =. C, 'f' = 0. C, Q3.Process Data = . C, Q4.Write to destination = . Z, Q2.Read register = =. Z, 'f' = 0. Z, Q3.Process Data = . Z, Q4.Write to destination = . N, Q2.Read register = =. N, 'f' = 1. N, Q3.Process Data = ; result is negative. N, Q4.Write to destination = ",
    "SWAPF\nSwap f\nSyntax:\n[ label ]\nSWAPF   f [,d [,a]\nOperands:\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\nOperation:\n(f<3:0>) \u2192 dest<7:4>,\n(f<7:4>) \u2192 dest<3:0>\nStatus Affected:\nNone\nEncoding:\n0011\n10da\nffff\nffff\nDescription:\nThe upper and lower nibbles of reg- ister 'f' are exchanged. If 'd' is 0, the result is placed in W. If 'd' is 1, the result is placed in register 'f' (default). If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite to\ndestination",
    "Example:\nSWAPF\nREG, 1, 0\nBefore Instruction\nREG\n=\n0x53\nAfter Instruction\nREG\n=\n0x35",
    "Example:\nSyntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) +1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) -1 \u2192 TBLPTR; if TBLRD +*, (TBLPTR) +1 \u2192",
    "Example:\nTBLPTR; (Prog Mem (TBLPTR)) \u2192 TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) +1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) -1 \u2192 TBLPTR; if TBLRD +*, (TBLPTR) +1 \u2192 TBLPTR; (Prog Mem (TBLPTR)) \u2192 TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) +1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) -1",
    "Example:\n\u2192 TBLPTR; if TBLRD +*, (TBLPTR) +1 \u2192 TBLPTR; (Prog Mem (TBLPTR)) \u2192 TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) +1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) -1 \u2192 TBLPTR; if TBLRD +*, (TBLPTR) +1 \u2192 TBLPTR; (Prog Mem (TBLPTR)) \u2192 TABLAT;. Status Affected:None, Table Read = Status Affected:None. Status Affected:None, Table Read = Status Affected:None. Status Affected:None, Table Read = Status Affected:None. Status Affected:None, Table Read = Status Affected:None. Encoding:, Table Read = 0000. Encoding:, Table Read = 0000. Encoding:, Table Read =",
    "Example:\n0000. Encoding:, Table Read = 10nn nn=0 * =1 *+ =2 *-. Description:, Table Read = =3 +* This instruction is used to read the con- tents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2 Mbyte address range. TBLPTR[0] = 0: Least Significant Byte of Program. Description:, Table Read = =3 +* This instruction is used to read the con- tents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2 Mbyte address range. TBLPTR[0] = 0: Least Significant Byte of Program. Description:, Table Read = =3 +* This instruction is used to read the con- tents of Program Memory (P.M.). To address the program memory, a pointer called",
    "Example:\nTable Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2 Mbyte address range. TBLPTR[0] = 0: Least Significant Byte of Program. Description:, Table Read = =3 +* This instruction is used to read the con- tents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2 Mbyte address range. TBLPTR[0] = 0: Least Significant Byte of Program. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Q Cycle Activity: Q1, Table Read = . Q Cycle Activity: Q1, Table Read = . Q Cycle Activity: Q1, Table Read = . Q Cycle Activity:",
    "Example:\nQ1, Table Read = . Decode, Table Read = No. Decode, Table Read = . Decode, Table Read = . Decode, Table Read = No. No operation, Table Read = No operation (Read Program Memory) No operation No operation (Write TABLAT). No operation, Table Read = No operation (Read Program Memory) No operation No operation (Write TABLAT). No operation, Table Read = No operation (Read Program Memory) No operation No operation (Write TABLAT). No operation, Table Read = No operation (Read Program Memory) No operation No operation (Write TABLAT)",
    "TBLRD Table Read (cont'd)\nExample1: TBLRD *+, 1 = ;. Example1: TBLRD *+, 2 = . Before Instruction TABLAT, 1 = =. Before Instruction TABLAT, 2 = 0x55. TBLPTR, 1 = =. TBLPTR, 2 = 0x00A356. MEMORY(0x00A356), 1 = =. MEMORY(0x00A356), 2 = 0x34. After Instruction, 1 = =. After Instruction, 2 = 0x34. TABLAT TBLPTR, 1 = =. TABLAT TBLPTR, 2 = 0x00A357. Example2: TBLRD +*, 1 = ;. Example2: TBLRD +*, 2 = . Before Instruction TABLAT, 1 = =. Before Instruction TABLAT, 2 = 0xAA. TBLPTR, 1 = =. TBLPTR, 2 = 0x01A357. MEMORY(0x01A357), 1 = =. MEMORY(0x01A357), 2 = 0x12. MEMORY(0x01A358), 1 =",
    "TBLRD Table Read (cont'd)\n=. MEMORY(0x01A358), 2 = 0x34. After Instruction TABLAT, 1 = =. After Instruction TABLAT, 2 = 0x34. TBLPTR, 1 = =. TBLPTR, 2 = 0x01A358",
    "PIC18FXX2\nSyntax:, TBLWT = Syntax:. Syntax:, Table Write = [ label ]. Syntax:, Table Write = TBLWT ( *; *+; *-; +*). Syntax:, Table Write = TBLWT ( *; *+; *-; +*). Operands:, TBLWT = Operands:. Operands:, Table Write = None. Operands:, Table Write = None. Operands:, Table Write = None. Operation:, TBLWT = Operation:. Operation:, Table Write = if TBLWT*, (TABLAT) \u2192 Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \u2192 Holding Register; (TBLPTR) +1 \u2192 TBLPTR; if TBLWT*-, (TABLAT) \u2192 Holding Register; (TBLPTR) -1 \u2192 TBLPTR; if TBLWT+*, (TBLPTR) +1 \u2192 TBLPTR; (TABLAT) \u2192 Holding Register; None. Operation:, Table Write = if TBLWT*, (TABLAT) \u2192 Holding Register; TBLPTR - No Change; if",
    "PIC18FXX2\nTBLWT*+, (TABLAT) \u2192 Holding Register; (TBLPTR) +1 \u2192 TBLPTR; if TBLWT*-, (TABLAT) \u2192 Holding Register; (TBLPTR) -1 \u2192 TBLPTR; if TBLWT+*, (TBLPTR) +1 \u2192 TBLPTR; (TABLAT) \u2192 Holding Register; None. Operation:, Table Write = if TBLWT*, (TABLAT) \u2192 Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \u2192 Holding Register; (TBLPTR) +1 \u2192 TBLPTR; if TBLWT*-, (TABLAT) \u2192 Holding Register; (TBLPTR) -1 \u2192 TBLPTR; if TBLWT+*, (TBLPTR) +1 \u2192 TBLPTR; (TABLAT) \u2192 Holding Register; None. Status Affected:, TBLWT = Status Affected:. Status Affected:, Table Write = Status Affected:. Status Affected:, Table Write = Status Affected:. Status Affected:, Table Write = Status Affected:. Encoding:, TBLWT = Encoding:. Encoding:, Table",
    "PIC18FXX2\nWrite = 0000. Encoding:, Table Write = 0000. Encoding:, Table Write = 0000 11nn nn=0 * =1 *+ =2 *-. Description:, TBLWT = Description:. Description:, Table Write = This instruction uses the 3 LSbs of the TBLPTR to determine which of the 8 holding registers the TABLAT data is written to. The 8 holding registers are used to program the contents of Pro- gram Memory (P.M.). See Section 5.0 for information on writing to FLASH memory. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2 MBtye address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word. Description:, Table Write = This instruction uses the 3 LSbs of the TBLPTR to determine which of the 8 holding registers the TABLAT data is written to. The 8 holding registers are used to program the contents of Pro- gram",
    "PIC18FXX2\nMemory (P.M.). See Section 5.0 for information on writing to FLASH memory. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2 MBtye address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word. Description:, Table Write = This instruction uses the 3 LSbs of the TBLPTR to determine which of the 8 holding registers the TABLAT data is written to. The 8 holding registers are used to program the contents of Pro- gram Memory (P.M.). See Section 5.0 for information on writing to FLASH memory. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2 MBtye address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1:",
    "PIC18FXX2\nMost Significant Byte of Program Memory Word. Words:, TBLWT = Words:. Words:, Table Write = 1. Words:, Table Write = 1. Words:, Table Write = 1. Cycles:, TBLWT = Cycles:. Cycles:, Table Write = 2. Cycles:, Table Write = 2. Cycles:, Table Write = 2. Q Cycle Activity: Q1 Q2 Decode No operation, TBLWT = . Q Cycle Activity: Q1 Q2 Decode No operation, Table Write = . Q Cycle Activity: Q1 Q2 Decode No operation, Table Write = . Q Cycle Activity: Q1 Q2 Decode No operation, Table Write = . , TBLWT = . , Table Write = . , Table Write = Q3. , Table Write = Q4. , TBLWT = . , Table Write = . , Table Write = No operation. , Table Write = No operation No. , TBLWT = No operation. , Table Write = No operation (Read TABLAT). , Table Write = No operation. , Table Write = operation to Holding or Memory)",
    "PIC18FXX2\nExample1:, Table Write = TBLWT. Example1:,  = *+;. Example1:, (Continued) = . Before Instruction, Table Write = Before Instruction. Before Instruction,  = . Before Instruction, (Continued) = . TABLAT, Table Write = TABLAT. TABLAT,  = =. TABLAT, (Continued) = 0x55. TBLPTR, Table Write = TBLPTR. TBLPTR,  = =. TBLPTR, (Continued) = 0x00A356. HOLDING REGISTER (0x00A356), Table Write = HOLDING REGISTER (0x00A356). HOLDING REGISTER (0x00A356),  = =. HOLDING REGISTER (0x00A356), (Continued) = 0xFF. After Instructions (table write completion), Table Write = After Instructions (table write completion). After Instructions (table write completion),  = After Instructions (table write completion). After Instructions (table write completion), (Continued) = After Instructions (table write completion). TABLAT, Table Write = TABLAT. TABLAT,",
    "PIC18FXX2\n= =. TABLAT, (Continued) = 0x55. TBLPTR, Table Write = TBLPTR. TBLPTR,  = =. TBLPTR, (Continued) = 0x00A357. HOLDING REGISTER (0x00A356), Table Write = HOLDING REGISTER (0x00A356). HOLDING REGISTER (0x00A356),  = =. HOLDING REGISTER (0x00A356), (Continued) = 0x55. Example 2:, Table Write = TBLWT. Example 2:,  = +*;. Example 2:, (Continued) = . Before Instruction, Table Write = Before Instruction. Before Instruction,  = . Before Instruction, (Continued) = . TABLAT, Table Write = TABLAT. TABLAT,  = =. TABLAT, (Continued) = 0x34. TBLPTR, Table Write = TBLPTR. TBLPTR,  = =. TBLPTR, (Continued) = 0x01389A. HOLDING REGISTER (0x01389A), Table Write = HOLDING REGISTER (0x01389A). HOLDING REGISTER (0x01389A),",
    "PIC18FXX2\n= =. HOLDING REGISTER (0x01389A), (Continued) = 0xFF. HOLDING REGISTER (0x01389B), Table Write = HOLDING REGISTER (0x01389B). HOLDING REGISTER (0x01389B),  = =. HOLDING REGISTER (0x01389B), (Continued) = 0xFF. After Instruction (table write completion), Table Write = After Instruction (table write completion). After Instruction (table write completion),  = After Instruction (table write completion). After Instruction (table write completion), (Continued) = After Instruction (table write completion). TABLAT, Table Write = TABLAT. TABLAT,  = =. TABLAT, (Continued) = 0x34. TBLPTR, Table Write = TBLPTR. TBLPTR,  = =. TBLPTR, (Continued) = 0x01389B. HOLDING REGISTER (0x01389A), Table Write = HOLDING REGISTER (0x01389A). HOLDING REGISTER (0x01389A),",
    "PIC18FXX2\n= =. HOLDING REGISTER (0x01389A), (Continued) = 0xFF. HOLDING REGISTER (0x01389B), Table Write = HOLDING REGISTER (0x01389B). HOLDING REGISTER (0x01389B),  = =. HOLDING REGISTER (0x01389B), (Continued) = 0x34",
    "PIC18FXX2\nSyntax:, Test f, skip if 0 = [ label ] TSTFSZ f [,a]. Syntax:, Test f, skip if 0 = [ label ] TSTFSZ f [,a]. Syntax:, Test f, skip if 0 = [ label ] TSTFSZ f [,a]. Syntax:, Test f, skip if 0 = [ label ] TSTFSZ f [,a]. Operands:, Test f, skip if 0 = 0 \u2264 f \u2264 255. Operands:, Test f, skip if 0 = 0 \u2264 f \u2264 255. Operands:, Test f, skip if 0 = 0 \u2264 f \u2264 255. Operands:, Test f, skip if 0 = 0 \u2264 f \u2264 255. , Test f, skip if 0 = a \u2208 [0,1]. , Test f, skip if 0 = a \u2208 [0,1]. , Test f, skip if 0 = a \u2208 [0,1]. , Test f, skip if 0 = a \u2208 [0,1]. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f =",
    "PIC18FXX2\n0. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Encoding:, Test f, skip if 0 = 0110. Encoding:, Test f, skip if 0 = 011a. Encoding:, Test f, skip if 0 = ffff. Encoding:, Test f, skip if 0 = ffff. Description:, Test f, skip if 0 = If 'f' = 0, the next instruction,. Description:, Test f, skip if 0 = If 'f' = 0, the next instruction,. Description:, Test f, skip if 0 = If 'f' = 0, the next instruction,. Description:, Test f, skip if 0 = If 'f' = 0, the next instruction,",
    "PIC18FXX2\nIf 'f' = 0, the next instruction, fetched during the current instruction execution, is discarded and a NOP is executed, making this a twocycle instruction. If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\nQ Cycle Activity:\nQ1\nDecode\nIf skip:\nQ1\nNo\n1(2)\nNote: 3 cycles if skip and followed by a 2-word instruction.\nQ2\nQ3\nQ4\nRead register 'f'\nQ2\nNo\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nNo operation\nQ4\nNo operation\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE    TSTFSZ  CNT, 1\nNZERO    :\nZERO   :\nBefore Instruction\nPC = Address\n(HERE)\nAfter Instruction\nIf CNT\n= 0x00,\nPC\n= Address (ZERO)\nIf CNT\n\u2260 0x00,\nPC\n= Address (NZERO)",
    "PIC18FXX2\nSyntax:, Exclusive OR literal with W = [ label ] XORLW. Syntax:, Exclusive OR literal with W = [ label ] XORLW. Syntax:, Exclusive OR literal with W = k. Syntax:, Exclusive OR literal with W = . Operands:, Exclusive OR literal with W = 0 \u2264 k \u2264 255. Operands:, Exclusive OR literal with W = 0 \u2264 k \u2264 255. Operands:, Exclusive OR literal with W = . Operands:, Exclusive OR literal with W = . Operation:, Exclusive OR literal with W = (W) .XOR. k \u2192 W. Operation:, Exclusive OR literal with W = (W) .XOR. k \u2192 W. Operation:, Exclusive OR literal with W = . Operation:, Exclusive OR literal with W = . Status Affected:, Exclusive OR literal with W = N, Z. Status Affected:, Exclusive OR literal with W = . Status Affected:, Exclusive OR literal with W = . Status Affected:, Exclusive OR literal with W = . Encoding:, Exclusive OR literal with W = 0000. Encoding:, Exclusive OR literal with W = 1010. Encoding:, Exclusive OR literal with W =",
    "PIC18FXX2\nkkkk. Encoding:, Exclusive OR literal with W = kkkk. Description:, Exclusive OR literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Words:, Exclusive OR literal with W = 1. Words:, Exclusive OR literal with W = . Words:, Exclusive OR literal with W = . Words:, Exclusive OR literal with W = . Cycles:, Exclusive OR literal with W = 1. Cycles:, Exclusive OR literal with W = . Cycles:, Exclusive OR literal with W = . Cycles:, Exclusive OR literal with W = . Q Cycle Activity: Q1, Exclusive OR literal with W = Q2. Q Cycle Activity:",
    "PIC18FXX2\nQ1, Exclusive OR literal with W = Q3. Q Cycle Activity: Q1, Exclusive OR literal with W = . Q Cycle Activity: Q1, Exclusive OR literal with W = Q4. Decode, Exclusive OR literal with W = Read literal 'k'. Decode, Exclusive OR literal with W = Process Data. Decode, Exclusive OR literal with W = . Decode, Exclusive OR literal with W = Write to W\nExample:\nXORLW\n0xAF\nBefore Instruction\nW\n=\n0xB5\nAfter Instruction\nW\n=\n0x1A",
    "Exclusive OR W with f\nSyntax:\n[ label ]\nXORWF     f [,d [,a]\nOperands:\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\nOperation:\n(W) .XOR. (f) \u2192 dest\nStatus Affected:\nN, Z\nEncoding:\n0001\n10da\nffff\nffff\nDescription:\nExclusive OR the contents of W with register 'f'. If 'd' is 0, the result is stored in W. If 'd' is 1, the result is stored back in the register 'f' (default).   If 'a' is 0, the Access Bank will be selected, overriding the BSR value. If 'a' is 1, then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite to\ndestination",
    "Example:\nXORWF   REG, 1, 0\nBefore Instruction\nREG\n=\n0xAF\nW\n=\n0xB5\nAfter Instruction\nREG\n=\n0x1A\nW\n=\n0xB5",
    "21.0 DEVELOPMENT SUPPORT\nThe PICmicro fi  microcontrollers are supported with a full range of hardware and software development tools:\nGLYPH<129> Integrated Development Environment\n-MPLAB fi  IDE Software\nGLYPH<129> Assemblers/Compilers/Linkers\n-MPASM TM  Assembler\n-MPLAB C17 and MPLAB C18 C Compilers\n-MPLINK TM  Object Linker/ MPLIB TM  Object Librarian\nGLYPH<129> Simulators\n-MPLAB SIM Software Simulator\nGLYPH<129> Emulators\n-MPLAB ICE 2000 In-Circuit Emulator\n-ICEPIC\u2122 In-Circuit Emulator\nGLYPH<129> In-Circuit Debugger\n-MPLAB ICD\nGLYPH<129> Device Programmers\n-PRO MATE fi  II Universal Device Programmer\n-PICSTART fi  Plus Entry-Level Development Programmer\nGLYPH<129> Low Cost Demonstration Boards\n-PICDEM TM  1 Demonstration Board\n-PICDEM 2 Demonstration Board\n-PICDEM   3 Demonstration Board\n-PICDEM   17 Demonstration Board\n-KEELOQ fi  Demonstration Board",
    "21.1 MPLAB Integrated Development Environment Software\nThe MPLAB IDE software brings an ease of software development previously unseen in the 8-bit microcontroller market. The MPLAB IDE is a Windows fi  based application that contains:\nGLYPH<129> An interface to debugging tools\n-simulator\n-programmer (sold separately)\n-emulator (sold separately)\n-in-circuit debugger (sold separately)\nGLYPH<129> A full-featured editor\nGLYPH<129> A project manager\nGLYPH<129> Customizable toolbar and key mapping\nGLYPH<129> A status bar\nGLYPH<129> On-line help\nThe MPLAB IDE allows you to:\nGLYPH<129> Edit your source files (either assembly or 'C')\nGLYPH<129> One touch assemble (or compile) and download to PICmicro emulator and simulator tools (automatically updates all project information)\nGLYPH<129> Debug using:\n-source files\n-absolute listing file\n-machine code",
    "21.1 MPLAB Integrated Development Environment Software\nThe ability to use MPLAB IDE with multiple debugging tools  allows  users  to  easily  switch  from  the  costeffective  simulator  to  a  full-featured  emulator  with minimal retraining.",
    "21.2 MPASM Assembler\nThe  MPASM  assembler  is  a  full-featured  universal macro assembler for all PICmicro MCU's.\nThe MPASM assembler has a command line interface and a Windows shell. It can be used as a stand-alone application on a Windows 3.x or greater system, or it can be used through MPLAB IDE. The MPASM assembler generates relocatable object files for the MPLINK object  linker,  Intel fi standard  HEX  files,  MAP  files  to detail memory usage and symbol reference, an absolute LST file that contains source lines and generated machine code, and a COD file for debugging.\nThe MPASM assembler features include:\nGLYPH<129> Integration into MPLAB IDE projects.\nGLYPH<129> User-defined macros to streamline assembly code.\nGLYPH<129> Conditional assembly for multi-purpose source files.\nGLYPH<129> Directives that allow complete control over the assembly process.",
    "21.3 MPLAB C17 and MPLAB C18 C Compilers\nThe MPLAB C17 and MPLAB C18 Code Development Systems are complete ANSI 'C' compilers for Microchip's  PIC17CXXX  and  PIC18CXXX  family  of microcontrollers, respectively. These compilers provide powerful  integration capabilities  and  ease  of  use  not found with other compilers.\nFor easier source level debugging, the compilers provide  symbol  information  that  is  compatible  with  the MPLAB IDE memory display.",
    "21.4 MPLINK Object Linker/ MPLIB Object Librarian\nThe MPLINK object linker combines relocatable objects  created  by  the  MPASM  assembler  and  the MPLAB C17 and MPLAB C18 C compilers. It can also link  relocatable  objects  from  pre-compiled  libraries, using directives from a linker script.\nThe  MPLIB  object  librarian  is  a  librarian  for  precompiled  code  to  be  used  with  the  MPLINK  object linker.  When  a  routine  from  a  library  is  called  from another source file, only the modules that contain that routine will be linked in with the application. This allows large libraries to  be used efficiently in many different applications. The MPLIB object librarian manages the creation and modification of library files.\nThe MPLINK object linker features include:\nGLYPH<129> Integration with MPASM assembler and MPLAB C17 and MPLAB C18 C compilers.\nGLYPH<129> Allows all memory areas to be defined as sections to provide link-time flexibility.\nThe MPLIB object librarian features include:",
    "21.4 MPLINK Object Linker/ MPLIB Object Librarian\nGLYPH<129> Easier linking because single libraries can be included instead of many smaller files.\nGLYPH<129> Helps keep code maintainable by grouping related modules together.\nGLYPH<129> Allows libraries to be created and modules to be added, listed, replaced, deleted or extracted.",
    "21.5 MPLAB SIM Software Simulator\nThe MPLAB SIM software simulator allows code development in a PC-hosted environment by simulating the PICmicro  series  microcontrollers  on  an  instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a file, or user-defined key press, to any of the pins. The execution  can  be  performed  in  single  step,  execute until break, or trace mode.\nThe MPLAB SIM simulator fully supports symbolic debugging using the MPLAB C17 and the MPLAB C18 C compilers and the MPASM assembler. The software simulator offers the flexibility to develop and debug code outside of the laboratory environment, making it an excellent multiproject software development tool.",
    "21.6 MPLAB ICE High Performance Universal In-Circuit Emulator with MPLAB IDE\nThe MPLAB ICE universal in-circuit emulator is intended to  provide  the  product  development  engineer  with  a complete microcontroller design tool set for PICmicro microcontrollers (MCUs). Software control of the MPLAB  ICE  in-circuit  emulator  is  provided  by  the MPLAB  Integrated  Development  Environment  (IDE), which allows editing, building, downloading and source debugging from a single environment.\nThe MPLAB ICE 2000 is a full-featured emulator system with enhanced trace, trigger and data monitoring features. Interchangeable processor modules allow the system to be easily reconfigured for emulation of different processors.  The  universal  architecture of the MPLAB  ICE  in-circuit  emulator  allows  expansion  to support new PICmicro microcontrollers.\nThe MPLAB ICE in-circuit emulator system has been designed as a real-time emulation system, with advanced features that are  generally  found  on  more expensive  development  tools.  The  PC  platform  and Microsoft fi Windows environment were chosen to best make these features available to you, the end user.",
    "21.7 ICEPIC In-Circuit Emulator\nThe ICEPIC low cost, in-circuit emulator is a solution for  the  Microchip  Technology  PIC16C5X,  PIC16C6X, PIC16C7X  and  PIC16CXXX  families  of  8-bit  OneTime-Programmable (OTP) microcontrollers. The modular system can support different subsets of PIC16C5X or  PIC16CXXX  products  through  the  use  of  interchangeable personality modules, or daughter boards. The  emulator  is  capable  of  emulating  without  target application circuitry being present.",
    "21.8 MPLAB ICD In-Circuit Debugger\nMicrochip's In-Circuit Debugger, MPLAB ICD, is a powerful, low cost, run-time development tool. This tool is based on the FLASH PICmicro MCUs and can be used to develop for this and other PICmicro microcontrollers. The MPLAB ICD utilizes the in-circuit debugging capability built into the FLASH devices. This feature, along with Microchip's In-Circuit Serial Programming TM  protocol,  offers  cost-effective  in-circuit  FLASH  debugging from  the graphical user interface of the MPLAB Integrated Development Environment. This enables a designer to develop and debug source code by watching variables, single-stepping and setting break points. Running at full speed enables testing hardware in realtime.",
    "21.9 PRO MATE II Universal Device Programmer\nThe PRO MATE II universal device programmer is a full-featured programmer,  capable of operating in stand-alone mode, as well as PC-hosted mode. The PRO MATE II device programmer is CE compliant.\nThe PRO MATE II device programmer has programmable VDD and VPP supplies, which allow it to verify programmed memory at VDD min and VDD max for maximum reliability. It has an LCD display for instructions and error messages, keys to enter commands and a modular detachable socket assembly to support various package types. In stand-alone mode, the PRO MATE II device programmer can read, verify, or program PICmicro devices. It can also set code protection in this mode.",
    "21.10 PICSTART Plus Entry Level Development Programmer\nThe PICSTART Plus development programmer is an easy-to-use,  low  cost,  prototype  programmer.  It  connects  to  the  PC  via  a  COM  (RS-232)  port.  MPLAB Integrated Development Environment software makes using the programmer simple and efficient.\nThe  PICSTART  Plus  development  programmer  supports all PICmicro devices with up to 40 pins. Larger pin count devices, such as the PIC16C92X and PIC17C76X, may be supported with an adapter socket. The PICSTART Plus development programmer is CE compliant.",
    "21.11 PICDEM 1 Low Cost PICmicro Demonstration Board\nThe PICDEM 1 demonstration board is a simple board which  demonstrates  the  capabilities  of  several  of Microchip's microcontrollers. The microcontrollers supported  are:  PIC16C5X  (PIC16C54  to  PIC16C58A), PIC16C61, PIC16C62X, PIC16C71, PIC16C8X, PIC17C42,  PIC17C43  and  PIC17C44.  All  necessary hardware and software is included to run basic demo programs. The user can program the sample microcontrollers  provided  with  the  PICDEM  1  demonstration board  on  a  PRO MATE  II  device  programmer,  or  a PICSTART Plus development programmer, and easily test firmware. The user can also connect the PICDEM 1 demonstration board to the MPLAB ICE incircuit emulator and download the firmware to the emulator for testing. A prototype area is available for the user to build some additional hardware and connect it to the microcontroller socket(s). Some of the features include an RS-232 interface, a potentiometer for simulated  analog  input,  push  button  switches  and",
    "21.11 PICDEM 1 Low Cost PICmicro Demonstration Board\neight LEDs connected to PORTB.",
    "21.12 PICDEM 2 Low Cost PIC16CXX Demonstration Board\nThe PICDEM 2 demonstration board is a simple demonstration board that supports the PIC16C62, PIC16C64, PIC16C65, PIC16C73 and PIC16C74 microcontrollers. All the necessary hardware and software is included to run the basic demonstration programs. The user can program the sample microcontrollers provided with the PICDEM 2 demonstration board on a PRO MATE II device programmer, or  a  PICSTART  Plus  development  programmer,  and easily test firmware. The MPLAB ICE in-circuit emulator may also be used with the PICDEM 2 demonstration board to test firmware. A prototype area has been provided to the user for adding additional hardware and connecting it to the microcontroller socket(s). Some of the features include a RS-232 interface, push button switches, a potentiometer for simulated analog input, a serial EEPROM to demonstrate usage of the I 2 C TM  bus and  separate  headers  for  connection  to  an  LCD module and a keypad.",
    "21.13 PICDEM 3 Low Cost PIC16CXXX Demonstration Board\nThe PICDEM 3 demonstration board is a simple demonstration  board  that  supports  the  PIC16C923  and PIC16C924 in the PLCC package. It will also support future 44-pin PLCC microcontrollers with an LCD Module. All the necessary  hardware  and  software  is included to run the basic demonstration programs. The user  can  program  the  sample  microcontrollers  provided  with  the  PICDEM  3  demonstration  board  on  a PRO MATE II device programmer, or a PICSTART Plus development programmer with an adapter socket, and easily test firmware. The MPLAB ICE in-circuit emulator may also be used with the PICDEM 3 demonstration board to test firmware. A prototype area has been provided to the user for adding hardware and connecting it to the microcontroller socket(s). Some of the features include  a  RS-232  interface,  push  button  switches,  a potentiometer for simulated analog input, a thermistor and  separate  headers  for  connection  to  an  external LCD  module  and  a  keypad.  Also  provided  on  the PICDEM 3 demonstration board is a LCD panel, with 4 commons and 12 segments, that is capable of displaying  time,",
    "21.13 PICDEM 3 Low Cost PIC16CXXX Demonstration Board\ntemperature  and  day  of  the  week.  The PICDEM 3 demonstration board provides an additional RS-232 interface and Windows software for showing the demultiplexed LCD signals on a PC. A simple serial interface  allows  the  user  to  construct  a  hardware demultiplexer for the LCD signals.",
    "21.14 PICDEM 17 Demonstration Board\nThe PICDEM 17 demonstration board is an evaluation board  that  demonstrates  the  capabilities  of  several Microchip microcontrollers, including PIC17C752, PIC17C756A, PIC17C762 and PIC17C766. All necessary hardware is included to run basic demo programs, which are supplied on a 3.5-inch disk. A programmed sample  is  included  and  the  user  may  erase  it  and program it with the other sample programs using the PRO MATE II device programmer, or the PICSTART Plus development programmer, and easily debug and test the sample code. In addition, the PICDEM 17 demonstration board supports downloading of programs to and executing out of external FLASH memory on board. The PICDEM 17 demonstration  board  is  also  usable with the MPLAB  ICE in-circuit emulator, or the PICMASTER emulator and all of the sample programs can be run and modified using either emulator. Additionally,  a  generous  prototype  area  is  available  for  user hardware.",
    "21.15 KEELOQ Evaluation and Programming Tools\nKEELOQ  evaluation  and  programming  tools  support Microchip's HCS Secure Data Products. The HCS evaluation  kit  includes  a  LCD  display  to  show  changing codes,  a  decoder  to  decode  transmissions  and  a programming interface to program test transmitters.",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\nMCRFXXX,  = . MCRFXXX,  = . MCRFXXX,  = . MCRFXXX,  = . MCRFXXX,  = . MCRFXXX,  = . MCRFXXX,  = . MCRFXXX,  = . MCRFXXX,  = . MCRFXXX,  = . MCRFXXX,  = . MCRFXXX,  = . MCRFXXX,  = . MCRFXXX,  = !. MCRFXXX,  = !. MCRFXXX, ! 76, 77. = ! ! 72, 73, 74,. HCSXXX,  = . HCSXXX,  = . HCSXXX,  = !. HCSXXX,  = . HCSXXX,  = . HCSXXX,  = . HCSXXX,  = . HCSXXX,  = !. HCSXXX,  = . HCSXXX,  = . HCSXXX,  = . HCSXXX,  = . HCSXXX,  = !. HCSXXX,  = !. HCSXXX,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= 64, 65,. HCSXXX, ! 76, 77. = . 24CXX/ 25CXX/ 93CXX,  = . 24CXX/ 25CXX/ 93CXX,  = . 24CXX/ 25CXX/ 93CXX,  = !. 24CXX/ 25CXX/ 93CXX,  = . 24CXX/ 25CXX/ 93CXX,  = . 24CXX/ 25CXX/ 93CXX,  = . 24CXX/ 25CXX/ 93CXX,  = . 24CXX/ 25CXX/ 93CXX,  = !. 24CXX/ 25CXX/ 93CXX,  = . 24CXX/ 25CXX/ 93CXX,  = . 24CXX/ 25CXX/ 93CXX,  = . 24CXX/ 25CXX/ 93CXX,  = . 24CXX/ 25CXX/ 93CXX,  = . 24CXX/ 25CXX/ 93CXX,  = . 24CXX/ 25CXX/ 93CXX,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= PIC16C62, 63,. 24CXX/ 25CXX/ 93CXX, ! 76, 77. = . PIC18FXXX !,  = . PIC18FXXX !,  = !. PIC18FXXX !,  = !. PIC18FXXX !,  = !. PIC18FXXX !,  = . PIC18FXXX !,  = !. PIC18FXXX !,  = !. PIC18FXXX !,  = !. PIC18FXXX !,  = . PIC18FXXX !,  = !. PIC18FXXX !,  = . PIC18FXXX !,  = . PIC18FXXX !,  = . PIC18FXXX !,  = . PIC18FXXX !,  = with. PIC18FXXX !, ! 76, 77. = . PIC18CXX2 !,  = . PIC18CXX2 !,  = !. PIC18CXX2 !,  = !. PIC18CXX2 !,  = !. PIC18CXX2 !,  = . PIC18CXX2 !,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . PIC18CXX2 !,  = !. PIC18CXX2 !,  = !. PIC18CXX2 !,  = . PIC18CXX2 !,  = !. PIC18CXX2 !,  = . PIC18CXX2 !,  = . PIC18CXX2 !,  = . PIC18CXX2 !,  = . PIC18CXX2 !,  = (DV164001). PIC18CXX2 !, ! 76, 77. = . PIC17C7XX !,  = !. PIC17C7XX !,  = . PIC17C7XX !,  = !. PIC17C7XX !,  = !. PIC17C7XX !,  = . PIC17C7XX !,  = . PIC17C7XX !,  = !. PIC17C7XX !,  = !. PIC17C7XX !,  = . PIC17C7XX !,  = . PIC17C7XX !,  = . PIC17C7XX !,  = !. PIC17C7XX !,  = . PIC17C7XX !,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . PIC17C7XX !,  = . PIC17C7XX !, ! 76, 77. = . PIC17C4X !,  = !. PIC17C4X !,  = . PIC17C4X !,  = !. PIC17C4X !,  = !. PIC17C4X !,  = . PIC17C4X !,  = . PIC17C4X !,  = !. PIC17C4X !,  = !. PIC17C4X !,  = !. PIC17C4X !,  = . PIC17C4X !,  = . PIC17C4X !,  = . PIC17C4X !,  = . PIC17C4X !,  = . PIC17C4X !,  = Debugger. PIC17C4X !, ! 76, 77. = . PIC16C9XX,  = !. PIC16C9XX,  = . PIC16C9XX,  = !. PIC16C9XX,  = !. PIC16C9XX,  = !. PIC16C9XX,  = . PIC16C9XX,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= !. PIC16C9XX,  = !. PIC16C9XX,  = . PIC16C9XX,  = . PIC16C9XX,  = !. PIC16C9XX,  = . PIC16C9XX,  = . PIC16C9XX,  = . PIC16C9XX,  = In-Circuit. PIC16C9XX, ! 76, 77. = . PIC16F8XX,  = !. PIC16F8XX,  = . PIC16F8XX,  = !. PIC16F8XX,  = !. PIC16F8XX,  = . PIC16F8XX,  = !. PIC16F8XX,  = !. PIC16F8XX,  = !. PIC16F8XX,  = . PIC16F8XX,  = . PIC16F8XX,  = . PIC16F8XX,  = . PIC16F8XX,  = . PIC16F8XX,  = . PIC16F8XX,  = fi ICD. PIC16F8XX, ! 76, 77. = . PIC16C8X/ PIC16F8X !,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . PIC16C8X/ PIC16F8X !,  = . PIC16C8X/ PIC16F8X !,  = !. PIC16C8X/ PIC16F8X !,  = !. PIC16C8X/ PIC16F8X !,  = !. PIC16C8X/ PIC16F8X !,  = . PIC16C8X/ PIC16F8X !,  = !. PIC16C8X/ PIC16F8X !,  = !. PIC16C8X/ PIC16F8X !,  = !. PIC16C8X/ PIC16F8X !,  = . PIC16C8X/ PIC16F8X !,  = . PIC16C8X/ PIC16F8X !,  = . PIC16C8X/ PIC16F8X !,  = . PIC16C8X/ PIC16F8X !,  = . PIC16C8X/ PIC16F8X !,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= the MPLAB. PIC16C8X/ PIC16F8X !, ! 76, 77. = . PIC16C7XX !,  = . PIC16C7XX !,  = . PIC16C7XX !,  = !. PIC16C7XX !,  = !. PIC16C7XX !,  = !. PIC16C7XX !,  = . PIC16C7XX !,  = !. PIC16C7XX !,  = !. PIC16C7XX !,  = . PIC16C7XX !,  = . PIC16C7XX !,  = . PIC16C7XX !,  = . PIC16C7XX !,  = . PIC16C7XX !,  = . PIC16C7XX !,  = to use. PIC16C7XX !, ! 76, 77. = . PIC16C7X !,  = . PIC16C7X !,  = . PIC16C7X !,  = !. PIC16C7X !,  = !. PIC16C7X !,  = !. PIC16C7X !,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= ! *. PIC16C7X !,  = !. PIC16C7X !,  = !. PIC16C7X !,  = ! \u2020. PIC16C7X !,  = ! \u2020. PIC16C7X !,  = . PIC16C7X !,  = . PIC16C7X !,  = . PIC16C7X !,  = . PIC16C7X !,  = on how. PIC16C7X !, ! 76, 77. = . PIC16F62X !,  = . PIC16F62X !,  = . PIC16F62X !,  = . PIC16F62X !,  = ! **. PIC16F62X !,  = . PIC16F62X !,  = . PIC16F62X !,  = ! **. PIC16F62X !,  = ! **. PIC16F62X !,  = . PIC16F62X !,  = . PIC16F62X !,  = . PIC16F62X !,  = . PIC16F62X !,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . PIC16F62X !,  = . PIC16F62X !,  = information. PIC16F62X !, ! 76, 77. = !. PIC16CXXX,  = !. PIC16CXXX,  = . PIC16CXXX,  = !. PIC16CXXX,  = !. PIC16CXXX,  = !. PIC16CXXX,  = . PIC16CXXX,  = !. PIC16CXXX,  = !. PIC16CXXX,  = !. PIC16CXXX,  = . PIC16CXXX,  = . PIC16CXXX,  = . PIC16CXXX,  = . PIC16CXXX,  = . PIC16CXXX,  = . PIC16CXXX, ! 76, 77. = for. PIC16C6X,  = !. PIC16C6X,  = . PIC16C6X,  = !. PIC16C6X,  = !. PIC16C6X,  = !. PIC16C6X,  = ! *. PIC16C6X,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= !. PIC16C6X,  = !. PIC16C6X,  = . PIC16C6X,  = ! \u2020. PIC16C6X,  = . PIC16C6X,  = . PIC16C6X,  = . PIC16C6X,  = . PIC16C6X,  = . PIC16C6X, ! 76, 77. = . PIC16C5X ! date.,  = . PIC16C5X ! date.,  = . PIC16C5X ! date.,  = !. PIC16C5X ! date.,  = !. PIC16C5X ! date.,  = !. PIC16C5X ! date.,  = . PIC16C5X ! date.,  = !. PIC16C5X ! date.,  = !. PIC16C5X ! date.,  = !. PIC16C5X ! date.,  = . PIC16C5X ! date.,  = . PIC16C5X ! date.,  = . PIC16C5X ! date.,  = . PIC16C5X ! date.,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . PIC16C5X ! date.,  = www.microchip.com. PIC16C5X ! date., ! 76, 77. = . PIC14000 !,  = . PIC14000 !,  = . PIC14000 !,  = !. PIC14000 !,  = !. PIC14000 !,  = . PIC14000 !,  = . PIC14000 !,  = !. PIC14000 !,  = !. PIC14000 !,  = . PIC14000 !,  = . PIC14000 !,  = !. PIC14000 !,  = . PIC14000 !,  = . PIC14000 !,  = . PIC14000 !,  = site at. PIC14000 !, ! 76, 77. = . PIC12CXXX ! for availability,  = . PIC12CXXX ! for availability,  = . PIC12CXXX ! for availability,  = !. PIC12CXXX ! for availability,  = !. PIC12CXXX ! for availability,  = !. PIC12CXXX ! for availability,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . PIC12CXXX ! for availability,  = !. PIC12CXXX ! for availability,  = !. PIC12CXXX ! for availability,  = . PIC12CXXX ! for availability,  = . PIC12CXXX ! for availability,  = . PIC12CXXX ! for availability,  = . PIC12CXXX ! for availability,  = . PIC12CXXX ! for availability,  = . PIC12CXXX ! for availability,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= Inc. web. PIC12CXXX ! for availability, ! 76, 77. = . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020,",
    "TABLE 21-1: DEVELOPMENT TOOLS FROM MICROCHIP\n= . Software Tools MPLAB fi Integrated Development Environment MPLAB fi C17 C Compiler MPLAB fi C18 C Compiler MPASM TM Assembler/ MPLINK TM Object Linker Emulators MPLAB fi ICE In-Circuit Emulator ICEPIC TM In-Circuit Emulator Debugger MPLAB fi ICD In-Circuit Debugger Programmers PICSTART fi Plus Entry Level Development Programmer PRO MATE fi II Universal Device Programmer Demo Boards and Eval Kits PICDEM TM 1 Demonstration Board PICDEM TM 2 Demonstration Board PICDEM TM 3 Demonstration Board PICDEM TM 14A Demonstration Board PICDEM TM 17 Demonstration Board KEELOQ fi Evaluation Kit KEELOQ fi Transponder Kit microID TM Programmer's Kit 125 kHz microID TM Developer's Kit 125 kHz Anticollision microID Developer's Kit 13.56 MHz Anticollision microID TM Developer's Kit MCP2510 CAN Developer's * Contact the Microchip Technology ** Contact Microchip Technology \u2020, ! 76, 77. = ",
    "PIC18FXX2\nNOTES:",
    "22.0 ELECTRICAL CHARACTERISTICS\nAbsolute Maximum Ratings (\u2020)\nAmbient temperature under bias............................................................................................................ .-55\u00b0C, 1 = to +125\u00b0C. Storage temperature",
    "22.0 ELECTRICAL CHARACTERISTICS\n.............................................................................................................................., 1 = -65\u00b0C to +150\u00b0C. Voltage on any pin with respect to VSS (except VDD, MCLR, and RA4) ......................................... -0.3V, 1 = to (VDD + 0.3V). Voltage on VDD with respect to VSS",
    "22.0 ELECTRICAL CHARACTERISTICS\n........................................................................................................., 1 = -0.3V to +7.5V. Voltage on MCLR with respect to VSS (Note 2) ........................................................................................., 1 = 0V to +13.25V. Voltage on RA4 with respect to",
    "22.0 ELECTRICAL CHARACTERISTICS\nVss..............................................................................................................., 1 = 0V to +8.5V. Total power dissipation (Note 1)",
    "22.0 ELECTRICAL CHARACTERISTICS\n..............................................................................................................................., 1 = 1.0W. Maximum current out of VSS pin",
    "22.0 ELECTRICAL CHARACTERISTICS\n..........................................................................................................................., 1 = 300 mA. Maximum current into VDD pin",
    "22.0 ELECTRICAL CHARACTERISTICS\n.............................................................................................................................., 1 = 250 mA. Input clamp current, I IK (VI < 0 or VI > VDD)",
    "22.0 ELECTRICAL CHARACTERISTICS\n......................................................................................................................, 1 = \u00b1 20 mA. Output clamp current, I OK (VO < 0 or VO > VDD)",
    "22.0 ELECTRICAL CHARACTERISTICS\n.............................................................................................................., 1 = \u00b1 20 mA. Maximum output current sunk by any I/O pin..........................................................................................................25, 1 = mA. Maximum output current sourced by any I/O pin",
    "22.0 ELECTRICAL CHARACTERISTICS\n...................................................................................................., 1 = 25 mA. Maximum current sunk by PORTA, PORTB, and PORTE (Note 3) (combined)...................................................200, 1 = mA. Maximum current sourced by PORTA, PORTB, and PORTE (Note 3) (combined)..............................................200, 1 =",
    "22.0 ELECTRICAL CHARACTERISTICS\nmA. Maximum current sunk by PORTC and PORTD (Note 3) (combined)..................................................................200, 1 = mA. Maximum current sourced by PORTC and PORTD (Note 3) (combined).............................................................200, 1 = mA\nNote 1: Power dissipation is calculated as follows:\nPdis = VDD x {IDD -\u2211 IOH} + \u2211 {(VDD-VOH) x IOH} + \u2211 (VOl x IOL)",
    "22.0 ELECTRICAL CHARACTERISTICS\n2: Voltage spikes below VSS at the MCLR/VPP pin, inducing currents greater than 80 mA, may cause latchup. Thus, a series resistor of 50-100 \u2126 should be used when applying a 'low' level to the MCLR/VPP pin, rather than pulling this pin directly to VSS.\n3: PORTD and PORTE not available on the PIC18F2X2 devices.\n\u2020 NOTICE: Stresses above those listed under 'Absolute Maximum Ratings' may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated  in  the  operation  listings  of  this  specification  is  not  implied.  Exposure  to  maximum  rating  conditions  for extended periods may affect device reliability.\nFIGURE 22-1: PIC18FXX2 VOLTAGE-FREQUENCY GRAPH (INDUSTRIAL)\nFIGURE 22-2: PIC18LFXX2 VOLTAGE-FREQUENCY GRAPH (INDUSTRIAL)",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial)\nPIC18LFXX2\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial\nPIC18FXX2\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial\n-40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial)\nD001, Symbol = VDD. D001, Characteristic = Supply Voltage. D001, Min = Supply Voltage. D001, Typ = Supply Voltage. D001, Max = Supply Voltage. D001, Units = Supply Voltage. D001, Conditions = Supply Voltage. D001, Symbol = VDD. D001, Characteristic = PIC18LFXX2. D001, Min = 2.0. D001, Typ = -. D001, Max = 5.5. D001, Units = V. D001, Conditions = HS, XT, RC and LP Osc mode. D001, Symbol = VDD. D001, Characteristic = PIC18FXX2. D001, Min = 4.2. D001, Typ = -. D001, Max = 5.5. D001, Units = V. D001, Conditions = . D002, Symbol = VDR. D002, Characteristic = RAM Data Retention Voltage (1). D002,",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial)\nMin = 1.5. D002, Typ = -. D002, Max = -. D002, Units = V. D002, Conditions = . D003, Symbol = VPOR. D003, Characteristic = VDD Start Voltage to ensure internal Power-on Reset signal. D003, Min = -. D003, Typ = -. D003, Max = 0.7. D003, Units = V. D003, Conditions = See Section 3.1 (Power-on Reset) for details. D004, Symbol = SVDD. D004, Characteristic = VDD Rise Rate to ensure internal Power-on Reset signal. D004, Min = 0.05. D004, Typ = -. D004, Max = -. D004, Units = V/ms. D004, Conditions = See Section 3.1 (Power-on Reset) for details. D005, Symbol = VBOR. D005, Characteristic = Brown-out Reset Voltage. D005, Min",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial)\n= Brown-out Reset Voltage. D005, Typ = Brown-out Reset Voltage. D005, Max = Brown-out Reset Voltage. D005, Units = Brown-out Reset Voltage. D005, Conditions = Brown-out Reset Voltage. D005, Symbol = VBOR. D005, Characteristic = PIC18LFXX2. D005, Min = PIC18LFXX2. D005, Typ = . D005, Max = . D005, Units = . D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 11. D005, Min = 1.98. D005, Typ = -. D005, Max = 2.14. D005, Units = V. D005, Conditions = 85 \u00b0 C \u2265 T \u2265 25 \u00b0 C. D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 10. D005, Min =",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial)\n2.67. D005, Typ = -. D005, Max = 2.89. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 01. D005, Min = 4.16. D005, Typ = -. D005, Max = 4.5. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 00. D005, Min = 4.45. D005, Typ = -. D005, Max = 4.83. D005, Units = V. D005, Conditions = . D005, Symbol = . D005, Characteristic = PIC18FXX2. D005, Min = . D005, Typ = . D005, Max = . D005, Units = . D005,",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial)\nConditions = . D005, Symbol = . D005, Characteristic = BORV1:BORV0 = 1x. D005, Min = N.A.. D005, Typ = -. D005, Max = N.A.. D005, Units = V. D005, Conditions = Not in operating voltage range of device. D005, Symbol = . D005, Characteristic = BORV1:BORV0 = 01. D005, Min = 4.16. D005, Typ = -. D005, Max = 4.5. D005, Units = V. D005, Conditions = . D005, Symbol = . D005, Characteristic = BORV1:BORV0 = 00. D005, Min = 4.45. D005, Typ = -. D005, Max = 4.83. D005, Units = V. D005, Conditions = ",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial)\nLegend: Shading of rows is to assist in readability of the table.\nNote 1: This is the limit to which VDD can be lowered in SLEEP mode, or during a device RESET, without losing RAM data.\n- 2: The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active Operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD MCLR = VDD; WDT enabled/disabled as specified.",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial)\n3: The power-down current in SLEEP mode does not depend on the oscillator type. Power-down current is measured with the part in SLEEP mode, with all I/O pins in hi-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR,...).\n4: For RC osc configuration, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in kOhm.\n5: The LVD and BOR modules share a large portion of circuitry. The \u2206 IBOR and \u2206 ILVD currents are not additive. Once one of these modules is enabled, the other may also be enabled without further penalty.",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nPIC18LFXX2\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C\n\u2264\nTA\n\u2264\n+85\u00b0C for industrial\nPIC18FXX2\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial\n-40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n, Symbol = I DD Supply. , Min = . , Typ = . , Max = . , Units = . , Conditions = . D010, Symbol = . D010, Min = -. D010, Typ = .5. D010, Max = 1. D010, Units = mA. D010, Conditions = XT osc configuration VDD = 2.0V, +25 \u00b0 C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = .5. , Max = 1.25. , Units = mA. , Conditions = VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = 1.2. , Max = 2. , Units = mA. , Conditions = VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = .3. , Max",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n= 1. , Units = mA. , Conditions = RC osc configuration VDD = 2.0V, +25 \u00b0 C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = .3. , Max = 1. , Units = mA. , Conditions = VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = 1.5. , Max = 3. , Units = mA. , Conditions = VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C, FOSC = 4 MHz RCIO osc configuration. , Symbol = . , Min = -. , Typ = .3. , Max = 1. , Units = mA. , Conditions = VDD = 2.0V, +25 \u00b0 C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = .3. , Max = 1. , Units = mA. , Conditions = VDD",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n= 2.0V, -40 \u00b0 C to +85 \u00b0 C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = .75. , Max = 3. , Units = mA. , Conditions = VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C, FOSC = 4 MHz. D010, Symbol = . D010, Min = . D010, Typ = 1.2. D010, Max = . D010, Units = . D010, Conditions = XT osc configuration \u00b0. , Symbol = . , Min = - -. , Typ = 1.2. , Max = 1.5 2. , Units = mA mA. , Conditions = VDD = 4.2V, +25 C, FOSC = 4 MHz VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = 1.2. , Max = 3.",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n, Units = mA. , Conditions = VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C, FOSC = 4 MHz RC osc configuration. , Symbol = . , Min = -. , Typ = 1.5. , Max = 3. , Units = mA. , Conditions = VDD = 4.2V, +25 \u00b0 C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = 1.5. , Max = 4. , Units = mA. , Conditions = VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = 1.6. , Max = 4. , Units = mA. , Conditions = VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C, FOSC = 4 MHz RCIO osc configuration. , Symbol = . , Min = -. , Typ = .75. , Max = 2. , Units = mA. ,",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nConditions = VDD = 4.2V, +25 \u00b0 C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = .75. , Max = 3. , Units = mA. , Conditions = VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = .8. , Max = 3. , Units = mA. , Conditions = VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C, FOSC = 4 MHz. D010A, Symbol = . D010A, Min = -. D010A, Typ = 14. D010A, Max = 30. D010A, Units = \u00b5 A. D010A, Conditions = LP osc, FOSC = 32 kHz, WDT disabled VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C. D010A, Symbol = . D010A, Min",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n= - -. D010A, Typ = 40 50. D010A, Max = 70 100. D010A, Units = \u00b5 A \u00b5 A. D010A, Conditions = LP osc, FOSC = 32 kHz, WDT disabled VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C\nLegend: Shading of rows is to assist in readability of the table.\nNote 1: This is the limit to which VDD can be lowered in SLEEP mode, or during a device RESET, without losing RAM data.\n- 2: The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active Operation mode are:",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD\nMCLR = VDD; WDT enabled/disabled as specified.\n3: The power-down current in SLEEP mode does not depend on the oscillator type. Power-down current is measured with the part in SLEEP mode, with all I/O pins in hi-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR,...).\n4: For RC osc configuration, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in kOhm.\n5: The LVD and BOR modules share a large portion of circuitry. The \u2206 IBOR and \u2206 ILVD currents are not additive. Once one of these modules is enabled, the other may also be enabled without further penalty.",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Symbol = I DD. , PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Characteristic = Supply Current (2,4) (Continued). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = Supply Current (2,4) (Continued). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = Supply Current (2,4) (Continued). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n+85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = Supply Current (2,4) (Continued). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = Supply Current (2,4) (Continued). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = Supply Current (2,4) (Continued). D010C, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial,",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nExtended).Symbol = . D010C, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Characteristic = PIC18LFXX2. D010C, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = -. D010C, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 10. D010C, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n+85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 25. D010C, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = mA. D010C, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = EC, ECIO osc configurations VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D010C, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Symbol = . D010C, PIC18LFXX2",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n(Industrial).PIC18FXX2 (Industrial, Extended).Characteristic = PIC18FXX2. D010C, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = -. D010C, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 10. D010C, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nextended.Max = 25. D010C, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = mA. D010C, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = EC, ECIO osc configurations VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C. D013, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Symbol = . D013, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Characteristic = PIC18LFXX2.",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nD013, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = - - -. D013, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = .6 10 15. D013, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 2 15 25. D013, Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = mA mA mA. D013, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = HS osc configuration FOSC = 4 MHz, VDD = 2.0V FOSC = 25 MHz, VDD = 5.5V HS + PLL osc configurations FOSC = 10 MHz, VDD = 5.5V. D013, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Symbol = . D013, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial,",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nExtended).Characteristic = PIC18FXX2. D013, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = - -. D013, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 10 15. D013, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 15 25. D013, Standard Operating Conditions",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n(unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = mA mA. D013, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = HS osc configuration FOSC = 25 MHz, VDD = 5.5V HS + PLL osc configurations FOSC = 10 MHz, VDD = 5.5V. D014, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Symbol = . D014, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Characteristic = PIC18LFXX2.",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nD014, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = -. D014, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 15. D014, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 55. D014, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n+85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = \u00b5 A. D014, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = Timer1 osc configuration FOSC = 32 kHz, VDD = 2.0V. D014, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Symbol = . D014, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Characteristic = PIC18FXX2. D014, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nstated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = - -. D014, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = - -. D014, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 200 250. D014, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n-40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = \u00b5 A \u00b5 A. D014, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = Timer1 osc configuration FOSC = 32 kHz, VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C FOSC = 32 kHz, VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C. D020, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Symbol = I PD. D020, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Characteristic = Power-down Current (3). D020, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n+85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = Power-down Current (3). D020, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = Power-down Current (3). D020, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = Power-down Current (3). D020, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n+85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = Power-down Current (3). D020, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = Power-down Current (3). , PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Symbol = . , PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Characteristic = PIC18LFXX2. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nindustrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = - - -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = .08 .1 3. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = .9 4 10. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = \u00b5 A \u00b5 A",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n\u00b5 A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = VDD = 2.0V, +25 \u00b0 C VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D020, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Symbol = . D020, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Characteristic = PIC18FXX2. D020, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nTA \u2264 +125\u00b0C for extended.Min = - -. D020, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = .1 3. D020, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = .9. D020, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = \u00b5 \u00b5.",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nD020, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = VDD = 4.2V, +25 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D021B, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Symbol = . D021B, PIC18LFXX2 (Industrial).PIC18FXX2 (Industrial, Extended).Characteristic = -. D021B, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = . D021B, Standard",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nOperating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 15. D021B, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 10 25. D021B, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = A A \u00b5 A. D021B, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nTA \u2264 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C\nLegend: Shading of rows is to assist in readability of the table.\nNote 1: This is the limit to which VDD can be lowered in SLEEP mode, or during a device RESET, without losing RAM data.\n2: The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active Operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD\nMCLR = VDD; WDT enabled/disabled as specified.",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n3: The power-down current in SLEEP mode does not depend on the oscillator type. Power-down current is measured with the part in SLEEP mode, with all I/O pins in hi-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR,...).\n4: For RC osc configuration, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in kOhm.\n5: The LVD and BOR modules share a large portion of circuitry. The \u2206 IBOR and \u2206 ILVD currents are not additive. Once one of these modules is enabled, the other may also be enabled without further penalty.\nPIC18LFXX2\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial\nPIC18FXX2\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n-40\u00b0C\n\u2264\nTA\n\u2264\n+85\u00b0C for industrial\n-40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n, Symbol = . , Characteristic = Module Differential Current. , Min = Module Differential Current. , Typ = Module Differential Current. , Max = Module Differential Current. , Units = Module Differential Current. , Conditions = Module Differential Current. D022, Symbol = \u2206 I WDT. D022, Characteristic = Watchdog Timer PIC18LFXX2. D022, Min = - - -. D022, Typ = .75 2 10. D022, Max = 1.5 8 25. D022, Units = \u00b5 A \u00b5 A \u00b5 A. D022, Conditions = VDD = 2.0V, +25 \u00b0 C VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D022, Symbol = . D022, Characteristic = Watchdog Timer PIC18FXX2. D022, Min = - - -. D022, Typ = 7 10 25. D022, Max = 15 25 40.",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nD022, Units = \u00b5 A \u00b5 A \u00b5 A. D022, Conditions = VDD = 4.2V, +25 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C. D022A, Symbol = \u2206 I BOR. D022A, Characteristic = Brown-out Reset (5) PIC18LFXX2. D022A, Min = - - -. D022A, Typ = 29 29 33. D022A, Max = 35 45 50. D022A, Units = \u00b5 A \u00b5 A \u00b5 A. D022A, Conditions = VDD = 2.0V, +25 \u00b0 C VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D022A, Symbol = . D022A, Characteristic = Brown-out Reset (5) PIC18FXX2.",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nD022A, Min = - - -. D022A, Typ = 36 36 36. D022A, Max = 40 50 65. D022A, Units = \u00b5 A \u00b5 A \u00b5 A. D022A, Conditions = VDD = 4.2V, +25 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C. D022B, Symbol = \u2206 I LVD. D022B, Characteristic = Low Voltage Detect (5) PIC18LFXX2. D022B, Min = - - -. D022B, Typ = 29 29 33. D022B, Max = 35 45 50. D022B, Units = \u00b5 A \u00b5 A \u00b5 A. D022B, Conditions = VDD = 2.0V, +25 \u00b0 C VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\nto +85 \u00b0 C. D022B, Symbol = . D022B, Characteristic = Low Voltage Detect (5) PIC18FXX2. D022B, Min = - - -. D022B, Typ = 33 33 33. D022B, Max = 40 50 65. D022B, Units = \u00b5 A \u00b5 A \u00b5 A. D022B, Conditions = VDD = 4.2V, +25 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C. D025, Symbol = \u2206 I TMR1. D025, Characteristic = Timer1 Oscillator PIC18LFXX2. D025, Min = - - -. D025, Typ = 5.2 5.2 6.5. D025, Max = 30 40 50. D025, Units = \u00b5 A \u00b5 A \u00b5 A. D025, Conditions = VDD =",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n2.0V, +25 \u00b0 C VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D025, Symbol = . D025, Characteristic = Timer1 Oscillator PIC18FXX2. D025, Min = - - -. D025, Typ = 6.5 6.5 6.5. D025, Max = 40 50 65. D025, Units = \u00b5 A \u00b5 A \u00b5 A. D025, Conditions = VDD = 4.2V, +25 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C\nLegend: Shading of rows is to assist in readability of the table.\nNote 1: This is the limit to which VDD can be lowered in SLEEP mode, or during a device RESET, without losing RAM data.",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n- 2: The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active Operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD MCLR = VDD; WDT enabled/disabled as specified.",
    "22.1 DC Characteristics: PIC18FXX2 (Industrial, Extended) PIC18LFXX2 (Industrial) (Continued)\n3: The power-down current in SLEEP mode does not depend on the oscillator type. Power-down current is measured with the part in SLEEP mode, with all I/O pins in hi-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR,...).\n4: For RC osc configuration, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in kOhm.\n5: The LVD and BOR modules share a large portion of circuitry. The \u2206 IBOR and \u2206 ILVD currents are not additive. Once one of these modules is enabled, the other may also be enabled without further penalty.",
    "DC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial\n-40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended",
    "DC CHARACTERISTICS\nD030 D030A D031 D032, Symbol = VIL. D030 D030A D031 D032, Characteristic = Input Low Voltage I/O ports: with TTL buffer. D030 D030A D031 D032, Min = Vss - Vss Vss VSS VSS. D030 D030A D031 D032, Max = 0.15 VDD 0.8 0.2 VDD 0.3 VDD 0.2 VDD 0.3 VDD. D030 D030A D031 D032, Units = V V V V V V. D030 D030A D031 D032, Conditions = VDD < 4.5V 4.5V \u2264 VDD \u2264 5.5V. D032A D033 D040, Symbol = VIH. D032A D033 D040, Characteristic = OSC1 (in XT, HS and LP and T1OSI OSC1 (in RC and EC mode) (1) Input High Voltage I/O ports: with TTL buffer. D032A",
    "DC CHARACTERISTICS\nD033 D040, Min = VSS 0.25 VDD + 0.8V. D032A D033 D040, Max = 0.2 VDD VDD. D032A D033 D040, Units = V V. D032A D033 D040, Conditions = VDD < 4.5V \u2264 \u2264. D042 D042A, Symbol = . D042 D042A, Characteristic = RC3 and RC4 MCLR, OSC1 (EC mode) OSC1 (in XT, HS and LP modes) and T1OSI OSC1 (RC mode) (1). D042 D042A, Min = 0.7 VDD 0.8 VDD 0.7 VDD. D042 D042A, Max = VDD VDD VDD. D042 D042A, Units = V V V. D042 D042A, Conditions = . D043 D060, Symbol = I IL. D043 D060, Characteristic = Input Leakage Current (2,3) I/O ports. D043",
    "DC CHARACTERISTICS\nD060, Min = 0.9 VDD .02. D043 D060, Max = VDD \u00b1 1. D043 D060, Units = V \u00b5 A. D043 D060, Conditions = . , Symbol = . , Characteristic = . , Min = -. , Max = . , Units = . , Conditions = VSS \u2264 VPIN \u2264 VDD, Pin at hi-impedance. D061 D063, Symbol = . D061 D063, Characteristic = MCLR OSC1. D061 D063, Min = -. D061 D063, Max = \u00b1 1. D061 D063, Units = \u00b5 A \u00b5 A. D061 D063, Conditions = Vss \u2264 VPIN \u2264 VDD Vss \u2264 VPIN \u2264 VDD. , Symbol = I PU I PURB. , Characteristic = Weak Pull-up Current. , Min = 50. , Max = \u00b1 1. , Units = . , Conditions = VDD = 5V, VPIN =. D070, Symbol = . D070, Characteristic = PORTB weak",
    "DC CHARACTERISTICS\npull-up current. D070, Min = . D070, Max = 450. D070, Units = \u00b5 A. D070, Conditions = . , Symbol = . , Characteristic = . , Min = . , Max = . , Units = . , Conditions = VSS\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PICmicro device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.\n4: Parameter is characterized but not tested.\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial\n-40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended",
    "DC CHARACTERISTICS\nD080, Symbol = VOL. D080, Characteristic = Output Low Voltage I/O ports. D080, Min = -. D080, Max = 0.6. D080, Units = V. D080, Conditions = I OL = 8.5 mA, VDD = 4.5V, -40 \u00b0 C to +85 \u00b0 C. D080A, Symbol = . D080A, Characteristic = . D080A, Min = -. D080A, Max = 0.6. D080A, Units = V. D080A, Conditions = I OL = 7.0 mA, VDD = 4.5V, -40 \u00b0 C to +125 \u00b0 C. D083, Symbol = . D083, Characteristic = OSC2/CLKO (RC mode). D083, Min = -. D083, Max = 0.6. D083, Units = V. D083, Conditions = I OL = 1.6 mA, VDD = 4.5V, -40 \u00b0 C to +85 \u00b0 C. D083A, Symbol =",
    "DC CHARACTERISTICS\n. D083A, Characteristic = . D083A, Min = -. D083A, Max = 0.6. D083A, Units = V. D083A, Conditions = I OL = 1.2 mA, VDD = 4.5V, -40 \u00b0 C to +125 \u00b0 C. D090, Symbol = VOH. D090, Characteristic = Output High Voltage (3) I/O ports. D090, Min = VDD - 0.7. D090, Max = -. D090, Units = V. D090, Conditions = I OH = -3.0 mA, VDD = 4.5V, -40 \u00b0 C to +85 \u00b0 C. D090A, Symbol = . D090A, Characteristic = . D090A, Min = VDD - 0.7. D090A, Max = -. D090A, Units = V. D090A, Conditions = I OH = -2.5 mA, VDD = 4.5V, -40 \u00b0 C to +125 \u00b0 C. D092, Symbol = .",
    "DC CHARACTERISTICS\nD092, Characteristic = OSC2/CLKO (RC mode). D092, Min = VDD - 0.7. D092, Max = -. D092, Units = V. D092, Conditions = I OH = -1.3 mA, VDD = 4.5V, -40 \u00b0 C to +85 \u00b0 C. D092A, Symbol = . D092A, Characteristic = . D092A, Min = VDD - 0.7. D092A, Max = -. D092A, Units = V. D092A, Conditions = I OH = -1.0 mA, VDD = 4.5V, -40 \u00b0 C to +125 \u00b0 C. D150, Symbol = VOD. D150, Characteristic = Open Drain High Voltage. D150, Min = -. D150, Max = 8.5. D150, Units = V. D150, Conditions = RA4 pin. D100 (4), Symbol = COSC2. D100 (4), Characteristic = OSC2 pin.",
    "DC CHARACTERISTICS\nD100 (4), Min = -. D100 (4), Max = 15. D100 (4), Units = pF. D100 (4), Conditions = In XT, HS and LP modes when external clock is used to drive OSC1. D101, Symbol = CIO. D101, Characteristic = All I/O pins and OSC2 (in RC mode). D101, Min = -. D101, Max = 50. D101, Units = pF. D101, Conditions = To meet the AC Timing Specifications. D102, Symbol = CB. D102, Characteristic = SCL, SDA. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = In I 2 C mode",
    "DC CHARACTERISTICS\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PICmicro device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.\n4: Parameter is characterized but not tested.",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\nTABLE 22-1: LOW VOLTAGE DETECT CHARACTERISTICS",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\nD420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 0001. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 1.98. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 2.06. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 2.14. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\n\u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = T \u2265 25 \u00b0 C. D420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 0010. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 2.18. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 2.27. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 2.36. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\nTA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = T \u2265 25 \u00b0 C. D420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 0011. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 2.37. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 2.47. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 2.57.",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\nD420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = T \u2265 25 \u00b0 C. D420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 0100. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 2.48. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 2.58. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 2.68. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 0101. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 2.67. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\n+125\u00b0C for extended.Typ = 2.78. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 2.89. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 0110. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 2.77. D420, Standard Operating Conditions",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\n(unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 2.89. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 3.01. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 0111. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\n-40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 2.98. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 3.1. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 3.22. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 1000.",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\nD420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 3.27. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 3.41. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 3.55. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D420, Symbol = VLVD. D420, Characteristic =",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\nLVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 1001. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 3.47. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 3.61. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 3.75. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\n+125\u00b0C for extended.Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 1010. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 3.57. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 3.72. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 3.87. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\n(unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 1011. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 3.76. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 3.92. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 4.08. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\nindustrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 1100. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 3.96. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 4.13. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 4.3.",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\nD420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 1101. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 4.16. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ = 4.33. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\n+85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 4.5. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVDVoltageonVDD transition high to low. D420, Characteristic = LVV = 1110. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 4.45. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ",
    "FIGURE 22-3: LOW VOLTAGE DETECT CHARACTERISTICS\n= 4.64. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 4.83. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D420, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = ",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\nD110, DC Characteristics.Sym = VPP. D110, DC Characteristics.Characteristic = Internal Program Memory Programming Specifications Voltage on MCLR/VPP pin. D110, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 9.00. D110, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = -. D110, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 13.25. D110, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D110, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\nindustrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D113, DC Characteristics.Sym = I DDP. D113, DC Characteristics.Characteristic = Supply Current during Programming. D113, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = -. D113, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = -. D113, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 10. D113, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = mA. D113, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\n\u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D120, DC Characteristics.Sym = ED. D120, DC Characteristics.Characteristic = Data EEPROM Memory Cell Endurance. D120, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 100K. D120, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = 1M. D120, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = -. D120, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = E/W. D120, Standard Operating Conditions (unless",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\notherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = -40 \u00b0 C to +85 \u00b0 C. D121, DC Characteristics.Sym = VDRW. D121, DC Characteristics.Characteristic = VDD for Read/Write. D121, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = VMIN. D121, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = -. D121, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 5.5. D121, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\n+125\u00b0C for extended.Units = V. D121, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = Using EECON to read/write VMIN = Minimum operating voltage. D122, DC Characteristics.Sym = TDEW. D122, DC Characteristics.Characteristic = Erase/Write Cycle Time. D122, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = -. D122, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = 4. D122, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = -. D122, Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = ms. D122, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D123, DC Characteristics.Sym = TRETD. D123, DC Characteristics.Characteristic = Characteristic Retention. D123, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 40. D123, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = -. D123, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = -. D123, Standard Operating Conditions (unless otherwise",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\nstated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = Year. D123, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = Provided no other specifications are violated. D124, DC Characteristics.Sym = TREF. D124, DC Characteristics.Characteristic = Number of Total Erase/Write Cycles before Refresh (1). D124, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 1M. D124, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = 10M. D124, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\n\u2264 +125\u00b0C for extended.Max = -. D124, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = E/W. D124, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = -40\u00b0C to +85\u00b0C. D130, DC Characteristics.Sym = EP. D130, DC Characteristics.Characteristic = Program FLASH Memory Cell Endurance. D130, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 10K. D130, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = 100K. D130, Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = -. D130, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = E/W. D130, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = -40 \u00b0 C to +85 \u00b0 C. D131, DC Characteristics.Sym = VPR. D131, DC Characteristics.Characteristic = VDD for Read. D131, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = VMIN. D131, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\n= -. D131, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 5.5. D131, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D131, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = VMIN = Minimum operating voltage. D132, DC Characteristics.Sym = VIE. D132, DC Characteristics.Characteristic = VDD for Block Erase. D132, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 4.5. D132, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\n-40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = -. D132, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 5.5. D132, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D132, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = Using ICSP port. D132A, DC Characteristics.Sym = VIW. D132A, DC Characteristics.Characteristic = VDD for Externally Timed Erase or Write. D132A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 4.5. D132A, Standard Operating",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\nConditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = -. D132A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 5.5. D132A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D132A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = Using ICSP port. D132B, DC Characteristics.Sym = VPEW. D132B, DC Characteristics.Characteristic = VDD for Self-timed Write. D132B, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\n\u2264 TA \u2264 +125\u00b0C for extended.Min = VMIN. D132B, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = -. D132B, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = 5.5. D132B, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = V. D132B, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = VMIN = Minimum operating voltage. D133, DC Characteristics.Sym = TIE. D133, DC Characteristics.Characteristic = ICSP Block Erase Cycle Time. D133, Standard Operating Conditions (unless otherwise stated)",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\nOperating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = -. D133, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = 4. D133, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = -. D133, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = ms. D133, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = VDD \u2265 4.5V. D133A, DC Characteristics.Sym = TIW. D133A, DC Characteristics.Characteristic = ICSP Erase",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\nor Write Cycle Time (externally timed). D133A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 1. D133A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = -. D133A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = -. D133A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = ms. D133A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = VDD \u2265 4.5V.",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\nD133A, DC Characteristics.Sym = TIW. D133A, DC Characteristics.Characteristic = Self-timed Write Cycle Time. D133A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = -. D133A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = 2. D133A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = -. D133A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = ms. D133A, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\n-40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = . D134, DC Characteristics.Sym = TRETD. D134, DC Characteristics.Characteristic = Characteristic Retention. D134, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Min = 40. D134, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Typ\u2020 = -. D134, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Max = -. D134, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Units = Year. D134, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264",
    "TABLE 22-2: MEMORY PROGRAMMING REQUIREMENTS\n+85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended.Conditions = Provided no other specifications are violated\n- \u2020 Data in 'Typ' column is at 5.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: Refer to Section 6.8 for a more detailed discussion on data EEPROM endurance.",
    "22.3.1 TIMING PARAMETER SYMBOLOGY\nThe  timing  parameter  symbols  have  been  created following one of the following formats:",
    "22.3.1 TIMING PARAMETER SYMBOLOGY\nLowercase letters (pp) and their meanings:, Frequency. = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, 3. TCC:ST.4. Ts..T = . Lowercase letters (pp) and their meanings:, (I 2 C specifications only) (I 2 C specifications.only)..Time = . pp, Frequency. = . pp, 3. TCC:ST.4. Ts..T = . pp, (I 2 C specifications only) (I 2 C specifications.only)..Time = . cc, Frequency. = CCP1. cc, 3. TCC:ST.4. Ts..T = osc. cc, (I 2 C specifications only) (I 2 C specifications.only)..Time = OSC1. ck, Frequency. = CLKO. ck, 3. TCC:ST.4. Ts..T = rd. ck, (I 2 C specifications only) (I 2 C specifications.only)..Time = RD. cs, Frequency. = CS. cs, 3. TCC:ST.4.",
    "22.3.1 TIMING PARAMETER SYMBOLOGY\nTs..T = rw. cs, (I 2 C specifications only) (I 2 C specifications.only)..Time = RD or WR. di, Frequency. = SDI. di, 3. TCC:ST.4. Ts..T = sc. di, (I 2 C specifications only) (I 2 C specifications.only)..Time = SCK. do, Frequency. = SDO. do, 3. TCC:ST.4. Ts..T = ss. do, (I 2 C specifications only) (I 2 C specifications.only)..Time = SS. dt, Frequency. = Data in. dt, 3. TCC:ST.4. Ts..T = t0. dt, (I 2 C specifications only) (I 2 C specifications.only)..Time = T0CKI. io, Frequency. = I/O port. io, 3. TCC:ST.4. Ts..T = t1. io, (I 2 C specifications only) (I 2 C specifications.only)..Time = T1CKI. mc, Frequency. = MCLR.",
    "22.3.1 TIMING PARAMETER SYMBOLOGY\nmc, 3. TCC:ST.4. Ts..T = wr. mc, (I 2 C specifications only) (I 2 C specifications.only)..Time = WR. Uppercase letters and their meanings:, Frequency. = Uppercase letters and their meanings:. Uppercase letters and their meanings:, 3. TCC:ST.4. Ts..T = . Uppercase letters and their meanings:, (I 2 C specifications only) (I 2 C specifications.only)..Time = . S, Frequency. = . S, 3. TCC:ST.4. Ts..T = . S, (I 2 C specifications only) (I 2 C specifications.only)..Time = . F, Frequency. = Fall. F, 3. TCC:ST.4. Ts..T = P. F, (I 2 C specifications only) (I 2 C specifications.only)..Time = Period. H, Frequency. = High. H, 3. TCC:ST.4. Ts..T = R. H, (I 2 C specifications only) (I 2 C",
    "22.3.1 TIMING PARAMETER SYMBOLOGY\nspecifications.only)..Time = Rise. I, Frequency. = Invalid (Hi-impedance). I, 3. TCC:ST.4. Ts..T = V. I, (I 2 C specifications only) (I 2 C specifications.only)..Time = Valid. L, Frequency. = Low. L, 3. TCC:ST.4. Ts..T = Z. L, (I 2 C specifications only) (I 2 C specifications.only)..Time = Hi-impedance. I 2 C only, Frequency. = I 2 C only. I 2 C only, 3. TCC:ST.4. Ts..T = . I 2 C only, (I 2 C specifications only) (I 2 C specifications.only)..Time = . AA, Frequency. = output access. AA, 3. TCC:ST.4. Ts..T = High. AA, (I 2 C specifications only) (I 2 C specifications.only)..Time = High. BUF, Frequency. = Bus free. BUF, 3. TCC:ST.4. Ts..T",
    "22.3.1 TIMING PARAMETER SYMBOLOGY\n= Low. BUF, (I 2 C specifications only) (I 2 C specifications.only)..Time = Low. TCC:ST (I 2 C specifications only), Frequency. = TCC:ST (I 2 C specifications only). TCC:ST (I 2 C specifications only), 3. TCC:ST.4. Ts..T = . TCC:ST (I 2 C specifications only), (I 2 C specifications only) (I 2 C specifications.only)..Time = . CC, Frequency. = . CC, 3. TCC:ST.4. Ts..T = . CC, (I 2 C specifications only) (I 2 C specifications.only)..Time = . HD, Frequency. = Hold. HD, 3. TCC:ST.4. Ts..T = SU. HD, (I 2 C specifications only) (I 2 C specifications.only)..Time = Setup. ST, Frequency. = . ST, 3. TCC:ST.4. Ts..T = . ST, (I 2 C specifications only) (I 2 C",
    "22.3.1 TIMING PARAMETER SYMBOLOGY\nspecifications.only)..Time = . DAT, Frequency. = DATA input hold. DAT, 3. TCC:ST.4. Ts..T = STO. DAT, (I 2 C specifications only) (I 2 C specifications.only)..Time = STOP condition. STA, Frequency. = START condition. STA, 3. TCC:ST.4. Ts..T = . STA, (I 2 C specifications only) (I 2 C specifications.only)..Time = ",
    "22.3.2 TIMING CONDITIONS\nThe temperature and voltages specified in Table 22-3 apply  to  all timing  specifications  unless  otherwise noted. Figure 22-4 specifies the load conditions for the timing specifications.",
    "TABLE 22-3: TEMPERATURE AND VOLTAGE SPECIFICATIONS - AC\nAC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial\n-40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended\nOperating voltage VDD range as described in DC spec Section 22.1 and Section 22.2.\nLC parts operate for industrial temperatures only.",
    "FIGURE 22-4: LOAD CONDITIONS FOR DEVICE TIMING SPECIFICATIONS\nVDD/2 CL RL VSS, Load condition 2 = Pin VSS CL for all pins except OSC2/CLKO and including D and E outputs as ports",
    "TABLE 22-4: EXTERNAL CLOCK TIMING REQUIREMENTS\n1A, Symbol = FOSC. 1A, Characteristic = External CLKI Frequency (1) Oscillator Frequency (1). 1A, Min = DC DC DC 0.1 4 4 4 5. 1A, Max = 40 25 4 4 25 10 6.25. 1A, Units = MHz MHz MHz MHz MHz MHz MHz kHz. 1A, Conditions = EC, ECIO, -40 \u00b0 C to +85 \u00b0 C EC, ECIO, +85 \u00b0 C to +125 \u00b0 C RC osc XT osc HS osc HS + PLL osc, -40 \u00b0 C to +85 \u00b0 C HS + PLL osc, +85 \u00b0 C to +125 \u00b0 C LP Osc mode. 1, Symbol = TOSC. 1, Characteristic = External CLKI Period (1) Oscillator Period (1). 1, Min = 25 40 250 250 40 100 160 25. 1, Max = - - - 10,000 250 250 250 -. 1, Units = ns ns ns ns ns ns ns \u00b5 s. 1, Conditions = EC, ECIO, -40 \u00b0 C to +85 \u00b0 C EC, ECIO, +85 \u00b0 C to",
    "TABLE 22-4: EXTERNAL CLOCK TIMING REQUIREMENTS\n+125 \u00b0 C RC osc XT osc HS osc HS + PLL osc, -40 \u00b0 C to +85 \u00b0 C HS + PLL osc, +85 \u00b0 C to +125 \u00b0 C LP osc. 2, Symbol = TCY. 2, Characteristic = Instruction Cycle Time (1). 2, Min = 100 160. 2, Max = - -. 2, Units = ns ns. 2, Conditions = TCY = 4/FOSC, -40 \u00b0 C to +85 \u00b0 C TCY = 4/FOSC, +85 \u00b0 C to +125 \u00b0 C. 3, Symbol = TosL, TosH. 3, Characteristic = External Clock in (OSC1) High or Low Time. 3, Min = 30 2.5 10. 3, Max = - - -. 3, Units = ns \u00b5 s ns. 3, Conditions = XT osc LP osc HS osc. 4, Symbol = TosR, TosF. 4, Characteristic = External Clock in (OSC1) Rise or Fall Time. 4, Min = - - -. 4, Max = 20 50 7.5. 4, Units",
    "TABLE 22-4: EXTERNAL CLOCK TIMING REQUIREMENTS\n= ns ns ns. 4, Conditions = XT osc LP osc HS osc\nNote 1: Instruction cycle period (TCY) equals four times the input oscillator time-base period for all configurations except PLL. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min.' values with an external clock applied to the OSC1/CLKI pin. When an external clock input is used, the 'max.' cycle time limit is 'DC' (no clock) for all devices.",
    "TABLE 22-5: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2 TO 5.5V)\n-, Sym = FOSC. -, Characteristic = Oscillator Frequency Range. -, Min = 4. -, Typ\u2020 = -. -, Max = 10. -, Units = MHz. -, Conditions = HS mode only. -, Sym = FSYS. -, Characteristic = On-chip VCO System Frequency. -, Min = 16. -, Typ\u2020 = -. -, Max = 40. -, Units = MHz. -, Conditions = HS mode only. -, Sym = t rc. -, Characteristic = PLL Start-up Time (Lock Time). -, Min = -. -, Typ\u2020 = -. -, Max = 2. -, Units = ms. -, Conditions = . -, Sym = \u2206 CLK. -, Characteristic = CLKO Stability (Jitter). -, Min = -2. -, Typ\u2020 = -. -, Max = +2. -, Units = %. -, Conditions = ",
    "TABLE 22-5: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2 TO 5.5V)\n- \u2020 Data in 'Typ' column is at 5V, 25 C unless otherwise stated. These parameters are for design guidance only \u00b0 and are not tested.",
    "TABLE 22-6: CLKO AND I/O TIMING REQUIREMENTS\n10, Symbol = TosH2ckL. 10, Characteristic = OSC1 \u2191 to CLKO \u2193. 10, Characteristic = OSC1 \u2191 to CLKO \u2193. 10, Min = -. 10, Typ = 75. 10, Max = 200. 10, Units = ns. 10, Conditions = (Note 1). 11, Symbol = TosH2ckH. 11, Characteristic = OSC1 \u2191 to CLKO \u2191. 11, Characteristic = OSC1 \u2191 to CLKO \u2191. 11, Min = -. 11, Typ = 75. 11, Max = 200. 11, Units = ns. 11, Conditions = (Note 1). 12, Symbol = TckR. 12, Characteristic = CLKO rise time. 12, Characteristic = CLKO rise time. 12, Min = -. 12, Typ = 35. 12, Max = 100. 12, Units = ns. 12, Conditions = (Note 1). 13, Symbol = TckF. 13, Characteristic = CLKO fall time. 13, Characteristic = CLKO fall time. 13, Min = -. 13, Typ = 35. 13, Max =",
    "TABLE 22-6: CLKO AND I/O TIMING REQUIREMENTS\n100. 13, Units = ns. 13, Conditions = (Note 1). 14, Symbol = TckL2ioV. 14, Characteristic = CLKO \u2193 to Port out valid. 14, Characteristic = CLKO \u2193 to Port out valid. 14, Min = -. 14, Typ = -. 14, Max = 0.5 TCY + 20. 14, Units = ns. 14, Conditions = (Note 1). 15, Symbol = TioV2ckH. 15, Characteristic = Port in valid before CLKO \u2191. 15, Characteristic = Port in valid before CLKO \u2191. 15, Min = 0.25 TCY + 25. 15, Typ = -. 15, Max = -. 15, Units = ns. 15, Conditions = (Note 1). 16, Symbol = TckH2ioI. 16, Characteristic = Port in hold after CLKO \u2191. 16, Characteristic = Port in hold after CLKO \u2191. 16, Min = 0. 16, Typ = -. 16, Max = -. 16, Units = ns. 16, Conditions = (Note 1). 17, Symbol =",
    "TABLE 22-6: CLKO AND I/O TIMING REQUIREMENTS\nTosH2ioV. 17, Characteristic = OSC1 \u2191 (Q1 cycle) to Port out valid. 17, Characteristic = OSC1 \u2191 (Q1 cycle) to Port out valid. 17, Min = -. 17, Typ = 50. 17, Max = 150. 17, Units = ns. 17, Conditions = . 18, Symbol = TosH2ioI. 18, Characteristic = OSC1 \u2191 (Q2 cycle) to Port input invalid (I/O in hold time). 18, Characteristic = PIC18 F XXX. 18, Min = 100. 18, Typ = -. 18, Max = -. 18, Units = ns. 18, Conditions = . 18A, Symbol = . 18A, Characteristic = . 18A, Characteristic = PIC18 LF XXX. 18A, Min = 200. 18A, Typ = -. 18A, Max = -. 18A, Units = ns. 18A, Conditions = . 19, Symbol = TioV2osH. 19, Characteristic = Port input valid to OSC1 \u2191 (I/O in setup time). 19, Characteristic = Port input",
    "TABLE 22-6: CLKO AND I/O TIMING REQUIREMENTS\nvalid to OSC1 \u2191 (I/O in setup time). 19, Min = 0. 19, Typ = -. 19, Max = -. 19, Units = ns. 19, Conditions = . 20, Symbol = TioR. 20, Characteristic = Port output rise time. 20, Characteristic = PIC18 F XXX. 20, Min = -. 20, Typ = 10. 20, Max = 25. 20, Units = ns. 20, Conditions = . 20A, Symbol = . 20A, Characteristic = . 20A, Characteristic = PIC18 LF XXX. 20A, Min = -. 20A, Typ = -. 20A, Max = 60. 20A, Units = ns. 20A, Conditions = VDD = 2V. 21, Symbol = TioF. 21, Characteristic = Port output fall time. 21, Characteristic = PIC18 F XXX. 21, Min = -. 21, Typ = 10. 21, Max = 25. 21, Units = ns. 21, Conditions = . 21A, Symbol = . 21A, Characteristic = . 21A, Characteristic = PIC18 LF",
    "TABLE 22-6: CLKO AND I/O TIMING REQUIREMENTS\nXXX. 21A, Min = -. 21A, Typ = -. 21A, Max = 60. 21A, Units = ns. 21A, Conditions = VDD = 2V. 22\u2020\u2020, Symbol = TINP. 22\u2020\u2020, Characteristic = INT pin high or low time. 22\u2020\u2020, Characteristic = INT pin high or low time. 22\u2020\u2020, Min = TCY. 22\u2020\u2020, Typ = -. 22\u2020\u2020, Max = -. 22\u2020\u2020, Units = ns. 22\u2020\u2020, Conditions = . 23\u2020\u2020, Symbol = TRBP. 23\u2020\u2020, Characteristic = RB7:RB4 change INT high or low time. 23\u2020\u2020, Characteristic = RB7:RB4 change INT high or low time. 23\u2020\u2020, Min = TCY. 23\u2020\u2020, Typ = -. 23\u2020\u2020, Max = -. 23\u2020\u2020, Units = ns. 23\u2020\u2020, Conditions = . 24\u2020\u2020, Symbol = TRCP. 24\u2020\u2020, Characteristic = RC7:RC4 change INT high or low time. 24\u2020\u2020, Characteristic =",
    "TABLE 22-6: CLKO AND I/O TIMING REQUIREMENTS\nRC7:RC4 change INT high or low time. 24\u2020\u2020, Min = 20. 24\u2020\u2020, Typ = . 24\u2020\u2020, Max = . 24\u2020\u2020, Units = ns. 24\u2020\u2020, Conditions = \n- \u2020\u2020 These parameters are asynchronous events not related to any internal clock edges.\nNote1: Measurements are taken in RC mode, where CLKO output is 4 x TOSC.",
    "TABLE 22-7: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\n30, Symbol = TmcL. 30, Characteristic = MCLR Pulse Width (low). 30, Min = 2. 30, Typ = -. 30, Max = -. 30, Units = \u00b5 s. 30, Conditions = . 31, Symbol = TWDT. 31, Characteristic = Watchdog Timer Time-out Period (No Postscaler). 31, Min = 7. 31, Typ = 18. 31, Max = 33. 31, Units = ms. 31, Conditions = . 32, Symbol = TOST. 32, Characteristic = Oscillation Start-up Timer Period. 32, Min = 1024 TOSC. 32, Typ = -. 32, Max = 1024 TOSC. 32, Units = -. 32, Conditions = TOSC = OSC1 period. 33, Symbol = TPWRT. 33, Characteristic = Power up Timer Period. 33, Min = 28. 33, Typ = 72. 33, Max = 132. 33, Units = ms. 33, Conditions = . 34, Symbol = T IOZ.",
    "TABLE 22-7: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\n34, Characteristic = I/O Hi-impedance from MCLR Low or Watchdog Timer Reset. 34, Min = -. 34, Typ = 2. 34, Max = -. 34, Units = \u00b5 s. 34, Conditions = . 35, Symbol = TBOR. 35, Characteristic = Brown-out Reset Pulse Width. 35, Min = 200. 35, Typ = -. 35, Max = -. 35, Units = \u00b5 s. 35, Conditions = VDD \u2264 BVDD (see D005). 36, Symbol = TIVRST. 36, Characteristic = Time for Internal Reference Voltage to become stable. 36, Min = -. 36, Typ = 20. 36, Max = 500. 36, Units = \u00b5 s. 36, Conditions = . 37, Symbol = TLVD. 37, Characteristic = Low Voltage Detect Pulse Width. 37, Min = 200. 37, Typ = -. 37, Max = -. 37, Units = \u00b5 s. 37, Conditions = VDD \u2264 VLVD (see D420)",
    "TABLE 22-8: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n40, Symbol = Tt0H. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = No Prescaler. 40, Min = 0.5T CY + 20. 40, Max = -. 40, Units = ns. 40, Conditions = . 40, Symbol = Tt0H. 40, Characteristic = . 40, Characteristic = . 40, Characteristic = With Prescaler. 40, Min = 10. 40, Max = -. 40, Units = ns. 40, Conditions = . 41, Symbol = Tt0L. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = No Prescaler. 41, Min = 0.5T CY + 20. 41, Max = -. 41, Units = ns. 41, Conditions = . 41, Symbol = Tt0L. 41, Characteristic = . 41, Characteristic = . 41, Characteristic = With Prescaler. 41, Min = 10. 41, Max = -. 41, Units = ns. 41, Conditions = . 42, Symbol =",
    "TABLE 22-8: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nTt0P. 42, Characteristic = T0CKI Period. 42, Characteristic = T0CKI Period. 42, Characteristic = No Prescaler. 42, Min = TCY + 10. 42, Max = -. 42, Units = ns. 42, Conditions = . 42, Symbol = Tt0P. 42, Characteristic = . 42, Characteristic = . 42, Characteristic = With Prescaler. 42, Min = Greater of: 20 nS or TCY + 40 N. 42, Max = -. 42, Units = ns. 42, Conditions = N = prescale value (1, 2, 4,..., 256). 45, Symbol = Tt1H. 45, Characteristic = T1CKI High. 45, Characteristic = Synchronous, no prescaler. 45, Characteristic = Synchronous, no prescaler. 45, Min = 0.5T CY + 20. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T1CKI High. 45, Characteristic = Synchronous, with prescaler. 45,",
    "TABLE 22-8: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nCharacteristic = PIC18 F XXX. 45, Min = 10. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T1CKI High. 45, Characteristic = Synchronous, with prescaler. 45, Characteristic = PIC18 LF XXX. 45, Min = 25. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T1CKI High. 45, Characteristic = Asynchronous. 45, Characteristic = PIC18 F XXX. 45, Min = 30. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T1CKI High. 45, Characteristic = Asynchronous. 45, Characteristic = PIC18 LF XXX. 45, Min = 50. 45, Max = -. 45, Units = ns. 45, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI Low Time. 46, Characteristic =",
    "TABLE 22-8: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nSynchronous, no prescaler. 46, Characteristic = Synchronous, no prescaler. 46, Min = 0.5T CY + 5. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI Low Time. 46, Characteristic = Synchronous, with prescaler. 46, Characteristic = PIC18 F XXX. 46, Min = 10. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI Low Time. 46, Characteristic = Synchronous, with prescaler. 46, Characteristic = PIC18 LF XXX. 46, Min = 25. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI Low Time. 46, Characteristic = Asynchronous. 46, Characteristic = PIC18 F XXX. 46, Min = 30. 46, Max = -. 46, Units = ns. 46, Conditions",
    "TABLE 22-8: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n= . 46, Symbol = Tt1L. 46, Characteristic = T1CKI Low Time. 46, Characteristic = Asynchronous. 46, Characteristic = PIC18 LF XXX. 46, Min = 50. 46, Max = -. 46, Units = ns. 46, Conditions = . 47, Symbol = Tt1P. 47, Characteristic = T1CKI input period. 47, Characteristic = Synchronous. 47, Characteristic = Synchronous. 47, Min = Greater of: 20 nS or TCY + 40 N. 47, Max = -. 47, Units = ns. 47, Conditions = N = prescale value (1, 2, 4, 8). 47, Symbol = Tt1P. 47, Characteristic = T1CKI input period. 47, Characteristic = Asynchronous. 47, Characteristic = Asynchronous. 47, Min = 60. 47, Max = -. 47, Units = ns. 47, Conditions = . , Symbol = Ft1. , Characteristic = T1CKI oscillator input frequency range. , Characteristic = T1CKI oscillator input frequency range.",
    "TABLE 22-8: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n, Characteristic = T1CKI oscillator input frequency range. , Min = DC. , Max = 50. , Units = kHz. , Conditions = . 48, Symbol = Tcke2tmrI Delay from. 48, Characteristic = external T1CKI clock edge to timer. 48, Characteristic = external T1CKI clock edge to timer. 48, Characteristic = external T1CKI clock edge to timer. 48, Min = 2 TOSC. 48, Max = 7 TOSC. 48, Units = -. 48, Conditions = ",
    "TABLE 22-9: CAPTURE/COMPARE/PWM REQUIREMENTS (CCP1 AND CCP2)\n50, Symbol = TccL. 50, Characteristic = CCPx input low time. 50, Characteristic = No Prescaler. 50, Characteristic = No Prescaler. 50, Min = 0.5 TCY + 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Symbol = TccL. 50, Characteristic = CCPx input low time. 50, Characteristic = With Prescaler. 50, Characteristic = PIC18 F XXX. 50, Min = 10. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Symbol = TccL. 50, Characteristic = CCPx input low time. 50, Characteristic = With Prescaler. 50, Characteristic = PIC18 LF XXX. 50, Min = 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx input high time. 51, Characteristic = No Prescaler. 51, Characteristic = No Prescaler. 51, Min = 0.5 TCY + 20.",
    "TABLE 22-9: CAPTURE/COMPARE/PWM REQUIREMENTS (CCP1 AND CCP2)\n51, Max = -. 51, Units = ns. 51, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx input high time. 51, Characteristic = With Prescaler. 51, Characteristic = PIC18 F XXX. 51, Min = 10. 51, Max = -. 51, Units = ns. 51, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx input high time. 51, Characteristic = With Prescaler. 51, Characteristic = PIC18 LF XXX. 51, Min = 20. 51, Max = -. 51, Units = ns. 51, Conditions = . 52, Symbol = TccP. 52, Characteristic = CCPx input period. 52, Characteristic = CCPx input period. 52, Characteristic = CCPx input period. 52, Min = 3 TCY + 40 N. 52, Max = -. 52, Units = ns. 52, Conditions = N = prescale value (1,4 or 16). 53, Symbol = TccR. 53, Characteristic = CCPx output fall time.",
    "TABLE 22-9: CAPTURE/COMPARE/PWM REQUIREMENTS (CCP1 AND CCP2)\n53, Characteristic = CCPx output fall time. 53, Characteristic = PIC18 F XXX. 53, Min = -. 53, Max = 25. 53, Units = ns. 53, Conditions = . 53, Symbol = TccR. 53, Characteristic = . 53, Characteristic = . 53, Characteristic = PIC18 LF XXX. 53, Min = -. 53, Max = 60. 53, Units = ns. 53, Conditions = VDD = 2V. 54, Symbol = TccF. 54, Characteristic = CCPx output fall time. 54, Characteristic = CCPx output fall time. 54, Characteristic = PIC18 F XXX. 54, Min = -. 54, Max = 25. 54, Units = ns. 54, Conditions = . 54, Symbol = TccF. 54, Characteristic = . 54, Characteristic = . 54, Characteristic = PIC18 LF XXX. 54, Min = -. 54, Max = 60. 54, Units = ns. 54, Conditions = VDD = 2V",
    "TABLE 22-9: CAPTURE/COMPARE/PWM REQUIREMENTS (CCP1 AND CCP2)\nFIGURE 22-11: PARALLEL SLAVE PORT TIMING (PIC18F4X2)",
    "TABLE 22-10: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F4X2)\n62, Symbol = TdtV2wrH. 62, Characteristic = Data in valid before WR \u2191 or CS \u2191 (setup time). 62, Min = 20 25. 62, Max = - -. 62, Units = ns ns. 62, Conditions = Extended Temp. Range. 63, Symbol = TwrH2dtI. 63, Characteristic = WR \u2191 or CS \u2191 to data-in invalid (hold time) PIC18. 63, Min = 20. 63, Max = -. 63, Units = ns. 63, Conditions = . , Symbol = . , Characteristic = PIC18 LF XXX. , Min = 35. , Max = -. , Units = ns. , Conditions = VDD = 2V. 64, Symbol = TrdL2dtV. 64, Characteristic = RD \u2193 and CS \u2193 to data-out valid. 64, Min = -. 64, Max = 80. 64, Units = ns. 64, Conditions = . , Symbol = . , Characteristic = . , Min = -. , Max = 90. , Units = ns. , Conditions = Extended Temp. Range. 65, Symbol =",
    "TABLE 22-10: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F4X2)\nTrdH2dtI. 65, Characteristic = RD \u2191 or CS \u2193 to data-out invalid. 65, Min = 10 30. 65, Max = . 65, Units = ns. 65, Conditions = . 66, Symbol = TibfINH. 66, Characteristic = Inhibit of the IBF flag bit being cleared from WR \u2191 or CS \u2191. 66, Min = -. 66, Max = 3 TCY. 66, Units = . 66, Conditions = ",
    "FIGURE 22-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 0)\nTABLE 22-11: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0)",
    "FIGURE 22-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 0)\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 input. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 input. 70, Min = TCY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = TscH. 71, Characteristic = SCK input high time. 71, Characteristic = Continuous. 71, Min = 1.25 TCY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = . 71A, Characteristic = (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK input low time. 72, Characteristic = Continuous. 72, Min = 1.25 TCY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol = . 72A,",
    "FIGURE 22-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 0)\nCharacteristic = (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup time of SDI data input to SCK edge. 73, Characteristic = Setup time of SDI data input to SCK edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last clock edge of Byte1 to the 1st clock edge of Byte2. 73A, Characteristic = Last clock edge of Byte1 to the 1st clock edge of Byte2. 73A, Min = 1.5 TCY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold time of SDI data input to SCK edge. 74, Characteristic = Hold",
    "FIGURE 22-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 0)\ntime of SDI data input to SCK edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO data output rise time. 75, Characteristic = PIC18 F XXX. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V. 76, Symbol = TdoF. 76, Characteristic = SDO data output fall time. 76, Characteristic = PIC18 F XXX. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V. 78, Symbol = TscR. 78, Characteristic = SCK output rise time. 78,",
    "FIGURE 22-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 0)\nCharacteristic = PIC18 F XXX. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . , Symbol = . , Characteristic = (Master mode). , Characteristic = PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V. 79, Symbol = TscF. 79, Characteristic = SCK output fall time (Master mode). 79, Characteristic = PIC18 F XXX. 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V. 80, Symbol = TscH2doV,. 80, Characteristic = SDO data output valid after SCK. 80, Characteristic = PIC18 F XXX. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . , Symbol =",
    "FIGURE 22-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 0)\nTscL2doV. , Characteristic = edge. , Characteristic = PIC18 LF XXX. , Min = -. , Max = 150. , Units = ns. , Conditions = VDD = 2V\nNote 1: Requires the use of Parameter # 73A.\n2: Only if Parameter # 71A and # 72A are used.",
    "TABLE 22-12: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1)\n71, Symbol = TscH. 71, Characteristic = SCK input high time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 TCY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = . 71A, Characteristic = . 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK input low time. 72, Characteristic = Continuous. 72, Min = 1.25 TCY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol = . 72A, Characteristic = (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup time of",
    "TABLE 22-12: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1)\nSDI data input to SCK edge. 73, Characteristic = Setup time of SDI data input to SCK edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last clock edge of Byte1 to the 1st clock edge of Byte2. 73A, Characteristic = Last clock edge of Byte1 to the 1st clock edge of Byte2. 73A, Min = 1.5 TCY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold time of SDI data input to SCK edge. 74, Characteristic = Hold time of SDI data input to SCK edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO data output rise time. 75, Characteristic = PIC18 F XXX. 75, Min =",
    "TABLE 22-12: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1)\n-. 75, Max = 25. 75, Units = ns. 75, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V. 76, Symbol = TdoF. 76, Characteristic = SDO data output fall time. 76, Characteristic = PIC18 F XXX. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V. 78, Symbol = TscR. 78, Characteristic = SCK output rise time (Master mode). 78, Characteristic = PIC18 F XXX. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXX. , Min = -. , Max = 60. ,",
    "TABLE 22-12: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1)\nUnits = ns. , Conditions = VDD = 2V. 79, Symbol = TscF. 79, Characteristic = SCK output fall time (Master mode). 79, Characteristic = PIC18 F XXX. 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V. 80, Symbol = TscH2doV,. 80, Characteristic = SDO data output valid after SCK edge. 80, Characteristic = PIC18 F XXX. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . , Symbol = TscL2doV. , Characteristic = . , Characteristic = PIC18 LF XXX. , Min = -. , Max = 150. , Units = ns. , Conditions = VDD = 2V. 81, Symbol = TdoV2scH, TdoV2scL. 81, Characteristic = SDO data",
    "TABLE 22-12: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1)\noutput setup to SCK edge. 81, Characteristic = SDO data output setup to SCK edge. 81, Min = TCY. 81, Max = -. 81, Units = ns. 81, Conditions = \nNote 1: Requires the use of Parameter # 73A.\n2: Only if Parameter # 71A and # 72A are used.",
    "TABLE 22-13: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING (CKE = 0))\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 input. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 input. 70, Min = TCY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = TscH. 71, Characteristic = SCK input high time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 TCY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = TscH. 71A, Characteristic = SCK input high time (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK input low time (Slave mode). 72, Characteristic = Continuous. 72, Min = 1.25 TCY + 30. 72, Max = -.",
    "TABLE 22-13: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING (CKE = 0))\n72, Units = ns. 72, Conditions = . 72A, Symbol = TscL. 72A, Characteristic = SCK input low time (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup time of SDI data input to SCK edge. 73, Characteristic = Setup time of SDI data input to SCK edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last clock edge of Byte1 to the first clock edge of Byte2. 73A, Characteristic = Last clock edge of Byte1 to the first clock edge of Byte2. 73A, Min = 1.5 TCY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol =",
    "TABLE 22-13: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING (CKE = 0))\nTscH2diL, TscL2diL. 74, Characteristic = Hold time of SDI data input to SCK edge. 74, Characteristic = Hold time of SDI data input to SCK edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO data output rise time. 75, Characteristic = PIC18 F XXX. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO data output rise time. 75, Characteristic = PIC18 LF XXX. 75, Min = -. 75, Max = 60. 75, Units = ns. 75, Conditions = VDD = 2V. 76, Symbol = TdoF. 76, Characteristic = SDO data output fall time. 76, Characteristic = PIC18 F XXX. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 76, Symbol = TdoF. 76,",
    "TABLE 22-13: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING (CKE = 0))\nCharacteristic = SDO data output fall time. 76, Characteristic = PIC18 LF XXX. 76, Min = -. 76, Max = 60. 76, Units = ns. 76, Conditions = VDD = 2V. 77, Symbol = TssH2doZ. 77, Characteristic = SS \u2191 to SDO output hi-impedance. 77, Characteristic = SS \u2191 to SDO output hi-impedance. 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK output rise time (Master mode). 78, Characteristic = PIC18 F XXX. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK output rise time (Master mode). 78, Characteristic = PIC18 LF XXX. 78, Min = -. 78, Max = 60. 78, Units = ns. 78, Conditions = VDD = 2V. 79, Symbol = TscF. 79,",
    "TABLE 22-13: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING (CKE = 0))\nCharacteristic = SCK output fall time (Master mode). 79, Characteristic = PIC18 F XXX. 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK output fall time (Master mode). 79, Characteristic = PIC18 LF XXX. 79, Min = -. 79, Max = 60. 79, Units = ns. 79, Conditions = VDD = 2V. 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO data output valid after SCK edge. 80, Characteristic = PIC18 F XXX. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO data output valid after SCK edge. 80, Characteristic = PIC18 LF XXX. 80, Min = -. 80, Max = 150. 80, Units = ns. 80, Conditions = VDD =",
    "TABLE 22-13: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING (CKE = 0))\n2V. 83, Symbol = TscH2ssH, TscL2ssH. 83, Characteristic = SS \u2191 after SCK edge. 83, Characteristic = SS \u2191 after SCK edge. 83, Min = 1.5 TCY + 40. 83, Max = -. 83, Units = ns. 83, Conditions = \nNote\n1: Requires the use of Parameter # 73A.\n2: Only if Parameter # 71A and # 72A are used.",
    "TABLE 22-14: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1)\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 input. 70,  = . 70, Min = TCY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = TscH. 71, Characteristic = SCK input high time (Slave mode). 71,  = Continuous. 71, Min = 1.25 TCY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = . 71A, Characteristic = . 71A,  = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK input low time (Slave mode). 72,  = Continuous. 72, Min = 1.25 TCY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol = . 72A, Characteristic = . 72A,",
    "TABLE 22-14: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1)\n= Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73A, Symbol = TB2B. 73A, Characteristic = Last clock edge of Byte1 to the first clock edge of Byte2. 73A,  = . 73A, Min = 1.5 TCY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold time of SDI data input to SCK edge. 74,  = . 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO data output rise time. 75,  = PIC18 F XXX. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . , Symbol = . , Characteristic = . ,",
    "TABLE 22-14: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1)\n= PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V. 76, Symbol = TdoF. 76, Characteristic = SDO data output fall time. 76,  = PIC18 F XXX. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . , Symbol = . , Characteristic = . ,  = PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V. 77, Symbol = TssH2doZ. 77, Characteristic = SS \u2191 to SDO output hi-impedance. 77,  = . 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK output rise time (Master mode). 78,  = PIC18 F XXX. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . , Symbol = . , Characteristic = . ,",
    "TABLE 22-14: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1)\n= PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V. 79, Symbol = TscF. 79, Characteristic = SCK output fall time (Master mode). 79,  = PIC18 F XXX. 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . , Symbol = . , Characteristic = . ,  = PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V. 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO data output valid after SCK edge. 80,  = PIC18 F XXX. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . , Symbol = . , Characteristic = . ,",
    "TABLE 22-14: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1)\n= PIC18 LF XXX. , Min = -. , Max = 150. , Units = ns. , Conditions = VDD = 2V. 82, Symbol = TssL2doV. 82, Characteristic = SDO data output valid after SS \u2193 edge PIC18 F XXX. 82,  = . 82, Min = -. 82, Max = 50. 82, Units = ns. 82, Conditions = . , Symbol = . , Characteristic = . ,  = PIC18 LF XXX. , Min = -. , Max = 150. , Units = ns. , Conditions = VDD = 2V. 83, Symbol = TscH2ssH, TscL2ssH. 83, Characteristic = SS \u2191 after SCK edge. 83,  = . 83, Min = 1.5 TCY + 40. 83, Max = -. 83, Units = ns. 83, Conditions = \nNote\n1: Requires the use of Parameter # 73A.\n2: Only if Parameter # 71A and # 72A are used.",
    "TABLE 22-15: I 2 C BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\n90, Symbol = TSU:STA. 90, Characteristic = START condition Setup time. 90, Characteristic = 100 kHz mode. 90, Min = 4700. 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated. , Symbol = . , Characteristic = . , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = START condition. 91, Symbol = THD:STA. 91, Characteristic = START condition. 91, Characteristic = 100 kHz mode. 91, Min = 4000. 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first. , Symbol = . , Characteristic = Hold time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = clock pulse is generated. 92, Symbol = TSU:STO. 92, Characteristic = STOP condition. 92, Characteristic = 100 kHz mode. 92, Min = 4700. 92, Max = -. 92, Units = ns. 92, Conditions = . , Symbol = . , Characteristic",
    "TABLE 22-15: I 2 C BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\n= Setup time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = . 93, Symbol = THD:STO. 93, Characteristic = STOP condition. 93, Characteristic = 100 kHz mode. 93, Min = 4000. 93, Max = -. 93, Units = ns. 93, Conditions = . , Symbol = . , Characteristic = Hold time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = ",
    "TABLE 22-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n100, Symbol = THIGH. 100, Characteristic = Clock high time. 100, Characteristic = 100 kHz mode. 100, Min = 4.0. 100, Max = -. 100, Units = \u00b5 s. 100, Conditions = PIC18FXXX must operate at a minimum of 1.5 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock high time. 100, Characteristic = 400 kHz mode. 100, Min = 0.6. 100, Max = -. 100, Units = \u00b5 s. 100, Conditions = PIC18FXXX must operate at a minimum of 10 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock high time. 100, Characteristic = SSP Module. 100, Min = 1.5 TCY. 100, Max = -. 100, Units = . 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock low time. 101, Characteristic = 100 kHz mode. 101, Min = 4.7. 101, Max = -. 101, Units = \u00b5 s. 101, Conditions = PIC18FXXX must operate at a minimum of 1.5 MHz. 101, Symbol =",
    "TABLE 22-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\nTLOW. 101, Characteristic = Clock low time. 101, Characteristic = 400 kHz mode. 101, Min = 1.3. 101, Max = -. 101, Units = \u00b5 s. 101, Conditions = PIC18FXXX must operate at a minimum of 10 MHz. 101, Symbol = TLOW. 101, Characteristic = Clock low time. 101, Characteristic = SSP Module. 101, Min = 1.5 TCY. 101, Max = -. 101, Units = . 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL rise time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL rise time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL fall time.",
    "TABLE 22-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n103, Characteristic = 100 kHz mode. 103, Min = -. 103, Max = 1000. 103, Units = ns. 103, Conditions = VDD \u2265 4.2V. 103, Symbol = TF. 103, Characteristic = SDA and SCL fall time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = VDD \u2265 4.2V. 90, Symbol = TSU:STA. 90, Characteristic = START condition setup time. 90, Characteristic = 100 kHz mode. 90, Min = 4.7. 90, Max = -. 90, Units = \u00b5 s. 90, Conditions = Only relevant for Repeated. 90, Symbol = TSU:STA. 90, Characteristic = START condition setup time. 90, Characteristic = 400 kHz mode. 90, Min = 0.6. 90, Max = -. 90, Units = \u00b5 s. 90, Conditions = START condition. 91, Symbol = THD:STA. 91, Characteristic = STARTcondition hold time. 91, Characteristic = 100 kHz mode.",
    "TABLE 22-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n91, Min = 4.0. 91, Max = -. 91, Units = \u00b5 s. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = STARTcondition hold time. 91, Characteristic = 400 kHz mode. 91, Min = 0.6. 91, Max = -. 91, Units = \u00b5 s. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD:DAT. 106, Characteristic = Data input hold time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD:DAT. 106, Characteristic = Data input hold time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = \u00b5 s. 106, Conditions = . 107, Symbol = TSU:DAT. 107, Characteristic = Data input setup time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -. 107,",
    "TABLE 22-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\nUnits = ns. 107, Conditions = (Note 2). 107, Symbol = TSU:DAT. 107, Characteristic = Data input setup time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = TSU:STO. 92, Characteristic = STOP condition setup time. 92, Characteristic = 100 kHz mode. 92, Min = 4.7. 92, Max = -. 92, Units = \u00b5 s. 92, Conditions = . 92, Symbol = TSU:STO. 92, Characteristic = STOP condition setup time. 92, Characteristic = 400 kHz mode. 92, Min = 0.6. 92, Max = -. 92, Units = \u00b5 s. 92, Conditions = . 109, Symbol = TAA. 109, Characteristic = Output valid from clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500. 109, Units = ns. 109, Conditions = (Note 1). 109, Symbol = TAA. 109, Characteristic = Output valid from clock.",
    "TABLE 22-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n109, Characteristic = 400 kHz mode. 109, Min = -. 109, Max = -. 109, Units = ns. 109, Conditions = (Note 1). 110, Symbol = TBUF. 110, Characteristic = Bus free time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = \u00b5 s. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus free time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = \u00b5 s. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = Bus capacitive loading. D102, Characteristic = Bus capacitive loading. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = \nNote",
    "TABLE 22-16: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n1: As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of START or STOP conditions.\n2: A Fast mode I 2 C bus device can be used in a Standard mode I 2 C bus system, but the requirement TSU:DAT \u2265 250 ns must then be met. This will automatically be the case if the device does not stretch the LOW period of the SCL signal. If such a device does stretch the LOW period of the SCL signal, it must output the next data bit to the SDA line. TR max. + TSU:DAT = 1000 + 250 = 1250 ns (according to the Standard mode I 2 C bus specification) before the SCL line is released.",
    "TABLE 22-17: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\n90, Symbol = TSU:STA. 90, Characteristic = START condition. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated START condition. 90, Symbol = TSU:STA. 90, Characteristic = Setup time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated START condition. 90, Symbol = TSU:STA. 90, Characteristic = . 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated START condition. 91, Symbol = THD:STA. 91, Characteristic = START condition. 91, Characteristic = 100 kHz mode. 91, Min = 2(T OSC)(BRG + 1).",
    "TABLE 22-17: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\n91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = Hold time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = . 91, Characteristic = 1 MHz mode (1). 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 92, Symbol = TSU:STO. 92, Characteristic = STOP condition. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 92, Symbol = TSU:STO. 92, Characteristic =",
    "TABLE 22-17: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\nSetup time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 92, Symbol = TSU:STO. 92, Characteristic = . 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 93, Symbol = THD:STO. 93, Characteristic = STOP condition. 93, Characteristic = 100 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = . 93, Symbol = THD:STO. 93, Characteristic = Hold time. 93, Characteristic = 400 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = . 93, Symbol = THD:STO. 93, Characteristic = .",
    "TABLE 22-17: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\n93, Characteristic = 1 MHz mode (1). 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = \nNote 1: Maximum pin capacitance = 10 pF for all I 2 C pins.",
    "TABLE 22-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\n100, Symbol = THIGH. 100, Characteristic = Clock high time. 100, Characteristic = 100 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock high time. 100, Characteristic = 400 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock high time. 100, Characteristic = 1 MHz mode (1). 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock low time. 101, Characteristic = 100 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock low",
    "TABLE 22-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\ntime. 101, Characteristic = 400 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock low time. 101, Characteristic = 1 MHz mode (1). 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL rise time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA and SCL rise time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA and",
    "TABLE 22-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\nSCL rise time. 102, Characteristic = 1 MHz mode (1). 102, Min = -. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL fall time. 103, Characteristic = 100 kHz mode. 103, Min = -. 103, Max = 1000. 103, Units = ns. 103, Conditions = VDD \u2265 4.2V. 103, Symbol = TF. 103, Characteristic = SDA and SCL fall time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = VDD \u2265 4.2V. 90, Symbol = TSU:STA. 90, Characteristic = STARTcondition setup time. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated START condition. 90, Symbol =",
    "TABLE 22-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\nTSU:STA. 90, Characteristic = STARTcondition setup time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated START condition. 90, Symbol = TSU:STA. 90, Characteristic = STARTcondition setup time. 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated START condition. 91, Symbol = THD:STA. 91, Characteristic = STARTcondition hold time. 91, Characteristic = 100 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = STARTcondition hold time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T",
    "TABLE 22-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\nOSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = STARTcondition hold time. 91, Characteristic = 1 MHz mode (1). 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD:DAT. 106, Characteristic = Data input hold time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD:DAT. 106, Characteristic = Data input hold time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = ms. 106, Conditions = . 107, Symbol = TSU:DAT. 107, Characteristic = Data input setup time. 107, Characteristic = 100 kHz mode. 107, Min =",
    "TABLE 22-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\n250. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = TSU:DAT. 107, Characteristic = Data input setup time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = TSU:STO. 92, Characteristic = STOP condition setup time. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = TSU:STO. 92, Characteristic = STOP condition setup time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = TSU:STO. 92, Characteristic = STOP condition setup time. 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG +",
    "TABLE 22-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\n1). 92, Max = -. 92, Units = ms. 92, Conditions = . 109, Symbol = TAA. 109, Characteristic = Output valid from clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500. 109, Units = ns. 109, Conditions = . 109, Symbol = TAA. 109, Characteristic = Output valid from clock. 109, Characteristic = 400 kHz mode. 109, Min = -. 109, Max = 1000. 109, Units = ns. 109, Conditions = . 109, Symbol = TAA. 109, Characteristic = Output valid from clock. 109, Characteristic = 1 MHz mode (1). 109, Min = -. 109, Max = -. 109, Units = ns. 109, Conditions = . 110, Symbol = TBUF. 110, Characteristic = Bus free time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus free time. 110,",
    "TABLE 22-18: MASTER SSP I 2 C BUS DATA REQUIREMENTS\nCharacteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = Bus capacitive loading. D102, Characteristic = Bus capacitive loading. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = \nNote 1: Maximum pin capacitance = 10 pF for all I 2 C pins.\n2: A Fast mode I 2 C bus device can be used in a Standard mode I 2 C bus system, but parameter #107 \u2265 250 ns must then be met. This will automatically be the case if the device does not stretch the LOW period of the SCL signal. If such a device does stretch the LOW period of the SCL signal, it must output the next data bit to the SDA line, parameter #102 + parameter #107 = 1000 + 250 = 1250 ns (for 100 kHz mode) before the SCL line is released.",
    "TABLE 22-19: USART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n120, Symbol = TckH2dtV. 120, Characteristic = SYNC XMIT (MASTER & SLAVE) Clock high to data out valid. 120, Characteristic = PIC18 F XXX. 120, Min = -. 120, Max = 50. 120, Units = ns. 120, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXX. , Min = -. , Max = 150. , Units = ns. , Conditions = VDD = 2V. 121, Symbol = Tckr. 121, Characteristic = Clock out rise time and fall time. 121, Characteristic = PIC18 F XXX. 121, Min = -. 121, Max = 25. 121, Units = ns. 121, Conditions = . , Symbol = . , Characteristic = (Master mode). , Characteristic = PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V. 122, Symbol = Tdtr. 122, Characteristic = Data out rise time and fall time. 122, Characteristic = PIC18 F XXX. 122, Min = -. 122, Max = 25.",
    "TABLE 22-19: USART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n122, Units = ns. 122, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XXX. , Min = -. , Max = 60. , Units = ns. , Conditions = VDD = 2V",
    "TABLE 22-20: USART SYNCHRONOUS  RECEIVE REQUIREMENTS\n125, Symbol = TdtV2ckl. 125, Characteristic = SYNC RCV (MASTER & SLAVE) Data hold before CK \u2193 (DT hold time). 125, Characteristic = SYNC RCV (MASTER & SLAVE) Data hold before CK \u2193 (DT hold time). 125, Min = 10. 125, Max = -. 125, Units = ns. 125, Conditions = . 126, Symbol = TckL2dtl. 126, Characteristic = Data hold after CK \u2193 (DT hold time). 126, Characteristic = PIC18 F XXX. 126, Min = 15. 126, Max = -. 126, Units = ns. 126, Conditions = . 126, Symbol = TckL2dtl. 126, Characteristic = Data hold after CK \u2193 (DT hold time). 126, Characteristic = PIC18 LF XXX. 126, Min = 20. 126, Max = -. 126, Units = ns. 126, Conditions = VDD = 2V",
    "TABLE 22-21: A/D CONVERTER CHARACTERISTICS: PIC18FXX2 (INDUSTRIAL, EXTENDED) PIC18LFXX2 (INDUSTRIAL)\nA01, Symbol = NR. A01, Characteristic = Resolution. A01, Min = -. A01, Typ = -. A01, Max = 10. A01, Units = bit. A01, Conditions = . A03, Symbol = EIL. A03, Characteristic = Integral linearity error. A03, Min = -. A03, Typ = -. A03, Max = <-1. A03, Units = LSb. A03, Conditions = VREF = VDD = 5.0V. A04, Symbol = EDL. A04, Characteristic = Differential linearity error. A04, Min = -. A04, Typ = -. A04, Max = <-1. A04, Units = LSb. A04, Conditions = VREF = VDD = 5.0V. A05, Symbol = EG. A05, Characteristic = Gain error. A05, Min = -. A05,",
    "TABLE 22-21: A/D CONVERTER CHARACTERISTICS: PIC18FXX2 (INDUSTRIAL, EXTENDED) PIC18LFXX2 (INDUSTRIAL)\nTyp = -. A05, Max = <-1. A05, Units = LSb. A05, Conditions = VREF = VDD = 5.0V. A06, Symbol = EOFF. A06, Characteristic = Offset error. A06, Min = -. A06, Typ = -. A06, Max = <-1.5. A06, Units = LSb. A06, Conditions = VREF = VDD = 5.0V. A10, Symbol = -. A10, Characteristic = Monotonicity. A10, Min = guaranteed (2). A10, Typ = guaranteed (2). A10, Max = guaranteed (2). A10, Units = -. A10, Conditions = VSS \u2264 VAIN \u2264 VREF. A20 A20A, Symbol = VREF. A20 A20A, Characteristic = Reference Voltage (VREFH - VREFL). A20 A20A, Min = 1.8V",
    "TABLE 22-21: A/D CONVERTER CHARACTERISTICS: PIC18FXX2 (INDUSTRIAL, EXTENDED) PIC18LFXX2 (INDUSTRIAL)\n3V. A20 A20A, Typ = - -. A20 A20A, Max = - -. A20 A20A, Units = V V. A20 A20A, Conditions = VDD < 3.0V VDD \u2265 3.0V. A21, Symbol = VREFH. A21, Characteristic = Reference voltage High. A21, Min = AVSS. A21, Typ = -. A21, Max = AVDD + 0.3V. A21, Units = V. A21, Conditions = . A22, Symbol = VREFL. A22, Characteristic = Reference voltage Low. A22, Min = AVSS - 0.3V. A22, Typ = -. A22, Max = VREFH. A22, Units = V. A22, Conditions = . A25, Symbol = VAIN. A25, Characteristic = Analog input voltage. A25, Min = AVSS - 0.3V. A25, Typ = -. A25, Max = AVDD +",
    "TABLE 22-21: A/D CONVERTER CHARACTERISTICS: PIC18FXX2 (INDUSTRIAL, EXTENDED) PIC18LFXX2 (INDUSTRIAL)\n0.3V. A25, Units = V. A25, Conditions = VDD \u2265 2.5V (Note 3). A30, Symbol = ZAIN. A30, Characteristic = Recommended impedance of analog voltage source. A30, Min = -. A30, Typ = -. A30, Max = 2.5. A30, Units = k \u2126. A30, Conditions = (Note 4). A50, Symbol = I REF. A50, Characteristic = VREF input current (Note 1). A50, Min = - -. A50, Typ = - -. A50, Max = 5 150. A50, Units = \u00b5 A \u00b5 A. A50, Conditions = During VAIN acquisition During A/D conversion cycle",
    "TABLE 22-21: A/D CONVERTER CHARACTERISTICS: PIC18FXX2 (INDUSTRIAL, EXTENDED) PIC18LFXX2 (INDUSTRIAL)\nNote 1: Vss \u2264 VAIN \u2264 VREF\n2: The A/D conversion result never decreases with an increase in the Input Voltage, and has no missing codes.\n3: For VDD < 2.5V, VAIN should be limited to < .5 VDD.\n4: Maximum allowed impedance for analog voltage source is 10 k \u2126 . This requires higher acquisition times.",
    "FIGURE 22-22: A/D CONVERSION TIMING\nNote 1: If the A/D clock source is selected as RC, a time of TCY is added before the A/D clock starts. This allows the SLEEP instruction to be executed.\n2: This is a minimal RC delay (typically 100 nS), which also disconnects the holding capacitor from the analog input.",
    "TABLE 22-22: A/D CONVERSION REQUIREMENTS\n130, Symbol = TAD. 130, Characteristic = A/D clock period. 130, Characteristic = PIC18 F XXX. 130, Min = 1.6. 130, Max = 20 (4). 130, Units = \u00b5 s. 130, Conditions = TOSC based. , Symbol = . , Characteristic = . , Characteristic = PIC18 F XXX. , Min = 2.0. , Max = 6.0. , Units = \u00b5 s. , Conditions = A/D RC mode. 131, Symbol = TCNV. 131, Characteristic = Conversion time. 131, Characteristic = Conversion time. 131, Min = 11. 131, Max = 12. 131, Units = TAD. 131, Conditions = . 132, Symbol = TACQ. 132, Characteristic = Acquisition time (Note 2). 132, Characteristic = Acquisition time (Note 2). 132, Min = 5 10. 132, Max = - -. 132, Units = \u00b5 s \u00b5 s. 132, Conditions = VREF = VDD = 5.0V VREF = VDD = 2.5V. 135, Symbol = TSWC. 135, Characteristic = Switching Time from convert \u2192 sample.",
    "TABLE 22-22: A/D CONVERSION REQUIREMENTS\n135, Characteristic = Switching Time from convert \u2192 sample. 135, Min = -. 135, Max = (Note 3). 135, Units = . 135, Conditions = \nNote 1: ADRES register may be read on the following TCY cycle.\n2: The time for the holding capacitor to acquire the 'New' input voltage, when the new input value has not changed by more than 1 LSB from the last sampled voltage. The source impedance (RS) on the input channels is 50 \u2126 . See Section 17.0 for more information on acquisition time consideration.\n3: On the next Q4 cycle of the device clock.\n4: The time of the A/D clock period is dependent on the device frequency and the TAD clock divider.",
    "23.0 DC AND AC CHARACTERISTICS GRAPHS AND TABLES\nNote:\nThe graphs and tables provided following this note are a statistical summary based on a limited number of samples and are provided for informational purposes only. The performance characteristics listed herein are not  tested  or  guaranteed.  In  some  graphs  or  tables,  the  data  presented  may  be  outside  the  specified operating range (e.g., outside specified power supply range) and therefore, outside the warranted range.\n'Typical' represents the mean of the distribution at 25 C. 'Maximum' or 'minimum' represents (mean + 3 \u00b0 \u03c3 ) or (mean - 3 \u03c3 ) respectively, where \u03c3 is a standard deviation, over the whole temperature range.",
    "FIGURE 23-3: TYPICAL IDD vs. FOSC OVER VDD (HS/PLL MODE)\nFIGURE 23-4: MAXIMUM IDD vs. FOSC OVER VDD (HS/PLL MODE)\nFIGURE 23-5: TYPICAL IDD vs. FOSC OVER VDD (XT MODE)\nFIGURE 23-6: MAXIMUM IDD vs. FOSC OVER VDD (XT MODE)",
    "PIC18FXX2\nFIGURE 23-7: TYPICAL IDD vs. FOSC OVER VDD (LP MODE)\nFIGURE 23-8: MAXIMUM IDD vs. FOSC OVER VDD (LP MODE)",
    "FIGURE 23-9: TYPICAL IDD vs. FOSC OVER VDD (EC MODE)\nFIGURE 23-10: MAXIMUM IDD vs. FOSC OVER VDD (EC MODE)",
    "PIC18FXX2\nFIGURE 23-11: TYPICAL AND MAXIMUM IDD vs. VDD (TIMER1 AS MAIN OSCILLATOR, 32.768 kHz, C1 AND C2 = 47 pF)\nFIGURE 23-12: AVERAGE FOSC vs. VDD FOR VARIOUS VALUES OF R (RC MODE, C = 20 pF, +25 C) \u00b0\nFIGURE 23-13: AVERAGE FOSC vs. VDD FOR VARIOUS VALUES OF R (RC MODE, C = 100 pF, +25 C) \u00b0\nFIGURE 23-14: AVERAGE FOSC vs. VDD FOR VARIOUS VALUES OF R (RC MODE, C = 300 pF, +25 C) \u00b0\nFIGURE 23-15: IPD vs. VDD, -40 C TO +125 C (SLEEP MODE, ALL PERIPHERALS DISABLED) \u00b0 \u00b0\nFIGURE 23-16: \u2206 IBOR vs. VDD OVER TEMPERATURE (BOR ENABLED, VBOR = 2.00 - 2.16V)\nFIGURE 23-19: TYPICAL, MINIMUM AND MAXIMUM WDT PERIOD vs. VDD (-40 C TO +125 C) \u00b0 \u00b0",
    "PIC18FXX2\nFIGURE 23-20: \u2206 ILVD vs. VDD OVER TEMPERATURE (LVD ENABLED, VLVD = 4.5 - 4.78V)\nFIGURE 23-22: TYPICAL, MINIMUM AND MAXIMUM VOH vs. IOH (VDD = 3V, -40 C TO +125 C) \u00b0 \u00b0\nFIGURE 23-23: TYPICAL AND MAXIMUM VOL vs. IOL (VDD = 5V, -40 C TO +125 C) \u00b0 \u00b0\nFIGURE 23-24: TYPICAL AND MAXIMUM VOL vs. IOL (VDD = 3V, -40 C TO +125 C) \u00b0 \u00b0\nFIGURE 23-25: MINIMUM AND MAXIMUM VIN vs. VDD (ST INPUT, -40 C TO +125 C) \u00b0 \u00b0\nFIGURE 23-26: MINIMUM AND MAXIMUM VIN vs. VDD (TTL INPUT, -40 C TO +125 C) \u00b0 \u00b0\nFIGURE 23-27: MINIMUM AND MAXIMUM VIN vs. VDD (I 2 C INPUT, -40 C TO +125 C) \u00b0 \u00b0\nFIGURE 23-28: A/D NON-LINEARITY vs. VREFH (VDD = VREFH, -40 C TO +125 C) \u00b0 \u00b0\nNOTES:",
    "Legend:\nXX...X\nCustomer-specific information\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week '01')\nNNN\nAlphanumeric traceability code\nPb-free JEDEC designator for Matte Tin (Sn)\n*\nThis package is Pb-free. The Pb-free JEDEC designator (     ) 3 e\ncan be found on the outer packaging for this package.",
    "Note :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.\n3\ne",
    "24.2 Package Details\nThe following sections give the technical details of the packages.",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\nNumber of Pins, Units.Dimension Limits = n. Number of Pins, INCHES *.MIN = 28. Number of Pins, INCHES *.NOM = 28. Number of Pins, INCHES *.MAX = 28. Number of Pins, MILLIMETERS.MIN = 28. Number of Pins, MILLIMETERS.NOM = 28. Number of Pins, MILLIMETERS.MAX = 28. Pitch, Units.Dimension Limits = p. Pitch, INCHES *.MIN = . Pitch, INCHES *.NOM = .100. Pitch, INCHES *.MAX = . Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 2.54. Pitch, MILLIMETERS.MAX = . Top to Seating Plane, Units.Dimension Limits = A. Top to Seating Plane, INCHES *.MIN = .140. Top to Seating Plane, INCHES *.NOM = .150. Top to Seating Plane, INCHES *.MAX = .160. Top to Seating Plane, MILLIMETERS.MIN = 3.56. Top to Seating Plane, MILLIMETERS.NOM = 3.81. Top to Seating Plane, MILLIMETERS.MAX =",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\n4.06. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, INCHES *.MIN = .125. Molded Package Thickness, INCHES *.NOM = .130. Molded Package Thickness, INCHES *.MAX = .135. Molded Package Thickness, MILLIMETERS.MIN = 3.18. Molded Package Thickness, MILLIMETERS.NOM = 3.30. Molded Package Thickness, MILLIMETERS.MAX = 3.43. Base to Seating Plane, Units.Dimension Limits = A1. Base to Seating Plane, INCHES *.MIN = .015. Base to Seating Plane, INCHES *.NOM = . Base to Seating Plane, INCHES *.MAX = . Base to Seating Plane, MILLIMETERS.MIN = 0.38. Base to Seating Plane, MILLIMETERS.NOM = . Base to Seating Plane, MILLIMETERS.MAX = . Shoulder to Shoulder Width, Units.Dimension Limits = E. Shoulder to Shoulder Width, INCHES *.MIN = .300. Shoulder to Shoulder Width, INCHES *.NOM = .310. Shoulder to Shoulder Width, INCHES *.MAX = .325. Shoulder to Shoulder Width,",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\nMILLIMETERS.MIN = 7.62. Shoulder to Shoulder Width, MILLIMETERS.NOM = 7.87. Shoulder to Shoulder Width, MILLIMETERS.MAX = 8.26. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, INCHES *.MIN = .275. Molded Package Width, INCHES *.NOM = .285. Molded Package Width, INCHES *.MAX = .295. Molded Package Width, MILLIMETERS.MIN = 6.99. Molded Package Width, MILLIMETERS.NOM = 7.24. Molded Package Width, MILLIMETERS.MAX = 7.49. Overall Length, Units.Dimension Limits = D. Overall Length, INCHES *.MIN = 1.345. Overall Length, INCHES *.NOM = 1.365. Overall Length, INCHES *.MAX = 1.385. Overall Length, MILLIMETERS.MIN = 34.16. Overall Length, MILLIMETERS.NOM = 34.67. Overall Length, MILLIMETERS.MAX = 35.18. Tip to Seating Plane, Units.Dimension Limits = L. Tip to Seating Plane, INCHES *.MIN = .125.",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\nTip to Seating Plane, INCHES *.NOM = .130. Tip to Seating Plane, INCHES *.MAX = .135. Tip to Seating Plane, MILLIMETERS.MIN = 3.18. Tip to Seating Plane, MILLIMETERS.NOM = 3.30. Tip to Seating Plane, MILLIMETERS.MAX = 3.43. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, INCHES *.MIN = .008. Lead Thickness, INCHES *.NOM = .012. Lead Thickness, INCHES *.MAX = .015. Lead Thickness, MILLIMETERS.MIN = 0.20. Lead Thickness, MILLIMETERS.NOM = 0.29. Lead Thickness, MILLIMETERS.MAX = 0.38. Upper Lead Width, Units.Dimension Limits = B1. Upper Lead Width, INCHES *.MIN = .040. Upper Lead Width, INCHES *.NOM = .053. Upper Lead Width, INCHES *.MAX = .065. Upper Lead Width, MILLIMETERS.MIN = 1.02. Upper Lead Width, MILLIMETERS.NOM = 1.33. Upper Lead Width,",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\nMILLIMETERS.MAX = 1.65. Lower Lead Width, Units.Dimension Limits = B. Lower Lead Width, INCHES *.MIN = .016. Lower Lead Width, INCHES *.NOM = .019. Lower Lead Width, INCHES *.MAX = .022. Lower Lead Width, MILLIMETERS.MIN = 0.41. Lower Lead Width, MILLIMETERS.NOM = 0.48. Lower Lead Width, MILLIMETERS.MAX = 0.56. Overall Row Spacing, Units.Dimension Limits = \u00a7. Overall Row Spacing, INCHES *.MIN = .320 eB. Overall Row Spacing, INCHES *.NOM = .350. Overall Row Spacing, INCHES *.MAX = .430. Overall Row Spacing, MILLIMETERS.MIN = 8.13. Overall Row Spacing, MILLIMETERS.NOM = 8.89. Overall Row Spacing, MILLIMETERS.MAX = 10.92. Mold Draft Angle Top, Units.Dimension Limits = . Mold Draft Angle Top, INCHES *.MIN = 5 \u03b1. Mold Draft Angle Top, INCHES *.NOM = 10. Mold Draft",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\nAngle Top, INCHES *.MAX = 15. Mold Draft Angle Top, MILLIMETERS.MIN = 5. Mold Draft Angle Top, MILLIMETERS.NOM = 10. Mold Draft Angle Top, MILLIMETERS.MAX = 15. Mold Draft Angle Bottom, Units.Dimension Limits = . Mold Draft Angle Bottom, INCHES *.MIN = 5 \u03b2. Mold Draft Angle Bottom, INCHES *.NOM = 10. Mold Draft Angle Bottom, INCHES *.MAX = 15. Mold Draft Angle Bottom, MILLIMETERS.MIN = 5. Mold Draft Angle Bottom, MILLIMETERS.NOM = 10. Mold Draft Angle Bottom, MILLIMETERS.MAX = 15\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimension D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side.\nJEDEC Equivalent:  MO-095\nDrawing No. C04-070",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\nPitch, Dimension Limits.n = p. Pitch, INCHES *.MIN.28 = . Pitch, INCHES *.NOM.28 = .050. Pitch, INCHES *.MAX.28 = . Pitch, MILLIMETERS.MIN.28 = . Pitch, MILLIMETERS.NOM.28 = 1.27. Pitch, MILLIMETERS.MAX.28 = . Overall Height, Dimension Limits.n = A. Overall Height, INCHES *.MIN.28 = .093. Overall Height, INCHES *.NOM.28 = .099. Overall Height, INCHES *.MAX.28 = .104. Overall Height, MILLIMETERS.MIN.28 = 2.36. Overall Height, MILLIMETERS.NOM.28 = 2.50. Overall Height, MILLIMETERS.MAX.28 = 2.64. Molded Package Thickness, Dimension Limits.n = A2. Molded Package Thickness, INCHES *.MIN.28 = .088. Molded Package Thickness, INCHES *.NOM.28 = .091. Molded Package Thickness, INCHES *.MAX.28 = .094. Molded Package Thickness,",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\nMILLIMETERS.MIN.28 = 2.24. Molded Package Thickness, MILLIMETERS.NOM.28 = 2.31. Molded Package Thickness, MILLIMETERS.MAX.28 = 2.39. Standoff, Dimension Limits.n = . Standoff, INCHES *.MIN.28 = .004 A1. Standoff, INCHES *.NOM.28 = .008. Standoff, INCHES *.MAX.28 = .012. Standoff, MILLIMETERS.MIN.28 = 0.10. Standoff, MILLIMETERS.NOM.28 = 0.20. Standoff, MILLIMETERS.MAX.28 = 0.30. Overall Width, Dimension Limits.n = E. Overall Width, INCHES *.MIN.28 = .394. Overall Width, INCHES *.NOM.28 = .407. Overall Width, INCHES *.MAX.28 = .420. Overall Width, MILLIMETERS.MIN.28 = 10.01. Overall Width, MILLIMETERS.NOM.28 = 10.34. Overall Width, MILLIMETERS.MAX.28 = 10.67. Molded Package Width, Dimension",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\nLimits.n = E1. Molded Package Width, INCHES *.MIN.28 = .288. Molded Package Width, INCHES *.NOM.28 = .295. Molded Package Width, INCHES *.MAX.28 = .299. Molded Package Width, MILLIMETERS.MIN.28 = 7.32. Molded Package Width, MILLIMETERS.NOM.28 = 7.49. Molded Package Width, MILLIMETERS.MAX.28 = 7.59. Overall Length, Dimension Limits.n = D. Overall Length, INCHES *.MIN.28 = .695. Overall Length, INCHES *.NOM.28 = .704. Overall Length, INCHES *.MAX.28 = .712. Overall Length, MILLIMETERS.MIN.28 = 17.65. Overall Length, MILLIMETERS.NOM.28 = 17.87. Overall Length, MILLIMETERS.MAX.28 = 18.08. Chamfer Distance, Dimension Limits.n = h. Chamfer Distance, INCHES *.MIN.28 = .010. Chamfer Distance, INCHES *.NOM.28 = .020.",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\nChamfer Distance, INCHES *.MAX.28 = .029. Chamfer Distance, MILLIMETERS.MIN.28 = 0.25. Chamfer Distance, MILLIMETERS.NOM.28 = 0.50. Chamfer Distance, MILLIMETERS.MAX.28 = 0.74. Foot Length, Dimension Limits.n = L. Foot Length, INCHES *.MIN.28 = .016. Foot Length, INCHES *.NOM.28 = .033. Foot Length, INCHES *.MAX.28 = .050. Foot Length, MILLIMETERS.MIN.28 = 0.41. Foot Length, MILLIMETERS.NOM.28 = 0.84. Foot Length, MILLIMETERS.MAX.28 = 1.27. Foot Angle Top, Dimension Limits.n = \u03c6. Foot Angle Top, INCHES *.MIN.28 = 0. Foot Angle Top, INCHES *.NOM.28 = 4. Foot Angle Top, INCHES *.MAX.28 = 8. Foot Angle Top, MILLIMETERS.MIN.28 = 0. Foot Angle Top, MILLIMETERS.NOM.28 =",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\n4. Foot Angle Top, MILLIMETERS.MAX.28 = 8. Lead Thickness, Dimension Limits.n = c. Lead Thickness, INCHES *.MIN.28 = .009. Lead Thickness, INCHES *.NOM.28 = .011. Lead Thickness, INCHES *.MAX.28 = .013. Lead Thickness, MILLIMETERS.MIN.28 = 0.23. Lead Thickness, MILLIMETERS.NOM.28 = 0.28. Lead Thickness, MILLIMETERS.MAX.28 = 0.33. Lead Width, Dimension Limits.n = . Lead Width, INCHES *.MIN.28 = .014 B. Lead Width, INCHES *.NOM.28 = .017. Lead Width, INCHES *.MAX.28 = .020. Lead Width, MILLIMETERS.MIN.28 = 0.36. Lead Width, MILLIMETERS.NOM.28 = 0.42. Lead Width, MILLIMETERS.MAX.28 = 0.51. Mold Draft Angle Top, Dimension Limits.n = \u03b1. Mold Draft Angle Top, INCHES *.MIN.28 = 0. Mold Draft Angle",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\nTop, INCHES *.NOM.28 = 12. Mold Draft Angle Top, INCHES *.MAX.28 = 15. Mold Draft Angle Top, MILLIMETERS.MIN.28 = 0. Mold Draft Angle Top, MILLIMETERS.NOM.28 = 12. Mold Draft Angle Top, MILLIMETERS.MAX.28 = 15. Mold Draft Angle Bottom, Dimension Limits.n = \u03b2. Mold Draft Angle Bottom, INCHES *.MIN.28 = 0. Mold Draft Angle Bottom, INCHES *.NOM.28 = 12. Mold Draft Angle Bottom, INCHES *.MAX.28 = 15. Mold Draft Angle Bottom, MILLIMETERS.MIN.28 = 0. Mold Draft Angle Bottom, MILLIMETERS.NOM.28 = 12. Mold Draft Angle Bottom, MILLIMETERS.MAX.28 = 15\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side.\nJEDEC Equivalent:  MS-013\nDrawing No. C04-052",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\nPitch, Dimension Limits.n = p. Pitch, INCHES *.MIN.40 = . Pitch, INCHES *.NOM.40 = .100. Pitch, INCHES *.MAX.40 = . Pitch, MILLIMETERS.MIN.40 = . Pitch, MILLIMETERS.NOM.40 = 2.54. Pitch, MILLIMETERS.MAX.40 = . Top to Seating Plane, Dimension Limits.n = A. Top to Seating Plane, INCHES *.MIN.40 = .160. Top to Seating Plane, INCHES *.NOM.40 = .175. Top to Seating Plane, INCHES *.MAX.40 = .190. Top to Seating Plane, MILLIMETERS.MIN.40 = 4.06. Top to Seating Plane, MILLIMETERS.NOM.40 = 4.45. Top to Seating Plane, MILLIMETERS.MAX.40 = 4.83. Molded Package Thickness, Dimension Limits.n = A2. Molded Package Thickness, INCHES *.MIN.40 = .140. Molded Package Thickness, INCHES *.NOM.40 = .150. Molded Package Thickness, INCHES *.MAX.40 = .160.",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\nMolded Package Thickness, MILLIMETERS.MIN.40 = 3.56. Molded Package Thickness, MILLIMETERS.NOM.40 = 3.81. Molded Package Thickness, MILLIMETERS.MAX.40 = 4.06. Base to Seating Plane, Dimension Limits.n = A1. Base to Seating Plane, INCHES *.MIN.40 = .015. Base to Seating Plane, INCHES *.NOM.40 = . Base to Seating Plane, INCHES *.MAX.40 = . Base to Seating Plane, MILLIMETERS.MIN.40 = 0.38. Base to Seating Plane, MILLIMETERS.NOM.40 = . Base to Seating Plane, MILLIMETERS.MAX.40 = . Shoulder to Shoulder Width, Dimension Limits.n = E. Shoulder to Shoulder Width, INCHES *.MIN.40 = .595. Shoulder to Shoulder Width, INCHES *.NOM.40 = .600. Shoulder to Shoulder Width, INCHES *.MAX.40 = .625. Shoulder to Shoulder Width, MILLIMETERS.MIN.40 = 15.11. Shoulder to Shoulder Width, MILLIMETERS.NOM.40 = 15.24. Shoulder",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\nto Shoulder Width, MILLIMETERS.MAX.40 = 15.88. Molded Package Width, Dimension Limits.n = E1. Molded Package Width, INCHES *.MIN.40 = .530. Molded Package Width, INCHES *.NOM.40 = .545. Molded Package Width, INCHES *.MAX.40 = .560. Molded Package Width, MILLIMETERS.MIN.40 = 13.46. Molded Package Width, MILLIMETERS.NOM.40 = 13.84. Molded Package Width, MILLIMETERS.MAX.40 = 14.22. Overall Length, Dimension Limits.n = D. Overall Length, INCHES *.MIN.40 = 2.045. Overall Length, INCHES *.NOM.40 = 2.058. Overall Length, INCHES *.MAX.40 = 2.065. Overall Length, MILLIMETERS.MIN.40 = 51.94. Overall Length, MILLIMETERS.NOM.40 = 52.26. Overall Length, MILLIMETERS.MAX.40 = 52.45. Tip to Seating Plane, Dimension Limits.n = L. Tip to Seating Plane, INCHES",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\n*.MIN.40 = .120. Tip to Seating Plane, INCHES *.NOM.40 = .130. Tip to Seating Plane, INCHES *.MAX.40 = .135. Tip to Seating Plane, MILLIMETERS.MIN.40 = 3.05. Tip to Seating Plane, MILLIMETERS.NOM.40 = 3.30. Tip to Seating Plane, MILLIMETERS.MAX.40 = 3.43. Lead Thickness, Dimension Limits.n = c. Lead Thickness, INCHES *.MIN.40 = .008. Lead Thickness, INCHES *.NOM.40 = .012. Lead Thickness, INCHES *.MAX.40 = .015. Lead Thickness, MILLIMETERS.MIN.40 = 0.20. Lead Thickness, MILLIMETERS.NOM.40 = 0.29. Lead Thickness, MILLIMETERS.MAX.40 = 0.38. Upper Lead Width, Dimension Limits.n = B1. Upper Lead Width, INCHES *.MIN.40 = .030. Upper Lead Width, INCHES *.NOM.40 = .050. Upper Lead Width, INCHES *.MAX.40 =",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\n.070. Upper Lead Width, MILLIMETERS.MIN.40 = 0.76. Upper Lead Width, MILLIMETERS.NOM.40 = 1.27. Upper Lead Width, MILLIMETERS.MAX.40 = 1.78. Lower Lead Width, Dimension Limits.n = B. Lower Lead Width, INCHES *.MIN.40 = .014. Lower Lead Width, INCHES *.NOM.40 = .018. Lower Lead Width, INCHES *.MAX.40 = .022. Lower Lead Width, MILLIMETERS.MIN.40 = 0.36. Lower Lead Width, MILLIMETERS.NOM.40 = 0.46. Lower Lead Width, MILLIMETERS.MAX.40 = 0.56. Overall Row Spacing, Dimension Limits.n = eB. Overall Row Spacing, INCHES *.MIN.40 = .620. Overall Row Spacing, INCHES *.NOM.40 = .650. Overall Row Spacing, INCHES *.MAX.40 = .680. Overall Row Spacing, MILLIMETERS.MIN.40 = 15.75. Overall Row Spacing,",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\nMILLIMETERS.NOM.40 = 16.51. Overall Row Spacing, MILLIMETERS.MAX.40 = 17.27. Mold Draft Angle Top, Dimension Limits.n = \u03b1. Mold Draft Angle Top, INCHES *.MIN.40 = 5. Mold Draft Angle Top, INCHES *.NOM.40 = 10. Mold Draft Angle Top, INCHES *.MAX.40 = 15. Mold Draft Angle Top, MILLIMETERS.MIN.40 = 5. Mold Draft Angle Top, MILLIMETERS.NOM.40 = 10. Mold Draft Angle Top, MILLIMETERS.MAX.40 = 15. Mold Draft Angle Bottom, Dimension Limits.n = \u03b2. Mold Draft Angle Bottom, INCHES *.MIN.40 = 5. Mold Draft Angle Bottom, INCHES *.NOM.40 = 10. Mold Draft Angle Bottom, INCHES *.MAX.40 = 15. Mold Draft Angle Bottom, MILLIMETERS.MIN.40 = 5. Mold Draft Angle Bottom, MILLIMETERS.NOM.40 = 10. Mold Draft Angle Bottom, MILLIMETERS.MAX.40 = 15\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side.\nJEDEC Equivalent:  MO-011\nDrawing No. C04-016",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nFor the most current package drawings, please see the Microchip Packaging Specification located at\nNote: http://www.microchip.com/packaging",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNumber of Pins, Units.Dimension Limits = n. Number of Pins, INCHES.MIN = 44. Number of Pins, INCHES.NOM = 44. Number of Pins, INCHES.MAX = 44. Number of Pins, MILLIMETERS *.MIN = . Number of Pins, MILLIMETERS *.NOM = 44. Number of Pins, MILLIMETERS *.MAX = 44. Pitch, Units.Dimension Limits = p. Pitch, INCHES.MIN = .031. Pitch, INCHES.NOM = .031. Pitch, INCHES.MAX = .031. Pitch, MILLIMETERS *.MIN = . Pitch, MILLIMETERS *.NOM = 0.80. Pitch, MILLIMETERS *.MAX = 0.80. Pins per Side, Units.Dimension Limits = n1. Pins per Side, INCHES.MIN = 11. Pins per Side, INCHES.NOM = 11. Pins per Side, INCHES.MAX = 11. Pins per Side, MILLIMETERS *.MIN = . Pins per Side, MILLIMETERS *.NOM = 11. Pins per Side,",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nMILLIMETERS *.MAX = 11. Overall Height, Units.Dimension Limits = A. Overall Height, INCHES.MIN = .039. Overall Height, INCHES.NOM = .043. Overall Height, INCHES.MAX = .047. Overall Height, MILLIMETERS *.MIN = 1.00. Overall Height, MILLIMETERS *.NOM = 1.10. Overall Height, MILLIMETERS *.MAX = 1.20. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, INCHES.MIN = .037. Molded Package Thickness, INCHES.NOM = .039. Molded Package Thickness, INCHES.MAX = .041. Molded Package Thickness, MILLIMETERS *.MIN = 0.95. Molded Package Thickness, MILLIMETERS *.NOM = 1.00. Molded Package Thickness, MILLIMETERS *.MAX = 1.05. Standoff, Units.Dimension Limits = A1. Standoff, INCHES.MIN = .002. Standoff, INCHES.NOM = .004. Standoff, INCHES.MAX =",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n.006. Standoff, MILLIMETERS *.MIN = 0.05. Standoff, MILLIMETERS *.NOM = 0.10. Standoff, MILLIMETERS *.MAX = 0.15. Foot Length, Units.Dimension Limits = L. Foot Length, INCHES.MIN = .018. Foot Length, INCHES.NOM = .024. Foot Length, INCHES.MAX = .030. Foot Length, MILLIMETERS *.MIN = 0.45. Foot Length, MILLIMETERS *.NOM = 0.60. Foot Length, MILLIMETERS *.MAX = 0.75. Footprint (Reference), Units.Dimension Limits = F. Footprint (Reference), INCHES.MIN = .039 REF.. Footprint (Reference), INCHES.NOM = .039 REF.. Footprint (Reference), INCHES.MAX = .039 REF.. Footprint (Reference), MILLIMETERS *.MIN = 1.00 REF.. Footprint (Reference), MILLIMETERS *.NOM = 1.00 REF.. Footprint",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n(Reference), MILLIMETERS *.MAX = 1.00 REF.. Foot Angle, Units.Dimension Limits = \u03c6. Foot Angle, INCHES.MIN = 0. Foot Angle, INCHES.NOM = 3.5. Foot Angle, INCHES.MAX = 7. Foot Angle, MILLIMETERS *.MIN = 0. Foot Angle, MILLIMETERS *.NOM = 3.5. Foot Angle, MILLIMETERS *.MAX = 7. Overall Width, Units.Dimension Limits = E. Overall Width, INCHES.MIN = .463. Overall Width, INCHES.NOM = .472. Overall Width, INCHES.MAX = .482. Overall Width, MILLIMETERS *.MIN = 11.75. Overall Width, MILLIMETERS *.NOM = 12.00. Overall Width, MILLIMETERS *.MAX = 12.25. Overall Length, Units.Dimension Limits = D. Overall Length, INCHES.MIN = .463. Overall Length, INCHES.NOM = .472. Overall Length, INCHES.MAX = .482. Overall Length,",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nMILLIMETERS *.MIN = 11.75. Overall Length, MILLIMETERS *.NOM = 12.00. Overall Length, MILLIMETERS *.MAX = 12.25. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, INCHES.MIN = .390. Molded Package Width, INCHES.NOM = .394. Molded Package Width, INCHES.MAX = .398. Molded Package Width, MILLIMETERS *.MIN = 9.90. Molded Package Width, MILLIMETERS *.NOM = 10.00. Molded Package Width, MILLIMETERS *.MAX = 10.10. Molded Package Length, Units.Dimension Limits = D1. Molded Package Length, INCHES.MIN = .390. Molded Package Length, INCHES.NOM = .394. Molded Package Length, INCHES.MAX = .398. Molded Package Length, MILLIMETERS *.MIN = 9.90. Molded Package Length, MILLIMETERS *.NOM = 10.00. Molded Package Length, MILLIMETERS *.MAX = 10.10. Lead Thickness,",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nUnits.Dimension Limits = c. Lead Thickness, INCHES.MIN = .004. Lead Thickness, INCHES.NOM = .006. Lead Thickness, INCHES.MAX = .008. Lead Thickness, MILLIMETERS *.MIN = 0.09. Lead Thickness, MILLIMETERS *.NOM = 0.15. Lead Thickness, MILLIMETERS *.MAX = 0.20. Lead Width, Units.Dimension Limits = B. Lead Width, INCHES.MIN = .012. Lead Width, INCHES.NOM = .015. Lead Width, INCHES.MAX = .017. Lead Width, MILLIMETERS *.MIN = 0.30. Lead Width, MILLIMETERS *.NOM = 0.38. Lead Width, MILLIMETERS *.MAX = 0.44. Pin 1 Corner Chamfer, Units.Dimension Limits = CH. Pin 1 Corner Chamfer, INCHES.MIN = .025. Pin 1 Corner Chamfer, INCHES.NOM = .035. Pin 1 Corner Chamfer, INCHES.MAX =",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n.045. Pin 1 Corner Chamfer, MILLIMETERS *.MIN = 0.64. Pin 1 Corner Chamfer, MILLIMETERS *.NOM = 0.89. Pin 1 Corner Chamfer, MILLIMETERS *.MAX = 1.14. Mold Draft Angle Top, Units.Dimension Limits = \u03b1. Mold Draft Angle Top, INCHES.MIN = 5. Mold Draft Angle Top, INCHES.NOM = 10. Mold Draft Angle Top, INCHES.MAX = 15. Mold Draft Angle Top, MILLIMETERS *.MIN = 5. Mold Draft Angle Top, MILLIMETERS *.NOM = 10. Mold Draft Angle Top, MILLIMETERS *.MAX = 15. Mold Draft Angle Bottom, Units.Dimension Limits = \u03b2. Mold Draft Angle Bottom, INCHES.MIN = 5. Mold Draft Angle Bottom, INCHES.NOM = 10. Mold Draft Angle Bottom, INCHES.MAX = 15. Mold Draft Angle Bottom, MILLIMETERS *.MIN = 5. Mold Draft Angle Bottom, MILLIMETERS *.NOM = 10. Mold Draft Angle Bottom, MILLIMETERS",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n*.MAX = 15\n- * Controlling Parameter",
    "Notes:\nDimensions D and E1 do not include mold flash or protrusions.  Mold flash or protrusions shall not exceed .010\" (0.254mm) per side.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nSee ASME Y14.5M\nJEDEC Equivalent:  MS-026\nDrawing No. C04-076\nRevised 07-22-05",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nn Number of Pins, INCHES *.Dimension Limits = n Number of Pins. n Number of Pins, INCHES *.NOM = 44. n Number of Pins, INCHES *.MAX = 44. n Number of Pins, MILLIMETERS.MIN = 44. n Number of Pins, MILLIMETERS.NOM = 44. n Number of Pins, MILLIMETERS.MAX = 44. p Pitch, INCHES *.Dimension Limits = p Pitch. p Pitch, INCHES *.NOM = .050. p Pitch, INCHES *.MAX = .050. p Pitch, MILLIMETERS.MIN = 1.27. p Pitch, MILLIMETERS.NOM = 1.27. p Pitch, MILLIMETERS.MAX = 1.27. n1 Pins per Side, INCHES *.Dimension Limits = n1 Pins per Side. n1 Pins per Side, INCHES *.NOM = 11. n1 Pins per Side, INCHES *.MAX = 11. n1 Pins per Side, MILLIMETERS.MIN = 11. n1 Pins per Side, MILLIMETERS.NOM = 11. n1 Pins per Side, MILLIMETERS.MAX = 11. Overall Height, INCHES",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n*.Dimension Limits = Overall Height. Overall Height, INCHES *.NOM = .173 .165. Overall Height, INCHES *.MAX = .180. Overall Height, MILLIMETERS.MIN = 4.19. Overall Height, MILLIMETERS.NOM = 4.39. Overall Height, MILLIMETERS.MAX = 4.57. Molded Package Thickness, INCHES *.Dimension Limits = Molded Package Thickness. Molded Package Thickness, INCHES *.NOM = .145 .153. Molded Package Thickness, INCHES *.MAX = .160. Molded Package Thickness, MILLIMETERS.MIN = 3.68. Molded Package Thickness, MILLIMETERS.NOM = 3.87. Molded Package Thickness, MILLIMETERS.MAX = 4.06. Standoff, INCHES *.Dimension Limits = Standoff. Standoff, INCHES *.NOM = .020. Standoff, INCHES *.MAX = .028 .035. Standoff, MILLIMETERS.MIN = 0.51. Standoff, MILLIMETERS.NOM = 0.71. Standoff, MILLIMETERS.MAX = 0.89. Side 1 Chamfer Height, INCHES *.Dimension",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nLimits = Side 1 Chamfer Height. Side 1 Chamfer Height, INCHES *.NOM = .024. Side 1 Chamfer Height, INCHES *.MAX = .034 .029. Side 1 Chamfer Height, MILLIMETERS.MIN = 0.61. Side 1 Chamfer Height, MILLIMETERS.NOM = 0.74. Side 1 Chamfer Height, MILLIMETERS.MAX = 0.86. Corner Chamfer 1, INCHES *.Dimension Limits = Corner Chamfer 1. Corner Chamfer 1, INCHES *.NOM = .040. Corner Chamfer 1, INCHES *.MAX = .050 .045. Corner Chamfer 1, MILLIMETERS.MIN = 1.02. Corner Chamfer 1, MILLIMETERS.NOM = 1.14. Corner Chamfer 1, MILLIMETERS.MAX = 1.27. Corner Chamfer (others), INCHES *.Dimension Limits = Corner Chamfer (others). Corner Chamfer (others), INCHES *.NOM = .000. Corner Chamfer (others), INCHES",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n*.MAX = .010 .005. Corner Chamfer (others), MILLIMETERS.MIN = 0.00. Corner Chamfer (others), MILLIMETERS.NOM = 0.13. Corner Chamfer (others), MILLIMETERS.MAX = 0.25. Overall Width, INCHES *.Dimension Limits = Overall Width. Overall Width, INCHES *.NOM = .685. Overall Width, INCHES *.MAX = .695 .690. Overall Width, MILLIMETERS.MIN = 17.40. Overall Width, MILLIMETERS.NOM = 17.53. Overall Width, MILLIMETERS.MAX = 17.65. Overall Length, INCHES *.Dimension Limits = Overall Length. Overall Length, INCHES *.NOM = .685. Overall Length, INCHES *.MAX = .695 .690. Overall Length, MILLIMETERS.MIN = 17.40. Overall Length, MILLIMETERS.NOM = 17.53. Overall Length, MILLIMETERS.MAX = 17.65. Molded Package Width, INCHES *.Dimension Limits = Molded Package Width. Molded Package Width, INCHES *.NOM =",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n.650. Molded Package Width, INCHES *.MAX = .656 .653. Molded Package Width, MILLIMETERS.MIN = 16.51. Molded Package Width, MILLIMETERS.NOM = 16.59. Molded Package Width, MILLIMETERS.MAX = 16.66. Molded Package Length, INCHES *.Dimension Limits = Molded Package Length. Molded Package Length, INCHES *.NOM = .650. Molded Package Length, INCHES *.MAX = .656 .653. Molded Package Length, MILLIMETERS.MIN = 16.51. Molded Package Length, MILLIMETERS.NOM = 16.59. Molded Package Length, MILLIMETERS.MAX = 16.66. Footprint Width, INCHES *.Dimension Limits = Footprint Width. Footprint Width, INCHES *.NOM = .590. Footprint Width, INCHES *.MAX = .630 .620. Footprint Width, MILLIMETERS.MIN = 14.99. Footprint Width, MILLIMETERS.NOM = 15.75. Footprint Width, MILLIMETERS.MAX = 16.00. Footprint Length, INCHES *.Dimension Limits = Footprint Length. Footprint Length, INCHES *.NOM =",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n.590. Footprint Length, INCHES *.MAX = .630 .620. Footprint Length, MILLIMETERS.MIN = 14.99. Footprint Length, MILLIMETERS.NOM = 15.75. Footprint Length, MILLIMETERS.MAX = 16.00. Lead Thickness, INCHES *.Dimension Limits = Lead Thickness. Lead Thickness, INCHES *.NOM = .008. Lead Thickness, INCHES *.MAX = .013 .011. Lead Thickness, MILLIMETERS.MIN = 0.20. Lead Thickness, MILLIMETERS.NOM = 0.27. Lead Thickness, MILLIMETERS.MAX = 0.33. Upper Lead Width, INCHES *.Dimension Limits = Upper Lead Width. Upper Lead Width, INCHES *.NOM = .026. Upper Lead Width, INCHES *.MAX = .032 .029. Upper Lead Width, MILLIMETERS.MIN = 0.66. Upper Lead Width, MILLIMETERS.NOM = 0.74. Upper Lead Width, MILLIMETERS.MAX = 0.81. Lower Lead Width, INCHES *.Dimension Limits = Lower Lead Width. Lower Lead Width, INCHES *.NOM =",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n.013. Lower Lead Width, INCHES *.MAX = .021 .020. Lower Lead Width, MILLIMETERS.MIN = 0.33. Lower Lead Width, MILLIMETERS.NOM = 0.51. Lower Lead Width, MILLIMETERS.MAX = 0.53. Mold Draft Angle Top, INCHES *.Dimension Limits = Mold Draft Angle Top. Mold Draft Angle Top, INCHES *.NOM = 0. Mold Draft Angle Top, INCHES *.MAX = 10 5. Mold Draft Angle Top, MILLIMETERS.MIN = 0. Mold Draft Angle Top, MILLIMETERS.NOM = 5. Mold Draft Angle Top, MILLIMETERS.MAX = 10. Mold Draft Angle Bottom, INCHES *.Dimension Limits = Mold Draft Angle Bottom. Mold Draft Angle Bottom, INCHES *.NOM = 0. Mold Draft Angle Bottom, INCHES *.MAX = 10 5. Mold Draft Angle Bottom, MILLIMETERS.MIN = 0. Mold Draft Angle Bottom, MILLIMETERS.NOM = 5. Mold Draft Angle Bottom, MILLIMETERS.MAX = 10\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side. JEDEC Equivalent:  MO-047\nDrawing No. C04-048",
    "PIC18FXX2\nNOTES:",
    "Revision A (June 2001)\nOriginal data sheet for the PIC18FXX2 family.",
    "Revision B (August 2002)\nThis revision includes the DC and AC Characteristics Graphs  and  Tables.  The  Electrical  Specifications  in Section 22.0 have been updated and there have been minor corrections to the data sheet text.",
    "Revision C (October 2006)\nPackaging diagrams updated.",
    "TABLE B-1: DEVICE DIFFERENCES\nProgram Memory (Kbytes), PIC18F242 = 16. Program Memory (Kbytes), PIC18F252 = 32. Program Memory (Kbytes), PIC18F442 = 16. Program Memory (Kbytes), PIC18F452 = 32. Data Memory (Bytes), PIC18F242 = 768. Data Memory (Bytes), PIC18F252 = 1536. Data Memory (Bytes), PIC18F442 = 768. Data Memory (Bytes), PIC18F452 = 1536. A/D Channels, PIC18F242 = 5. A/D Channels, PIC18F252 = 5. A/D Channels, PIC18F442 = 8. A/D Channels, PIC18F452 = 8. Parallel Slave Port (PSP), PIC18F242 = No. Parallel Slave Port (PSP), PIC18F252 = No. Parallel Slave Port (PSP), PIC18F442 = Yes. Parallel Slave Port (PSP), PIC18F452 = Yes. Package Types, PIC18F242 =",
    "TABLE B-1: DEVICE DIFFERENCES\n28-pin DIP 28-pin SOIC. Package Types, PIC18F252 = 28-pin DIP 28-pin SOIC. Package Types, PIC18F442 = 40-pin DIP 44-pin PLCC 44-pin TQFP. Package Types, PIC18F452 = 40-pin DIP 44-pin PLCC 44-pin TQFP",
    "APPENDIX B: DEVICE DIFFERENCES\nThe differences between the devices listed in this data sheet are shown in Table B-1.",
    "APPENDIX C: CONVERSION CONSIDERATIONS\nThis  appendix  discusses  the  considerations  for  converting from previous versions of a device to the ones listed in this data sheet. Typically, these changes are due to the differences in the process technology used. An  example  of  this  type  of  conversion  is  from  a PIC16C74A to a PIC16C74B.\nNot Applicable\nAPPENDIX D:\nMIGRATION FROM BASELINE TO ENHANCED DEVICES\nThis section discusses how to migrate from a Baseline device (i.e., PIC16C5X) to an Enhanced MCU device (i.e., PIC18FXXX).\nThe  following  are  the  list  of  modifications  over  the PIC16C5X microcontroller family:\nNot Currently Available",
    "APPENDIX E: MIGRATION FROM MID-RANGE TO ENHANCED DEVICES\nA detailed  discussion of the  differences between  the mid-range  MCU  devices  (i.e.,  PIC16CXXX)  and  the enhanced  devices  (i.e.,  PIC18FXXX)  is  provided  in AN716,  'Migrating  Designs  from  PIC16C74A/74B  to PIC18F442'.  The  changes  discussed,  while  device specific,  are  generally  applicable  to  all  mid-range  to enhanced device migrations.\nThis Application Note is available as Literature Number DS00716.",
    "APPENDIX F: MIGRATION FROM HIGH-END TO ENHANCED DEVICES\nA detailed discussion of the migration pathway and differences  between  the  high-end  MCU  devices  (i.e., PIC17CXXX) and the enhanced devices (i.e., PIC18FXXX)  is  provided  in  AN726,  'PIC17CXXX  to PIC18FXXX Migration'. This Application Note is available as Literature Number DS00726.",
    "PIC18FXX2\nNOTES:",
    "A\nA/D ..................................................................................., 1 = 181. A/D Converter Flag (ADIF Bit) ................................., 1 = 183. A/D Converter Interrupt, Configuring, 1 = ....................... 184. Acquisition Requirements ........................................, 1 = 184. ADCON0 Register",
    "A\n...................................................., 1 = 181. ADCON1 Register, 1 = .................................................... 181. ADRESH Register, 1 = .................................................... 181. ADRESH/ADRESL Registers, 1 = .................................. 183. ADRESL Register, 1 =",
    "A\n.................................................... 181. Analog Port Pins, 1 = ................................................ 99 , 100. Analog Port Pins, Configuring, 1 = .................................. 186. Associated Registers, 1 = ............................................... 188. Configuring the Module, 1 =",
    "A\n............................................ 184. Conversion Clock (TAD) ..........................................., 1 = 186. Conversion Status (GO/DONE Bit), 1 = .......................... 183. Conversions, 1 = ............................................................. 187. Converter Characteristics ........................................, 1 = 287. Equations,",
    "A\n1 = . Acquisition Time ..............................................., 1 = 185. Minimum Charging Time, 1 = .................................. 185. Examples, 1 = . Calculating the Minimum Required Acquisition Time, 1 = ...................................... 185. Result Registers ......................................................., 1 = 187. Special Event Trigger (CCP) ............................, 1 = 120 ,",
    "A\n188. TAD vs. Device Operating Frequencies ...................., 1 = 186. Use of the CCP2 Trigger .........................................., 1 = 188. Absolute Maximum Ratings ............................................., 1 = 259. AC (Timing) Characteristics, 1 = ............................................. 269. Load Conditions for Device Timing, 1 = 270. Specifications",
    "A\n................................................... Parameter Symbology, 1 = ............................................. 269. Temperature and Voltage Specifications - AC, 1 = ......... 270. Timing Conditions ...................................................., 1 = 270. ACKSTAT Status Flag, 1 = ..................................................... 155. ADCON0 Register, 1 =",
    "A\n............................................................ 181. GO/DONE Bit, 1 = ........................................................... 183. ADCON1 Register, 1 = ............................................................ 181. ADDLW, 1 =",
    "A\n............................................................................ 217. ADDWF, 1 = ............................................................................ 217. ADDWFC ........................................................................., 1 = 218 181. ADRESH Register",
    "A\n............................................................ ADRESH/ADRESL Registers ..........................................., 1 = 183. ADRESL Register, 1 = ............................................................ 181. Analog-to-Digital Converter. See A/D, 1 = . ANDLW, 1 =",
    "A\n............................................................................ 218. ANDWF ............................................................................, 1 = 219. Assembler, 1 = . MPASM Assembler, 1 = .................................................. 253. B, 1 = . Baud Rate Generator, 1 = 151.",
    "A\n....................................................... BC ...................................................................................., 1 = 219. BCF .................................................................................., 1 = 220",
    "A\nBlock Diagrams A/D Converter, 1 = 183. Analog Input Model, 1 = .................................................. 184. Baud Rate Generator, 1 = .............................................. 151. Capture Mode Operation, 1 = ......................................... 119. Compare Mode Operation, 1 = ....................................... 120. Low Voltage Detect, 1 = 190. External Reference Source Internal Reference Source, 1 =",
    "A\n.............................. MSSP, 1 = ............................... 190. MSSP (SPI Mode), 1 = ................................................... 125. On-Chip Reset Circuit, 1 = ................................................ 25. Parallel Slave Port (PORTD and PORTE), 1 = ............... 100. PIC18F2X2, 1 =",
    "A\n.................................................................. 8. PIC18F4X2, 1 = .................................................................. 9. PLL ............................................................................, 1 = 19. PORTC (Peripheral Output Override), 1 =",
    "A\n........................ 93. PORTD (I/O Mode), 1 = .................................................... 95. PORTE (I/O Mode), 1 = .................................................... 97. PWM Operation (Simplified), 1 = .................................... 122. RA3:RA0 and RA5 Port Pins, 1 = ..................................... 87.",
    "A\nRA4/T0CKI Pin .........................................................., 1 = 88. RA6 Pin ....................................................................., 1 = 88. RB2:RB0 Port, 1 = .................................................... 91. Pins RB3 Pin, 1 =",
    "A\n..................................................................... 91. RB7:RB4 Port Pins, 1 = .................................................... 90. Table Read Operation, 1 = ............................................... 55. Table Write Operation ................................................, 1 = 56. Table Writes to FLASH Program Memory",
    "A\n.............................................., 1 = ................. 61. Timer0 in 16-bit Mode, 1 = 104. Timer0 in 8-bit Mode ................................................, 1 = 104. Timer1, 1 = ..................................................................... 108. Timer2",
    "A\n....................................................................., 1 = 112. Timer3, 1 = . ..................................................................... Timer3 (16-bit R/W Mode), 1 = 114. USART, 1 = ....................................... 114. Asynchronous Receive, 1 =",
    "A\n.................................... 174 172. Watchdog Timer ...................................................................................., 1 = ...................................................... 204. BN",
    "A\n................................................................................., 1 = 220. BNC, 1 = 221 221. BNOV ..............................................................................., 1 = 222. BNZ, 1 = 222.",
    "A\n.................................................................................. BOR. See Brown-out Reset, 1 = . BOV ................................................................................. BRA",
    "A\n................................................................................., 1 = 225. BRG. See Baud Rate, 1 = . , 1 = 223. Generator Brown-out Reset (BOR) ..................................................... BSF .................................................................................., 1 = 26 223 224.",
    "A\nBTFSC ............................................................................. BTFSS ............................................................................., 1 = 224. BTG, 1 = 225. ................................................................................. Bus Collision",
    "A\nDuring a STOP, 1 = . Condition BZ ...................................................................................., 1 = .......................... 163 226",
    "C\nCALL, 1 = ................................................................................ 226. Capture (CCP Module), 1 = ..................................................... 119. Associated Registers, 1 = ............................................... 121. CCP Pin Configuration ............................................., 1",
    "C\n= 119. CCPR1H:CCPR1L Registers, 1 = ................................... 119. Software Interrupt ....................................................., 1 = 119. Timer1/Timer3 Mode Selection, 1 = ................................ 119. Capture/Compare/PWM (CCP), 1 = 117. ........................................ Capture Mode. See Capture CCP1, 1 =",
    "C\n........................................................................ 118. CCPR1H Register, 1 = ............................................ 118. CCPR1L Register, 1 = ............................................ 118. CCP2",
    "C\n........................................................................, 1 = 118. CCPR2H Register, 1 = ............................................ 118. CCPR2L Register Compare Mode. See, 1 = ............................................ 118. Compare Interaction of Two CCP Modules PWM Mode. See PWM, 1 = ............................. 118. Timer Resources",
    "C\n......................................................, 1 = 118. Clocking Scheme/Instruction Cycle, 1 = .................................... 39. CLRF ................................................................................, 1 = 227. CLRWDT, 1 =",
    "C\n.......................................................................... 227. Code, 1 = . Examples 16 x 16 Signed Multiply, 1 = Routine ................................. 72 ............................. 72. 8 x 8 Signed Multiply Routine ....................................., 1 = 71. 8 x 8 Unsigned Multiply Routine, 1 = ................................. 71. Changing Between Capture",
    "C\nPrescalers, 1 = ................... 119. Data EEPROM Read ................................................., 1 = 67. Data EEPROM Refresh Routine, 1 = ................................ 68 67. Data EEPROM Write .................................................., 1 = ................... Erasing a FLASH Program Memory Row, 1 = 60. Fast Register Stack",
    "C\n.................................................... (Bank1) Using, 1 = 39 ............................................ 50. How to Clear RAM Indirect Addressing Initializing PORTA ......................................................, 1 = 87 90. Initializing PORTB, 1 = ......................................................",
    "C\n...................................................... 93. Initializing PORTC, 1 = . Initializing PORTD, 1 = ...................................................... 95. , 1 = 97. Initializing PORTE ...................................................... Loading the SSPBUF (SSPSR) Register, 1 = 128. ................. Reading a FLASH Program Memory Word Saving STATUS, WREG and BSR",
    "C\n..............................................., 1 = ................ 59 85. Registers in RAM Writing to FLASH Program Memory ....................., 1 = 62 - 63 195. Protection ..............................................................., 1 = . Code COMF",
    "C\n..............................................................................., 1 = 228. Compare (CCP Module) ..................................................., 1 = 120. Associated Registers, 1 = ............................................... 121 120. CCP Pin Configuration",
    "C\n......................................................., 1 = ............................................. 120. CCPR1 Register, 1 = . Software Interrupt Special Event, 1 = 120 120 , 188. ..................................................... Trigger ........................109, 1 = , 115 , ................................. Timer1/Timer3 Mode Selection, 1 = 120.",
    "C\nConfiguration Bits ............................................................., 1 = 195 ....................................... 85. Context Saving During Interrupts .............................................., 1 = 314. Conversion Considerations .........................................................................., 1 = 228. CPFSEQ, 1 = 229.",
    "C\nCPFSGT, 1 = ........................................................................... ........................................................................... 229. CPFSLT, 1 = ",
    "D\nData EEPROM Memory",
    "D\nAssociated, 1 = Registers ................................................. 69. EEADR Register, 1 = ........................................................ 65. EECON1 Register, 1 = ...................................................... 65. EECON2 Register, 1 = ...................................................... 65. Operation During Code Protect, 1 =",
    "D\n................................. 68. Protection Against Spurious Write, 1 = ............................. 68. Reading, 1 = ..................................................................... 67. Using, 1 = .......................................................................... 68. Write Verify, 1 =",
    "D\n................................................................ 68. Writing, 1 = ........................................................................ 67. Data Memory, 1 = ..................................................................... 42. General Purpose Registers, 1 =",
    "D\n....................................... 42. Map for PIC18F242/442, 1 = ............................................ 43. Map for PIC18F252/452, 1 = ............................................ 44. Special Function Registers, 1 = ........................................ 42. DAW, 1 =",
    "D\n................................................................................ 230. DC and AC Characteristics, 1 = . Graphs and Tables, 1 = .................................................. 289. DC Characteristics, 1 = ....................................................261 , 265",
    "D\n.......................................................................... 231. DECF, 1 = ............................................................................... 230. DECFSZ, 1 = .......................................................................... 231. Development Support, 1 = . Device Differences",
    "D\n..........................................................., 1 = ...................................................... 253 313. , 1 = ................................................................... Device Overview, 1 = 7. Features",
    "D\n......................................................................., 1 = 7. Direct Addressing, 1 = ............................................................... 51. Example, 1 = ..................................................................... 49",
    "E\nElectrical Characteristics .................................................. 259\nErrata ................................................................................... 5",
    "F\nFirmware Instructions ....................................................... 211\nFLASH Program Memory ................................................... 55\nAssociated Registers ................................................. 63\nControl Registers ....................................................... 56",
    "F\nErase Sequence ........................................................ 60\nErasing ....................................................................... 60\nOperation During Code Protect\n................................. 63\nReading ..................................................................... 59",
    "F\nTABLAT Register ....................................................... 58\nTable Pointer\n............................................................. 58\nBoundaries Based on Operation ........................ 58\nTable Pointer Boundaries .......................................... 58\nTable Reads and Table Writes .................................. 55\nBlock Diagrams\nReads from FLASH Program Memory ....... 59",
    "F\nWriting to .................................................................... 61\nProtection Against Spurious Writes ................... 63\nUnexpected Termination .................................... 63\nWrite Verify ........................................................ 63",
    "G\nGeneral Call Address Support ......................................... 148\nGOTO .............................................................................. 232",
    "I\nI 2 C (MSSP Module), ............................................................................. 87 = . ACK Pulse, ............................................................................. 87 = ................................................................ 139. Read/Write Bit Information (R/W Bit),",
    "I\n............................................................................. 87 = ....................... 139. I 2 C (SSP Module), ............................................................................. 87 = . ACK Pulse,",
    "I\n............................................................................. 87 = ................................................................ 138. I 2 C Master Mode Reception, ............................................................................. 87 =",
    "I\n............................................. 155. I 2 C Mode, ............................................................................. 87 = . Clock Stretching .......................................................,",
    "I\n............................................................................. 87 = 144. I 2 C Mode (MSSP Module) ................................................, ............................................................................. 87 = 134 134. Registers 2 C Module,",
    "I\n............................................................................. 87 = ................................................................... , ............................................................................. 87 = 138. ACK Pulse,",
    "I\n............................................................................. 87 = ........................................................ , 139. Acknowledge Sequence Timing, ............................................................................. 87 = ............................... 158.",
    "I\nBaud Rate Generator, ............................................................................. 87 = ............................................... 151. Bus Collision, ............................................................................. 87 = . Repeated START Condition,",
    "I\n............................................................................. 87 = ............................ 162. START Condition ............................................., ............................................................................. 87 = 160. Clock Arbitration,",
    "I\n............................................................................. 87 = ....................................................... 152. Effect of a RESET, ............................................................................. 87 =",
    "I\n.................................................... 159. General Call Address Support, ............................................................................. 87 = ................................. 148. Master Mode, ............................................................................. 87 =",
    "I\n............................................................ 149. Operation, ............................................................................. 87 = ......................................................... 150. Repeated START Condition Timing,",
    "I\n............................................................................. 87 = ................. 154. Master Mode START Condition, ............................................................................. 87 = ............................... 153. Master Mode Transmission",
    "I\n......................................, ............................................................................. 87 = 155. and Arbitration .................................................., ............................................................................. 87 = 159.",
    "I\nMulti-Master Mode, ............................................................................. 87 = ................................................... 159. Operation, ............................................................................. 87 = 138.",
    "I\n................................................................. Read/Write Bit Information (R/W Bit), ............................................................................. 87 = ............... 138 , 139. Serial Clock (RC3/SCK/SCL),",
    "I\n............................................................................. 87 = ................................... 139. Slave Mode ..............................................................,",
    "I\n............................................................................. 87 = 138. Addressing, ............................................................................. 87 = ....................................................... 138. Reception",
    "I\n........................................................., ............................................................................. 87 = 139. Transmission .................................................... Slave Mode Timing (10-bit Reception,,",
    "I\n............................................................................. 87 = 139. SEN = 0) .........................................................., ............................................................................. 87 = 142. Slave Mode Timing (10-bit Reception, SEN = 1)",
    "I\n.........................................................., ............................................................................. 87 = 147. Slave Mode Timing (10-bit Transmission) Slave Mode Timing (7-bit Reception,, ............................................................................. 87 = ................ 143",
    "I\n140. SEN = 0) .......................................................... Slave Mode Timing (7-bit Reception,, ............................................................................. 87 = . SEN = 1) ..........................................................,",
    "I\n............................................................................. 87 = 146. Slave Mode Timing (7-bit Transmission), ............................................................................. 87 = .................. 141. SLEEP Operation .....................................................,",
    "I\n............................................................................. 87 = 159. STOP Condition Timing, ............................................................................. 87 = ........................................... 158. ICEPIC In-Circuit Emulator",
    "I\n............................................................., ............................................................................. 87 = .............................................. 254 195 , 210. ID Locations INCF",
    "I\n................................................................................., ............................................................................. 87 = 232. INCFSZ, ............................................................................. 87 =",
    "I\n............................................................................ 233. In-Circuit Debugger, ............................................................................. 87 = 210. .......................................................... In-Circuit Serial Programming (ICSP),",
    "I\n............................................................................. 87 = ...................... 195 , 210. Indirect Addressing ............................................................, ............................................................................. 87 = 51. INDF and FSR",
    "I\nRegisters, ............................................................................. 87 = 50. Indirect Addressing Operation, ............................................................................. 87 = ........................................... ............................................ 51.",
    "I\nIndirect File Operand, ............................................................................. 87 = .......................................................... 42. INFSNZ ............................................................................,",
    "I\n............................................................................. 87 = 233. Instruction Cycle, ............................................................................. 87 = ................................................................. 39. Instruction Flow/Pipelining Instruction Format",
    "I\n............................................................, ............................................................................. 87 = ................................................. 40 213",
    "I\nInstruction Set, 1 = .................................................................. 211. ADDLW, 1 = .................................................................... 217. ADDWF, 1 = .................................................................... 217. ADDWFC, 1 =",
    "I\n................................................................. 218. ANDLW ...................................................................., 1 = 218. ANDWF, 1 = .................................................................... 219. BC, 1 = 219.",
    "I\n............................................................................ BCF, 1 = ......................................................................... 220. BN, 1 = ............................................................................ 220. BNC, 1 =",
    "I\n......................................................................... 221. BNN, 1 = ......................................................................... 221. BNOV, 1 = ...................................................................... 222. BNZ, 1 =",
    "I\n......................................................................... 222. BOV, 1 = ......................................................................... 225. BRA, 1 = ......................................................................... 223. BSF, 1 =",
    "I\n.......................................................................... 223. BTFSC, 1 = ..................................................................... 224. BTFSS, 1 = ..................................................................... 224. BTG, 1 =",
    "I\n......................................................................... 225. BZ, 1 = ............................................................................ 226. CALL, 1 = ........................................................................ 226. CLRF",
    "I\n......................................................................., 1 = 227. CLRWDT, 1 = ................................................................. 227. COMF ......................................................................, 1 = 228. CPFSEQ, 1 =",
    "I\n.................................................................. 228 229. CPFSGT CPFSLT, 1 = .................................................................. ................................................................... 229. DAW",
    "I\n........................................................................, 1 = 230. DCFSNZ, 1 = .................................................................. 231. DECF ......................................................................., 1 = 230. DECFSZ, 1 =",
    "I\n.................................................................. 231. INCF ........................................................................, 1 = 232. GOTO, 1 = ...................................................................... 232",
    "I\n.................................................................... 233. INCFSZ, 1 = . INFSNZ, 1 = .................................................................... 233. IORLW, 1 = ..................................................................... 234. IORWF, 1 =",
    "I\n..................................................................... 234. LFSR, 1 = ....................................................................... 235. MOVF, 1 = ...................................................................... 235. MOVFF MOVLB, 1 =",
    "I\n.................................................................... 236 .................................................................... 236. MOVLW, 1 = ................................................................... 237. MOVWF, 1 =",
    "I\n................................................................... 237. MULLW, 1 = .................................................................... 238 ..................................................................... MULWF, 1 = 238. NEGF, 1 =",
    "I\n....................................................................... 239. NOP, 1 = ......................................................................... 239 240. POP ........................................................................., 1 =",
    "I\n....................................................................... 240. PUSH, 1 = ..................................................................... 241 ..................................................................... 241. RCALL, 1 = . RESET RETFIE, 1 =",
    "I\n.................................................................... 242. RETLW, 1 = .................................................................... 242. RETURN, 1 = .................................................................. 243. RLCF",
    "I\n......................................................................., 1 = 243. RLNCF, 1 = ..................................................................... ........................................................................ RRCF, 1 = 244 244. RRNCF, 1 =",
    "I\n.................................................................... 245 245. SETF, 1 = . ....................................................................... SLEEP, 1 = ...................................................................... , 1 = 246",
    "I\n................................................................. 246. SUBFWB SUBLW, 1 = .................................................................... 247. SUBWF ...................................................................., 1 = 247 248. , 1 =",
    "I\n.................................................................. SUBWFB ...................................................................., 1 = . SWAPF, 1 = 248",
    "PIC18FXX2\nTBLRD, 1 = ..................................................................... 249. TBLWT, 1 = ..................................................................... 250. TSTFSZ, 1 = .................................................................... 251. XORLW, 1 =",
    "PIC18FXX2\n.................................................................... 251. XORWF, 1 = .................................................................... 252. Summary Table, 1 = ........................................................ 214. Instructions in Program Memory, 1 =",
    "PIC18FXX2\n........................................ 40. Two-Word Instructions, 1 = ............................................... 41. INT Interrupt (RB0/INT). See Interrupt Sources INTCON Register, 1 = . RBIF Bit, 1 = ...................................................................... 90. INTCON Registers",
    "PIC18FXX2\n......................................................., 1 = 75 - 77. Inter-Integrated Circuit. See I 2 C, 1 = . Interrupt Sources, 1 = .............................................................. 195. A/D Conversion Complete, 1 = ........................................ 184. Capture Complete (CCP), 1 = ......................................... 119. Compare Complete",
    "PIC18FXX2\n(CCP), 1 = ....................................... 120. INT0 ..........................................................................., 1 = 85. Interrupt-on-Change (RB7:RB4 ), 1 = ............................... 90. PORTB, Interrupt-on-Change, 1 = .................................... 85. RB0/INT Pin, External, 1 =",
    "PIC18FXX2\n................................................ 85. TMR0 ........................................................................., 1 = 85. TMR0 Overflow, 1 = ........................................................ 105. TMR1 Overflow TMR2 to PR2 Match, 1 =",
    "PIC18FXX2\n................................................ 107 , 109. TMR2 to PR2 Match (PWM), 1 = ................................................. 112 ............................ 111 , 122. TMR3 Overflow ................................................, 1 = 113 , 115. USART Receive/Transmit Complete, 1 = ........................ 165. Interrupts, 1 =",
    "PIC18FXX2\n............................................................................ 73. Logic, 1 = ........................................................................... 74. Interrupts, Enable Bits CCP1 Enable (CCP1IE, 1 = Bit) ...................................... 119. Interrupts, Flag Bits, 1 = . A/D Converter Flag (ADIF Bit), 1 =",
    "PIC18FXX2\n.................................. 183. CCP1 Flag (CCP1IF Bit), 1 = .......................................... 119. CCP1IF Flag (CCP1IF Bit), 1 = ....................................... 120. Interrupt-on-Change (RB7:RB4) Flag, 1 = . (RBIF Bit), 1 = ........................................................... 90. IORLW, 1 =",
    "PIC18FXX2\n............................................................................. 234. IORWF ............................................................................., 1 = 234. IPR Registers, 1 = ............................................................... 82 - 83. K, 1 = . KEELOQ Evaluation and Programming Tools,",
    "PIC18FXX2\n1 = ................... 256. L, 1 = . LFSR ................................................................................, 1 = 235. Lookup Tables, 1 = . Computed GOTO, 1 = ....................................................... 41. Table Reads, Table Writes, 1 = ......................................... 41. Low Voltage Detect, 1 =",
    "PIC18FXX2\n.......................................................... 189. Converter Characteristics, 1 = ......................................... 267. Effects of a RESET, 1 = .................................................. 193. Operation, 1 = ................................................................. 192. Current Consumption, 1 =",
    "PIC18FXX2\n....................................... 193. During SLEEP .................................................., 1 = 193. Reference Voltage Set Point ..................................................., 1 = ............................ 193. Typical Application LVD. See Low Voltage Detect., 1 = 189 ......................................... 189",
    "M\nMaster SSP (MSSP) Module Overview ........................... Master Synchronous Serial Port (MSSP). See MSSP., 1 = 125. Master Synchronous Serial Port. See MSSP Memory Organization, 1 = . Data Memory, 1 = ............................................................. 42. Program Memory, 1 = ....................................................... 35. Memory Programming Requirements, 1 = .............................. 268. Migration from Baseline to Enhanced Devices, 1 =",
    "M\n................ 314. Migration from High-End to Enhanced Devices, 1 = ............... 315. Migration from Mid-Range to Enhanced Devices, 1 = ............ 315. MOVF, 1 = .............................................................................. 235. MOVFF, 1 = ............................................................................ 236. MOVLB, 1 =",
    "M\n............................................................................ 236. MOVLW, 1 = ........................................................................... 237. MOVWF, 1 = ........................................................................... 237. MPLAB C17 and MPLAB C18",
    "M\nC Compilers, 1 = ..................... 253. MPLAB ICD In-Circuit Debugger ....................................., 1 = 255. MPLAB ICE High Performance Universal In-Circuit, 1 = ....................................... 254. Emulator with MPLAB IDE MPLAB Integrated Development Environment Software ............................................., 1 = 253. MPLINK Object Linker/MPLIB Object Librarian, 1 = ............... 254. MSSP",
    "M\n..............................................................................., 1 = 125. Control Registers (general), 1 = ...................................... 125. Enabling SPI I/O, 1 = ...................................................... 129. Operation",
    "M\n................................................................., 1 = 128. Typical Connection, 1 = .................................................. 129. MSSP Module, 1 = . SPI Master Mode, 1 = ..................................................... 130. SPI Master./Slave Connection, 1 = ................................. 129. SPI Slave Mode, 1 =",
    "M\n....................................................... 131. MULLW, 1 = ............................................................................ 238. MULWF, 1 = ............................................................................ 238. N, 1 = . NEGF, 1 =",
    "M\n............................................................................... 239. NOP, 1 = ................................................................................. 239. O, 1 = . Opcode Field Descriptions, 1 = ............................................... 212. PSA Bit",
    "M\n...................................................................., 1 = 105. T0CS Bit .................................................................. T0PS2:T0PS0 Bits, 1 = 105 105. , 1 = .................................................... T0SE Bit",
    "M\n..................................................................., 1 = 105 ...................................................... 17. EC, 1 = .............................................................................. 17. ECIO, 1 =",
    "M\n.......................................................................... 17. HS, 1 = 17. .............................................................................., 1 = . HS + PLL, 1 = ................................................................... 17",
    "M\n.............................................................................. 17. RC .............................................................................., 1 = 17. RCIO, 1 = .......................................................................... 17. XT",
    "M\n.............................................................................., 1 = 17 195. Oscillator Selection ..............................................107, 1 = .......................................................... , 115. Oscillator, Timer1, 1 = , 109. Oscillator, Timer3 Oscillator, WDT",
    "M\n................................................................, 1 = ............................................................. 113 203",
    "P\nPackaging, 1 = ........................................................................ 305. Details, 1 = ...................................................................... 307. Marking Information, 1 = ................................................. 305. Parallel Slave Port, 1 = . PORTD, 1 =",
    "P\n.................................................................... 100. Parallel Slave Port (PSP), 1 = ........................................... 95 , 100. Associated Registers, 1 = ............................................... 101 ,. RE0/RD/AN5 Pin, 1 = ................................................ 99 100. RE1/WR/AN6 Pin, 1 =",
    "P\n............................................... 99 , 100. RE2/CS/AN7 Pin ................................................, 1 = 99 , 100. Select (PSPMODE Bit), 1 = ...................................... 95 , 100. PIC18F2X2 Pin Functions, 1 = . MCLR/VPP, 1 = .................................................................. 10.",
    "P\nOSC1/CLKI, 1 = ................................................................ 10. OSC2/CLKO/RA6, 1 = ...................................................... 10. RA0/AN0, 1 = .................................................................... 10. RA1/AN1, 1 =",
    "P\n.................................................................... 10. RA2/AN2/VREF-, 1 = .......................................................... 10. RA3/AN3/VREF+, 1 = ......................................................... 10. RA4/T0CKI, 1 =",
    "P\n................................................................. 10. RA5/AN4/SS/LVDIN, 1 = ................................................... 10. RB0/INT0, 1 = ................................................................... 11. RB1/INT1, 1 =",
    "P\n................................................................... 11. RB2/INT2, 1 = ................................................................... 11. RB3/CCP2, 1 = ................................................................. 11. RB4, 1 =",
    "P\n............................................................................ 11. RB5/PGM, 1 = ................................................................... 11. RB6/PGC, 1 = ................................................................... 11. RB7/PGD",
    "P\n................................................................... RC0/T1OSO/T1CKI, 1 = 11 12. RC1/T1OSI/CCP2, 1 = ...................................................... 12. RC2/CCP1 ................................................................., 1 = 12. RC3/SCK/SCL, 1 =",
    "P\n........................................................... 12. RC4/SDI/SDA, 1 = ............................................................ 12. RC5/SDO, 1 = ................................................................... 12. RC6/TX/CK, 1 = 12. RC7/RX/DT, 1 =",
    "P\n................................................................ ................................................................ 12. VDD, 1 = ............................................................................. 12. VSS, 1 = 12.",
    "P\n............................................................................. PIC18F4X2 Pin Functions, 1 = . MCLR/VPP, 1 = .................................................................. 13. OSC1/CLKI, 1 = ................................................................ 13. OSC2/CLKO, 1 =",
    "P\n.............................................................. 13. RA0/AN0, 1 = .................................................................... 13. RA1/AN1, 1 = .................................................................... 13. RA2/AN2/VREF-, 1 =",
    "P\n.......................................................... 13. RA3/AN3/VREF+, 1 = ......................................................... 13. RA4/T0CKI ................................................................., 1 = 13",
    "P\n................................................... 13. RA5/AN4/SS/LVDIN RB0/INT ....................................................................., 1 = . , 1 = 14. RB1, 1 = ............................................................................ 14. RB2, 1 =",
    "P\n............................................................................ 14 ............................................................................ 14. RB3, 1 = 14. RB4 ............................................................................ RB5/PGM, 1 =",
    "P\n................................................................... 14. RB6/PGC, 1 = ................................................................... 14 14. RB7/PGD ..................................................................., 1 = . RC0/T1OSO/T1CKI, 1 =",
    "P\n................................................... 15. RC1/T1OSI/CCP2, 1 = ...................................................... 15 15. RC2/CCP1 ................................................................., 1 = 15. RC3/SCK/SCL RC4/SDI/SDA, 1 =",
    "P\n........................................................... 15. RC5/SDO ..................................................................., 1 = 15. RC6/TX/CK, 1 = ................................................................ 15",
    "PIC18FXX2\nRC7/RX/DT, 1 = ................................................................ 15. RD0/PSP0, 1 = ................................................................. 16. RD1/PSP1, 1 = ................................................................. 16. RD2/PSP2, 1 =",
    "PIC18FXX2\n................................................................. 16. RD3/PSP3, 1 = ................................................................. 16. RD4/PSP4, 1 = ................................................................. 16. RD5/PSP5, 1 =",
    "PIC18FXX2\n................................................................. 16. RD6/PSP6, 1 = ................................................................. 16. RD7/PSP7, 1 = ................................................................. 16. RE0/RD/AN5, 1 =",
    "PIC18FXX2\n.............................................................. 16. RE1/WR/AN6, 1 = ............................................................. 16. RE2/CS/AN7, 1 = .............................................................. 16. VDD, 1 =",
    "PIC18FXX2\n............................................................................ 16. VSS ............................................................................, 1 = 16. PIC18FXX2 Voltage-Frequency Graph, 1 = . (Industrial) ................................................................, 1 = 260. PIC18LFXX2",
    "PIC18FXX2\nVoltage-Frequency Graph, 1 = . (Industrial) ................................................................, 1 = 260. PICDEM 1 Low Cost PICmicro, 1 = . Demonstration Board, 1 = ............................................... 255. PICDEM 17 Demonstration Board, 1 = ................................... 256. PICDEM 2 Low Cost PIC16CXX, 1 = . Demonstration Board, 1 =",
    "PIC18FXX2\n............................................... 255. PICDEM 3 Low Cost PIC16CXXX, 1 = . Demonstration Board ..............................................., 1 = 256. PICSTART Plus Entry Level Development, 1 = . Programmer, 1 = ............................................................. 255. PIE Registers, 1 =",
    "PIC18FXX2\n................................................................80 - 81. Pinout I/O Descriptions, 1 = . PIC18F2X2 ................................................................, 1 = 10. PIR Registers, 1 = ................................................................78 - 79. PLL Lock Time-out, 1 =",
    "PIC18FXX2\n............................................................. 26. Pointer, FSR, 1 = ...................................................................... 50. POP, 1 = 240. ................................................................................. POR. See Power-on Reset, 1 = . PORTA, 1 = . Associated Registers, 1 =",
    "PIC18FXX2\n................................................. 89. LATA Register, 1 = ........................................................... 87. PORTA Register, 1 = ........................................................ 87. TRISA Register, 1 = .......................................................... 87. PORTB,",
    "PIC18FXX2\n1 = . Associated Registers, 1 = ................................................. 92. LATB Register, 1 = ........................................................... 90. PORTB Register, 1 = ........................................................ 90. RB0/INT Pin, External ................................................, 1 = 85.",
    "PIC18FXX2\nRB7:RB4 Interrupt-on-Change Flag (RBIF Bit), 1 = .......... 90. TRISB Register .........................................................., 1 = 90. PORTC, 1 = . Associated Registers, 1 = ................................................. 94. LATC Register, 1 = ........................................................... 93. PORTC Register, 1 =",
    "PIC18FXX2\n........................................................ 93. RC3/SCK/SCL Pin, 1 = ................................................... 139. RC7/RX/DT Pin, 1 = ........................................................ 168. TRISC Register, 1 = ...................................................93 ,",
    "PIC18FXX2\n165. PORTD, 1 = . Associated Registers, 1 = ................................................. 96. LATD Register, 1 = ........................................................... 95. Parallel Slave Port (PSP) Function, 1 = ............................ 95. PORTD Register TRISD Register, 1 = ........................................................ 95",
    "PIC18FXX2\n.......................................................... 95\nPORTE",
    "Q\nAnalog Port Pins, 1 = ................................................ 99 , 100. Associated Registers, 1 = ................................................. 99. LATE Register ............................................................, 1 = 97. PORTE Register, 1 = ........................................................ 97. PSP Mode Select (PSPMODE Bit),",
    "Q\n1 = .................... 95 , 100. RE0/RD/AN5 Pin, 1 = ................................................ 99 , 100. RE1/WR/AN6 Pin, 1 = ............................................... 99 , 100. RE2/CS/AN7 Pin, 1 = ................................................ 99 , 100. TRISE Register, 1 =",
    "Q\n.......................................................... 97. Postscaler, WDT, 1 = . Assignment (PSA Bit), 1 = ............................................... 105. Rate Select (T0PS2:T0PS0 Bits), 1 = ............................. 105. Switching Between Timer0 and WDT, 1 = ...................... 105. Power-down Mode. See SLEEP, 1 = . Power-on Reset (POR), 1 =",
    "Q\n...................................................... 26. Oscillator Start-up Timer (OST), 1 = ................................. 26. Power-up Timer (PWRT) ............................................, 1 = 26. Prescaler, Capture, 1 = ........................................................... 119. Prescaler, Timer0, 1 =",
    "Q\n............................................................. 105. Assignment (PSA Bit), 1 = ............................................... 105. Rate Select (T0PS2:T0PS0 Bits), 1 = ............................. 105. Switching Between Timer0 and WDT, 1 = ...................... 105. Prescaler, Timer2, 1 =",
    "Q\n............................................................. 122. PRO MATE II Universal Device Programmer, 1 = ................... 255. Product Identification System, 1 = ........................................... 327. Program Counter, 1 = . PCL Register, 1 = .............................................................. 39. PCLATH Register, 1 =",
    "Q\n....................................................... 39. PCLATU Register, 1 = ....................................................... 39. Program Memory, 1 = . Interrupt Vector, 1 = .......................................................... 35. Map and Stack for PIC18F442/242, 1 = ............................ 36. Map and Stack for PIC18F452/252, 1 =",
    "Q\n............................ 36. RESET Vector, 1 = ............................................................ 35. Program Verification and Code Protection, 1 = ....................... 207. Associated Registers, 1 = ............................................... 207. Programming, Device Instructions, 1 = ................................... 211. PSP.See Parallel Slave Port., 1 = . Pulse Width Modulation. See PWM (CCP Module). PUSH",
    "Q\n..............................................................................., 1 = 240. PWM (CCP Module), 1 = ......................................................... 122. Associated Registers, 1 = ............................................... 123. CCPR1H:CCPR1L Registers, 1 =",
    "Q\n................................... 122. Duty Cycle, 1 = ................................................................ 122. Example Frequencies/Resolutions, 1 = ........................... 123. Period, 1 = ....................................................................... 122. Setup for PWM Operation, 1 =",
    "Q\n........................................ 123. TMR2 to PR2 Match ........................................., 1 = 111 , 122\nQ Clock\n............................................................................ 122",
    "R\nRAM. See Data Memory\nRC Oscillator ...................................................................... 18\nRCALL .............................................................................. 241\nRCSTA Register\nSPEN Bit .................................................................. 165",
    "R\nRegister File ....................................................................... 42\nRegisters",
    "R\nADCON0 (A/D Control 0) ........................................., 1 = 181. ADCON1 (A/D Control 1), 1 = ......................................... 182. CCP1CON and CCP2CON, 1 = . (Capture/Compare/PWM Control), 1 = ................... 117. CONFIG1H (Configuration 1 High), 1 = .......................... 196. CONFIG2H (Configuration 2 High), 1 = .......................... 197. CONFIG2L (Configuration 2 Low), 1 =",
    "R\n........................... 197. CONFIG3H (Configuration 3 High), 1 = .......................... 198. CONFIG4L (Configuration 4 Low), 1 = ........................... 198. CONFIG5H (Configuration 5 High), 1 = .......................... 199. CONFIG5L (Configuration 5 Low), 1 = ........................... 199. CONFIG6H (Configuration 6 High), 1 = .......................... 200. CONFIG6L (Configuration 6 Low), 1 =",
    "R\n........................... 200. CONFIG7H (Configuration 7 High), 1 = .......................... 201. CONFIG7L (Configuration 7 Low), 1 = ........................... 201. DEVID1 (Device ID Register 1), 1 = ............................... 202. DEVID2 (Device ID Register 2), 1 = ............................... 202. EECON1 (Data EEPROM Control 1), 1 = ....................57 , 66. File Summary",
    "R\n........................................................46, 1 = - 48. INTCON (Interrupt Control), 1 = ........................................ 75. INTCON2 (Interrupt Control 2), 1 = ................................... 76. INTCON3 (Interrupt Control 3), 1 = ................................... 77. IPR1 (Peripheral Interrupt Priority 1), 1 = ......................... 82. IPR2 (Peripheral Interrupt",
    "R\nPriority 2) ..........................................., 1 = ......................... 83. LVDCON (LVD Control), 1 = 191 .................................... 21. OSCCON (Oscillator Control) PIE1 (Peripheral Interrupt Enable 1), 1 = .......................... 80. PIE2 (Peripheral Interrupt Enable 2), 1 = .......................... 81. PIR1 (Peripheral Interrupt Request 1), 1 = ....................... 78. PIR2",
    "R\n(Peripheral Interrupt Request 2), 1 = ....................... 79. RCON (Register Control) ..........................................., 1 = 84. RCON (RESET Control), 1 = 53. ............................................ Control), 1 = ...................... RCSTA (Receive Status and SSPCON1 (MSSP Control 1), 1 = 167. I 2 C Mode ......................................................... SPI Mode",
    "R\n......................................................... SSPCON2 (MSSP Control 2), 1 = 136 127. I 2 C Mode ......................................................... SSPSTAT (MSSP Status) I 2 C Mode ........................................................., 1 = 137 135. SPI Mode",
    "R\n......................................................... STATUS ....................................................................., 1 = 126. , 1 = 52. STKPTR (Stack Pointer), 1 = ............................................ 38. T0CON (Timer0 Control), 1 = ......................................... 103. T1CON (Timer 1",
    "R\nControl), 1 = ........................................ 107. T2CON (Timer 2 Control), 1 = ........................................ 111. T3CON (Timer3 Control), 1 = ......................................... 113. TRISE ........................................................................, 1 = 98. TXSTA (Transmit Status and Control) WDTCON (Watchdog Timer Control), 1 =",
    "R\n..................... 166 203. RESET ................................................................25, 1 = ...................... 195 , 241. Brown-out Reset (BOR), 1 = 195. ........................................... MCLR Reset (During SLEEP) ...................................., 1 = 25. MCLR Reset (Normal Operation), 1 =",
    "R\n.............................. 25. Oscillator Start-up Timer (OST), 1 = ............................... 195. Power-on Reset (POR), 1 = .......................................25 , 195. , 1 = ......................................... 195. Power-up Timer (PWRT) Programmable Brown-out Reset (BOR), 1 = .................... 25. RESET Instruction",
    "R\n....................................................., 1 = 25 25. Stack Full Reset ......................................................... Stack Underflow Reset .............................................., 1 = 25. Watchdog Timer (WDT) Reset, 1 = .................................. 25",
    "R\nRETFIE, 1 = ............................................................................ 242. RETFIE, 2 = . RETLW, 1 = ............................................................................. 242. RETLW, 2 = . RETURN, 1 =",
    "R\n.......................................................................... 243. RETURN, 2 = . Revision History ..............................................................., 1 = 313. Revision History ..............................................................., 2 = . RLCF, 1 =",
    "R\n................................................................................ 243. RLCF, 2 = . RLNCF, 1 = ............................................................................. 244. RLNCF, 2 = . RRCF, 1 =",
    "R\n............................................................................... 244. RRCF, 2 = . RRNCF, 1 = ............................................................................. 245. RRNCF, 2 = ",
    "S\nSCI. See USART, 1 = . SCK SDI, 1 = .................................................................................. 125 ................................................................................... 125. SDO, 1 =",
    "S\n................................................................................. 125. Serial Clock, SCK, 1 = ............................................................. 125. Serial Communication Interface. See USART, 1 = . Serial Data In, SDI, 1 = ........................................................... 125. Serial Data Out, SDO, 1 =",
    "S\n....................................................... 125. Serial Peripheral Interface. See SPI, 1 = . SETF, 1 = ................................................................................ 245. Slave Select Synchronization, 1 = ........................................... 131. Slave Select, SS, 1 =",
    "S\n.............................................................. 125. SLEEP ...............................................................195, 1 = , 205 , 246. Software Simulator (MPLAB SIM), 1 = .................................... 254. Special Event Trigger. See Compare, 1 = . Special Features of the CPU, 1 = ............................................ 195. Configuration Registers, 1 =",
    "S\n................................... 196 - 201. Special Function Registers, 1 = ................................................ 42. Map, 1 = ............................................................................ 45. SPI, 1 = . Master Mode, 1 = ............................................................ 130. Serial Clock, 1 =",
    "S\n.............................................................. 125. Serial Data In, 1 = ........................................................... 125. Serial Data Out, 1 = ........................................................ 125. Slave Select, 1 =",
    "S\n............................................................. 125. SPI Clock, 1 = ................................................................. 130. SPI Mode, 1 = ................................................................. 125. SPI Master/Slave Connection, 1 =",
    "S\n.......................................... 129. SPI Module, 1 = . Associated Registers, 1 = ............................................... 133. Bus Mode Compatibility, 1 = ........................................... 133. Effects of a RESET .................................................., 1 = 133. Master/Slave Connection, 1 =",
    "S\n......................................... 129. Slave Mode, 1 = .............................................................. 131. Slave Select Synchronization, 1 = .................................. 131. Slave Synch Timing, 1 = ................................................. 131. SLEEP Operation",
    "S\n....................................................., 1 = 133. ...................................................................................., 1 = 125. SS SSP, 1 = . I 2 C Mode. See I 2 C, 1 = . SPI Mode ................................................................., 1 = 125. SPI Mode. See SPI, 1 = . SSPBUF",
    "S\nRegister, 1 = .................................................... 130. SSPSR Register, 1 = ...................................................... 130. TMR2 Output for Clock Shift, 1 = ............................ 111 , 112. SSPOV Status Flag, 1 = .......................................................... 155. SSPSTAT Register R/W Bit, 1 =",
    "S\n............................................................. 138 , 139. Status Bits, 1 = . Significance, 1 = . and the Initialization Condition for RCON Register ............................................., 1 = 27. SUBFWB, 1 = .......................................................................... 246. SUBLW, 1 =",
    "S\n............................................................................ 247. SUBWF, 1 = ............................................................................ 247. SUBWFB, 1 = .......................................................................... 248. SWAPF, 1 =",
    "S\n............................................................................ 248",
    "T\nTABLAT Register ..............................................................., 1 = 58. Table Pointer Operations (table), 1 = ........................................ 58. TBLPTR Register, 1 = ............................................................... 58. TBLRD",
    "T\n............................................................................., 1 = 249. TBLWT ............................................................................., 1 = 250. Time-out Sequence, 1 = ........................................................... 26. Time-out in Various Situations, 1 =",
    "T\n................................... 27. Timer0 .............................................................................., 1 = 103. 16-bit Mode Timer Reads and Writes, 1 = ...................... 105. Associated Registers ..............................................., 1 = 105. Clock Source Edge Select (T0SE Bit), 1 = ..................... 105. Clock Source Select (T0CS",
    "T\nBit), 1 = ............................... 105. Operation ................................................................., 1 = 105. Overflow Interrupt ...................................................., 1 = 105. Prescaler. See Prescaler, Timer0, 1 = . Timer1",
    "T\n.............................................................................., 1 = 107. 16-bit Read/Write Mode, 1 = ........................................... 109. Associated Registers, 1 = ............................................... 110. Operation",
    "T\n................................................................., 1 = 108. Oscillator ...........................................................107, 1 = , 109. Overflow Interrupt .............................................107, 1 = , 109. Special Event Trigger (CCP) ............................109, 1 = , 120. TMR1H Register",
    "T\n......................................................, 1 = 107. TMR1L Register ......................................................., 1 = 107. Timer2 .............................................................................. Associated Registers, 1 = 111",
    "T\n............................................... 112. Operation, 1 = 111. ................................................................. Postscaler. See Postscaler, Timer2, 1 = . PR2 Register ....................................................111 Prescaler. See Prescaler, Timer2, 1 = , 122 , 112. SSP Clock Shift",
    "T\n................................................111 TMR2 Register ........................................................., 1 = 111. TMR2 to PR2 Match Interrupt ................... 111, 1 = , 122. Timer3 .............................................................................., 1 = 113",
    "T\n................................................ Associated Registers, 1 = 115. Operation ................................................................., 1 = 114. Oscillator ...........................................................113, 1 = , 115. Overflow Interrupt .............................................113, 1 = , 115. Special Event Trigger",
    "T\n(CCP), 1 = ................................... 115. TMR3H Register ......................................................, 1 = 113 113. TMR3L Register ....................................................... Timing Diagrams, 1 = . Bus Collision, 1 = . Transmit and Acknowledge, 1 = ..................... 159. A/D Conversion",
    "T\n........................................................, 1 = 287. Acknowledge Sequence .........................................., 1 = 158. Baud Rate Generator with Clock Arbitration BRG Reset Due to SDA Arbitration During START Condition, 1 = ............ 152 ............................................. 161. Brown-out Reset (BOR), 1 = ........................................... 274. Bus Collision Start Condition (SDA",
    "T\nOnly), 1 = .............................. 160. Bus Collision During a Repeated START Condition (Case 1), 1 = .............................. 162. Bus Collision During a Repeated START Condition (Case 2) .............................. Bus Collision During a START Condition, 1 = 162. (SCL = 0) ......................................................... Bus Collision During a STOP Condition, 1 = 161. (Case 1)",
    "T\n........................................................... Bus Collision During a STOP Condition, 1 = 163. (Case 2) ........................................................... Capture/Compare/PWM (CCP1 and, 1 = 163 ............. CCP2) CLKO and I/O .........................................................., 1 = 276 272. Clock Synchronization",
    "T\n............................................., 1 = 145",
    "PIC18FXX2\nExample SPI Master Mode (CKE = 0), 1 = ..................... 278. Example SPI Master Mode (CKE = 1), 1 = ..................... 279. Example SPI Slave Mode (CKE = 0), 1 = ....................... 280. Example SPI Slave Mode (CKE = 1), 1 = ....................... 281. External Clock (All Modes except PLL), 1 = .................... 271. First START Bit Timing ............................................",
    "PIC18FXX2\n............................................................, 1 = 153. I 2 C Bus Data, 1 = 282. I 2 C Bus START/STOP Bits, 1 = ...................................... 282. I 2 C Master Mode (Reception, 7-bit Address) I 2 C Master Mode (Transmission,, 1 = ........... 157. 7 or 10-bit Address) ......................................... I 2 C Slave Mode Timing (10-bit Reception,, 1 = 156. SEN = 0)",
    "PIC18FXX2\n.......................................................... I 2 C Slave Mode Timing (10-bit Transmission), 1 = 142 ......... 143. I 2 C Slave Mode Timing (7-bit Reception, SEN = 0) .........................................................., 1 = 140. I 2 C Slave Mode Timing (7-bit Reception, SEN = 1) .................................................., 1 = , 147. I 2 C Slave Mode Timing (7-bit Transmission), 1 =",
    "PIC18FXX2\n........... 141. Low Voltage Detect .................................................., 1 = 192. Master SSP I 2 C Bus Data ........................................, 1 = 284. Master SSP I 2 C Bus START/STOP Bits, 1 = .................. 284. Parallel Slave Port (PIC18F4X2), 1 = .............................. 277. Parallel Slave Port (Read), 1 =",
    "PIC18FXX2\n........................................ 101. Parallel Slave Port (Write) ........................................, 1 = 100. PWM Output ............................................................., 1 = 122. Repeat START, 1 = 154. Condition ......................................... RESET, Watchdog Timer (WDT), Oscillator Start-up Timer (OST) and Power-up Timer (PWRT), 1 =",
    "PIC18FXX2\n................................. 273 131. Slave Synchronization .............................................. Slaver Mode General Call Address, 1 = 148. Sequence (7 or 10-bit Address Mode) .............................. Slow Rise Time (MCLR Tied to VDD) ........................., 1 = 33. SPI Mode (Master Mode) ........................................., 1 = 130. SPI Mode (Slave Mode with CKE = 0), 1 =",
    "PIC18FXX2\n..................... 132. SPI Mode (Slave Mode with CKE = 1) ..................... Stop Condition Receive or Transmit, 1 = 132 158. Mode .............. Time-out Sequence on POR w/PLL Enabled (MCLR Tied to VDD) ..........................................., 1 = 33. Time-out Sequence on Power-up, 1 = . (MCLR Not Tied to VDD) Case 1 ................................................................ Case 2",
    "PIC18FXX2\n................................................................, 1 = 32 32. Time-out Sequence on Power-up (MCLR Tied to VDD) ..........................................., 1 = 32. Timer0 and Timer1 External Clock ........................... Timing for Transition Between Timer1 and OSC1 (HS with PLL) .........................................., 1 = 275. Transition Between Timer1 and OSC1, 1 = 23. (HS, XT,",
    "PIC18FXX2\nLP) ....................................................... Transition Between Timer1 and OSC1, 1 = 22 23. (RC, EC) ............................................................, 1 = 22 173. Transition from OSC1 to Timer1 Oscillator ................ USART Asynchronous Master Transmission, 1 = ............ USART Asynchronous Master Transmission (Back to Back)",
    "PIC18FXX2\n.................................................., 1 = 173. USART Asynchronous Reception, 1 = 175. ............................ USART Synchronous Receive (Master/Slave), 1 = ......... 286. USART Synchronous Reception (Master Mode, SREN) ...................................... ........................., 1 = 178. USART Synchronous Transmission USART Synchronous Transmission, 1 = 177. (Master/Slave)",
    "PIC18FXX2\n.................................................., 1 = 286",
    "PIC18FXX2\nUSART Synchronous Transmission (Through TXEN) .............................................., 1 = 177. Wake-up from SLEEP via Interrupt, 1 = .......................... 206. Timing Diagrams Requirements, 1 = . Master SSP I 2 C Bus START/STOP Bits, 1 = .................. 284. Timing Requirements, 1 = . A/D Conversion, 1 = ........................................................ 288. Capture/Compare/PWM (CCP1 and CCP2), 1 = ............ 276. CLKO and",
    "PIC18FXX2\nI/O, 1 = .......................................................... 273. Example SPI Mode (Master Mode, CKE = 0), 1 = .......... 278. Example SPI Mode (Master Mode, CKE = 1), 1 = .......... 279. Example SPI Mode (Slave Mode, CKE = 0) ............, 1 = 280. Example SPI Slave Mode (CKE = 1) ......................., 1 = 281. External Clock",
    "PIC18FXX2\n.........................................................., 1 = 271. I 2 C Bus Data (Slave Mode), 1 = ..................................... 283. Master SSP I 2 C Bus Data, 1 = ........................................ 285. Parallel Slave Port (PIC18F4X2), 1 = ............................. 277. RESET, Watchdog Timer, Oscillator Start-up, 1 = . Brown-out Reset Requirements",
    "PIC18FXX2\n......................., 1 = 274. Timer0 and Timer1 External Clock, 1 = .......................... 275. USART Synchronous Receive ................................., 1 = 286. USART Synchronous Transmission, 1 = ........................ 286. Timing Specifications, 1 = . TRISE Register PSPMODE Bit, 1 = .....................................................95 , 100. TSTFSZ, 1 =",
    "PIC18FXX2\n........................................................................... 251. Two-Word Instructions, 1 = . Example Cases, 1 = .......................................................... 41. TXSTA Register, 1 = . BRGH Bit, 1 = ................................................................. 168",
    "U\nUniversal Synchronous Asynchronous Receiver Transmitter. See USART, 1 = . USART ............................................................................., 1 = 165. Asynchronous Mode, 1 = ................................................ 172. Associated Registers, Receive, 1 = ........................ 175. Associated Registers, Transmit, 1 = ....................... 173. Receiver, 1 =",
    "U\n.......................................................... 174. Transmitter, 1 = ....................................................... 172. Baud Rate Generator (BRG), 1 = ................................... 168. Associated Registers, 1 = ....................................... 168. Baud Rate Error, Calculating, 1 = ........................... 168. Baud",
    "U\nRate Formula .........................................., 1 = 168. Baud Rates for Asynchronous Mode (BRGH = 0) .............................................., 1 = 170. Baud Rates for Asynchronous Mode (BRGH = 1) .............................................., 1 = 171. Baud Rates for Synchronous Mode, 1 = ................. 169. High Baud Rate Select (BRGH Bit), 1 = ................. 168. Sampling, 1 =",
    "U\n.......................................................... 168. Serial Port Enable (SPEN Bit), 1 = ................................. 165. Synchronous Master Mode, 1 = ...................................... 176. Associated Registers, Reception, 1 = ..................... 178. Associated Registers, Transmit, 1 = ....................... 176. Reception, 1 =",
    "U\n........................................................ 178. Transmission, 1 = ................................................... 176. Synchronous Slave Mode, 1 = ........................................ 179. Associated Registers, Receive, 1 = ........................ 180. Associated Registers, Transmit, 1 = ....................... 179. Reception, 1 =",
    "U\n........................................................ 180. Transmission, 1 = ................................................... 179",
    "W\nWake-up from SLEEP, 1 = .............................................. 195 , 205. Using Interrupts, 1 = ........................................................ 205. Watchdog Timer (WDT) ..........................................., 1 = 195 , 203. Associated Registers, 1 = ............................................... 204. Control Register, 1 =",
    "W\n....................................................... 203. Postscaler, 1 = ........................................................ 203 , 204. Programming Considerations, 1 = .................................. 203. RC Oscillator, 1 = ............................................................ 203. Time-out Period, 1 =",
    "W\n....................................................... 203. WCOL .............................................................................. 153, 1 = WCOL .............................................................................. 153. WCOL Status Flag, 1 =",
    "W\n............................................153 , 155 , 158. WWW, On-Line Support, 1 = ....................................................... 5",
    "X\nXORLW, 1 = ............................................................................ 251. XORWF, 1 = ........................................................................... 252",
    "PIC18FXX2\nNOTES:",
    "THE MICROCHIP WEB SITE\nMicrochip provides online support via our WWW site at www.microchip.com. This web site is used as a means to make  files and  information  easily available to customers. Accessible by using your favorite Internet browser, the web site contains the following information:\nGLYPH<129> Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\nGLYPH<129> General Technical Support - Frequently Asked Questions (FAQ), technical support requests, online discussion groups, Microchip consultant program member listing\nGLYPH<129> Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "CUSTOMER CHANGE NOTIFICATION SERVICE\nMicrochip's  customer  notification  service  helps  keep customers current on Microchip products. Subscribers will receive  e-mail  notification  whenever  there  are changes,  updates,  revisions  or  errata  related  to  a specified product family or development tool of interest.\nTo register, access the Microchip web site at www.microchip.com, click on Customer Change Notification and follow the registration instructions.",
    "CUSTOMER SUPPORT\nUsers  of  Microchip  products  can  receive  assistance through several channels:\nGLYPH<129> Distributor or Representative\nGLYPH<129> Local Sales Office\nGLYPH<129> Field Application Engineer (FAE)\nGLYPH<129> Technical Support\nGLYPH<129> Development Systems Information Line\nCustomers should contact their distributor, representative  or  field  application  engineer  (FAE)  for support. Local sales offices are also available to help customers.  A  listing  of  sales  offices  and  locations  is included in the back of this document.\nTechnical support is available through the web site at: http://support.microchip.com",
    "READER RESPONSE\nIt is our intention to provide you with the best documentation possible to ensure successful use of your Microchip product.  If you wish to provide your comments on organization, clarity, subject matter, and ways in which our documentation can better serve you, please FAX your comments to the Technical Publications Manager at (480) 792-4150.\nPlease list the following information, and use this outline to provide us with your comments about this document.\nTo:\nTechnical Publications Manager\nRE:\nReader Response\nTotal Pages Sent ________\nFrom:\nName\nCompany\nAddress\nCity / State / ZIP / Country\nTelephone: (_______) _________ - _________\nApplication (optional):\nWould you like a reply?       Y         N\nDevice:  PIC18FXX2\nLiterature Number:  DS39564C\nQuestions:\nFAX: (______) _________ - _________\n1. What are the best features of this document?\n2. How does this document meet your hardware and software development needs?",
    "READER RESPONSE\n3. Do you find the organization of this document easy to follow? If not, why?\n4. What additions to the document do you think would enhance the structure and subject?\n5. What deletions from the document could be made without affecting the overall usefulness?\n6. Is there any incorrect or misleading information (what and where)?\n7. How would you improve this document?\nDS39564C-page 328",
    "PIC18FXX2 PRODUCT IDENTIFICATION SYSTEM\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.",
    "Examples:\na) PIC18LF452 - I/P 301 = Industrial temp., PDIP package, Extended VDD limits, QTP pattern #301.\nb) PIC18LF242 - I/SO = Industrial temp., SOIC package, Extended VDD limits.\nc) PIC18F442 - E/P = Extended temp., PDIP package, normal VDD limits.\nNote 1: F = LF =\nStandard Voltage range Wide Voltage Range\n2: T =\nin tape and reel - SOIC, PLCC, and TQFP packages only.",
    "Examples:\nDevice, - = PIC18FXX2 (1) , PIC18FXX2T (2) ; VDD range 4.2V to 5.5V PIC18LFXX2 (1) , PIC18LFXX2T (2) ; VDD range 2.5V to 5.5V. Device, X Temperature Range = PIC18FXX2 (1) , PIC18FXX2T (2) ; VDD range 4.2V to 5.5V PIC18LFXX2 (1) , PIC18LFXX2T (2) ; VDD range 2.5V to 5.5V. Device, /XX Package = PIC18FXX2 (1) , PIC18FXX2T (2) ; VDD range 4.2V to 5.5V PIC18LFXX2 (1) , PIC18LFXX2T (2) ; VDD range 2.5V to 5.5V. Device, XXX Pattern = PIC18FXX2 (1) , PIC18FXX2T (2) ; VDD range 4.2V to 5.5V PIC18LFXX2 (1) ,",
    "Examples:\nPIC18LFXX2T (2) ; VDD range 2.5V to 5.5V. Temperature Range, - = I E. Temperature Range, X Temperature Range = = =. Temperature Range, /XX Package = -40 \u00b0 C to +85 \u00b0 C (Industrial) -40 \u00b0 C to +125 \u00b0 C (Extended). Temperature Range, XXX Pattern = . Package, - = PT SO SP P L. Package, X Temperature Range = = = = = =. Package, /XX Package = TQFP (Thin Quad Flatpack) SOIC Skinny Plastic DIP PDIP PLCC. Package, XXX Pattern = . Pattern, - = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, X Temperature Range = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, /XX Package = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, XXX Pattern = QTP, SQTP, Code or Special Requirements (blank otherwise)",
    "AMERICAS\nCorporate Office 2355 West Chandler Blvd. Chandler, AZ  85224-6199 Tel:  480-792-7200 Fax:  480-792-7277 Technical Support: http://support.microchip.com Web Address: www.microchip.com\nAtlanta Alpharetta, GA Tel: 770-640-0034 Fax: 770-640-0307",
    "Boston\nWestborough, MA Tel: 774-760-0087 Fax: 774-760-0088\nChicago Itasca, IL Tel: 630-285-0071 Fax: 630-285-0075\nDallas Addison, TX Tel: 972-818-7423 Fax: 972-818-2924\nDetroit Farmington Hills, MI Tel: 248-538-2250 Fax: 248-538-2260\nKokomo Kokomo, IN Tel: 765-864-8360 Fax: 765-864-8387\nLos Angeles Mission Viejo, CA Tel: 949-462-9523 Fax: 949-462-9608\nSanta Clara Santa Clara, CA Tel: 408-961-6444 Fax: 408-961-6445\nToronto Mississauga, Ontario, Canada Tel: 905-673-0699 Fax:  905-673-6509",
    "ASIA/PACIFIC\nAsia Pacific Office Suites 3707-14, 37th Floor Tower 6, The Gateway Habour City, Kowloon Hong Kong Tel: 852-2401-1200 Fax: 852-2401-3431\nAustralia - Sydney Tel: 61-2-9868-6733 Fax: 61-2-9868-6755\nChina - Beijing Tel: 86-10-8528-2100 Fax: 86-10-8528-2104\nChina - Chengdu Tel: 86-28-8665-5511 Fax: 86-28-8665-7889\nChina - Fuzhou Tel: 86-591-8750-3506 Fax: 86-591-8750-3521\nChina - Hong Kong SAR Tel: 852-2401-1200 Fax: 852-2401-3431\nChina - Qingdao Tel: 86-532-8502-7355 Fax: 86-532-8502-7205\nChina - Shanghai Tel: 86-21-5407-5533 Fax: 86-21-5407-5066",
    "ASIA/PACIFIC\nChina - Shenyang Tel: 86-24-2334-2829 Fax: 86-24-2334-2393\nChina - Shenzhen Tel: 86-755-8203-2660 Fax: 86-755-8203-1760\nChina - Shunde Tel: 86-757-2839-5507 Fax: 86-757-2839-5571\nChina - Wuhan Tel: 86-27-5980-5300 Fax: 86-27-5980-5118\nChina - Xian Tel: 86-29-8833-7250 Fax: 86-29-8833-7256\nIndia - Bangalore Tel: 91-80-4182-8400 Fax: 91-80-4182-8422\nIndia - New Delhi Tel: 91-11-4160-8631 Fax: 91-11-4160-8632\nIndia - Pune Tel: 91-20-2566-1512 Fax: 91-20-2566-1513\nJapan - Yokohama Tel: 81-45-471- 6166 Fax: 81-45-471-6122",
    "ASIA/PACIFIC\nKorea - Gumi Tel: 82-54-473-4301 Fax: 82-54-473-4302\nKorea - Seoul Tel: 82-2-554-7200 Fax: 82-2-558-5932 or 82-2-558-5934\nMalaysia - Penang Tel: 60-4-646-8870 Fax: 60-4-646-5086\nPhilippines - Manila Tel: 63-2-634-9065 Fax: 63-2-634-9069",
    "Singapore\nTel:  65-6334-8870 Fax: 65-6334-8850\nTaiwan - Hsin Chu Tel: 886-3-572-9526 Fax: 886-3-572-6459\nTaiwan - Kaohsiung Tel: 886-7-536-4818 Fax: 886-7-536-4803\nTaiwan - Taipei Tel: 886-2-2500-6610 Fax: 886-2-2508-0102\nThailand - Bangkok Tel: 66-2-694-1351 Fax: 66-2-694-1350",
    "EUROPE\nAustria - Wels Tel: 43-7242-2244-3910 Fax: 43-7242-2244-393",
    "Denmark - Copenhagen\nTel: 45-4450-2828\nFax: 45-4485-2829\nFrance - Paris Tel: 33-1-69-53-63-20 Fax: 33-1-69-30-90-79\nGermany - Munich Tel: 49-89-627-144-0 Fax: 49-89-627-144-44\nItaly - Milan Tel: 39-0331-742611 Fax: 39-0331-466781\nNetherlands - Drunen Tel: 31-416-690399 Fax: 31-416-690340\nSpain - Madrid Tel: 34-91-708-08-90 Fax: 34-91-708-08-91\nUK - Wokingham Tel: 44-118-921-5869 Fax: 44-118-921-5820",
    "Mouser Electronics\nAuthorized Distributor\nClick to View Pricing, Inventory, Delivery & Lifecycle Information:",
    "Microchip:\nPIC18F452T-I/PT\u00a0 PIC18F442T-I/PT\u00a0 PIC18F452-I/PT\u00a0 PIC18F442-I/PT\u00a0 PIC18LF252T-I/SO\u00a0 PIC18F252-I/SO PIC18F442-I/ML\u00a0 PIC18F452-I/ML\u00a0 PIC18F442-E/L\u00a0 PIC18F242-I/SO\u00a0 PIC18F252-I/SP\u00a0 PIC18F242-I/SP\u00a0 PIC18F452I/L\u00a0 PIC18F452-I/P\u00a0 PIC18F452-E/L\u00a0 PIC18F452-E/P\u00a0 PIC18F442-E/PT\u00a0 PIC18F452-E/PT\u00a0 PIC18F452T-I/L PIC18F242T-I/SO\u00a0 PIC18F252T-I/SO\u00a0 PIC18LF452-I/L\u00a0 PIC18LF452-I/P\u00a0 PIC18F242-E/SO\u00a0 PIC18F252-E/SO PIC18F252-E/SP\u00a0 PIC18F452-I/PTG",
    "Microchip:\nPIC18F452-E/ML\u00a0 PIC18F442-I/P\u00a0 PIC18F442-I/L\u00a0 PIC18LF252-I/SOG PIC18LF452T-I/PT\u00a0 PIC18LF452T-I/ML\u00a0 PIC18LF242-I/SP\u00a0 PIC18LF452-I/PT\u00a0 PIC18LF452-I/ML\u00a0 PIC18LF252-I/SP PIC18LF252-I/SO\u00a0 PIC18LF442-I/PT\u00a0 PIC18LF242-I/SO\u00a0 PIC18LF442-I/P\u00a0 PIC18LF442-I/L"
]
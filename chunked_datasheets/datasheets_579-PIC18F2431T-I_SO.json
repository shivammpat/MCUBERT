[
    "PIC18F2331/2431/4331/4431 Data Sheet\n28/40/44-Pin Enhanced Flash Microcontrollers with nanoWatt Technology, High-Performance PWM and A/D",
    "Note the following details of the code protection feature on Microchip devices:\n\u00b7 Microchip products meet the specification contained in their particular Microchip Data Sheet.\n\u00b7 Microchip believes that its family of products is one of the most secure families of its kind on the market today, when used in the intended manner and under normal conditions.\n\u00b7 There are dishonest and possibly illegal methods used to breach the code protection feature. All of these methods, to our knowledge, require using the Microchip products in a manner outside the operating specifications contained in Microchip's Data Sheets. Most likely, the person doing so is engaged in theft of intellectual property.\n\u00b7 Microchip is willing to work with the customer who is concerned about the integrity of their code.\n\u00b7 Neither Microchip nor any other semiconductor manufacturer can guarantee the security of their code. Code protection does not mean that we are guaranteeing the product as 'unbreakable.'",
    "Note the following details of the code protection feature on Microchip devices:\nCode protection is constantly evolving. We at Microchip are committed to continuously improving the code protection features of our products. Attempts to break Microchip's code protection feature may be a violation of the Digital Millennium Copyright Act. If such acts allow unauthorized access to your software or other copyrighted work, you may have a right to sue for relief under that Act.",
    "Note the following details of the code protection feature on Microchip devices:\nInformation  contained  in  this  publication  regarding  device applications and the like is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure  that  your  application  meets  with  your  specifications. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES  OF  ANY  KIND  WHETHER  EXPRESS  OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION, INCLUDING  BUT  NOT  LIMITED  TO  ITS CONDITION, QUALITY, PERFORMANCE, MERCHANTABILITY OR FITNESS  FOR  PURPOSE . Microchip  disclaims  all  liability arising  from  this  information  and  its  use.  Use  of  Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold  harmless  Microchip  from  any  and  all  damages,  claims, suits,  or  expenses  resulting  from  such  use.  No  licenses  are conveyed, implicitly or otherwise, under any Microchip intellectual property rights.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, dsPIC, KEELOQ, KEELOQ logo, MPLAB, PIC, PICmicro, PICSTART, PIC 32 logo, rfPIC and UNI/O are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nFilterLab, Hampshire, HI-TECH C, Linear Active Thermistor, MXDEV, MXLAB, SEEVAL and The Embedded Control Solutions Company are registered trademarks of Microchip Technology Incorporated in the U.S.A.",
    "Trademarks\nAnalog-for-the-Digital Age, Application Maestro, CodeGuard, dsPICDEM, dsPICDEM.net, dsPICworks, dsSPEAK, ECAN, ECONOMONITOR, FanSense, HI-TIDE, In-Circuit Serial Programming, ICSP, Mindi, MiWi, MPASM, MPLAB Certified logo, MPLIB, MPLINK, mTouch, Octopus, Omniscient Code Generation, PICC, PICC-18, PICDEM, PICDEM.net, PICkit, PICtail, REAL ICE, rfLAB, Select Mode, Total Endurance, TSHARC, UniWinDriver, WiperLock and ZENA are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nAll other trademarks mentioned herein are property of their respective companies.\n\u00a9 2010, Microchip Technology Incorporated, Printed in the U.S.A., All Rights Reserved.\nPrinted on recycled paper.",
    "ISBN: 978-1-60932-490-2\nMicrochip received ISO/TS-16949:2002 certification for its worldwide headquarters, design and wafer fabrication facilities in Chandler and Tempe, Arizona; Gresham, Oregon and design centers in California and India. The Company's quality system processes and procedures are for its PIC \u00ae MCUs and dsPIC \u00ae  DSCs, KEELOQ \u00ae  code hopping devices, Serial EEPROMs, microperipherals, nonvolatile memory and analog products. In addition, Microchip's quality system for the design and manufacture of development systems is ISO 9001:2000 certified.\nQUALITY MANAGEMENT SYSTEM CERTIFIED BY DNV",
    "Power-Managed Modes:\n\u00b7 Up to 4 Channels with Complementary Outputs\n\u00b7 Edge or Center-Aligned Operation\n\u00b7 Flexible Dead-Band Generator\n\u00b7 Hardware Fault Protection Inputs\n\u00b7 Simultaneous Update of Duty Cycle and Period:\n-Flexible Special Event Trigger output",
    "Motion Feedback Module:\n\u00b7 Three Independent Input Capture Channels:\n-Flexible operating modes for period and pulse-width measurement\n-Special Hall sensor interface module\n-Special Event Trigger output to other modules\n\u00b7 Quadrature Encoder Interface:\n-2-phase inputs and one index input from encoder\n-High and low position tracking with direction status and change of direction interrupt\n-Velocity measurement",
    "High-Speed, 200 ksps 10-Bit A/D Converter:\n\u00b7 Up to 9 Channels\n\u00b7 Simultaneous, Two-Channel Sampling\n\u00b7 Sequential Sampling: 1, 2 or 4 Selected Channels\n\u00b7 Auto-Conversion Capability\n\u00b7 4-Word FIFO with Selectable Interrupt Frequency\n\u00b7 Selectable External Conversion Triggers\n\u00b7 Programmable Acquisition Time",
    "Flexible Oscillator Structure:\n\u00b7 Four Crystal modes up to 40 MHz\n\u00b7 Two External Clock modes up to 40 MHz\n\u00b7 Internal Oscillator Block:\n-8 user-selectable frequencies: 31 kHz to 8 MHz\n-OSCTUNE can compensate for frequency drift\n\u00b7 Secondary Oscillator using Timer1 @ 32 kHz\n\u00b7 Fail-Safe Clock Monitor:\n-Allows for safe shutdown of device if clock fails\n\u00b7 Run: CPU on, Peripherals on\n\u00b7 Idle: CPU off, Peripherals on\n\u00b7 Sleep: CPU off, Peripherals off\n\u00b7 Ultra Low, 50 nA Input Leakage\n\u00b7 Idle mode Currents Down to 5.8 \uf06d A, Typical\n\u00b7 Sleep Current Down to 0.1 \uf06d A, Typical\n\u00b7 Timer1 Oscillator, 1.8 \uf06d A, Typical, 32 kHz, 2V\n\u00b7 Watchdog Timer (WDT), 2.1 \uf06d A, typical\n\u00b7 Oscillator Two-Speed Start-up\n-Fast wake from Sleep and Idle, 1 \uf06d s, typical",
    "Flexible Oscillator Structure:\nPIC18F2331, Program Memory.Flash (bytes) = 8192. PIC18F2331, Program Memory.#Single-Word Instructions = 4096. PIC18F2331, Data Memory.SRAM (bytes) = 768. PIC18F2331, Data Memory.EEPROM (bytes) = 256. PIC18F2331, I/O.I/O = 24. PIC18F2331, 10-Bit A/D (ch).10-Bit A/D (ch) = 5. PIC18F2331, CCP = 2. PIC18F2331, SSP.SPI = Y. PIC18F2331, SSP.Slave I 2 C\u2122 = Y. PIC18F2331, EUSART.EUSART = Y. PIC18F2331, Quadrature Encoder.Quadrature Encoder = Y. PIC18F2331, 14-Bit.PWM (ch) = 6. PIC18F2331, Timers 8/16-Bit = 1/3. PIC18F2431, Program Memory.Flash (bytes) =",
    "Flexible Oscillator Structure:\n16384. PIC18F2431, Program Memory.#Single-Word Instructions = 8192. PIC18F2431, Data Memory.SRAM (bytes) = 768. PIC18F2431, Data Memory.EEPROM (bytes) = 256. PIC18F2431, I/O.I/O = 24. PIC18F2431, 10-Bit A/D (ch).10-Bit A/D (ch) = 5. PIC18F2431, CCP = 2. PIC18F2431, SSP.SPI = Y. PIC18F2431, SSP.Slave I 2 C\u2122 = Y. PIC18F2431, EUSART.EUSART = Y. PIC18F2431, Quadrature Encoder.Quadrature Encoder = Y. PIC18F2431, 14-Bit.PWM (ch) = 6. PIC18F2431, Timers 8/16-Bit = 1/3. PIC18F4331, Program Memory.Flash (bytes) = 8192. PIC18F4331, Program",
    "Flexible Oscillator Structure:\nMemory.#Single-Word Instructions = 4096. PIC18F4331, Data Memory.SRAM (bytes) = 768. PIC18F4331, Data Memory.EEPROM (bytes) = 256. PIC18F4331, I/O.I/O = 36. PIC18F4331, 10-Bit A/D (ch).10-Bit A/D (ch) = 9. PIC18F4331, CCP = 2. PIC18F4331, SSP.SPI = Y. PIC18F4331, SSP.Slave I 2 C\u2122 = Y. PIC18F4331, EUSART.EUSART = Y. PIC18F4331, Quadrature Encoder.Quadrature Encoder = Y. PIC18F4331, 14-Bit.PWM (ch) = 8. PIC18F4331, Timers 8/16-Bit = 1/3. PIC18F4431, Program Memory.Flash (bytes) = 16384. PIC18F4431, Program Memory.#Single-Word Instructions = 8192.",
    "Flexible Oscillator Structure:\nPIC18F4431, Data Memory.SRAM (bytes) = 768. PIC18F4431, Data Memory.EEPROM (bytes) = 256. PIC18F4431, I/O.I/O = 36. PIC18F4431, 10-Bit A/D (ch).10-Bit A/D (ch) = 9. PIC18F4431, CCP = 2. PIC18F4431, SSP.SPI = Y. PIC18F4431, SSP.Slave I 2 C\u2122 = Y. PIC18F4431, EUSART.EUSART = Y. PIC18F4431, Quadrature Encoder.Quadrature Encoder = Y. PIC18F4431, 14-Bit.PWM (ch) = 8. PIC18F4431, Timers 8/16-Bit = 1/3",
    "Peripheral Highlights:\n\u00b7 High-Current Sink/Source 25 mA/25 mA\n\u00b7 Three External Interrupts\n\u00b7 Two Capture/Compare/PWM (CCP) modules\n\u00b7 Enhanced USART module:\n-Supports RS-485, RS-232 and LIN/J2602\n-Auto-wake-up on Start bit\n-Auto-Baud Detect",
    "Special Microcontroller Features:\n\u00b7 100,000 Erase/Write Cycle Enhanced Flash Program Memory, Typical\n\u00b7 1,000,000 Erase/Write Cycle Data EEPROM Memory, Typical\n\u00b7 Flash/Data EEPROM Retention: 100 Years\n\u00b7 Self-Programmable under Software Control\n\u00b7 Priority Levels for Interrupts\n\u00b7 8 x 8 Single-Cycle Hardware Multiplier\n\u00b7 Extended Watchdog Timer (WDT):\n-Programmable period from 41 ms to 131s\n\u00b7 Single-Supply In-Circuit Serial Programming\u2122 (ICSP\u2122) via Two Pins\n\u00b7 In-Circuit Debug (ICD) via Two Pins:\n-Drives PWM outputs safely when debugging",
    "44-Pin QFN (2)\nNote 1: RC3 is the alternate pin for T0CKI/T5CKI; RC4 is the alternate pin for SDI/SDA; RC5 is the alternate pin for SCK/SCL.\n2: For the QFN package, it is recommended that the bottom pad be connected to VSS.\n3: RD4 is the alternate pin for FLTA.\n4: RD5 is the alternate pin for PWM4.",
    "Table of Contents\n1.0, 1 = Device Overview ......................................................................................................................................................................... 1.0, 2 = 11. 2.0, 1 = Guidelines for Getting Started with PIC18F Microcontrollers",
    "Table of Contents\n...................................................................................................... 2.0, 2 = 25. 3.0, 1 = Oscillator Configurations",
    "Table of Contents\n............................................................................................................................................................. 3.0, 2 = 29. 4.0, 1 = Power-Managed Modes",
    "Table of Contents\n.............................................................................................................................................................. 4.0, 2 = 39. 5.0, 1 =",
    "Table of Contents\nReset........................................................................................................................................................................................... 5.0, 2 = 47. 6.0, 1 = Memory",
    "Table of Contents\nOrganization.................................................................................................................................................................. 6.0, 2 = 61. 7.0, 1 = Data EEPROM Memory",
    "Table of Contents\n.............................................................................................................................................................. 7.0, 2 = 79. 8.0, 1 = Flash Program",
    "Table of Contents\nMemory............................................................................................................................................................... 8.0, 2 = 85. 9.0, 1 = 8 x 8 Hardware",
    "Table of Contents\nMultiplier............................................................................................................................................................. 9.0, 2 = 95. 10.0, 1 = Interrupts",
    "Table of Contents\n..................................................................................................................................................................................... 10.0, 2 = 97. 11.0, 1 = I/O Ports",
    "Table of Contents\n.................................................................................................................................................................................... 11.0, 2 = 113. 12.0, 1 = Timer0 Module",
    "Table of Contents\n.......................................................................................................................................................................... 12.0, 2 = 127. 13.0, 1 = Timer1 Module",
    "Table of Contents\n.......................................................................................................................................................................... 13.0, 2 = 131. 14.0, 1 = Timer2 Module",
    "Table of Contents\n.......................................................................................................................................................................... 14.0, 2 = 136. 15.0, 1 = Timer5 Module",
    "Table of Contents\n.......................................................................................................................................................................... 15.0, 2 = 139. 16.0, 1 = Capture/Compare/PWM (CCP) Modules",
    "Table of Contents\n.................................................................................................................................. 16.0, 2 = 145. 17.0, 1 = Motion Feedback",
    "Table of Contents\nModule.......................................................................................................................................................... 17.0, 2 = 151. 18.0, 1 = Power Control PWM",
    "Table of Contents\nModule..................................................................................................................................................... 18.0, 2 = 173. 19.0, 1 = Synchronous Serial Port (SSP) Module",
    "Table of Contents\n.................................................................................................................................... 19.0, 2 = 205. 20.0, 1 = Enhanced Universal Synchronous Asynchronous Receiver Transmitter (EUSART)................................................................ 20.0, 2 = 217. 21.0, 1 = 10-Bit High-Speed Analog-to-Digital",
    "Table of Contents\nConverter (A/D) Module .................................................................................................. 21.0, 2 = 239. 22.0, 1 = Low-Voltage Detect",
    "Table of Contents\n(LVD)......................................................................................................................................................... 22.0, 2 = 257. 23.0, 1 = Special Features of the",
    "Table of Contents\nCPU..................................................................................................................................................... 23.0, 2 = 263. 24.0, 1 = Instruction Set",
    "Table of Contents\nSummary........................................................................................................................................................... 24.0, 2 = 283. 25.0, 1 = Development",
    "Table of Contents\nSupport................................................................................................................................................................ 25.0, 2 = 325. 26.0, 1 = Electrical Characteristics",
    "Table of Contents\n........................................................................................................................................................... 26.0, 2 = 329. 27.0, 1 = Packaging",
    "Table of Contents\nInformation............................................................................................................................................................... 27.0, 2 = 363. Appendix, 1 = A: Revision",
    "Table of Contents\nHistory.............................................................................................................................................................. Appendix, 2 = 375. Appendix B: Device",
    "Table of Contents\nDifferences........................................................................................................................................................., 1 = Appendix B: Device",
    "Table of Contents\nDifferences.......................................................................................................................................................... Appendix B: Device",
    "Table of Contents\nDifferences........................................................................................................................................................., 2 = 375. Appendix C: Conversion Considerations",
    "Table of Contents\n..........................................................................................................................................., 1 = Appendix C: Conversion Considerations",
    "Table of Contents\n............................................................................................................................................ Appendix C: Conversion Considerations",
    "Table of Contents\n..........................................................................................................................................., 2 = 376. Appendix D: Migration from Baseline to Enhanced",
    "Table of Contents\nDevices.............................................................................................................., 1 = Appendix D: Migration from Baseline to Enhanced Devices............................................................................................................... Appendix D: Migration from Baseline to Enhanced",
    "Table of Contents\nDevices.............................................................................................................., 2 = 376. Appendix E: Migration From Mid-Range to Enhanced Devices........................................................................................................., 1 = Appendix E: Migration From Mid-Range to Enhanced",
    "Table of Contents\nDevices.......................................................................................................... Appendix E: Migration From Mid-Range to Enhanced Devices........................................................................................................., 2 = 377. Appendix, 1 = F: Migration From High-End to Enhanced",
    "Table of Contents\nDevices............................................................................................................. Appendix, 2 = 377.",
    "Table of Contents\nINDEX................................................................................................................................................................................................, 1 =",
    "Table of Contents\nINDEX.................................................................................................................................................................................................",
    "Table of Contents\nINDEX................................................................................................................................................................................................, 2 = 379. The Microchip Web",
    "Table of Contents\nSite....................................................................................................................................................................., 1 = The Microchip Web",
    "Table of Contents\nSite...................................................................................................................................................................... The Microchip Web",
    "Table of Contents\nSite....................................................................................................................................................................., 2 = 389. Customer Change Notification Service",
    "Table of Contents\n.............................................................................................................................................., 1 = Customer Change Notification Service",
    "Table of Contents\n............................................................................................................................................... Customer Change Notification Service",
    "Table of Contents\n.............................................................................................................................................., 2 = 389. Customer",
    "Table of Contents\nSupport.............................................................................................................................................................................., 1 = Customer",
    "Table of Contents\nSupport............................................................................................................................................................................... Customer",
    "Table of Contents\nSupport.............................................................................................................................................................................., 2 = 389. Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................., 1 = Reader",
    "Table of Contents\nResponse............................................................................................................................................................................... Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................., 2 = 390. Product Identification",
    "Table of Contents\nSystem............................................................................................................................................................., 1 = Product Identification",
    "Table of Contents\nSystem.............................................................................................................................................................. Product Identification",
    "Table of Contents\nSystem............................................................................................................................................................., 2 = 391",
    "TO OUR VALUED CUSTOMERS\nIt is our intention to provide our valued customers with the best documentation possible to ensure successful use of your Microchip products. To this end, we will continue to improve our publications to better suit your needs. Our publications will be refined and enhanced as new volumes and updates are introduced.\nIf you have any questions or comments regarding this publication, please contact the Marketing Communications Department via E-mail at docerrors@microchip.com or fax the Reader Response Form in the back of this data sheet to (480) 792-4150. We welcome your feedback.",
    "Most Current Data Sheet\nTo obtain the most up-to-date version of this data sheet, please register at our Worldwide Web site at:\nhttp://www.microchip.com\nYou can determine the version of a data sheet by examining its literature number found on the bottom outside corner of any page. The last character of the literature number is the version number, (e.g., DS30000A is version A of document DS30000).",
    "Errata\nAn errata sheet, describing minor operational differences from the data sheet and recommended workarounds, may exist for current devices. As device/documentation issues become known to us, we will publish an errata sheet. The errata will specify the revision of silicon and revision of document to which it applies.\nTo determine if an errata sheet exists for a particular device, please check with one of the following:\n\u00b7 Microchip's Worldwide Web site; http://www.microchip.com\n\u00b7 Your local Microchip sales office (see last page)\nWhen contacting a sales office, please specify which device, revision of silicon and data sheet (include literature number) you are using.",
    "Customer Notification System\nRegister on our web site at www.microchip.com to receive the most current information on all of our products.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "1.0 DEVICE OVERVIEW\nThis document contains device-specific information for the following devices:\n\u2022 PIC18F2331\n\u2022 PIC18LF2331\n\u2022 PIC18F2431\n\u2022 PIC18LF2431\n\u2022 PIC18F4331\n\u2022 PIC18LF4331\n\u2022 PIC18F4431\n\u2022 PIC18LF4431\n- \u00b7 On-the-Fly Mode Switching: The powermanaged modes are invoked by user code during operation, allowing the user to incorporate power-saving ideas into their application's software design.\nThis family offers the advantages of all PIC18 microcontrollers -namely, high computational performance at an economical price, with the addition of high-endurance enhanced Flash program memory and a high-speed  10-bit  A/D  Converter.  On  top  of  these features, the PIC18F2331/2431/4331/4431 family introduces design enhancements that make these microcontrollers a logical choice for many high-performance, power  control  and  motor  control  applications.  These special peripherals include:",
    "1.0 DEVICE OVERVIEW\n\u00b7 14-Bit Resolution Power Control PWM module (PCPWM) with Programmable Dead-Time Insertion\n\u00b7 Motion Feedback Module (MFM), including a 3-Channel Input Capture (IC) module and Quadrature Encoder Interface (QEI)\n\u00b7 High-Speed 10-Bit A/D Converter (HSADC)\nThe PCPWM can generate up to eight complementary PWM outputs with dead-band time insertion. Overdrive current is detected by off-chip analog comparators or the digital Fault inputs (FLTA, FLTB).\nThe  MFM  Quadrature  Encoder  Interface  provides precise rotor position feedback and/or velocity measurement. The MFM 3x input capture or external interrupts  can  be  used  to  detect  the  rotor  state  for electrically commutated motor applications using Hall sensor feedback, such as BLDC motor drives.\nPIC18F2331/2431/4331/4431 devices also feature Flash program memory and an internal RC oscillator with built-in LP modes.",
    "1.1.1 nanoWatt Technology\nAll of the devices in the PIC18F2331/2431/4331/4431 family incorporate a range of features that can significantly  reduce  power  consumption  during  operation. Key items include:\n\u00b7 Alternate Run Modes: By clocking the controller from the Timer1 source or the internal oscillator block, power consumption during code execution can be reduced by as much as 90%.\n\u00b7 Multiple Idle Modes: The controller can also run with its CPU core disabled, but the peripherals are still active. In these states, power consumption can be reduced even further, to as little as 4% of normal operation requirements.\n\u00b7 Lower Consumption in Key Modules: The power requirements for both Timer1 and the Watchdog Timer have been reduced by up to 80%, with typical values of 1.1 and 2.1 \uf06d A, respectively.",
    "1.1.2 MULTIPLE OSCILLATOR OPTIONS AND FEATURES\nAll of the devices in the PIC18F2331/2431/4331/4431 family  offer  nine  different  oscillator  options,  allowing users a wide range of choices in developing application hardware. These include:",
    "1.1.2 MULTIPLE OSCILLATOR OPTIONS AND FEATURES\n\u00b7 Four Crystal modes, using crystals or ceramic resonators.\n\u00b7 Two External Clock modes, offering the option of using two pins (oscillator input and a divide-by-4 clock output) or one pin (oscillator input, with the second pin reassigned as general I/O).\n\u00b7 Two External RC Oscillator modes, with the same pin options as the External Clock modes.\n\u00b7 An internal oscillator block, which provides an 8 MHz clock and an INTRC source (approximately 31 kHz, stable over temperature and VDD), as well as a range of 6 user-selectable clock frequencies (from 125 kHz to 4 MHz) for a total of 8 clock frequencies.\n\u00b7 A Phase Lock Loop (PLL) frequency multiplier, available to both the High-Speed Crystal and Internal Oscillator modes, which allows clock speeds of up to 40 MHz. Used with the internal oscillator, the PLL gives users a complete selection of clock speeds, from 31 kHz to 32 MHz - all without using an external crystal or clock circuit.",
    "1.1.2 MULTIPLE OSCILLATOR OPTIONS AND FEATURES\n\u00b7 Fail-Safe Clock Monitor: This option constantly monitors the main clock source against a reference signal provided by the internal oscillator. If a clock failure occurs, the controller is switched to the internal oscillator block, allowing for continued low-speed operation or a safe application shutdown.\n\u00b7 Two-Speed Start-up: This option allows the internal oscillator to serve as the clock source from Power-on Reset, or wake-up from Sleep mode, until the primary clock source is available.",
    "1.2 Other Special Features\n\u00b7 Memory Endurance: The enhanced Flash cells for both program memory and data EEPROM are rated to last for many thousands of erase/write cycles - up to 100,000 for program memory and 1,000,000 for EEPROM. Data retention without refresh is conservatively estimated to be greater than 100 years.\n\u00b7 High-Speed 10-Bit A/D Converter: This module incorporates programmable acquisition time, allowing for a channel to be selected and a conversion to be initiated without waiting for a sampling period and thus, reducing code overhead.\n\u00b7 Self-Programmability: These devices can write to their own program memory spaces under internal software control. By using a bootloader routine located in the protected boot block at the top of program memory, it becomes possible to create an application that can update itself in the field.\n\u00b7 Power Control PWM Module: In PWM mode, this module provides 1, 2 or 4 modulated outputs for controlling half-bridge and full-bridge drivers. Other features include auto-shutdown on Fault detection and auto-restart to reactivate outputs once the condition has cleared.",
    "1.2 Other Special Features\n\u00b7 Enhanced Addressable USART: This serial communication module is capable of standard RS-232 operation and provides support for the LIN/J2602 bus protocol. Other enhancements include automatic baud rate detection and a 16-bit Baud Rate Generator for improved resolution. When the microcontroller is using the internal oscillator block, the EUSART provides stable operation for applications that talk to the outside world without using an external crystal (or its accompanying power requirement).\n\u00b7 Extended Watchdog Timer (WDT): This enhanced version incorporates a 16-bit prescaler, allowing an extended time-out range that is stable across operating voltage and temperature. See Section 26.0 'Electrical Characteristics' for time-out periods.",
    "1.2 Other Special Features\n\u00b7 Motion Feedback Module (MFM): This module features a Quadrature Encoder Interface (QEI) and an Input Capture (IC) module. The QEI accepts two phase inputs (QEA, QEB) and one index input (INDX) from an incremental encoder. The QEI supports high and low precision position tracking, direction status and change of direction interrupt and velocity measurement. The input capture features 3 channels of independent input capture with Timer5 as the time base, a Special Event Trigger to other modules and an adjustable noise filter on each IC input.\n\u00b7 Extended Watchdog Timer (WDT): This enhanced version incorporates a 16-bit prescaler, allowing a time-out range from 4 ms to over 2 minutes, that is stable across operating voltage and temperature.",
    "1.3 Details on Individual Family Members\nAll other features for devices in this family are identical. These are summarized in Table 1-1.\nDevices in the PIC18F2331/2431/4331/4431 family are available in 28-pin (PIC18F2331/2431) and 40/44-pin (PIC18F4331/4431) packages. The block diagram for the two groups is shown in Figure 1-1.\nThe devices are differentiated from each other in three ways:\n1. Flash program memory (8 Kbytes for PIC18F2331/4331 devices, 16 Kbytes for PIC18F2431/4431).\n2. A/D channels (5 for PIC18F2331/2431 devices, 9 for PIC18F4331/4431 devices).\n3. I/O ports (3 bidirectional ports on PIC18F2331/ 2431 devices, 5 bidirectional ports on PIC18F4331/4431 devices).",
    "TABLE 1-1: DEVICE FEATURES\nOperating Frequency, PIC18F2331 = DC - 40 MHz. Operating Frequency, PIC18F2431 = DC - 40 MHz. Operating Frequency, PIC18F4331 = DC - 40 MHz. Operating Frequency, PIC18F4431 = DC - 40 MHz. Program Memory (Bytes), PIC18F2331 = 8192. Program Memory (Bytes), PIC18F2431 = 16384. Program Memory (Bytes), PIC18F4331 = 8192. Program Memory (Bytes), PIC18F4431 = 16384. Program Memory (Instructions), PIC18F2331 = 4096. Program Memory (Instructions), PIC18F2431 = 8192. Program Memory (Instructions), PIC18F4331 = 4096. Program Memory (Instructions), PIC18F4431 = 8192. Data Memory (Bytes), PIC18F2331 = 768. Data Memory (Bytes), PIC18F2431 = 768. Data Memory (Bytes), PIC18F4331 = 768. Data Memory (Bytes), PIC18F4431 = 768. Data EEPROM Memory",
    "TABLE 1-1: DEVICE FEATURES\n(Bytes), PIC18F2331 = 256. Data EEPROM Memory (Bytes), PIC18F2431 = 256. Data EEPROM Memory (Bytes), PIC18F4331 = 256. Data EEPROM Memory (Bytes), PIC18F4431 = 256. Interrupt Sources, PIC18F2331 = 22. Interrupt Sources, PIC18F2431 = 22. Interrupt Sources, PIC18F4331 = 34. Interrupt Sources, PIC18F4431 = 34. I/O Ports, PIC18F2331 = Ports A, B, C. I/O Ports, PIC18F2431 = Ports A, B, C. I/O Ports, PIC18F4331 = Ports A, B, C, D, E. I/O Ports, PIC18F4431 = Ports A, B, C, D, E. Timers, PIC18F2331 = 4. Timers, PIC18F2431 = 4. Timers, PIC18F4331 = 4. Timers, PIC18F4431 = 4. Capture/Compare/PWM modules, PIC18F2331 = 2.",
    "TABLE 1-1: DEVICE FEATURES\nCapture/Compare/PWM modules, PIC18F2431 = 2. Capture/Compare/PWM modules, PIC18F4331 = 2. Capture/Compare/PWM modules, PIC18F4431 = 2. 14-Bit Power Control PWM, PIC18F2331 = (6 Channels). 14-Bit Power Control PWM, PIC18F2431 = (6 Channels). 14-Bit Power Control PWM, PIC18F4331 = (8 Channels). 14-Bit Power Control PWM, PIC18F4431 = (8 Channels). Motion Feedback Module (Input Capture/Quadrature Encoder Interface), PIC18F2331 = 1 QEI or 3x IC. Motion Feedback Module (Input Capture/Quadrature Encoder Interface), PIC18F2431 = 1 QEI or 3x IC. Motion Feedback Module (Input Capture/Quadrature Encoder Interface), PIC18F4331 = 1 QEI or 3x IC. Motion Feedback Module (Input Capture/Quadrature Encoder Interface), PIC18F4431 = 1 QEI or 3x",
    "TABLE 1-1: DEVICE FEATURES\nIC. Serial Communications, PIC18F2331 = SSP, Enhanced USART. Serial Communications, PIC18F2431 = SSP, Enhanced USART. Serial Communications, PIC18F4331 = SSP, Enhanced USART. Serial Communications, PIC18F4431 = SSP, Enhanced USART. 10-Bit High-Speed Analog-to-Digital Converter module, PIC18F2331 = 5 Input Channels. 10-Bit High-Speed Analog-to-Digital Converter module, PIC18F2431 = 5 Input Channels. 10-Bit High-Speed Analog-to-Digital Converter module, PIC18F4331 = 9 Input Channels. 10-Bit High-Speed Analog-to-Digital Converter module, PIC18F4431 = 9 Input Channels. Resets (and Delays), PIC18F2331 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR (optional), WDT. Resets (and Delays), PIC18F2431 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR",
    "TABLE 1-1: DEVICE FEATURES\n(optional), WDT. Resets (and Delays), PIC18F4331 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR (optional), WDT. Resets (and Delays), PIC18F4431 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST), MCLR (optional), WDT. Programmable Low-Voltage Detect, PIC18F2331 = Yes. Programmable Low-Voltage Detect, PIC18F2431 = Yes. Programmable Low-Voltage Detect, PIC18F4331 = Yes. Programmable Low-Voltage Detect, PIC18F4431 = Yes. Programmable Brown-out Reset, PIC18F2331 = Yes. Programmable Brown-out Reset, PIC18F2431 = Yes. Programmable Brown-out Reset, PIC18F4331 = Yes. Programmable Brown-out Reset, PIC18F4431 = Yes. Instruction Set, PIC18F2331 = 75 Instructions. Instruction Set, PIC18F2431 = 75 Instructions. Instruction Set, PIC18F4331",
    "TABLE 1-1: DEVICE FEATURES\n= 75 Instructions. Instruction Set, PIC18F4431 = 75 Instructions. Packages, PIC18F2331 = 28-pin SPDIP 28-pin SOIC 28-pin QFN. Packages, PIC18F2431 = 28-pin SPDIP 28-pin SOIC 28-pin QFN. Packages, PIC18F4331 = 40-pin PDIP 44-pin TQFP 44-pin QFN. Packages, PIC18F4431 = 40-pin PDIP 44-pin TQFP 44-pin QFN\nThe pinouts for all devices are listed in Table 1-2 and Table 1-3.",
    "TABLE 1-1: DEVICE FEATURES\nLike  all  Microchip  PIC18  devices,  members  of  the PIC18F2331/2431/4331/4431  family  are  available  as both standard and  low-voltage devices. Standard devices with Enhanced Flash memory, designated with an  'F'  in  the  part  number  (such  as  PIC18 F 2331), accommodate an operating VDD range of 4.2V to 5.5V. Low-voltage parts, designated by 'LF' (such as PIC18 LF 2331), function over an extended VDD range of 2.0V to 5.5V.",
    "FIGURE 1-2: PIC18F4331/4431 (40/44-PIN) BLOCK DIAGRAM\nNote 1: RE3 is available only when MCLR is disabled.\n2: RD4 is the alternate pin for FLTA.\n3: RC3, RC4 and RC5 are alternate pins for T0CKI/T5CKI, SDI/SDA, SCK/SCL, respectively.\n4: RD5 is the alternate pin for PWM4.",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS\nMCLR/VPP, Pin Number.SPDIP, SOIC = 1. MCLR/VPP, Pin Number.QFN = 26. MCLR/VPP, Pin.Type = . MCLR/VPP, Buffer Type = . MCLR/VPP, Description = Master Clear (input) or programming voltage (input).. MCLR, Pin Number.SPDIP, SOIC = . MCLR, Pin Number.QFN = . MCLR, Pin.Type = I. MCLR, Buffer Type = ST. MCLR, Description = Master Clear (Reset) input. This pin is an active-low Reset to the device.. , Pin Number.SPDIP, SOIC = . , Pin Number.QFN = . , Pin.Type = P. , Buffer Type = . , Description = High-voltage ICSP\u2122 programming enable pin.. VPP, Pin Number.SPDIP, SOIC = 9. VPP, Pin Number.QFN = 6. VPP, Pin.Type = . VPP, Buffer Type = . VPP, Description = Oscillator crystal",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS\nor external clock input.. OSC1/CLKI/RA7 OSC1, Pin Number.SPDIP, SOIC = . OSC1/CLKI/RA7 OSC1, Pin Number.QFN = . OSC1/CLKI/RA7 OSC1, Pin.Type = I. OSC1/CLKI/RA7 OSC1, Buffer Type = ST. OSC1/CLKI/RA7 OSC1, Description = Oscillator crystal input or external clock source input. ST buffer when configured in RC mode; CMOS otherwise.. CLKI, Pin Number.SPDIP, SOIC = . CLKI, Pin Number.QFN = . CLKI, Pin.Type = I. CLKI, Buffer Type = CMOS. CLKI, Description = External clock source input. Always associated with pin function OSC1. (See related OSC1/CLKI, OSC2/CLKO pins.). RA7, Pin Number.SPDIP, SOIC = . RA7, Pin Number.QFN = . RA7,",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS\nPin.Type = I/O. RA7, Buffer Type = TTL. RA7, Description = General purpose I/O pin.. OSC2/CLKO/RA6, Pin Number.SPDIP, SOIC = 10. OSC2/CLKO/RA6, Pin Number.QFN = 7. OSC2/CLKO/RA6, Pin.Type = . OSC2/CLKO/RA6, Buffer Type = . OSC2/CLKO/RA6, Description = Oscillator crystal or clock output.. OSC2, Pin Number.SPDIP, SOIC = . OSC2, Pin Number.QFN = . OSC2, Pin.Type = O. OSC2, Buffer Type = -. OSC2, Description = Oscillator crystal output. Connects to crystal or resonator in Crystal Oscillator mode.. CLKO, Pin Number.SPDIP, SOIC = . CLKO, Pin Number.QFN = . CLKO, Pin.Type = O. CLKO, Buffer Type = -.",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS\nCLKO, Description = In RC mode, OSC2 pin outputs CLKO, which has 1/4 the frequency of OSC1 and denotes the instruction cycle rate.. RA6, Pin Number.SPDIP, SOIC = . RA6, Pin Number.QFN = . RA6, Pin.Type = I/O. RA6, Buffer Type = TTL. RA6, Description = General purpose I/O pin.. PORTA is a bidirectional I/O port., Pin Number.SPDIP, SOIC = PORTA is a bidirectional I/O port.. PORTA is a bidirectional I/O port., Pin Number.QFN = PORTA is a bidirectional I/O port.. PORTA is a bidirectional I/O port., Pin.Type = PORTA is a bidirectional I/O port.. PORTA is a bidirectional I/O port., Buffer Type = PORTA is a bidirectional I/O port.. PORTA is a bidirectional",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS\nI/O port., Description = PORTA is a bidirectional I/O port.. RA0/AN0, Pin Number.SPDIP, SOIC = 2. RA0/AN0, Pin Number.QFN = 27. RA0/AN0, Pin.Type = . RA0/AN0, Buffer Type = . RA0/AN0, Description = . RA0, Pin Number.SPDIP, SOIC = . RA0, Pin Number.QFN = . RA0, Pin.Type = I/O. RA0, Buffer Type = TTL. RA0, Description = Digital I/O.. AN0, Pin Number.SPDIP, SOIC = . AN0, Pin Number.QFN = . AN0, Pin.Type = I. AN0, Buffer Type = Analog. AN0, Description = Analog Input 0.. RA1/AN1, Pin Number.SPDIP, SOIC = 3. RA1/AN1, Pin Number.QFN = 28. RA1/AN1, Pin.Type = .",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS\nRA1/AN1, Buffer Type = . RA1/AN1, Description = . RA1, Pin Number.SPDIP, SOIC = . RA1, Pin Number.QFN = . RA1, Pin.Type = I/O. RA1, Buffer Type = TTL. RA1, Description = Digital I/O.. AN1, Pin Number.SPDIP, SOIC = . AN1, Pin Number.QFN = . AN1, Pin.Type = I. AN1, Buffer Type = Analog. AN1, Description = Analog Input 1.. RA2/AN2/VREF-/CAP1/INDX, Pin Number.SPDIP, SOIC = 4. RA2/AN2/VREF-/CAP1/INDX, Pin Number.QFN = 1. RA2/AN2/VREF-/CAP1/INDX, Pin.Type = . RA2/AN2/VREF-/CAP1/INDX, Buffer Type = . RA2/AN2/VREF-/CAP1/INDX, Description = .",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS\nRA2, Pin Number.SPDIP, SOIC = . RA2, Pin Number.QFN = . RA2, Pin.Type = I/O. RA2, Buffer Type = TTL. RA2, Description = Digital I/O.. AN2, Pin Number.SPDIP, SOIC = . AN2, Pin Number.QFN = . AN2, Pin.Type = I. AN2, Buffer Type = Analog. AN2, Description = Analog Input. VREF-, Pin Number.SPDIP, SOIC = . VREF-, Pin Number.QFN = . VREF-, Pin.Type = I. VREF-, Buffer Type = Analog. VREF-, Description = 2. A/D reference voltage (low) input.. CAP1, Pin Number.SPDIP, SOIC = . CAP1, Pin Number.QFN = . CAP1, Pin.Type = I. CAP1, Buffer Type = ST. CAP1, Description = Input Capture Pin 1.. INDX, Pin Number.SPDIP, SOIC = . INDX, Pin",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS\nNumber.QFN = . INDX, Pin.Type = I. INDX, Buffer Type = ST. INDX, Description = Quadrature Encoder Interface index input pin.. RA3/AN3/VREF+/CAP2/QEA, Pin Number.SPDIP, SOIC = 5. RA3/AN3/VREF+/CAP2/QEA, Pin Number.QFN = 2. RA3/AN3/VREF+/CAP2/QEA, Pin.Type = . RA3/AN3/VREF+/CAP2/QEA, Buffer Type = . RA3/AN3/VREF+/CAP2/QEA, Description = . RA3, Pin Number.SPDIP, SOIC = . RA3, Pin Number.QFN = . RA3, Pin.Type = I/O. RA3, Buffer Type = TTL. RA3, Description = Digital I/O.. AN3, Pin Number.SPDIP, SOIC = . AN3, Pin Number.QFN = . AN3,",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS\nPin.Type = I. AN3, Buffer Type = Analog. AN3, Description = Analog Input 3.. VREF+, Pin Number.SPDIP, SOIC = . VREF+, Pin Number.QFN = . VREF+, Pin.Type = I. VREF+, Buffer Type = Analog. VREF+, Description = A/D reference voltage (high) input.. CAP2, Pin Number.SPDIP, SOIC = . CAP2, Pin Number.QFN = . CAP2, Pin.Type = I. CAP2, Buffer Type = ST. CAP2, Description = Input Capture Pin 2.. QEA, Pin Number.SPDIP, SOIC = . QEA, Pin Number.QFN = . QEA, Pin.Type = I. QEA, Buffer Type = ST. QEA, Description = Quadrature Encoder Interface Channel A input pin.. RA4/AN4/CAP3/QEB, Pin Number.SPDIP, SOIC = 6. RA4/AN4/CAP3/QEB, Pin",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS\nNumber.QFN = 3. RA4/AN4/CAP3/QEB, Pin.Type = . RA4/AN4/CAP3/QEB, Buffer Type = . RA4/AN4/CAP3/QEB, Description = . RA4, Pin Number.SPDIP, SOIC = . RA4, Pin Number.QFN = . RA4, Pin.Type = I/O. RA4, Buffer Type = TTL. RA4, Description = Digital I/O.. AN4, Pin Number.SPDIP, SOIC = . AN4, Pin Number.QFN = . AN4, Pin.Type = I. AN4, Buffer Type = Analog. AN4, Description = Analog Input 4.. CAP3, Pin Number.SPDIP, SOIC = . CAP3, Pin Number.QFN = . CAP3, Pin.Type = I. CAP3, Buffer Type = ST. CAP3, Description = Input Capture Pin 3.. QEB, Pin Number.SPDIP, SOIC = . QEB, Pin Number.QFN =",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS\n. QEB, Pin.Type = I. QEB, Buffer Type = ST. QEB, Description = Quadrature Encoder Interface Channel B input pin.\nLegend:\nTTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels\nO = Output\nCMOS = CMOS compatible input or output\nI\n= Input\nP\n= Power",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB0/PWM0, Pin Number.SPDIP, SOIC = 21. RB0/PWM0, Pin Number.QFN = 18. RB0/PWM0, Pin.Type = I/O. RB0/PWM0, Buffer Type = TTL. RB0/PWM0, Description = programmed for internal weak pull-ups on all inputs. Digital I/O.. RB0 PWM0 RB1/PWM1 RB1, Pin Number.SPDIP, SOIC = 22. RB0 PWM0 RB1/PWM1 RB1, Pin Number.QFN = 19. RB0 PWM0 RB1/PWM1 RB1, Pin.Type = O I/O O I/O. RB0 PWM0 RB1/PWM1 RB1, Buffer Type = TTL TTL TTL. RB0 PWM0 RB1/PWM1 RB1, Description = PWM Output 0. Digital I/O. PWM Output",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\n1. Digital I/O.. RB2/PWM2 RB2 PWM2 RB3/PWM3 RB3 PWM3, Pin Number.SPDIP, SOIC = 23 24. RB2/PWM2 RB2 PWM2 RB3/PWM3 RB3 PWM3, Pin Number.QFN = 20 21. RB2/PWM2 RB2 PWM2 RB3/PWM3 RB3 PWM3, Pin.Type = O I/O. RB2/PWM2 RB2 PWM2 RB3/PWM3 RB3 PWM3, Buffer Type = TTL TTL TTL TTL. RB2/PWM2 RB2 PWM2 RB3/PWM3 RB3 PWM3, Description = PWM Output 2. Digital I/O. PWM Output 3.. RB4/KBI0/PWM5 RB4, Pin Number.SPDIP, SOIC = 25.",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB4/KBI0/PWM5 RB4, Pin Number.QFN = 22. RB4/KBI0/PWM5 RB4, Pin.Type = O. RB4/KBI0/PWM5 RB4, Buffer Type = . RB4/KBI0/PWM5 RB4, Description = Digital I/O.. KBI0 PWM5, Pin Number.SPDIP, SOIC = . KBI0 PWM5, Pin Number.QFN = . KBI0 PWM5, Pin.Type = I/O I O. KBI0 PWM5, Buffer Type = TTL TTL. KBI0 PWM5, Description = Interrupt-on-change pin. PWM Output 5.. RB5/KBI1/PWM4/PGM RB5, Pin Number.SPDIP, SOIC = 26. RB5/KBI1/PWM4/PGM RB5, Pin Number.QFN = .",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB5/KBI1/PWM4/PGM RB5, Pin.Type = I/O. RB5/KBI1/PWM4/PGM RB5, Buffer Type = TTL TTL. RB5/KBI1/PWM4/PGM RB5, Description = . KBI1 PWM4, Pin Number.SPDIP, SOIC = . KBI1 PWM4, Pin Number.QFN = 23. KBI1 PWM4, Pin.Type = I O I/O. KBI1 PWM4, Buffer Type = TTL TTL. KBI1 PWM4, Description = Digital I/O. Interrupt-on-change pin. PWM Output 4.. RB6/KBI2/PGC RB6, Pin Number.SPDIP, SOIC = 27. RB6/KBI2/PGC RB6, Pin Number.QFN = 24. RB6/KBI2/PGC RB6, Pin.Type = I/O I",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. RB6/KBI2/PGC RB6, Buffer Type = TTL TTL. RB6/KBI2/PGC RB6, Description = Digital I/O.. KBI2, Pin Number.SPDIP, SOIC = . KBI2, Pin Number.QFN = . KBI2, Pin.Type = I/O. KBI2, Buffer Type = ST. KBI2, Description = Interrupt-on-change pin.. PGC RB7/KBI3/PGD, Pin Number.SPDIP, SOIC = 28. PGC RB7/KBI3/PGD, Pin Number.QFN = 25. PGC RB7/KBI3/PGD, Pin.Type = . PGC RB7/KBI3/PGD, Buffer Type = TTL. PGC RB7/KBI3/PGD, Description = In-Circuit Debugger and ICSP programming clock pin.. , Pin Number.SPDIP, SOIC = . , Pin Number.QFN = . ,",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin.Type = . , Buffer Type = . , Description = Digital I/O.. RB7, Pin Number.SPDIP, SOIC = . RB7, Pin Number.QFN = . RB7, Pin.Type = . RB7, Buffer Type = . RB7, Description = . KBI3, Pin Number.SPDIP, SOIC = . KBI3, Pin Number.QFN = . KBI3, Pin.Type = I. KBI3, Buffer Type = TTL. KBI3, Description = Interrupt-on-change pin.. PGD, Pin Number.SPDIP, SOIC = . PGD, Pin Number.QFN = . PGD, Pin.Type = I/O. PGD, Buffer Type = ST. PGD, Description = In-Circuit Debugger and ICSP programming data pin.\nLegend:\nTTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels\nO = Output\nCMOS = CMOS compatible input or output\nI\n= Input\nP = Power",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\n, Pin Number.SPDIP, SOIC = 11. , Pin Number.QFN = 8. , Pin.Type = . , Buffer Type = . , Description = PORTC is a bidirectional I/O port.. RC0/T1OSO/T1CKI RC0, Pin Number.SPDIP, SOIC = . RC0/T1OSO/T1CKI RC0, Pin Number.QFN = . RC0/T1OSO/T1CKI RC0, Pin.Type = I/O. RC0/T1OSO/T1CKI RC0, Buffer Type = ST. RC0/T1OSO/T1CKI RC0, Description = Digital I/O.. T1OSO, Pin Number.SPDIP, SOIC = . T1OSO, Pin Number.QFN = . T1OSO, Pin.Type = O. T1OSO, Buffer Type = -. T1OSO, Description = Timer1 oscillator output.. T1CKI, Pin Number.SPDIP, SOIC = . T1CKI, Pin",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.QFN = . T1CKI, Pin.Type = I. T1CKI, Buffer Type = ST. T1CKI, Description = Timer1 external clock input.. RC1/T1OSI/CCP2/FLTA, Pin Number.SPDIP, SOIC = 12. RC1/T1OSI/CCP2/FLTA, Pin Number.QFN = 9. RC1/T1OSI/CCP2/FLTA, Pin.Type = . RC1/T1OSI/CCP2/FLTA, Buffer Type = . RC1/T1OSI/CCP2/FLTA, Description = . RC1, Pin Number.SPDIP, SOIC = . RC1, Pin Number.QFN = . RC1, Pin.Type = I/O. RC1, Buffer Type = ST. RC1, Description = Digital I/O.. T1OSI, Pin Number.SPDIP, SOIC = . T1OSI, Pin Number.QFN = . T1OSI, Pin.Type = I.",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nT1OSI, Buffer Type = Analog. T1OSI, Description = Timer1 oscillator input.. CCP2, Pin Number.SPDIP, SOIC = . CCP2, Pin Number.QFN = . CCP2, Pin.Type = I/O. CCP2, Buffer Type = ST. CCP2, Description = Capture 2 input, Compare 2 output, PWM2 output.. FLTA, Pin Number.SPDIP, SOIC = . FLTA, Pin Number.QFN = . FLTA, Pin.Type = I. FLTA, Buffer Type = ST. FLTA, Description = Fault interrupt input pin.. RC2/CCP1, Pin Number.SPDIP, SOIC = 13. RC2/CCP1, Pin Number.QFN = 10. RC2/CCP1, Pin.Type = . RC2/CCP1, Buffer Type = . RC2/CCP1, Description = . RC2, Pin Number.SPDIP, SOIC = . RC2, Pin Number.QFN =",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. RC2, Pin.Type = I/O. RC2, Buffer Type = ST. RC2, Description = Digital I/O.. CCP1, Pin Number.SPDIP, SOIC = . CCP1, Pin Number.QFN = . CCP1, Pin.Type = I/O. CCP1, Buffer Type = ST. CCP1, Description = Capture 1 input/Compare 1 output/PWM1 output.. RC3/T0CKI/T5CKI/INT0, Pin Number.SPDIP, SOIC = 14. RC3/T0CKI/T5CKI/INT0, Pin Number.QFN = 11. RC3/T0CKI/T5CKI/INT0, Pin.Type = . RC3/T0CKI/T5CKI/INT0, Buffer Type = . RC3/T0CKI/T5CKI/INT0, Description = . RC3, Pin Number.SPDIP, SOIC = . RC3, Pin Number.QFN = . RC3, Pin.Type =",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. RC3, Buffer Type = ST. RC3, Description = Digital I/O.. T0CKI, Pin Number.SPDIP, SOIC = . T0CKI, Pin Number.QFN = . T0CKI, Pin.Type = I. T0CKI, Buffer Type = ST. T0CKI, Description = Timer0 alternate clock input.. T5CKI, Pin Number.SPDIP, SOIC = . T5CKI, Pin Number.QFN = . T5CKI, Pin.Type = I. T5CKI, Buffer Type = ST. T5CKI, Description = Timer5 alternate clock input.. INT0, Pin Number.SPDIP, SOIC = . INT0, Pin Number.QFN = . INT0, Pin.Type = I. INT0, Buffer Type = ST. INT0, Description = External Interrupt 0.. RC4/INT1/SDI/SDA, Pin Number.SPDIP, SOIC = 15. RC4/INT1/SDI/SDA, Pin Number.QFN = 12.",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC4/INT1/SDI/SDA, Pin.Type = . RC4/INT1/SDI/SDA, Buffer Type = . RC4/INT1/SDI/SDA, Description = . RC4, Pin Number.SPDIP, SOIC = . RC4, Pin Number.QFN = . RC4, Pin.Type = I/O. RC4, Buffer Type = ST. RC4, Description = Digital I/O.. INT1, Pin Number.SPDIP, SOIC = . INT1, Pin Number.QFN = . INT1, Pin.Type = I. INT1, Buffer Type = ST. INT1, Description = External Interrupt 1.. SDI, Pin Number.SPDIP, SOIC = . SDI, Pin Number.QFN = . SDI, Pin.Type = I. SDI, Buffer Type = ST. SDI, Description = SPI data. SDA, Pin Number.SPDIP, SOIC = . SDA, Pin Number.QFN = . SDA, Pin.Type =",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. SDA, Buffer Type = I 2 C. SDA, Description = in. I 2 C\u2122data I/O.. RC5/INT2/SCK/SCL, Pin Number.SPDIP, SOIC = 16. RC5/INT2/SCK/SCL, Pin Number.QFN = 13. RC5/INT2/SCK/SCL, Pin.Type = . RC5/INT2/SCK/SCL, Buffer Type = . RC5/INT2/SCK/SCL, Description = . RC5, Pin Number.SPDIP, SOIC = . RC5, Pin Number.QFN = . RC5, Pin.Type = I/O. RC5, Buffer Type = ST. RC5, Description = Digital I/O.. INT2, Pin Number.SPDIP, SOIC = . INT2, Pin Number.QFN = . INT2, Pin.Type = I. INT2, Buffer Type = ST. INT2, Description = External Interrupt 2.. SCK, Pin",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.SPDIP, SOIC = . SCK, Pin Number.QFN = . SCK, Pin.Type = I/O. SCK, Buffer Type = ST. SCK, Description = Synchronous serial clock input/output for SPI mode.. SCL, Pin Number.SPDIP, SOIC = . SCL, Pin Number.QFN = . SCL, Pin.Type = I/O. SCL, Buffer Type = I 2 C. SCL, Description = Synchronous serial clock input/output for I 2 C mode.. RC6/TX/CK/SS, Pin Number.SPDIP, SOIC = 17. RC6/TX/CK/SS, Pin Number.QFN = 14. RC6/TX/CK/SS, Pin.Type = . RC6/TX/CK/SS, Buffer Type = . RC6/TX/CK/SS, Description = . RC6, Pin Number.SPDIP, SOIC = . RC6, Pin Number.QFN = . RC6, Pin.Type =",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. RC6, Buffer Type = ST. RC6, Description = Digital I/O.. TX, Pin Number.SPDIP, SOIC = . TX, Pin Number.QFN = . TX, Pin.Type = O. TX, Buffer Type = -. TX, Description = EUSART asynchronous transmit.. CK, Pin Number.SPDIP, SOIC = . CK, Pin Number.QFN = . CK, Pin.Type = I/O. CK, Buffer Type = ST. CK, Description = EUSART synchronous clock (see related RX/DT).. SS, Pin Number.SPDIP, SOIC = . SS, Pin Number.QFN = . SS, Pin.Type = I. SS, Buffer Type = TTL. SS, Description = SPI slave select input.. RC7/RX/DT/SDO, Pin Number.SPDIP, SOIC = 18. RC7/RX/DT/SDO, Pin Number.QFN = 15.",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC7/RX/DT/SDO, Pin.Type = . RC7/RX/DT/SDO, Buffer Type = . RC7/RX/DT/SDO, Description = . RC7, Pin Number.SPDIP, SOIC = . RC7, Pin Number.QFN = . RC7, Pin.Type = I/O. RC7, Buffer Type = ST. RC7, Description = Digital I/O.. RX, Pin Number.SPDIP, SOIC = . RX, Pin Number.QFN = . RX, Pin.Type = I. RX, Buffer Type = ST. RX, Description = EUSART asynchronous receive.. DT, Pin Number.SPDIP, SOIC = . DT, Pin Number.QFN = . DT, Pin.Type = I/O. DT, Buffer Type = ST. DT, Description = EUSART synchronous data (see related TX/CK).. SDO, Pin Number.SPDIP, SOIC = . SDO, Pin",
    "TABLE 1-2: PIC18F2331/2431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.QFN = . SDO, Pin.Type = O. SDO, Buffer Type = -. SDO, Description = SPI data out.. VSS, Pin Number.SPDIP, SOIC = 8, 19. VSS, Pin Number.QFN = 5, 16. VSS, Pin.Type = P. VSS, Buffer Type = -. VSS, Description = Ground reference for logic and I/O pins.. VDD, Pin Number.SPDIP, SOIC = 7, 20. VDD, Pin Number.QFN = 4, 17. VDD, Pin.Type = P. VDD, Buffer Type = -. VDD, Description = Positive supply for logic and I/O pins.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI\n= Input\nO = Output\nP = Power",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS\nMCLR/VPP/RE3, Pin Number.PDIP = 1. MCLR/VPP/RE3, Pin Number.TQFP = 18. MCLR/VPP/RE3, Pin Number.QFN = 18. MCLR/VPP/RE3, Pin.Type = . MCLR/VPP/RE3, Buffer.Type = . MCLR/VPP/RE3, Description. = Master Clear (input) or programming voltage (input).. MCLR, Pin Number.PDIP = . MCLR, Pin Number.TQFP = . MCLR, Pin Number.QFN = . MCLR, Pin.Type = I. MCLR, Buffer.Type = ST. MCLR, Description. = Master Clear (Reset) input. This pin is an active-low Reset to the device.. VPP, Pin Number.PDIP = . VPP, Pin Number.TQFP = . VPP, Pin Number.QFN = . VPP, Pin.Type = P I. VPP, Buffer.Type = ST. VPP, Description. = Programming",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS\nvoltage input. Digital input. Available only when. RE3, Pin Number.PDIP = 13. RE3, Pin Number.TQFP = 30. RE3, Pin Number.QFN = 32. RE3, Pin.Type = . RE3, Buffer.Type = . RE3, Description. = Oscillator crystal or external clock input.. OSC1/CLKI/RA7 OSC1, Pin Number.PDIP = . OSC1/CLKI/RA7 OSC1, Pin Number.TQFP = . OSC1/CLKI/RA7 OSC1, Pin Number.QFN = . OSC1/CLKI/RA7 OSC1, Pin.Type = I. OSC1/CLKI/RA7 OSC1, Buffer.Type = ST. OSC1/CLKI/RA7 OSC1, Description. = Oscillator crystal input or external clock source input. ST buffer when configured in RC mode; CMOS otherwise.. CLKI, Pin Number.PDIP = . CLKI, Pin Number.TQFP = .",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS\nCLKI, Pin Number.QFN = . CLKI, Pin.Type = I. CLKI, Buffer.Type = CMOS. CLKI, Description. = External clock source input. Always associated with pin function OSC1. (See related OSC1/CLKI, OSC2/CLKO pins.). RA7, Pin Number.PDIP = . RA7, Pin Number.TQFP = . RA7, Pin Number.QFN = . RA7, Pin.Type = I/O. RA7, Buffer.Type = TTL. RA7, Description. = General purpose I/O pin.. OSC2/CLKO/RA6, Pin Number.PDIP = 14. OSC2/CLKO/RA6, Pin Number.TQFP = 31. OSC2/CLKO/RA6, Pin Number.QFN = 33. OSC2/CLKO/RA6, Pin.Type = . OSC2/CLKO/RA6, Buffer.Type = . OSC2/CLKO/RA6, Description. =",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS\nOscillator crystal or clock output.. OSC2, Pin Number.PDIP = . OSC2, Pin Number.TQFP = . OSC2, Pin Number.QFN = . OSC2, Pin.Type = O. OSC2, Buffer.Type = -. OSC2, Description. = Oscillator crystal output. Connects to crystal or resonator in Crystal Oscillator mode.. CLKO, Pin Number.PDIP = . CLKO, Pin Number.TQFP = . CLKO, Pin Number.QFN = . CLKO, Pin.Type = O. CLKO, Buffer.Type = -. CLKO, Description. = In RC mode, OSC2 pin outputs CLKO, which has 1/4 the frequency of OSC1 and denotes the instruction cycle rate.. RA6, Pin Number.PDIP = . RA6, Pin Number.TQFP = . RA6, Pin Number.QFN = . RA6, Pin.Type = I/O. RA6, Buffer.Type = TTL. RA6, Description.",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS\n= General purpose I/O pin.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI\n= Input\nO = Output\nP\n= Power\nNote 1: RC3 is the alternate pin for T0CKI/T5CKI; RC4 is the alternate pin for SDI/SDA; RC5 is the alternate pin for SCK/SCL; RC7 is the alternate pin for SDO.\n2: RD4 is the alternate pin for FLTA.\n3: RD5 is the alternate pin for PWM4.",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRA0/AN0 RA0 AN0, Pin Number.PDIP = 2. RA0/AN0 RA0 AN0, Pin Number.TQFP = 19. RA0/AN0 RA0 AN0, Pin Number.QFN = 19. RA0/AN0 RA0 AN0, Pin.Type = I/O I. RA0/AN0 RA0 AN0, Buffer.Type = TTL Analog. RA0/AN0 RA0 AN0, Description. = Digital I/O. Analog Input 0.. RA1/AN1 RA1 AN1, Pin Number.PDIP = 3. RA1/AN1 RA1 AN1, Pin Number.TQFP = 20. RA1/AN1 RA1 AN1, Pin Number.QFN = 20. RA1/AN1 RA1 AN1, Pin.Type = I/O I. RA1/AN1 RA1 AN1, Buffer.Type = TTL Analog. RA1/AN1 RA1 AN1, Description. = Digital I/O. Analog Input 1..",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRA2/AN2/V REF -/CAP1/ INDX RA2, Pin Number.PDIP = 4. RA2/AN2/V REF -/CAP1/ INDX RA2, Pin Number.TQFP = 21. RA2/AN2/V REF -/CAP1/ INDX RA2, Pin Number.QFN = 21. RA2/AN2/V REF -/CAP1/ INDX RA2, Pin.Type = I/O I I I I. RA2/AN2/V REF -/CAP1/ INDX RA2, Buffer.Type = TTL Analog Analog ST ST. RA2/AN2/V REF -/CAP1/ INDX RA2, Description. = Digital I/O. Analog Input 2. A/D reference voltage (low) input. Input Capture Pin 1. Quadrature Encoder Interface index input pin.. RA3/AN3/VREF+/ CAP2/QEA RA3, Pin Number.PDIP = 5. RA3/AN3/VREF+/",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nCAP2/QEA RA3, Pin Number.TQFP = 22. RA3/AN3/VREF+/ CAP2/QEA RA3, Pin Number.QFN = 22. RA3/AN3/VREF+/ CAP2/QEA RA3, Pin.Type = I/O I I I I. RA3/AN3/VREF+/ CAP2/QEA RA3, Buffer.Type = TTL Analog Analog ST ST. RA3/AN3/VREF+/ CAP2/QEA RA3, Description. = Digital I/O. Analog Input 3. A/D reference voltage (high) input. Input Capture Pin 2.. RA4/AN4/CAP3/QEB RA4 AN4 CAP3 QEB, Pin Number.PDIP = 6. RA4/AN4/CAP3/QEB RA4 AN4 CAP3 QEB, Pin Number.TQFP = 23. RA4/AN4/CAP3/QEB RA4 AN4 CAP3 QEB, Pin Number.QFN = 23.",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRA4/AN4/CAP3/QEB RA4 AN4 CAP3 QEB, Pin.Type = I/O I I I. RA4/AN4/CAP3/QEB RA4 AN4 CAP3 QEB, Buffer.Type = TTL Analog ST ST. RA4/AN4/CAP3/QEB RA4 AN4 CAP3 QEB, Description. = Digital I/O. Analog Input 4. Input Capture Pin 3. Quadrature Encoder Interface Channel B input pin.. RA5/AN5/LVDIN RA5 AN5 LVDIN, Pin Number.PDIP = 7. RA5/AN5/LVDIN RA5 AN5 LVDIN, Pin Number.TQFP = 24. RA5/AN5/LVDIN RA5 AN5 LVDIN, Pin Number.QFN = 24. RA5/AN5/LVDIN RA5 AN5 LVDIN, Pin.Type = I/O I I. RA5/AN5/LVDIN RA5 AN5 LVDIN, Buffer.Type",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= TTL Analog Analog. RA5/AN5/LVDIN RA5 AN5 LVDIN, Description. = Digital I/O. Analog Input 5. Low-Voltage Detect input.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI\n= Input\nO = Output\nP = Power\nNote 1: RC3 is the alternate pin for T0CKI/T5CKI; RC4 is the alternate pin for SDI/SDA; RC5 is the alternate pin for SCK/SCL; RC7 is the alternate pin for SDO.\n2: RD4 is the alternate pin for FLTA.\n3: RD5 is the alternate pin for PWM4.",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\n, Pin Number.PDIP = 33. , Pin Number.TQFP = 8. , Pin Number.QFN = 9. , Pin.Type = . , Buffer.Type = . , Description = . RB0/PWM0 RB0, Pin Number.PDIP = . RB0/PWM0 RB0, Pin Number.TQFP = . RB0/PWM0 RB0, Pin Number.QFN = . RB0/PWM0 RB0, Pin.Type = I/O. RB0/PWM0 RB0, Buffer.Type = TTL. RB0/PWM0 RB0, Description = Digital I/O.. PWM0, Pin Number.PDIP = . PWM0, Pin Number.TQFP = . PWM0, Pin Number.QFN = . PWM0, Pin.Type = O. PWM0, Buffer.Type = TTL. PWM0, Description = PWM Output 0.. RB1/PWM1, Pin",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PDIP = 34. RB1/PWM1, Pin Number.TQFP = 9. RB1/PWM1, Pin Number.QFN = 10. RB1/PWM1, Pin.Type = . RB1/PWM1, Buffer.Type = . RB1/PWM1, Description = . RB1, Pin Number.PDIP = . RB1, Pin Number.TQFP = . RB1, Pin Number.QFN = . RB1, Pin.Type = I/O. RB1, Buffer.Type = TTL. RB1, Description = Digital I/O.. PWM1, Pin Number.PDIP = . PWM1, Pin Number.TQFP = . PWM1, Pin Number.QFN = . PWM1, Pin.Type = O. PWM1, Buffer.Type = TTL. PWM1, Description = PWM Output 1.. RB2/PWM2, Pin Number.PDIP = 35.",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB2/PWM2, Pin Number.TQFP = 10. RB2/PWM2, Pin Number.QFN = 11. RB2/PWM2, Pin.Type = . RB2/PWM2, Buffer.Type = . RB2/PWM2, Description = . RB2, Pin Number.PDIP = . RB2, Pin Number.TQFP = . RB2, Pin Number.QFN = . RB2, Pin.Type = I/O. RB2, Buffer.Type = TTL. RB2, Description = Digital I/O.. PWM2, Pin Number.PDIP = . PWM2, Pin Number.TQFP = . PWM2, Pin Number.QFN = . PWM2, Pin.Type = O. PWM2, Buffer.Type = TTL. PWM2, Description = PWM Output 2.. RB3/PWM3, Pin Number.PDIP = 36. RB3/PWM3, Pin",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.TQFP = 11. RB3/PWM3, Pin Number.QFN = 12. RB3/PWM3, Pin.Type = . RB3/PWM3, Buffer.Type = . RB3/PWM3, Description = . RB3 PWM3, Pin Number.PDIP = . RB3 PWM3, Pin Number.TQFP = . RB3 PWM3, Pin Number.QFN = . RB3 PWM3, Pin.Type = I/O O. RB3 PWM3, Buffer.Type = TTL TTL. RB3 PWM3, Description = Digital I/O. PWM Output 3.. RB4/KBI0/PWM5, Pin Number.PDIP = 37. RB4/KBI0/PWM5, Pin Number.TQFP = 14. RB4/KBI0/PWM5, Pin Number.QFN = 14. RB4/KBI0/PWM5, Pin.Type =",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. RB4/KBI0/PWM5, Buffer.Type = . RB4/KBI0/PWM5, Description = . RB4, Pin Number.PDIP = . RB4, Pin Number.TQFP = . RB4, Pin Number.QFN = . RB4, Pin.Type = I/O. RB4, Buffer.Type = TTL. RB4, Description = Digital I/O.. KBI0, Pin Number.PDIP = . KBI0, Pin Number.TQFP = . KBI0, Pin Number.QFN = . KBI0, Pin.Type = I O. KBI0, Buffer.Type = TTL TTL. KBI0, Description = Interrupt-on-change pin. PWM Output 5.. RB5/KBI1/PWM4/, Pin Number.PDIP = 38. RB5/KBI1/PWM4/, Pin Number.TQFP = 15. RB5/KBI1/PWM4/, Pin",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.QFN = 15. RB5/KBI1/PWM4/, Pin.Type = . RB5/KBI1/PWM4/, Buffer.Type = . RB5/KBI1/PWM4/, Description = . PGM RB5, Pin Number.PDIP = . PGM RB5, Pin Number.TQFP = . PGM RB5, Pin Number.QFN = . PGM RB5, Pin.Type = I/O. PGM RB5, Buffer.Type = TTL. PGM RB5, Description = Digital I/O.. KBI1, Pin Number.PDIP = . KBI1, Pin Number.TQFP = . KBI1, Pin Number.QFN = . KBI1, Pin.Type = I. KBI1, Buffer.Type = TTL TTL. KBI1, Description = Interrupt-on-change pin.. PWM4, Pin Number.PDIP = . PWM4, Pin Number.TQFP = .",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPWM4, Pin Number.QFN = . PWM4, Pin.Type = O. PWM4, Buffer.Type = . PWM4, Description = PWM Output 4.. PGM, Pin Number.PDIP = . PGM, Pin Number.TQFP = . PGM, Pin Number.QFN = . PGM, Pin.Type = I/O. PGM, Buffer.Type = ST. PGM, Description = Single-Supply ICSP\u2122 Programming entry. RB6/KBI2/PGC, Pin Number.PDIP = 39. RB6/KBI2/PGC, Pin Number.TQFP = 16. RB6/KBI2/PGC, Pin Number.QFN = 16. RB6/KBI2/PGC, Pin.Type = . RB6/KBI2/PGC, Buffer.Type = . RB6/KBI2/PGC, Description = . RB6, Pin Number.PDIP = . RB6, Pin Number.TQFP = . RB6,",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin Number.QFN = . RB6, Pin.Type = I/O. RB6, Buffer.Type = TTL. RB6, Description = Digital I/O.. KBI2, Pin Number.PDIP = . KBI2, Pin Number.TQFP = . KBI2, Pin Number.QFN = . KBI2, Pin.Type = I. KBI2, Buffer.Type = TTL. KBI2, Description = Interrupt-on-change pin.. PGC, Pin Number.PDIP = . PGC, Pin Number.TQFP = . PGC, Pin Number.QFN = . PGC, Pin.Type = I/O. PGC, Buffer.Type = ST. PGC, Description = In-Circuit Debugger and ICSP programming clock pin.. RB7/KBI3/PGD, Pin Number.PDIP = 40. RB7/KBI3/PGD, Pin Number.TQFP = 17. RB7/KBI3/PGD, Pin Number.QFN = 17.",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB7/KBI3/PGD, Pin.Type = . RB7/KBI3/PGD, Buffer.Type = . RB7/KBI3/PGD, Description = . , Pin Number.PDIP = . , Pin Number.TQFP = . , Pin Number.QFN = . , Pin.Type = I/O. , Buffer.Type = TTL. , Description = Digital I/O.. , Pin Number.PDIP = . , Pin Number.TQFP = . , Pin Number.QFN = . , Pin.Type = I. , Buffer.Type = TTL. , Description = Interrupt-on-change pin.. PGD, Pin Number.PDIP = . PGD, Pin Number.TQFP = . PGD, Pin Number.QFN = . PGD, Pin.Type = . PGD, Buffer.Type = ST. PGD, Description = . RB7, Pin Number.PDIP = . RB7, Pin Number.TQFP = . RB7, Pin Number.QFN = . RB7,",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin.Type = . RB7, Buffer.Type = . RB7, Description = . KBI3, Pin Number.PDIP = . KBI3, Pin Number.TQFP = . KBI3, Pin Number.QFN = . KBI3, Pin.Type = I/O. KBI3, Buffer.Type = . KBI3, Description = . , Pin Number.PDIP = . , Pin Number.TQFP = . , Pin Number.QFN = . , Pin.Type = . , Buffer.Type = . , Description = In-Circuit Debugger and ICSP programming data pin.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI\n= Input\nO = Output\nP\n= Power\nNote 1: RC3 is the alternate pin for T0CKI/T5CKI; RC4 is the alternate pin for SDI/SDA; RC5 is the alternate pin for SCK/SCL; RC7 is the alternate pin for SDO.",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\n2: RD4 is the alternate pin for FLTA.\n3: RD5 is the alternate pin for PWM4.",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC0/T1OSO/T1CKI, Pin Number.PDIP = 15. RC0/T1OSO/T1CKI, Pin Number.TQFP = 32. RC0/T1OSO/T1CKI, Pin Number.QFN = 34. RC0/T1OSO/T1CKI, Pin.Type = I/O. RC0/T1OSO/T1CKI, Buffer.Type = ST. RC0/T1OSO/T1CKI, Description. = . RC0 T1OSO, Pin Number.PDIP = . RC0 T1OSO, Pin Number.TQFP = . RC0 T1OSO, Pin Number.QFN = . RC0 T1OSO, Pin.Type = O. RC0 T1OSO, Buffer.Type = -. RC0 T1OSO, Description. = Digital I/O. Timer1 oscillator output.. T1CKI, Pin Number.PDIP = . T1CKI, Pin Number.TQFP = . T1CKI, Pin Number.QFN = . T1CKI,",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin.Type = I. T1CKI, Buffer.Type = ST. T1CKI, Description. = Timer1 external clock input.. RC1/T1OSI/CCP2/, Pin Number.PDIP = 16. RC1/T1OSI/CCP2/, Pin Number.TQFP = 35. RC1/T1OSI/CCP2/, Pin Number.QFN = 35. RC1/T1OSI/CCP2/, Pin.Type = . RC1/T1OSI/CCP2/, Buffer.Type = . RC1/T1OSI/CCP2/, Description. = . FLTA, Pin Number.PDIP = . FLTA, Pin Number.TQFP = . FLTA, Pin Number.QFN = . FLTA, Pin.Type = . FLTA, Buffer.Type = . FLTA, Description. = . RC1, Pin Number.PDIP = . RC1, Pin Number.TQFP = . RC1, Pin Number.QFN = . RC1, Pin.Type =",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. RC1, Buffer.Type = ST. RC1, Description. = Digital I/O.. T1OSI, Pin Number.PDIP = . T1OSI, Pin Number.TQFP = . T1OSI, Pin Number.QFN = . T1OSI, Pin.Type = I. T1OSI, Buffer.Type = CMOS. T1OSI, Description. = Timer1 oscillator input.. CCP2, Pin Number.PDIP = . CCP2, Pin Number.TQFP = . CCP2, Pin Number.QFN = . CCP2, Pin.Type = I/O. CCP2, Buffer.Type = ST. CCP2, Description. = Capture 2 input, Compare 2 output, PWM2. FLTA, Pin Number.PDIP = . FLTA, Pin Number.TQFP = . FLTA, Pin Number.QFN = . FLTA, Pin.Type = I. FLTA, Buffer.Type = ST. FLTA, Description. = Fault interrupt input pin..",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC2/CCP1/FLTB, Pin Number.PDIP = 17. RC2/CCP1/FLTB, Pin Number.TQFP = 36. RC2/CCP1/FLTB, Pin Number.QFN = 36. RC2/CCP1/FLTB, Pin.Type = . RC2/CCP1/FLTB, Buffer.Type = . RC2/CCP1/FLTB, Description. = . RC2, Pin Number.PDIP = . RC2, Pin Number.TQFP = . RC2, Pin Number.QFN = . RC2, Pin.Type = I/O. RC2, Buffer.Type = ST. RC2, Description. = Digital I/O.. CCP1, Pin Number.PDIP = . CCP1, Pin Number.TQFP = . CCP1, Pin Number.QFN = . CCP1, Pin.Type = I/O. CCP1, Buffer.Type = ST. CCP1, Description. = Capture 1",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\ninput/Compare 1 output/PWM1 output.. FLTB, Pin Number.PDIP = . FLTB, Pin Number.TQFP = . FLTB, Pin Number.QFN = . FLTB, Pin.Type = I. FLTB, Buffer.Type = ST. FLTB, Description. = Fault interrupt input pin.. RC3/T0CKI/T5CKI/ INT0, Pin Number.PDIP = 18. RC3/T0CKI/T5CKI/ INT0, Pin Number.TQFP = 37. RC3/T0CKI/T5CKI/ INT0, Pin Number.QFN = 37. RC3/T0CKI/T5CKI/ INT0, Pin.Type = . RC3/T0CKI/T5CKI/ INT0, Buffer.Type = . RC3/T0CKI/T5CKI/ INT0, Description. = . RC3 (1), Pin Number.PDIP = . RC3 (1), Pin Number.TQFP = . RC3",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\n(1), Pin Number.QFN = . RC3 (1), Pin.Type = I/O. RC3 (1), Buffer.Type = ST. RC3 (1), Description. = Digital I/O.. T0CKI, Pin Number.PDIP = . T0CKI, Pin Number.TQFP = . T0CKI, Pin Number.QFN = . T0CKI, Pin.Type = I. T0CKI, Buffer.Type = ST. T0CKI, Description. = Timer0 alternate clock input.. T5CKI (1), Pin Number.PDIP = . T5CKI (1), Pin Number.TQFP = . T5CKI (1), Pin Number.QFN = . T5CKI (1), Pin.Type = . T5CKI (1), Buffer.Type = . T5CKI (1), Description. = . , Pin Number.PDIP = . , Pin Number.TQFP = . , Pin Number.QFN = . , Pin.Type = I. ,",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = ST. , Description. = Timer5 alternate clock input.. INT0, Pin Number.PDIP = . INT0, Pin Number.TQFP = . INT0, Pin Number.QFN = . INT0, Pin.Type = I. INT0, Buffer.Type = ST. INT0, Description. = External Interrupt 0.. RC4/INT1/SDI/SDA, Pin Number.PDIP = 23. RC4/INT1/SDI/SDA, Pin Number.TQFP = 42. RC4/INT1/SDI/SDA, Pin Number.QFN = 42. RC4/INT1/SDI/SDA, Pin.Type = . RC4/INT1/SDI/SDA, Buffer.Type = . RC4/INT1/SDI/SDA, Description. = . RC4, Pin Number.PDIP = . RC4, Pin Number.TQFP = . RC4, Pin Number.QFN = . RC4, Pin.Type = I/O. RC4,",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nBuffer.Type = ST. RC4, Description. = Digital I/O.. INT1, Pin Number.PDIP = . INT1, Pin Number.TQFP = . INT1, Pin Number.QFN = . INT1, Pin.Type = I. INT1, Buffer.Type = ST. INT1, Description. = External Interrupt 1.. SDI (1), Pin Number.PDIP = . SDI (1), Pin Number.TQFP = . SDI (1), Pin Number.QFN = . SDI (1), Pin.Type = I. SDI (1), Buffer.Type = ST. SDI (1), Description. = SPI data in.. , Pin Number.PDIP = . , Pin Number.TQFP = . , Pin Number.QFN = . , Pin.Type = . , Buffer.Type = 2. , Description. = I C\u2122data. SDA (1), Pin Number.PDIP = . SDA (1), Pin Number.TQFP = . SDA",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\n(1), Pin Number.QFN = . SDA (1), Pin.Type = I/O. SDA (1), Buffer.Type = I C. SDA (1), Description. = 2 I/O.. RC5/INT2/SCK/SCL, Pin Number.PDIP = 24. RC5/INT2/SCK/SCL, Pin Number.TQFP = 43. RC5/INT2/SCK/SCL, Pin Number.QFN = 43. RC5/INT2/SCK/SCL, Pin.Type = . RC5/INT2/SCK/SCL, Buffer.Type = . RC5/INT2/SCK/SCL, Description. = . RC5, Pin Number.PDIP = . RC5, Pin Number.TQFP = . RC5, Pin Number.QFN = . RC5, Pin.Type = I/O. RC5, Buffer.Type = ST. RC5, Description. = Digital I/O.. INT2, Pin",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PDIP = . INT2, Pin Number.TQFP = . INT2, Pin Number.QFN = . INT2, Pin.Type = I. INT2, Buffer.Type = ST. INT2, Description. = External Interrupt 2.. SCK (1), Pin Number.PDIP = . SCK (1), Pin Number.TQFP = . SCK (1), Pin Number.QFN = . SCK (1), Pin.Type = I/O. SCK (1), Buffer.Type = ST. SCK (1), Description. = Synchronous serial clock input/output. SCL (1), Pin Number.PDIP = . SCL (1), Pin Number.TQFP = . SCL (1), Pin Number.QFN = . SCL (1), Pin.Type = I/O. SCL (1), Buffer.Type = I 2 C. SCL (1), Description. = for SPI mode. Synchronous serial clock input/output for I",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\n2 C mode.. RC6/TX/CK/SS, Pin Number.PDIP = 25. RC6/TX/CK/SS, Pin Number.TQFP = 44. RC6/TX/CK/SS, Pin Number.QFN = 44. RC6/TX/CK/SS, Pin.Type = . RC6/TX/CK/SS, Buffer.Type = . RC6/TX/CK/SS, Description. = . RC6, Pin Number.PDIP = . RC6, Pin Number.TQFP = . RC6, Pin Number.QFN = . RC6, Pin.Type = I/O. RC6, Buffer.Type = ST. RC6, Description. = Digital I/O.. TX, Pin Number.PDIP = . TX, Pin Number.TQFP = . TX, Pin Number.QFN = . TX, Pin.Type = O. TX, Buffer.Type = -. TX, Description. = EUSART asynchronous transmit.. CK, Pin Number.PDIP = . CK, Pin",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.TQFP = . CK, Pin Number.QFN = . CK, Pin.Type = I/O. CK, Buffer.Type = ST. CK, Description. = EUSART synchronous clock (see related RX/DT).. SS, Pin Number.PDIP = . SS, Pin Number.TQFP = . SS, Pin Number.QFN = . SS, Pin.Type = I. SS, Buffer.Type = ST. SS, Description. = SPI slave select input.. RC7/RX/DT/SDO, Pin Number.PDIP = 26. RC7/RX/DT/SDO, Pin Number.TQFP = 1. RC7/RX/DT/SDO, Pin Number.QFN = 1. RC7/RX/DT/SDO, Pin.Type = . RC7/RX/DT/SDO, Buffer.Type = . RC7/RX/DT/SDO, Description. = . RC7, Pin Number.PDIP = . RC7, Pin",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.TQFP = . RC7, Pin Number.QFN = . RC7, Pin.Type = I/O. RC7, Buffer.Type = ST. RC7, Description. = Digital I/O.. RX, Pin Number.PDIP = . RX, Pin Number.TQFP = . RX, Pin Number.QFN = . RX, Pin.Type = I. RX, Buffer.Type = ST. RX, Description. = EUSART asynchronous receive.. DT, Pin Number.PDIP = . DT, Pin Number.TQFP = . DT, Pin Number.QFN = . DT, Pin.Type = I/O. DT, Buffer.Type = ST. DT, Description. = EUSART synchronous data (see related TX/CK).. SDO (1), Pin Number.PDIP = . SDO (1), Pin Number.TQFP = . SDO (1), Pin Number.QFN = . SDO (1), Pin.Type =",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nO. SDO (1), Buffer.Type = -. SDO (1), Description. = SPI data out.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI\n= Input\nO = Output\nP = Power\nNote 1: RC3 is the alternate pin for T0CKI/T5CKI; RC4 is the alternate pin for SDI/SDA; RC5 is the alternate pin for SCK/SCL; RC7 is the alternate pin for SDO.\n2: RD4 is the alternate pin for FLTA.\n3: RD5 is the alternate pin for PWM4.",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD0/T0CKI/T5CKI, Pin Number.PDIP = 19. RD0/T0CKI/T5CKI, Pin Number.TQFP = 38. RD0/T0CKI/T5CKI, Pin Number.QFN = 38. RD0/T0CKI/T5CKI, Pin.Type = . RD0/T0CKI/T5CKI, Buffer.Type = . RD0/T0CKI/T5CKI, Description. = PORTD is a bidirectional I/O port.. RD0, Pin Number.PDIP = . RD0, Pin Number.TQFP = . RD0, Pin Number.QFN = . RD0, Pin.Type = I/O. RD0, Buffer.Type = ST. RD0, Description. = Digital I/O.. T0CKI, Pin Number.PDIP = . T0CKI, Pin Number.TQFP = . T0CKI, Pin Number.QFN = . T0CKI, Pin.Type = I. T0CKI, Buffer.Type =",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nST. T0CKI, Description. = Timer0 external clock input.. T5CKI, Pin Number.PDIP = . T5CKI, Pin Number.TQFP = . T5CKI, Pin Number.QFN = . T5CKI, Pin.Type = I. T5CKI, Buffer.Type = ST. T5CKI, Description. = Timer5 input clock.. RD1/SDO, Pin Number.PDIP = 20. RD1/SDO, Pin Number.TQFP = 39. RD1/SDO, Pin Number.QFN = 39. RD1/SDO, Pin.Type = . RD1/SDO, Buffer.Type = . RD1/SDO, Description. = . RD1, Pin Number.PDIP = . RD1, Pin Number.TQFP = . RD1, Pin Number.QFN = . RD1, Pin.Type = I/O. RD1, Buffer.Type = ST. RD1, Description. = Digital I/O.. SDO (1), Pin Number.PDIP = .",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nSDO (1), Pin Number.TQFP = . SDO (1), Pin Number.QFN = . SDO (1), Pin.Type = O. SDO (1), Buffer.Type = -. SDO (1), Description. = SPI data out.. RD2/SDI/SDA, Pin Number.PDIP = 21. RD2/SDI/SDA, Pin Number.TQFP = 40. RD2/SDI/SDA, Pin Number.QFN = 40. RD2/SDI/SDA, Pin.Type = . RD2/SDI/SDA, Buffer.Type = . RD2/SDI/SDA, Description. = . RD2, Pin Number.PDIP = . RD2, Pin Number.TQFP = . RD2, Pin Number.QFN = . RD2, Pin.Type = I/O. RD2, Buffer.Type = ST. RD2, Description. = Digital I/O.. SDI (1), Pin Number.PDIP =",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. SDI (1), Pin Number.TQFP = . SDI (1), Pin Number.QFN = . SDI (1), Pin.Type = I. SDI (1), Buffer.Type = ST. SDI (1), Description. = SPI data in.. SDA (1), Pin Number.PDIP = . SDA (1), Pin Number.TQFP = . SDA (1), Pin Number.QFN = . SDA (1), Pin.Type = I/O. SDA (1), Buffer.Type = ST. SDA (1), Description. = I 2 C\u2122data I/O.. RD3/SCK/SCL, Pin Number.PDIP = 22. RD3/SCK/SCL, Pin Number.TQFP = 41. RD3/SCK/SCL, Pin Number.QFN = 41. RD3/SCK/SCL, Pin.Type = . RD3/SCK/SCL, Buffer.Type = .",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD3/SCK/SCL, Description. = . RD3, Pin Number.PDIP = . RD3, Pin Number.TQFP = . RD3, Pin Number.QFN = . RD3, Pin.Type = I/O. RD3, Buffer.Type = ST. RD3, Description. = Digital I/O.. SCK (1), Pin Number.PDIP = . SCK (1), Pin Number.TQFP = . SCK (1), Pin Number.QFN = . SCK (1), Pin.Type = I/O. SCK (1), Buffer.Type = ST. SCK (1), Description. = Synchronous serial clock input/output for SPI mode.. SCL (1), Pin Number.PDIP = . SCL (1), Pin Number.TQFP = . SCL (1), Pin Number.QFN = . SCL (1), Pin.Type = . SCL (1), Buffer.Type = . SCL (1),",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nDescription. = 2. , Pin Number.PDIP = . , Pin Number.TQFP = . , Pin Number.QFN = . , Pin.Type = I/O. , Buffer.Type = ST. , Description. = Synchronous serial clock input/output for I C mode.. RD4/FLTA, Pin Number.PDIP = 27. RD4/FLTA, Pin Number.TQFP = 2. RD4/FLTA, Pin Number.QFN = 2. RD4/FLTA, Pin.Type = . RD4/FLTA, Buffer.Type = . RD4/FLTA, Description. = . RD4, Pin Number.PDIP = . RD4, Pin Number.TQFP = . RD4, Pin Number.QFN = . RD4, Pin.Type = I/O. RD4, Buffer.Type = ST. RD4, Description. = Digital I/O.. FLTA (2), Pin Number.PDIP = . FLTA (2), Pin Number.TQFP = . FLTA",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\n(2), Pin Number.QFN = . FLTA (2), Pin.Type = I. FLTA (2), Buffer.Type = ST. FLTA (2), Description. = Fault interrupt input pin.. RD5/PWM4, Pin Number.PDIP = 28. RD5/PWM4, Pin Number.TQFP = 3. RD5/PWM4, Pin Number.QFN = 3. RD5/PWM4, Pin.Type = . RD5/PWM4, Buffer.Type = . RD5/PWM4, Description. = . RD5, Pin Number.PDIP = . RD5, Pin Number.TQFP = . RD5, Pin Number.QFN = . RD5, Pin.Type = I/O. RD5, Buffer.Type = ST. RD5, Description. = Digital I/O.. PWM4 (3), Pin Number.PDIP = . PWM4 (3), Pin Number.TQFP = .",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPWM4 (3), Pin Number.QFN = . PWM4 (3), Pin.Type = O. PWM4 (3), Buffer.Type = TTL. PWM4 (3), Description. = PWM Output 4.. RD6/PWM6, Pin Number.PDIP = 29. RD6/PWM6, Pin Number.TQFP = 4. RD6/PWM6, Pin Number.QFN = 4. RD6/PWM6, Pin.Type = . RD6/PWM6, Buffer.Type = . RD6/PWM6, Description. = . RD6, Pin Number.PDIP = . RD6, Pin Number.TQFP = . RD6, Pin Number.QFN = . RD6, Pin.Type = I/O. RD6, Buffer.Type = ST. RD6, Description. = Digital I/O.. PWM6, Pin Number.PDIP = . PWM6, Pin",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.TQFP = . PWM6, Pin Number.QFN = . PWM6, Pin.Type = O. PWM6, Buffer.Type = TTL. PWM6, Description. = PWM Output 6.. RD7/PWM7, Pin Number.PDIP = 30. RD7/PWM7, Pin Number.TQFP = 5. RD7/PWM7, Pin Number.QFN = 5. RD7/PWM7, Pin.Type = . RD7/PWM7, Buffer.Type = . RD7/PWM7, Description. = . RD7, Pin Number.PDIP = . RD7, Pin Number.TQFP = . RD7, Pin Number.QFN = . RD7, Pin.Type = I/O. RD7, Buffer.Type = ST. RD7, Description. = Digital I/O.. PWM7, Pin Number.PDIP = . PWM7, Pin Number.TQFP = .",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPWM7, Pin Number.QFN = . PWM7, Pin.Type = O. PWM7, Buffer.Type = TTL. PWM7, Description. = PWM Output 7.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI\n= Input\nO = Output\nP\n= Power\nNote 1: RC3 is the alternate pin for T0CKI/T5CKI; RC4 is the alternate pin for SDI/SDA; RC5 is the alternate pin for SCK/SCL; RC7 is the alternate pin for SDO.\n2: RD4 is the alternate pin for FLTA.\n3: RD5 is the alternate pin for PWM4.",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRE0/AN6 RE0 AN6, Pin Number.PDIP = 8. RE0/AN6 RE0 AN6, Pin Number.TQFP = 25. RE0/AN6 RE0 AN6, Pin Number.QFN = 25. RE0/AN6 RE0 AN6, Pin.Type = I/O I. RE0/AN6 RE0 AN6, Buffer.Type = ST Analog. RE0/AN6 RE0 AN6, Description. = Digital I/O. Analog Input 6.. RE1/AN7 RE1 AN7, Pin Number.PDIP = 9. RE1/AN7 RE1 AN7, Pin Number.TQFP = 26. RE1/AN7 RE1 AN7, Pin Number.QFN = 26. RE1/AN7 RE1 AN7, Pin.Type = I/O I. RE1/AN7 RE1 AN7, Buffer.Type = ST Analog. RE1/AN7 RE1 AN7, Description. = Digital I/O. Analog Input 7.. RE2/AN8",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRE2 AN8, Pin Number.PDIP = 10. RE2/AN8 RE2 AN8, Pin Number.TQFP = 27. RE2/AN8 RE2 AN8, Pin Number.QFN = 27. RE2/AN8 RE2 AN8, Pin.Type = I/O I. RE2/AN8 RE2 AN8, Buffer.Type = ST Analog. RE2/AN8 RE2 AN8, Description. = Digital I/O. Analog Input 8.. VSS, Pin Number.PDIP = 12, 31. VSS, Pin Number.TQFP = 6, 29. VSS, Pin Number.QFN = 6, 30, 31. VSS, Pin.Type = P. VSS, Buffer.Type = -. VSS, Description. = Ground reference for logic and I/O pins.. VDD, Pin Number.PDIP = 11, 32. VDD, Pin Number.TQFP = 7, 28. VDD, Pin Number.QFN = 7, 8, 28, 29. VDD,",
    "TABLE 1-3: PIC18F4331/4431 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin.Type = P. VDD, Buffer.Type = -. VDD, Description. = Positive supply for logic and I/O pins.. NC, Pin Number.PDIP = -. NC, Pin Number.TQFP = 12,13, 33, 34. NC, Pin Number.QFN = 13. NC, Pin.Type = NC. NC, Buffer.Type = NC. NC, Description. = No connect.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nI\n= Input\nO = Output\nP = Power\nNote 1: RC3 is the alternate pin for T0CKI/T5CKI; RC4 is the alternate pin for SDI/SDA; RC5 is the alternate pin for SCK/SCL; RC7 is the alternate pin for SDO.\n2: RD4 is the alternate pin for FLTA.\n3: RD5 is the alternate pin for PWM4.",
    "2.1 Basic Connection Requirements\nGetting started with the PIC18F2331/2431/4331/4431 family of 8-bit microcontrollers requires attention to a minimal set of device pin connections before proceeding with development.\nThe following pins must always be connected:\n\u00b7 All VDD and VSS pins (see Section 2.2 'Power Supply Pins' )\n\u00b7 All AVDD and AVSS pins, regardless of whether or not the analog device features are used (see Section 2.2 'Power Supply Pins' )\n\u2022\nMCLR pin\n(see\nSection 2.3 'Master Clear (MCLR) Pin'\n)\nThese pins must also be connected if they are being used in the end application:\n\u00b7 PGC/PGD pins used for In-Circuit Serial Programming\u2122 (ICSP\u2122) and debugging purposes (see Section 2.4 'ICSP Pins' )\n\u00b7 OSCI and OSCO pins when an external oscillator source is used (see Section 2.5 'External Oscillator Pins' )\nAdditionally, the following pins may be required:\n- \u00b7 VREF+/VREF- pins are used when external voltage reference for analog modules is implemented\nNote:",
    "2.1 Basic Connection Requirements\nThe AVDD and AVSS pins must always be connected, regardless of whether any of the analog modules are being used.\nThe  minimum  mandatory  connections  are  shown  in Figure 2-1.",
    "Key (all values are recommendations):\nC1 through C6: 0.1 \u00b5F, 20V ceramic\nR1: 10 k \u2126\nR2: 100 \u2126 to 470 \u2126\nNote 1:\nThe example shown is for a PIC18F device with five VDD/VSS and AVDD/AVSS pairs. Other devices may have more or less pairs; adjust the number of decoupling capacitors appropriately.",
    "2.2.1 DECOUPLING CAPACITORS\nThe  use  of  decoupling  capacitors  on  every  pair  of power  supply  pins,  such  as  VDD,  VSS,  AVDD  and AVSS, is required.\nConsider the following criteria when using decoupling capacitors:\n\u00b7 Value and type of capacitor: A 0.1 \uf06d F (100 nF), 10-20V capacitor is recommended. The capacitor should be a low-ESR device, with a resonance frequency in the range of 200 MHz and higher. Ceramic capacitors are recommended.\n\u00b7 Placement on the printed circuit board: The decoupling capacitors should be placed as close to the pins as possible. It is recommended to place the capacitors on the same side of the board as the device. If space is constricted, the capacitor can be placed on another layer on the PCB using a via; however, ensure that the trace length from the pin to the capacitor is no greater than 0.25 inch (6 mm).",
    "2.2.1 DECOUPLING CAPACITORS\n\u00b7 Handling high-frequency noise: If the board is experiencing high-frequency noise (upward of tens of MHz), add a second ceramic type capacitor in parallel to the above described decoupling capacitor. The value of the second capacitor can be in the range of 0.01 \uf06d F to 0.001 \uf06d F. Place this second capacitor next to each primary decoupling capacitor. In high-speed circuit designs, consider implementing a decade pair of capacitances as close to the power and ground pins as possible (e.g., 0.1 \uf06d F in parallel with 0.001 \uf06d F).\n\u00b7 Maximizing performance: On the board layout from the power supply circuit, run the power and return traces to the decoupling capacitors first, and then to the device pins. This ensures that the decoupling capacitors are first in the power chain. Equally important is to keep the trace length between the capacitor and the power pins to a minimum, thereby reducing PCB trace inductance.",
    "2.2.1 DECOUPLING CAPACITORS\nOn  boards  with  power  traces  running  longer  than six inches in length, it is suggested to use a tank capacitor for integrated circuits, including microcontrollers, to supply  a  local  power  source.  The  value  of  the  tank capacitor  should  be  determined  based  on  the  trace resistance  that  connects  the  power  supply  source  to the  device,  and  the  maximum  current  drawn  by  the device in the application. In other words, select the tank capacitor so that it meets the acceptable voltage sag at the device. Typical values range from 4.7 \uf06d F to 47 \uf06d F.",
    "2.2.3 CONSIDERATIONS WHEN USING BOR\nWhen the Brown-out Reset (BOR) feature is enabled, a sudden change in VDD may result in a spontaneous BOR event. This can happen when the microcontroller is operating under normal operating conditions, regardless of what the BOR set point has been programmed to, and even if VDD does not approach the set point. The precipitating factor in these BOR events is a rise or fall in VDD with a slew rate faster than 0.15V/ \uf06d s.\nAn application that incorporates adequate decoupling between the power supplies will not experience such rapid  voltage  changes.  Additionally,  the  use  of  an electrolytic  tank  capacitor  across  VDD  and  VSS,  as described above, will be helpful in preventing high slew rate transitions.\nIf  the  application has components that turn on or off, and share the same VDD circuit as the microcontroller, the  BOR  can  be  disabled  in  software  by  using  the SBOREN bit before  switching  the  component.  Afterwards, allow a small delay before re-enabling the BOR. By doing this, it is ensured that the BOR is disabled during  the  interval  that  might  cause  high  slew  rate changes of VDD.",
    "2.2.3 CONSIDERATIONS WHEN USING BOR\nNote:\nNot all devices incorporate software BOR control. See Section 5.0 'Reset' for device-specific information.",
    "2.3 Master Clear (MCLR) Pin\nThe MCLR pin provides two specific device functions:  Device  Reset,  and  Device  Programming and  Debugging.  If  programming  and  debugging  are not required in the end application, a direct connection  to  VDD  may  be  all  that  is  required.  The addition  of  other  components,  to  help  increase  the application's resistance to spurious Resets from voltage sags, may be beneficial. A typical configuration  is  shown  in  Figure 2-1.  Other  circuit designs  may  be  implemented,  depending  on  the application's requirements.\nDuring  programming  and  debugging,  the  resistance and capacitance that can be added to the pin must be considered. Device programmers and debuggers drive the  MCLR  pin.  Consequently,  specific  voltage  levels (VIH  and  VIL)  and  fast  signal  transitions  must  not  be adversely  affected.  Therefore,  specific  values  of  R1 and C1  will need  to be adjusted based  on the application  and  PCB  requirements.  For  example,  it  is recommended that the capacitor, C1, be isolated from the  MCLR  pin  during  programming  and  debugging operations by using a jumper (Figure 2-2). The jumper is replaced for normal run-time operations.",
    "2.3 Master Clear (MCLR) Pin\nAny components associated with the MCLR  pin should be placed within 0.25 inch (6 mm) of the pin.",
    "FIGURE 2-2: EXAMPLE OF MCLR PIN CONNECTIONS\nNote 1: R1 \uf0a3 10 k \uf057 is  recommended. A suggested starting value  is 10 k \uf057 . Ensure  that  the MCLR pin VIH and VIL specifications are met.\n2: R2 \uf0a3 470 \uf057 will limit any current flowing into MCLR from the external capacitor, C, in the event of MCLR  pin  breakdown,  due to Electrostatic  Discharge  (ESD)  or  Electrical Overstress (EOS). Ensure that the MCLR pin VIH and VIL specifications are met.",
    "2.4 ICSP Pins\nThe PGC and PGD pins are used for In-Circuit Serial Programming\u2122 (ICSP\u2122) and debugging purposes. It is recommended to keep the trace length between the ICSP connector and the ICSP pins on the device as short as possible. If the ICSP connector is expected to experience an ESD event, a series resistor is recommended, with the value in the range of a few tens of ohms, not to exceed 100 \u2126 .\nPull-up resistors, series diodes, and capacitors on the PGC and PGD pins are not recommended as they will interfere  with  the  programmer/debugger  communications to the device. If such discrete components are an application requirement, they should be removed from the circuit during programming and debugging. Alternatively, refer to the AC/DC characteristics and timing requirements  information in the respective device Flash  programming  specification  for  information  on capacitive loading limits and pin input voltage high (VIH) and input low (VIL) requirements.",
    "2.4 ICSP Pins\nFor device emulation, ensure that the 'Communication Channel Select' (i.e., PGCx/PGDx pins) programmed into the  device  matches the physical connections for the ICSP to the Microchip debugger/emulator tool.\nFor more information on available Microchip development  tools  connection  requirements,  refer  to Section 25.0 'Development Support' .",
    "FIGURE 2-3:\nMany  microcontrollers  have  options  for  at  least  two oscillators:  a  high-frequency  primary  oscillator  and  a low-frequency secondary oscillator (refer to Section 3.0 'Oscillator Configurations' for details).\nThe  oscillator  circuit  should  be  placed  on  the  same side  of  the  board  as  the  device.  Place  the  oscillator circuit  close  to  the  respective  oscillator  pins  with  no more than 0.5 inch (12 mm) between the circuit components and the pins. The load capacitors should be placed next to the oscillator itself, on the same side of the board.\nUse a grounded copper pour around the oscillator circuit to isolate it from surrounding circuits. The grounded copper pour should be routed directly to the MCU ground. Do not run any signal traces or power traces inside the ground pour. Also, if using a two-sided board, avoid any traces on the other side of the board where the crystal is placed.",
    "FIGURE 2-3:\nLayout  suggestions  are  shown  in  Figure  2-4.  In-line packages may be handled with a single-sided layout that completely encompasses the oscillator pins. With fine-pitch packages, it is not always possible to completely surround the pins and components. A suitable solution is to tie the broken guard sections to a mirrored ground layer. In all cases, the guard trace(s) must be returned to ground.\nIn  planning  the  application's  routing  and  I/O  assignments, ensure that adjacent port pins and other signals in close proximity to the oscillator are benign (i.e., free of high frequencies, short rise and fall times, and other similar noise).\nFor  additional  information  and  design  guidance  on oscillator circuits, please  refer  to  these  Microchip Application Notes, available at the corporate web site (www.microchip.com):",
    "FIGURE 2-3:\n\u00b7 AN826,  Crystal Oscillator Basics and Crystal ' Selection for rfPIC\u2122 and PICmicro \u00ae  Devices'\n\u00b7 AN849, 'Basic PICmicro \u00ae  Oscillator Design'\n\u00b7 AN943, 'Practical PICmicro \u00ae  Oscillator Analysis and Design'\n\u00b7 AN949, 'Making Your Oscillator Work'",
    "2.6 Unused I/Os\nUnused I/O pins should be configured as outputs and driven to a logic low state. Alternatively, connect a 1 k \u2126 to 10 k \u2126 resistor to VSS on unused pins and drive the output to logic low.",
    "3.1 Oscillator Types\nCRYSTAL/CERAMIC RESONATOR OPERATION (XT, LP, HS OR HSPLL CONFIGURATION)\nThe  PIC18F2331/2431/4331/4431  devices  can  be operated in 10 different oscillator modes. The user can program the Configuration bits, FOSC<3:0>, in Configuration  Register  1H  to  select  one  of  these 10 modes:\n1. LP\nLow-Power Crystal\n2. XT\nCrystal/Resonator\n3. HS\nHigh-Speed Crystal/Resonator\n4. HSPLL\nHigh-Speed Crystal/Resonator with PLL Enabled\n5. RC\nExternal  Resistor/Capacitor  with FOSC/4 Output on RA6\n6. RCIO\nExternal Resistor/Capacitor with I/O on RA6\n7. INTIO1\nInternal Oscillator with FOSC/4 Output on RA6 and I/O on RA7\n8. INTIO2\nInternal Oscillator with I/O on RA6 and RA7\n9. EC\nExternal Clock with FOSC/4 Output\n10. ECIO\nExternal Clock with I/O on RA6",
    "3.2 Crystal Oscillator/Ceramic Resonators\nIn XT, LP, HS or HSPLL Oscillator modes, a crystal or ceramic  resonator  is  connected  to  the  OSC1  and OSC2 pins to establish  oscillation.  Figure 3-1  shows the pin connections.\nThe  oscillator  design  requires  the  use  of  a  parallel resonant crystal.",
    "Note:\nUse of a series resonant crystal may give\na frequency out of the crystal manufacturers' specifications.\nNote 1: See Table 3-1 and Table 3-2 for initial values of C1 and C2.\n2: A  series  resistor  (RS)  may  be  required  for  AT strip resonant crystals.\n3: RF varies with the oscillator mode chosen.",
    "Typical Capacitor Values Used:\nXT, Freq = 455 kHz. XT, OSC1 = 56 pF. XT, OSC2 = 56 pF. , Freq = 2.0 MHz. , OSC1 = 47 pF. , OSC2 = 47 pF. , Freq = 4.0 MHz. , OSC1 = 33 pF. , OSC2 = 33 pF. HS, Freq = 8.0 MHz. HS, OSC1 = 27 pF. HS, OSC2 = 27 pF. , Freq = 16.0 MHz. , OSC1 = 22 pF. , OSC2 = 22 pF\nCapacitor values are for design guidance only.\nThese  capacitors  were  tested  with  the  resonators listed below for basic start-up and operation. These values are not optimized .\nDifferent capacitor values may be required to produce acceptable oscillator operation. The user should test the performance of the oscillator over the expected VDD and temperature range for the application.\nSee  the  notes  following  Table 3-2 for additional information.",
    "Typical Capacitor Values Used:\n455 kHz, Resonators Used: = 4.0 MHz. 2.0 MHz, Resonators Used: = 8.0 MHz. 16.0 MHz, Resonators Used: = 16.0 MHz",
    "TABLE 3-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nAn external clock source may also be connected to the OSC1 pin in the HS mode, as shown in Figure 3-2.",
    "TABLE 3-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nLP, Crystal Freq.Crystal Freq = 32 kHz. LP, Typical Capacitor Values Tested:.C1 = 33 pF. LP, Typical Capacitor Values Tested:.C2 = 33 pF. LP, Crystal Freq.Crystal Freq = 200 kHz. LP, Typical Capacitor Values Tested:.C1 = 15 pF. LP, Typical Capacitor Values Tested:.C2 = 15 pF. XT, Crystal Freq.Crystal Freq = 1 MHz. XT, Typical Capacitor Values Tested:.C1 = 33 pF. XT, Typical Capacitor Values Tested:.C2 = 33 pF. XT, Crystal Freq.Crystal Freq = 4 MHz. XT, Typical Capacitor Values Tested:.C1 = 27 pF. XT, Typical Capacitor Values Tested:.C2 = 27 pF. HS, Crystal Freq.Crystal Freq = 4 MHz. HS, Typical Capacitor Values Tested:.C1 = 27 pF. HS, Typical Capacitor Values Tested:.C2 = 27 pF.",
    "TABLE 3-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nHS, Crystal Freq.Crystal Freq = 8 MHz. HS, Typical Capacitor Values Tested:.C1 = 22 pF. HS, Typical Capacitor Values Tested:.C2 = 22 pF. HS, Crystal Freq.Crystal Freq = 20 MHz. HS, Typical Capacitor Values Tested:.C1 = 15 pF. HS, Typical Capacitor Values Tested:.C2 = 15 pF\nCapacitor values are for design guidance only.\nThese capacitors were tested with the crystals listed below for basic start-up and operation. These values are not optimized.\nDifferent capacitor values may be required to produce acceptable oscillator operation. The user should test the performance of the oscillator over the expected VDD and temperature range for the application.\nSee  the  notes  following  this  table  for  additional information.\n32 kHz, Crystals Used: = 4 MHz. 200 kHz, Crystals Used: = 8 MHz. 1 MHz, Crystals Used: = 20 MHz",
    "TABLE 3-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nNote 1: Higher capacitance increases the stability  of  oscillator,  but  also  increases the start-up time.\n2: When operating below 3V VDD, or when using certain ceramic resonators at any voltage, it may be necessary to use the HS mode or switch to a crystal oscillator.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer  for appropriate values of external components.\n4: Rs may be required to avoid overdriving crystals with low drive level specification.\n5: Always verify oscillator performance over the  VDD  and  temperature  range  that  is expected for the application.",
    "FIGURE 3-2:\nEXTERNAL CLOCK INPUT OPERATION (HS OSC CONFIGURATION)",
    "3.3 PLL Frequency Multiplier\nA Phase Locked Loop (PLL) circuit is provided as an option  for  users  who  wish  to  use  a  lower  frequency oscillator circuit or to clock the device up to its highest rated frequency from a crystal oscillator. This may be useful for those concerned  with EMI  from  highfrequency  crystals  or  users  requiring  higher  clock speeds from an internal oscillator.",
    "3.3.1 HSPLL OSCILLATOR MODE\nThe  HSPLL  mode  uses  the  HS  Oscillator  mode  for frequencies up to 10 MHz. A PLL circuit then multiplies the oscillator output frequency by four to produce an internal clock frequency up to 40 MHz. The PLLEN bit is not available in this oscillator mode.\nThe PLL is only available to the crystal oscillator when the FOSC<3:0> Configuration bits are programmed for HSPLL mode (' 0110 ').",
    "3.4 External Clock Input\nThe EC and ECIO Oscillator modes require an external clock source to be connected to the OSC1 pin. There is no  oscillator  start-up  time  required  after  a  Power-on Reset or after an exit from Sleep mode.\nIn  the  EC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic. Figure 3-4 shows the pin connections for the EC Oscillator mode.",
    "EXTERNAL CLOCK INPUT OPERATION\n(EC CONFIGURATION)\nThe ECIO Oscillator mode functions like the EC mode, except  that  the  OSC2  pin  becomes  an  additional general purpose I/O pin. The I/O pin becomes bit 6 of PORTA (RA6). Figure 3-5 shows the pin connections for the ECIO Oscillator mode.\nFIGURE 3-5:",
    "3.5 RC Oscillator\nFor timing-insensitive applications, the 'RC' and 'RCIO' device options offer additional cost savings. The actual oscillator frequency is a function of several factors:\n\u00b7 Supply voltage\n\u00b7 Values of the external resistor (REXT) and capacitor (CEXT)\n\u00b7 Operating temperature\nGiven the same device, operating voltage and temperature, and component values, there will also be unit-to-unit frequency variations. These are due to factors, such as:\n\u00b7 Normal manufacturing variation\n\u00b7 Difference in lead frame capacitance between package types (especially for low CEXT values)\n\u00b7 Variations within the tolerance of limits of REXT and CEXT\nIn  the  RC Oscillator mode (Figure 3-6), the oscillator frequency divided by 4 is available on the OSC2 pin. This  signal  may  be  used  for  test  purposes  or  to synchronize other logic.",
    "FIGURE 3-6: RC OSCILLATOR MODE\nThe RCIO Oscillator mode (Figure 3-7) functions like the RC mode, except that the OSC2 pin becomes an additional general purpose I/O pin. The I/O pin becomes bit 6 of PORTA (RA6).",
    "3.6.2 INTRC OUTPUT FREQUENCY\nThe PIC18F2331/2431/4331/4431 devices include an internal oscillator block, which generates two different clock signals; either can be used as the system's clock source.  This  can  eliminate  the  need  for  external oscillator circuits on the OSC1 and/or OSC2 pins.\nThe main output (INTOSC) is an 8 MHz clock source, which can be used to directly drive the system clock. It also drives a postscaler, which can provide a range of clock frequencies from 125 kHz to 4 MHz. The INTOSC  output  is  enabled  when  a  system  clock frequency from 125 kHz to 8 MHz is selected.\nThe  other  clock  source  is  the  internal  RC  oscillator (INTRC), which provides a 31 kHz output. The INTRC oscillator is enabled by selecting the internal oscillator block as the system clock source, or when any of the following are enabled:\n\u00b7 Power-up Timer\n\u00b7 Fail-Safe Clock Monitor\n\u00b7 Watchdog Timer\n\u00b7 Two-Speed Start-up\nThese  features  are  discussed  in  greater  detail  in Section 23.0 'Special Features of the CPU' .",
    "3.6.2 INTRC OUTPUT FREQUENCY\nThe  clock  source  frequency  (INTOSC  direct,  INTRC direct or INTOSC postscaler) is selected by configuring the IRCF bits of the OSCCON register (Register 3-2).",
    "3.6.1 INTIO MODES\nUsing  the  internal  oscillator  as  the  clock  source  can eliminate the need for up to two external oscillator pins, which  can  then  be  used  for  digital  I/O.  Two  distinct configurations are available:\n\u00b7 In INTIO1 mode, the OSC2 pin outputs FOSC/4, while OSC1 functions as RA7 for digital input and output.\n\u00b7 In INTIO2 mode, OSC1 functions as RA7 and OSC2 functions as RA6, both for digital input and output.\nThe internal oscillator block is calibrated at the factory to produce an INTOSC output frequency of 8.0 MHz. This changes the frequency of the INTRC source from its  nominal  31.25 kHz.  Peripherals  and  features  that depend on the INTRC source will be affected by this shift in frequency.",
    "3.6.3 OSCTUNE REGISTER\nThe internal oscillator's output has been calibrated at the factory,  but  can  be  adjusted  in  the  user's  application. This  is  done  by  writing  to  the  OSCTUNE  register (Register 3-1).  Each  increment  may  adjust  the  FRC frequency by varying amounts and may not be monotonic. The next closest frequency may be multiple steps apart.\nWhen the OSCTUNE register is modified, the INTOSC and INTRC frequencies will begin shifting to the new frequency. Code execution continues during this shift. There is no indication that the shift has occurred. Operation  of  features  that  depend  on  the  INTRC  clock source frequency, such as the WDT, Fail-Safe Clock Monitor and  peripherals,  will  also  be  affected  by  the change in frequency.",
    "3.6.4 INTOSC FREQUENCY DRIFT\nThe factory calibrates the internal oscillator block output (INTOSC) for 8 MHz. This frequency, however, may drift  as  the  VDD  or  temperature  changes,  which  can affect the controller operation in a variety of ways.\nThe INTOSC frequency can be adjusted by modifying the value in the OSCTUNE register. This has no effect on the INTRC clock source frequency.\nTuning the INTOSC source requires knowing when to make  an  adjustment,  in  which  direction  it  should  be made,  and  in  some  cases,  how  large  a  change  is needed. Three compensation techniques are discussed in Section 3.6.4.1 'Compensating with the EUSART' , Section 3.6.4.2  'Compensating with the Timers' and Section 3.6.4.3 'Compensating with the CCP Module in Capture Mode' , but other techniques may be used.",
    "OSCTUNE: OSCILLATOR TUNING REGISTER\n-, U-0 = -. -, R/W-0 = TUN5. -, R/W-0 = TUN4. -, R/W-0 = TUN3. -, R/W-0 = TUN2. -, R/W-0 = TUN1. -, R/W-0 = TUN0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "OSCTUNE: OSCILLATOR TUNING REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-6 Unimplemented: Read as ' 0 '",
    "bit 5-0 TUN<5:0>: Frequency Tuning bits\n011111 = Maximum frequency\n\u2022\n\u2022\n\u2022\n\u2022\n000001\n000000 = Center frequency. Oscillator module is running at the calibrated frequency.\n111111\n\u2022\n\u2022\n\u2022\n\u2022\n100000 = Minimum frequency",
    "3.6.4.1 Compensating with the EUSART\nAn  adjustment  may  be  required  when  the  EUSART begins generating framing errors or receives data with errors  while  in  Asynchronous  mode.  Framing  errors frequently indicate that the device clock frequency is too high. To adjust for this, decrement the value in the OSCTUNE register to reduce the clock frequency.",
    "3.6.4.3 Compensating with the CCP Module in Capture Mode\nConversely, errors in data may suggest that the clock speed  is too low; to compensate,  increment  the OSCTUNE register to increase the clock frequency.",
    "3.6.4.2 Compensating with the Timers\nThis  technique  compares  the  device  clock  speed  to that of a reference clock. Two timers may be used: one timer clocked by the peripheral clock and the other by a fixed reference source, such as the Timer1 oscillator.\nBoth timers are cleared, but the timer clocked by the reference  generates  interrupts.  When  an  interrupt occurs,  the  internally  clocked  timer  is  read  and  both timers are cleared. If the internally clocked timer value is greater than expected, the internal oscillator block is running  too  fast.  To  adjust  for  this,  decrement  the OSCTUNE register.\nA  CCP  module  can  use  free-running  Timer1  (or Timer3), clocked by the internal oscillator block and an external event with a known period (such as the AC power frequency). The time of the first  event is captured in the CCPRxH:CCPRxL registers and recorded for later use. When the second event causes a capture, the time of the first event is subtracted from the time of the  second  event.  Since  the  period  of  the  external event is known, the time difference between events can be calculated.",
    "3.6.4.2 Compensating with the Timers\nIf  the measured time is much greater than the calculated  time,  the internal  oscillator  block  is  running  too fast. To compensate for this, decrement the OSCTUNE register.  If  the  measured  time  is  much  less  than  the calculated time, the internal oscillator block is running too slow and  the OSCTUNE  register  should  be incremented.",
    "3.7.1 OSCILLATOR CONTROL REGISTER\nLike  previous  PIC18  devices,  the  PIC18F2331/2431/ 4331/4431 devices include a feature that allows the system clock source to be switched from the main oscillator to an alternate low-frequency clock source. PIC18F2331/ 2431/4331/4431 devices offer two alternate clock sources. When enabled, these give additional options for switching to the various power-managed  operating modes.\nEssentially,  there  are  three  clock  sources  for  these devices:\n\u00b7 Primary oscillators\n\u00b7 Secondary oscillators\n\u00b7 Internal oscillator block\nThe primary oscillators include the External Crystal and  Resonator  modes,  the  External  RC  modes,  the External Clock modes and the internal oscillator block. The particular mode is defined on POR by the contents of  Configuration  Register  1H.  The  details  of  these modes are covered earlier in this chapter.\nThe secondary oscillators are those external sources not  connected  to  the  OSC1  or  OSC2  pins.  These sources  may  continue  to  operate  even  after the controller is placed in a power-managed mode.",
    "3.7.1 OSCILLATOR CONTROL REGISTER\nPIC18F2331/2431/4331/4431  devices  offer  only  the Timer1 oscillator as a secondary oscillator. This oscillator,  in  all  power-managed  modes,  is  often  the time  base  for  functions  such  as  a  Real-Time  Clock (RTC).\nMost often, a 32.768 kHz watch crystal is connected between  the  RC0/T1OSO/T1CKI  and  RC1/T1OSI/ CCP2/FLTA pins. Like the LP Oscillator mode circuit, loading capacitors are also connected from each pin to ground.\nThe Timer1 oscillator is discussed in greater detail in Section 13.2 'Timer1 Oscillator' .\nIn addition to being a primary clock source, the internal oscillator  block is  available  as  a  power-managed mode clock source. The INTRC source is also used as the clock source for several special features, such as the WDT and Fail-Safe Clock Monitor.",
    "3.7.1 OSCILLATOR CONTROL REGISTER\nThe clock sources for the PIC18F2331/2431/4331/4431 devices  are  shown  in  Figure 3-8.  See Section 13.0 'Timer1  Module' for further  details  of  the  Timer1 oscillator.  See Section 23.1 'Configuration Bits' for Configuration register details.\nThe  OSCCON register  (Register 3-2)  controls  several aspects of the system clock's operation, both in full-power operation and in power-managed modes.\nThe System Clock Select bits, SCS<1:0>, select the clock source that is used when the device is operating in power-managed modes. The available clock sources are the primary clock (defined in Configuration Register 1H),  the  secondary  clock  (Timer1  oscillator)  and  the internal  oscillator  block.  The  clock  selection  has  no effect  until  a SLEEP instruction  is  executed  and  the device  enters  a  power-managed  mode  of  operation. The SCS bits are cleared on all forms of Reset.",
    "3.7.1 OSCILLATOR CONTROL REGISTER\nThe Internal Oscillator Select bits, IRCF<2:0>, select the frequency output of the internal oscillator block that is used to drive the system clock. The choices are the INTRC source, the INTOSC source (8 MHz) or one of the  six  frequencies  derived  from  the  INTOSC  postscaler  (125 kHz  to  4 MHz).  If  the  internal  oscillator block  is  supplying  the  system  clock,  changing  the states of these bits will have an immediate change on the internal oscillator's output. On device Resets, the default output frequency of the internal oscillator block is set at 32 kHz.",
    "3.7.1 OSCILLATOR CONTROL REGISTER\nThe OSTS, IOFS and T1RUN bits indicate which clock source is currently providing the system clock. The OSTS indicates that the Oscillator Start-up Timer has timed out, and the primary clock is providing the system clock in Primary Clock modes. The IOFS bit indicates when the internal oscillator block has stabilized, and is providing the system clock in RC Clock modes. The T1RUN bit (T1CON<6>)  indicates  when  the  Timer1  oscillator  is providing the system clock in Secondary Clock modes. In power-managed modes, only one of these three bits will be set at any time. If none of these bits are set, the INTRC is  providing  the  system  clock,  or  the  internal  oscillator block has just started and is not yet stable.\nThe IDLEN bit controls the selective shutdown of the controller's CPU in power-managed modes. The use of these bits  is  discussed in  more  detail  in Section 4.0 'Power-Managed Modes'",
    "3.7.1 OSCILLATOR CONTROL REGISTER\nNote 1: The Timer1 oscillator must be enabled to select the secondary clock source. The Timer1 oscillator is enabled by setting the T1OSCEN  bit  in  the  Timer1  Control register (T1CON<3>). If the Timer1 oscillator is not enabled, then any attempt to select a secondary  clock source, when executing a SLEEP instruction, will be ignored.\n2: It is recommended  that the Timer1 oscillator be operating and stable before executing  the SLEEP instruction,  or  a very  long  delay  may  occur  while  the Timer1 oscillator starts.",
    "OSCCON: OSCILLATOR CONTROL REGISTER\nIDLEN, R/W-0 = IRCF2. IDLEN, R/W-0 = IRCF1. IDLEN, R/W-0 = IRCF0. IDLEN, R (1) = OSTS. IDLEN, R-0 = IOFS. IDLEN, R/W-0 = SCS1. IDLEN, R/W-0 = SCS0. bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R (1) = . bit 7, R-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = bit 0",
    "OSCCON: OSCILLATOR CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 IDLEN: Idle Enable bit\n1 = Idle mode enabled; CPU core is not clocked in power-managed modes\n0 = Run mode enabled; CPU core is clocked in power-managed modes",
    "bit 6-4\nIRCF<2:0>: Internal Oscillator Frequency Select bits\n111 = 8 MHz (8 MHz source drives clock directly)\n110 = 4 MHz (default)\n101 = 2 MHz\n100 = 1 MHz\n011 = 500 kHz\n010 = 250 kHz\n001 = 125 kHz\n000 = 31 kHz (INTRC source drives clock directly) (2)\nbit 3\nOSTS: Oscillator Start-up Timer Time-out Status bit (1)\n1 = Oscillator Start-up Timer time-out has expired; primary oscillator is running\n0 = Oscillator Start-up Timer time-out is running; primary oscillator is not ready",
    "bit 2\nIOFS: INTOSC Frequency Stable bit\n1 = INTOSC frequency is stable\n0 = INTOSC frequency is not stable",
    "bit 1-0\nSCS<1:0>: System Clock Select bits\n1x = Internal oscillator block\n01 = Secondary (Timer1) oscillator\n00 = Primary oscillator\nNote 1: Depends on the state of the IESO bit in Configuration Register 1H.\n2: Default output frequency of INTOSC on Reset.",
    "3.7.2 OSCILLATOR TRANSITIONS\nThe PIC18F2331/2431/4331/4431 devices contain circuitry to prevent clocking 'glitches' when switching between clock sources. A short pause in the system clock occurs during the clock switch. The length of this pause is  between  8  and  9  clock  periods  of  the  new clock source. This ensures that the new clock source is stable and that its pulse width will not be less than the shortest pulse width of the two clock sources.\nClock  transitions  are  discussed  in  greater  detail  in Section 4.1.2 'Entering Power-Managed Modes' .",
    "3.8 Effects of Power-Managed Modes on the Various Clock Sources\nWhen  PRI_IDLE  mode  is  selected,  the  designated primary oscillator continues to run without interruption. For all other power-managed modes, the oscillator using the OSC1 pin is disabled. The OSC1 pin (and OSC2 pin, if used by the oscillator) will stop oscillating.\nWhen  the  device  executes  a SLEEP instruction,  the system  is  switched  to  one  of  the  power-managed modes,  depending  on  the  state  of  the  IDLEN  and SCS<1:0> bits of the OSCCON register. See Section 4.0 'Power-Managed Modes' for details.\nIn secondary clock modes (SEC_RUN and SEC_IDLE),  the  Timer1  oscillator  is  operating  and providing the system clock. The Timer1 oscillator may also  run  in  all  power-managed  modes  if  required  to clock Timer1.",
    "3.8 Effects of Power-Managed Modes on the Various Clock Sources\nIn internal oscillator modes (RC_RUN and RC_IDLE), the internal oscillator block provides the system clock source.  The  INTRC  output  can  be  used  directly  to provide  the  system  clock  and  may  be  enabled  to support  various  special  features,  regardless  of  the power-managed mode (see Section 23.2 'Watchdog Timer (WDT)' through Section 23.4 'Fail-Safe Clock Monitor' ). The INTOSC output at 8 MHz may be used directly to clock the system, or may be divided down first. The INTOSC output is disabled if the system clock is provided directly from the INTRC output.\nIf  the  Sleep  mode  is  selected,  all  clock  sources  are stopped.  Since  all  the  transistor  switching  currents have been stopped, Sleep mode achieves the lowest current consumption  of  the device (only leakage currents).",
    "3.8 Effects of Power-Managed Modes on the Various Clock Sources\nEnabling any on-chip feature that will  operate during Sleep will increase the current consumed during Sleep. The INTRC is required to support WDT operation. The Timer1 oscillator may be operating to support a RealTime Clock. Other features may be operating that do not  require  a  system  clock  source  (i.e.,  SSP  slave, INTx pins, A/D conversions and others).",
    "3.9 Power-up Delays\nPower-up delays are controlled by two timers, so that no external Reset circuitry is required for most applications. The delays ensure that the device is kept in Reset until the device power supply is stable under normal circumstances, and the primary clock is operating and stable. For additional information on power-up delays, see Section 5.3  'Power-on  Reset  (POR)' through Section 5.4 'Brown-out Reset (BOR)' .\nThe first timer is the Power-up Timer (PWRT), which provides  a  fixed  delay  on  power-up  (parameter  33, Table 26-8),  if  enabled,  in  Configuration  Register  2L. The  second  timer  is  the  Oscillator  Start-up  Timer (OST), intended to keep the chip in Reset until the crystal oscillator is stable (LP , XT and HS modes). The OST does  this  by  counting  1024  oscillator  cycles  before allowing the oscillator to clock the device.",
    "3.9 Power-up Delays\nWhen  the  HSPLL  Oscillator  mode  is  selected,  the device is kept in Reset for an additional 2 ms, following the HS mode OST delay, so the PLL can lock to the incoming clock frequency.",
    "TABLE 3-3: OSC1 AND OSC2 PIN STATES IN SLEEP MODE\nRC, INTIO1, OSC1 Pin = Floating, external resistor should pull high. RC, INTIO1, OSC2 Pin = At logic low (clock/4 output). RCIO, INTIO2, OSC1 Pin = Floating, external resistor should pull high. RCIO, INTIO2, OSC2 Pin = Configured as PORTA, bit 6. ECIO, OSC1 Pin = Floating, pulled by external clock. ECIO, OSC2 Pin = Configured as PORTA, bit 6. EC, OSC1 Pin = Floating, pulled by external clock. EC, OSC2 Pin = At logic low (clock/4 output). LP, XT and HS, OSC1 Pin = Feedback inverter disabled at quiescent voltage level. LP, XT and HS, OSC2 Pin = Feedback inverter disabled at quiescent voltage level\nNote: See Table 5-1 in Section 5.0 'Reset' for time-outs due to Sleep and MCLR Reset.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "4.1.1 CLOCK SOURCES\nPIC18F2331/2431/4331/4431  devices  offer  a  total  of seven  operating modes  for more  efficient power management.  These  modes  provide  a  variety  of options for selective power conservation in applications where resources may be limited (i.e., battery-powered devices).\nThere are three categories of power-managed modes:\n\u00b7 Run modes\n\u00b7 Idle modes\n\u00b7 Sleep mode\nThese categories define which portions of the device are clocked, and sometimes, what speed. The Run and Idle modes may use any of the three available clock sources (primary, secondary or internal oscillator block); the Sleep mode does not use a clock source.\nThe  power-managed  modes  include  several  powersaving features offered on previous PIC \u00ae  devices. One is  the  clock  switching feature, offered in other PIC18 devices, allowing the controller to use the Timer1 oscillator in place of the primary oscillator. Also included is the Sleep mode, offered by all PIC devices, where all device clocks are stopped.",
    "4.1 Selecting Power-Managed Modes\nSelecting a power-managed mode requires two decisions: if  the  CPU  is  to  be  clocked  or  not  and  the selection of a clock source. The IDLEN bit (OSCCON<7>) controls CPU clocking, while the SCS<1:0> bits (OSCCON<1:0>) select the clock source. The individual modes, bit settings, clock sources and affected modules are summarized in Table 4-1.\nThe SCS<1:0> bits allow the selection of one of three clock sources for power-managed modes. They are:\n\u00b7 the primary clock, as defined by the FOSC<3:0> Configuration bits\n\u00b7 the secondary clock (the Timer1 oscillator)\n\u00b7 the internal oscillator block (for RC modes)",
    "4.1.2 ENTERING POWER-MANAGED MODES\nSwitching from one power-managed mode to another begins by loading the OSCCON register. The SCS<1:0> bits select the clock source and determine which Run or Idle mode is to be used. Changing these bits  causes  an  immediate  switch  to  the  new  clock source,  assuming  that  it  is  running.  The  switch  may also  be  subject  to  clock  transition  delays.  These  are discussed  in Section 4.1.3  'Clock  Transitions  and Status Indicators' and subsequent sections.\nEntry  to  the  power-managed  Idle  or  Sleep  modes  is triggered by the execution of a SLEEP instruction. The actual mode that results depends on the status of the IDLEN bit.\nDepending on the  current  mode  and the  mode being switched to, a change to a power-managed mode does not  always  require  setting  all  of  these  bits. Many transitions may be done by changing the oscillator select bits, or changing the IDLEN bit, prior to issuing a SLEEP instruction. If the IDLEN  bit  is already  configured correctly, it may only be necessary to perform a SLEEP instruction to switch to the desired mode.",
    "TABLE 4-1: POWER-MANAGED MODES\nSleep, OSCCON Bits<7,1:0>.IDLEN (1) = 0. Sleep, OSCCON Bits<7,1:0>.SCS<1:0> = N/A. Sleep, Module Clocking.CPU = Off. Sleep, Module Clocking.Peripherals = Off. Sleep, Available Clock and Oscillator Source.Available Clock and Oscillator Source = None - All clocks are disabled. PRI_RUN, OSCCON Bits<7,1:0>.IDLEN (1) = N/A. PRI_RUN, OSCCON Bits<7,1:0>.SCS<1:0> = 00. PRI_RUN, Module Clocking.CPU = Clocked. PRI_RUN, Module Clocking.Peripherals = Clocked. PRI_RUN, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Primary - LP, XT, HS, HSPLL, RC, EC and Internal Oscillator Block. (2) This is the normal, full-power execution mode.. SEC_RUN, OSCCON",
    "TABLE 4-1: POWER-MANAGED MODES\nBits<7,1:0>.IDLEN (1) = N/A. SEC_RUN, OSCCON Bits<7,1:0>.SCS<1:0> = 01. SEC_RUN, Module Clocking.CPU = Clocked. SEC_RUN, Module Clocking.Peripherals = Clocked. SEC_RUN, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Secondary - Timer1 Oscillator. RC_RUN, OSCCON Bits<7,1:0>.IDLEN (1) = N/A. RC_RUN, OSCCON Bits<7,1:0>.SCS<1:0> = 1x. RC_RUN, Module Clocking.CPU = Clocked. RC_RUN, Module Clocking.Peripherals = Clocked. RC_RUN, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Internal Oscillator Block (2). PRI_IDLE, OSCCON Bits<7,1:0>.IDLEN (1) = 1. PRI_IDLE, OSCCON",
    "TABLE 4-1: POWER-MANAGED MODES\nBits<7,1:0>.SCS<1:0> = 00. PRI_IDLE, Module Clocking.CPU = Off. PRI_IDLE, Module Clocking.Peripherals = Clocked. PRI_IDLE, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Primary - LP, XT, HS, HSPLL, RC, EC. SEC_IDLE, OSCCON Bits<7,1:0>.IDLEN (1) = 1. SEC_IDLE, OSCCON Bits<7,1:0>.SCS<1:0> = 01. SEC_IDLE, Module Clocking.CPU = Off. SEC_IDLE, Module Clocking.Peripherals = Clocked. SEC_IDLE, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Secondary - Timer1 Oscillator. RC_IDLE, OSCCON Bits<7,1:0>.IDLEN (1) = 1. RC_IDLE, OSCCON Bits<7,1:0>.SCS<1:0> = 1x. RC_IDLE, Module",
    "TABLE 4-1: POWER-MANAGED MODES\nClocking.CPU = Off. RC_IDLE, Module Clocking.Peripherals = Clocked. RC_IDLE, Available Clock and Oscillator Source.Available Clock and Oscillator Source = Internal Oscillator Block (2)\nNote 1: IDLEN reflects its value when the SLEEP instruction is executed.\n2: Includes INTOSC and INTOSC postscaler, as well as the INTRC source.",
    "4.2 Run Modes\nThe length of the transition between clock sources is the sum of two cycles of the old clock source and three to  four  cycles  of  the  new  clock  source.  This  formula assumes that the new clock source is stable.\nThree  bits  indicate  the  current  clock  source  and  its status. They are:\n\u00b7 OSTS (OSCCON<3>)\n\u00b7 IOFS (OSCCON<2>)\n\u00b7 T1RUN (T1CON<6>)\nIn general, only one of these bits will be set while in a given  power-managed  mode.  When  the  OSTS  bit  is set,  the  primary  clock  is  providing  the  device  clock. When  the  IOFS  bit  is  set,  the  INTOSC  output  is providing a stable, 8 MHz clock source to a divider that actually drives the device clock. When the T1RUN bit is set, the Timer1 oscillator is providing the clock. If none of  these  bits  are  set,  then  either  the  INTRC  clock source is clocking the device, or the INTOSC source is not yet stable.",
    "4.2 Run Modes\nIf the internal oscillator block is configured as the primary clock source by the FOSC<3:0> Configuration bits, then both  the  OSTS  and  IOFS  bits  may  be  set  when  in PRI_RUN or PRI_IDLE modes. This indicates that the primary clock (INTOSC output) is generating a stable, 8 MHz  output.  Entering  another  power-managed  RC mode at the same frequency would clear the OSTS bit.\nNote 1: Caution should be used when modifying a single IRCF bit. If VDD is less than 3V, it is possible to select a higher clock speed than is supported by the low VDD. Improper  device  operation  may  result  if the VDD/FOSC specifications are violated.\n2: Executing a SLEEP instruction does not necessarily  place  the  device  into  Sleep mode. It acts as the trigger to place the controller  into  either  the  Sleep  mode  or one of the Idle modes, depending on the setting of the IDLEN bit.",
    "4.1.4 MULTIPLE SLEEP COMMANDS\nThe  power-managed  mode  that  is  invoked  with  the SLEEP instruction is determined by the setting of the IDLEN  bit  at  the  time  the  instruction  is  executed.  If another SLEEP instruction is executed, the device will enter the power-managed mode specified by IDLEN at that time. If IDLEN has changed, the device will enter the new power-managed mode specified by the new setting.\nIn the  Run  modes,  clocks  to  both  the  core  and peripherals are active. The difference between these modes is the clock source.",
    "4.2.1 PRI_RUN MODE\nThe PRI_RUN mode is the normal, full-power execution mode of the microcontroller. This is also the default mode upon a device Reset unless Two-Speed Start-up is enabled (see Section 23.3 'Two-Speed Start-up' for details). In this mode, the OSTS bit is set. The IOFS bit  may  be  set  if  the  internal  oscillator  block  is  the primary  clock  source  (see Section 3.7.1  'Oscillator Control Register' ).",
    "4.2.2 SEC_RUN MODE\nThe SEC_RUN mode is the compatible mode to the 'clock switching' feature offered in other PIC18 devices.  In  this  mode,  the  CPU  and  peripherals  are clocked from the Timer1 oscillator. This gives users the option of lower power consumption while still using a high-accuracy clock source.\nSEC_RUN mode is entered by setting the SCS<1:0> bits to ' 01 '. The device clock source is switched to the Timer1 oscillator (see Figure 4-1), the primary oscillator is shut down, the T1RUN bit (T1CON<6>) is set and the OSTS bit is cleared.\nNote:",
    "4.2.2 SEC_RUN MODE\nThe  Timer1  oscillator  should  already  be running prior to entering SEC_RUN mode. If the T1OSCEN bit is not set when the SCS<1:0> bits are set to ' 01 ', entry to SEC_RUN  mode  will  not  occur.  If  the Timer1  oscillator  is  enabled,  but  not  yet running, device clocks will be delayed until the  oscillator  has  started.  In  such  situations, initial oscillator operation is far from stable  and  unpredictable  operation  may result.\nOn transitions from SEC_RUN mode to PRI_RUN, the peripherals and CPU continue to be clocked from the Timer1  oscillator  while  the  primary  clock  is  started. When the primary clock becomes ready, a clock switch back  to  the  primary  clock  occurs  (see  Figure 4-2). When the clock switch is complete, the T1RUN bit is cleared, the OSTS bit is set and the primary clock is providing the clock. The IDLEN and SCS bits are not affected by the wake-up; the Timer1 oscillator continues to run.",
    "4.2.3 RC_RUN MODE\nIn RC_RUN  mode,  the  CPU  and  peripherals  are clocked  from  the  internal  oscillator  block  using  the INTOSC multiplexer. In this mode, the primary clock is shut down. When using the INTRC source, this mode provides  the  best  power  conservation  of  all  the  Run modes, while still executing code. It works well for user applications which are not highly timing-sensitive or do not require high-speed clocks at all times.\nIf the primary clock source is the internal oscillator block (either INTRC or INTOSC), there are no distinguishable differences  between  PRI_RUN  and  RC_RUN  modes during  execution.  However,  a  clock  switch  delay  will occur  during  entry  to  and  exit  from  RC_RUN  mode. Therefore,  if  the  primary  clock  source  is  the  internal oscillator  block,  the  use  of  RC_RUN  mode  is  not recommended.",
    "4.2.3 RC_RUN MODE\nThis  mode is  entered  by  setting  the  SCS1  bit  to  ' 1 '. Although it is ignored, it is recommended that the SCS0 bit also be cleared; this is to maintain software compatibility  with  future  devices.  When  the  clock  source  is switched to the INTOSC multiplexer (see Figure 4-3), the primary oscillator is shut down and the OSTS bit is cleared. The IRCF bits may be modified at any time to immediately change the clock speed.",
    "Note:\nCaution should be used when modifying a single IRCF bit. If VDD is less than 3V, it is possible  to  select  a  higher  clock  speed than is supported by the low VDD. Improper  device  operation  may  result  if the VDD/FOSC specifications are violated.",
    "PIC18F2331/2431/4331/4431\nIf  the IRCF bits and the INTSRC bit are all clear, the INTOSC output is not  enabled  and  the  IOFS  bit  will remain clear; there will be no indication of the current clock  source.  The  INTRC  source  is  providing  the device clocks.\nIf the  IRCF  bits  are  changed  from  all  clear  (thus, enabling the INTOSC output), or if INTSRC is set, the IOFS  bit becomes  set  after the INTOSC  output becomes stable. Clocks to the device continue while the  INTOSC  source  stabilizes,  after  an  interval  of TIOBST.\nOn transitions from RC_RUN mode to PRI_RUN mode, the device continues to be clocked from the INTOSC multiplexer while the primary clock is started. When the primary  clock  becomes  ready,  a  clock  switch  to  the primary clock occurs (see Figure 4-4). When the clock switch is complete, the IOFS bit is cleared, the OSTS bit is set and the primary clock is providing the device clock. The IDLEN and SCS bits are not affected by the switch. The INTRC source will continue to run if either the WDT or the Fail-Safe Clock Monitor is enabled.",
    "PIC18F2331/2431/4331/4431\nIf the IRCF bits were previously at a non-zero value, or if INTSRC  was  set  before  setting  SCS1  and  the INTOSC source was already stable, the IOFS bit will remain set.",
    "4.3 Sleep Mode\nThe power-managed Sleep mode in the PIC18F2331/ 2431/4331/4431  devices  is  identical  to  the  legacy Sleep  mode  offered  in  all  other  PIC  devices.  It  is entered by clearing the IDLEN bit (the default state on device  Reset)  and  executing  the SLEEP instruction. This shuts down the selected oscillator (Figure 4-5). All clock source status bits are cleared.\nEntering the Sleep mode from any other mode does not require a clock switch. This is because no clocks are needed once the controller has entered Sleep. If the WDT is selected,  the  INTRC  source  will  continue  to operate. If the Timer1 oscillator is enabled, it will also continue to run.",
    "4.3 Sleep Mode\nWhen a wake event occurs in Sleep mode (by interrupt, Reset or WDT time-out), the device will not be clocked until the clock source, selected by the SCS<1:0> bits, becomes ready (see Figure 4-6), or it will be clocked from the internal oscillator block if either the Two-Speed Start-up or the Fail-Safe Clock Monitor is enabled (see Section 23.0  'Special  Features  of  the  CPU' ). In either case, the OSTS bit is set when the primary clock is providing the device clocks. The IDLEN and SCS bits are not affected by the wake-up.",
    "4.4 Idle Modes\nThe  Idle  modes  allow  the  controller's  CPU  to  be selectively shut down while the peripherals continue to operate. Selecting a particular Idle mode allows users to further manage power consumption.\nIf the IDLEN bit is set to a ' 1 ' when a SLEEP instruction is executed, the peripherals will be clocked from the clock source selected using the SCS<1:0> bits; however, the CPU will not be clocked. The clock source status bits are not  affected.  Setting  IDLEN  and  executing  a SLEEP instruction provides a quick method of switching from a given Run mode to its corresponding Idle mode.\nIf the WDT is selected, the INTRC source will continue to operate. If the Timer1 oscillator is enabled, it will also continue to run.",
    "4.4 Idle Modes\nSince the CPU is not executing instructions, the only exits from any of the Idle modes are by interrupt, WDT time-out or a Reset. When a wake event occurs, CPU execution is delayed by an interval of TCSD (Parameter 38, Table 26-8) while it becomes ready to execute code. When the CPU begins executing code, it resumes with the same clock source for the current Idle mode. For example, when waking from RC_IDLE mode, the internal oscillator block will clock the CPU and peripherals (in other words, RC_RUN mode). The IDLEN and SCS bits are not affected by the wake-up.\nWhile in any Idle mode or Sleep mode, a WDT timeout  will  result  in  a  WDT  wake-up  to  the  Run  mode currently specified by the SCS<1:0> bits.",
    "FIGURE 4-5: TRANSITION TIMING FOR ENTRY TO SLEEP MODE\nQ4 Q3 Q2 Q1 Q1, 1 = . OSC1, 1 = . CPU Clock, 1 = . Peripheral Clock, 1 = . Sleep, 1 = . Program Counter PC, 1 = 2\nFIGURE 4-6:",
    "4.4.1 PRI_IDLE MODE\nThis mode is unique among the three low-power Idle modes, in that it does not disable the primary device clock. For timing-sensitive applications, this allows for the fastest resumption of device operation with its more accurate primary clock source, since the clock source does not have to 'warm-up' or transition from another oscillator.\nsetting the IDLEN bit and executing a SLEEP instruction. If the device is in another Run mode, set the IDLEN bit first, then set the SCS<1:0> bits to ' 01 ' and execute SLEEP . When the clock source is switched to the Timer1 oscillator, the primary oscillator is shut down, the OSTS bit is cleared and the T1RUN bit is set.",
    "4.4.1 PRI_IDLE MODE\nPRI_IDLE mode is entered from PRI_RUN mode by setting the IDLEN bit and executing a SLEEP instruction. If the device is in another Run mode, set IDLEN first, then  clear  the  SCS  bits  and  execute SLEEP . Although the CPU is disabled, the peripherals continue to be clocked from the primary clock source specified by  the  FOSC<3:0> Configuration bits.  The  OSTS bit remains set (see Figure 4-7).\nWhen a wake event occurs, the CPU is clocked from the primary  clock  source.  A  delay  of  interval,  TCSD,  is required  between  the  wake  event  and  when  code execution starts. This is required to allow the CPU to become ready to execute instructions. After the wakeup, the OSTS bit remains set. The IDLEN and SCS bits are not affected by the wake-up (see Figure 4-8).",
    "4.4.2 SEC_IDLE MODE\nIn  SEC_IDLE  mode,  the  CPU  is  disabled  but  the peripherals  continue  to  be  clocked  from  the  Timer1 oscillator.  This  mode  is  entered  from  SEC_RUN  by",
    "FIGURE 4-7: TRANSITION TIMING FOR ENTRY TO IDLE MODE\nFIGURE 4-8: TRANSITION TIMING FOR WAKE FROM IDLE TO RUN MODE\nWhen a wake event occurs, the peripherals continue to be clocked from the Timer1 oscillator. After an interval of TCSD, following the wake event, the CPU begins executing code being clocked by the Timer1 oscillator. The IDLEN and SCS bits are not affected by the wake-up; the Timer1 oscillator continues to run (see Figure 4-8).",
    "Note:\nThe  Timer1  oscillator  should  already  be running prior to entering SEC_IDLE mode. If the T1OSCEN bit is not set when the SLEEP instruction  is  executed,  the SLEEP instruction  will be  ignored  and entry to SEC_IDLE mode will not occur. If the Timer1 oscillator is enabled but not yet running, peripheral clocks will be delayed until  the  oscillator  has  started.  In  such situations, initial oscillator operation is far from  stable  and  unpredictable  operation may result.",
    "4.4.3 RC_IDLE MODE\nIn RC_IDLE mode, the CPU is disabled but the peripherals continue to be clocked from the internal oscillator block using the INTOSC multiplexer. This mode allows for controllable power conservation during Idle periods.\nOn all exits from Idle or Sleep modes by interrupt, code execution  branches  to  the  interrupt  vector  if  the  GIE/ GIEH bit (INTCON<7>) is set. Otherwise, code execution continues or resumes without branching (see Section 10.0 'Interrupts' ).\nFrom  RC_RUN,  this  mode  is  entered  by  setting  the IDLEN  bit  and  executing  a SLEEP instruction.  If  the device is in another Run mode, first set IDLEN, then set the SCS1 bit and execute SLEEP . Although its value is ignored, it is recommended that SCS0 also be cleared; this  is  to  maintain  software  compatibility  with  future devices.  The  INTOSC  multiplexer  may  be  used  to select a higher clock frequency by modifying the IRCF bits before executing the SLEEP instruction. When the clock source is switched to the INTOSC multiplexer, the primary  oscillator  is  shut  down  and  the  OSTS  bit  is cleared.",
    "4.4.3 RC_IDLE MODE\nIf  the IRCF bits are set to any non-zero value, or the INTSRC bit is set, the INTOSC output is enabled. The IOFS  bit becomes  set,  after  the INTOSC  output becomes stable, after an interval of TIOBST (Parameter 39, Table 26-8). Clocks to the peripherals continue  while  the  INTOSC  source  stabilizes.  If  the IRCF  bits  were  previously  at  a  non-zero  value,  or INTSRC  was  set  before  the SLEEP instruction  was executed, and the INTOSC source was already stable, the  IOFS  bit  will  remain  set.  If  the  IRCF  bits  and INTSRC are all clear, the INTOSC output will not be enabled, the IOFS bit will remain clear and there will be no indication of the current clock source.",
    "4.4.3 RC_IDLE MODE\nWhen a wake event occurs, the peripherals continue to be clocked from the INTOSC multiplexer. After a delay of TCSD, following the wake event, the CPU begins executing code being clocked by the INTOSC multiplexer. The IDLEN and SCS bits are not affected by the wake-up. The INTRC source will continue to run if either the WDT or the Fail-Safe Clock Monitor is enabled.",
    "4.5 Exiting Idle and Sleep Modes\nAn exit from Sleep mode or any of the Idle modes, is triggered by an interrupt, a Reset or a WDT time-out. This  section  discusses  the  triggers  that  cause  exits from power-managed modes. The clocking subsystem actions  are  discussed  in  more  detail  in  each  of  the sections that relate to the power-managed modes (see Section 4.2 'Run Modes', Section 4.3 'Sleep Mode' and Section 4.4 'Idle Modes' ).",
    "4.5.1 EXIT BY INTERRUPT\nAny of the available interrupt sources can cause the device to exit from an Idle mode or Sleep mode to a Run  mode.  To  enable  this  functionality,  an  interrupt source must be enabled by setting its enable bit in one of the INTCON or PIE registers. The exit sequence is initiated when the corresponding interrupt flag bit is set.\nA  fixed  delay  of  interval,  TCSD,  following  the  wake event, is required when leaving Sleep and Idle modes. This delay is required for the CPU to prepare for execution.  Instruction  execution  resumes  on  the  first  clock cycle following this delay.",
    "4.5.2 EXIT BY WDT TIME-OUT\nA WDT time-out will cause different actions depending on which power-managed mode the device is in when the time-out occurs.\nIf the device is not executing code (all Idle modes and Sleep mode), the time-out will result in an exit from the power-managed mode (see Section 4.2 'Run Modes' and Section 4.3 'Sleep Mode' ). If the device is  executing  code  (all  Run  modes),  the  time-out  will result in a WDT Reset (see Section 23.2 'Watchdog Timer (WDT)' ).\nThe WDT  timer and postscaler are cleared by executing a SLEEP or CLRWDT instruction, the loss of a currently selected clock source (if the Fail-Safe Clock Monitor is enabled) and modifying the IRCF bits in the OSCCON register if the internal oscillator block is the device clock source.",
    "4.5.3 EXIT BY RESET\nNormally, the device is held in Reset by the Oscillator Start-up Timer (OST) until the primary clock becomes ready. At that time, the OSTS bit is set and the device begins executing code. If the internal oscillator block is the new clock source, the IOFS bit is set instead.\nThe  exit  delay  time  from  Reset  to  the  start  of  code execution depends on both the clock sources before and after the wake-up, and the type of oscillator if the new clock source is the primary clock. Exit delays are summarized in Table 4-2.",
    "4.5.3 EXIT BY RESET\nCode  execution  can  begin  before  the  primary  clock becomes ready. If either the Two-Speed Start-up (see Section 23.3  'Two-Speed  Start-up' ) or Fail-Safe Clock  Monitor  (see Section 23.4  'Fail-Safe  Clock Monitor' ) is enabled, the device may begin execution as soon as the Reset source has cleared. Execution is clocked  by  the  INTOSC  multiplexer  driven  by  the internal  oscillator  block.  Execution  is  clocked  by  the internal  oscillator  block  until  either  the  primary  clock becomes ready or a power-managed mode is entered before the primary clock becomes ready; the primary clock is then shut down.",
    "4.5.4 EXIT WITHOUT AN OSCILLATOR START-UP DELAY\nCertain  exits  from  power-managed  modes  do  not invoke the OST at all. There are two cases:\n\u00b7 PRI_IDLE mode, where the primary clock source is not stopped; and\n\u00b7 the primary clock source is not any of the LP, XT, HS or HSPLL modes.\nIn  these  instances,  the  primary  clock  source  either does not require an oscillator start-up delay since it is already  running  (PRI_IDLE),  or  normally  does  not require an oscillator start-up delay (RC, EC and INTIO Oscillator modes). However, a fixed delay of interval, TCSD, following the wake event, is still required when leaving  Sleep  and  Idle  modes  to  allow  the  CPU  to prepare for  execution.  Instruction  execution  resumes on the first clock cycle following this delay.",
    "TABLE 4-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nPrimary Device Clock (PRI_IDLE mode), Clock Source After Wake-up = LP, XT, HS. Primary Device Clock (PRI_IDLE mode), Exit Delay = T CSD (1). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = . Primary Device Clock (PRI_IDLE mode), Clock Source After Wake-up = HSPLL. Primary Device Clock (PRI_IDLE mode), Exit Delay = T CSD (1). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = OSTS. Primary Device Clock (PRI_IDLE mode), Clock Source After Wake-up = EC, RC. Primary Device Clock (PRI_IDLE mode), Exit Delay = T CSD (1). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = . Primary Device Clock (PRI_IDLE mode), Clock Source After Wake-up = INTOSC (2). Primary Device Clock (PRI_IDLE mode), Exit Delay = T CSD",
    "TABLE 4-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\n(1). Primary Device Clock (PRI_IDLE mode), Clock Ready Status Bit (OSCCON) = IOFS. T1OSC, Clock Source After Wake-up = LP, XT, HS. T1OSC, Exit Delay = T OST (3). T1OSC, Clock Ready Status Bit (OSCCON) = OSTS. T1OSC, Clock Source After Wake-up = HSPLL. T1OSC, Exit Delay = T OST + t rc (3). T1OSC, Clock Ready Status Bit (OSCCON) = OSTS. T1OSC, Clock Source After Wake-up = EC, RC. T1OSC, Exit Delay = T CSD (1). T1OSC, Clock Ready Status Bit (OSCCON) = OSTS. T1OSC, Clock Source After Wake-up = INTOSC (2). T1OSC, Exit Delay = TIOBST (4). T1OSC, Clock Ready Status Bit (OSCCON) = IOFS.",
    "TABLE 4-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nINTOSC (3), Clock Source After Wake-up = LP, XT, HS. INTOSC (3), Exit Delay = T OST (3). INTOSC (3), Clock Ready Status Bit (OSCCON) = OSTS. INTOSC (3), Clock Source After Wake-up = HSPLL. INTOSC (3), Exit Delay = T OST + t rc (3). INTOSC (3), Clock Ready Status Bit (OSCCON) = OSTS. INTOSC (3), Clock Source After Wake-up = EC, RC. INTOSC (3), Exit Delay = T CSD (1). INTOSC (3), Clock Ready Status Bit (OSCCON) = OSTS. INTOSC (3), Clock Source After Wake-up = INTOSC (2). INTOSC (3), Exit Delay = None. INTOSC (3), Clock Ready Status Bit (OSCCON) = IOFS. None (Sleep mode), Clock Source After Wake-up = LP, XT, HS.",
    "TABLE 4-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nNone (Sleep mode), Exit Delay = T OST (3). None (Sleep mode), Clock Ready Status Bit (OSCCON) = OSTS. None (Sleep mode), Clock Source After Wake-up = HSPLL. None (Sleep mode), Exit Delay = T OST + t rc (3). None (Sleep mode), Clock Ready Status Bit (OSCCON) = OSTS. None (Sleep mode), Clock Source After Wake-up = EC, RC. None (Sleep mode), Exit Delay = T CSD (1). None (Sleep mode), Clock Ready Status Bit (OSCCON) = OSTS. None (Sleep mode), Clock Source After Wake-up = INTOSC (2). None (Sleep mode), Exit Delay = TIOBST (4). None (Sleep mode), Clock Ready Status Bit (OSCCON) = IOFS",
    "TABLE 4-2: EXIT DELAY ON WAKE-UP BY RESET FROM SLEEP MODE OR ANY IDLE MODE (BY CLOCK SOURCES)\nNote 1: TCSD (Parameter 38) is a required delay when waking from Sleep and all Idle modes, and runs concurrently with any other required delays (see Section 4.4 'Idle Modes' ).\n2: Includes both the INTOSC 8 MHz source and postscaler derived frequencies.\n3: TOST is the Oscillator Start-up Timer (Parameter 32). t rc is the PLL Lock-out Timer (Parameter F12); it is also designated as TPLL.\n4: Execution continues during TIOBST (Parameter 39), the INTOSC stabilization period.",
    "5.0 RESET\nThe PIC18F2331/2431/4331/4431 devices differentiate between various kinds of Reset:\na) Power-on Reset (POR)\nb) MCLR Reset during normal operation\nc) MCLR Reset during Sleep\nd) Watchdog Timer (WDT) Reset (during execution)\ne) Programmable Brown-out Reset (BOR)\nf) RESET Instruction\ng) Stack Full Reset\nh) Stack Underflow Reset",
    "FIGURE 5-1: SIMPLIFIED BLOCK DIAGRAM OF ON-CHIP RESET CIRCUIT\nThis  section  discusses  Resets  generated  by  MCLR, POR and BOR, and the operation of the various startup timers. Stack Reset events are covered in Section 6.1.2.4 'Stack Full/Underflow Resets' . WDT Resets are covered in Section 23.2 'Watchdog Timer (WDT)' .\nA simplified block diagram of the On-Chip Reset Circuit is shown in Figure 5-1.",
    "5.1 RCON Register\nDevice  Reset  events  are  tracked  through  the  RCON register (Register 5-1). The lower five bits of the register indicate that a specific Reset event has occurred. In most cases, these bits can only be cleared by the event and must be set by the application after the event. The state of these flag bits, taken together, can be read to indicate the type of Reset that just occurred. This is described in more detail in Section 5.6 'Reset State of Registers' .\n- Note 1: If the  BOREN  Configuration  bit  is  set (Brown-out Reset enabled), the BOR bit is ' 1 ' on  a  Power-on  Reset.  After  a Brown-out Reset has occurred, the BOR bit  will  be  cleared  and  must  be  set  by firmware to indicate the occurrence of the next Brown-out Reset.\nThe  RCON  register  also  has  control  bits  for  setting interrupt  priority  (IPEN)  and  software  control  of  the BOR  (SBOREN).  Interrupt  priority  is  discussed  in Section 10.0 'Interrupts' . BOR is covered in Section 5.4 'Brown-out Reset (BOR)' .",
    "5.1 RCON Register\n- 2: It  is  recommended  that  the  POR  bit  be set  after  a  Power-on  Reset  has  been detected,  so  that  subsequent  Power-on Resets may be detected.",
    "REGISTER 5-1: RCON: RESET CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R-1. R/W-0, 5 = R-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR (2). IPEN, 7 = BOR (1). bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 5-1: RCON: RESET CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 IPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16CXXX Compatibility mode)\nUnimplemented: Read as ' 0 '\nRI: RESET Instruction Flag bit\n1 = The RESET instruction was not executed (set by firmware only)\n0 = The RESET instruction was executed causing a device Reset (must be set in software after a Brown-out Reset occurs)\nTO: Watchdog Time-out Flag bit\n1 = Set by power-up, CLRWDT instruction or SLEEP instruction\n0 = A WDT time-out occurred\nPD: Power-Down Detection Flag bit\n1 = Set by power-up or by the CLRWDT instruction\n0 = Set by execution of the SLEEP instruction\nbit 1 POR: Power-on Reset Status bit\n(2)\n1 = A Power-on Reset has not occurred (set by firmware only)\n0 = A Power-on Reset occurred (must be set in software after a Power-on Reset occurs)",
    "bit 0 BOR: Brown-out Reset Status bit\n(1)\n1 = A Brown-out Reset has not occurred (set by firmware only)\n0 = A Brown-out Reset occurred (must be set in software after a Brown-out Reset occurs)\nNote 1: If SBOREN is enabled, its Reset state is ' 1 '; otherwise, it is ' 0 '.\n2: The actual Reset value of POR is determined by the type of device Reset. See the notes following this register and Section 5.6 'Reset State of Registers' for additional information.\nNote 1: It is recommended that the POR bit be set after a Power-on Reset has been detected so that subsequent Power-on Resets may be detected.\n2: Brown-out Reset is said to have occurred when BOR is ' 0 ' and POR is ' 1 ' (assuming that POR was set to ' 1 ' by software immediately after a Power-on Reset).",
    "bit 6-5\nbit 4",
    "bit 3\n- bit 2",
    "5.2 Master Clear (MCLR)\nThe  MCLR  pin  can  trigger  an  external  Reset  of  the device by holding the pin low. These devices have a noise filter in the  MCLR Reset path that detects and ignores small pulses.\nThe MCLR pin is not driven low by any internal Resets, including the Watchdog Timer.\nIn  PIC18F2331/2431/4331/4431  devices,  the  MCLR input can be disabled with the MCLRE Configuration bit. When MCLR is disabled, the pin becomes a digital input. For more information, see Section 11.5 'PORTE, TRISE and LATE Registers' .",
    "5.3 Power-on Reset (POR)\nA Power-on Reset pulse is generated on-chip whenever VDD rises above a certain threshold. This allows the device to start in the initialized state when VDD is adequate for operation.\nTo take advantage of the POR circuitry, tie the MCLR pin through a resistor (1 k \uf057 to 10 k \uf057 ) to VDD. This will eliminate external RC components usually needed to create a Power-on Reset delay. The minimum rise rate for VDD is specified (Parameter D004). For a slow rise time, see Figure 5-2.\nWhen the device starts normal operation (i.e., exits the Reset  condition),  device  operating  parameters  (such as voltage, frequency and temperature) must be met to ensure operation. If these conditions are not met, the device  must  be  held  in  Reset  until  the  operating conditions are met.",
    "5.3 Power-on Reset (POR)\nPower-on Reset events are captured by the POR bit (RCON<1>). The state of the bit is set to ' 0 ' whenever a POR occurs and does not change for any other Reset event. POR is not reset to ' 1 ' by any hardware event. To capture multiple events, the  user  manually  resets the bit to ' 1 ' in software following any Power-on Reset.\nNote:, 1 = The following decoupling method is recommended:. , 1 = 1. A 1 \uf06d F capacitor should be connected across AVDD and AVSS.. , 1 = 2. A similar capacitor should be connected across VDD and VSS.",
    "EXTERNAL POWER-ON RESET CIRCUIT (FOR SLOW VDD POWER-UP)\nNote 1: External Power-on Reset circuit is required only if the VDD power-up slope is too slow. The diode, D, helps discharge the capacitor quickly when VDD powers down.\n2: R  <  40 k \uf057 is  recommended  to  make sure that the voltage drop across R does not violate the device's electrical specification.\n3: R1 \uf0b3 1 k \uf057 will limit any current flowing into MCLR from external capacitor, C, in the event of MCLR/VPP pin breakdown, due to Electrostatic Discharge (ESD) or Electrical Overstress (EOS).",
    "5.4 Brown-out Reset (BOR)\nA  Configuration  bit,  BOREN,  can  disable  (if  clear/ programmed) or enable (if  set)  the  Brown-out  Reset circuitry.  If  VDD  falls  below  VBOR  (Parameter  D005A through D005F) for greater than TBOR (Parameter 35), the brown-out situation will reset the chip. A Reset may not occur if VDD falls below VBOR for less than TBOR. The chip will remain in Brown-out Reset until VDD rises above VBOR. If the Power-up Timer is enabled, it will be invoked after VDD rises above VBOR; it then will keep the chip in Reset for an additional time delay TPWRT (Parameter 33).  If  VDD  drops  below  VBOR  while  the Power-up Timer is running, the chip will go back into a Brown-out  Reset  and  the  Power-up  Timer  will  be initialized. Once VDD rises above VBOR, the Power-up Timer will execute the additional time delay. Enabling the Brown-out Reset does not automatically enable the PWRT.",
    "5.5.3 PLL LOCK TIME-OUT\nPIC18F2331/2431/4331/4431 devices incorporate three  separate  on-chip  timers  that  help  regulate  the Power-on  Reset  process.  Their  main  function  is  to ensure that the device clock is stable before code is executed. These timers are:\n\u00b7 Power-up Timer (PWRT)\n\u00b7 Oscillator Start-up Timer (OST)\n\u00b7 PLL Lock Time-out",
    "5.5.1 POWER-UP TIMER (PWRT)\nThe  Power-up  Timer  (PWRT)  of  PIC18F2331/2431/ 4331/4431 devices is an 11-bit counter that uses the INTRC  source  as  the  clock  input.  This  yields  an approximate time interval of 2,048 x 32 \uf06d s = 65.6 ms.\nWhile  the  PWRT  is  counting,  the  device  is  held  in Reset.  The  power-up  time  delay  depends  on  the INTRC clock and will vary from chip to chip due to temperature and process variation. See DC Parameter 33 for details.\nThe  PWRT  is  enabled  by  clearing  the  PWRTEN Configuration bit.",
    "5.5.2 OSCILLATOR START-UP TIMER (OST)\nThe Oscillator Start-up Timer (OST) provides a 1,024 oscillator cycle (from OSC1 input) delay after the PWRT delay is over (Parameter 33). This ensures that the  crystal  oscillator  or  resonator  has  started  and stabilized.\nThe OST time-out is invoked only for XT, LP, HS and HSPLL modes, and on Power-on Reset or on exit from most power-managed modes.",
    "TABLE 5-1: TIME-OUT IN VARIOUS SITUATIONS\nHSPLL, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1) + 1024 T OSC + 2 ms (2). HSPLL, Power-up (2) and Brown-out.PWRTEN = 1 = 1024 T OSC + 2 ms (2). HSPLL, Exit From Power-Managed Mode.Exit From Power-Managed Mode = 1024 T OSC + 2 ms (2). HS, XT, LP, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1) + 1024 T OSC. HS, XT, LP, Power-up (2) and Brown-out.PWRTEN = 1 = 1024 T OSC. HS, XT, LP, Exit From Power-Managed Mode.Exit From Power-Managed Mode = 1024 T OSC. EC, ECIO, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1). EC, ECIO, Power-up (2) and Brown-out.PWRTEN = 1 =",
    "TABLE 5-1: TIME-OUT IN VARIOUS SITUATIONS\n-. EC, ECIO, Exit From Power-Managed Mode.Exit From Power-Managed Mode = -. RC, RCIO, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1). RC, RCIO, Power-up (2) and Brown-out.PWRTEN = 1 = -. RC, RCIO, Exit From Power-Managed Mode.Exit From Power-Managed Mode = -. INTIO1, INTIO2, Power-up (2) and Brown-out.PWRTEN = 0 = 66 ms (1). INTIO1, INTIO2, Power-up (2) and Brown-out.PWRTEN = 1 = -. INTIO1, INTIO2, Exit From Power-Managed Mode.Exit From Power-Managed Mode = -\nNote 1: 66 ms (65.5 ms) is the nominal Power-up Timer (PWRT) delay.\n- 2: 2 ms is the nominal time required for the 4x PLL to lock.",
    "TABLE 5-1: TIME-OUT IN VARIOUS SITUATIONS\nWith  the  PLL  enabled  in  its  PLL  mode,  the  time-out sequence following a Power-on Reset is slightly different  from  other  oscillator  modes.  A  separate  timer  is used to provide a fixed time-out that is sufficient for the PLL to lock to the main oscillator frequency. This PLL Lock Time-out (TPLL) is typically 2 ms and follows the oscillator start-up time-out.",
    "5.5.4 TIME-OUT SEQUENCE\nOn power-up, the time-out sequence is as follows:\n1. After the POR pulse has cleared, the PWRT time-out is invoked (if enabled).\n2. Then, the OST is activated.\nThe total time-out will vary based on oscillator configuration and the status of the PWRT. Figure 5-3 through Figure 5-7  depict  time-out  sequences  on  power-up, with the Power-up Timer enabled and the device operating in HS  Oscillator mode. Figure 5-3 through Figure 5-6 also apply to devices operating in XT or LP modes.\nFor devices in RC mode, and with the PWRT disabled, there  will  be  no  time-out  at  all.  Since  the  time-outs occur from the POR pulse, if MCLR is kept low long enough, all time-outs will expire. Bringing MCLR high will  begin  execution  immediately (Figure 5-5). This is useful for testing purposes or synchronization of more than one PIC18FXXXX device operating in parallel.",
    "5.6 Reset State of Registers\nMost registers are unaffected by a Reset. Their status is unknown  on  POR  and  unchanged  by  all  other Resets.  The  other  registers  are  forced  to  a  'Reset state' depending on the type of Reset that occurred.\nStatus bits from the RCON register (RI, TO, PD, POR and  BOR)  are  set  or  cleared  differently  in  different Reset situations, as indicated in Table 5-2. These bits are  used  in  software  to  determine  the  nature  of  the Reset.\nMost  registers  are  not  affected  by  a  WDT  wake-up, since  this  is  viewed  as  the  resumption  of  normal operation.\nTable 5-3  describes  the  Reset  states  for  all  of  the Special Function Registers. These are categorized by Power-on  and  Brown-out  Resets,  Master  Clear  and WDT Resets, and WDT wake-ups.",
    "FIGURE 5-3: TIME-OUT SEQUENCE ON POWER-UP (MCLR TIED TO VDD, VDD RISE < TPWRT)\nTPWRT\nTOST\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET",
    "TIME-OUT SEQUENCE ON POWER-UP (MCLR NOT TIED TO VDD): CASE 1\nTPWRT\nTOST\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET",
    "TIME-OUT SEQUENCE ON POR w/PLL ENABLED (MCLR TIED TO VDD)\nNote:\nTOST = 1024 clock cycles.\nTPLL \uf0bb 2 ms max. First three stages of the PWRT timer.",
    "TABLE 5-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nPower-on Reset, Program Counter = 0000h. Power-on Reset, RCON Register = 0--1 1100. Power-on Reset, RI = 1. Power-on Reset, TO = 1. Power-on Reset, PD = 1. Power-on Reset, POR = 0. Power-on Reset, BOR = 0. Power-on Reset, STKFUL = 0. Power-on Reset, STKUNF = 0. RESET Instruction, Program Counter = 0000h. RESET Instruction, RCON Register = 0--0 uuuu. RESET Instruction, RI = 0. RESET Instruction, TO = u. RESET Instruction, PD = u. RESET Instruction, POR = u. RESET Instruction, BOR = u. RESET Instruction, STKFUL = u. RESET Instruction, STKUNF = u. Brown-out, Program Counter = 0000h. Brown-out, RCON Register = 0--1 11u-. Brown-out, RI = 1. Brown-out, TO = 1. Brown-out, PD = 1. Brown-out, POR = u.",
    "TABLE 5-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nBrown-out, BOR = 0. Brown-out, STKFUL = u. Brown-out, STKUNF = u. MCLR Reset during power-managed Run modes, Program Counter = 0000h. MCLR Reset during power-managed Run modes, RCON Register = 0--u 1uuu. MCLR Reset during power-managed Run modes, RI = u. MCLR Reset during power-managed Run modes, TO = 1. MCLR Reset during power-managed Run modes, PD = u. MCLR Reset during power-managed Run modes, POR = u. MCLR Reset during power-managed Run modes, BOR = u. MCLR Reset during power-managed Run modes, STKFUL = u. MCLR Reset during power-managed Run modes, STKUNF = u. MCLR Reset during power-managed Idle and Sleep modes, Program Counter = 0000h. MCLR Reset during power-managed Idle and Sleep modes, RCON Register = 0--u 10uu. MCLR Reset during power-managed Idle and Sleep modes, RI = u. MCLR Reset during",
    "TABLE 5-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\npower-managed Idle and Sleep modes, TO = 1. MCLR Reset during power-managed Idle and Sleep modes, PD = 0. MCLR Reset during power-managed Idle and Sleep modes, POR = u. MCLR Reset during power-managed Idle and Sleep modes, BOR = u. MCLR Reset during power-managed Idle and Sleep modes, STKFUL = u. MCLR Reset during power-managed Idle and Sleep modes, STKUNF = u. WDT Time-out during full power or power-managed Run modes, Program Counter = 0000h. WDT Time-out during full power or power-managed Run modes, RCON Register = 0--u 0uuu. WDT Time-out during full power or power-managed Run modes, RI = u. WDT Time-out during full power or power-managed Run modes, TO = 0. WDT Time-out during full power or power-managed Run modes, PD = u. WDT Time-out during full power or power-managed Run modes, POR = u. WDT Time-out during full power or power-managed Run",
    "TABLE 5-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nmodes, BOR = u. WDT Time-out during full power or power-managed Run modes, STKFUL = u. WDT Time-out during full power or power-managed Run modes, STKUNF = u. MCLR Reset during full-power execution, Program Counter = . MCLR Reset during full-power execution, RCON Register = . MCLR Reset during full-power execution, RI = . MCLR Reset during full-power execution, TO = . MCLR Reset during full-power execution, PD = . MCLR Reset during full-power execution, POR = . MCLR Reset during full-power execution, BOR = . MCLR Reset during full-power execution, STKFUL = u. MCLR Reset during full-power execution, STKUNF = u. Stack Full Reset (STVREN = 1 ), Program Counter = 0000h. Stack Full Reset (STVREN = 1 ), RCON Register = 0--u uuuu. Stack Full Reset (STVREN = 1 ), RI = u. Stack Full Reset (STVREN = 1 ),",
    "TABLE 5-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nTO = u. Stack Full Reset (STVREN = 1 ), PD = u. Stack Full Reset (STVREN = 1 ), POR = u. Stack Full Reset (STVREN = 1 ), BOR = u. Stack Full Reset (STVREN = 1 ), STKFUL = 1. Stack Full Reset (STVREN = 1 ), STKUNF = u. Stack Underflow Reset (STVREN = 1 ), Program Counter = . Stack Underflow Reset (STVREN = 1 ), RCON Register = . Stack Underflow Reset (STVREN = 1 ), RI = . Stack Underflow Reset (STVREN = 1 ), TO = . Stack Underflow Reset (STVREN = 1 ), PD = . Stack Underflow Reset (STVREN = 1 ), POR = . Stack Underflow Reset (STVREN = 1 ), BOR = . Stack Underflow Reset (STVREN = 1 ), STKFUL = u. Stack Underflow Reset (STVREN = 1 ), STKUNF = 1. Stack Underflow Error (not",
    "TABLE 5-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nan actual Reset, STVREN = 0 ), Program Counter = 0000h. Stack Underflow Error (not an actual Reset, STVREN = 0 ), RCON Register = u--u uuuu. Stack Underflow Error (not an actual Reset, STVREN = 0 ), RI = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), TO = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), PD = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), POR = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), BOR = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), STKFUL = u. Stack Underflow Error (not an actual Reset, STVREN = 0 ), STKUNF = 1. WDT time-out during power-managed Idle or Sleep modes, Program Counter = PC + 2. WDT time-out during power-managed Idle or Sleep modes,",
    "TABLE 5-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nRCON Register = u--u 00uu. WDT time-out during power-managed Idle or Sleep modes, RI = u. WDT time-out during power-managed Idle or Sleep modes, TO = 0. WDT time-out during power-managed Idle or Sleep modes, PD = 0. WDT time-out during power-managed Idle or Sleep modes, POR = u. WDT time-out during power-managed Idle or Sleep modes, BOR = u. WDT time-out during power-managed Idle or Sleep modes, STKFUL = u. WDT time-out during power-managed Idle or Sleep modes, STKUNF = u. Interrupt exit from power-managed modes, Program Counter = PC + 2 (1). Interrupt exit from power-managed modes, RCON Register = u--u u0uu. Interrupt exit from power-managed modes, RI = u. Interrupt exit from power-managed modes, TO = u. Interrupt exit from power-managed modes, PD = 0. Interrupt exit from power-managed modes, POR = u. Interrupt exit from power-managed",
    "TABLE 5-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nmodes, BOR = u. Interrupt exit from power-managed modes, STKFUL = u. Interrupt exit from power-managed modes, STKUNF = u\nLegend:\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 '.\nNote 1: When the wake-up is due to an interrupt and the GIEH or GIEL bits are set, the PC is loaded with the interrupt vector (0x000008h or 0x000018h).",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTOSU, Applicable Devices = 2331. TOSU, Applicable Devices = 2431. TOSU, Applicable Devices = 4331. TOSU, Applicable Devices = 4431. TOSU, Power-on Reset, Brown-out Reset = ---0 0000. TOSU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. TOSU, Wake-up via WDT or Interrupt = ---0 uuuu (3). TOSH, Applicable Devices = 2331. TOSH, Applicable Devices = 2431. TOSH, Applicable Devices = 4331. TOSH, Applicable Devices = 4431. TOSH, Power-on Reset, Brown-out Reset = 0000 0000. TOSH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSH, Wake-up via WDT or Interrupt = uuuu uuuu (3). TOSL, Applicable Devices = 2331. TOSL, Applicable Devices = 2431. TOSL, Applicable Devices = 4331. TOSL, Applicable Devices = 4431. TOSL, Power-on",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nReset, Brown-out Reset = 0000 0000. TOSL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSL, Wake-up via WDT or Interrupt = uuuu uuuu (3). STKPTR, Applicable Devices = 2331. STKPTR, Applicable Devices = 2431. STKPTR, Applicable Devices = 4331. STKPTR, Applicable Devices = 4431. STKPTR, Power-on Reset, Brown-out Reset = 00-0 0000. STKPTR, MCLR Resets WDT Reset RESET Instruction Stack Resets = uu-0 0000. STKPTR, Wake-up via WDT or Interrupt = uu-u uuuu (3). PCLATU, Applicable Devices = 2331. PCLATU, Applicable Devices = 2431. PCLATU, Applicable Devices = 4331. PCLATU, Applicable Devices = 4431. PCLATU, Power-on Reset, Brown-out Reset = ---0 0000. PCLATU, MCLR Resets WDT Reset",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nRESET Instruction Stack Resets = ---0 0000. PCLATU, Wake-up via WDT or Interrupt = ---u uuuu. PCLATH, Applicable Devices = 2331. PCLATH, Applicable Devices = 2431. PCLATH, Applicable Devices = 4331. PCLATH, Applicable Devices = 4431. PCLATH, Power-on Reset, Brown-out Reset = 0000 0000. PCLATH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PCLATH, Wake-up via WDT or Interrupt = uuuu uuuu. PCL, Applicable Devices = 2331. PCL, Applicable Devices = 2431. PCL, Applicable Devices = 4331. PCL, Applicable Devices = 4431. PCL, Power-on Reset, Brown-out Reset = 0000 0000. PCL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PCL, Wake-up via WDT or Interrupt = PC + 2 (2). TBLPTRU, Applicable Devices = 2331.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTBLPTRU, Applicable Devices = 2431. TBLPTRU, Applicable Devices = 4331. TBLPTRU, Applicable Devices = 4431. TBLPTRU, Power-on Reset, Brown-out Reset = --00 0000. TBLPTRU, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. TBLPTRU, Wake-up via WDT or Interrupt = --uu uuuu. TBLPTRH, Applicable Devices = 2331. TBLPTRH, Applicable Devices = 2431. TBLPTRH, Applicable Devices = 4331. TBLPTRH, Applicable Devices = 4431. TBLPTRH, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRH, Wake-up via WDT or Interrupt = uuuu uuuu. TBLPTRL, Applicable Devices = 2331. TBLPTRL, Applicable Devices = 2431. TBLPTRL, Applicable Devices = 4331.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTBLPTRL, Applicable Devices = 4431. TBLPTRL, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRL, Wake-up via WDT or Interrupt = uuuu uuuu. TABLAT, Applicable Devices = 2331. TABLAT, Applicable Devices = 2431. TABLAT, Applicable Devices = 4331. TABLAT, Applicable Devices = 4431. TABLAT, Power-on Reset, Brown-out Reset = 0000 0000. TABLAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TABLAT, Wake-up via WDT or Interrupt = uuuu uuuu. PRODH, Applicable Devices = 2331. PRODH, Applicable Devices = 2431. PRODH, Applicable Devices = 4331. PRODH, Applicable Devices = 4431. PRODH, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODH, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nuuuu uuuu. PRODH, Wake-up via WDT or Interrupt = uuuu uuuu. PRODL, Applicable Devices = 2331. PRODL, Applicable Devices = 2431. PRODL, Applicable Devices = 4331. PRODL, Applicable Devices = 4431. PRODL, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PRODL, Wake-up via WDT or Interrupt = uuuu uuuu. INTCON, Applicable Devices = 2331. INTCON, Applicable Devices = 2431. INTCON, Applicable Devices = 4331. INTCON, Applicable Devices = 4431. INTCON, Power-on Reset, Brown-out Reset = 0000 000x. INTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000u. INTCON, Wake-up via WDT or Interrupt = uuuu uuuu (1). INTCON2, Applicable Devices = 2331. INTCON2, Applicable Devices",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n= 2431. INTCON2, Applicable Devices = 4331. INTCON2, Applicable Devices = 4431. INTCON2, Power-on Reset, Brown-out Reset = 1111 -1-1. INTCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 -1-1. INTCON2, Wake-up via WDT or Interrupt = uuuu -u-u (1). INTCON3, Applicable Devices = 2331. INTCON3, Applicable Devices = 2431. INTCON3, Applicable Devices = 4331. INTCON3, Applicable Devices = 4431. INTCON3, Power-on Reset, Brown-out Reset = 11-0 0-00. INTCON3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 11-0 0-00. INTCON3, Wake-up via WDT or Interrupt = uu-u u-uu (1). INDF0, Applicable Devices = 2331. INDF0, Applicable Devices = 2431. INDF0, Applicable Devices = 4331. INDF0, Applicable Devices = 4431.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nINDF0, Power-on Reset, Brown-out Reset = N/A. INDF0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF0, Wake-up via WDT or Interrupt = N/A. POSTINC0, Applicable Devices = 2331. POSTINC0, Applicable Devices = 2431. POSTINC0, Applicable Devices = 4331. POSTINC0, Applicable Devices = 4431. POSTINC0, Power-on Reset, Brown-out Reset = N/A. POSTINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC0, Wake-up via WDT or Interrupt = N/A. POSTDEC0, Applicable Devices = 2331. POSTDEC0, Applicable Devices = 2431. POSTDEC0, Applicable Devices = 4331. POSTDEC0, Applicable Devices = 4431. POSTDEC0, Power-on Reset, Brown-out Reset = N/A. POSTDEC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPOSTDEC0, Wake-up via WDT or Interrupt = N/A. PREINC0, Applicable Devices = 2331. PREINC0, Applicable Devices = 2431. PREINC0, Applicable Devices = 4331. PREINC0, Applicable Devices = 4431. PREINC0, Power-on Reset, Brown-out Reset = N/A. PREINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC0, Wake-up via WDT or Interrupt = N/A. PLUSW0, Applicable Devices = 2331. PLUSW0, Applicable Devices = 2431. PLUSW0, Applicable Devices = 4331. PLUSW0, Applicable Devices = 4431. PLUSW0, Power-on Reset, Brown-out Reset = N/A. PLUSW0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW0, Wake-up via WDT or Interrupt = N/A. FSR0H, Applicable Devices = 2331. FSR0H, Applicable Devices = 2431. FSR0H, Applicable",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nDevices = 4331. FSR0H, Applicable Devices = 4431. FSR0H, Power-on Reset, Brown-out Reset = ---- xxxx. FSR0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR0H, Wake-up via WDT or Interrupt = ---- uuuu. FSR0L, Applicable Devices = 2331. FSR0L, Applicable Devices = 2431. FSR0L, Applicable Devices = 4331. FSR0L, Applicable Devices = 4431. FSR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR0L, Wake-up via WDT or Interrupt = uuuu uuuu. WREG, Applicable Devices = 2331. WREG, Applicable Devices = 2431. WREG, Applicable Devices = 4331. WREG, Applicable Devices = 4431. WREG, Power-on",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nReset, Brown-out Reset = xxxx xxxx. WREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. WREG, Wake-up via WDT or Interrupt = uuuu uuuu. INDF1, Applicable Devices = 2331. INDF1, Applicable Devices = 2431. INDF1, Applicable Devices = 4331. INDF1, Applicable Devices = 4431. INDF1, Power-on Reset, Brown-out Reset = N/A. INDF1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF1, Wake-up via WDT or Interrupt = N/A. POSTINC1, Applicable Devices = 2331. POSTINC1, Applicable Devices = 2431. POSTINC1, Applicable Devices = 4331. POSTINC1, Applicable Devices = 4431. POSTINC1, Power-on Reset, Brown-out Reset = N/A. POSTINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC1,",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nWake-up via WDT or Interrupt = N/A. POSTDEC1, Applicable Devices = 2331. POSTDEC1, Applicable Devices = 2431. POSTDEC1, Applicable Devices = 4331. POSTDEC1, Applicable Devices = 4431. POSTDEC1, Power-on Reset, Brown-out Reset = N/A. POSTDEC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC1, Wake-up via WDT or Interrupt = N/A. PREINC1, Applicable Devices = 2331. PREINC1, Applicable Devices = 2431. PREINC1, Applicable Devices = 4331 4331. PREINC1, Applicable Devices = 4431. PREINC1, Power-on Reset, Brown-out Reset = N/A. PREINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC1, Wake-up via WDT or Interrupt = N/A. PLUSW1, Applicable Devices = 2331. PLUSW1, Applicable Devices = 2431. PLUSW1,",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nApplicable Devices = . PLUSW1, Applicable Devices = 4431. PLUSW1, Power-on Reset, Brown-out Reset = N/A. PLUSW1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW1, Wake-up via WDT or Interrupt = N/A\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 5-2 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: Bit 3 of PORTE and LATE are enabled if MCLR functionality is disabled. When not enabled as the PORTE pin, they are disabled and read as ' 0 '. The 28-pin devices do not have only RE3 implemented.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFSR1H, Applicable Devices = 2331. FSR1H, Applicable Devices = 2431. FSR1H, Applicable Devices = 4331. FSR1H, Applicable Devices = 4431. FSR1H, Power-on Reset, Brown-out Reset = ---- 0000. FSR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR1H, Wake-up via WDT or Interrupt = ---- uuuu. FSR1L, Applicable Devices = 2331. FSR1L, Applicable Devices = 2431. FSR1L, Applicable Devices = 4331. FSR1L, Applicable Devices = 4431. FSR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR1L, Wake-up via WDT or Interrupt = uuuu uuuu. BSR, Applicable Devices = 2331. BSR,",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices = 2431. BSR, Applicable Devices = 4331. BSR, Applicable Devices = 4431. BSR, Power-on Reset, Brown-out Reset = ---- 0000. BSR, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. BSR, Wake-up via WDT or Interrupt = ---- uuuu. INDF2, Applicable Devices = 2331. INDF2, Applicable Devices = 2431. INDF2, Applicable Devices = 4331. INDF2, Applicable Devices = 4431. INDF2, Power-on Reset, Brown-out Reset = N/A. INDF2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF2, Wake-up via WDT or Interrupt = N/A. POSTINC2, Applicable Devices = 2331. POSTINC2, Applicable Devices = 2431. POSTINC2, Applicable Devices = 4331. POSTINC2, Applicable Devices = 4431. POSTINC2, Power-on Reset, Brown-out Reset",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= N/A. POSTINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC2, Wake-up via WDT or Interrupt = N/A. POSTDEC2, Applicable Devices = 2331. POSTDEC2, Applicable Devices = 2431. POSTDEC2, Applicable Devices = 4331. POSTDEC2, Applicable Devices = 4431. POSTDEC2, Power-on Reset, Brown-out Reset = N/A. POSTDEC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC2, Wake-up via WDT or Interrupt = N/A. PREINC2, Applicable Devices = 2331. PREINC2, Applicable Devices = 2431. PREINC2, Applicable Devices = 4331. PREINC2, Applicable Devices = 4431. PREINC2, Power-on Reset, Brown-out Reset = N/A. PREINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC2, Wake-up via",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = N/A. PLUSW2, Applicable Devices = 2331. PLUSW2, Applicable Devices = 2431. PLUSW2, Applicable Devices = 4331. PLUSW2, Applicable Devices = 4431. PLUSW2, Power-on Reset, Brown-out Reset = N/A. PLUSW2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW2, Wake-up via WDT or Interrupt = N/A. FSR2H, Applicable Devices = 2331. FSR2H, Applicable Devices = 2431. FSR2H, Applicable Devices = 4331. FSR2H, Applicable Devices = 4431. FSR2H, Power-on Reset, Brown-out Reset = ---- 0000. FSR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR2H, Wake-up via WDT or Interrupt = ---- uuuu. FSR2L, Applicable Devices = 2331. FSR2L, Applicable Devices =",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n2431. FSR2L, Applicable Devices = 4331. FSR2L, Applicable Devices = 4431. FSR2L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR2L, Wake-up via WDT or Interrupt = uuuu uuuu. STATUS, Applicable Devices = 2331. STATUS, Applicable Devices = 2431. STATUS, Applicable Devices = 4331. STATUS, Applicable Devices = 4431. STATUS, Power-on Reset, Brown-out Reset = ---x xxxx. STATUS, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---u uuuu. STATUS, Wake-up via WDT or Interrupt = ---u uuuu. TMR0H, Applicable Devices = 2331. TMR0H, Applicable Devices = 2431. TMR0H, Applicable Devices = 4331. TMR0H, Applicable Devices = 4431.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTMR0H, Power-on Reset, Brown-out Reset = 0000 0000. TMR0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TMR0H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR0L, Applicable Devices = 2331. TMR0L, Applicable Devices = 2431. TMR0L, Applicable Devices = 4331. TMR0L, Applicable Devices = 4431. TMR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR0L, Wake-up via WDT or Interrupt = uuuu uuuu. T0CON, Applicable Devices = 2331. T0CON, Applicable Devices = 2431. T0CON, Applicable Devices = 4331. T0CON, Applicable Devices = 4431. T0CON, Power-on Reset, Brown-out",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset = 1111 1111. T0CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. T0CON, Wake-up via WDT or Interrupt = uuuu uuuu. OSCCON, Applicable Devices = 2331. OSCCON, Applicable Devices = 2431. OSCCON, Applicable Devices = 4331. OSCCON, Applicable Devices = 4431. OSCCON, Power-on Reset, Brown-out Reset = 0000 q000. OSCCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 q000. OSCCON, Wake-up via WDT or Interrupt = uuuu uuuu. LVDCON, Applicable Devices = 2331. LVDCON, Applicable Devices = 2431. LVDCON, Applicable Devices = 4331. LVDCON, Applicable Devices = 4431. LVDCON, Power-on Reset, Brown-out Reset = --00 0101. LVDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0101.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLVDCON, Wake-up via WDT or Interrupt = --uu uuuu. WDTCON, Applicable Devices = 2331. WDTCON, Applicable Devices = 2431. WDTCON, Applicable Devices = 4331. WDTCON, Applicable Devices = 4431. WDTCON, Power-on Reset, Brown-out Reset = 0--- ---0. WDTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0--- ---0. WDTCON, Wake-up via WDT or Interrupt = u--- ---u. RCON (4), Applicable Devices = 2331. RCON (4), Applicable Devices = 2431. RCON (4), Applicable Devices = 4331. RCON (4), Applicable Devices = 4431. RCON (4), Power-on Reset, Brown-out Reset = 0--1 11q0. RCON (4), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0--q qquu. RCON (4), Wake-up via",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = u--u qquu. TMR1H, Applicable Devices = 2331. TMR1H, Applicable Devices = 2431. TMR1H, Applicable Devices = 4331. TMR1H, Applicable Devices = 4431. TMR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR1L, Applicable Devices = 2331. TMR1L, Applicable Devices = 2431. TMR1L, Applicable Devices = 4331. TMR1L, Applicable Devices = 4431. TMR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1L, Wake-up via",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu uuuu. T1CON, Applicable Devices = 2331. T1CON, Applicable Devices = 2431. T1CON, Applicable Devices = 4331. T1CON, Applicable Devices = 4431. T1CON, Power-on Reset, Brown-out Reset = 0000 0000. T1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = u0uu uuuu. T1CON, Wake-up via WDT or Interrupt = uuuu uuuu. TMR2, Applicable Devices = 2331. TMR2, Applicable Devices = 2431. TMR2, Applicable Devices = 4331. TMR2, Applicable Devices = 4431. TMR2, Power-on Reset, Brown-out Reset = 0000 0000. TMR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TMR2, Wake-up via WDT or Interrupt = uuuu uuuu. PR2, Applicable Devices = 2331.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPR2, Applicable Devices = 2431. PR2, Applicable Devices = 4331. PR2, Applicable Devices = 4431. PR2, Power-on Reset, Brown-out Reset = 1111 1111. PR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. PR2, Wake-up via WDT or Interrupt = 1111 1111. T2CON, Applicable Devices = 2331. T2CON, Applicable Devices = 2431. T2CON, Applicable Devices = 4331. T2CON, Applicable Devices = 4431. T2CON, Power-on Reset, Brown-out Reset = -000 0000. T2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. T2CON, Wake-up via WDT or Interrupt = -uuu uuuu. SSPBUF, Applicable Devices = 2331. SSPBUF, Applicable Devices = 2431. SSPBUF, Applicable Devices = 4331. SSPBUF, Applicable Devices = 4431. SSPBUF, Power-on Reset,",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = xxxx xxxx. SSPBUF, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. SSPBUF, Wake-up via WDT or Interrupt = uuuu uuuu. SSPADD, Applicable Devices = 2331. SSPADD, Applicable Devices = 2431. SSPADD, Applicable Devices = 4331. SSPADD, Applicable Devices = 4431. SSPADD, Power-on Reset, Brown-out Reset = 0000 0000. SSPADD, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPADD, Wake-up via WDT or Interrupt = uuuu uuuu. SSPSTAT, Applicable Devices = 2331. SSPSTAT, Applicable Devices = 2431. SSPSTAT, Applicable Devices = 4331. SSPSTAT, Applicable Devices = 4431. SSPSTAT, Power-on Reset, Brown-out Reset = 0000 0000. SSPSTAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000. SSPSTAT, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON, Applicable Devices = 2331. SSPCON, Applicable Devices = 2431. SSPCON, Applicable Devices = 4331. SSPCON, Applicable Devices = 4431. SSPCON, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPCON, Wake-up via WDT or Interrupt = uuuu uuuu\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 5-2 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: Bit 3 of PORTE and LATE are enabled if MCLR functionality is disabled. When not enabled as the PORTE pin, they are disabled and read as ' 0 '. The 28-pin devices do not have only RE3 implemented.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADRESH, Applicable Devices = 2331. ADRESH, Applicable Devices = 2431. ADRESH, Applicable Devices = 4331. ADRESH, Applicable Devices = 4431. ADRESH, Power-on Reset, Brown-out Reset = xxxx. ADRESH, Power-on Reset, Brown-out Reset = xxxx. ADRESH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. ADRESH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. ADRESH, Wake-up via WDT or Interrupt = uuuu. ADRESH, Wake-up via WDT or Interrupt = uuuu. ADRESL, Applicable Devices = 2331. ADRESL, Applicable Devices = 2431. ADRESL, Applicable Devices = 4331. ADRESL, Applicable Devices = 4431. ADRESL, Power-on Reset, Brown-out Reset = xxxx. ADRESL, Power-on Reset, Brown-out Reset = xxxx. ADRESL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADRESL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. ADRESL, Wake-up via WDT or Interrupt = uuuu. ADRESL, Wake-up via WDT or Interrupt = uuuu. ADCON0, Applicable Devices = 2331. ADCON0, Applicable Devices = 2431. ADCON0, Applicable Devices = 4331. ADCON0, Applicable Devices = 4431. ADCON0, Power-on Reset, Brown-out Reset = --00. ADCON0, Power-on Reset, Brown-out Reset = 0000. ADCON0, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00. ADCON0, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ADCON0, Wake-up via WDT or Interrupt = --uu. ADCON0, Wake-up via WDT or Interrupt = uuuu. ADCON1, Applicable Devices = 2331. ADCON1, Applicable Devices = 2431. ADCON1, Applicable Devices = 4331.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADCON1, Applicable Devices = 4431. ADCON1, Power-on Reset, Brown-out Reset = 00-0. ADCON1, Power-on Reset, Brown-out Reset = 0000. ADCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 00-0. ADCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ADCON1, Wake-up via WDT or Interrupt = uu-u. ADCON1, Wake-up via WDT or Interrupt = uuuu. ADCON2, Applicable Devices = 2331. ADCON2, Applicable Devices = 2431. ADCON2, Applicable Devices = 4331. ADCON2, Applicable Devices = 4431. ADCON2, Power-on Reset, Brown-out Reset = 0000. ADCON2, Power-on Reset, Brown-out Reset = 0000. ADCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ADCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ADCON2,",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu. ADCON2, Wake-up via WDT or Interrupt = uuuu. ADCON3, Applicable Devices = 2331. ADCON3, Applicable Devices = 2431. ADCON3, Applicable Devices = 4331. ADCON3, Applicable Devices = 4431. ADCON3, Power-on Reset, Brown-out Reset = 00-0. ADCON3, Power-on Reset, Brown-out Reset = 0000. ADCON3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 00-0. ADCON3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ADCON3, Wake-up via WDT or Interrupt = uu-u. ADCON3, Wake-up via WDT or Interrupt = uuuu. ADCHS, Applicable Devices = 2331. ADCHS, Applicable Devices = 2431. ADCHS, Applicable Devices = 4331. ADCHS, Applicable Devices = 4431. ADCHS, Power-on Reset, Brown-out Reset = 0000. ADCHS, Power-on",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset = 0000. ADCHS, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ADCHS, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ADCHS, Wake-up via WDT or Interrupt = uuuu. ADCHS, Wake-up via WDT or Interrupt = uuuu. CCPR1H, Applicable Devices = 2331. CCPR1H, Applicable Devices = 2431. CCPR1H, Applicable Devices = 4331. CCPR1H, Applicable Devices = 4431. CCPR1H, Power-on Reset, Brown-out Reset = xxxx. CCPR1H, Power-on Reset, Brown-out Reset = xxxx. CCPR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. CCPR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. CCPR1H, Wake-up via WDT or Interrupt = uuuu. CCPR1H, Wake-up via WDT or Interrupt =",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. CCPR1L, Applicable Devices = 2331. CCPR1L, Applicable Devices = 2431. CCPR1L, Applicable Devices = 4331. CCPR1L, Applicable Devices = 4431. CCPR1L, Power-on Reset, Brown-out Reset = xxxx. CCPR1L, Power-on Reset, Brown-out Reset = xxxx. CCPR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. CCPR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. CCPR1L, Wake-up via WDT or Interrupt = uuuu. CCPR1L, Wake-up via WDT or Interrupt = uuuu. CCP1CON, Applicable Devices = 2331. CCP1CON, Applicable Devices = 2431. CCP1CON, Applicable Devices = 4331. CCP1CON, Applicable Devices = 4431. CCP1CON, Power-on Reset, Brown-out Reset = --00. CCP1CON, Power-on Reset,",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = 0000. CCP1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00. CCP1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. CCP1CON, Wake-up via WDT or Interrupt = --uu. CCP1CON, Wake-up via WDT or Interrupt = uuuu. CCPR2H, Applicable Devices = 2331. CCPR2H, Applicable Devices = 2431. CCPR2H, Applicable Devices = 4331. CCPR2H, Applicable Devices = 4431. CCPR2H, Power-on Reset, Brown-out Reset = xxxx. CCPR2H, Power-on Reset, Brown-out Reset = xxxx. CCPR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. CCPR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. CCPR2H, Wake-up via WDT or Interrupt = uuuu. CCPR2H, Wake-up",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nvia WDT or Interrupt = uuuu. CCPR2L, Applicable Devices = 2331. CCPR2L, Applicable Devices = 2431. CCPR2L, Applicable Devices = 4331. CCPR2L, Applicable Devices = 4431. CCPR2L, Power-on Reset, Brown-out Reset = xxxx. CCPR2L, Power-on Reset, Brown-out Reset = xxxx. CCPR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. CCPR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. CCPR2L, Wake-up via WDT or Interrupt = uuuu. CCPR2L, Wake-up via WDT or Interrupt = uuuu. CCP2CON, Applicable Devices = 2331. CCP2CON, Applicable Devices = 2431. CCP2CON, Applicable Devices = 4331. CCP2CON, Applicable Devices = 4431. CCP2CON, Power-on Reset, Brown-out Reset = --00.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nCCP2CON, Power-on Reset, Brown-out Reset = 0000. CCP2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00. CCP2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. CCP2CON, Wake-up via WDT or Interrupt = --uu. CCP2CON, Wake-up via WDT or Interrupt = uuuu. ANSEL1, Applicable Devices = 2331. ANSEL1, Applicable Devices = 2431. ANSEL1, Applicable Devices = 4331. ANSEL1, Applicable Devices = 4431. ANSEL1, Power-on Reset, Brown-out Reset = ----. ANSEL1, Power-on Reset, Brown-out Reset = ---1. ANSEL1, MCLR Resets WDT Reset RESET Instruction Stack Resets = ----. ANSEL1, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---1. ANSEL1, Wake-up via WDT or Interrupt = ----.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nANSEL1, Wake-up via WDT or Interrupt = ---u. ANSEL0, Applicable Devices = 2331. ANSEL0, Applicable Devices = 2431. ANSEL0, Applicable Devices = 4331. ANSEL0, Applicable Devices = 4431. ANSEL0, Power-on Reset, Brown-out Reset = 1111. ANSEL0, Power-on Reset, Brown-out Reset = 1111. ANSEL0, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111. ANSEL0, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111. ANSEL0, Wake-up via WDT or Interrupt = uuuu. ANSEL0, Wake-up via WDT or Interrupt = uuuu. T5CON, Applicable Devices = 2331. T5CON, Applicable Devices = 2431. T5CON, Applicable Devices = 4331. T5CON, Applicable Devices = 4431. T5CON, Power-on Reset, Brown-out Reset = 0000. T5CON, Power-on Reset, Brown-out Reset = 0000.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nT5CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. T5CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. T5CON, Wake-up via WDT or Interrupt = uuuu. T5CON, Wake-up via WDT or Interrupt = uuuu. QEICON, Applicable Devices = 2331. QEICON, Applicable Devices = 2431. QEICON, Applicable Devices = 4331. QEICON, Applicable Devices = 4431. QEICON, Power-on Reset, Brown-out Reset = 0000. QEICON, Power-on Reset, Brown-out Reset = 0000. QEICON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. QEICON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. QEICON, Wake-up via WDT or Interrupt = uuuu. QEICON, Wake-up via WDT or Interrupt = uuuu. SPBRGH, Applicable Devices = 2331. SPBRGH, Applicable Devices",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 2431. SPBRGH, Applicable Devices = 4331. SPBRGH, Applicable Devices = 4431. SPBRGH, Power-on Reset, Brown-out Reset = 0000. SPBRGH, Power-on Reset, Brown-out Reset = 0000. SPBRGH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. SPBRGH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. SPBRGH, Wake-up via WDT or Interrupt = uuuu. SPBRGH, Wake-up via WDT or Interrupt = uuuu. SPBRG, Applicable Devices = 2331. SPBRG, Applicable Devices = 2431. SPBRG, Applicable Devices = 4331. SPBRG, Applicable Devices = 4431. SPBRG, Power-on Reset, Brown-out Reset = 0000. SPBRG, Power-on Reset, Brown-out Reset = 0000. SPBRG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. SPBRG, MCLR Resets WDT Reset RESET Instruction Stack",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets = 0000. SPBRG, Wake-up via WDT or Interrupt = uuuu. SPBRG, Wake-up via WDT or Interrupt = uuuu. RCREG, Applicable Devices = 2331. RCREG, Applicable Devices = 2431. RCREG, Applicable Devices = 4331. RCREG, Applicable Devices = 4431. RCREG, Power-on Reset, Brown-out Reset = 0000. RCREG, Power-on Reset, Brown-out Reset = 0000. RCREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. RCREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. RCREG, Wake-up via WDT or Interrupt = uuuu. RCREG, Wake-up via WDT or Interrupt = uuuu. TXREG, Applicable Devices = 2331. TXREG, Applicable Devices = 2431. TXREG, Applicable Devices = 4331. TXREG, Applicable Devices = 4431. TXREG, Power-on Reset,",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = 0000. TXREG, Power-on Reset, Brown-out Reset = 0000. TXREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. TXREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. TXREG, Wake-up via WDT or Interrupt = uuuu. TXREG, Wake-up via WDT or Interrupt = uuuu. TXSTA, Applicable Devices = 2331. TXSTA, Applicable Devices = 2431. TXSTA, Applicable Devices = 4331. TXSTA, Applicable Devices = 4431. TXSTA, Power-on Reset, Brown-out Reset = 0000. TXSTA, Power-on Reset, Brown-out Reset = -010. TXSTA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. TXSTA, MCLR Resets WDT Reset RESET Instruction Stack Resets = -010. TXSTA, Wake-up via WDT or Interrupt = uuuu. TXSTA, Wake-up via WDT or Interrupt =",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n-uuu. RCSTA, Applicable Devices = 2331. RCSTA, Applicable Devices = 2431. RCSTA, Applicable Devices = 4331. RCSTA, Applicable Devices = 4431. RCSTA, Power-on Reset, Brown-out Reset = 0000. RCSTA, Power-on Reset, Brown-out Reset = 000x. RCSTA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. RCSTA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 000x. RCSTA, Wake-up via WDT or Interrupt = uuuu. RCSTA, Wake-up via WDT or Interrupt = uuuu. BAUDCON, Applicable Devices = 2331. BAUDCON, Applicable Devices = 2431. BAUDCON, Applicable Devices = 4331. BAUDCON, Applicable Devices = 4431. BAUDCON, Power-on Reset, Brown-out Reset = -1-1. BAUDCON, Power-on Reset, Brown-out Reset = 0-00. BAUDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n-1-1. BAUDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0-00. BAUDCON, Wake-up via WDT or Interrupt = -u-u. BAUDCON, Wake-up via WDT or Interrupt = u-uu. EEADR, Applicable Devices = 2331. EEADR, Applicable Devices = 2431. EEADR, Applicable Devices = 4331. EEADR, Applicable Devices = 4431. EEADR, Power-on Reset, Brown-out Reset = 0000. EEADR, Power-on Reset, Brown-out Reset = 0000. EEADR, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. EEADR, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. EEADR, Wake-up via WDT or Interrupt = uuuu. EEADR, Wake-up via WDT or Interrupt = uuuu. EEDATA, Applicable Devices = 2331. EEDATA, Applicable Devices = 2431. EEDATA, Applicable Devices = 4331.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nEEDATA, Applicable Devices = 4431. EEDATA, Power-on Reset, Brown-out Reset = 0000. EEDATA, Power-on Reset, Brown-out Reset = 0000. EEDATA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. EEDATA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. EEDATA, Wake-up via WDT or Interrupt = uuuu. EEDATA, Wake-up via WDT or Interrupt = uuuu. EECON2, Applicable Devices = 2331. EECON2, Applicable Devices = 2431. EECON2, Applicable Devices = 4331. EECON2, Applicable Devices = 4431. EECON2, Power-on Reset, Brown-out Reset = 0000. EECON2, Power-on Reset, Brown-out Reset = 0000. EECON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. EECON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. EECON2, Wake-up via",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = 0000. EECON2, Wake-up via WDT or Interrupt = 0000. EECON1, Applicable Devices = 2331. EECON1, Applicable Devices = 2431. EECON1, Applicable Devices = 4331. EECON1, Applicable Devices = 4431. EECON1, Power-on Reset, Brown-out Reset = xx-0. EECON1, Power-on Reset, Brown-out Reset = x000. EECON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = uu-0. EECON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = u000. EECON1, Wake-up via WDT or Interrupt = uu-0. EECON1, Wake-up via WDT or Interrupt = u000. IPR3, Applicable Devices = 2331. IPR3, Applicable Devices = 2431. IPR3, Applicable Devices = 4331. IPR3, Applicable Devices = 4431. IPR3, Power-on Reset, Brown-out Reset = ---1. IPR3,",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = 1111. IPR3, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---1. IPR3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111. IPR3, Wake-up via WDT or Interrupt = ---u. IPR3, Wake-up via WDT or Interrupt = uuuu. PIE3, Applicable Devices = 2331. PIE3, Applicable Devices = 2431. PIE3, Applicable Devices = 4331. PIE3, Applicable Devices = 4431. PIE3, Power-on Reset, Brown-out Reset = ---0. PIE3, Power-on Reset, Brown-out Reset = 0000. PIE3, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0. PIE3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. PIE3, Wake-up via WDT or Interrupt = ---u. PIE3, Wake-up via WDT or Interrupt = uuuu. PIR3, Applicable Devices =",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n2331. PIR3, Applicable Devices = 2431. PIR3, Applicable Devices = 4331. PIR3, Applicable Devices = 4431. PIR3, Power-on Reset, Brown-out Reset = ---0. PIR3, Power-on Reset, Brown-out Reset = 0000. PIR3, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0. PIR3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. PIR3, Wake-up via WDT or Interrupt = ---u. PIR3, Wake-up via WDT or Interrupt = uuuu\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 5-2 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: Bit 3 of PORTE and LATE are enabled if MCLR functionality is disabled. When not enabled as the PORTE pin, they are disabled and read as ' 0 '. The 28-pin devices do not have only RE3 implemented.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nIPR2, Applicable Devices = 2331. IPR2, Applicable Devices = 2431. IPR2, Applicable Devices = 4331. IPR2, Applicable Devices = 4431. IPR2, Power-on Reset, Brown-out Reset = 1--1 -1-1. IPR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1--1 -1-1. IPR2, Wake-up via WDT or Interrupt = u--u -u-u. PIR2, Applicable Devices = 2331. PIR2, Applicable Devices = 2431. PIR2, Applicable Devices = 4331. PIR2, Applicable Devices = 4431. PIR2, Power-on Reset, Brown-out Reset = 0--0 -0-0. PIR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0--0 -0-0. PIR2, Wake-up via WDT or Interrupt = u--u -u-u. PIE2, Applicable Devices = 2331. PIE2, Applicable Devices = 2431.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIE2, Applicable Devices = 4331. PIE2, Applicable Devices = 4431. PIE2, Power-on Reset, Brown-out Reset = 0--0 -0-0. PIE2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0--0 -0-0. PIE2, Wake-up via WDT or Interrupt = u--u -u-u. IPR1, Applicable Devices = 2331. IPR1, Applicable Devices = 2431. IPR1, Applicable Devices = 4331. IPR1, Applicable Devices = 4431. IPR1, Power-on Reset, Brown-out Reset = -111 1111. IPR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -111 1111. IPR1, Wake-up via WDT or Interrupt = -uuu uuuu. PIR1, Applicable Devices = 2331. PIR1, Applicable Devices = 2431. PIR1, Applicable Devices = 4331. PIR1, Applicable Devices = 4431. PIR1, Power-on Reset, Brown-out Reset",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= -000 0000. PIR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. PIR1, Wake-up via WDT or Interrupt = -uuu uuuu (1). PIR1, Applicable Devices = 2331. PIR1, Applicable Devices = 2431. PIR1, Applicable Devices = 4331. PIR1, Applicable Devices = 4431. PIR1, Power-on Reset, Brown-out Reset = -000 0000. PIR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. PIR1, Wake-up via WDT or Interrupt = -uuu uuuu (1). PIE1, Applicable Devices = 2331. PIE1, Applicable Devices = 2431. PIE1, Applicable Devices = 4331. PIE1, Applicable Devices = 4431. PIE1, Power-on Reset, Brown-out Reset = 0000 0000. PIE1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PIE1, Wake-up via",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu uuuu. PIE1, Applicable Devices = 2331. PIE1, Applicable Devices = 2431. PIE1, Applicable Devices = 4331. PIE1, Applicable Devices = 4431. PIE1, Power-on Reset, Brown-out Reset = -000 0000. PIE1, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. PIE1, Wake-up via WDT or Interrupt = -uuu uuuu. OSCTUNE, Applicable Devices = 2331. OSCTUNE, Applicable Devices = 2431. OSCTUNE, Applicable Devices = 4331. OSCTUNE, Applicable Devices = 4431. OSCTUNE, Power-on Reset, Brown-out Reset = --00 0000. OSCTUNE, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. OSCTUNE, Wake-up via WDT or Interrupt = --uu uuuu. TRISE (6), Applicable Devices = 2331. TRISE (6), Applicable Devices = 2431. TRISE",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(6), Applicable Devices = 4331. TRISE (6), Applicable Devices = 4431. TRISE (6), Power-on Reset, Brown-out Reset = ---- -111. TRISE (6), MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- -111. TRISE (6), Wake-up via WDT or Interrupt = ---- -uuu. TRISD, Applicable Devices = 2331. TRISD, Applicable Devices = 2431. TRISD, Applicable Devices = 4331. TRISD, Applicable Devices = 4431. TRISD, Power-on Reset, Brown-out Reset = 1111 1111. TRISD, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISD, Wake-up via WDT or Interrupt = uuuu uuuu. TRISC, Applicable Devices = 2331. TRISC, Applicable Devices = 2431. TRISC, Applicable Devices = 4331. TRISC, Applicable Devices = 4431. TRISC, Power-on Reset, Brown-out Reset = 1111",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n1111. TRISC, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISC, Wake-up via WDT or Interrupt = uuuu uuuu. TRISB, Applicable Devices = 2331. TRISB, Applicable Devices = 2431. TRISB, Applicable Devices = 4331. TRISB, Applicable Devices = 4431. TRISB, Power-on Reset, Brown-out Reset = 1111 1111. TRISB, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISB, Wake-up via WDT or Interrupt = uuuu uuuu. TRISA (5), Applicable Devices = 2331. TRISA (5), Applicable Devices = 2431. TRISA (5), Applicable Devices = 4331. TRISA (5), Applicable Devices = 4431. TRISA (5), Power-on Reset, Brown-out Reset = 1111 1111 (5). TRISA (5), MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111 (5). TRISA",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(5), Wake-up via WDT or Interrupt = uuuu uuuu (5). PR5H, Applicable Devices = 2331. PR5H, Applicable Devices = 2431. PR5H, Applicable Devices = 4331. PR5H, Applicable Devices = 4431. PR5H, Power-on Reset, Brown-out Reset = 1111 1111. PR5H, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. PR5H, Wake-up via WDT or Interrupt = uuuu uuuu. PR5L, Applicable Devices = 2331. PR5L, Applicable Devices = 2431. PR5L, Applicable Devices = 4331. PR5L, Applicable Devices = 4431. PR5L, Power-on Reset, Brown-out Reset = 1111 1111. PR5L, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. PR5L, Wake-up via WDT or Interrupt = uuuu uuuu. LATE (6), Applicable Devices = 2331.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLATE (6), Applicable Devices = 2431. LATE (6), Applicable Devices = 4331. LATE (6), Applicable Devices = 4431. LATE (6), Power-on Reset, Brown-out Reset = ---- -xxx. LATE (6), MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- -uuu. LATE (6), Wake-up via WDT or Interrupt = ---- -uuu. LATD, Applicable Devices = 2331. LATD, Applicable Devices = 2431. LATD, Applicable Devices = 4331. LATD, Applicable Devices = 4431. LATD, Power-on Reset, Brown-out Reset = xxxx xxxx. LATD, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATD, Wake-up via WDT or Interrupt = uuuu uuuu. LATC, Applicable Devices = 2331. LATC, Applicable Devices = 2431. LATC, Applicable Devices = 4331.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLATC, Applicable Devices = 4431. LATC, Power-on Reset, Brown-out Reset = xxxx xxxx. LATC, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATC, Wake-up via WDT or Interrupt = uuuu uuuu. LATB, Applicable Devices = 2331. LATB, Applicable Devices = 2431. LATB, Applicable Devices = 4331. LATB, Applicable Devices = 4431. LATB, Power-on Reset, Brown-out Reset = xxxx xxxx. LATB, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATB, Wake-up via WDT or Interrupt = uuuu uuuu. LATA (5), Applicable Devices = 2331. LATA (5), Applicable Devices = 2431. LATA (5), Applicable Devices = 4331. LATA (5), Applicable Devices = 4431. LATA (5), Power-on Reset, Brown-out",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset = xxxx xxxx (5). LATA (5), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu (5). LATA (5), Wake-up via WDT or Interrupt = uuuu uuuu (5). TMR5H, Applicable Devices = 2331. TMR5H, Applicable Devices = 2431. TMR5H, Applicable Devices = 4331. TMR5H, Applicable Devices = 4431. TMR5H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR5H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR5H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR5L, Applicable Devices = 2331. TMR5L, Applicable Devices = 2431. TMR5L, Applicable Devices = 4331. TMR5L, Applicable Devices = 4431.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTMR5L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR5L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR5L, Wake-up via WDT or Interrupt = uuuu uuuu. PORTE (6), Applicable Devices = 2331. PORTE (6), Applicable Devices = 2431. PORTE (6), Applicable Devices = 4331. PORTE (6), Applicable Devices = 4431. PORTE (6), Power-on Reset, Brown-out Reset = ---- xxxx. PORTE (6), MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- xxxx. PORTE (6), Wake-up via WDT or Interrupt = ---- uuuu. PORTD, Applicable Devices = 2331. PORTD, Applicable Devices = 2431. PORTD, Applicable Devices = 4331. PORTD, Applicable Devices = 4431. PORTD, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPORTD, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PORTD, Wake-up via WDT or Interrupt = uuuu uuuu. PORTC, Applicable Devices = 2331. PORTC, Applicable Devices = 2431. PORTC, Applicable Devices = 4331. PORTC, Applicable Devices = 4431. PORTC, Power-on Reset, Brown-out Reset = xxxx xxxx. PORTC, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PORTC, Wake-up via WDT or Interrupt = uuuu uuuu. PORTB, Applicable Devices = 2331. PORTB, Applicable Devices = 2431. PORTB, Applicable Devices = 4331. PORTB, Applicable Devices = 4431. PORTB, Power-on Reset, Brown-out Reset = xxxx xxxx. PORTB, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PORTB, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. PORTA (5), Applicable Devices = 2331. PORTA (5), Applicable Devices = 2431. PORTA (5), Applicable Devices = 4331. PORTA (5), Applicable Devices = 4431. PORTA (5), Power-on Reset, Brown-out Reset = xx0x 0000 (5). PORTA (5), MCLR Resets WDT Reset RESET Instruction Stack Resets = uu0u 0000 (5). PORTA (5), Wake-up via WDT or Interrupt = uuuu uuuu (5)\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition.\nShaded cells indicate conditions do not apply for the designated device.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 5-2 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: Bit 3 of PORTE and LATE are enabled if MCLR functionality is disabled. When not enabled as the PORTE pin, they are disabled and read as ' 0 '. The 28-pin devices do not have only RE3 implemented.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPTCON0, Applicable Devices = 2331. PTCON0, Applicable Devices = 2431. PTCON0, Applicable Devices = 4331. PTCON0, Applicable Devices = 4431. PTCON0, Power-on Reset, Brown-out Reset = 0000 0000. PTCON0, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PTCON0, Wake-up via WDT or Interrupt = uuuu uuuu. PTCON1, Applicable Devices = 2331. PTCON1, Applicable Devices = 2431. PTCON1, Applicable Devices = 4331. PTCON1, Applicable Devices = 4431. PTCON1, Power-on Reset, Brown-out Reset = 00-- ----. PTCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 00-- ----. PTCON1, Wake-up via WDT or Interrupt = uu-- ----. PTMRL, Applicable Devices = 2331. PTMRL, Applicable Devices = 2431. PTMRL, Applicable Devices",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= 4331. PTMRL, Applicable Devices = 4431. PTMRL, Power-on Reset, Brown-out Reset = 0000 0000. PTMRL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PTMRL, Wake-up via WDT or Interrupt = uuuu uuuu. PTMRH, Applicable Devices = 2331. PTMRH, Applicable Devices = 2431. PTMRH, Applicable Devices = 4331. PTMRH, Applicable Devices = 4431. PTMRH, Power-on Reset, Brown-out Reset = ---- 0000. PTMRH, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. PTMRH, Wake-up via WDT or Interrupt = ---- uuuu. PTPERL, Applicable Devices = 2331. PTPERL, Applicable Devices = 2431. PTPERL, Applicable Devices = 4331. PTPERL, Applicable Devices = 4431. PTPERL, Power-on Reset, Brown-out Reset = 1111",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n1111. PTPERL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. PTPERL, Wake-up via WDT or Interrupt = uuuu uuuu. PTPERH, Applicable Devices = 2331. PTPERH, Applicable Devices = 2431. PTPERH, Applicable Devices = 4331. PTPERH, Applicable Devices = 4431. PTPERH, Power-on Reset, Brown-out Reset = ---- 1111. PTPERH, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 1111. PTPERH, Wake-up via WDT or Interrupt = ---- uuuu. PDC0L, Applicable Devices = 2331. PDC0L, Applicable Devices = 2431. PDC0L, Applicable Devices = 4331. PDC0L, Applicable Devices = 4431. PDC0L, Power-on Reset, Brown-out Reset = 0000 0000. PDC0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPDC0L, Wake-up via WDT or Interrupt = uuuu uuuu. PDC0H, Applicable Devices = 2331. PDC0H, Applicable Devices = 2431. PDC0H, Applicable Devices = 4331. PDC0H, Applicable Devices = 4431. PDC0H, Power-on Reset, Brown-out Reset = --00 0000. PDC0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. PDC0H, Wake-up via WDT or Interrupt = --uu uuuu. PDC1L, Applicable Devices = 2331. PDC1L, Applicable Devices = 2431. PDC1L, Applicable Devices = 4331. PDC1L, Applicable Devices = 4431. PDC1L, Power-on Reset, Brown-out Reset = 0000 0000. PDC1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PDC1L, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. PDC1H, Applicable Devices = 2331. PDC1H, Applicable Devices = 2431. PDC1H, Applicable Devices = 4331. PDC1H, Applicable Devices = 4431. PDC1H, Power-on Reset, Brown-out Reset = --00 0000. PDC1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. PDC1H, Wake-up via WDT or Interrupt = --uu uuuu. PDC2L, Applicable Devices = 2331. PDC2L, Applicable Devices = 2431. PDC2L, Applicable Devices = 4331. PDC2L, Applicable Devices = 4431. PDC2L, Power-on Reset, Brown-out Reset = 0000 0000. PDC2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PDC2L, Wake-up via WDT or Interrupt = uuuu uuuu. PDC2H, Applicable Devices = 2331.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPDC2H, Applicable Devices = 2431. PDC2H, Applicable Devices = 4331. PDC2H, Applicable Devices = 4431. PDC2H, Power-on Reset, Brown-out Reset = --00 0000. PDC2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. PDC2H, Wake-up via WDT or Interrupt = --uu uuuu. PDC3L, Applicable Devices = 2331. PDC3L, Applicable Devices = 2431. PDC3L, Applicable Devices = 4331. PDC3L, Applicable Devices = 4431. PDC3L, Power-on Reset, Brown-out Reset = 0000 0000. PDC3L, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PDC3L, Wake-up via WDT or Interrupt = uuuu uuuu. PDC3H, Applicable Devices = 2331. PDC3H, Applicable Devices = 2431. PDC3H, Applicable Devices =",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n4331. PDC3H, Applicable Devices = 4431. PDC3H, Power-on Reset, Brown-out Reset = --00 0000. PDC3H, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. PDC3H, Wake-up via WDT or Interrupt = --uu uuuu. SEVTCMPL, Applicable Devices = 2331. SEVTCMPL, Applicable Devices = 2431. SEVTCMPL, Applicable Devices = 4331. SEVTCMPL, Applicable Devices = 4431. SEVTCMPL, Power-on Reset, Brown-out Reset = 0000 0000. SEVTCMPL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SEVTCMPL, Wake-up via WDT or Interrupt = uuuu uuuu. SEVTCMPH, Applicable Devices = 2331. SEVTCMPH, Applicable Devices = 2431. SEVTCMPH, Applicable Devices = 4331. SEVTCMPH, Applicable",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = 4431. SEVTCMPH, Power-on Reset, Brown-out Reset = ---- 0000. SEVTCMPH, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. SEVTCMPH, Wake-up via WDT or Interrupt = ---- uuuu. PWMCON0, Applicable Devices = 2331. PWMCON0, Applicable Devices = 2431. PWMCON0, Applicable Devices = 4331. PWMCON0, Applicable Devices = 4431. PWMCON0, Power-on Reset, Brown-out Reset = -111 0000. PWMCON0, MCLR Resets WDT Reset RESET Instruction Stack Resets = -111 0000. PWMCON0, Wake-up via WDT or Interrupt = -uuu uuuu. PWMCON1, Applicable Devices = 2331. PWMCON1, Applicable Devices = 2431. PWMCON1, Applicable Devices = 4331. PWMCON1, Applicable Devices =",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n4431. PWMCON1, Power-on Reset, Brown-out Reset = 0000 0-00. PWMCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0-00. PWMCON1, Wake-up via WDT or Interrupt = uuuu u-uu. DTCON, Applicable Devices = 2331. DTCON, Applicable Devices = 2431. DTCON, Applicable Devices = 4331. DTCON, Applicable Devices = 4431. DTCON, Power-on Reset, Brown-out Reset = 0000 0000. DTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. DTCON, Wake-up via WDT or Interrupt = uuuu uuuu. FLTCONFIG, Applicable Devices = 2331. FLTCONFIG, Applicable Devices = 2431. FLTCONFIG, Applicable Devices = 4331. FLTCONFIG, Applicable Devices = 4431. FLTCONFIG, Power-on Reset, Brown-out Reset = 0000 0000.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFLTCONFIG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. FLTCONFIG, Wake-up via WDT or Interrupt = uuuu uuuu. OVDCOND, Applicable Devices = 2331. OVDCOND, Applicable Devices = 2431. OVDCOND, Applicable Devices = 4331. OVDCOND, Applicable Devices = 4431. OVDCOND, Power-on Reset, Brown-out Reset = 1111 1111. OVDCOND, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. OVDCOND, Wake-up via WDT or Interrupt = uuuu uuuu. OVDCONS, Applicable Devices = 2331. OVDCONS, Applicable Devices = 2431. OVDCONS, Applicable Devices = 4331. OVDCONS, Applicable Devices = 4431. OVDCONS, Power-on Reset, Brown-out Reset = 0000 0000. OVDCONS, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000. OVDCONS, Wake-up via WDT or Interrupt = uuuu uuuu. CAP1BUFH/ VELRH, Applicable Devices = 2331. CAP1BUFH/ VELRH, Applicable Devices = 2431. CAP1BUFH/ VELRH, Applicable Devices = 4331. CAP1BUFH/ VELRH, Applicable Devices = 4431. CAP1BUFH/ VELRH, Power-on Reset, Brown-out Reset = xxxx xxxx. CAP1BUFH/ VELRH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CAP1BUFH/ VELRH, Wake-up via WDT or Interrupt = uuuu uuuu. CAP1BUFL/ VELRL, Applicable Devices = 2331. CAP1BUFL/ VELRL, Applicable Devices = 2431. CAP1BUFL/ VELRL, Applicable Devices = 4331. CAP1BUFL/ VELRL, Applicable Devices = 4431. CAP1BUFL/",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nVELRL, Power-on Reset, Brown-out Reset = xxxx xxxx. CAP1BUFL/ VELRL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CAP1BUFL/ VELRL, Wake-up via WDT or Interrupt = uuuu uuuu. CAP2BUFH/ POSCNTH, Applicable Devices = 2331. CAP2BUFH/ POSCNTH, Applicable Devices = 2431. CAP2BUFH/ POSCNTH, Applicable Devices = 4331. CAP2BUFH/ POSCNTH, Applicable Devices = 4431. CAP2BUFH/ POSCNTH, Power-on Reset, Brown-out Reset = xxxx. CAP2BUFH/ POSCNTH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CAP2BUFH/ POSCNTH, Wake-up via WDT or Interrupt = uuuu uuuu. CAP2BUFL/, Applicable Devices =",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n2331. CAP2BUFL/, Applicable Devices = 2431. CAP2BUFL/, Applicable Devices = . CAP2BUFL/, Applicable Devices = . CAP2BUFL/, Power-on Reset, Brown-out Reset = xxxx. CAP2BUFL/, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CAP2BUFL/, Wake-up via WDT or Interrupt = . POSCNTL, Applicable Devices = . POSCNTL, Applicable Devices = . POSCNTL, Applicable Devices = 4331. POSCNTL, Applicable Devices = 4431. POSCNTL, Power-on Reset, Brown-out Reset = xxxx xxxx. POSCNTL, MCLR Resets WDT Reset RESET Instruction Stack Resets = . POSCNTL, Wake-up via WDT or Interrupt = uuuu uuuu. CAP3BUFH/ MAXCNTH, Applicable Devices = 2331. CAP3BUFH/ MAXCNTH, Applicable Devices = 2431. CAP3BUFH/",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMAXCNTH, Applicable Devices = 4331. CAP3BUFH/ MAXCNTH, Applicable Devices = 4431. CAP3BUFH/ MAXCNTH, Power-on Reset, Brown-out Reset = xxxx xxxx. CAP3BUFH/ MAXCNTH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CAP3BUFH/ MAXCNTH, Wake-up via WDT or Interrupt = uuuu uuuu\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 5-2 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: Bit 3 of PORTE and LATE are enabled if MCLR functionality is disabled. When not enabled as the PORTE pin, they are disabled and read as ' 0 '. The 28-pin devices do not have only RE3 implemented.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nCAP3BUFL/ MAXCNTL, Applicable Devices = 2331. CAP3BUFL/ MAXCNTL, Applicable Devices = 2431. CAP3BUFL/ MAXCNTL, Applicable Devices = 4331. CAP3BUFL/ MAXCNTL, Applicable Devices = 4431. CAP3BUFL/ MAXCNTL, Power-on Reset, Brown-out Reset = xxxx. CAP3BUFL/ MAXCNTL, Power-on Reset, Brown-out Reset = xxxx. CAP3BUFL/ MAXCNTL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. CAP3BUFL/ MAXCNTL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. CAP3BUFL/ MAXCNTL, Wake-up via WDT or Interrupt = uuuu. CAP3BUFL/ MAXCNTL, Wake-up via WDT or Interrupt = uuuu. CAP1CON, Applicable Devices = 2331. CAP1CON, Applicable Devices = 2431. CAP1CON, Applicable Devices =",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n4331. CAP1CON, Applicable Devices = 4431. CAP1CON, Power-on Reset, Brown-out Reset = -0--. CAP1CON, Power-on Reset, Brown-out Reset = 0000. CAP1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -0--. CAP1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. CAP1CON, Wake-up via WDT or Interrupt = -u--. CAP1CON, Wake-up via WDT or Interrupt = uuuu. CAP2CON, Applicable Devices = 2331. CAP2CON, Applicable Devices = 2431. CAP2CON, Applicable Devices = 4331. CAP2CON, Applicable Devices = 4431. CAP2CON, Power-on Reset, Brown-out Reset = -0--. CAP2CON, Power-on Reset, Brown-out Reset = 0000. CAP2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -0--. CAP2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000. CAP2CON, Wake-up via WDT or Interrupt = -u--. CAP2CON, Wake-up via WDT or Interrupt = uuuu. CAP3CON, Applicable Devices = 2331. CAP3CON, Applicable Devices = 2431. CAP3CON, Applicable Devices = 4331. CAP3CON, Applicable Devices = 4431. CAP3CON, Power-on Reset, Brown-out Reset = -0--. CAP3CON, Power-on Reset, Brown-out Reset = 0000. CAP3CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -0--. CAP3CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. CAP3CON, Wake-up via WDT or Interrupt = -u--. CAP3CON, Wake-up via WDT or Interrupt = uuuu. DFLTCON, Applicable Devices = 2331. DFLTCON, Applicable Devices = 2431. DFLTCON, Applicable Devices = 4331. DFLTCON, Applicable Devices = 4431. DFLTCON,",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = -000. DFLTCON, Power-on Reset, Brown-out Reset = 0000. DFLTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000. DFLTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. DFLTCON, Wake-up via WDT or Interrupt = -uuu. DFLTCON, Wake-up via WDT or Interrupt = uuuu\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 5-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 5-2 for Reset value for specific condition.\n5: Bits 6 and 7 of PORTA, LATA and TRISA are enabled depending on the oscillator mode selected. When not enabled as PORTA pins, they are disabled and read ' 0 '.\n6: Bit 3 of PORTE and LATE are enabled if MCLR functionality is disabled. When not enabled as the PORTE pin, they are disabled and read as ' 0 '. The 28-pin devices do not have only RE3 implemented.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "6.1 Program Memory Organization\nThere  are  three  memory  types  in  enhanced  MCU devices. These memory types are:\n\u00b7 Program Memory\n\u00b7 Data RAM\n\u00b7 Data EEPROM\nAs Harvard architecture devices, the data and program memories  use  separate  buses,  enabling  concurrent access of the two memory spaces. The data EEPROM, for practical purposes, can be regarded as a peripheral device, since it is addressed and accessed through a set of control registers.\nAdditional detailed information on the operation of the Flash  program  memory  is  provided  in Section 8.0 'Flash Program Memory' . Data EEPROM is discussed separately in Section 7.0 'Data EEPROM Memory' .",
    "PROGRAM MEMORY MAP AND STACK FOR PIC18F2331/4331\nPIC18  microcontrollers  implement  a  21-bit  program counter that can address a 2-Mbyte program memory space. Accessing a location between the upper boundary  of  the  physically  implemented  memory  and  the 2-Mbyte address will return all ' 0 's (a NOP instruction).\nThe PIC18F2331/4331 devices each have 8 Kbytes of Flash memory and can store up to 4,096 single-word instructions.\nThe PIC18F2431/4431 devices each have 16 Kbytes of Flash memory and can store up to 8,192 single-word instructions.\nPIC18 devices have two interrupt vectors. The Reset vector address is at 000000h and the interrupt vector addresses are at 000008h and 000018h.\nThe program memory maps for PIC18F2331/4331 and PIC18F2431/4431  devices  are  shown  in  Figure 6-1 and Figure 6-2, respectively.",
    "6.1.1 PROGRAM COUNTER\nThe Program Counter (PC) specifies the address of the instruction to fetch for execution. The PC is 21 bits wide and  contained  in  three  8-bit  registers.  The  low  byte, known as the PCL register, is both readable and writable. The  high  byte (PCH  register) contains the PC<15:8> bits and is not directly readable or writable.\nThe stack space is not part  of  either  program  or  data space. The Stack Pointer is readable and writable, and the  address  on  the  top  of  the  stack  is  readable  and writable through the Top-of-Stack (TOS) Special Function Registers. Data can also be pushed to, or popped from, the  stack  using  the  Top-of-Stack  SFRs.  Status  bits indicate if the stack is full, has overflowed or underflowed.\nUpdates to the PCH register are performed through the PCLATH register. The upper byte is the PCU register and contains the bits, PC<20:16>. This register is also not directly readable or writable. Updates to the PCU register are performed through the PCLATU register.",
    "6.1.1 PROGRAM COUNTER\nThe contents of PCLATH and PCLATU are transferred to the program counter by any operation that writes to the PCL. Similarly, the upper two bytes of the program counter are transferred to PCLATH and PCLATU by an operation that reads PCL. This is useful for computed offsets  to  the  PC  (see Section 6.1.4.1  'Computed GOTO' ).\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the Least Significant bit of the PCL is fixed to a value of ' 0 '. The PC increments by two to address sequential instructions in the program memory.\nThe CALL , RCALL , GOTO and program branch instructions write to the program counter directly. For these instructions, the contents of PCLATH and PCLATU are not transferred to the program counter.",
    "6.1.2 RETURN ADDRESS STACK\nThe return address stack allows any combination of up to  31  program  calls  and  interrupts  to  occur.  The  PC (Program Counter) is pushed onto the stack when a CALL or RCALL instruction is executed, or an interrupt is Acknowledged. The PC value is pulled off the stack on a RETURN, RETLW or a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN or CALL instructions.\nThe stack operates as a 31-word by 21-bit RAM and a 5-bit Stack Pointer, with the Stack Pointer initialized to 00000b after all Resets. There is no RAM associated with Stack Pointer, 00000b. This is only a Reset value. During a CALL type instruction, causing a push onto the stack,  the  Stack  Pointer  is  first  incremented  and  the RAM location pointed to by the Stack Pointer is written with  the  contents  of  the  PC  (already  pointing  to  the instruction following the CALL ). During a RETURN type instruction, causing a pop from the stack, the contents of  the  RAM  location  pointed  to  by  the  STKPTR  are transferred  to  the  PC  and  then  the  Stack  Pointer  is decremented.",
    "6.1.2.1 Top-of-Stack Access\nThe top of the stack is  readable  and writable. Three register locations, TOSU, TOSH and TOSL, hold the contents  of  the stack  location pointed  to by  the STKPTR  register  (Figure 6-3).  This  allows  users  to implement a software stack if necessary. After a CALL , RCALL or interrupt, the software can read the pushed value by reading the TOSU, TOSH and TOSL registers. These values can be placed on a user-defined software stack.  At  return  time,  the  software  can  replace  the TOSU, TOSH and TOSL and do a return.\nThe user must disable the global interrupt enable bits while accessing the stack to prevent inadvertent stack corruption.",
    "6.1.2.2 Return Stack Pointer (STKPTR)\nThe STKPTR register (Register 6-1) contains the Stack Pointer value, the STKFUL (Stack Full) status bit and the STKUNF (Stack Underflow) status bits. The value of  the  Stack Pointer can be 0 through 31. The Stack Pointer increments before values are pushed onto the stack and decrements after values are popped off the stack. At Reset, the Stack Pointer value will be zero. The user may read and write the Stack Pointer value. This  feature  can  be  used  by  a  Real-Time  Operating System (RTOS) for return stack maintenance.\nAfter the PC is pushed onto the stack 31 times (without popping any values off the stack), the STKFUL bit is set.  The  STKFUL  bit  is  cleared  by  software  or  by  a POR.",
    "6.1.2.2 Return Stack Pointer (STKPTR)\nThe action that takes place when the stack becomes full depends on the state of the STVREN (Stack Overflow Reset Enable) Configuration bit. (Refer to Section 23.1 'Configuration Bits' for a description of the device  Configuration  bits.) If STVREN  is  set (default),  the  31st push  will  push the (PC  +  2)  value onto  the  stack,  set  the  STKFUL  bit  and  reset  the device. The STKFUL bit will remain set and the Stack Pointer will be set to zero.\nIf STVREN is cleared, the STKFUL bit will be set on the 31st push and the Stack Pointer will increment to 31. Any additional pushes will not overwrite the 31st push and STKPTR will remain at 31.",
    "PIC18F2331/2431/4331/4431\nWhen  the  stack  has  been  popped  enough  times  to unload the stack, the next pop will return a value of zero to  the  PC  and  set  the  STKUNF  bit,  while  the  Stack Pointer remains at zero. The STKUNF bit will remain set until cleared by software or a POR occurs.\nNote:\nReturning a value of zero to the PC on an underflow has the effect of vectoring the program  to  the  Reset  vector,  where  the stack conditions can be verified and appropriate actions can be taken. This is not the same as a Reset as the contents of the SFRs are not affected.",
    "REGISTER 6-1: STKPTR: STACK POINTER REGISTER\nSTKFUL (1), R/C-0 = STKUNF (1). STKFUL (1), U-0 = -. STKFUL (1), R/W-0 = SP4. STKFUL (1), R/W-0 = SP3. STKFUL (1), R/W-0 = SP2. STKFUL (1), R/W-0 = SP1. STKFUL (1), R/W-0 = SP0. bit 7 bit 0, R/C-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 6-1: STKPTR: STACK POINTER REGISTER\nLegend:, 1 = C = Clearable bit. Legend:, 2 = . Legend:, 3 = . R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nSTKFUL: Stack Full Flag bit (1)\n1 = Stack became full or overflowed\n0 = Stack has not become full or overflowed\nbit 6\nSTKUNF:\nStack Underflow Flag bit (1)\n1 = Stack underflow occurred\n0 = Stack underflow did not occur\nbit 5\nUnimplemented: Read as ' 0 '\nbit 4-0\nSP<4:0>: Stack Pointer Location bits\nNote 1: Bit 7 and bit 6 are cleared by user software or by a POR.",
    "6.1.2.3 PUSH and POP Instructions\nSince the Top-of-Stack (TOS) is readable and writable, the ability to push values onto the stack and pull values off the stack without disturbing normal program execution is a desirable option. To push the current PC value onto  the  stack,  a PUSH instruction  can  be  executed. This  will  increment  the  Stack  Pointer  and  load  the current  PC  value  onto  the  stack.  TOSU,  TOSH  and TOSL can then be modified to place data or a return address on the stack.\nThe PUSH instruction places the current PC value onto the stack. This increments the Stack Pointer and loads the current PC value onto the stack. The POP instruction  discards  the  current  TOS  by  decrementing  the Stack  Pointer.  The  previous  value  pushed  onto  the stack then becomes the TOS value.",
    "6.1.2.4 Stack Full/Underflow Resets\nThese Resets are enabled by programming the STVREN bit in Configuration  Register  4L.  When  the STVREN bit is cleared, a full or underflow condition will set  the  appropriate  STKFUL  or  STKUNF  bit,  but  not cause a device Reset. When the STVREN bit is set, a full or  underflow  condition  will  set  the  appropriate STKFUL  or  STKUNF  bit  and  then  cause  a  device Reset. The STKFUL or STKUNF bits are cleared by the user software or a Power-on Reset.",
    "6.1.3 FAST REGISTER STACK\nA  Fast  Register  Stack  is  provided  for  the  STATUS, WREG and BSR registers, to provide a 'fast  return' option for interrupts. The stack for each register is only one level deep and is neither readable nor writable. It is loaded  with  the  current  value  of  the  corresponding register when the processor vectors for an interrupt. All interrupt sources  will push  values  into the stack registers.\nThe values in the registers are then loaded back into their associated registers if the RETFIE FAST , instruction is used to return from the interrupt. If both low and high-priority interrupts are enabled, the stack registers cannot be used reliably to return from low-priority interrupts. If a high-priority interrupt occurs while servicing a low-priority interrupt, the stack register values stored by the  low-priority  interrupt  will  be  overwritten.  In  these cases, users must save the key registers in software during a low-priority interrupt.",
    "6.1.3 FAST REGISTER STACK\nIf interrupt priority is not used, all interrupts may use the Fast  Register  Stack  for  returns  from  interrupt.  If  no interrupts  are  used,  the  Fast  Register  Stack  can  be used to restore the STATUS, WREG and BSR registers at the end of a subroutine call. To use the Fast Register Stack  for  a  subroutine  call,  a CALL label , FAST instruction  must  be  executed  to  save  the  STATUS, WREG and BSR registers to the Fast Register Stack. A RETURN , FAST instruction is then executed to restore these registers from the Fast Register Stack.\nExample 6-1 shows a source code example that uses the Fast  Register  Stack during  a  subroutine call  and return.",
    "EXAMPLE 6-1: FAST REGISTER STACK CODE EXAMPLE\nCALL SUB1, FAST, 1 = ;STATUS, WREG, BSR ;SAVED IN FAST REGISTER ;STACK. \uf0b7, 1 = . SUB1 \uf0b7 RETURN FAST, 1 = ;RESTORE VALUES SAVED ;IN FAST REGISTER STACK",
    "6.1.4 LOOK-UP TABLES IN PROGRAM MEMORY\nThere may be programming situations that require the creation of data structures, or look-up tables, in program memory. For PIC18 devices, look-up tables can be implemented two ways:\n\u00b7 Computed GOTO\n\u00b7 Table Reads",
    "6.1.4.1 Computed GOTO\nA computed GOTO is accomplished by adding an offset to  the  program  counter.  An  example  is  shown  in Example 6-2.\nA look-up table can be formed  with an ADDWF  PCL instruction and a group of RETLW nn instructions. The W register is loaded with an offset into the table before executing a call to that table. The first instruction of the called routine is the ADDWF PCL instruction. The next instruction  executed  will  be  one  of  the RETLW nn instructions  that  returns  the  value  ' nn '  to  the  calling function.\nThe offset  value  (in  WREG)  specifies  the  number  of bytes  that  the  program  counter  should  advance  and should be multiples of 2 (LSb = 0 ).\nIn  this  method,  only  one  data  byte  can  be  stored  in each  instruction  location  and  room  on  the  return address stack is required.",
    "EXAMPLE 6-2: COMPUTED GOTO USING AN OFFSET VALUE\n, 1 = MOVFW CALL. , 2 = OFFSET TABLE. ORG, 1 = 0xnn00. ORG, 2 = . TABLE, 1 = ADDWF. TABLE, 2 = PCL. TABLE, 1 = RETLW. TABLE, 2 = 0xnn. TABLE, 1 = RETLW. TABLE, 2 = 0xnn. TABLE, 1 = RETLW. TABLE, 2 = 0xnn. , 1 = .. , 2 = . , 1 = .. , 2 = . , 1 = .. , 2 = ",
    "6.1.4.2 Table Reads and Table Writes\nA  better  method  of  storing  data  in  program  memory allows two bytes of data to be stored in each instruction location. Look-up table data may be stored, two bytes per program word, by using table reads and writes.",
    "6.2 Clocking Scheme/Instruction Cycle\nThe Table Pointer register (TBLPTR) specifies the byte address and the Table Latch register (TABLAT) contains the data that is read from or written to program memory.  Data  is  transferred to or from program memory, one byte at a time.\nTable  read  and  table  write  operations  are  discussed further in Section 8.1 'Table Reads  and  Table Writes' .\nThe clock  input  (from  OSC1)  is  internally  divided  by four to generate four non-overlapping quadrature clocks,  namely  Q1,  Q2,  Q3  and  Q4.  Internally,  the Program Counter (PC) is incremented every Q1, the instruction  is  fetched  from  the  program  memory  and latched  into  the  Instruction  Register  (IR)  in  Q4.  The instruction is decoded and executed during the following  Q1  through  Q4.  The  clocks  and  instruction execution flow are shown in Figure 6-4.",
    "6.3 Instruction Flow/Pipelining\nAn 'Instruction  Cycle'  consists  of  four  Q  cycles  (Q1, Q2, Q3 and Q4). The instruction fetch and execute are pipelined such that  fetch takes  one  instruction cycle, while  decode  and  execute  take  another  instruction cycle. However, due to the pipelining, each instruction effectively  executes  in  one  cycle.  If  an  instruction causes the  program  counter to  change (e.g., GOTO ), then two cycles are required to complete the instruction (Example 6-3).\nA fetch cycle begins with the Program Counter (PC) incrementing in Q1.\nIn the execution cycle, the fetched instruction is latched into  the  'Instruction  Register'  (IR)  in  cycle,  Q1.  This instruction  is  then  decoded  and  executed  during  the Q2, Q3 and Q4 cycles. Data memory is read during Q2 (operand  read)  and  written  during  Q4  (destination write).",
    "EXAMPLE 6-3: INSTRUCTION PIPELINE FLOW\nAll instructions are single cycle, except for any program branches. These take two cycles since the fetch instruction is 'flushed' from the pipeline, while the new instruction is being fetched and then executed.",
    "6.4.1 TWO-WORD INSTRUCTIONS\nThe program memory is addressed in bytes. Instructions are stored as two bytes or four bytes in program memory. The  Least  Significant  Byte  of  an  instruction  word  is always  stored  in  a  program  memory  location  with  an even address (LSB = 0 ). Figure 6-5 shows an example of how instruction words are stored in the program memory. To  maintain  alignment  with  instruction  boundaries,  the PC increments in steps of 2 and the LSB will always read ' 0 '.\nThe standard PIC18 instruction set has four two-word instructions: CALL , MOVFF , GOTO and LSFR . In  all cases, the second word of the instructions always has ' 1111 ' as its four Most Significant bits; the other 12 bits are literal data, usually a data memory address.",
    "6.4.1 TWO-WORD INSTRUCTIONS\nThe CALL and GOTO instructions  have  the  absolute program memory address embedded into the instruction. Since instructions are always stored on word boundaries, the data contained in the instruction is a word address. The word address is written to PC<20:1>,  which accesses the desired byte address in program memory. Instruction  2  in  Figure 6-5  shows  how  the  instruction, ' GOTO  000006h ',  is  encoded in the program memory. Program  branch  instructions,  which  encode  a  relative address offset, operate in the same manner. The offset value stored in a branch instruction represents the number of single-word instructions that the PC will be offset by. Section 24.0 'Instruction Set Summary' provides further details of the instruction set.",
    "6.4.1 TWO-WORD INSTRUCTIONS\nThe use of ' 1111 '  in  the  four  MSbs  of  an  instruction specifies a special form of NOP . If the instruction is executed in  proper  sequence,  immediately after  the  first word,  the  data  in  the  second  word  is  accessed  and used by the instruction sequence. If the first  word  is skipped  for  some  reason  and  the  second  word  is executed by itself, a NOP is executed instead. This is necessary for cases when the two-word instruction is preceded by a conditional instruction that changes the PC. Example 6-4 shows how this works.",
    "Note:\nFor  information  on  two-word  instructions in the extended instruction set, see Section 24.2 'Instruction Set'.",
    "FIGURE 6-5: INSTRUCTIONS IN PROGRAM MEMORY\nProgram Memory\nByte Locations\n\uf0ae\uf020\nInstruction 1:\nInstruction 2:\nMOVLW\n055h\nGOTO\n000006h\nInstruction 3:\n, LSB = 0 = . , Word Address \uf0af = 000000h. , LSB = 0 = . , Word Address \uf0af = 000002h. , LSB = 0 = . , Word Address \uf0af = 000004h. , LSB = 0 = . , Word Address \uf0af = 000006h. 0Fh, LSB = 0 = 55h. 0Fh, Word Address \uf0af = 000008h. EFh, LSB = 0 = 03h. EFh, Word Address \uf0af = 00000Ah. F0h, LSB = 0 = 00h. F0h, Word Address \uf0af = 00000Ch. C1h, LSB = 0 = 23h. C1h, Word Address \uf0af = 00000Eh. F4h, LSB = 0 = 56h. F4h, Word Address \uf0af = 000010h. , LSB = 0 = . , Word Address \uf0af = 000012h. , LSB = 0 = . , Word Address \uf0af = 000014h\nMOVFF\n123h, 456h",
    "FIGURE 6-5: INSTRUCTIONS IN PROGRAM MEMORY\nEXAMPLE 6-4:\nTWO-WORD INSTRUCTIONS",
    "FIGURE 6-5: INSTRUCTIONS IN PROGRAM MEMORY\n0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:.Source Code = ; is RAM location 0?. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE 1:.Source Code = ; No, skip this word. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = .",
    "FIGURE 6-5: INSTRUCTIONS IN PROGRAM MEMORY\n1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; Execute this word as a NOP. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:.Source Code = ; continue code. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Object Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. CASE 2:, CASE 1:.Source Code = CASE 2:. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Object",
    "FIGURE 6-5: INSTRUCTIONS IN PROGRAM MEMORY\nCode = Object Code. Object Code, CASE 1:.Object Code = Object Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. Object Code, CASE 1:.Source Code = Source Code. 0110, CASE 1:.Object Code = 0110. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Object Code = 0000. 0110, CASE 1:.Source Code = TSTFSZ. 0110, CASE 1:.Source Code = REG1. 0110, CASE 1:.Source Code = . 0110, CASE 1:.Source Code = ; is RAM location 0?. 1100, CASE 1:.Object Code = 0001. 1100, CASE 1:.Object Code = 0010. 1100, CASE 1:.Object Code = 0011. 1100, CASE 1:.Source Code = MOVFF. 1100, CASE 1:.Source Code = REG1,. 1100, CASE 1:.Source Code = REG2. 1100, CASE 1:.Source Code =",
    "FIGURE 6-5: INSTRUCTIONS IN PROGRAM MEMORY\n; Yes, execute this word. 1111, CASE 1:.Object Code = 0100. 1111, CASE 1:.Object Code = 0101. 1111, CASE 1:.Object Code = 0110. 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = . 1111, CASE 1:.Source Code = ; 2nd word of instruction. 0010, CASE 1:.Object Code = 0100. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Object Code = 0000. 0010, CASE 1:.Source Code = ADDWF. 0010, CASE 1:.Source Code = REG3. 0010, CASE 1:.Source Code = . 0010, CASE 1:.Source Code = ; continue code",
    "6.5 Data Memory Organization\nThe data memory in PIC18 devices is implemented as static RAM. Each register in the data memory has a 12-bit address, allowing up to 4,096 bytes of data memory. The memory space is divided into as many as 16 banks that contain  256 bytes  each.  PIC18F2331/2431/4331/4431 devices implement all 16 banks.\nThe instruction  set  and  architecture  allow  operations across  all  banks.  The  entire  data  memory  may  be accessed  by  Direct,  Indirect  or  Indexed  Addressing modes. Addressing modes are discussed later in this subsection.\nFigure 6-6 shows the data memory organization for the PIC18F2331/2431/4331/4431 devices. The data memory  contains  Special  Function  Registers  (SFRs)  and General Purpose Registers (GPRs). The SFRs are used for  control  and  status  of  the  controller  and  peripheral functions,  while  GPRs  are  used  for  data  storage  and scratchpad  operations  in  the  user's  application.  Any read of an unimplemented location will read as ' 0 's.",
    "6.5 Data Memory Organization\nTo  ensure  that  commonly  used  registers  (SFRs  and select GPRs) can be accessed in a single cycle, PIC18 devices implement an Access Bank. This is a 256-byte memory space that provides fast access to SFRs and the  lower  portion  of  GPR  Bank  0  without  using  the BSR. Section 6.5.2 'Access Bank' provides a detailed description of the Access RAM.",
    "6.5.2 ACCESS BANK\nLarge  areas  of  data  memory  require  an  efficient addressing  scheme  to  make  rapid  access  to  any address  possible.  Ideally,  this  means  that  an  entire address does not need to be provided for each read or write  operation.  For  PIC18  devices,  this  is  accomplished with a RAM banking scheme. This divides the memory space into 16 contiguous banks of 256 bytes.\nDepending  on  the  instruction,  each  location  can  be addressed directly by its full 12-bit address, or an 8-bit low-order  address  and  a  four-bit  Bank  Pointer.  Most instructions in  the PIC18 instruction set make use of the Bank Pointer, known as the Bank Select Register (BSR). This SFR holds the four Most Significant bits of a location's address; the instruction itself includes the eight Least Significant bits. Only the four lower bits of the BSR are implemented (BSR<3:0>). The upper four bits are unused; they will always read ' 0 ' and cannot be written to. The BSR can be loaded directly by using the MOVLB instruction.",
    "6.5.2 ACCESS BANK\nThe value of the BSR indicates the bank in data memory. The eight bits in the instruction show the location in the bank and can be thought of as an offset from the bank's lower boundary. The relationship between the BSR's value and the bank division in data memory is shown in Figure 6-6.\nSince up to 16 registers may share the same low-order address, the user must always be careful to ensure that the proper bank is selected before performing a data read or write. For example, writing what should be program  data  to  the  eight-bit  address  of  F9h,  while  the BSR is 0Fh, will end up resetting the program counter.\nWhile any bank can be selected, only those banks that are  actually  implemented  can  be  read  or  written  to. Writes  to  unimplemented  banks  are  ignored,  while reads from unimplemented banks will return ' 0 's. Even so, the STATUS register will still be affected as if the operation  was  successful.  The  data  memory  map  in Figure 6-5 indicates which banks are implemented.",
    "6.5.2 ACCESS BANK\nIn  the  core  PIC18  instruction  set,  only  the MOVFF instruction  fully  specifies  the  12-bit  address  of  the source and target registers. This instruction ignores the BSR completely when it executes. All other instructions include only the low-order address as an operand and must use either the BSR or the Access Bank to locate their target registers.\nWhile  the  use  of  the  BSR  with  an  embedded  8-bit address  allows  users  to  address  the  entire  range  of data memory, it also means that the user must always ensure  that  the  correct  bank  is  selected;  otherwise, data may be read from or written to the wrong location. This can be disastrous if a GPR is the intended target of  an  operation,  but  an  SFR  is  written  to  instead. Verifying  and/or  changing  the  BSR  for  each  read  or write to data memory can become very inefficient.",
    "6.5.2 ACCESS BANK\nTo streamline access for the most commonly used data memory locations, the data memory is configured with an  Access  Bank,  which  allows  users  to  access  a mapped block of memory without specifying  a  BSR. The  Access  Bank  consists  of  the  first  128  bytes  of memory (00h-7Fh) in Bank 0 and the last 128 bytes of memory (80h-FFh) in Block 15. The lower half is known as the 'Access RAM' and is composed of GPRs. This upper  half  is also where  the  device's  SFRs  are mapped. These two areas are mapped contiguously in the  Access  Bank  and  can  be  addressed  in  a  linear fashion by an 8-bit address (Figure 6-6).\nThe Access Bank is used by core PIC18 instructions that include the Access RAM bit (the 'a' parameter in the instruction). When 'a' is equal to ' 1 ', the instruction uses  the  BSR  and  the  8-bit  address  included  in  the opcode for the data memory address. When 'a' is ' 0 ', however,  the  instruction  is  forced  to  use  the  Access Bank  address  map;  the  current  value  of  the  BSR  is ignored entirely.",
    "6.5.2 ACCESS BANK\nUsing this 'forced' addressing allows the instruction to operate on a data address in a single cycle, without updating the BSR first. For 8-bit addresses of 80h and above, this means that users can evaluate and operate on SFRs more efficiently. The Access RAM below 80h is a good place for data values that the user might need to  access  rapidly,  such  as  immediate  computational results  or  common  program  variables.  Access  RAM also allows for faster and more code efficient context saving and switching of variables.",
    "6.5.3 GENERAL PURPOSE REGISTER (GPR) FILE\nPIC18 devices may have banked memory in the GPR area. This is data RAM, which is available for use by all instructions. GPRs  start  at  the  bottom  of  Bank  0 (address 000h) and grow upwards towards the bottom of the SFR area. GPRs are not initialized by a Power-on Reset and are unchanged on all other Resets.",
    "6.5.4 SPECIAL FUNCTION REGISTERS\nThe Special Function  Registers (SFRs) are registers used by the CPU and peripheral modules for controlling the desired operation of the device. These registers are implemented as static RAM. A list of these registers is given in Table 6-1 and Table 6-2.\n'core' are described in this section, while those related to the operation of the peripheral features are described in the section of that peripheral feature.\nThe SFRs are typically distributed among the peripherals whose functions they control.\nThe SFRs can be classified into two sets: those associated with the 'core' function and those related to the peripheral  functions.  Those  registers  related  to  the\nThe unused SFR locations will be unimplemented and read as ' 0 's.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\nFFFh, Name = TOSU. FFFh, Address = FDFh. FFFh, Name = INDF2 (1). FFFh, Address = FBFh. FFFh, Name = CCPR1H. FFFh, Address = F9Fh. FFFh, Name = IPR1. FFFh, Address = F7Fh. FFFh, Name = PTCON0. FFEh, Name = TOSH. FFEh, Address = FDEh. FFEh, Name = POSTINC2 (1). FFEh, Address = FBEh. FFEh, Name = CCPR1L. FFEh, Address = F9Eh. FFEh, Name = PIR1. FFEh, Address = F7Eh. FFEh, Name = PTCON1. FFDh, Name = TOSL. FFDh, Address = FDDh. FFDh, Name = POSTDEC2 (1). FFDh, Address = FBDh. FFDh, Name = CCP1CON. FFDh,",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\nAddress = F9Dh. FFDh, Name = PIE1. FFDh, Address = F7Dh. FFDh, Name = PTMRL. FFCh, Name = STKPTR. FFCh, Address = FDCh. FFCh, Name = PREINC2 (1). FFCh, Address = FBCh. FFCh, Name = CCPR2H. FFCh, Address = F9Ch. FFCh, Name = - (2). FFCh, Address = F7Ch. FFCh, Name = PTMRH. FFBh, Name = PCLATU. FFBh, Address = FDBh. FFBh, Name = PLUSW2 (1). FFBh, Address = FBBh. FFBh, Name = CCPR2L. FFBh, Address = F9Bh. FFBh, Name = OSCTUNE. FFBh, Address = F7Bh. FFBh, Name = PTPERL. FFAh, Name = PCLATH. FFAh, Address = FDAh. FFAh, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\nFSR2H. FFAh, Address = FBAh. FFAh, Name = CCP2CON. FFAh, Address = F9Ah. FFAh, Name = ADCON3. FFAh, Address = F7Ah. FFAh, Name = PTPERH. FF9h, Name = PCL. FF9h, Address = FD9h. FF9h, Name = FSR2L. FF9h, Address = FB9h. FF9h, Name = ANSEL1. FF9h, Address = F99h. FF9h, Name = ADCHS. FF9h, Address = F79h. FF9h, Name = PDC0L. FF8h, Name = TBLPTRU. FF8h, Address = FD8h. FF8h, Name = STATUS. FF8h, Address = FB8h. FF8h, Name = ANSEL0. FF8h, Address = F98h. FF8h, Name = - (2). FF8h, Address",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\n= F78h. FF8h, Name = PDC0H. FF7h, Name = TBLPTRH. FF7h, Address = FD7h. FF7h, Name = TMR0H. FF7h, Address = FB7h. FF7h, Name = T5CON. FF7h, Address = F97h. FF7h, Name = - (2). FF7h, Address = F77h. FF7h, Name = PDC1L. FF6h, Name = TBLPTRL. FF6h, Address = FD6h. FF6h, Name = TMR0L. FF6h, Address = FB6h. FF6h, Name = QEICON. FF6h, Address = F96h. FF6h, Name = TRISE (3). FF6h, Address = F76h. FF6h, Name = PDC1H. FF5h, Name = TABLAT. FF5h, Address =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\nFD5h. FF5h, Name = T0CON. FF5h, Address = FB5h. FF5h, Name = - (2). FF5h, Address = F95h. FF5h, Name = TRISD (3). FF5h, Address = F75h. FF5h, Name = PDC2L. FF4h, Name = PRODH. FF4h, Address = FD4h. FF4h, Name = - (2). FF4h, Address = FB4h. FF4h, Name = - (2). FF4h, Address = F94h. FF4h, Name = TRISC. FF4h, Address = F74h. FF4h, Name = PDC2H. FF3h, Name = PRODL. FF3h, Address = FD3h. FF3h, Name = OSCCON. FF3h, Address = FB3h. FF3h, Name = - (2).",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\nFF3h, Address = F93h. FF3h, Name = TRISB. FF3h, Address = F73h. FF3h, Name = PDC3L (3). FF2h, Name = INTCON. FF2h, Address = FD2h. FF2h, Name = LVDCON. FF2h, Address = FB2h. FF2h, Name = - (2). FF2h, Address = F92h. FF2h, Name = TRISA. FF2h, Address = F72h. FF2h, Name = PDC3H (3). FF1h, Name = INTCON2. FF1h, Address = FD1h. FF1h, Name = WDTCON. FF1h, Address = FB1h. FF1h, Name = - (2). FF1h, Address = F91h. FF1h, Name = PR5H. FF1h, Address = F71h. FF1h,",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\nName = SEVTCMPL. FF0h, Name = INTCON3. FF0h, Address = FD0h. FF0h, Name = RCON. FF0h, Address = FB0h. FF0h, Name = SPBRGH. FF0h, Address = F90h. FF0h, Name = PR5L. FF0h, Address = F70h. FF0h, Name = SEVTCMPH. FEFh, Name = INDF0 (1). FEFh, Address = FCFh. FEFh, Name = TMR1H. FEFh, Address = FAFh. FEFh, Name = SPBRG. FEFh, Address = F8Fh. FEFh, Name = - (2). FEFh, Address = F6Fh. FEFh, Name = PWMCON0. FEEh, Name = POSTINC0 (1). FEEh, Address = FCEh. FEEh, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\nTMR1L. FEEh, Address = FAEh. FEEh, Name = RCREG. FEEh, Address = F8Eh. FEEh, Name = - (2). FEEh, Address = F6Eh. FEEh, Name = PWMCON1. FEDh, Name = POSTDEC0 (1). FEDh, Address = FCDh. FEDh, Name = T1CON. FEDh, Address = FADh. FEDh, Name = TXREG. FEDh, Address = F8Dh. FEDh, Name = LATE (3). FEDh, Address = F6Dh. FEDh, Name = DTCON. FECh, Name = PREINC0 (1). FECh, Address = FCCh. FECh, Name = TMR2. FECh, Address = FACh. FECh, Name = TXSTA. FECh, Address = F8Ch. FECh, Name = LATD (3). FECh, Address = F6Ch. FECh, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\nFLTCONFIG. FEBh, Name = PLUSW0 (1). FEBh, Address = FCBh. FEBh, Name = PR2. FEBh, Address = FABh. FEBh, Name = RCSTA. FEBh, Address = F8Bh. FEBh, Name = LATC. FEBh, Address = F6Bh. FEBh, Name = OVDCOND. FEAh, Name = FSR0H. FEAh, Address = FCAh. FEAh, Name = T2CON. FEAh, Address = FAAh. FEAh, Name = BAUDCON. FEAh, Address = F8Ah. FEAh, Name = LATB. FEAh, Address = F6Ah. FEAh, Name = OVDCONS. FE9h, Name = FSR0L. FE9h, Address = FC9h. FE9h, Name = SSPBUF. FE9h, Address = FA9h. FE9h, Name = EEADR. FE9h, Address = F89h.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\nFE9h, Name = LATA. FE9h, Address = F69h. FE9h, Name = CAP1BUFH. FE8h, Name = WREG. FE8h, Address = FC8h. FE8h, Name = SSPADD. FE8h, Address = FA8h. FE8h, Name = EEDATA. FE8h, Address = F88h. FE8h, Name = TMR5H. FE8h, Address = F68h. FE8h, Name = CAP1BUFL. FE7h, Name = INDF1 (1). FE7h, Address = FC7h. FE7h, Name = SSPSTAT. FE7h, Address = FA7h. FE7h, Name = EECON2. FE7h, Address = F87h. FE7h, Name = TMR5L. FE7h, Address = F67h. FE7h, Name = CAP2BUFH. FE6h, Name =",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\nPOSTINC1 (1). FE6h, Address = FC6h. FE6h, Name = SSPCON. FE6h, Address = FA6h. FE6h, Name = EECON1. FE6h, Address = F86h. FE6h, Name = - (2). FE6h, Address = F66h. FE6h, Name = CAP2BUFL. FE5h, Name = POSTDEC1 (1). FE5h, Address = FC5h. FE5h, Name = - (2). FE5h, Address = FA5h. FE5h, Name = IPR3. FE5h, Address = F85h. FE5h, Name = - (2). FE5h, Address = F65h. FE5h, Name = CAP3BUFH. FE4h, Name = PREINC1 (1). FE4h, Address = FC4h. FE4h, Name = ADRESH. FE4h, Address = FA4h.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\nFE4h, Name = PIR3. FE4h, Address = F84h. FE4h, Name = PORTE. FE4h, Address = F64h. FE4h, Name = CAP3BUFL. FE3h, Name = PLUSW1 (1). FE3h, Address = FC3h. FE3h, Name = ADRESL. FE3h, Address = FA3h. FE3h, Name = PIE3. FE3h, Address = F83h. FE3h, Name = PORTD (3). FE3h, Address = F63h. FE3h, Name = CAP1CON. FE2h, Name = FSR1H. FE2h, Address = FC2h. FE2h, Name = ADCON0. FE2h, Address = FA2h. FE2h, Name = IPR2. FE2h, Address = F82h. FE2h, Name = PORTC. FE2h, Address = F62h.",
    "TABLE 6-1: SPECIAL FUNCTION REGISTER MAP FOR PIC18F2331/2431/4331/4431 DEVICES\nFE2h, Name = CAP2CON. FE1h, Name = FSR1L. FE1h, Address = FC1h. FE1h, Name = ADCON1. FE1h, Address = FA1h. FE1h, Name = PIR2. FE1h, Address = F81h. FE1h, Name = PORTB. FE1h, Address = F61h. FE1h, Name = CAP3CON. FE0h, Name = BSR. FE0h, Address = FC0h. FE0h, Name = ADCON2. FE0h, Address = FA0h. FE0h, Name = PIE2. FE0h, Address = F80h. FE0h, Name = PORTA. FE0h, Address = F60h. FE0h, Name = DFLTCON\nNote\n1: This is not a physical register.\n2: Unimplemented registers are read as ' 0 '.\n3: This register is not available on 28-pin devices.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nTOSU, Bit 7 = -. TOSU, Bit 6 = -. TOSU, Bit 5 = -. TOSU, Bit 4 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 3 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 2 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 1 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 0 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Value on POR, BOR = ---0 0000. TOSU, Value on POR, BOR = . TOSH, Bit 7 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 6 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 5 = Top-of-Stack High Byte",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\n(TOS<15:8>). TOSH, Bit 4 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 3 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 2 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 1 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 0 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Value on POR, BOR = 0000 0000. TOSH, Value on POR, BOR = . TOSL, Bit 7 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 6 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 5 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 4 = Top-of-Stack Low",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nByte (TOS<7:0>). TOSL, Bit 3 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 2 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 1 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 0 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Value on POR, BOR = 0000 0000. TOSL, Value on POR, BOR = . STKPTR, Bit 7 = STKFUL. STKPTR, Bit 6 = STKUNF. STKPTR, Bit 5 = -. STKPTR, Bit 4 = SP4. STKPTR, Bit 3 = SP3. STKPTR, Bit 2 = SP2. STKPTR, Bit 1 = SP1. STKPTR, Bit 0 = SP0. STKPTR, Value on POR, BOR =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\n00-0 0000. STKPTR, Value on POR, BOR = . PCLATU, Bit 7 = -. PCLATU, Bit 6 = -. PCLATU, Bit 5 = bit 21 (3). PCLATU, Bit 4 = Holding Register for PC<20:16>. PCLATU, Bit 3 = Holding Register for PC<20:16>. PCLATU, Bit 2 = Holding Register for PC<20:16>. PCLATU, Bit 1 = Holding Register for PC<20:16>. PCLATU, Bit 0 = Holding Register for PC<20:16>. PCLATU, Value on POR, BOR = ---0 0000. PCLATU, Value on POR, BOR = . PCLATH, Bit 7 = Holding Register for PC<15:8>. PCLATH, Bit 6 = Holding Register for PC<15:8>. PCLATH, Bit 5 = Holding Register for PC<15:8>. PCLATH, Bit 4 = Holding Register for",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nPC<15:8>. PCLATH, Bit 3 = Holding Register for PC<15:8>. PCLATH, Bit 2 = Holding Register for PC<15:8>. PCLATH, Bit 1 = Holding Register for PC<15:8>. PCLATH, Bit 0 = Holding Register for PC<15:8>. PCLATH, Value on POR, BOR = 0000 0000. PCLATH, Value on POR, BOR = . PCL, Bit 7 = PC Low Byte (PC<7:0>). PCL, Bit 6 = PC Low Byte (PC<7:0>). PCL, Bit 5 = PC Low Byte (PC<7:0>). PCL, Bit 4 = PC Low Byte (PC<7:0>). PCL, Bit 3 = PC Low Byte (PC<7:0>). PCL, Bit 2 = PC Low Byte (PC<7:0>). PCL, Bit 1 = PC Low Byte (PC<7:0>). PCL,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nBit 0 = PC Low Byte (PC<7:0>). PCL, Value on POR, BOR = 0000 0000. PCL, Value on POR, BOR = . TBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit 21 (3). TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on POR, BOR = --00 0000. TBLPTRU, Value on POR, BOR = .",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nTBLPTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Value on POR, BOR = 0000 0000. TBLPTRH, Value on POR, BOR = .",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nTBLPTRL, Bit 7 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Value on POR, BOR = 0000 0000. TBLPTRL, Value on POR, BOR = .",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nTABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on POR, BOR = 0000 0000. TABLAT, Value on POR, BOR = . PRODH, Bit 7 = Product Register High Byte. PRODH, Bit 6 = Product Register High Byte. PRODH, Bit 5 = Product Register High Byte. PRODH, Bit 4 = Product Register High Byte. PRODH, Bit 3 = Product Register High Byte. PRODH, Bit 2 = Product Register High Byte. PRODH, Bit 1 = Product Register High Byte. PRODH, Bit 0 = Product Register High Byte. PRODH, Value on POR, BOR = xxxx xxxx. PRODH, Value on POR, BOR = . PRODL, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\n7 = Product Register Low Byte. PRODL, Bit 6 = Product Register Low Byte. PRODL, Bit 5 = Product Register Low Byte. PRODL, Bit 4 = Product Register Low Byte. PRODL, Bit 3 = Product Register Low Byte. PRODL, Bit 2 = Product Register Low Byte. PRODL, Bit 1 = Product Register Low Byte. PRODL, Bit 0 = Product Register Low Byte. PRODL, Value on POR, BOR = xxxx xxxx. PRODL, Value on POR, BOR = . INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on POR, BOR = . INTCON2, Bit 7 = RBPU.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nINTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = -. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = -. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111 -1-1. INTCON2, Value on POR, BOR = . INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 11-0 0-00. INTCON3, Value on POR, BOR = . INDF0, Bit 7 = Uses contents of",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nFSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 0 = Uses contents of FSR0 to address data memory -",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nvalue of FSR0 not changed (not a physical register). INDF0, Value on POR, BOR = N/A. INDF0, Value on POR, BOR = N/A. POSTINC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 2 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nUses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Value on POR, BOR = N/A. POSTINC0, Value on POR, BOR = N/A. POSTDEC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\npost-decremented (not a physical register). POSTDEC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Value on POR, BOR = N/A. POSTDEC0, Value on POR, BOR = . PREINC0, Bit 7 = Uses contents of",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nFSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\npre-incremented (not a physical register). PREINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Value on POR, BOR = N/A. PREINC0, Value on POR, BOR = . PLUSW0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 offset by W(not a physical register). PLUSW0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 offset by W(not a physical register). PLUSW0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 offset by W(not a physical register). PLUSW0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 offset by W(not a physical register). PLUSW0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\noffset by W(not a physical register). PLUSW0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 offset by W(not a physical register). PLUSW0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 offset by W(not a physical register). PLUSW0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 offset by W(not a physical register). PLUSW0, Value on POR, BOR = N/A. PLUSW0, Value on POR, BOR = . FSR0H, Bit 7 = -. FSR0H, Bit 6 = -. FSR0H, Bit 5 = -. FSR0H, Bit 4 = -. FSR0H, Bit 3 = Indirect Data Memory Address Pointer 0 High. FSR0H, Bit 2 = Indirect Data Memory Address Pointer 0 High. FSR0H, Bit 1 = Indirect Data Memory Address Pointer 0 High. FSR0H, Bit 0 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nIndirect Data Memory Address Pointer 0 High. FSR0H, Value on POR, BOR = ---- xxxx. FSR0H, Value on POR, BOR = . FSR0L, Bit 7 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 6 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 5 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 4 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 3 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 2 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 1 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 0 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Value on POR, BOR = xxxx xxxx. FSR0L, Value on POR, BOR = . WREG, Bit 7 = Working Register. WREG, Bit 6 = Working Register. WREG, Bit 5 = Working",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nRegister. WREG, Bit 4 = Working Register. WREG, Bit 3 = Working Register. WREG, Bit 2 = Working Register. WREG, Bit 1 = Working Register. WREG, Bit 0 = Working Register. WREG, Value on POR, BOR = xxxx xxxx. WREG, Value on POR, BOR = . INDF1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nregister). INDF1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register). INDF1, Value on POR, BOR = N/A. INDF1, Value on POR, BOR = . POSTINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nregister). POSTINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Value on POR, BOR = N/A. POSTINC1, Value on POR, BOR = . POSTDEC1, Bit 7 = Uses contents of FSR1 to address data memory - value",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nof FSR1 post-decremented (not a physical register). POSTDEC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register).",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nPOSTDEC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Value on POR, BOR = N/A. POSTDEC1, Value on POR, BOR = . PREINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nFSR1 pre-incremented (not a physical register). PREINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Value on POR, BOR = N/A. PREINC1, Value on POR, BOR = . PLUSW1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 5 = Uses contents of FSR1 to",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\naddress data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Value on POR, BOR = N/A. PLUSW1, Value on POR, BOR = . FSR1H, Bit 7 = -. FSR1H, Bit 6 = -.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nFSR1H, Bit 5 = -. FSR1H, Bit 4 = -. FSR1H, Bit 3 = Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 2 = Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 1 = Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 0 = Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Value on POR, BOR = ---- 0000. FSR1H, Value on POR, BOR = . FSR1L, Bit 7 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 6 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 5 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 4 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 3 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 2 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 1 = Indirect Data",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nMemory Address Pointer 1 Low Byte. FSR1L, Bit 0 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Value on POR, BOR = xxxx xxxx. FSR1L, Value on POR, BOR = . BSR, Bit 7 = -. BSR, Bit 6 = -. BSR, Bit 5 = -. BSR, Bit 4 = -. BSR, Bit 3 = Bank Select Register. BSR, Bit 2 = Bank Select Register. BSR, Bit 1 = Bank Select Register. BSR, Bit 0 = Bank Select Register. BSR, Value on POR, BOR = ---- 0000. BSR, Value on POR, BOR = . INDF2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 5 = Uses contents of FSR2 to",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\naddress data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Value on POR, BOR = N/A. INDF2, Value on POR, BOR = . POSTINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\npost-incremented (not a physical register). POSTINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register).",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nPOSTINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Value on POR, BOR = N/A. POSTINC2, Value on POR, BOR = . POSTDEC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 3 = Uses contents of FSR2 to address data memory - value of",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nFSR2 post-decremented (not a physical register). POSTDEC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Value on POR, BOR = N/A. POSTDEC2, Value on POR, BOR = . PREINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 5 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nUses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Value on POR, BOR = N/A. PREINC2, Value on",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nPOR, BOR = . PLUSW2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\na physical register). PLUSW2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Value on POR, BOR = N/A. PLUSW2, Value on POR, BOR = . FSR2H, Bit 7 = -. FSR2H, Bit 6 = -. FSR2H, Bit 5 = -. FSR2H, Bit 4 = -. FSR2H, Bit 3 = Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 2 = Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 1 = Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 0 = Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Value on POR, BOR = ---- 0000. FSR2H, Value on POR, BOR = . FSR2L STATUS, Bit 7 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nTimer0 Register High Byte. FSR2L STATUS, Bit 6 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS, Bit 5 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS, Bit 4 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS, Bit 3 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS, Bit 2 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS, Bit 1 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte. FSR2L STATUS, Bit 0 = Indirect Data Memory Address Pointer 2 Low Byte - - - N OV Z DC C Timer0 Register High Byte.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nFSR2L STATUS, Value on POR, BOR = xxxx xxxx ---x xxxx. FSR2L STATUS, Value on POR, BOR = . TMR0L, Bit 7 = Register Low Byte. TMR0L, Bit 6 = Register Low Byte. TMR0L, Bit 5 = Register Low Byte. TMR0L, Bit 4 = Register Low Byte. TMR0L, Bit 3 = Register Low Byte. TMR0L, Bit 2 = Register Low Byte. TMR0L, Bit 1 = Register Low Byte. TMR0L, Bit 0 = Register Low Byte. TMR0L, Value on POR, BOR = xxxx. TMR0L, Value on POR, BOR = . T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T016BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nT0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = . T0CON, Value on POR, BOR = . TMR0H, Bit 7 = . TMR0H, Bit 6 = . TMR0H, Bit 5 = . TMR0H, Bit 4 = . TMR0H, Bit 3 = . TMR0H, Bit 2 = . TMR0H, Bit 1 = . TMR0H, Bit 0 = . TMR0H, Value on POR, BOR = 0000 0000. TMR0H, Value on POR, BOR = . , Bit 7 = Timer0. , Bit 6 = Timer0. , Bit 5 = Timer0. , Bit 4 = Timer0. , Bit 3 = Timer0. , Bit 2 = Timer0. , Bit 1 = Timer0. , Bit 0 = Timer0. , Value on",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nPOR, BOR = xxxx. , Value on POR, BOR = . , Bit 7 = . , Bit 6 = . , Bit 5 = . , Bit 4 = . , Bit 3 = . , Bit 2 = . , Bit 1 = . , Bit 0 = . , Value on POR, BOR = 1111 1111. , Value on POR, BOR = \nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition. Shaded cells are unimplemented.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431)\nNote 1: RA6 and associated bits are configured as port pins in RCIO, ECIO and INTIO2 (with port function on RA6) Oscillator modes only and read ' 0 ' in all other oscillator modes.\n2: RA7 and associated bits are configured as port pins in INTIO2 Oscillator mode only and read ' 0 ' in all other modes.\n3: Bit 21 of the PC is only available in Test mode and Serial Programming modes.\n4: These registers and/or bits are not implemented on the PIC18F2331/2431 devices and read as ' 0 '.\n5: The RE3 port bit is only available for PIC18F4331/4431 devices when the MCLRE fuse (CONFIG3H<7>) is programmed to ' 0 '; otherwise, RE3 reads ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nOSCCON, Bit 7 = IDLEN. OSCCON, Bit 6 = IRCF2. OSCCON, Bit 5 = IRCF1. OSCCON, Bit 4 = IRCF0. OSCCON, Bit 3 = OSTS. OSCCON, Bit 2 = IOFS. OSCCON, Bit 1 = SCS1. OSCCON, Bit 0 = SCS0. OSCCON, Value on POR, BOR = 0000. OSCCON, Value on POR, BOR = q000. LVDCON, Bit 7 = -. LVDCON, Bit 6 = -. LVDCON, Bit 5 = IRVST. LVDCON, Bit 4 = LVDEN. LVDCON, Bit 3 = LVDL3. LVDCON, Bit 2 = LVDL2. LVDCON, Bit 1 = LVDL1. LVDCON, Bit 0 = LVDL0. LVDCON, Value on POR, BOR = --00. LVDCON, Value on POR,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nBOR = 0101. WDTCON, Bit 7 = WDTW. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTEN. WDTCON, Value on POR, BOR = 0---. WDTCON, Value on POR, BOR = ---0. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Value on POR, BOR = 0--1. RCON, Value on POR, BOR = 11q0. TMR1H, Bit 7 = Timer1 Register High Byte.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nTMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on POR, BOR = xxxx. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nTMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on POR, BOR = xxxx. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0000. T1CON, Value on POR, BOR = 0000. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\n4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR, BOR = 0000. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR, BOR = 1111. T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nTOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. SSPBUF, Bit 7 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 0 = SSP Receive Buffer/Transmit Register. SSPBUF,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nValue on POR, BOR = xxxx. SSPBUF, Value on POR, BOR = xxxx. SSPADD, Bit 7 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 6 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 5 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 4 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 3 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 2 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nRate Reload Register in I 2 C Master mode.. SSPADD, Bit 1 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 0 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Value on POR, BOR = 0000. SSPADD, Value on POR, BOR = 0000. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Value on POR, BOR = 0000. SSPSTAT, Value on POR, BOR = 0000. SSPCON, Bit 7 = WCOL.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nSSPCON, Bit 6 = SSPOV. SSPCON, Bit 5 = SSPEN. SSPCON, Bit 4 = CKP. SSPCON, Bit 3 = SSPM3. SSPCON, Bit 2 = SSPM2. SSPCON, Bit 1 = SSPM1. SSPCON, Bit 0 = SSPM0. SSPCON, Value on POR, BOR = 0000. SSPCON, Value on POR, BOR = 0000. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte. ADRESH, Value on POR, BOR = xxxx.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nADRESH, Value on POR, BOR = xxxx. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Value on POR, BOR = xxxx. ADRESL, Value on POR, BOR = xxxx. ADCON0, Bit 7 = -. ADCON0, Bit 6 = -. ADCON0, Bit 5 = ACONV. ADCON0, Bit 4 = ACSCH. ADCON0, Bit 3 = ACMOD1. ADCON0, Bit 2 = ACMOD0. ADCON0, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\n1 = GO/DONE. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR = --00. ADCON0, Value on POR, BOR = 0000. ADCON1, Bit 7 = VCFG1. ADCON1, Bit 6 = VCFG0. ADCON1, Bit 5 = -. ADCON1, Bit 4 = FIFOEN. ADCON1, Bit 3 = BFEMT. ADCON1, Bit 2 = BFOVFL. ADCON1, Bit 1 = ADPNT1. ADCON1, Bit 0 = ADPNT0. ADCON1, Value on POR, BOR = 00-0. ADCON1, Value on POR, BOR = 0000. ADCON2, Bit 7 = ADFM. ADCON2, Bit 6 = ACQT3. ADCON2, Bit 5 = ACQT2. ADCON2, Bit 4 = ACQT1. ADCON2, Bit 3 = ACQT0. ADCON2, Bit 2 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nADCS2. ADCON2, Bit 1 = ADCS1. ADCON2, Bit 0 = ADCS0. ADCON2, Value on POR, BOR = 0000. ADCON2, Value on POR, BOR = 0000. ADCON3, Bit 7 = ADRS1. ADCON3, Bit 6 = ADRS0. ADCON3, Bit 5 = -. ADCON3, Bit 4 = SSRC4. ADCON3, Bit 3 = SSRC3. ADCON3, Bit 2 = SSRC2. ADCON3, Bit 1 = SSRC1. ADCON3, Bit 0 = SSRC0. ADCON3, Value on POR, BOR = 00-0. ADCON3, Value on POR, BOR = 0000. ADCHS, Bit 7 = GDSEL1. ADCHS, Bit 6 = GDSEL0. ADCHS, Bit 5 = GBSEL1. ADCHS, Bit 4 = GBSEL0. ADCHS, Bit 3 = GCSEL1. ADCHS, Bit 2 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nGCSEL0. ADCHS, Bit 1 = GASEL1. ADCHS, Bit 0 = GASEL0. ADCHS, Value on POR, BOR = 0000. ADCHS, Value on POR, BOR = 0000. CCPR1H, Bit 7 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Value on POR, BOR = xxxx.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nCCPR1H, Value on POR, BOR = xxxx. CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nCCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = --00. CCP1CON, Value on POR, BOR = 0000. CCPR2H, Bit 7 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 6 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 5 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 4 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 3 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 2 = Capture/Compare/PWM Register",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\n2 High Byte. CCPR2H, Bit 1 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 0 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on POR, BOR = xxxx. CCPR2L, Bit 7 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 6 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 5 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 4 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 3 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 2 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 1 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 0 = Capture/Compare/PWM",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nRegister 2 Low Byte. CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on POR, BOR = xxxx. CCP2CON, Bit 7 = -. CCP2CON, Bit 6 = -. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Value on POR, BOR = --00. CCP2CON, Value on POR, BOR = 0000. ANSEL1, Bit 7 = -. ANSEL1, Bit 6 = -. ANSEL1, Bit 5 = -. ANSEL1, Bit 4 = -. ANSEL1, Bit 3 = -. ANSEL1, Bit 2 = -. ANSEL1, Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\n-. ANSEL1, Bit 0 = ANS8 (4). ANSEL1, Value on POR, BOR = ----. ANSEL1, Value on POR, BOR = ---1. ANSEL0, Bit 7 = ANS7 (4). ANSEL0, Bit 6 = ANS6 (4). ANSEL0, Bit 5 = ANS5 (4). ANSEL0, Bit 4 = ANS4. ANSEL0, Bit 3 = ANS3. ANSEL0, Bit 2 = ANS2. ANSEL0, Bit 1 = ANS1. ANSEL0, Bit 0 = ANS0. ANSEL0, Value on POR, BOR = 1111. ANSEL0, Value on POR, BOR = 1111. T5CON, Bit 7 = T5SEN. T5CON, Bit 6 = RESEN (4). T5CON, Bit 5 = T5MOD. T5CON, Bit 4 = T5PS1. T5CON, Bit 3 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nT5PS0. T5CON, Bit 2 = T5SYNC. T5CON, Bit 1 = TMR5CS. T5CON, Bit 0 = TMR5ON. T5CON, Value on POR, BOR = 0000. T5CON, Value on POR, BOR = 0000. QEICON, Bit 7 = VELM. QEICON, Bit 6 = QERR. QEICON, Bit 5 = UP/DOWN. QEICON, Bit 4 = QEIM2. QEICON, Bit 3 = QEIM1. QEICON, Bit 2 = QEIM0. QEICON, Bit 1 = PDEC1. QEICON, Bit 0 = PDEC0. QEICON, Value on POR, BOR = 0000. QEICON, Value on POR, BOR = 0000. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nEUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nBaud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. RCREG, Bit 7 = EUSART Receive Register. RCREG, Bit 6 = EUSART Receive Register. RCREG, Bit 5 = EUSART Receive Register. RCREG, Bit 4 = EUSART Receive Register. RCREG, Bit 3 = EUSART Receive Register. RCREG, Bit 2 = EUSART Receive Register. RCREG, Bit 1 = EUSART Receive Register. RCREG, Bit 0 = EUSART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. TXREG, Bit 7 = EUSART Transmit Register. TXREG, Bit 6 = EUSART Transmit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nRegister. TXREG, Bit 5 = EUSART Transmit Register. TXREG, Bit 4 = EUSART Transmit Register. TXREG, Bit 3 = EUSART Transmit Register. TXREG, Bit 2 = EUSART Transmit Register. TXREG, Bit 1 = EUSART Transmit Register. TXREG, Bit 0 = EUSART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. RCSTA BAUDCON, Bit 7 = SPEN -. RCSTA BAUDCON, Bit 6 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nRX9 RCIDL. RCSTA BAUDCON, Bit 5 = SREN -. RCSTA BAUDCON, Bit 4 = CREN SCKP. RCSTA BAUDCON, Bit 3 = ADDEN BRG16. RCSTA BAUDCON, Bit 2 = FERR -. RCSTA BAUDCON, Bit 1 = OERR WUE. RCSTA BAUDCON, Bit 0 = RX9D ABDEN. RCSTA BAUDCON, Value on POR, BOR = 0000 -1-1. RCSTA BAUDCON, Value on POR, BOR = 000X 0-00\nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition. Shaded cells are unimplemented.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nNote 1: RA6 and associated bits are configured as port pins in RCIO, ECIO and INTIO2 (with port function on RA6) Oscillator modes only and read ' 0 ' in all other oscillator modes.\n2: RA7 and associated bits are configured as port pins in INTIO2 Oscillator mode only and read ' 0 ' in all other modes.\n3: Bit 21 of the PC is only available in Test mode and Serial Programming modes.\n4: These registers and/or bits are not implemented on the PIC18F2331/2431 devices and read as ' 0 '.\n5: The RE3 port bit is only available for PIC18F4331/4431 devices when the MCLRE fuse (CONFIG3H<7>) is programmed to ' 0 '; otherwise, RE3 reads ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nEEADR, Bit 7 = EEPROM Address Register. EEADR, Bit 6 = EEPROM Address Register. EEADR, Bit 5 = EEPROM Address Register. EEADR, Bit 4 = EEPROM Address Register. EEADR, Bit 3 = EEPROM Address Register. EEADR, Bit 2 = EEPROM Address Register. EEADR, Bit 1 = EEPROM Address Register. EEADR, Bit 0 = EEPROM Address Register. EEADR, Value on POR, BOR = 0000. EEADR, Value on POR, BOR = 0000. EEDATA, Bit 7 = EEPROM Data Register. EEDATA, Bit 6 = EEPROM Data Register. EEDATA, Bit 5 = EEPROM Data Register. EEDATA, Bit 4 = EEPROM Data Register. EEDATA, Bit 3 = EEPROM Data Register. EEDATA, Bit 2 = EEPROM Data Register. EEDATA, Bit 1 = EEPROM Data Register. EEDATA, Bit 0",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\n= EEPROM Data Register. EEDATA, Value on POR, BOR = 0000. EEDATA, Value on POR, BOR = 0000. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Value on POR, BOR = 0000. EECON2, Value on POR, BOR = 0000. EECON1, Bit 7",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\n= EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on POR, BOR = xx-0. EECON1, Value on POR, BOR = x000. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = -. IPR3, Bit 4 = PTIP. IPR3, Bit 3 = IC3DRIP. IPR3, Bit 2 = IC2QEIP. IPR3, Bit 1 = IC1IP. IPR3, Bit 0 = TMR5IP. IPR3, Value on POR, BOR = ---1. IPR3, Value on POR, BOR = 1111. PIR3, Bit 7 = -. PIR3,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nBit 6 = -. PIR3, Bit 5 = -. PIR3, Bit 4 = PTIF. PIR3, Bit 3 = IC3DRIF. PIR3, Bit 2 = IC2QEIF. PIR3, Bit 1 = IC1IF. PIR3, Bit 0 = TMR5IF. PIR3, Value on POR, BOR = ---0. PIR3, Value on POR, BOR = 0000. PIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = -. PIE3, Bit 4 = PTIE. PIE3, Bit 3 = IC3DRIE. PIE3, Bit 2 = IC2QEIE. PIE3, Bit 1 = IC1IE. PIE3, Bit 0 = TMR5IE. PIE3, Value on POR, BOR = ---0. PIE3, Value on POR, BOR = 0000. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = -.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nIPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = -. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = -. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = 1--1. IPR2, Value on POR, BOR = -1-1. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = -. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = -. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = 0--0. PIR2, Value on POR, BOR = -0-0. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = -. PIE2, Bit 5",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\n= -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = -. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = -. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = 0--0. PIE2, Value on POR, BOR = -0-0. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = -111. IPR1, Value on POR, BOR = 1111. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\n4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = -000. PIR1, Value on POR, BOR = 0000. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = -000. PIE1, Value on POR, BOR = 0000. OSCTUNE, Bit 7 = -. OSCTUNE, Bit 6 = -. OSCTUNE, Bit 5 = TUN5. OSCTUNE, Bit 4 = TUN4. OSCTUNE,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nBit 3 = TUN3. OSCTUNE, Bit 2 = TUN2. OSCTUNE, Bit 1 = TUN1. OSCTUNE, Bit 0 = TUN0. OSCTUNE, Value on POR, BOR = --00. OSCTUNE, Value on POR, BOR = 0000. ADCON3, Bit 7 = ADRS1. ADCON3, Bit 6 = ADRS0. ADCON3, Bit 5 = -. ADCON3, Bit 4 = SSRC4. ADCON3, Bit 3 = SSRC3. ADCON3, Bit 2 = SSRC2. ADCON3, Bit 1 = SSRC1. ADCON3, Bit 0 = SSRC0. ADCON3, Value on POR, BOR = 00-0. ADCON3, Value on POR, BOR = 0000. ADCHS, Bit 7 = GDSEL1. ADCHS, Bit 6 = GDSEL0. ADCHS, Bit 5 = GBSEL1. ADCHS, Bit 4 = GBSEL0. ADCHS, Bit 3 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nGCSEL1. ADCHS, Bit 2 = GCSEL0. ADCHS, Bit 1 = GASEL1. ADCHS, Bit 0 = GASEL0. ADCHS, Value on POR, BOR = 0000. ADCHS, Value on POR, BOR = 0000. TRISE (4), Bit 7 = -. TRISE (4), Bit 6 = -. TRISE (4), Bit 5 = -. TRISE (4), Bit 4 = -. TRISE (4), Bit 3 = -. TRISE (4), Bit 2 = PORTE Data Direction Register (4). TRISE (4), Bit 1 = PORTE Data Direction Register (4). TRISE (4), Bit 0 = PORTE Data Direction Register (4). TRISE (4), Value on POR, BOR = ----. TRISE (4), Value on POR, BOR = -111. TRISD (4), Bit 7 = PORTD Data Direction Register. TRISD (4), Bit 6 = PORTD Data",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nDirection Register. TRISD (4), Bit 5 = PORTD Data Direction Register. TRISD (4), Bit 4 = PORTD Data Direction Register. TRISD (4), Bit 3 = PORTD Data Direction Register. TRISD (4), Bit 2 = PORTD Data Direction Register. TRISD (4), Bit 1 = PORTD Data Direction Register. TRISD (4), Bit 0 = PORTD Data Direction Register. TRISD (4), Value on POR, BOR = 1111. TRISD (4), Value on POR, BOR = 1111. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nBOR = 1111. TRISC, Value on POR, BOR = 1111. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR = 1111. TRISB, Value on POR, BOR = 1111. TRISA, Bit 7 = TRISA7 (2) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 6 = TRISA7 (2) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 5 = TRISA7 (2) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 4 = TRISA7 (2) TRISA6",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\n(1) PORTA Data Direction Register. TRISA, Bit 3 = TRISA7 (2) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 2 = TRISA7 (2) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 1 = TRISA7 (2) TRISA6 (1) PORTA Data Direction Register. TRISA, Bit 0 = TRISA7 (2) TRISA6 (1) PORTA Data Direction Register. TRISA, Value on POR, BOR = 1111. TRISA, Value on POR, BOR = 1111. PR5H, Bit 7 = Timer5 Period Register High Byte. PR5H, Bit 6 = Timer5 Period Register High Byte. PR5H, Bit 5 = Timer5 Period Register High Byte. PR5H, Bit 4 = Timer5 Period Register High Byte. PR5H, Bit 3 = Timer5 Period Register High Byte. PR5H, Bit 2 = Timer5 Period Register High Byte. PR5H, Bit 1 = Timer5 Period Register High Byte.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nPR5H, Bit 0 = Timer5 Period Register High Byte. PR5H, Value on POR, BOR = 1111. PR5H, Value on POR, BOR = 1111. PR5L, Bit 7 = Timer5 Period Register Low Byte. PR5L, Bit 6 = Timer5 Period Register Low Byte. PR5L, Bit 5 = Timer5 Period Register Low Byte. PR5L, Bit 4 = Timer5 Period Register Low Byte. PR5L, Bit 3 = Timer5 Period Register Low Byte. PR5L, Bit 2 = Timer5 Period Register Low Byte. PR5L, Bit 1 = Timer5 Period Register Low Byte. PR5L, Bit 0 = Timer5 Period Register Low Byte. PR5L, Value on POR, BOR = 1111. PR5L, Value on POR, BOR = 1111. LATE (4), Bit 7 = - - - - - LATE Data Output Register. LATE (4), Bit 6 = - - - - - LATE Data Output Register. LATE (4), Bit 5 = - - -",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\n- - LATE Data Output Register. LATE (4), Bit 4 = - - - - - LATE Data Output Register. LATE (4), Bit 3 = - - - - - LATE Data Output Register. LATE (4), Bit 2 = - - - - - LATE Data Output Register. LATE (4), Bit 1 = - - - - - LATE Data Output Register. LATE (4), Bit 0 = - - - - - LATE Data Output Register. LATE (4), Value on POR, BOR = ----. LATE (4), Value on POR, BOR = -xxx. LATD (4), Bit 7 = LATD Data Output Register Data Output Register. LATD (4), Bit 6 = LATD Data Output Register Data Output Register. LATD (4), Bit 5 = LATD Data Output Register Data Output Register. LATD (4), Bit 4 = LATD Data Output Register Data Output Register. LATD (4), Bit 3 = LATD Data Output Register Data Output",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nRegister. LATD (4), Bit 2 = LATD Data Output Register Data Output Register. LATD (4), Bit 1 = LATD Data Output Register Data Output Register. LATD (4), Bit 0 = LATD Data Output Register Data Output Register. LATD (4), Value on POR, BOR = xxxx. LATD (4), Value on POR, BOR = xxxx. LATC, Bit 7 = LATC. LATC, Bit 6 = LATC. LATC, Bit 5 = LATC. LATC, Bit 4 = LATC. LATC, Bit 3 = LATC. LATC, Bit 2 = LATC. LATC, Bit 1 = LATC. LATC, Bit 0 = LATC. LATC, Value on POR, BOR = xxxx. LATC, Value on POR, BOR = xxxx. LATB, Bit 7 = LATB Data Output Register. LATB, Bit 6 = LATB Data Output Register. LATB, Bit 5 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nLATB Data Output Register. LATB, Bit 4 = LATB Data Output Register. LATB, Bit 3 = LATB Data Output Register. LATB, Bit 2 = LATB Data Output Register. LATB, Bit 1 = LATB Data Output Register. LATB, Bit 0 = LATB Data Output Register. LATB, Value on POR, BOR = xxxx. LATB, Value on POR, BOR = xxxx. LATA, Bit 7 = LATA7 (2). LATA, Bit 6 = LATA6 (1). LATA, Bit 5 = LATA Data Output Register. LATA, Bit 4 = LATA Data Output Register. LATA, Bit 3 = LATA Data Output Register. LATA, Bit 2 = LATA Data Output Register. LATA, Bit 1 = LATA Data Output Register. LATA, Bit 0 = LATA Data Output Register. LATA, Value on POR, BOR = xxxx. LATA, Value on POR, BOR = xxxx.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nTMR5H, Bit 7 = Timer5 Register High Byte. TMR5H, Bit 6 = Timer5 Register High Byte. TMR5H, Bit 5 = Timer5 Register High Byte. TMR5H, Bit 4 = Timer5 Register High Byte. TMR5H, Bit 3 = Timer5 Register High Byte. TMR5H, Bit 2 = Timer5 Register High Byte. TMR5H, Bit 1 = Timer5 Register High Byte. TMR5H, Bit 0 = Timer5 Register High Byte. TMR5H, Value on POR, BOR = xxxx. TMR5H, Value on POR, BOR = xxxx. TMR5L, Bit 7 = Timer5 Register Low Byte. TMR5L, Bit 6 = Timer5 Register Low Byte. TMR5L, Bit 5 = Timer5 Register Low Byte. TMR5L, Bit 4 = Timer5 Register Low Byte. TMR5L, Bit 3 = Timer5 Register Low Byte.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nTMR5L, Bit 2 = Timer5 Register Low Byte. TMR5L, Bit 1 = Timer5 Register Low Byte. TMR5L, Bit 0 = Timer5 Register Low Byte. TMR5L, Value on POR, BOR = xxxx. TMR5L, Value on POR, BOR = xxxx. PORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = RE3 (4,5). PORTE, Bit 2 = RE2 (4). PORTE, Bit 1 = RE1 (4). PORTE, Bit 0 = RE0 (4). PORTE, Value on POR, BOR = ----. PORTE, Value on POR, BOR = xxxx. PORTD (4), Bit 7 = RD7. PORTD (4), Bit 6 = RD6. PORTD (4), Bit 5 = RD5. PORTD (4), Bit 4 = RD4. PORTD",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\n(4), Bit 3 = RD3. PORTD (4), Bit 2 = RD2. PORTD (4), Bit 1 = RD1. PORTD (4), Bit 0 = RD0. PORTD (4), Value on POR, BOR = xxxx. PORTD (4), Value on POR, BOR = xxxx. PORTC, Bit 7 = RC7. PORTC, Bit 6 = RC6. PORTC, Bit 5 = RC5. PORTC, Bit 4 = RC4. PORTC, Bit 3 = RC3. PORTC, Bit 2 = RC2. PORTC, Bit 1 = RC1. PORTC, Bit 0 = RC0. PORTC, Value on POR, BOR = xxxx. PORTC, Value on POR, BOR = xxxx. PORTB, Bit 7 = RB7. PORTB, Bit 6 = RB6. PORTB, Bit 5 = RB5. PORTB, Bit 4 = RB4. PORTB, Bit 3 = RB3. PORTB, Bit 2 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nRB2. PORTB, Bit 1 = RB1. PORTB, Bit 0 = RB0. PORTB, Value on POR, BOR = xxxx. PORTB, Value on POR, BOR = xxxx. PORTA, Bit 7 = RA7 (2). PORTA, Bit 6 = RA6 (1). PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR = xx0x. PORTA, Value on POR, BOR = 0000. PTCON0, Bit 7 = PTOPS3. PTCON0, Bit 6 = PTOPS2. PTCON0, Bit 5 = PTOPS1. PTCON0, Bit 4 = PTOPS0. PTCON0, Bit 3 = PTCKPS1. PTCON0, Bit 2 = PTCKPS0. PTCON0, Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nPTMOD1. PTCON0, Bit 0 = PTMOD0. PTCON0, Value on POR, BOR = 0000. PTCON0, Value on POR, BOR = 0000. PTCON1 PTMRL, Bit 7 = PTEN PTDIR - - - - - - PWM Time Base Register (lower 8 bits). PTCON1 PTMRL, Bit 6 = PTEN PTDIR - - - - - - PWM Time Base Register (lower 8 bits). PTCON1 PTMRL, Bit 5 = PTEN PTDIR - - - - - - PWM Time Base Register (lower 8 bits). PTCON1 PTMRL, Bit 4 = PTEN PTDIR - - - - - - PWM Time Base Register (lower 8 bits). PTCON1 PTMRL, Bit 3 = PTEN PTDIR - - - - - - PWM Time Base Register (lower 8 bits). PTCON1 PTMRL, Bit 2 = PTEN PTDIR - - - -",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\n- - PWM Time Base Register (lower 8 bits). PTCON1 PTMRL, Bit 1 = PTEN PTDIR - - - - - - PWM Time Base Register (lower 8 bits). PTCON1 PTMRL, Bit 0 = PTEN PTDIR - - - - - - PWM Time Base Register (lower 8 bits). PTCON1 PTMRL, Value on POR, BOR = 00-- 0000. PTCON1 PTMRL, Value on POR, BOR = ---- 0000. PTMRH, Bit 7 = UNUSED PWM Time Base Register (upper 4 bits). PTMRH, Bit 6 = UNUSED PWM Time Base Register (upper 4 bits). PTMRH, Bit 5 = UNUSED PWM Time Base Register (upper 4 bits). PTMRH, Bit 4 = UNUSED PWM Time Base Register (upper 4 bits). PTMRH, Bit 3 = UNUSED PWM Time Base Register (upper 4 bits). PTMRH, Bit 2 = UNUSED",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nPWM Time Base Register (upper 4 bits). PTMRH, Bit 1 = UNUSED PWM Time Base Register (upper 4 bits). PTMRH, Bit 0 = UNUSED PWM Time Base Register (upper 4 bits). PTMRH, Value on POR, BOR = ----. PTMRH, Value on POR, BOR = 0000. PTPERL, Bit 7 = PWM Time Base Period Register (lower 8 bits). PTPERL, Bit 6 = PWM Time Base Period Register (lower 8 bits). PTPERL, Bit 5 = PWM Time Base Period Register (lower 8 bits). PTPERL, Bit 4 = PWM Time Base Period Register (lower 8 bits). PTPERL, Bit 3 = PWM Time Base Period Register (lower 8 bits). PTPERL, Bit 2 = PWM Time Base Period Register (lower 8 bits). PTPERL, Bit 1 = PWM Time Base Period Register (lower 8 bits). PTPERL, Bit 0 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nPWM Time Base Period Register (lower 8 bits). PTPERL, Value on POR, BOR = 1111. PTPERL, Value on POR, BOR = 1111. PTPERH, Bit 7 = UNUSED PWM Time Base Period Register (upper 4 bits). PTPERH, Bit 6 = UNUSED PWM Time Base Period Register (upper 4 bits). PTPERH, Bit 5 = UNUSED PWM Time Base Period Register (upper 4 bits). PTPERH, Bit 4 = UNUSED PWM Time Base Period Register (upper 4 bits). PTPERH, Bit 3 = UNUSED PWM Time Base Period Register (upper 4 bits). PTPERH, Bit 2 = UNUSED PWM Time Base Period Register (upper 4 bits). PTPERH, Bit 1 = UNUSED PWM Time Base Period Register (upper 4 bits). PTPERH, Bit 0 = UNUSED PWM Time Base Period Register (upper 4 bits). PTPERH, Value on POR, BOR = ----. PTPERH,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nValue on POR, BOR = 1111\n= unknown, = unchanged, = unimplemented, = value depends on condition. Shaded cells are unimplemented.\nLegend: x u -q",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nNote 1: RA6 and associated bits are configured as port pins in RCIO, ECIO and INTIO2 (with port function on RA6) Oscillator modes only and read ' 0 ' in all other oscillator modes.\n2: RA7 and associated bits are configured as port pins in INTIO2 Oscillator mode only and read ' 0 ' in all other modes.\n3: Bit 21 of the PC is only available in Test mode and Serial Programming modes.\n4: These registers and/or bits are not implemented on the PIC18F2331/2431 devices and read as ' 0 '.\n5: The RE3 port bit is only available for PIC18F4331/4431 devices when the MCLRE fuse (CONFIG3H<7>) is programmed to ' 0 '; otherwise, RE3 reads ' 0 '. This bit is read-only.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nPDC0L, Bit 7 = PWM Duty Cycle #0L Register (lower 8 bits). PDC0L, Bit 6 = PWM Duty Cycle #0L Register (lower 8 bits). PDC0L, Bit 5 = PWM Duty Cycle #0L Register (lower 8 bits). PDC0L, Bit 4 = PWM Duty Cycle #0L Register (lower 8 bits). PDC0L, Bit 3 = PWM Duty Cycle #0L Register (lower 8 bits). PDC0L, Bit 2 = PWM Duty Cycle #0L Register (lower 8 bits). PDC0L, Bit 1 = PWM Duty Cycle #0L Register (lower 8 bits). PDC0L, Bit 0 = PWM Duty Cycle #0L Register (lower 8 bits). PDC0L, Value on POR, BOR = 0000 0000. PDC0H, Bit 7 = UNUSED. PDC0H, Bit 6 = UNUSED. PDC0H, Bit 5 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nPWM Duty Cycle #0H Register (upper 6 bits). PDC0H, Bit 4 = PWM Duty Cycle #0H Register (upper 6 bits). PDC0H, Bit 3 = PWM Duty Cycle #0H Register (upper 6 bits). PDC0H, Bit 2 = PWM Duty Cycle #0H Register (upper 6 bits). PDC0H, Bit 1 = PWM Duty Cycle #0H Register (upper 6 bits). PDC0H, Bit 0 = PWM Duty Cycle #0H Register (upper 6 bits). PDC0H, Value on POR, BOR = --00 0000. PDC1L, Bit 7 = PWM Duty Cycle #1L Register (lower 8 bits). PDC1L, Bit 6 = PWM Duty Cycle #1L Register (lower 8 bits). PDC1L, Bit 5 = PWM Duty Cycle #1L Register (lower 8 bits). PDC1L, Bit 4 = PWM Duty",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nCycle #1L Register (lower 8 bits). PDC1L, Bit 3 = PWM Duty Cycle #1L Register (lower 8 bits). PDC1L, Bit 2 = PWM Duty Cycle #1L Register (lower 8 bits). PDC1L, Bit 1 = PWM Duty Cycle #1L Register (lower 8 bits). PDC1L, Bit 0 = PWM Duty Cycle #1L Register (lower 8 bits). PDC1L, Value on POR, BOR = 0000 0000. PDC1H, Bit 7 = UNUSED. PDC1H, Bit 6 = UNUSED. PDC1H, Bit 5 = PWM Duty Cycle #1H Register (upper 6 bits). PDC1H, Bit 4 = PWM Duty Cycle #1H Register (upper 6 bits). PDC1H, Bit 3 = PWM Duty Cycle #1H Register (upper 6 bits). PDC1H, Bit 2 = PWM Duty Cycle #1H Register (upper 6",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nbits). PDC1H, Bit 1 = PWM Duty Cycle #1H Register (upper 6 bits). PDC1H, Bit 0 = PWM Duty Cycle #1H Register (upper 6 bits). PDC1H, Value on POR, BOR = --00 0000. PDC2L, Bit 7 = PWM Duty Cycle #2L Register (lower 8 bits). PDC2L, Bit 6 = PWM Duty Cycle #2L Register (lower 8 bits). PDC2L, Bit 5 = PWM Duty Cycle #2L Register (lower 8 bits). PDC2L, Bit 4 = PWM Duty Cycle #2L Register (lower 8 bits). PDC2L, Bit 3 = PWM Duty Cycle #2L Register (lower 8 bits). PDC2L, Bit 2 = PWM Duty Cycle #2L Register (lower 8 bits). PDC2L, Bit 1 = PWM Duty Cycle #2L Register (lower 8 bits).",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nPDC2L, Bit 0 = PWM Duty Cycle #2L Register (lower 8 bits). PDC2L, Value on POR, BOR = 0000 0000. PDC2H, Bit 7 = UNUSED. PDC2H, Bit 6 = UNUSED. PDC2H, Bit 5 = PWM Duty Cycle #2H Register (upper 6 bits). PDC2H, Bit 4 = PWM Duty Cycle #2H Register (upper 6 bits). PDC2H, Bit 3 = PWM Duty Cycle #2H Register (upper 6 bits). PDC2H, Bit 2 = PWM Duty Cycle #2H Register (upper 6 bits). PDC2H, Bit 1 = PWM Duty Cycle #2H Register (upper 6 bits). PDC2H, Bit 0 = PWM Duty Cycle #2H Register (upper 6 bits). PDC2H, Value on POR, BOR = --00 0000. PDC3L (4), Bit 7 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nPWM Duty Cycle #3L Register (lower 8 bits). PDC3L (4), Bit 6 = PWM Duty Cycle #3L Register (lower 8 bits). PDC3L (4), Bit 5 = PWM Duty Cycle #3L Register (lower 8 bits). PDC3L (4), Bit 4 = PWM Duty Cycle #3L Register (lower 8 bits). PDC3L (4), Bit 3 = PWM Duty Cycle #3L Register (lower 8 bits). PDC3L (4), Bit 2 = PWM Duty Cycle #3L Register (lower 8 bits). PDC3L (4), Bit 1 = PWM Duty Cycle #3L Register (lower 8 bits). PDC3L (4), Bit 0 = PWM Duty Cycle #3L Register (lower 8 bits). PDC3L (4), Value on POR, BOR = 0000 0000. PDC3H (4), Bit 7 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nUNUSED. PDC3H (4), Bit 6 = UNUSED. PDC3H (4), Bit 5 = PWM Duty Cycle #3H Register (upper 6 bits). PDC3H (4), Bit 4 = PWM Duty Cycle #3H Register (upper 6 bits). PDC3H (4), Bit 3 = PWM Duty Cycle #3H Register (upper 6 bits). PDC3H (4), Bit 2 = PWM Duty Cycle #3H Register (upper 6 bits). PDC3H (4), Bit 1 = PWM Duty Cycle #3H Register (upper 6 bits). PDC3H (4), Bit 0 = PWM Duty Cycle #3H Register (upper 6 bits). PDC3H (4), Value on POR, BOR = --00 0000. SEVTCMPL, Bit 7 = PWM Special Event Compare Register (lower 8 bits). SEVTCMPL, Bit 6 = PWM Special Event Compare",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nRegister (lower 8 bits). SEVTCMPL, Bit 5 = PWM Special Event Compare Register (lower 8 bits). SEVTCMPL, Bit 4 = PWM Special Event Compare Register (lower 8 bits). SEVTCMPL, Bit 3 = PWM Special Event Compare Register (lower 8 bits). SEVTCMPL, Bit 2 = PWM Special Event Compare Register (lower 8 bits). SEVTCMPL, Bit 1 = PWM Special Event Compare Register (lower 8 bits). SEVTCMPL, Bit 0 = PWM Special Event Compare Register (lower 8 bits). SEVTCMPL, Value on POR, BOR = 0000 0000. SEVTCMPH, Bit 7 = UNUSED. SEVTCMPH, Bit 6 = UNUSED. SEVTCMPH, Bit 5 = UNUSED. SEVTCMPH, Bit 4 = UNUSED. SEVTCMPH, Bit 3 = PWM Special Event Compare Register (upper 4 bits). SEVTCMPH,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nBit 2 = PWM Special Event Compare Register (upper 4 bits). SEVTCMPH, Bit 1 = PWM Special Event Compare Register (upper 4 bits). SEVTCMPH, Bit 0 = PWM Special Event Compare Register (upper 4 bits). SEVTCMPH, Value on POR, BOR = ---- 0000. PWMCON0, Bit 7 = -. PWMCON0, Bit 6 = PWMEN2. PWMCON0, Bit 5 = PWMEN1. PWMCON0, Bit 4 = PWMEN0. PWMCON0, Bit 3 = PMOD3. PWMCON0, Bit 2 = PMOD2. PWMCON0, Bit 1 = PMOD1. PWMCON0, Bit 0 = PMOD0. PWMCON0, Value on POR, BOR = -111 0000. PWMCON1, Bit 7 = SEVOPS3. PWMCON1, Bit 6 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nSEVOPS2. PWMCON1, Bit 5 = SEVOPS1. PWMCON1, Bit 4 = SEVOPS0. PWMCON1, Bit 3 = SEVTDIR. PWMCON1, Bit 2 = -. PWMCON1, Bit 1 = UDIS. PWMCON1, Bit 0 = OSYNC. PWMCON1, Value on POR, BOR = 0000 0-00. DTCON, Bit 7 = DTPS1. DTCON, Bit 6 = DTPS0. DTCON, Bit 5 = DT5. DTCON, Bit 4 = DT4. DTCON, Bit 3 = DT3. DTCON, Bit 2 = DT2. DTCON, Bit 1 = DT1. DTCON, Bit 0 = DT0. DTCON, Value on POR, BOR = 0000 0000. FLTCONFIG, Bit 7 = BRFEN. FLTCONFIG, Bit 6 = FLTBS (4). FLTCONFIG, Bit 5 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nFLTBMOD (4). FLTCONFIG, Bit 4 = FLTBEN (4). FLTCONFIG, Bit 3 = FLTCON. FLTCONFIG, Bit 2 = FLTAS. FLTCONFIG, Bit 1 = FLTAMOD. FLTCONFIG, Bit 0 = FLTAEN. FLTCONFIG, Value on POR, BOR = 0000 0000. OVDCOND, Bit 7 = POVD7 (4). OVDCOND, Bit 6 = POVD6 (4). OVDCOND, Bit 5 = POVD5. OVDCOND, Bit 4 = POVD4. OVDCOND, Bit 3 = POVD3. OVDCOND, Bit 2 = POVD2. OVDCOND, Bit 1 = POVD1. OVDCOND, Bit 0 = POVD0. OVDCOND, Value on POR, BOR = 1111 1111. OVDCONS, Bit 7 = POUT7 (4).",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nOVDCONS, Bit 6 = POUT6 (4). OVDCONS, Bit 5 = POUT5. OVDCONS, Bit 4 = POUT4. OVDCONS, Bit 3 = POUT3. OVDCONS, Bit 2 = POUT2. OVDCONS, Bit 1 = POUT1. OVDCONS, Bit 0 = POUT0. OVDCONS, Value on POR, BOR = 0000 0000. CAP1BUFH/ VELRH, Bit 7 = Capture 1 Register High Byte/Velocity Register High Byte. CAP1BUFH/ VELRH, Bit 6 = Capture 1 Register High Byte/Velocity Register High Byte. CAP1BUFH/ VELRH, Bit 5 = Capture 1 Register High Byte/Velocity Register High Byte. CAP1BUFH/ VELRH, Bit 4 = Capture 1 Register High Byte/Velocity Register High Byte. CAP1BUFH/ VELRH, Bit 3 = Capture 1 Register High Byte/Velocity Register High Byte.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nCAP1BUFH/ VELRH, Bit 2 = Capture 1 Register High Byte/Velocity Register High Byte. CAP1BUFH/ VELRH, Bit 1 = Capture 1 Register High Byte/Velocity Register High Byte. CAP1BUFH/ VELRH, Bit 0 = Capture 1 Register High Byte/Velocity Register High Byte. CAP1BUFH/ VELRH, Value on POR, BOR = xxxx xxxx. CAP1BUFL/ VELRL, Bit 7 = Capture 1 Register Low Byte/Velocity Register Low Byte. CAP1BUFL/ VELRL, Bit 6 = Capture 1 Register Low Byte/Velocity Register Low Byte. CAP1BUFL/ VELRL, Bit 5 = Capture 1 Register Low Byte/Velocity Register Low Byte. CAP1BUFL/ VELRL, Bit 4 = Capture 1 Register Low Byte/Velocity Register Low Byte. CAP1BUFL/ VELRL, Bit 3 = Capture 1 Register Low Byte/Velocity Register Low Byte. CAP1BUFL/ VELRL, Bit 2 = Capture 1 Register Low Byte/Velocity Register",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nLow Byte. CAP1BUFL/ VELRL, Bit 1 = Capture 1 Register Low Byte/Velocity Register Low Byte. CAP1BUFL/ VELRL, Bit 0 = Capture 1 Register Low Byte/Velocity Register Low Byte. CAP1BUFL/ VELRL, Value on POR, BOR = xxxx xxxx. CAP2BUFH/ POSCNTH, Bit 7 = Capture 2 Register High Byte/QEI Position Counter Register High Byte. CAP2BUFH/ POSCNTH, Bit 6 = Capture 2 Register High Byte/QEI Position Counter Register High Byte. CAP2BUFH/ POSCNTH, Bit 5 = Capture 2 Register High Byte/QEI Position Counter Register High Byte. CAP2BUFH/ POSCNTH, Bit 4 = Capture 2 Register High Byte/QEI Position Counter Register High Byte. CAP2BUFH/ POSCNTH, Bit 3 = Capture 2 Register High Byte/QEI Position Counter Register High Byte. CAP2BUFH/ POSCNTH, Bit 2 = Capture 2 Register High",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nByte/QEI Position Counter Register High Byte. CAP2BUFH/ POSCNTH, Bit 1 = Capture 2 Register High Byte/QEI Position Counter Register High Byte. CAP2BUFH/ POSCNTH, Bit 0 = Capture 2 Register High Byte/QEI Position Counter Register High Byte. CAP2BUFH/ POSCNTH, Value on POR, BOR = xxxx xxxx. CAP2BUFL/ POSCNTL, Bit 7 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte. CAP2BUFL/ POSCNTL, Bit 6 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte. CAP2BUFL/ POSCNTL, Bit 5 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte. CAP2BUFL/ POSCNTL, Bit 4 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte. CAP2BUFL/ POSCNTL, Bit 3 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte. CAP2BUFL/",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nPOSCNTL, Bit 2 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte. CAP2BUFL/ POSCNTL, Bit 1 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte. CAP2BUFL/ POSCNTL, Bit 0 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte. CAP2BUFL/ POSCNTL, Value on POR, BOR = xxxx xxxx. CAP3BUFH/ MAXCNTH, Bit 7 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte. CAP3BUFH/ MAXCNTH, Bit 6 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte. CAP3BUFH/ MAXCNTH, Bit 5 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte. CAP3BUFH/ MAXCNTH, Bit 4 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte. CAP3BUFH/ MAXCNTH,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nBit 3 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte. CAP3BUFH/ MAXCNTH, Bit 2 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte. CAP3BUFH/ MAXCNTH, Bit 1 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte. CAP3BUFH/ MAXCNTH, Bit 0 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte. CAP3BUFH/ MAXCNTH, Value on POR, BOR = xxxx xxxx. CAP3BUFL/ MAXCNTL, Bit 7 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte. CAP3BUFL/ MAXCNTL, Bit 6 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte. CAP3BUFL/ MAXCNTL, Bit 5 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte. CAP3BUFL/ MAXCNTL,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nBit 4 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte. CAP3BUFL/ MAXCNTL, Bit 3 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte. CAP3BUFL/ MAXCNTL, Bit 2 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte. CAP3BUFL/ MAXCNTL, Bit 1 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte. CAP3BUFL/ MAXCNTL, Bit 0 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte. CAP3BUFL/ MAXCNTL, Value on POR, BOR = xxxx xxxx. CAP1CON, Bit 7 = -. CAP1CON, Bit 6 = CAP1REN. CAP1CON, Bit 5 = -. CAP1CON, Bit 4 = -. CAP1CON, Bit 3 = CAP1M3. CAP1CON, Bit 2 = CAP1M2. CAP1CON, Bit 1 =",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nCAP1M1. CAP1CON, Bit 0 = CAP1M0. CAP1CON, Value on POR, BOR = -0-- 0000. CAP2CON, Bit 7 = -. CAP2CON, Bit 6 = CAP2REN. CAP2CON, Bit 5 = -. CAP2CON, Bit 4 = -. CAP2CON, Bit 3 = CAP2M3. CAP2CON, Bit 2 = CAP2M2. CAP2CON, Bit 1 = CAP2M1. CAP2CON, Bit 0 = CAP2M0. CAP2CON, Value on POR, BOR = -0-- 0000. CAP3CON, Bit 7 = -. CAP3CON, Bit 6 = CAP3REN. CAP3CON, Bit 5 = -. CAP3CON, Bit 4 = -. CAP3CON, Bit 3 = CAP3M3. CAP3CON, Bit 2 = CAP3M2. CAP3CON, Bit 1 = CAP3M1. CAP3CON, Bit 0 = CAP3M0. CAP3CON,",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nValue on POR, BOR = -0-- 0000. DFLTCON, Bit 7 = -. DFLTCON, Bit 6 = FLT4EN. DFLTCON, Bit 5 = FLT3EN. DFLTCON, Bit 4 = FLT2EN. DFLTCON, Bit 3 = FLT1EN. DFLTCON, Bit 2 = FLTCK2. DFLTCON, Bit 1 = FLTCK1. DFLTCON, Bit 0 = FLTCK0. DFLTCON, Value on POR, BOR = -000 0000\nLegend: x = unknown, u = unchanged, -= unimplemented, q = value depends on condition. Shaded cells are unimplemented.",
    "TABLE 6-2: REGISTER FILE SUMMARY (PIC18F2331/2431/4331/4431) (CONTINUED)\nNote 1: RA6 and associated bits are configured as port pins in RCIO, ECIO and INTIO2 (with port function on RA6) Oscillator modes only and read ' 0 ' in all other oscillator modes.\n2: RA7 and associated bits are configured as port pins in INTIO2 Oscillator mode only and read ' 0 ' in all other modes.\n3: Bit 21 of the PC is only available in Test mode and Serial Programming modes.\n4: These registers and/or bits are not implemented on the PIC18F2331/2431 devices and read as ' 0 '.\n5: The RE3 port bit is only available for PIC18F4331/4431 devices when the MCLRE fuse (CONFIG3H<7>) is programmed to ' 0 '; otherwise, RE3 reads ' 0 '. This bit is read-only.",
    "6.6 STATUS Register\nThe STATUS register, shown in Register 6-2, contains the arithmetic status of the ALU. The STATUS register can  be  the  operand  for  any  instruction,  as  with  any other register. If the STATUS register is the destination for an instruction that affects the Z, DC, C, OV or N bits, then the write to these five bits is disabled. These bits are set or cleared according to the device logic. Therefore,  the  result  of  an  instruction  with  the  STATUS register as destination may be different than intended.\nFor example, CLRF STATUS will clear the upper three bits and set the Z bit. This leaves the STATUS register as 000u u1uu (where u = unchanged).",
    "REGISTER 6-2: STATUS REGISTER\n-, U-0 = -. -, U-0 = -. -, R/W-x = N. -, R/W-x = OV. -, R/W-x = Z. -, R/W-x = DC (1). -, R/W-x = C (2). bit 7, U-0 = . bit 7, U-0 = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = bit 0",
    "REGISTER 6-2: STATUS REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 4 N: Negative bit\nThis bit is used for signed arithmetic (2's complement). It indicates whether the result was negative (ALU MSB = 1 ).\n1 = Result was negative\n0 = Result was positive",
    "bit 3 OV: Overflow bit\nThis bit is used for signed arithmetic (2's complement). It indicates an overflow of the 7-bit magnitude which causes the sign bit (bit 7) to change state.\n1 = Overflow occurred for signed arithmetic (in this arithmetic operation)\n0 = No overflow occurred",
    "bit 2 Z: Zero bit\n1 = The result of an arithmetic or logic operation is zero\n0 = The result of an arithmetic or logic operation is not zero\nDC:\nDigit Carry/Borrow bit\n(1)\nFor ADDWF, ADDLW, SUBLW and SUBWF instructions:\n1 = A carry-out from the 4th low-order bit of the result occurred\n0 = No carry-out from the 4th low-order bit of the result",
    "bit 0 C: Carry/Borrow bit (2)\nFor ADDWF, ADDLW, SUBLW and SUBWF instructions:\n1 = A carry-out from the Most Significant bit of the result occurred\n0 = No carry-out from the Most Significant bit of the result occurred\nNote 1: For Borrow, the polarity is reversed. A subtraction is executed by adding the 2's complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either bit 4 or bit 3 of the source register.\n2: For Borrow, the polarity is reversed. A subtraction is executed by adding the 2's complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either the high or low-order bit of the source register.\nIt  is  recommended,  therefore,  that  only BCF, BSF, SWAPF, MOVFF and MOVWF instructions  are  used  to alter the STATUS register, because these instructions do not affect the Z, C, DC, OV or N bits in the STATUS register. For other instructions not affecting any Status bits, see Table 24-2.\nNote:",
    "bit 0 C: Carry/Borrow bit (2)\nThe C and DC bits operate as a Borrow and Digit Borrow bit respectively, in subtraction.\nbit 1",
    "6.7 Data Addressing Modes\nThe data memory space can be addressed in several ways. For most instructions, the addressing mode is fixed. Other instructions may use up to three modes, depending on which operands are used and whether or not the extended instruction set is enabled.\nA few instructions, such as MOVFF ,  include the entire 12-bit address (either source or destination) in their op codes. In these cases, the BSR is ignored entirely.\nThe addressing modes are:\n\u00b7 Inherent\n\u00b7 Literal\n\u00b7 Direct\n\u00b7 Indirect",
    "6.7.1 INHERENT AND LITERAL ADDRESSING\nMany  PIC18  control  instructions  do  not  need  any argument at all. They either perform an operation that globally affects the device or they operate implicitly on one register. This addressing mode is known as Inherent Addressing. Examples include SLEEP RESET , and DAW .\nOther instructions work in a similar way but require an additional  explicit  argument  in  the  opcode.  This  is known  as  Literal  Addressing  mode  because  they require some literal value as an argument. Examples include ADDLW and MOVLW , which respectively, add or move a literal value to the W register. Other examples include CALL and GOTO , which include a 20-bit program memory address.",
    "6.7.2 DIRECT ADDRESSING\nDirect  Addressing  specifies  all  or  part  of  the  source and/or destination address of the operation within the opcode itself. The options are specified by the arguments accompanying the instruction.\nIn the core PIC18 instruction set, bit-oriented and byteoriented instructions use some  version of Direct Addressing by default. All of these instructions include some  8-bit  literal  address  as  their  Least  Significant Byte. This address specifies either a register address in one of the banks of data RAM ( Section 6.5.4 'Special Function Registers' ) or a location in the Access Bank ( Section 6.5.2 'Access Bank' ) as the data source for the instruction.\nThe Access RAM bit, 'a', determines how the address is interpreted. When 'a' is ' 1 ', the contents of the BSR ( Section 6.5.1  'Bank  Select  Register  (BSR)' )  are used with the address to determine the complete 12-bit address of the register. When 'a' is ' 0 ', the address is interpreted  as  being  a  register  in  the  Access  Bank. Addressing that uses the Access RAM is sometimes also known as Direct Forced Addressing mode.",
    "6.7.2 DIRECT ADDRESSING\nThe destination of the operation's results is determined by the destination bit, 'd'. When 'd' is ' 1 ', the results are stored back in the source register, overwriting its original contents. When 'd' is ' 0 ',  the results are stored in the  W  register.  Instructions  without  the  'd'  argument have a destination that is implicit in the instruction; their destination is either the target register being operated on or the W register.",
    "6.7.3 INDIRECT ADDRESSING\nIndirect Addressing allows the user to access a location in  data memory without giving a fixed address in the instruction. This is done by using File Select Registers (FSRs) as pointers to the locations to be read or written to. Since the FSRs are themselves located in RAM as Special Function Registers, they can also be directly manipulated under program control. This makes FSRs very  useful  in  implementing  data  structures,  such  as tables and arrays in data memory.\nThe registers for Indirect Addressing are also implemented with Indirect File Operands (INDFs) that permit automatic manipulation of the pointer value with auto-incrementing, auto-decrementing or offsetting with another value. This allows for efficient code, using loops, such as the example of clearing an entire RAM bank in Example 6-5.",
    "HOW TO CLEAR RAM (BANK 1) USING INDIRECT ADDRESSING\nNEXT, 1 = LFSR CLRF. NEXT, 2 = FSR0, 100h POSTINC0. NEXT, 3 = ; ; Clear INDF ; register then ; inc pointer. , 1 = BTFSS. , 2 = FSR0H, 1. , 3 = ; All done with ; Bank1?. CONTINUE, 1 = BRA. CONTINUE, 2 = NEXT. CONTINUE, 3 = ; NO, clear next ; YES, continue",
    "6.7.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nAt  the  core  of  Indirect  Addressing  are  three  sets  of registers: FSR0, FSR1 and FSR2. Each represents a pair  of  8-bit  registers,  FSRnH  and  FSRnL.  The  four upper bits of the FSRnH register are not used so each FSR pair holds a 12-bit value. This represents a value that can address the entire range of the data memory in a linear fashion. The FSR register pairs, then, serve as pointers to data memory locations.",
    "6.7.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nIndirect  Addressing  is  accomplished  with  a  set  of Indirect File Operands: INDF0 through INDF2. These can  be  thought  of  as  'virtual'  registers;  they  are mapped in the SFR space but are not physically implemented. Reading or writing to a particular INDF register actually accesses its corresponding FSR register pair. A read from INDF1, for example, reads the data at the address indicated by FSR1H:FSR1L. Instructions that use the INDF registers as operands actually use the contents of their corresponding FSR as a pointer to the instruction's target. The  INDF  operand  is just a convenient way of using the pointer.\nBecause Indirect Addressing uses a full 12-bit address, data RAM banking is not necessary. Thus, the current contents of the BSR and the Access RAM bit have no effect on determining the target address.",
    "6.7.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nIn addition to the INDF operand, each FSR register pair also has four additional indirect operands. Like INDF, these  are  'virtual'  registers  that  cannot  be  indirectly read or written to. Accessing these registers actually accesses  the  associated  FSR  register  pair,  but  also performs a specific action on its stored value. They are:\n\u00b7 POSTDEC: accesses the FSR value, then automatically decrements it by 1 afterwards\n\u00b7 POSTINC: accesses the FSR value, then automatically increments it by 1 afterwards\n\u00b7 PREINC: increments the FSR value by 1, then uses it in the operation\n\u00b7 PLUSW: adds the signed value of the W register (range of -127 to 128) to that of the FSR and uses the new value in the operation.",
    "6.7.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nIn  this  context,  accessing  an  INDF  register  uses  the value in the FSR registers without changing them. Similarly, accessing a PLUSW register gives the FSR value offset by that in the W register; neither value is actually changed in the operation. Accessing the other virtual registers changes the value of the FSR registers.\nOperations  on  the  FSRs  with  POSTDEC,  POSTINC and PREINC affect the entire register pair; that is, rollovers of the FSRnL register from FFh to 00h carry over to  the  FSRnH register. On the other hand, results of these operations do not change the value of any flags in the STATUS register (e.g., Z, N, OV, etc.).",
    "PIC18F2331/2431/4331/4431\nThe PLUSW register can be used to implement a form of Indexed Addressing in the data memory space. By manipulating  the  value  in  the  W  register,  users  can reach  addresses  that  are  fixed  offsets  from  pointer addresses. In some applications, this can be used to implement  some  powerful  program  control  structure, such as software stacks, inside of data memory.\nOn the other hand, using the virtual registers to write to an FSR pair may not occur as planned. In these cases, the value will be written to the FSR pair but without any incrementing or decrementing. Thus, writing to INDF2 or POSTDEC2  will  write  the  same  value  to  the FSR2H:FSR2L.",
    "6.7.3.3 Operations by FSRs on FSRs\nIndirect Addressing operations that target other FSRs or virtual registers represent special cases. For example, using an FSR to point to one of the virtual registers will not result in successful operations. As a specific case, assume that FSR0H:FSR0L contain FE7h, the address of INDF1. Attempts to read the value of the INDF1 using INDF0 as an operand will return 00h. Attempts to write to INDF1 using INDF0 as the operand will result in a NOP .\nSince the FSRs are physical registers mapped in the SFR space, they can be manipulated through all direct operations.  Users  should  proceed  cautiously  when working  on  these  registers,  particularly  if  their  code uses Indirect Addressing.\nSimilarly, operations by Indirect Addressing are generally permitted on all other SFRs. Users should exercise the  appropriate  caution  that  they  do  not  inadvertently change settings  that  might  affect  the  operation  of  the device.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "7.2 EECON1 and EECON2 Registers\nThe  data  EEPROM  is  readable  and  writable  during normal operation over the entire VDD range. The data memory  is  not  directly  mapped  in  the  register  file space. Instead, it is  indirectly  addressed through  the Special Function Registers (SFR).\nThere  are  four  SFRs  used  to  read  and  write  the program and data EEPROM memory. These registers are:\n\u00b7 EECON1\n\u00b7 EECON2\n\u00b7 EEDATA\n\u00b7 EEADR\nThe EEPROM data memory allows byte read and write. When interfacing to the data memory block, EEDATA holds the 8-bit data for read/write and EEADR holds the address  of  the  EEPROM  location  being  accessed. These devices have 256 bytes of data EEPROM with an address range from 00h to FFh.",
    "7.2 EECON1 and EECON2 Registers\nThe EEPROM data memory is rated for high  erase/ write cycle  endurance.  A  byte  write  automatically erases  the  location  and  writes  the  new  data  (erasebefore-write). The write time is controlled by an on-chip timer. The  write time will vary with voltage and temperature,  as  well  as  from  chip-to-chip.  Please refer to Parameter D122 (Table 26-1 in Section 26.0 'Electrical Characteristics' ) for exact limits.",
    "7.1 EEADR\nThe Address register can address 256 bytes of data EEPROM.\nAccess  to  the  data  EEPROM  is  controlled  by  two registers: EECON1 and EECON2. These are the same registers which control access to the program memory and  are used  in a similar manner  for the data EEPROM.\nThe  EECON1  register  (Register 7-1)  is  the  control register for data and program memory access. Control bit, EEPGD, determines if the access will be to program or data EEPROM memory. When clear, operations will access the data EEPROM memory. When set, program memory is accessed.\nControl bit, CFGS, determines if the access will be to the Configuration registers or to program memory/data EEPROM memory. When set, subsequent operations access Configuration registers. When CFGS is clear, the  EEPGD bit  selects  either  Flash  program  or  data EEPROM memory.\nThe WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear. The WRERR bit is set in hardware when the WREN bit is set and cleared when the internal programming timer expires and the write operation is complete.\nNote:",
    "7.1 EEADR\nDuring normal operation, the WRERR bit is read as ' 1 '. This can indicate that a write operation was prematurely terminated by a Reset or a write operation was attempted improperly.\nThe WR control bit initiates  write operations. The  bit cannot be cleared, only set, in software; it is cleared in hardware at the completion of the write operation.\nNote:\nThe  EEIF  interrupt  flag  bit  (PIR2<4>)  is set when the write is complete. It must be cleared in software.\nControl  bits,  RD  and  WR,  start  read  and  erase/write operations, respectively. These bits are set by firmware and  cleared  by  hardware  at  the  completion  of  the operation.\nThe  RD  bit  cannot  be  set  when  accessing  program memory (EEPGD = 1 ). Program memory is read using table read instructions. See Section 7.3 'Reading the Data EEPROM Memory' regarding table reads.\nThe EECON2 register is not a physical register. It is used  exclusively  in  the memory  write  and  erase sequences. Reading EECON2 will read all ' 0 's.",
    "REGISTER 7-1: EECON1: EEPROM CONTROL REGISTER 1\nEEPGD, R/W-x = CFGS. EEPGD, U-0 = -. EEPGD, R/W-0 = FREE. EEPGD, R/W-x = WRERR (1). EEPGD, R/W-0 = WREN. EEPGD, R/S-0 = WR. EEPGD, R/S-0 = RD. bit 7 bit 0, R/W-x = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-x = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/S-0 = bit 7 bit 0. bit 7 bit 0, R/S-0 = bit 7 bit 0",
    "REGISTER 7-1: EECON1: EEPROM CONTROL REGISTER 1\nLegend:, 1 = S = Settable bit (cannot be cleared in software). Legend:, 2 = S = Settable bit (cannot be cleared in software). Legend:, 3 = S = Settable bit (cannot be cleared in software). R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 EEPGD: Flash Program or Data EEPROM Memory Select bit\n1 = Access Flash program memory\n0 = Access data EEPROM memory\nCFGS: Flash Program/Data EEPROM or Configuration Select bit\n1 = Access Configuration registers\n0 = Access Flash program or data EEPROM memory",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4\nFREE:\nFlash Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation)\n0 = Perform write only",
    "bit 3 WRERR: Flash Program/Data EEPROM Error Flag bit (1)\n1 = A write operation is prematurely terminated (any Reset during self-timed programming in normal operation, or an improper write attempt)\n0 = The write operation completed",
    "bit 2 WREN: Flash Program/Data EEPROM Write Enable bit\n1 = Allows write cycles to Flash program/data EEPROM\n0 = Inhibits write cycles to Flash program/data EEPROM",
    "bit 1 WR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle (The operation is self-timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle to the EEPROM is complete",
    "bit 0 RD: Read Control bit\n1 = Initiates an EEPROM read (Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared) in software. RD bit cannot be set when EEPGD = 1 or CFGS = 1 .)\n0 = Does not initiate an EEPROM read\nNote 1: When a WRERR occurs, the EEPGD and CFGS bits are not cleared. This allows tracing of the error condition.",
    "7.3 Reading the Data EEPROM Memory\nTo read a data memory location, the user must write the address to the EEADR register, clear the EEPGD control  bit  (EECON1<7>)  and  then  set  control  bit,  RD (EECON1<0>). The data is available for the very next instruction  cycle;  therefore,  the  EEDATA register can be read by the next instruction. EEDATA will hold this value until another read operation, or until it is written to by  the user (during a write operation).The  basic process is shown in Example 7-1.",
    "7.4 Writing to the Data EEPROM Memory\nTo write an EEPROM data location, the address must first be written to the EEADR register and the data written to the EEDATA register. The sequence in Example 7-2 must be followed to initiate the write cycle.\nThe write will not begin if this sequence is not exactly followed (write 55h to EECON2,  write 0AAh  to EECON2, then set WR bit) for each byte. It is strongly recommended that  interrupts  be  disabled  during  this code segment.\nAdditionally, the WREN bit in EECON1 must be set to enable  writes.  This  mechanism  prevents  accidental writes to data EEPROM due to unexpected code execution (i.e., runaway programs). The WREN bit should be kept clear  at  all  times,  except  when  updating  the EEPROM. The WREN bit is not cleared by hardware.\nAfter  a  write  sequence  has  been  initiated,  EECON1, EEADR and EEDATA cannot be modified. The WR bit will be inhibited from being set unless the WREN bit is set. The WREN bit must be set on a previous instruction. Both WR and WREN cannot be set with the same instruction.",
    "7.4 Writing to the Data EEPROM Memory\nAt  the  completion  of  the  write  cycle,  the  WR  bit  is cleared in hardware and the EEPROM Interrupt Flag bit (EEIF) is set. The user may either enable this interrupt or poll this bit. EEIF must be cleared by software.",
    "7.5 Write Verify\nDepending  on  the  application,  good  programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "7.6 Protection Against Spurious Write\nThere are conditions when the device may not want to write to the data EEPROM memory. To protect against spurious EEPROM writes, various mechanisms have been built-in. On power-up, the WREN bit is cleared. Also,  the  Power-up  Timer  (72 ms  duration)  prevents EEPROM write.\nThe write initiate sequence and the WREN bit together help  prevent  an  accidental  write  during  brown-out, power glitch, or software malfunction.",
    "EXAMPLE 7-1: DATA EEPROM READ\nMOVLW, 1 = DATA_EE_ADDR. MOVLW, 2 = ;. MOVWF, 1 = EEADR. MOVWF, 2 = ; Data Memory Address to read. BCF, 1 = EECON1, EEPGD. BCF, 2 = ; Point to DATA memory. BSF, 1 = EECON1, RD. BSF, 2 = ; EEPROM Read. MOVF, 1 = EEDATA, W. MOVF, 2 = ; W = EEDATA",
    "EXAMPLE 7-2: DATA EEPROM WRITE\nRequired Sequence, 1 = MOVLW MOVWF MOVLW MOVWF BCF BCF BSF. Required Sequence, 2 = DATA_EE_ADDR EEADR DATA_EE_DATA EEDATA EECON1, EEPGD EECON1, CFGS EECON1, WREN GIE. Required Sequence, 3 = ; ; Data Memory Address to write Data Memory Value to write Point to DATA memory Access EEPROM Enable writes. Required Sequence, 1 = . Required Sequence, 2 = . Required Sequence, 3 = ;. Required Sequence, 1 = . Required Sequence, 2 = . Required Sequence, 3 = ;. Required Sequence, 1 = . Required Sequence, 2 = . Required Sequence, 3 = ;. Required Sequence, 1 = . Required Sequence, 2 = . Required Sequence, 3 = ;. Required Sequence, 1 = . Required Sequence, 2 = . Required Sequence, 3 = ;. , 1 = BCF. , 2 = INTCON,. , 3 = ; Disable Interrupts. , 1 = MOVLW. , 2 = 55h. , 3 = ;. , 1 = MOVWF. , 2 =",
    "EXAMPLE 7-2: DATA EEPROM WRITE\nEECON2. , 3 = ; Write. , 1 = MOVLW. , 2 = 0AAh. , 3 = ;. , 1 = MOVWF. , 2 = EECON2. , 3 = ; Write 0AAh. , 1 = BSF. , 2 = EECON1, WR. , 3 = ; Set WR bit to begin write. , 1 = BTFSC. , 2 = EECON1, WR. , 3 = ; Wait for write to complete. , 1 = GOTO. , 2 = $-2. , 3 = ;. , 1 = BSF. , 2 = INTCON, GIE. , 3 = ; Enable interrupts",
    "7.9 Using the Data EEPROM\nData EEPROM memory has its own code-protect bits in Configuration  Words.  External  read  and  write  operations  are  disabled  if  either  of  these  mechanisms  are enabled.\nThe microcontroller itself can both read and write to the internal data EEPROM, regardless of the state of the code-protect Configuration bit. Refer to Section 23.0 'Special Features of the CPU' for additional information.",
    "7.8 Protection Against Spurious Write\nThere are conditions when the device may not want to write to the data EEPROM memory. To protect against spurious EEPROM writes, various mechanisms have been  implemented.  On  power-up,  the  WREN  bit  is cleared.  In  addition,  writes  to  the  EEPROM  memory are blocked during the Power-up Timer period (TPWRT, Parameter 33).\nThe data EEPROM  is a high-endurance, byteaddressable  array  that  has  been  optimized  for  the storage of frequently changing information (e.g., program  variables  or  other  data  that  are  updated often).  Frequently  changing  values  will  typically  be updated more often than Specification D124. If this is not the case, an array refresh must be performed. For this reason, variables that change infrequently (such as constants,  IDs,  calibration,  etc.)  should  be  stored  in Flash program memory.\nA  simple  data  EEPROM  refresh  routine  is  shown  in Example 7-3.",
    "Note:\nIf data EEPROM is only used to store con- stants and/or data that changes rarely, an array  refresh  is  likely  not  required.  See Specification D124.\nThe write/initiate sequence, and the WREN  bit together, help prevent an  accidental write during Brown-out Reset, power glitch or software malfunction.",
    "EXAMPLE 7-3: DATA EEPROM REFRESH ROUTINE\nLOOP, CLRF BCF BCF BCF BSF BSF = MOVLW. LOOP, EEADR EECON1, EECON1, INTCON, EECON1, EECON1, = 55h EECON2. LOOP, CFGS EEPGD GIE WREN = RD. LOOP, ; Start at address 0 ; Set for memory Set for Data EEPROM Disable interrupts Enable writes Loop to refresh array Read current address = ; ; ; Write 55h ;. LOOP, CLRF BCF BCF BCF BSF BSF = MOVWF MOVLW. LOOP, EEADR EECON1, EECON1, INTCON, EECON1, EECON1, = 0AAh. LOOP, CFGS EEPGD GIE WREN = WR WR. LOOP, ; Start at address 0 ; Set for memory Set for Data EEPROM Disable interrupts Enable writes Loop to refresh array Read current address = ; ; Set WR bit to begin write complete. LOOP, CLRF BCF BCF BCF BSF BSF = MOVWF. LOOP, EEADR EECON1,",
    "EXAMPLE 7-3: DATA EEPROM REFRESH ROUTINE\nEECON1, INTCON, EECON1, EECON1, = EECON2. LOOP, CFGS EEPGD GIE WREN = . LOOP, ; Start at address 0 ; Set for memory Set for Data EEPROM Disable interrupts Enable writes Loop to refresh array Read current address = ; Wait for write to. LOOP, CLRF BCF BCF BCF BSF BSF = . LOOP, EEADR EECON1, EECON1, INTCON, EECON1, EECON1, = . LOOP, CFGS EEPGD GIE WREN = . LOOP, ; Start at address 0 ; Set for memory Set for Data EEPROM Disable interrupts Enable writes Loop to refresh array Read current address = Write 0AAh. LOOP, CLRF BCF BCF BCF BSF BSF = BSF. LOOP, EEADR EECON1, EECON1, INTCON, EECON1, EECON1, = EECON1,. LOOP, CFGS EEPGD GIE WREN = . LOOP, ; Start at address 0 ; Set for memory Set for Data EEPROM Disable interrupts Enable writes",
    "EXAMPLE 7-3: DATA EEPROM REFRESH ROUTINE\nLoop to refresh array Read current address = . LOOP, CLRF BCF BCF BCF BSF BSF = BTFSC BRA. LOOP, EEADR EECON1, EECON1, INTCON, EECON1, EECON1, = EECON1, $-2. LOOP, CFGS EEPGD GIE WREN = . LOOP, ; Start at address 0 ; Set for memory Set for Data EEPROM Disable interrupts Enable writes Loop to refresh array Read current address = ;. LOOP, CLRF BCF BCF BCF BSF BSF = INCFSZ BRA. LOOP, EEADR EECON1, EECON1, INTCON, EECON1, EECON1, = EEADR, LOOP. LOOP, CFGS EEPGD GIE WREN = F. LOOP, ; Start at address 0 ; Set for memory Set for Data EEPROM Disable interrupts Enable writes Loop to refresh array Read current address = Increment address. LOOP, CLRF BCF BCF BCF BSF BSF = BCF. LOOP, EEADR EECON1, EECON1, INTCON,",
    "EXAMPLE 7-3: DATA EEPROM REFRESH ROUTINE\nEECON1, EECON1, = EECON1,. LOOP, CFGS EEPGD GIE WREN = WREN. LOOP, ; Start at address 0 ; Set for memory Set for Data EEPROM Disable interrupts Enable writes Loop to refresh array Read current address = ; Not zero, do it again. LOOP, CLRF BCF BCF BCF BSF BSF = BSF. LOOP, EEADR EECON1, EECON1, INTCON, EECON1, EECON1, = INTCON,. LOOP, CFGS EEPGD GIE WREN = GIE. LOOP, ; Start at address 0 ; Set for memory Set for Data EEPROM Disable interrupts Enable writes Loop to refresh array Read current address = ; Disable writes ; Enable interrupts",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on page = 54. EEADR, Bit 7 = EEPROM Address Register. EEADR, Bit 6 = EEPROM Address Register. EEADR, Bit 5 = EEPROM Address Register. EEADR, Bit 4 = EEPROM Address Register. EEADR, Bit 3 = EEPROM Address Register. EEADR, Bit 2 = EEPROM Address Register. EEADR, Bit 1 = EEPROM Address Register. EEADR, Bit 0 = EEPROM Address Register. EEADR, Reset Values on page = 56. EEDATA, Bit 7 = EEPROM Data Register. EEDATA, Bit 6 = EEPROM Data Register. EEDATA, Bit 5",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\n= EEPROM Data Register. EEDATA, Bit 4 = EEPROM Data Register. EEDATA, Bit 3 = EEPROM Data Register. EEDATA, Bit 2 = EEPROM Data Register. EEDATA, Bit 1 = EEPROM Data Register. EEDATA, Bit 0 = EEPROM Data Register. EEDATA, Reset Values on page = 56. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register).",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nEECON2, Reset Values on page = 56. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Reset Values on page = 56. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = -. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = -. IPR2, Bit 0 = CCP2IP. IPR2, Reset Values on page = 57. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = -.",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nPIR2, Bit 2 = LVDIF. PIR2, Bit 1 = -. PIR2, Bit 0 = CCP2IF. PIR2, Reset Values on page = 57. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = -. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = -. PIE2, Bit 0 = CCP2IE. PIE2, Reset Values on page = 57\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used during Flash/EEPROM access.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "8.0 FLASH PROGRAM MEMORY\nThe Flash program memory is readable, writable and erasable during normal operation over the entire VDD range.\nThe program memory space is 16 bits wide, while the data RAM space is 8 bits wide. Table reads and table writes move data between these two memory spaces through an 8-bit register (TABLAT).\nA read from program memory is executed on one byte at a time. A write to program memory is executed on blocks of 8 bytes at a time. Program memory is erased in blocks of 64 bytes at a time. A bulk erase operation may not be issued from user code.\nWhile writing or erasing program memory, instruction fetches  cease  until  the  operation  is  complete.  The program memory cannot be accessed during the write or erase, therefore, code cannot execute. An internal programming timer terminates program memory writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing  a  program  memory location  that  forms  an  invalid  instruction  results  in  a NOP .",
    "8.1 Table Reads and Table Writes\nIn order to read and write program memory, there are two operations that allow the processor to move bytes between  the  program  memory  space  and  the  data RAM:\n\u00b7 Table Read ( TBLRD )\n\u00b7 Table Write ( TBLWT )",
    "FIGURE 8-1: TABLE READ OPERATION\nTable  read  operations  retrieve  data  from  program memory  and  place  it  into  TABLAT  in  the  data  RAM space. Figure 8-1 shows the operation of a table read with program memory and data RAM.\nTable write operations store data from TABLAT in the data memory space into holding registers in program memory.  The  procedure  to  write  the  contents  of  the holding  registers  into  program  memory  is  detailed  in Section 8.5  'Writing  to  Flash  Program  Memory' . Figure 8-2  shows  the  operation  of  a  table  write  with program memory and data RAM.\nTable operations work with byte entities. A table block containing data, rather than program instructions, is not required to be word-aligned. Therefore, a table block can start and end at any byte address. If a table write is being used  to  write  executable  code  into  program  memory, program  instructions  will need  to  be  word-aligned, (TBLPTRL<0> = 0 ).",
    "8.2 Control Registers\nSeveral control registers are used in conjunction with the TBLRD and TBLWT instructions. These include the:\nThe FREE bit controls program memory erase operations. When the FREE bit is set, the erase operation is initiated  on  the  next  WR  command.  When  FREE  is clear, only writes are enabled.\n\u00b7 EECON1 register\n\u00b7 EECON2 register\n\u00b7 TABLAT register\n\u00b7 TBLPTR registers",
    "8.2.1 EECON1 AND EECON2 REGISTERS\nEECON1 is the control register for memory accesses.\nEECON2 is not a physical register. Reading EECON2 will read  all ' 0 's. The  EECON2  register  is  used exclusively in the memory write and erase sequences.\nControl bit, EEPGD, determines if the access will be to program  or  data  EEPROM  memory.  When  clear, operations  will  access  the  data  EEPROM  memory. When set, program memory is accessed.\nControl bit, CFGS, determines if the access will be to the Configuration registers or to program memory/data EEPROM memory. When set, subsequent operations access Configuration registers, regardless of EEPGD. (See Section 23.0 'Special Features of the CPU' .) When  CFGS  is  clear,  the  EEPGD  bit  selects  either program Flash or data EEPROM memory.",
    "8.2.1 EECON1 AND EECON2 REGISTERS\nA  write  operation  is  allowed  when  the  WREN  bit (EECON1<2>) is set. On power-up, the WREN bit is clear.  The  WRERR bit (EECON1<3>) is set in hardware  when  the  WR  bit  (EECON1<1>)  is  set  and cleared when the internal programming timer expires and the write operation is complete.",
    "Note:\nDuring  normal  operation,  the  WRERR may read as ' 1 '.  This can indicate that a write  operation  was  prematurely  terminated by a Reset or a write operation was attempted improperly.\nThe WR control bit initiates  write operations. The  bit cannot  be  cleared,  only  set,  in  software.  The  bit  is cleared  in  hardware  at  the  completion  of  the  write operation.\nThe  EEIF  interrupt  flag  bit  (PIR2<4>)  is set when the write is complete. It must be cleared in software.",
    "REGISTER 8-1: EECON1: DATA EEPROM CONTROL REGISTER 1\nEEPGD, R/W-x = CFGS. EEPGD, U-0 = -. EEPGD, R/W-0 = FREE. EEPGD, R/W-x = WRERR (1). EEPGD, R/W-0 = WREN. EEPGD, R/S-0 = WR. EEPGD, R/S-0 = RD. bit 7 bit 0, R/W-x = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-x = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/S-0 = bit 7 bit 0. bit 7 bit 0, R/S-0 = bit 7 bit 0",
    "REGISTER 8-1: EECON1: DATA EEPROM CONTROL REGISTER 1\nLegend:, 1 = S = Settable bit (cannot be cleared in software). Legend:, 2 = S = Settable bit (cannot be cleared in software). Legend:, 3 = S = Settable bit (cannot be cleared in software). R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 EEPGD: Flash Program or Data EEPROM Memory Select bit\n1 = Access Flash program memory\n0 = Access data EEPROM memory",
    "bit 6\nCFGS: Flash Program/Data EEPROM or Configuration Select bit\n1 = Access Configuration registers\n0 = Access Flash program or data EEPROM memory",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4\nFREE: Flash Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation)\n0 = Perform write only",
    "bit 3 WRERR: Flash Program/Data EEPROM Error Flag bit (1)\n1 = A write operation is prematurely terminated (any Reset during self-timed programming in normal operation, or an improper write attempt)\n0 = The write operation completed",
    "bit 2\nWREN: Flash Program/Data EEPROM Write Enable bit\n1 = Allows write cycles to Flash program/data EEPROM\n0 = Inhibits write cycles to Flash program/data EEPROM",
    "bit 1 WR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle (The operation is self-timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle to the EEPROM is complete",
    "bit 0 RD: Read Control bit\n1 = Initiates an EEPROM read (Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared) in software. RD bit cannot be set when EEPGD = 1 or CFGS = 1 .)\n0 = Does not initiate an EEPROM read\n- Note 1: When a WRERR occurs, the EEPGD and CFGS bits are not cleared. This allows tracing of the error condition.",
    "8.2.4 TABLE POINTER BOUNDARIES\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch is used to hold 8-bit data  during  data  transfers  between  program memory and data RAM.",
    "8.2.3 TBLPTR - TABLE POINTER REGISTER\nThe Table Pointer (TBLPTR) addresses a byte within the  program  memory.  The  TBLPTR  is  comprised  of three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL).  These  three  registers join  to  form a  22-bit  wide  pointer.  The  low-order 21 bits allow the device to address up to 2 Mbytes of program  memory  space.  Setting  the  22nd  bit  allows access  to the Device ID, the User ID and  the Configuration bits.\nTBLPTR is  used  in  reads,  writes  and  erases  of  the Flash program memory.\nWhen a TBLRD is  executed,  all  22  bits  of  the  Table Pointer determine which byte is read from program or configuration memory into TABLAT.",
    "8.2.3 TBLPTR - TABLE POINTER REGISTER\nWhen a TBLWT is executed, the three LSbs of the Table Pointer (TBLPTR<2:0>) determine which of the eight program memory holding registers is written to. When the timed write to program memory (long write) begins, the 19 MSbs of the Table Pointer, TBLPTR (TBLPTR<21:3>), will determine which program memory block of 8 bytes is written to (TBLPTR<2:0> are ignored). For more detail, see Section 8.5 'Writing to Flash Program Memory' .\nThe TBLPTR is used by the TBLRD and TBLWT instructions.  These  instructions  can  update  the  TBLPTR  in one of four ways based on the table operation. These operations are shown in Table 8-1. These operations on the TBLPTR only affect the low-order 21 bits.\nWhen an erase of program memory is executed, the 16 MSbs of the Table Pointer (TBLPTR<21:6>) point to the  64-byte  block  that  will  be  erased.  The  Least Significant bits (TBLPTR<5:0>) are ignored.",
    "8.2.3 TBLPTR - TABLE POINTER REGISTER\nFigure 8-3 describes the relevant boundaries of TBLPTR based on Flash program memory operations.\nTABLE 8-1: TABLE POINTER OPERATIONS WITH TBLRD AND TBLWT INSTRUCTIONS\n\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write",
    "8.3 Reading the Flash Program Memory\nThe TBLRD instruction  is  used  to  retrieve  data  from program  memory  and  place  it  into  data  RAM.  Table reads from program memory are performed one byte at a time.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. Figure 8-4 shows  the  interface  between  the  internal  program memory and the TABLAT.\nTBLPTR points to a byte address in program space. Executing a TBLRD instruction places the byte pointed to into TABLAT. In addition, TBLPTR can be modified automatically for the next table read operation.",
    "EXAMPLE 8-1: READING A FLASH PROGRAM MEMORY WORD\n, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF. , 2 = CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL. , 3 = ; Load TBLPTR with the base ; address of the word. READ_WORD, 1 = . READ_WORD, 2 = . READ_WORD, 3 = . , 1 = TBLRD*+. , 2 = TBLRD*+. , 3 = ; read into TABLAT and increment TBLPTR. , 1 = MOVF. , 2 = TABLAT,W. , 3 = ; get data. , 1 = MOVWF TBLRD*+. , 2 = WORD_EVEN. , 3 = ; read into TABLAT and increment TBLPTR. , 1 = MOVF. , 2 = TABLAT,W. , 3 = ; get data. , 1 = MOVWF. , 2 = WORD_ODD. , 3 = ",
    "8.4 Erasing Flash Program Memory\nThe  minimum  erase  block  is  32  words  or  64  bytes. Larger blocks of program memory can be bulk erased only  through  the  use  of  an  external  programmer  or ICSP  control.  Word  erase  in  the  Flash  array  is  not supported.\nWhen  initiating  an  erase  sequence  from  the  microcontroller itself, a block of 64 bytes of program memory is erased. The Most Significant 16 bits of the TBLPTR<21:6>  point  to  the block being erased; TBLPTR<5:0> are ignored.\nThe EECON1 register commands the erase operation. The EEPGD bit (EECON1<7>) must be set to point to the Flash program memory. The WREN bit (EECON1<2>) must be set to enable write operations. The FREE bit (EECON1<4>) is set to select an erase operation.\nFor protection, the write initiate sequence  using EECON2 must be used.",
    "8.4.1 FLASH PROGRAM MEMORY ERASE SEQUENCE\nThe sequence of events for erasing a block of internal program memory location is:\n1. Load the Table Pointer with the address of the row being erased.\n2. Set the EECON1 register for the erase operation:\n-set the EEPGD bit to point to program memory;\n-clear the CFGS bit to access program memory;\n-set the WREN bit to enable writes;\n-set the FREE bit to enable the erase.\n3. Disable interrupts.\n4. Write 55h to EECON2.\n5. Write 0AAh to EECON2.\n6. Set  the  WR  bit.  This  will  begin  the  row  erase cycle.\nA long write is necessary for erasing the internal Flash. Instruction  execution  is  halted  while  in  a  long  write cycle. The long write will be terminated by the internal programming timer.\n7. The CPU will stall for the duration of the erase (about 2 ms using internal timer).\n8. Execute a NOP .\n9. Re-enable interrupts.",
    "EXAMPLE 8-2: ERASING A FLASH PROGRAM MEMORY ROW\nERASE_ROW, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF. ERASE_ROW, 2 = CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW TBLPTRL. ERASE_ROW, 3 = ; load TBLPTR with ; address of the. ERASE_ROW, 1 = BSF BCF. ERASE_ROW, 2 = EECON1, EEPGD EECON1, CFGS EECON1,. ERASE_ROW, 3 = ; point to Flash program memory ; access Flash program memory. ERASE_ROW, 1 = BSF. ERASE_ROW, 2 = WREN. ERASE_ROW, 3 = ; enable write to memory. ERASE_ROW, 1 = BSF. ERASE_ROW, 2 = EECON1, FREE. ERASE_ROW, 3 = ; enable Row Erase operation. ERASE_ROW, 1 = BCF. ERASE_ROW, 2 = INTCON, GIE. ERASE_ROW, 3 = ; disable interrupts. Required Sequence, 1 = MOVLW. Required",
    "EXAMPLE 8-2: ERASING A FLASH PROGRAM MEMORY ROW\nSequence, 2 = 55h. Required Sequence, 3 = . Required Sequence, 1 = MOVWF. Required Sequence, 2 = EECON2. Required Sequence, 3 = ; write 55H. Required Sequence, 1 = MOVWF. Required Sequence, 2 = . Required Sequence, 3 = . Required Sequence, 1 = . Required Sequence, 2 = EECON2. Required Sequence, 3 = ; write 0AAH. Required Sequence, 1 = BSF. Required Sequence, 2 = EECON2, WR. Required Sequence, 3 = ; start erase (CPU. Required Sequence, 1 = BSF. Required Sequence, 2 = INTCON, GIE. Required Sequence, 3 = ; re-enable interrupts. , 1 = . , 2 = . , 3 = ",
    "8.5 Writing to Flash Program Memory\nThe  programming  block  size  is  4  words  or  8  bytes. Word or byte programming is not supported.\nThe  long  write  is  necessary  for  programming  the internal Flash. Instruction execution is halted while in a long write cycle. The long write will be terminated by the internal programming timer.\nTable  writes  are  used  internally  to  load  the  holding registers needed to program the Flash memory. There are  8  holding  registers  used  by  the  table  writes  for programming.\nThe  EEPROM  on-chip  timer  controls  the  write  time. The write/erase voltages are generated by an on-chip charge pump, rated to operate over the voltage range of the device.\nSince the Table Latch (TABLAT) is only a single byte, the TBLWT instruction has to be executed 8 times for each  programming  operation.  All  of  the  table  write operations will essentially be short writes, because only the holding registers are written. At the end of updating 8 registers, the EECON1 register must be written to, to start the programming operation with a long write.",
    "Note:\nThe default value of the holding registers on device Resets and after write operations is FFh. A write of FFh to a holding register does not modify that byte. This means that individual  bytes  of  program  memory may be modified, provided that the modification does not attempt to change any bit from a ' 0 ' to a  ' 1 '. When  modifying  individual bytes, it is not necessary to load all 64 holding registers before executing a write operation.",
    "8.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\n- 7. Set the EECON1 register for the write operation by doing the following:\nThe sequence of events for programming an internal program memory location should be:",
    "8.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\n1. Read 64 bytes into RAM.\n2. Update data values in RAM as necessary.\n3. Load Table Pointer with address being erased.\n4. Do the row erase procedure (see Section 8.4.1 'Flash Program Memory Erase Sequence' ).\n5. Load Table Pointer with the address of the first byte being written.\n6. Write the first 8 bytes into the holding registers with auto-increment.\n\u00b7 Set the EEPGD bit to point to program memory\n\u00b7 Clear the CFGS bit to access program memory\n\u00b7 Set the WREN bit to enable byte writes\n8. Disable interrupts.\n9. Write 55h to EECON2.\n10. Write 0AAh to EECON2.\n11. Set the WR bit. This will begin the write cycle.\n12. The CPU will stall for the duration of the write (about 2 ms using internal timer).\n13. Execute a NOP .\n14. Re-enable interrupts.\n15. Repeat Steps 6-14 seven times to write 64 bytes.\n16. Verify the memory (table read).",
    "8.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\nThis procedure will require about 18 ms to update one row of 64 bytes of memory. An example of the required code is given in Example 8-3.",
    "WRITING TO FLASH PROGRAM MEMORY\n, 1 = MOVLW. , 2 = D'64'. , 1 = MOVWF. , 2 = COUNTER. , 1 = MOVLW. , 2 = BUFFER_ADDR_HIGH. , 1 = MOVWF. , 2 = FSR0H. , 1 = MOVLW. , 2 = BUFFER_ADDR_LOW. , 1 = MOVWF. , 2 = FSR0L. , 1 = MOVLW. , 2 = CODE_ADDR_UPPER. , 1 = MOVWF. , 2 = TBLPTRU. , 1 = MOVLW. , 2 = CODE_ADDR_HIGH. , 1 = MOVWF. , 2 = TBLPTRH. , 1 = MOVLW. , 2 = CODE_ADDR_LOW. , 1 = MOVWF. , 2 = TBLPTRL. READ_BLOCK, 1 = READ_BLOCK. READ_BLOCK, 2 = READ_BLOCK. , 1 = TBLRD*+. , 2 = . , 1 = MOVF. , 2 = TABLAT,W. , 1 =",
    "WRITING TO FLASH PROGRAM MEMORY\nMOVWF. , 2 = POSTINC0. , 1 = DECFSZ. , 2 = COUNTER. , 1 = BRA. , 2 = READ_BLOCK. MODIFY_WORD, 1 = MODIFY_WORD. MODIFY_WORD, 2 = MODIFY_WORD. , 1 = MOVLW. , 2 = DATA_ADDR_HIGH. , 1 = MOVWF. , 2 = FSR0H. , 1 = MOVLW. , 2 = DATA_ADDR_LOW. , 1 = MOVWF. , 2 = FSR0L. , 1 = MOVLW. , 2 = NEW_DATA_LOW. , 1 = MOVWF. , 2 = POSTINC0. , 1 = MOVLW. , 2 = NEW_DATA_HIGH. MOVWF INDF0 ERASE_BLOCK, 1 = MOVWF INDF0 ERASE_BLOCK. MOVWF INDF0 ERASE_BLOCK, 2 = MOVWF INDF0 ERASE_BLOCK. , 1 = MOVLW. , 2 = CODE_ADDR_UPPER. , 1 = MOVWF. , 2",
    "WRITING TO FLASH PROGRAM MEMORY\n= TBLPTRU. , 1 = MOVLW. , 2 = CODE_ADDR_HIGH. , 1 = MOVWF. , 2 = TBLPTRH. , 1 = . , 2 = CODE_ADDR_LOW. , 1 = MOVLW. , 2 = . , 1 = MOVWF BCF. , 2 = TBLPTRL EECON1, CFGS. , 1 = BSF. , 2 = EECON1, EEPGD. , 1 = BSF. , 2 = EECON1, WREN. , 1 = BSF. , 2 = EECON1, FREE. , 1 = BCF. , 2 = INTCON, GIE. , 1 = MOVLW. , 2 = 55h. , 1 = MOVWF. , 2 = EECON2. , 1 = MOVLW. , 2 = 0AAh. , 1 = . , 2 = EECON2. , 1 = MOVWF. , 2 = . , 1 = BSF. , 2 = EECON1,. , 1 = NOP. , 2 = WR. , 1 = BSF. ,",
    "WRITING TO FLASH PROGRAM MEMORY\n2 = INTCON, GIE. , 1 = MOVLW MOVWF. , 2 = BUFFER_ADDR_HIGH FSR0H. , 1 = . , 2 = BUFFER_ADDR_LOW. , 1 = MOVLW. , 2 = . , 1 = MOVWF. , 2 = . FSR0L PROGRAM_LOOP, 1 = FSR0L PROGRAM_LOOP. FSR0L PROGRAM_LOOP, 2 = FSR0L PROGRAM_LOOP. , 1 = MOVLW. , 2 = 8. , 1 = MOVWF. , 2 = COUNTER. , 1 = MOVWF TBLWT+*. , 2 = TABLAT. , 1 = . , 2 = . , 1 = DECFSZ. , 2 = COUNTER. , 1 = GOTO. , 2 = WRITE_WORD_TO_HREGS",
    "WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\nPROGRAM_MEMORY, 1 = PROGRAM_MEMORY. PROGRAM_MEMORY, 2 = PROGRAM_MEMORY. BCF, 1 = INTCON, GIE. BCF, 2 = ; disable interrupts. MOVLW, 1 = 55h. MOVLW, 2 = ; required sequence. MOVWF, 1 = EECON2. MOVWF, 2 = ; write 55h. MOVLW, 1 = 0AAh. MOVLW, 2 = . MOVWF, 1 = EECON2. MOVWF, 2 = ; write 0AAh. BSF, 1 = EECON1, WR. BSF, 2 = ; start program (CPU stall). NOP, 1 = . NOP, 2 = . BSF, 1 = INTCON, GIE. BSF, 2 = ; re-enable interrupts. DECFSZ, 1 = COUNTER_HI. DECFSZ, 2 = ; loop until done. GOTO, 1 = PROGRAM_LOOP. GOTO, 2 = . BCF, 1 = EECON1, WREN. BCF, 2 = ; disable write to memory",
    "8.5.2 WRITE VERIFY\nDepending  on  the  application,  good  programming practice  may  dictate  that  the  value  written  to  the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.\nreprogrammed if needed. The WRERR bit is set when a write operation is interrupted by a MCLR Reset, or a WDT Time-out Reset during normal operation. In these situations, users can check the WRERR bit and rewrite the location.",
    "8.6 Flash Program Operation During Code Protection\nIf a write is terminated by an unplanned event, such as loss  of  power  or  an  unexpected  Reset,  the  memory location just programmed  should  be  verified  and",
    "See Section 23.5 'Program Verification and Code\nProtection' for  details  on  code  protection  of  Flash program memory.",
    "TABLE 8-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nTBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit 21 (1). TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Reset Values on Page: = 54. TBPLTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 5 = Program Memory Table Pointer High Byte",
    "TABLE 8-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n(TBLPTR<15:8>). TBPLTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Reset Values on Page: = 54. TBLPTRL, Bit 7 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer Low Byte",
    "TABLE 8-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n(TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Reset Values on Page: = 54. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Reset Values on Page: = 54. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 =",
    "TABLE 8-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nPEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Reset Values",
    "TABLE 8-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\non Page: = 56. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Reset Values on Page: = 56. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = -. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = -. IPR2, Bit 0 = CCP2IP. IPR2, Reset Values on Page: = 57. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = -. PIR2, Bit 2 =",
    "TABLE 8-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nLVDIF. PIR2, Bit 1 = -. PIR2, Bit 0 = CCP2IF. PIR2, Reset Values on Page: = 57. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = -. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = -. PIE2, Bit 0 = CCP2IE. PIE2, Reset Values on Page: = 57\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used during Flash/EEPROM access.\nNote 1: Bit 21 of the PC is only available in Test mode and Serial Programming modes.",
    "9.1 Introduction\nAll PIC18 devices include an 8 x 8 hardware multiplier as part of the ALU. The multiplier performs an unsigned operation and yields a 16-bit result that is stored in the product register pair, PRODH:PRODL. The multiplier's operation  does  not  affect  any  flags  in  the  STATUS register.\nMaking multiplication a hardware operation allows it to be completed  in  a  single  instruction  cycle.  This  has  the advantages  of  higher  computational  throughput  and reduced  code  size  for  multiplication  algorithms,  and allows the PIC18 devices to be used in many applications previously reserved for digital signal processors.\nA comparison of various hardware and software multiply operations, along with the savings in memory and execution time, is shown in Table 9-1.\nExample 9-1  shows  the  sequence  to  do  an  8  x  8 unsigned  multiply.  Only  one  instruction  is  required when one argument of the multiply is already loaded in the WREG register.\nExample 9-2 shows the sequence to do an 8 x 8 signed multiply. To account for the sign bits of the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "ROUTINE\nMOVF\nARG1, W\n;\nMULWF\nARG2\n; ARG1 * ARG2 ->\n; PRODH:PRODL",
    "EXAMPLE 9-2: 8 x 8 SIGNED MULTIPLY ROUTINE\nMOVF MULWF, 1 = ARG1, W ARG2. MOVF MULWF, 2 = ; ARG1 * ARG2 -> ; PRODH:PRODL. BTFSC SUBWF, 1 = ARG2, SB PRODH, F. BTFSC SUBWF, 2 = ; Test Sign Bit ; PRODH = PRODH ; - ARG1. MOVF BTFSC SUBWF, 1 = ARG2, W ARG1, SB PRODH, F. MOVF BTFSC SUBWF, 2 = ; Test Sign Bit ; PRODH = PRODH ; - ARG2",
    "TABLE 9-1: PERFORMANCE COMPARISON\n8 x 8 Unsigned, Multiply Method = Without Hardware Multiply. 8 x 8 Unsigned, Program Memory (Words). = 13. 8 x 8 Unsigned, Cycles (Max). = 69. 8 x 8 Unsigned, Time.@40 MHz = 6.9 \uf06d s. 8 x 8 Unsigned, Time.@10 MHz = 27.6 \uf06d s. 8 x 8 Unsigned, Time.@4MHz = 69 \uf06d s. 8 x 8 Unsigned, Multiply Method = Hardware Multiply. 8 x 8 Unsigned, Program Memory (Words). = 1. 8 x 8 Unsigned, Cycles (Max). = 1. 8 x 8 Unsigned, Time.@40 MHz = 100 ns. 8 x 8 Unsigned, Time.@10 MHz = 400 ns. 8 x 8 Unsigned, Time.@4MHz = 1 \uf06d s. 8 x 8 Signed, Multiply Method = Without Hardware Multiply. 8 x 8 Signed, Program Memory (Words). = 33. 8 x 8 Signed, Cycles (Max). = 91. 8 x 8 Signed, Time.@40 MHz = 9.1 \uf06d s. 8 x 8 Signed, Time.@10 MHz = 36.4 \uf06d s. 8 x 8",
    "TABLE 9-1: PERFORMANCE COMPARISON\nSigned, Time.@4MHz = 91 \uf06d s. 8 x 8 Signed, Multiply Method = Hardware Multiply. 8 x 8 Signed, Program Memory (Words). = 6. 8 x 8 Signed, Cycles (Max). = 6. 8 x 8 Signed, Time.@40 MHz = 600 ns. 8 x 8 Signed, Time.@10 MHz = 2.4 \uf06d s. 8 x 8 Signed, Time.@4MHz = 6 \uf06d s. 16 x 16 Unsigned, Multiply Method = Without Hardware Multiply. 16 x 16 Unsigned, Program Memory (Words). = 21. 16 x 16 Unsigned, Cycles (Max). = 242. 16 x 16 Unsigned, Time.@40 MHz = 24.2 \uf06d s. 16 x 16 Unsigned, Time.@10 MHz = 96.8 \uf06d s. 16 x 16 Unsigned, Time.@4MHz = 242 \uf06d s. 16 x 16 Unsigned, Multiply Method = Hardware Multiply. 16 x 16 Unsigned, Program Memory (Words). = 24. 16 x 16 Unsigned, Cycles (Max). = 24. 16 x 16 Unsigned, Time.@40 MHz = 2.4 \uf06d s. 16 x 16 Unsigned,",
    "TABLE 9-1: PERFORMANCE COMPARISON\nTime.@10 MHz = 9.6 \uf06d s. 16 x 16 Unsigned, Time.@4MHz = 24 \uf06d s. 16 x 16 Signed, Multiply Method = Without Hardware Multiply. 16 x 16 Signed, Program Memory (Words). = 52. 16 x 16 Signed, Cycles (Max). = 254. 16 x 16 Signed, Time.@40 MHz = 25.4 \uf06d s. 16 x 16 Signed, Time.@10 MHz = 102.6 \uf06d s. 16 x 16 Signed, Time.@4MHz = 254 \uf06d s. 16 x 16 Signed, Multiply Method = Hardware Multiply. 16 x 16 Signed, Program Memory (Words). = 36. 16 x 16 Signed, Cycles (Max). = 36. 16 x 16 Signed, Time.@40 MHz = 3.6 \uf06d s. 16 x 16 Signed, Time.@10 MHz = 14.4 \uf06d s. 16 x 16 Signed, Time.@4MHz = 36 \uf06d s",
    "PIC18F2331/2431/4331/4431\nExample 9-3  shows  the  sequence  to  do  a  16  x  16 unsigned  multiply.  Equation 9-1  shows  the  algorithm that is used. The 32-bit result is stored in four registers, RES<3:0>.\nEQUATION 9-1:\n16 x 16 UNSIGNED MULTIPLICATION ALGORITHM\nRES<3:0>\n=\nARG1H:ARG1L   ARG2H:ARG2L \uf0b7\n=\n(ARG1H   ARG2H   2 16 ) + \uf0b7 \uf0b7\n(ARG1H   ARG2L   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2H   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2L) \uf0b7",
    "EXAMPLE 9-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2L. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1L * ARG2L -> PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 = RES1. MOVFF, 3 = ;. MOVFF, 4 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES0. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1H, ARG2H. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = . MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1H * ARG2H -> PRODH:PRODL.",
    "EXAMPLE 9-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVFF, 1 = PRODH,. MOVFF, 2 = RES3. MOVFF, 3 = ;. MOVFF, 4 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES2. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1L * ARG2H -> PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF, 1 = RES1,. ADDWF, 2 = F. ADDWF, 3 = ;. ADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W.",
    "EXAMPLE 9-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF, 3 = ;. MOVF, 4 = products. ADDWFC, 1 = RES2,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . MULWF, 1 = ARG2L. MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 = ARG1H * ARG2L -> PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF, 1 = RES1,. ADDWF,",
    "EXAMPLE 9-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\n2 = F. ADDWF, 3 = ;. ADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = products. ADDWFC, 1 = RES2,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = . CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3,. ADDWFC, 2 = F. ADDWFC, 3 = ;. ADDWFC, 4 = \nExample 9-4  shows  the  sequence  to  do  a  16  x  16 signed  multiply.  Equation 9-2  shows  the  algorithm used.  The  32-bit  result  is  stored  in  four  registers, RES<3:0>.  To  account  for  the  sign  bits  of  the  arguments, each argument pair's Most Significant bit (MSb) is tested and the appropriate subtractions are done.\nEQUATION 9-2:\n16 x 16 SIGNED MULTIPLICATION ALGORITHM",
    "RES<3:0>\n=\nARG1H:ARG1L   ARG2H:ARG2L \uf0b7\n=\n(ARG1H   ARG2H   2 16 ) +\n\uf0b7\n\uf0b7\n(ARG1H   ARG2L   2 8 ) + \uf0b7 \uf0b7\n(ARG1L   ARG2H \u00b2 2 8 ) + \uf0b7\n(ARG1L   ARG2L)+ \uf0b7\n(-1 \uf0b7 ARG2H<7>   ARG1H:ARG1L   2 16 ) + \uf0b7 \uf0b7\n(-1 \uf0b7 ARG1H<7>   ARG2H:ARG2L   2 16 ) \uf0b7 \uf0b7",
    "EXAMPLE 9-4: 16 x 16 SIGNED MULTIPLY ROUTINE\nMULWF, ARG1L, = ARG2L. MULWF, W = . MULWF,  = ; ;. MULWF,  = ARG1L * ARG2L -> PRODH:PRODL. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES1. MOVFF,  = ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES0. MOVFF,  = ;. MOVFF,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF,  = ;. MULWF,",
    "EXAMPLE 9-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= ARG1H * ARG2H -> PRODH:PRODL. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES3. MOVFF,  = ; ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES2. MOVFF,  = ;. MOVFF,  = . MOVF, ARG1L, = ARG1L,W. MOVF, W = . MOVF,  = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1L * ARG2H -> PRODH:PRODL. MOVF, ARG1L, = PRODL,. MOVF, W = W. MOVF,  = ;. MOVF,  = . ADDWF, ARG1L, = RES1, F. ADDWF, W = . ADDWF,",
    "EXAMPLE 9-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= ;. ADDWF,  = Add cross. MOVF, ARG1L, = PRODH,. MOVF, W = W. MOVF,  = ;. MOVF,  = products. ADDWFC, ARG1L, = RES2, F. ADDWFC, W = . ADDWFC,  = ;. ADDWFC,  = . CLRF, ARG1L, = WREG. CLRF, W = . CLRF,  = ;. CLRF,  = . ADDWFC, ARG1L, = RES3, F. ADDWFC, W = . ADDWFC,  = ;. ADDWFC,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = ;. MOVF,  = . MULWF, ARG1L, = ARG2L. MULWF, W = . MULWF,  = ;. MULWF,",
    "EXAMPLE 9-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= ARG1H * ARG2L -> PRODH:PRODL. MOVF, ARG1L, = PRODL,. MOVF, W = W. MOVF,  = ;. MOVF,  = . ADDWF, ARG1L, = RES1, F. ADDWF, W = . ADDWF,  = ;. ADDWF,  = Add cross. MOVF, ARG1L, = PRODH,. MOVF, W = W. MOVF,  = ;. MOVF,  = products. ADDWFC, ARG1L, = RES2, F. ADDWFC, W = . ADDWFC,  = ;. ADDWFC,  = . CLRF, ARG1L, = WREG. CLRF, W = . CLRF,  = ;. CLRF,  = . ADDWFC, ARG1L, = RES3,. ADDWFC, W = F. ADDWFC,  = ;. ADDWFC,",
    "EXAMPLE 9-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . BTFSS, ARG1L, = ARG2H, 7. BTFSS, W = . BTFSS,  = ;. BTFSS,  = ARG2H:ARG2L neg?. BRA, ARG1L, = SIGN_ARG1. BRA, W = . BRA,  = ;. BRA,  = no, check ARG1. MOVF, ARG1L, = ARG1L,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWF, ARG1L, = RES2. SUBWF, W = . SUBWF,  = ;. SUBWF,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWFB, ARG1L, = RES3. SUBWFB, W = . SUBWFB,  = . SUBWFB,",
    "EXAMPLE 9-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . ; SIGN_ARG1, ARG1L, = . ; SIGN_ARG1, W = . ; SIGN_ARG1,  = . ; SIGN_ARG1,  = . BTFSS, ARG1L, = ARG1H,. BTFSS, W = 7. BTFSS,  = ;. BTFSS,  = ARG1H:ARG1L neg?. BRA, ARG1L, = CONT_CODE. BRA, W = . BRA,  = ;. BRA,  = no, done. MOVF, ARG1L, = ARG2L,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWF, ARG1L, = RES2. SUBWF, W = . SUBWF,  = ;. SUBWF,  = . MOVF, ARG1L, = ARG2H,. MOVF, W = W. MOVF,  = ;. MOVF,",
    "EXAMPLE 9-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . SUBWFB, ARG1L, = RES3. SUBWFB, W = . SUBWFB,  = . SUBWFB,  = . CONT_CODE, ARG1L, = . CONT_CODE, W = . CONT_CODE,  = . CONT_CODE,  = . :, ARG1L, = . :, W = . :,  = . :,  = ",
    "10.0 INTERRUPTS\nThe PIC18F2331/2431/4331/4431 devices have multiple interrupt sources and  an  interrupt priority feature that allows each interrupt source to be assigned a  high-priority  level  or  a  low-priority  level.  The  highpriority interrupt vector is at 000008h and the low-priority interrupt  vector  is  at  000018h.  High-priority  interrupt events will interrupt any low-priority interrupts that may be in progress.\nWhen  the  IPEN  bit  is  cleared  (default  state),  the interrupt priority feature is disabled and interrupts are compatible with PIC \u00ae  mid-range devices. In Compatibility  mode,  the  interrupt  priority  bits  for  each  source have  no  effect.  INTCON<6>  is  the  PEIE  bit,  which enables/disables all peripheral interrupt sources. INTCON<7> is the GIE bit, which enables/disables all interrupt  sources.  All  interrupts  branch  to  address 000008h in Compatibility mode.\nThere are thirteen registers which are used to control interrupt operation. These registers are:",
    "10.0 INTERRUPTS\n\u00b7 RCON\n\u00b7 INTCON\n\u00b7 INTCON2\n\u00b7 INTCON3\n\u00b7 PIR1, PIR2, PIR3\n\u00b7 PIE1, PIE2, PIE3\n\u00b7 IPR1, IPR2, IPR3\nIt is recommended that the Microchip header files supplied  with  MPLAB \u00ae   IDE  be  used  for  the  symbolic  bit names in these registers. This allows the assembler/ compiler to automatically take care of the placement of these bits within the specified register.\nIn  general,  each  interrupt  source  has  three  bits  to control its operation. The functions of these bits are:\n\u00b7 Flag bit to indicate that an interrupt event occurred\n\u00b7 Enable bit that allows program execution to branch to the interrupt vector address when the flag bit is set\n\u00b7 Priority bit to select high priority or low priority (most interrupt sources have priority bits)",
    "10.0 INTERRUPTS\nThe interrupt priority feature is enabled by setting the IPEN bit (RCON<7>). When  interrupt priority is enabled,  there  are  two  bits  which  enable  interrupts globally. Setting the GIEH bit (INTCON<7>) enables all interrupts  that  have  the  priority  bit  set  (high  priority). Setting the GIEL bit (INTCON<6>) enables all interrupts that have the priority bit cleared (low priority). When  the  interrupt  flag,  enable  bit  and  appropriate global  interrupt  enable  bit  are  set,  the  interrupt  will vector  immediately  to  address  000008h  or  000018h depending on the priority bit setting. Individual interrupts can be disabled through their corresponding enable bits.\nWhen an interrupt is responded to, the global interrupt enable bit is cleared to disable further interrupts. If the IPEN bit is cleared, this is the GIE bit. If interrupt priority levels are used, this will be either the GIEH or GIEL bit. High-priority  interrupt  sources  can  interrupt  a  lowpriority interrupt. Low-priority interrupts are not processed while high-priority interrupts are in progress.",
    "10.0 INTERRUPTS\nThe return address is pushed onto the stack and the PC  is loaded with the interrupt vector address (000008h or 000018h). Once in the Interrupt Service Routine,  the  source(s)  of  the  interrupt  can  be  determined by polling the  interrupt  flag  bits.  The  interrupt flag bits must be cleared in software before re-enabling interrupts to avoid recursive interrupts.\nThe 'return from interrupt' instruction, RETFIE , exits the  interrupt  routine  and  sets  the  GIE  bit  (GIEH  or GIEL  if  priority  levels  are  used),  which  re-enables interrupts.\nFor external interrupt events, such as the INTx pins or the PORTB input change interrupt, the interrupt latency will be  three  to  four  instruction  cycles.  The  exact latency is the same for one or two-cycle instructions. Individual interrupt flag bits are set, regardless of the status of their corresponding enable bit or the GIE bit.\nNote:\nDo not use the MOVFF instruction to modify any of the Interrupt Control registers while any interrupt  is  enabled.  Doing  so  may cause erratic microcontroller behavior.",
    "PIC18F2331/2431/4331/4431\nFIGURE 10-1:\nINTERRUPT LOGIC",
    "10.1 INTCON Registers\nThe  INTCON  registers  are  readable  and  writable registers which contain various enable, priority and flag bits.\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable  bit.  User  software  should  ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.",
    "REGISTER 10-1: INTCON: INTERRUPT CONTROL REGISTER\nGIE/GIEH, R/W-0 = PEIE/GIEL. GIE/GIEH, R/W-0 = TMR0IE. GIE/GIEH, R/W-0 = INT0IE. GIE/GIEH, R/W-0 = RBIE. GIE/GIEH, R/W-0 = TMR0IF. GIE/GIEH, R/W-0 = INT0IF. GIE/GIEH, R/W-x = RBIF. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-x = bit 0",
    "REGISTER 10-1: INTCON: INTERRUPT CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 GIE/GIEH: Global Interrupt Enable bit\nWhen IPEN = 0 :\n1 = Enables all unmasked interrupts\n0 = Disables all interrupts\nWhen IPEN = 1 :\n1 = Enables all high-priority interrupts\n0 = Disables all high-priority interrupts",
    "bit 6\nPEIE/GIEL: Peripheral Interrupt Enable bit\nWhen IPEN = 0 :\n1 = Enables all unmasked peripheral interrupts\n0 = Disables all peripheral interrupts",
    "When IPEN = 1 :\n1 = Enables all low-priority peripheral interrupts\n0 = Disables all low-priority peripheral interrupts",
    "bit 5\nTMR0IE: TMR0 Overflow Interrupt Enable bit\n1 = Enables the TMR0 overflow interrupt\n0 = Disables the TMR0 overflow interrupt",
    "bit 4\nINT0IE: INT0 External Interrupt Enable bit\n1 = Enables the INT0 external interrupt\n0 = Disables the INT0 external interrupt",
    "bit 3\nRBIE: RB Port Change Interrupt Enable bit\n1 = Enables the RB port change interrupt for RB<7:4> pins\n0 = Disables the RB port change interrupt for RB<7:4> pins\nbit 2\nTMR0IF: TMR0 Overflow Interrupt Flag bit\n1 = TMR0 register has overflowed (must be cleared in software)\n0 = TMR0 register did not overflow",
    "bit 1\nINT0IF: INT0 External Interrupt Flag bit\n1 = The INT0 external interrupt occurred (must be cleared in software)\n0 = The INT0 external interrupt did not occur",
    "bit 0\nRBIF: RB Port Change Interrupt Flag bit\n1 = At least one of the RB<7:4> pins changed state (must be cleared in software)\n0 = None of the RB<7:4> pins have changed state",
    "REGISTER 10-2: INTCON2: INTERRUPT CONTROL REGISTER 2\nRBPU, R/W-1 = INTEDG0. RBPU, R/W-1 = INTEDG1. RBPU, R/W-1 = INTEDG2. RBPU, U-0 = -. RBPU, R/W-1 = TMR0IP. RBPU, U-0 = -. RBPU, R/W-1 = RBIP. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0",
    "REGISTER 10-2: INTCON2: INTERRUPT CONTROL REGISTER 2\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 RBPU: PORTB Pull-up Enable bit\n1 = All PORTB pull-ups are disabled\n0 = PORTB pull-ups are enabled by individual port latch values",
    "bit 6\nINTEDG0: External Interrupt 0 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 5\nINTEDG1: External Interrupt 1 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge",
    "bit 4\nINTEDG2: External Interrupt 2 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge",
    "bit 3 Unimplemented: Read as ' 0 '\nbit 2\nTMR0IP: TMR0 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1 Unimplemented: Read as ' 0 '",
    "bit 0 RBIP: RB Port Change Interrupt Priority bit\n1 = High priority\n0 = Low priority\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.",
    "REGISTER 10-3: INTCON3: INTERRUPT CONTROL REGISTER 3\nINT2IP, R/W-1 = INT1IP. INT2IP, U-0 = -. INT2IP, R/W-0 = INT2IE. INT2IP, R/W-0 = INT1IE. INT2IP, U-0 = -. INT2IP, R/W-0 = INT2IF. INT2IP, R/W-0 = INT1IF. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "bit 7 INT2IP: INT2 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6\nINT1IP: INT1 External Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4\nINT2IE: INT2 External Interrupt Enable bit\n1 = Enables the INT2 external interrupt\n0 = Disables the INT2 external interrupt\nbit 3\nINT1IE: INT1 External Interrupt Enable bit\n1 = Enables the INT1 external interrupt\n0 = Disables the INT1 external interrupt",
    "bit 2 Unimplemented: Read as ' 0 '\nbit 1\nINT2IF:\nINT2 External Interrupt Flag bit\n1 = The INT2 external interrupt occurred (must be cleared in software)\n0 = The INT2 external interrupt did not occur",
    "bit 0\nINT1IF: INT1 External Interrupt Flag bit\n1 = The INT1 external interrupt occurred (must be cleared in software)\n0 = The INT1 external interrupt did not occur\nNote:\nInterrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.",
    "10.2 PIR Registers\nThe PIR registers contain the individual flag bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are three Peripheral Interrupt Request (Flag) Registers (PIR1, PIR2 and PIR3).\nNote 1: Interrupt flag bits are  set when an interrupt  condition  occurs,  regardless  of  the state of its corresponding enable bit or the Global Interrupt Enable bit, GIE (INTCON<7>).\n2: User software should ensure the appropriate interrupt flag bits are cleared prior to enabling an interrupt and after servicing that interrupt.",
    "REGISTER 10-4: PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nU-0, 1 = R/W-0. U-0, 2 = R-0. U-0, 3 = R-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = ADIF. -, 2 = RCIF. -, 3 = TXIF. -, 4 = SSPIF. -, 5 = CCP1IF. -, 6 = TMR2IF. -, 7 = TMR1IF. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 10-4: PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6 ADIF: A/D Converter Interrupt Flag bit\n1 = An A/D conversion completed (must be cleared in software)\n0 = The A/D conversion is not complete\nbit 5\nRCIF: EUSART Receive Interrupt Flag bit\n1 = The EUSART receive buffer, RCREG, is full (cleared when RCREG is read)\n0 = The EUSART receive buffer is empty",
    "bit 4 TXIF: EUSART Transmit Interrupt Flag bit\n1 = The EUSART transmit buffer, TXREG, is empty (cleared when TXREG is written)\n0 = The EUSART transmit buffer is full",
    "bit 3 SSPIF: Synchronous Serial Port Interrupt Flag bit\n1 = The transmission/reception is complete (must be cleared in software)\n0 = Waiting to transmit/receive",
    "bit 2 CCP1IF: CCP1 Interrupt Flag bit\nCapture mode:\n1 = A TMR1 register capture occurred (must be cleared in software)\n0 = No TMR1 register capture occurred",
    "Compare mode:\n1 = A TMR1 register compare match occurred (must be cleared in software)\n0 = No TMR1 register compare match occurred\nPWM mode:\nUnused in this mode.",
    "bit 1 TMR2IF: TMR2 to PR2 Match Interrupt Flag bit\n1 = TMR2 to PR2 match occurred (must be cleared in software)\n0 = No TMR2 to PR2 match occurred",
    "bit 0 TMR1IF: TMR1 Overflow Interrupt Flag bit\n1 = TMR1 register overflowed (must be cleared in software)\n0 = TMR1 register did not overflow",
    "REGISTER 10-5: PIR2: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 2\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-0. R/W-0, 4 = U-0. R/W-0, 5 = R/W-0. R/W-0, 6 = U-0. R/W-0, 7 = R/W-0. OSCFIF, 1 = -. OSCFIF, 2 = -. OSCFIF, 3 = EEIF. OSCFIF, 4 = -. OSCFIF, 5 = LVDIF. OSCFIF, 6 = -. OSCFIF, 7 = CCP2IF. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit",
    "REGISTER 10-5: PIR2: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 2\n7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 OSCFIF: Oscillator Fail Interrupt Flag bit\n1 = Device oscillator failed, clock input has changed to INTOSC (must be cleared in software)\n0 = Device clock operating",
    "bit 6-5 Unimplemented: Read as ' 0 '\nbit 4\nEEIF: EEPROM or Flash Write Operation Interrupt Flag bit\n1 = The write operation is complete (must be cleared in software)\n0 = The write operation is not complete or has not been started",
    "bit 3 Unimplemented: Read as ' 0 '\nbit 2\nLVDIF: Low-Voltage Detect Interrupt Flag bit\n1 = The supply voltage has fallen below the specified LVD voltage (must be cleared in software)\n0 = The supply voltage is greater than the specified LVD voltage",
    "Capture mode:\n1 = A TMR1 register capture occurred (must be cleared in software)\n0 = No TMR1 register capture occurred",
    "Compare mode:\n1 = A TMR1 register compare match occurred (must be cleared in software)\n0 = No TMR1 register compare match occurred",
    "PWM mode:\nNot used in this mode.",
    "REGISTER 10-6: PIR3: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 3\n-, U-0 = -. -, U-0 = -. -, R/W-0 = PTIF. -, R/W-0 = IC3DRIF. -, R/W-0 = IC2QEIF. -, R/W-0 = IC1IF. -, R/W-0 = TMR5IF. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 10-6: PIR3: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 3\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 4 PTIF: PWM Time Base Interrupt bit\n1 = PWM time base matched the value in the PTPER registers. Interrupt is issued according to the postscaler settings. PTIF must be cleared in software.\n0 = PWM time base has not matched the value in the PTPER registers\nIC3DRIF: IC3 Interrupt Flag/Direction Change Interrupt Flag bit",
    "IC3 Enabled (CAP3CON<3:0>):\n1 = TMR5 value was captured by the active edge on CAP3 input (must be cleared in software)\n0 = TMR5 capture has not occurred",
    "QEI Enabled (QEIM<2:0>):\n1 = Direction of rotation has changed (must be cleared in software)\n0 = Direction of rotation has not changed",
    "IC2 Enabled (CAP2CON<3:0>):\n1 = TMR5 value was captured by the active edge on CAP2 input (must be cleared in software)\n0 = TMR5 capture has not occurred",
    "QEI Enabled (QEIM<2:0>):\n1 = The QEI position counter has reached the MAXCNT value, or the index pulse, INDX, has been detected. Depends on the QEI operating mode enabled. Must be cleared in software.\n0 = The QEI position counter has not reached the MAXCNT value or the index pulse has not been detected",
    "bit 1 IC1 Enabled (CAP1CON<3:0>):\n1 = TMR5 value was captured by the active edge on CAP1 input (must be cleared in software)\n0 = TMR5 capture has not occurred",
    "QEI Enabled (QEIM<2:0>), Velocity Measurement Mode Enabled (VELM = 0 in QEICON register):\n1 = Timer5 value was captured by the active velocity edge (based on PHA or PHB input). CAP1REN bit must be set in CAP1CON register. IC1IF must be cleared in software.\n0 = Timer5 value was not captured by the active velocity edge",
    "bit 0 TMR5IF: Timer5 Interrupt Flag bit\n1 = Timer5 time base matched the PR5 value (must be cleared in software)\n0 = Timer5 time base did not match the PR5 value\nbit 3",
    "10.3 PIE Registers\nThe PIE registers contain the individual enable bits for the peripheral interrupts. Due to the number of peripheral interrupt  sources,  there  are  three  Peripheral  Interrupt Enable Registers (PIE1, PIE2 and PIE3). When IPEN = 0 , the PEIE bit must be set to enable any of these peripheral interrupts.",
    "REGISTER 10-7: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nU-0, 1 = R/W-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = ADIE. -, 2 = RCIE. -, 3 = TXIE. -, 4 = SSPIE. -, 5 = CCP1IE. -, 6 = TMR2IE. -, 7 = TMR1IE. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 10-7: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nADIE: A/D Converter Interrupt Enable bit\n1 = Enables the A/D interrupt\n0 = Disables the A/D interrupt\nbit 5\nRCIE: EUSART Receive Interrupt Enable bit\n1 = Enables the EUSART receive interrupt\n0 = Disables the EUSART receive interrupt\nbit 4\nTXIE: EUSART Transmit Interrupt Enable bit\n1 = Enables the EUSART transmit interrupt\n0 = Disables the EUSART transmit interrupt\nbit 3",
    "REGISTER 10-7: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nSSPIE: Synchronous Serial Port Interrupt Enable bit\n1 = Enables the SSP interrupt\n0 = Disables the SSP interrupt",
    "bit 2 CCP1IE: CCP1 Interrupt Enable bit\n1 = Enables the CCP1 interrupt\n0 = Disables the CCP1 interrupt",
    "bit 1\nTMR2IE: TMR2 to PR2 Match Interrupt Enable bit\n1 = Enables the TMR2 to PR2 match interrupt\n0 = Disables the TMR2 to PR2 match interrupt\nbit 0\nTMR1IE: TMR1 Overflow Interrupt Enable bit\n1 = Enables the TMR1 overflow interrupt\n0 = Disables the TMR1 overflow interrupt",
    "REGISTER 10-8: PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-0. R/W-0, 4 = U-0. R/W-0, 5 = R/W-0. R/W-0, 6 = U-0. R/W-0, 7 = R/W-0. OSCFIE, 1 = -. OSCFIE, 2 = -. OSCFIE, 3 = EEIE. OSCFIE, 4 = -. OSCFIE, 5 = LVDIE. OSCFIE, 6 = -. OSCFIE, 7 = CCP2IE. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 10-8: PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 OSCFIE: Oscillator Fail Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 6-5\nUnimplemented: Read as ' 0 '\nbit 4\nEEIE:\nInterrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 3 Unimplemented: Read as '\n0 '\nbit 2\nLVDIE: Low-Voltage Detect Interrupt Enable bit\n1 = Enabled\n0 =  Disabled",
    "bit 1\nUnimplemented: Read as ' 0 '\nbit 0\nCCP2IE: CCP2 Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "REGISTER 10-9: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\n-, U-0 = -. -, U-0 = -. -, R/W-0 = PTIE. -, R/W-0 = IC3DRIE. -, R/W-0 = IC2QEIE. -, R/W-0 = IC1IE. -, R/W-0 = TMR5IE. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "bit 7-5 Unimplemented: Read as ' 0 '\nbit 4\nPTIE: PWM Time Base Interrupt Enable bit\n1 = PTIF enabled\n0 = PTIF disabled\nbit 3\nIC3DRIE: IC3 Interrupt Enable/Direction Change Interrupt Enable bit\nIC3 Enabled (CAP3CON<3:0>):\n1 = IC3 interrupt enabled\n0 = IC3 interrupt disabled",
    "QEI Enabled (QEIM<2:0>):\n1 = Change of direction interrupt enabled\n0 = Change of direction interrupt disabled",
    "bit 2\nIC2QEIE: IC2 Interrupt Flag/QEI Interrupt Flag Enable bit\nIC2 Enabled (CAP2CON<3:0>):\n1 = IC2 interrupt enabled)\n0 = IC2 interrupt disabled",
    "QEI Enabled (QEIM<2:0>):\n1 = QEI interrupt enabled\n0 = QEI interrupt disabled",
    "bit 1\nIC1IE: IC1 Interrupt Enable bit\n1 = IC1 interrupt enabled\n0 = IC1 interrupt disabled",
    "bit 0 TMR5IE: Timer5 Interrupt Enable bit\n1 = Timer5 interrupt enabled\n0 = Timer5 interrupt disabled",
    "10.4 IPR Registers\nThe IPR registers contain the individual priority bits for the peripheral interrupts. Due  to the number  of peripheral interrupt sources, there are three peripheral interrupt  priority  registers  (IPR1,  IPR2  and  IPR3). Using the priority bits requires that the Interrupt Priority Enable (IPEN) bit be set.",
    "REGISTER 10-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\n-, R/W-1 = ADIP. -, R/W-1 = RCIP. -, R/W-1 = TXIP. -, R/W-1 = SSPIP. -, R/W-1 = CCPIP. -, R/W-1 = TMR2IP. -, R/W-1 = TMR1IP. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0",
    "REGISTER 10-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nADIP: A/D Converter Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5\nRC1IP: EUSART Receive Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 4\nTX1IP: EUSART Transmit Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nSSP1IP: Synchronous Serial Port Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2",
    "REGISTER 10-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nCCP1IP: CCP1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nTMR2IP: TMR2 to PR2 Match Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 0\nTMR1IP: TMR1 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 10-11: IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nR/W-1, 1 = U-0. R/W-1, 2 = U-0. R/W-1, 3 = R/W-1. R/W-1, 4 = U-0. R/W-1, 5 = R/W-1. R/W-1, 6 = U-0. R/W-1, 7 = R/W-1. OSCFIP, 1 = -. OSCFIP, 2 = -. OSCFIP, 3 = EEIP. OSCFIP, 4 = -. OSCFIP, 5 = LVDIP. OSCFIP, 6 = -. OSCFIP, 7 = CCP2IP. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 10-11: IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nOSCFIP:\nOscillator Fail Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 6-5\nUnimplemented: Read as ' 0 '\nbit 4\nEEIP: Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 3\nUnimplemented: Read as ' 0 '\nbit 2\nLVDIP: Low-Voltage Detect Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1\nUnimplemented: Read as ' 0 '\nbit 0",
    "REGISTER 10-11: IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nCCP2IP: CCP2 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "REGISTER 10-12: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-1. U-0, 4 = R/W-1. U-0, 5 = R/W-1. U-0, 6 = R/W-1. U-0, 7 = R/W-1. -, 1 = -. -, 2 = -. -, 3 = PTIP. -, 4 = IC3DRIP. -, 5 = IC2QEIP. -, 6 = IC1IP. -, 7 = TMR5IP. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 10-12: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-5 Unimplemented: Read as ' 0 '\nbit 4\nPTIP: PWM Time Base Interrupt Priority bit\n1 = High priority\n0 = Low priority\nIC3DRIP: IC3 Interrupt Priority/Direction Change Interrupt Priority bit",
    "IC3 Enabled (CAP3CON<3:0>):\n1 = IC3 interrupt high priority\n0 = IC3 interrupt low priority",
    "QEI Enabled (QEIM<2:0>):\n1 = Change of direction interrupt high priority\n0 = Change of direction interrupt low priority\nIC2QEIP:\nIC2 Interrupt Priority/QEI Interrupt Priority bit",
    "IC2 Enabled (CAP2CON<3:0>):\n1 = IC2 interrupt high priority\n0 = IC2 interrupt low priority",
    "QEI Enabled (QEIM<2:0>):\n1 = High priority\n0 = Low priority\nIC1IP: IC1 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 0 TMR5IP:\nTimer5 Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 3\nbit 2\nbit 1",
    "10.5 RCON Register\nThe RCON register contains bits used to determine the cause  of  the  last  Reset  or  wake-up  from  a  powermanaged  mode.  RCON  also  contains  the  bit  that enables interrupt priorities (IPEN).",
    "REGISTER 10-13: RCON: RESET CONTROL REGISTER\nIPEN, U-0 = -. IPEN, U-0 = -. IPEN, R/W-1 = RI. IPEN, R-1 = TO. IPEN, R-1 = PD. IPEN, R/W-0 = POR. IPEN, R/W-0 = BOR. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R-1 = bit 7. bit 7, R-1 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 10-13: RCON: RESET CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 IPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16CXXX Compatibility mode)\nbit 6-5 Unimplemented: Read as ' 0 '\nbit 4\nRI: RESET Instruction Flag bit\nFor details of bit operation, see Register 5-1.\nbit 3\nTO: Watchdog Timer Time-out Flag bit\nFor details of bit operation, see Register 5-1.\nbit 2\nPD: Power-Down Detection Flag bit\nFor details of bit operation, see Register 5-1.\nbit 1\nPOR: Power-on Reset Status bit\nFor details of bit operation, see Register 5-1.\nbit 0\nBOR: Brown-out Reset Status bit\nFor details of bit operation, see Register 5-1.",
    "10.7 TMR0 Interrupt\nExternal interrupts on the INT0, INT1 and INT2 pins are edge-triggered. If the corresponding INTEDGx bit in the INTCON2 register is set (= 1 ), the interrupt is triggered by a rising edge. If the bit is clear, the trigger is on the falling edge.\nWhen a valid edge appears on the INTx pin, the corresponding flag bit, INTxIF, is set. This interrupt can be disabled  by  clearing  the  corresponding  enable  bit, INTxIE.  Before  re-enabling  the  interrupt,  the  flag  bit, INTxIF,  must  be  cleared  in  software  in  the  Interrupt Service Routine.\nAll external interrupts (INT0, INT1 and INT2) can wakeup the processor from the Idle or Sleep modes if bit, INTxIE, was set prior to going into those modes. If the Global Interrupt Enable bit, GIE, is set, the processor will branch to the interrupt vector following wake-up.",
    "10.7 TMR0 Interrupt\nIn 8-bit mode  (which  is  the  default),  an  overflow (FFh \uf0ae 00h)  in  the  TMR0  register  will  set  flag  bit, TMR0IF. In 16-bit mode, an overflow (FFFFh \uf0ae\uf020 0000h) in the TMR0H:TMR0L  registers  will set flag bit, TMR0IF.  The  interrupt  can  be  enabled/disabled  by setting/clearing enable  bit, TMR0IE  (INTCON<5>). Interrupt priority for Timer0 is determined by the value contained in the interrupt priority bit, TMR0IP (INTCON2<2>). See Section 12.0 'Timer0 Module' for further details.",
    "10.8 PORTB Interrupt-on-Change\nInterrupt priority for INT1 and INT2 is determined by the  value  contained  in  the  Interrupt  Priority  bits, INT1IP  (INTCON3<6>)  and  INT2IP  (INTCON3<7>). There  is  no  priority  bit  associated  with  INT0.  It  is always a high-priority interrupt source.\nAn input change on PORTB<7:4> sets flag bit, RBIF (INTCON<0>). The interrupt can be enabled/disabled by  setting/clearing  enable  bit,  RBIE  (INTCON<3>). Interrupt  priority  for  PORTB  interrupt-on-change  is determined  by  the  value  contained  in  the  interrupt priority bit, RBIP (INTCON2<0>).",
    "10.9 Context Saving During Interrupts\nDuring interrupts, the return PC address is saved on the stack. Additionally, the WREG, STATUS and BSR registers are saved on the fast return stack. If a fast return  from  interrupt  is  not  used  (see Section 6.1.3 'Fast Register Stack' ), the user may need to save the WREG,  STATUS  and  BSR  registers  on  entry  to  the Interrupt  Service  Routine.  Depending  on  the  user's application, other registers may also need to be saved. Example 10-1 saves and restores the WREG, STATUS and BSR registers during an Interrupt Service Routine.",
    "EXAMPLE 10-1: SAVING STATUS, WREG AND BSR REGISTERS IN RAM\nMOVWF MOVFF MOVFF ; ; ;, 1 = W_TEMP. MOVWF MOVFF MOVFF ; ; ;, 2 = ; W_TEMP is in virtual bank. , 1 = STATUS, STATUS_TEMP. , 2 = ; STATUS_TEMP located anywhere. , 1 = BSR, BSR_TEMP. , 2 = ; BSR_TMEP located anywhere. USER, 1 = ISR CODE. USER, 2 = . MOVFF, 1 = BSR_TEMP, BSR. MOVFF, 2 = ; Restore BSR. MOVF, 1 = W_TEMP, W. MOVF, 2 = ; Restore WREG. MOVFF, 1 = STATUS_TEMP, STATUS. MOVFF, 2 = ; Restore STATUS",
    "11.0 I/O PORTS\nDepending on the device selected and features enabled, there are up to five ports available. Some pins of  the  I/O  ports  are  multiplexed  with  an  alternate function from the peripheral features on the device. In general, when a peripheral is enabled, that pin may not be used as a general purpose I/O pin.\nEach port has three registers for its operation. These registers are:\n\u00b7 TRIS register (Data Direction register)\n\u00b7 PORT register (reads the levels on the pins of the device)\n\u00b7 LAT register (Data Latch)\nThe Data Latch (LAT register) is useful for read-modifywrite  operations  on  the  value  that  the  I/O  pins  are driving.\nA  simplified  model  of  a  generic  I/O  port  without  the interfaces to other peripherals is shown in Figure 11-1.",
    "11.1 PORTA, TRISA and LATA Registers\nPORTA is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISA.  Setting  a TRISA bit (= 1 ) will make the corresponding PORTA pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISA bit (= 0 ) will make the corresponding PORTA pin an output (i.e., put the contents of the output latch on the selected pin).\nReading the  PORTA register reads the  status of  the pins, whereas writing to it, will write to the port latch.\nThe Data Latch register (LATA) is also memory mapped. Read-modify-write operations on the LATA register read and write the latched output value for PORTA.",
    "11.1 PORTA, TRISA and LATA Registers\nThe  RA<4:2>  pins  are  multiplexed  with  three  input capture pins and Quadrature Encoder Interface pins. Pins,  RA6  and  RA7,  are  multiplexed  with  the  main oscillator  pins.  They  are  enabled  as  oscillator  or  I/O pins by the selection of the main oscillator in Configuration Register 1H (see Section 23.1 'Configuration Bits' for details). When they are not used as port pins, RA6 and RA7 and their associated TRIS and LAT bits are read as ' 0 '.\nThe  other  PORTA  pins  are  multiplexed  with  analog inputs, the analog VREF+ and VREF- inputs and the comparator voltage reference output. The operation of pins RA<3:0> and RA5 as A/D Converter inputs is selected by clearing/setting the control bits in the ANSEL0 and ANSEL1 registers.",
    "11.1 PORTA, TRISA and LATA Registers\nNote, 1 = 1: On a Power-on Reset, RA<5:0> are configured as analog inputs andread as ' 0 '.. 2:, 1 = RA5 I/F is available only on 40-pin devices (PIC18F4331/4431).\nThe  TRISA  register  controls  the  direction  of  the  RA pins, even when they are being used as analog inputs. The user must ensure the bits in the TRISA register are maintained set when using them as analog inputs.",
    "EXAMPLE 11-1: INITIALIZING PORTA\nCLRF, 1 = PORTA. CLRF, 2 = ; Initialize PORTA by ; clearing output ; data latches. CLRF, 1 = LATA. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF MOVLW, 1 = 0x3F ANSEL0 0xCF. MOVLW MOVWF MOVLW, 2 = ; Configure A/D ; for digital inputs ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISA. MOVWF, 2 = ; Set RA<3:0> as inputs ; RA<5:4> as outputs",
    "TABLE 11-1: PORTA I/O SUMMARY\nRA0/AN0, Function = RA0. RA0/AN0, TRIS Setting = 0. RA0/AN0, I/O = O. RA0/AN0, I/O Type = DIG. RA0/AN0, Description = LATA<0> data output; not affected by analog input.. RA0/AN0, Function = RA0. RA0/AN0, TRIS Setting = 1. RA0/AN0, I/O = I. RA0/AN0, I/O Type = TTL. RA0/AN0, Description = PORTA<0> data input; disabled when analog input is enabled.. RA0/AN0, Function = AN0. RA0/AN0, TRIS Setting = 1. RA0/AN0, I/O = I. RA0/AN0, I/O Type = ANA. RA0/AN0, Description = A/D Input Channel 0. Default input configuration on POR; does not affect digital output.. RA1/AN1, Function = RA1. RA1/AN1, TRIS Setting = 0.",
    "TABLE 11-1: PORTA I/O SUMMARY\nRA1/AN1, I/O = O. RA1/AN1, I/O Type = DIG. RA1/AN1, Description = LATA<1> data output; not affected by analog input.. RA1/AN1, Function = RA1. RA1/AN1, TRIS Setting = 1. RA1/AN1, I/O = I. RA1/AN1, I/O Type = TTL. RA1/AN1, Description = PORTA<1> data input; disabled when analog input is enabled.. RA1/AN1, Function = AN1. RA1/AN1, TRIS Setting = 1. RA1/AN1, I/O = I. RA1/AN1, I/O Type = ANA. RA1/AN1, Description = A/D Input Channel 1. Default input configuration on POR; does not affect digital output.. RA2/AN2/VREF-/ CAP1/INDX, Function = RA2. RA2/AN2/VREF-/ CAP1/INDX, TRIS Setting = 0.",
    "TABLE 11-1: PORTA I/O SUMMARY\nRA2/AN2/VREF-/ CAP1/INDX, I/O = O. RA2/AN2/VREF-/ CAP1/INDX, I/O Type = DIG. RA2/AN2/VREF-/ CAP1/INDX, Description = LATA<2> data output; not affected by analog input.. RA2/AN2/VREF-/ CAP1/INDX, Function = RA2. RA2/AN2/VREF-/ CAP1/INDX, TRIS Setting = 1. RA2/AN2/VREF-/ CAP1/INDX, I/O = I. RA2/AN2/VREF-/ CAP1/INDX, I/O Type = TTL. RA2/AN2/VREF-/ CAP1/INDX, Description = PORTA<2> data input. Disabled when analog input is enabled.. RA2/AN2/VREF-/ CAP1/INDX, Function = AN2. RA2/AN2/VREF-/ CAP1/INDX, TRIS Setting = 1.",
    "TABLE 11-1: PORTA I/O SUMMARY\nRA2/AN2/VREF-/ CAP1/INDX, I/O = I. RA2/AN2/VREF-/ CAP1/INDX, I/O Type = ANA. RA2/AN2/VREF-/ CAP1/INDX, Description = A/D Input Channel 2. Default input configuration on POR.. RA2/AN2/VREF-/ CAP1/INDX, Function = VREF-. RA2/AN2/VREF-/ CAP1/INDX, TRIS Setting = 1. RA2/AN2/VREF-/ CAP1/INDX, I/O = I. RA2/AN2/VREF-/ CAP1/INDX, I/O Type = ANA. RA2/AN2/VREF-/ CAP1/INDX, Description = A/D voltage reference low input.. RA2/AN2/VREF-/ CAP1/INDX, Function = CAP1. RA2/AN2/VREF-/ CAP1/INDX, TRIS Setting = 1.",
    "TABLE 11-1: PORTA I/O SUMMARY\nRA2/AN2/VREF-/ CAP1/INDX, I/O = I. RA2/AN2/VREF-/ CAP1/INDX, I/O Type = ST. RA2/AN2/VREF-/ CAP1/INDX, Description = Input Capture Pin 1. Disabled when analog input is enabled.. RA2/AN2/VREF-/ CAP1/INDX, Function = INDX. RA2/AN2/VREF-/ CAP1/INDX, TRIS Setting = 1. RA2/AN2/VREF-/ CAP1/INDX, I/O = I. RA2/AN2/VREF-/ CAP1/INDX, I/O Type = ST. RA2/AN2/VREF-/ CAP1/INDX, Description = Quadrature Encoder Interface index input pin. Disabled when analog input is enabled.. RA3/AN3/VREF+/ CAP2/QEA, Function = RA3. RA3/AN3/VREF+/ CAP2/QEA, TRIS Setting = 0.",
    "TABLE 11-1: PORTA I/O SUMMARY\nRA3/AN3/VREF+/ CAP2/QEA, I/O = O. RA3/AN3/VREF+/ CAP2/QEA, I/O Type = DIG. RA3/AN3/VREF+/ CAP2/QEA, Description = LATA<3> data output; not affected by analog input.. RA3/AN3/VREF+/ CAP2/QEA, Function = RA3. RA3/AN3/VREF+/ CAP2/QEA, TRIS Setting = 1. RA3/AN3/VREF+/ CAP2/QEA, I/O = I. RA3/AN3/VREF+/ CAP2/QEA, I/O Type = TTL. RA3/AN3/VREF+/ CAP2/QEA, Description = PORTA<3> data input; disabled when analog input is enabled.. RA3/AN3/VREF+/ CAP2/QEA, Function = AN3. RA3/AN3/VREF+/ CAP2/QEA, TRIS Setting = 1.",
    "TABLE 11-1: PORTA I/O SUMMARY\nRA3/AN3/VREF+/ CAP2/QEA, I/O = I. RA3/AN3/VREF+/ CAP2/QEA, I/O Type = ANA. RA3/AN3/VREF+/ CAP2/QEA, Description = A/D Input Channel 3. Default input configuration on POR.. RA3/AN3/VREF+/ CAP2/QEA, Function = VREF+. RA3/AN3/VREF+/ CAP2/QEA, TRIS Setting = 1. RA3/AN3/VREF+/ CAP2/QEA, I/O = I. RA3/AN3/VREF+/ CAP2/QEA, I/O Type = ANA. RA3/AN3/VREF+/ CAP2/QEA, Description = A/D voltage reference high input.. RA3/AN3/VREF+/ CAP2/QEA, Function = CAP2. RA3/AN3/VREF+/ CAP2/QEA, TRIS Setting = 1.",
    "TABLE 11-1: PORTA I/O SUMMARY\nRA3/AN3/VREF+/ CAP2/QEA, I/O = I. RA3/AN3/VREF+/ CAP2/QEA, I/O Type = ST. RA3/AN3/VREF+/ CAP2/QEA, Description = Input Capture Pin 2. Disabled when analog input is enabled.. RA3/AN3/VREF+/ CAP2/QEA, Function = QEA. RA3/AN3/VREF+/ CAP2/QEA, TRIS Setting = 1. RA3/AN3/VREF+/ CAP2/QEA, I/O = I. RA3/AN3/VREF+/ CAP2/QEA, I/O Type = ST. RA3/AN3/VREF+/ CAP2/QEA, Description = Quadrature Encoder Interface Channel A input pin. Disabled when analog input is enabled.. RA4/AN4/CAP3/ QEB, Function = RA4. RA4/AN4/CAP3/ QEB, TRIS Setting = 0.",
    "TABLE 11-1: PORTA I/O SUMMARY\nRA4/AN4/CAP3/ QEB, I/O = O. RA4/AN4/CAP3/ QEB, I/O Type = DIG. RA4/AN4/CAP3/ QEB, Description = LATA<4> data output; not affected by analog input.. RA4/AN4/CAP3/ QEB, Function = RA4. RA4/AN4/CAP3/ QEB, TRIS Setting = 1. RA4/AN4/CAP3/ QEB, I/O = I. RA4/AN4/CAP3/ QEB, I/O Type = ST. RA4/AN4/CAP3/ QEB, Description = PORTA<4> data input; disabled when analog input is enabled.. RA4/AN4/CAP3/ QEB, Function = AN4. RA4/AN4/CAP3/ QEB, TRIS Setting = 1. RA4/AN4/CAP3/ QEB, I/O = I. RA4/AN4/CAP3/ QEB, I/O Type = ANA.",
    "TABLE 11-1: PORTA I/O SUMMARY\nRA4/AN4/CAP3/ QEB, Description = A/D Input Channel 4. Default input configuration on POR.. RA4/AN4/CAP3/ QEB, Function = CAP3. RA4/AN4/CAP3/ QEB, TRIS Setting = 1. RA4/AN4/CAP3/ QEB, I/O = I. RA4/AN4/CAP3/ QEB, I/O Type = ST. RA4/AN4/CAP3/ QEB, Description = Input Capture Pin 3. Disabled when analog input is enabled.. RA4/AN4/CAP3/ QEB, Function = QEB. RA4/AN4/CAP3/ QEB, TRIS Setting = 1. RA4/AN4/CAP3/ QEB, I/O = I. RA4/AN4/CAP3/ QEB, I/O Type = ST. RA4/AN4/CAP3/ QEB, Description = Quadrature Encoder Interface Channel B input pin. Disabled when analog input is enabled.. RA5/AN5/LVDIN, Function =",
    "TABLE 11-1: PORTA I/O SUMMARY\nRA5. RA5/AN5/LVDIN, TRIS Setting = 0. RA5/AN5/LVDIN, I/O = O. RA5/AN5/LVDIN, I/O Type = DIG. RA5/AN5/LVDIN, Description = LATA<5> data output; not affected by analog input.. RA5/AN5/LVDIN, Function = RA5. RA5/AN5/LVDIN, TRIS Setting = 1. RA5/AN5/LVDIN, I/O = I. RA5/AN5/LVDIN, I/O Type = TTL. RA5/AN5/LVDIN, Description = PORTA<5> data input; disabled when analog input is enabled.. RA5/AN5/LVDIN, Function = AN5. RA5/AN5/LVDIN, TRIS Setting = 1. RA5/AN5/LVDIN, I/O = I. RA5/AN5/LVDIN, I/O Type = ANA.",
    "TABLE 11-1: PORTA I/O SUMMARY\nRA5/AN5/LVDIN, Description = A/D Input Channel 5. Default configuration on POR.. RA5/AN5/LVDIN, Function = LVDIN. RA5/AN5/LVDIN, TRIS Setting = 1. RA5/AN5/LVDIN, I/O = I. RA5/AN5/LVDIN, I/O Type = ANA. RA5/AN5/LVDIN, Description = Low-Voltage Detect external trip point input.. OSC2/CLKO/RA6, Function = OSC2. OSC2/CLKO/RA6, TRIS Setting = x. OSC2/CLKO/RA6, I/O = O. OSC2/CLKO/RA6, I/O Type = ANA. OSC2/CLKO/RA6, Description = Main oscillator feedback output connection (XT, HS and LP modes).. OSC2/CLKO/RA6, Function = CLKO. OSC2/CLKO/RA6, TRIS Setting = x.",
    "TABLE 11-1: PORTA I/O SUMMARY\nOSC2/CLKO/RA6, I/O = O. OSC2/CLKO/RA6, I/O Type = DIG. OSC2/CLKO/RA6, Description = System cycle clock output (F OSC/4) in RC, INTIO1 and EC Oscillator modes.. OSC2/CLKO/RA6, Function = RA6. OSC2/CLKO/RA6, TRIS Setting = 0. OSC2/CLKO/RA6, I/O = O. OSC2/CLKO/RA6, I/O Type = DIG. OSC2/CLKO/RA6, Description = LATA<6> data output. Enabled in RCIO, INTIO2 and ECIO modes only.. OSC2/CLKO/RA6, Function = RA6. OSC2/CLKO/RA6, TRIS Setting = 1. OSC2/CLKO/RA6, I/O = I. OSC2/CLKO/RA6, I/O Type = TTL. OSC2/CLKO/RA6,",
    "TABLE 11-1: PORTA I/O SUMMARY\nDescription = PORTA<6> data input. Enabled in RCIO, INTIO2 and ECIO modes only.. OSC1/CLKI/RA7, Function = OSC1. OSC1/CLKI/RA7, TRIS Setting = x. OSC1/CLKI/RA7, I/O = I. OSC1/CLKI/RA7, I/O Type = ANA. OSC1/CLKI/RA7, Description = Main oscillator input connection.. OSC1/CLKI/RA7, Function = CLKI. OSC1/CLKI/RA7, TRIS Setting = x. OSC1/CLKI/RA7, I/O = I. OSC1/CLKI/RA7, I/O Type = ANA. OSC1/CLKI/RA7, Description = Main clock input connection.. OSC1/CLKI/RA7, Function = RA7. OSC1/CLKI/RA7, TRIS Setting = 0. OSC1/CLKI/RA7, I/O = O.",
    "TABLE 11-1: PORTA I/O SUMMARY\nOSC1/CLKI/RA7, I/O Type = DIG. OSC1/CLKI/RA7, Description = LATA<7> data output. Disabled in external oscillator modes.. OSC1/CLKI/RA7, Function = . OSC1/CLKI/RA7, TRIS Setting = 1. OSC1/CLKI/RA7, I/O = I. OSC1/CLKI/RA7, I/O Type = TTL. OSC1/CLKI/RA7, Description = PORTA<7> data input. Disabled in external oscillator modes.\nDIG = Digital level output; TTL = TTL input buffer; ST = Schmitt Trigger input buffer; ANA = Analog level input/output; = Don't care (TRIS bit does not affect port direction or is overridden for this option).\nLegend: x",
    "TABLE 11-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nPORTA, Bit 7 = RA7 (1). PORTA, Bit 6 = RA6 (1). PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Reset Values on Page: = 57. LATA, Bit 7 = LATA7 (1). LATA, Bit 6 = LATA6 (1). LATA, Bit 5 = LATA Data Output Register. LATA, Bit 4 = LATA Data Output Register. LATA, Bit 3 = LATA Data Output Register. LATA, Bit 2 = LATA Data Output Register. LATA, Bit 1 = LATA Data Output Register. LATA, Bit 0 = LATA Data Output Register. LATA, Reset Values on Page: = 57. TRISA, Bit 7 = TRISA7 (1). TRISA, Bit 6 = TRISA6 (1). TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA",
    "TABLE 11-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nData Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Reset Values on Page: = 57. ADCON1, Bit 7 = VCFG1. ADCON1, Bit 6 = VCFG0. ADCON1, Bit 5 = -. ADCON1, Bit 4 = FIFOEN. ADCON1, Bit 3 = BFEMT. ADCON1, Bit 2 = BFOVFL. ADCON1, Bit 1 = ADPNT1. ADCON1, Bit 0 = ADPNT0. ADCON1, Reset Values on Page: = 56. ANSEL0, Bit 7 = ANS7 (2). ANSEL0, Bit 6 = ANS6 (2). ANSEL0, Bit 5 = ANS5 (2). ANSEL0, Bit 4 = ANS4. ANSEL0, Bit 3 = ANS3. ANSEL0, Bit 2 = ANS2. ANSEL0,",
    "TABLE 11-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nBit 1 = ANS1. ANSEL0, Bit 0 = ANS0. ANSEL0, Reset Values on Page: = 56. ANSEL1, Bit 7 = -. ANSEL1, Bit 6 = -. ANSEL1, Bit 5 = -. ANSEL1, Bit 4 = -. ANSEL1, Bit 3 = -. ANSEL1, Bit 2 = -. ANSEL1, Bit 1 = -. ANSEL1, Bit 0 = ANS8 (2). ANSEL1, Reset Values on Page: = 56\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by PORTA.\nNote 1: RA<7:6> and their associated latch and data direction bits are enabled as I/O pins based on oscillator configuration; otherwise, they are read as ' 0 '.\n2: ANS5 through ANS8 are available only on the PIC18F4331/4431 devices.",
    "11.2 PORTB, TRISB and LATB Registers\nPORTB is an 8-bit wide, bidirectional port. The corresponding Data Direction register is  TRISB.  Setting  a TRISB bit (= 1 )  will  make the corresponding PORTB pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISB bit (= 0 ) will make the corresponding PORTB pin an output (i.e., put the contents of the output latch on the selected pin).\nFour of the PORTB pins (RB<7:4>) have an interrupton-change feature. Only pins configured as inputs can cause  this  interrupt  to  occur  (i.e.,  any  RB<7:4>  pin configured as an output is excluded from the interrupton-change comparison). The input pins (of RB<7:4>) are  compared  with  the  old  value  latched  on  the  last read of PORTB. The 'mismatch' outputs of RB<7:4> are  ORed  together  to  generate  the  RB  port  change interrupt with flag bit, RBIF (INTCON<0>).",
    "11.2 PORTB, TRISB and LATB Registers\nThe  Data  Latch  register (LATB)  is also memory mapped.  Read-modify-write  operations  on  the  LATB register  read  and  write  the  latched  output  value  for PORTB.",
    "EXAMPLE 11-2: INITIALIZING PORTB\nCLRF, 1 = PORTB. CLRF, 2 = ; Initialize PORTB by ; clearing output ; data latches. CLRF, 1 = LATB. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0xCF. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISB. MOVWF, 2 = ; Set RB<3:0> as inputs ; RB<5:4> as outputs ; RB<7:6> as inputs\nEach of the PORTB pins has a weak internal pull-up. A single  control  bit  can  turn  on  all  the  pull-ups.  This  is performed by clearing bit RBPU (INTCON2<7>). The weak pull-up is automatically turned off when the port pin  is configured  as  an  output.  The  pull-ups  are disabled on a Power-on Reset.\nThis  interrupt  can  wake  the  device  from  Sleep.  The user,  in  the  Interrupt  Service  Routine,  can  clear  the interrupt in the following manner:",
    "EXAMPLE 11-2: INITIALIZING PORTB\na) Any  read  or  write  of  PORTB  (except  with  the MOVFF (ANY), PORTB instruction).\nb) NOP (or any 1 TCY delay).\nc) Clear flag bit, RBIF.\nA mismatch condition will continue to set flag bit, RBIF. Reading  PORTB  and  waiting  1  TCY  will  end  the mismatch  condition  and  allow  flag  bit,  RBIF,  to  be cleared. Also, if the port pin returns to its original state, the mismatch condition will be cleared.\nThe interrupt-on-change  feature  is  recommended  for wake-up on key depression operation and operations where PORTB is only used for the interrupt-on-change feature. Polling of PORTB is not recommended while using the interrupt-on-change feature.\nRB<3:0> and RB4 pins are multiplexed with the 14-bit PWM module for PWM<3:0> and PWM5 output. The RB5 pin  can  be  configured  by  the  Configuration  bit, PWM4MX, as the alternate pin for PWM4 output.",
    "TABLE 11-3: PORTB I/O SUMMARY\nRB0/PWM0, Function = RB0. RB0/PWM0, TRIS Setting = 0. RB0/PWM0, I/O = O. RB0/PWM0, I/O Type = DIG. RB0/PWM0, Description = LATB<0> data output; not affected by analog input.. RB0/PWM0, Function = RB0. RB0/PWM0, TRIS Setting = 1. RB0/PWM0, I/O = I. RB0/PWM0, I/O Type = TTL. RB0/PWM0, Description = PORTB<0> data input; weak pull-up when RBPU bit is cleared. Disabled when analog input is enabled.. RB0/PWM0, Function = PWM0. RB0/PWM0, TRIS Setting = 0. RB0/PWM0, I/O = O. RB0/PWM0, I/O Type = DIG. RB0/PWM0, Description =",
    "TABLE 11-3: PORTB I/O SUMMARY\nPWM Output 0.. RB1/PWM1, Function = RB1. RB1/PWM1, TRIS Setting = 0. RB1/PWM1, I/O = O. RB1/PWM1, I/O Type = DIG. RB1/PWM1, Description = LATB<1> data output; not affected by analog input.. RB1/PWM1, Function = RB1. RB1/PWM1, TRIS Setting = 1. RB1/PWM1, I/O = I. RB1/PWM1, I/O Type = TTL. RB1/PWM1, Description = PORTB<1> data input; weak pull-up when RBPU bit is cleared. Disabled when analog input is enabled.. RB1/PWM1, Function = PWM1. RB1/PWM1, TRIS Setting = 0. RB1/PWM1, I/O = O. RB1/PWM1, I/O Type = DIG.",
    "TABLE 11-3: PORTB I/O SUMMARY\nRB1/PWM1, Description = PWM Output 1.. RB2/PWM2, Function = RB2. RB2/PWM2, TRIS Setting = 0. RB2/PWM2, I/O = O. RB2/PWM2, I/O Type = DIG. RB2/PWM2, Description = LATB<2> data output; not affected by analog input.. RB2/PWM2, Function = RB2. RB2/PWM2, TRIS Setting = 1. RB2/PWM2, I/O = I. RB2/PWM2, I/O Type = TTL. RB2/PWM2, Description = PORTB<2> data input; weak pull-up when RBPU bit is cleared. Disabled when analog input is enabled.. RB2/PWM2, Function = PWM2. RB2/PWM2, TRIS Setting = 0. RB2/PWM2, I/O = O. RB2/PWM2,",
    "TABLE 11-3: PORTB I/O SUMMARY\nI/O Type = DIG. RB2/PWM2, Description = PWM Output 2.. RB3/PWM3, Function = RB3. RB3/PWM3, TRIS Setting = 0. RB3/PWM3, I/O = O. RB3/PWM3, I/O Type = DIG. RB3/PWM3, Description = LATB<3> data output; not affected by analog input.. RB3/PWM3, Function = RB3. RB3/PWM3, TRIS Setting = 1. RB3/PWM3, I/O = I. RB3/PWM3, I/O Type = TTL. RB3/PWM3, Description = PORTB<3> data input; weak pull-up when RBPU bit is cleared. Disabled when analog input is enabled.. RB3/PWM3, Function = PWM3. RB3/PWM3, TRIS Setting = 0. RB3/PWM3, I/O = O.",
    "TABLE 11-3: PORTB I/O SUMMARY\nRB3/PWM3, I/O Type = DIG. RB3/PWM3, Description = PWM Output 3.. RB4/KBI0/PWM5, Function = RB4. RB4/KBI0/PWM5, TRIS Setting = 0. RB4/KBI0/PWM5, I/O = O. RB4/KBI0/PWM5, I/O Type = DIG. RB4/KBI0/PWM5, Description = LATB<4> data output; not affected by analog input.. RB4/KBI0/PWM5, Function = RB4. RB4/KBI0/PWM5, TRIS Setting = 1. RB4/KBI0/PWM5, I/O = I. RB4/KBI0/PWM5, I/O Type = TTL. RB4/KBI0/PWM5, Description = PORTB<4> data input; weak pull-up when RBPU bit is cleared. Disabled when analog input is",
    "TABLE 11-3: PORTB I/O SUMMARY\nenabled.. RB4/KBI0/PWM5, Function = KBI0. RB4/KBI0/PWM5, TRIS Setting = 1. RB4/KBI0/PWM5, I/O = I. RB4/KBI0/PWM5, I/O Type = TTL. RB4/KBI0/PWM5, Description = Interrupt-on-change pin.. RB4/KBI0/PWM5, Function = PWM5. RB4/KBI0/PWM5, TRIS Setting = 0. RB4/KBI0/PWM5, I/O = O. RB4/KBI0/PWM5, I/O Type = DIG. RB4/KBI0/PWM5, Description = PWM Output 5.. RB5/KBI1/ PWM4/PGM, Function = RB5. RB5/KBI1/ PWM4/PGM, TRIS Setting = 0. RB5/KBI1/",
    "TABLE 11-3: PORTB I/O SUMMARY\nPWM4/PGM, I/O = O. RB5/KBI1/ PWM4/PGM, I/O Type = DIG. RB5/KBI1/ PWM4/PGM, Description = LATB<5> data output.. RB5/KBI1/ PWM4/PGM, Function = RB5. RB5/KBI1/ PWM4/PGM, TRIS Setting = 1. RB5/KBI1/ PWM4/PGM, I/O = I. RB5/KBI1/ PWM4/PGM, I/O Type = TTL. RB5/KBI1/ PWM4/PGM, Description = PORTB<5> data input; weak pull-up when RBPU bit is cleared.. RB5/KBI1/ PWM4/PGM, Function = KBI1. RB5/KBI1/ PWM4/PGM, TRIS Setting = 1. RB5/KBI1/ PWM4/PGM, I/O",
    "TABLE 11-3: PORTB I/O SUMMARY\n= I. RB5/KBI1/ PWM4/PGM, I/O Type = TTL. RB5/KBI1/ PWM4/PGM, Description = Interrupt-on-change pin.. RB5/KBI1/ PWM4/PGM, Function = PWM4 (3). RB5/KBI1/ PWM4/PGM, TRIS Setting = 0. RB5/KBI1/ PWM4/PGM, I/O = O. RB5/KBI1/ PWM4/PGM, I/O Type = DIG. RB5/KBI1/ PWM4/PGM, Description = PWM Output 4; takes priority over port data.. RB5/KBI1/ PWM4/PGM, Function = PGM (2). RB5/KBI1/ PWM4/PGM, TRIS Setting = x. RB5/KBI1/ PWM4/PGM, I/O = I. RB5/KBI1/",
    "TABLE 11-3: PORTB I/O SUMMARY\nPWM4/PGM, I/O Type = ST. RB5/KBI1/ PWM4/PGM, Description = Single-Supply Programming mode entry (ICSP\u2122). Enabled by LVP Configuration bit; all other pin functions are disabled.. RB6/KBI2/PGC, Function = RB6. RB6/KBI2/PGC, TRIS Setting = 0. RB6/KBI2/PGC, I/O = O. RB6/KBI2/PGC, I/O Type = DIG. RB6/KBI2/PGC, Description = LATB<6> data output.. RB6/KBI2/PGC, Function = RB6. RB6/KBI2/PGC, TRIS Setting = 1. RB6/KBI2/PGC, I/O = I. RB6/KBI2/PGC, I/O Type = TTL. RB6/KBI2/PGC, Description = PORTB<6> data input; weak pull-up when RBPU bit is cleared..",
    "TABLE 11-3: PORTB I/O SUMMARY\nRB6/KBI2/PGC, Function = KBI2. RB6/KBI2/PGC, TRIS Setting = 1. RB6/KBI2/PGC, I/O = I. RB6/KBI2/PGC, I/O Type = TTL. RB6/KBI2/PGC, Description = Interrupt-on-change pin.. RB6/KBI2/PGC, Function = PGC. RB6/KBI2/PGC, TRIS Setting = x. RB6/KBI2/PGC, I/O = I. RB6/KBI2/PGC, I/O Type = ST. RB6/KBI2/PGC, Description = Serial execution (ICSP\u2122) clock input for ICSP and ICD operation. (1). RB7/KBI3/PGD, Function = RB7. RB7/KBI3/PGD, TRIS Setting = 0. RB7/KBI3/PGD, I/O = O. RB7/KBI3/PGD, I/O Type =",
    "TABLE 11-3: PORTB I/O SUMMARY\nDIG. RB7/KBI3/PGD, Description = LATB<7> data output.. RB7/KBI3/PGD, Function = RB7. RB7/KBI3/PGD, TRIS Setting = 1. RB7/KBI3/PGD, I/O = I. RB7/KBI3/PGD, I/O Type = TTL. RB7/KBI3/PGD, Description = PORTB<7> data input; weak pull-up when RBPU bit is cleared.. RB7/KBI3/PGD, Function = KBI3. RB7/KBI3/PGD, TRIS Setting = 1. RB7/KBI3/PGD, I/O = I. RB7/KBI3/PGD, I/O Type = TTL. RB7/KBI3/PGD, Description = Interrupt-on-change pin.. RB7/KBI3/PGD, Function = PGD. RB7/KBI3/PGD, TRIS Setting = x.",
    "TABLE 11-3: PORTB I/O SUMMARY\nRB7/KBI3/PGD, I/O = O. RB7/KBI3/PGD, I/O Type = DIG. RB7/KBI3/PGD, Description = Serial execution data output for ICSP and ICD operation. (1). RB7/KBI3/PGD, Function = . RB7/KBI3/PGD, TRIS Setting = x. RB7/KBI3/PGD, I/O = I. RB7/KBI3/PGD, I/O Type = ST. RB7/KBI3/PGD, Description = Serial execution data input for ICSP and ICD operation. (1)\nLegend:\nDIG = Digital level output; TTL = TTL input buffer; ST = Schmitt Trigger input buffer; ANA = Analog level input/output; x = Don't care (TRIS bit does not affect port direction or is overridden for this option).\nNote",
    "TABLE 11-3: PORTB I/O SUMMARY\n1: All other pin functions are disabled when ICSP or ICD is enabled.\n2: Single-Supply Programming must be enabled.\n3: RD5 is the alternate pin for PWM4.",
    "TABLE 11-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nPORTB, Bit 7 = RB7. PORTB, Bit 6 = RB6. PORTB, Bit 5 = RB5. PORTB, Bit 4 = RB4. PORTB, Bit 3 = RB3. PORTB, Bit 2 = RB2. PORTB, Bit 1 = RB1. PORTB, Bit 0 = RB0. PORTB, Reset Values on Page: = 57. LATB, Bit 7 = LATB Data Output Register. LATB, Bit 6 = LATB Data Output Register. LATB, Bit 5 = LATB Data Output Register. LATB, Bit 4 = LATB Data Output Register. LATB, Bit 3 = LATB Data Output Register. LATB, Bit 2 = LATB Data Output Register. LATB, Bit 1 = LATB Data Output Register. LATB, Bit 0 = LATB Data Output Register. LATB, Reset Values on Page: = 57. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register.",
    "TABLE 11-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nTRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Reset Values on Page: = 57. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = -. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 =",
    "TABLE 11-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\n-. INTCON2, Bit 0 = RBIP. INTCON2, Reset Values on Page: = 54. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Reset Values on Page: = 54\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by PORTB.",
    "11.3 PORTC, TRISC and LATC Registers\nExternal interrupts, IN0, INT1 and INT2, are placed on RC3, RC4 and RC5 pins, respectively.\nPORTC is an 8-bit wide, bidirectional port. The corresponding Data Direction register is  TRISC.  Setting a TRISC bit (= 1 )  will  make the corresponding PORTC pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISC bit (= 0 ) will make the corresponding PORTC pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATC)  is  also memory mapped.  Read-modify-write  operations  on  the  LATC register  read  and  write  the  latched  output  value  for PORTC.\nPORTC is multiplexed with several peripheral functions (Table 11-5).  The  pins  have  Schmitt  Trigger  input buffers.",
    "11.3 PORTC, TRISC and LATC Registers\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTC pin. Some peripherals override the TRIS bit to make a pin an output, while other peripherals override the TRIS bit to make a pin an input. The user should refer to the corresponding peripheral section for the correct TRIS bit settings.\nNote:\nOn  a  Power-on  Reset,  these  pins  are configured as digital inputs.\nThe  contents  of  the  TRISC  register  are  affected  by peripheral  overrides.  Reading  TRISC  always  returns the current contents, even though a peripheral device may be overriding one or more of the pins.\nSSP alternate interface pins, SDI/SDA, SCK/SCL and SDO  are  placed on RC4,  RC5  and  RC7  pins, respectively.\nThese pins are multiplexed on PORTC and PORTD by using the SSPMX bit in the CONFIG3L register.\nEUSART pins RX/DT and TX/CK are placed on RC7 and RC6 pins, respectively.",
    "11.3 PORTC, TRISC and LATC Registers\nThe alternate Timer5 external clock input, T5CKI, and the  alternate  TMR0  external  clock  input,  T0CKI,  are placed on RC3 and are multiplexed with the PORTD (RD0)  pin  using  the  EXCLKMX  Configuration  bit  in CONFIG3H. Fault inputs to the 14-bit PWM module, FLTA and FLTB, are located on RC1 and RC2. FLTA input  on  RC1  is  multiplexed  with  RD4  using  the FLTAMX bit.\nThe  contents  of  the  TRISC  register  are  affected  by peripheral  overrides.  Reading  TRISC  always  returns the current contents, even though a peripheral device may be overriding one or more of the pins.",
    "11.3 PORTC, TRISC and LATC Registers\nCLRF, EXAMPLE 11-3: = PORTC. CLRF, INITIALIZING PORTC = ; Initialize PORTC by ; clearing output ; data latches. CLRF, EXAMPLE 11-3: = LATC. CLRF, INITIALIZING PORTC = ; Alternate method ; to clear output ; data latches. MOVLW, EXAMPLE 11-3: = 0xCF. MOVLW, INITIALIZING PORTC = ; Value used to ; initialize data ; direction. MOVWF, EXAMPLE 11-3: = TRISC. MOVWF, INITIALIZING PORTC = ; Set RC<3:0> as inputs ; RC<5:4> as outputs ; RC<7:6> as inputs",
    "TABLE 11-5: PORTC I/O SUMMARY\nRC0/T1OSO/ T1CKI, Function = RC0. RC0/T1OSO/ T1CKI, TRIS Setting = 0. RC0/T1OSO/ T1CKI, I/O = O. RC0/T1OSO/ T1CKI, I/O Type = DIG. RC0/T1OSO/ T1CKI, Description = LATC<0> data output.. RC0/T1OSO/ T1CKI, Function = RC0. RC0/T1OSO/ T1CKI, TRIS Setting = 1. RC0/T1OSO/ T1CKI, I/O = I. RC0/T1OSO/ T1CKI, I/O Type = ST. RC0/T1OSO/ T1CKI, Description = PORTC<0> data input.. RC0/T1OSO/ T1CKI, Function = T1OSO. RC0/T1OSO/ T1CKI, TRIS Setting = x. RC0/T1OSO/ T1CKI, I/O = O. RC0/T1OSO/ T1CKI, I/O",
    "TABLE 11-5: PORTC I/O SUMMARY\nType = ANA. RC0/T1OSO/ T1CKI, Description = Timer1 oscillator output; enabled when Timer1 oscillator is enabled. Disables digital I/O.. RC0/T1OSO/ T1CKI, Function = T1CKI. RC0/T1OSO/ T1CKI, TRIS Setting = 1. RC0/T1OSO/ T1CKI, I/O = I. RC0/T1OSO/ T1CKI, I/O Type = ST. RC0/T1OSO/ T1CKI, Description = Timer1/Timer3 counter input.. RC1/T1OSI/ CCP2/FLTA, Function = RC1. RC1/T1OSI/ CCP2/FLTA, TRIS Setting = 0. RC1/T1OSI/ CCP2/FLTA, I/O = O. RC1/T1OSI/ CCP2/FLTA, I/O Type = DIG. RC1/T1OSI/ CCP2/FLTA, Description = LATC<1> data output..",
    "TABLE 11-5: PORTC I/O SUMMARY\nRC1/T1OSI/ CCP2/FLTA, Function = RC1. RC1/T1OSI/ CCP2/FLTA, TRIS Setting = 1. RC1/T1OSI/ CCP2/FLTA, I/O = I. RC1/T1OSI/ CCP2/FLTA, I/O Type = ST. RC1/T1OSI/ CCP2/FLTA, Description = PORTC<1> data input.. RC1/T1OSI/ CCP2/FLTA, Function = T1OSI. RC1/T1OSI/ CCP2/FLTA, TRIS Setting = x. RC1/T1OSI/ CCP2/FLTA, I/O = I. RC1/T1OSI/ CCP2/FLTA, I/O Type = ANA. RC1/T1OSI/ CCP2/FLTA, Description = Timer1 oscillator input; enabled when Timer1 oscillator is enabled. Disables digital I/O.. RC1/T1OSI/ CCP2/FLTA, Function",
    "TABLE 11-5: PORTC I/O SUMMARY\n= CCP2. RC1/T1OSI/ CCP2/FLTA, TRIS Setting = 0. RC1/T1OSI/ CCP2/FLTA, I/O = O. RC1/T1OSI/ CCP2/FLTA, I/O Type = DIG. RC1/T1OSI/ CCP2/FLTA, Description = CCP2 compare and PWM output; takes priority over port data.. RC1/T1OSI/ CCP2/FLTA, Function = CCP2. RC1/T1OSI/ CCP2/FLTA, TRIS Setting = 1. RC1/T1OSI/ CCP2/FLTA, I/O = I. RC1/T1OSI/ CCP2/FLTA, I/O Type = ST. RC1/T1OSI/ CCP2/FLTA, Description = CCP2 capture input.. RC1/T1OSI/ CCP2/FLTA, Function = FLTA. RC1/T1OSI/ CCP2/FLTA, TRIS Setting = 1.",
    "TABLE 11-5: PORTC I/O SUMMARY\nRC1/T1OSI/ CCP2/FLTA, I/O = I. RC1/T1OSI/ CCP2/FLTA, I/O Type = ST. RC1/T1OSI/ CCP2/FLTA, Description = Fault Interrupt Input Pin A.. RC2/CCP1/FLTB, Function = RC2. RC2/CCP1/FLTB, TRIS Setting = 0. RC2/CCP1/FLTB, I/O = O. RC2/CCP1/FLTB, I/O Type = DIG. RC2/CCP1/FLTB, Description = LATC<2> data output.. RC2/CCP1/FLTB, Function = RC2. RC2/CCP1/FLTB, TRIS Setting = 1. RC2/CCP1/FLTB, I/O = I. RC2/CCP1/FLTB, I/O Type = ST. RC2/CCP1/FLTB, Description = PORTC<2> data input..",
    "TABLE 11-5: PORTC I/O SUMMARY\nRC2/CCP1/FLTB, Function = CCP1. RC2/CCP1/FLTB, TRIS Setting = 0. RC2/CCP1/FLTB, I/O = O. RC2/CCP1/FLTB, I/O Type = DIG. RC2/CCP1/FLTB, Description = CCP1 compare or PWM output; takes priority over port data.. RC2/CCP1/FLTB, Function = CCP1. RC2/CCP1/FLTB, TRIS Setting = 1. RC2/CCP1/FLTB, I/O = I. RC2/CCP1/FLTB, I/O Type = ST. RC2/CCP1/FLTB, Description = CCP1 capture input.. RC2/CCP1/FLTB, Function = FLTB. RC2/CCP1/FLTB, TRIS Setting = 1. RC2/CCP1/FLTB, I/O = I.",
    "TABLE 11-5: PORTC I/O SUMMARY\nRC2/CCP1/FLTB, I/O Type = ST. RC2/CCP1/FLTB, Description = Fault Interrupt Input Pin B.. RC3/T0CKI/ T5CKI/INT0, Function = RC3. RC3/T0CKI/ T5CKI/INT0, TRIS Setting = 0. RC3/T0CKI/ T5CKI/INT0, I/O = O. RC3/T0CKI/ T5CKI/INT0, I/O Type = DIG. RC3/T0CKI/ T5CKI/INT0, Description = LATC<3> data output.. RC3/T0CKI/ T5CKI/INT0, Function = RC3. RC3/T0CKI/ T5CKI/INT0, TRIS Setting = 1. RC3/T0CKI/ T5CKI/INT0, I/O = I. RC3/T0CKI/ T5CKI/INT0, I/O Type = ST. RC3/T0CKI/ T5CKI/INT0, Description = PORTC<3> data",
    "TABLE 11-5: PORTC I/O SUMMARY\ninput.. RC3/T0CKI/ T5CKI/INT0, Function = T0CKI (1). RC3/T0CKI/ T5CKI/INT0, TRIS Setting = 1. RC3/T0CKI/ T5CKI/INT0, I/O = I. RC3/T0CKI/ T5CKI/INT0, I/O Type = ST. RC3/T0CKI/ T5CKI/INT0, Description = Timer0 alternate clock input.. RC3/T0CKI/ T5CKI/INT0, Function = T5CKI (1). RC3/T0CKI/ T5CKI/INT0, TRIS Setting = 1. RC3/T0CKI/ T5CKI/INT0, I/O = I. RC3/T0CKI/ T5CKI/INT0, I/O Type = ST. RC3/T0CKI/ T5CKI/INT0, Description = Timer5 alternate clock input.. RC3/T0CKI/ T5CKI/INT0, Function = INT0. RC3/T0CKI/",
    "TABLE 11-5: PORTC I/O SUMMARY\nT5CKI/INT0, TRIS Setting = 1. RC3/T0CKI/ T5CKI/INT0, I/O = I. RC3/T0CKI/ T5CKI/INT0, I/O Type = ST. RC3/T0CKI/ T5CKI/INT0, Description = External Interrupt 0.. RC4/INT1/SDI/ SDA, Function = RC4. RC4/INT1/SDI/ SDA, TRIS Setting = 0. RC4/INT1/SDI/ SDA, I/O = O. RC4/INT1/SDI/ SDA, I/O Type = DIG. RC4/INT1/SDI/ SDA, Description = LATC<4> data output.. RC4/INT1/SDI/ SDA, Function = RC4. RC4/INT1/SDI/ SDA, TRIS Setting = 1. RC4/INT1/SDI/ SDA, I/O = I. RC4/INT1/SDI/ SDA, I/O Type = ST.",
    "TABLE 11-5: PORTC I/O SUMMARY\nRC4/INT1/SDI/ SDA, Description = PORTC<4> data input.. RC4/INT1/SDI/ SDA, Function = INT1. RC4/INT1/SDI/ SDA, TRIS Setting = 1. RC4/INT1/SDI/ SDA, I/O = I. RC4/INT1/SDI/ SDA, I/O Type = ST. RC4/INT1/SDI/ SDA, Description = External Interrupt 1.. RC4/INT1/SDI/ SDA, Function = SDI (1). RC4/INT1/SDI/ SDA, TRIS Setting = 1. RC4/INT1/SDI/ SDA, I/O = I. RC4/INT1/SDI/ SDA, I/O Type = ST. RC4/INT1/SDI/ SDA, Description = SPI data input (SSP module).. RC4/INT1/SDI/ SDA, Function = SDA (1). RC4/INT1/SDI/",
    "TABLE 11-5: PORTC I/O SUMMARY\nSDA, TRIS Setting = 0. RC4/INT1/SDI/ SDA, I/O = O. RC4/INT1/SDI/ SDA, I/O Type = DIG. RC4/INT1/SDI/ SDA, Description = I 2 C\u2122 data output (SSP module); takes priority over port data.. RC4/INT1/SDI/ SDA, Function = SDA (1). RC4/INT1/SDI/ SDA, TRIS Setting = 1. RC4/INT1/SDI/ SDA, I/O = I. RC4/INT1/SDI/ SDA, I/O Type = I 2 C. RC4/INT1/SDI/ SDA, Description = I 2 C data input (SSP module).. RC5/INT2/SCK/ SCL, Function = RC5. RC5/INT2/SCK/ SCL, TRIS Setting = 0. RC5/INT2/SCK/ SCL, I/O = O. RC5/INT2/SCK/",
    "TABLE 11-5: PORTC I/O SUMMARY\nSCL, I/O Type = DIG. RC5/INT2/SCK/ SCL, Description = LATC<5> data output.. RC5/INT2/SCK/ SCL, Function = RC5. RC5/INT2/SCK/ SCL, TRIS Setting = 1. RC5/INT2/SCK/ SCL, I/O = I. RC5/INT2/SCK/ SCL, I/O Type = ST. RC5/INT2/SCK/ SCL, Description = PORTC<5> data input.. RC5/INT2/SCK/ SCL, Function = INT2. RC5/INT2/SCK/ SCL, TRIS Setting = 1. RC5/INT2/SCK/ SCL, I/O = I. RC5/INT2/SCK/ SCL, I/O Type = ST. RC5/INT2/SCK/ SCL, Description = External Interrupt 2.. RC5/INT2/SCK/ SCL, Function = SCK (1).",
    "TABLE 11-5: PORTC I/O SUMMARY\nRC5/INT2/SCK/ SCL, TRIS Setting = 0. RC5/INT2/SCK/ SCL, I/O = O. RC5/INT2/SCK/ SCL, I/O Type = DIG. RC5/INT2/SCK/ SCL, Description = SPI clock output (SSP module); takes priority over port data.. RC5/INT2/SCK/ SCL, Function = SCK (1). RC5/INT2/SCK/ SCL, TRIS Setting = 1. RC5/INT2/SCK/ SCL, I/O = I. RC5/INT2/SCK/ SCL, I/O Type = ST. RC5/INT2/SCK/ SCL, Description = SPI clock input (SSP module).. RC5/INT2/SCK/ SCL, Function = SCL (1). RC5/INT2/SCK/ SCL, TRIS Setting = 0. RC5/INT2/SCK/ SCL, I/O = O.",
    "TABLE 11-5: PORTC I/O SUMMARY\nRC5/INT2/SCK/ SCL, I/O Type = DIG. RC5/INT2/SCK/ SCL, Description = I 2 C clock output (SSP module); takes priority over port data.. RC5/INT2/SCK/ SCL, Function = SCL (1). RC5/INT2/SCK/ SCL, TRIS Setting = 1. RC5/INT2/SCK/ SCL, I/O = I. RC5/INT2/SCK/ SCL, I/O Type = I 2 C. RC5/INT2/SCK/ SCL, Description = I 2 C clock input (SSP module); input type depends on module setting.. RC6/TX/CK/SS, Function = RC6. RC6/TX/CK/SS, TRIS Setting = 0. RC6/TX/CK/SS, I/O = O. RC6/TX/CK/SS, I/O Type = DIG. RC6/TX/CK/SS, Description = LATC<6> data output..",
    "TABLE 11-5: PORTC I/O SUMMARY\nRC6/TX/CK/SS, Function = RC6. RC6/TX/CK/SS, TRIS Setting = 1. RC6/TX/CK/SS, I/O = I. RC6/TX/CK/SS, I/O Type = ST. RC6/TX/CK/SS, Description = PORTC<6> data input.. RC6/TX/CK/SS, Function = TX. RC6/TX/CK/SS, TRIS Setting = 0. RC6/TX/CK/SS, I/O = O. RC6/TX/CK/SS, I/O Type = DIG. RC6/TX/CK/SS, Description = Asynchronous serial transmit data output (EUSART module); takes priority over port data. User must configure as an output.. RC6/TX/CK/SS, Function = CK. RC6/TX/CK/SS, TRIS Setting = 0. RC6/TX/CK/SS, I/O = O. RC6/TX/CK/SS, I/O Type = DIG.",
    "TABLE 11-5: PORTC I/O SUMMARY\nRC6/TX/CK/SS, Description = Synchronous serial clock output (EUSART module); takes priority over port data.. RC6/TX/CK/SS, Function = CK. RC6/TX/CK/SS, TRIS Setting = 1. RC6/TX/CK/SS, I/O = I. RC6/TX/CK/SS, I/O Type = ST. RC6/TX/CK/SS, Description = Synchronous serial clock input (EUSART module).. RC6/TX/CK/SS, Function = SS. RC6/TX/CK/SS, TRIS Setting = 1. RC6/TX/CK/SS, I/O = I. RC6/TX/CK/SS, I/O Type = ST. RC6/TX/CK/SS, Description = SPI slave select input.\nLegend:",
    "TABLE 11-5: PORTC I/O SUMMARY\nDIG = Digital level output; TTL = TTL input buffer; ST = Schmitt Trigger input buffer; ANA = Analog level input/output; x = Don't care (TRIS bit does not affect port direction or is overridden for this option).\nNote 1: RD0 is the alternate pin for T0CKI/T5CKI; RD2 is the alternate pin for SDI/SDA; RD3 is the alternate pin for SCK/SCL;\nRD1 is the alternate pin for SDO.",
    "TABLE 11-5: PORTC I/O SUMMARY (CONTINUED)\nRC7/RX/DT/SDO, Function = RC7. RC7/RX/DT/SDO, TRIS Setting = 0. RC7/RX/DT/SDO, I/O = O. RC7/RX/DT/SDO, I/O Type = DIG. RC7/RX/DT/SDO, Description = LATC<7> data output.. RC7/RX/DT/SDO, Function = . RC7/RX/DT/SDO, TRIS Setting = 1. RC7/RX/DT/SDO, I/O = I. RC7/RX/DT/SDO, I/O Type = ST. RC7/RX/DT/SDO, Description = PORTC<7> data input.. RC7/RX/DT/SDO, Function = RX. RC7/RX/DT/SDO, TRIS Setting = 1. RC7/RX/DT/SDO, I/O = I. RC7/RX/DT/SDO, I/O",
    "TABLE 11-5: PORTC I/O SUMMARY (CONTINUED)\nType = ST. RC7/RX/DT/SDO, Description = Asynchronous serial receive data input (EUSART module).. RC7/RX/DT/SDO, Function = DT. RC7/RX/DT/SDO, TRIS Setting = 0. RC7/RX/DT/SDO, I/O = O. RC7/RX/DT/SDO, I/O Type = DIG. RC7/RX/DT/SDO, Description = Synchronous serial data output (EUSART module); takes priority over port data.. RC7/RX/DT/SDO, Function = . RC7/RX/DT/SDO, TRIS Setting = 1. RC7/RX/DT/SDO, I/O = I. RC7/RX/DT/SDO, I/O Type = ST. RC7/RX/DT/SDO, Description = Synchronous serial data input (EUSART module). User must configure as an input..",
    "TABLE 11-5: PORTC I/O SUMMARY (CONTINUED)\nRC7/RX/DT/SDO, Function = SDO (1). RC7/RX/DT/SDO, TRIS Setting = 0. RC7/RX/DT/SDO, I/O = O. RC7/RX/DT/SDO, I/O Type = DIG. RC7/RX/DT/SDO, Description = SPI data out; takes priority over port data.\nLegend:\nDIG = Digital level output; TTL = TTL input buffer; ST = Schmitt Trigger input buffer; ANA = Analog level input/output; x = Don't care (TRIS bit does not affect port direction or is overridden for this option).\nNote 1: RD0 is the alternate pin for T0CKI/T5CKI; RD2 is the alternate pin for SDI/SDA; RD3 is the alternate pin for SCK/SCL; RD1 is the alternate pin for SDO.",
    "TABLE 11-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nPORTC, Bit 7 = RC7. PORTC, Bit 6 = RC6. PORTC, Bit 5 = RC5. PORTC, Bit 4 = RC4. PORTC, Bit 3 = RC3. PORTC, Bit 2 = RC2. PORTC, Bit 1 = RC1. PORTC, Bit 0 = RC0. PORTC, Reset Values on Page: = 57. LATC, Bit 7 = LATC Data Output Register. LATC, Bit 6 = LATC Data Output Register. LATC, Bit 5 = LATC Data Output Register. LATC, Bit 4 = LATC Data Output Register. LATC, Bit 3 = LATC Data Output Register. LATC, Bit 2 = LATC Data Output Register. LATC, Bit 1 = LATC Data Output Register. LATC, Bit 0 = LATC Data Output Register. LATC, Reset Values on Page: = 57. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 =",
    "TABLE 11-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nPORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Reset Values on Page: = 57. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = -. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = -. INTCON2, Bit 0 = RBIP. INTCON2, Reset Values on",
    "TABLE 11-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nPage: = 54. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Reset Values on Page: = 54\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by PORTC.",
    "11.4 PORTD, TRISD and LATD Registers\nNote:\nPORTD is only available on PIC18F4331/ 4431 devices.\nPORTD  is  an  8-bit wide, bidirectional port. The corresponding Data Direction register is TRISD. Setting a TRISD bit (= 1 ) will make the corresponding PORTD pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISD bit  (= 0 )  will  make the corresponding PORTD pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data  Latch  register (LATD)  is  also memory mapped.  Read-modify-write  operations  on  the  LATD register  read  and  write  the  latched  output  value  for PORTD.\nAll  pins  on  PORTD  are  implemented  with  Schmitt Trigger input buffers. Each pin is individually configurable as an input or output.\nNote:\nOn  a  Power-on  Reset,  these  pins  are configured as digital inputs.",
    "11.4 PORTD, TRISD and LATD Registers\nPORTD  includes  PWM<7:6>  complementary  fourth channel  PWM outputs. PWM4 is the complementary output  of  PWM5  (the  third  channel),  which  is  multiplexed with the RB5 pin. This output can be used as the alternate output using the PWM4MX Configuration bit in  CONFIG3H when the Single-Supply Programming pin (PGM) is used on RB5.\nRD1, RD2 and RD3 can be used as the alternate output for SDO, SDI/SDA and SCK/SCL using the SSPMX Configuration bit in CONFIG3H.\nRD4 an be used as the alternate output for FLTA using the FLTAMX Configuration bit in CONFIG3H.",
    "EXAMPLE 11-4: INITIALIZING PORTD\nCLRF, 1 = PORTD. CLRF, 2 = ; Initialize PORTD by ; clearing output ; data latches. CLRF, 1 = LATD. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0xCF. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISD. MOVWF, 2 = ; Set RD<3:0> as inputs ; RD<5:4> as outputs ; RD<7:6> as inputs",
    "TABLE 11-7: PORTD I/O SUMMARY\nRD0/T0CKI/ T5CKI, Function = RD0. RD0/T0CKI/ T5CKI, TRIS Setting = 0. RD0/T0CKI/ T5CKI, I/O = O. RD0/T0CKI/ T5CKI, I/O Type = DIG. RD0/T0CKI/ T5CKI, Description = LATD<0> data output.. RD0/T0CKI/ T5CKI, Function = RD0. RD0/T0CKI/ T5CKI, TRIS Setting = 1. RD0/T0CKI/ T5CKI, I/O = I. RD0/T0CKI/ T5CKI, I/O Type = ST. RD0/T0CKI/ T5CKI, Description = PORTD<0> data input.. RD0/T0CKI/ T5CKI, Function = T0CKI (1). RD0/T0CKI/ T5CKI, TRIS Setting = 1. RD0/T0CKI/ T5CKI, I/O = I. RD0/T0CKI/",
    "TABLE 11-7: PORTD I/O SUMMARY\nT5CKI, I/O Type = ST. RD0/T0CKI/ T5CKI, Description = Timer0 alternate clock input.. RD0/T0CKI/ T5CKI, Function = T5CKI (1). RD0/T0CKI/ T5CKI, TRIS Setting = 1. RD0/T0CKI/ T5CKI, I/O = I. RD0/T0CKI/ T5CKI, I/O Type = ST. RD0/T0CKI/ T5CKI, Description = Timer5 alternate clock input.. RD1/SDO, Function = RD1. RD1/SDO, TRIS Setting = 0. RD1/SDO, I/O = O. RD1/SDO, I/O Type = DIG. RD1/SDO, Description = LATD<1> data output.. RD1/SDO, Function = RD1. RD1/SDO, TRIS Setting = 1. RD1/SDO, I/O = I. RD1/SDO, I/O Type = ST. RD1/SDO, Description =",
    "TABLE 11-7: PORTD I/O SUMMARY\nPORTD<1> data input.. RD1/SDO, Function = SDO (1). RD1/SDO, TRIS Setting = 0. RD1/SDO, I/O = O. RD1/SDO, I/O Type = DIG. RD1/SDO, Description = SPI data out; takes priority over port data.. RD2/SDI/SDA, Function = RD2. RD2/SDI/SDA, TRIS Setting = 0. RD2/SDI/SDA, I/O = O. RD2/SDI/SDA, I/O Type = DIG. RD2/SDI/SDA, Description = LATD<2> data output.. RD2/SDI/SDA, Function = RD2. RD2/SDI/SDA, TRIS Setting = 1. RD2/SDI/SDA, I/O = I. RD2/SDI/SDA, I/O Type = ST. RD2/SDI/SDA, Description = PORTD<2> data input..",
    "TABLE 11-7: PORTD I/O SUMMARY\nRD2/SDI/SDA, Function = SDI (1). RD2/SDI/SDA, TRIS Setting = 1. RD2/SDI/SDA, I/O = I. RD2/SDI/SDA, I/O Type = ST. RD2/SDI/SDA, Description = SPI data input (SSP module).. RD2/SDI/SDA, Function = SDA (1). RD2/SDI/SDA, TRIS Setting = 0. RD2/SDI/SDA, I/O = O. RD2/SDI/SDA, I/O Type = DIG. RD2/SDI/SDA, Description = I 2 C\u2122 data output (SSP module); takes priority over port data.. RD2/SDI/SDA, Function = SDA (1). RD2/SDI/SDA, TRIS Setting = 1. RD2/SDI/SDA, I/O = I. RD2/SDI/SDA, I/O Type = I 2 C.",
    "TABLE 11-7: PORTD I/O SUMMARY\nRD2/SDI/SDA, Description = I 2 C data input (SSP module).. RD3/SCK/SCL, Function = RD3. RD3/SCK/SCL, TRIS Setting = 0. RD3/SCK/SCL, I/O = O. RD3/SCK/SCL, I/O Type = DIG. RD3/SCK/SCL, Description = LATD<3> data output.. RD3/SCK/SCL, Function = RD3. RD3/SCK/SCL, TRIS Setting = 1. RD3/SCK/SCL, I/O = I. RD3/SCK/SCL, I/O Type = ST. RD3/SCK/SCL, Description = PORTD<3> data input.. RD3/SCK/SCL, Function = SCK (1). RD3/SCK/SCL, TRIS Setting = 0. RD3/SCK/SCL, I/O = O. RD3/SCK/SCL, I/O Type =",
    "TABLE 11-7: PORTD I/O SUMMARY\nDIG. RD3/SCK/SCL, Description = SPI clock output (SSP module); takes priority over port data.. RD3/SCK/SCL, Function = SCK (1). RD3/SCK/SCL, TRIS Setting = 1. RD3/SCK/SCL, I/O = I. RD3/SCK/SCL, I/O Type = ST. RD3/SCK/SCL, Description = SPI clock input (SSP module).. RD3/SCK/SCL, Function = SCL (1). RD3/SCK/SCL, TRIS Setting = 0. RD3/SCK/SCL, I/O = O. RD3/SCK/SCL, I/O Type = DIG. RD3/SCK/SCL, Description = I 2 C clock output (SSP module); takes priority over port data.. RD3/SCK/SCL, Function = SCL (1). RD3/SCK/SCL, TRIS Setting = 1.",
    "TABLE 11-7: PORTD I/O SUMMARY\nRD3/SCK/SCL, I/O = I. RD3/SCK/SCL, I/O Type = I 2 C. RD3/SCK/SCL, Description = I 2 C clock input (SSP module); input type depends on module setting.. RD4/FLTA, Function = RD4. RD4/FLTA, TRIS Setting = 0. RD4/FLTA, I/O = O. RD4/FLTA, I/O Type = DIG. RD4/FLTA, Description = LATD<4> data output.. RD4/FLTA, Function = RD4. RD4/FLTA, TRIS Setting = 1. RD4/FLTA, I/O = I. RD4/FLTA, I/O Type = ST. RD4/FLTA, Description = PORTD<4> data input.. RD4/FLTA, Function = FLTA (2). RD4/FLTA, TRIS Setting = 1. RD4/FLTA, I/O = I. RD4/FLTA, I/O Type = ST.",
    "TABLE 11-7: PORTD I/O SUMMARY\nRD4/FLTA, Description = Fault Interrupt Input Pin A.. RD5/PWM4, Function = RD5. RD5/PWM4, TRIS Setting = 0. RD5/PWM4, I/O = O. RD5/PWM4, I/O Type = DIG. RD5/PWM4, Description = LATD<5> data output.. RD5/PWM4, Function = RD5. RD5/PWM4, TRIS Setting = 1. RD5/PWM4, I/O = I. RD5/PWM4, I/O Type = ST. RD5/PWM4, Description = PORTD<5> data input.. RD5/PWM4, Function = PWM4 (3). RD5/PWM4, TRIS Setting = 0. RD5/PWM4, I/O = O. RD5/PWM4, I/O Type = DIG. RD5/PWM4, Description = PWM Output 4; takes priority",
    "TABLE 11-7: PORTD I/O SUMMARY\nover port data.. RD6/PWM6, Function = RD6. RD6/PWM6, TRIS Setting = 0. RD6/PWM6, I/O = O. RD6/PWM6, I/O Type = DIG. RD6/PWM6, Description = LATD<6> data output.. RD6/PWM6, Function = RD6. RD6/PWM6, TRIS Setting = 1. RD6/PWM6, I/O = I. RD6/PWM6, I/O Type = ST. RD6/PWM6, Description = PORTD<6> data input.. RD6/PWM6, Function = PWM6. RD6/PWM6, TRIS Setting = 0. RD6/PWM6, I/O = O. RD6/PWM6, I/O Type = DIG. RD6/PWM6, Description = PWM Output 6; takes priority over port data.. RD7/PWM7,",
    "TABLE 11-7: PORTD I/O SUMMARY\nFunction = RD7. RD7/PWM7, TRIS Setting = 0. RD7/PWM7, I/O = O. RD7/PWM7, I/O Type = DIG. RD7/PWM7, Description = LATD<7> data output.. RD7/PWM7, Function = RD7. RD7/PWM7, TRIS Setting = 1. RD7/PWM7, I/O = I. RD7/PWM7, I/O Type = ST. RD7/PWM7, Description = PORTD<7> data input.. RD7/PWM7, Function = PWM7. RD7/PWM7, TRIS Setting = 0. RD7/PWM7, I/O = O. RD7/PWM7, I/O Type = DIG. RD7/PWM7, Description = PWM Output 7; takes priority over port data.\nLegend:",
    "TABLE 11-7: PORTD I/O SUMMARY\nDIG = Digital level output; TTL = TTL input buffer; ST = Schmitt Trigger input buffer;\nx = Don't care (TRIS bit does not affect port direction or is overridden for this option).\nNote 1: RC3 is the alternate pin for T0CKI/T5CKI; RC4 is the alternate pin for SDI/SDA; RC5 is the alternate pin for SCK/SCL;\nRC7 is the alternate pin for SDO.\n2: RC1 is the alternate pin for FLTA.\n3: RB5 is the alternate pin for PWM4.",
    "TABLE 11-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nPORTD, Bit 7 = RD7. PORTD, Bit 6 = RD6. PORTD, Bit 5 = RD5. PORTD, Bit 4 = RD4. PORTD, Bit 3 = RD3. PORTD, Bit 2 = RD2. PORTD, Bit 1 = RD1. PORTD, Bit 0 = RD0. PORTD, Reset Values on Page: = 57. LATD, Bit 7 = LATD Data Output Register. LATD, Bit 6 = LATD Data Output Register. LATD, Bit 5 = LATD Data Output Register. LATD, Bit 4 = LATD Data Output Register. LATD, Bit 3 = LATD Data Output Register. LATD, Bit 2 = LATD Data Output Register. LATD, Bit 1 = LATD Data Output Register. LATD, Bit 0 = LATD Data Output Register. LATD, Reset Values on Page: = 57. TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register.",
    "TABLE 11-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nTRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Reset Values on Page: = 57",
    "11.5 PORTE, TRISE and LATE Registers\nNote:\nPORTE is only available on PIC18F4331/ 4431 devices.\nPORTE is a 4-bit wide, bidirectional port. Three pins (RE0/AN6,  RE1/AN7  and  RE2/AN8)  are  individually configurable  as  inputs  or  outputs.  These  pins  have Schmitt  Trigger  input  buffers.  When  selected  as  an analog input, these pins will read as ' 0 's.\nThe corresponding  Data  Direction  register  is  TRISE. Setting a TRISE bit (= 1 ) will make the corresponding PORTE pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISE bit (= 0 ) will make the corresponding PORTE pin an output (i.e., put the contents of the output latch on the selected pin).\nTRISE controls the direction of the RE pins, even when they are being used as analog inputs. The user must make sure to keep the pins configured as inputs when using them as analog inputs.\nNote: On a Power-on Reset, RE<2:0> are configured as analog inputs.",
    "11.5 PORTE, TRISE and LATE Registers\nThe  Data  Latch  register (LATE)  is also memory mapped.  Read-modify-write  operations  on  the  LATE register  read  and  write  the  latched  output  value  for PORTE.\nThe fourth pin of PORTE (MCLR/VPP/RE3) is an input only  pin  available  for  PIC18F4331/4431  devices.  Its operation is controlled by the MCLRE Configuration bit in Configuration Register 3H (CONFIG3H<7>). When selected as a port pin (MCLRE = 0 ), it functions as a digital input-only pin. As such, it does not have TRIS or LAT  bits  associated  with  its  operation.  Otherwise,  it functions as the device's master clear input. In either configuration, RE3 also functions as the programming voltage input during programming.\nNote:\nOn a Power-on Reset, RE3 is enabled as a digital input only if Master Clear functionality is disabled.",
    "EXAMPLE 11-5: INITIALIZING PORTE\nCLRF, 1 = PORTE. CLRF, 2 = ; Initialize PORTE by ; clearing output ; data latches. CLRF, 1 = LATE. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF BCF MOVLW, 1 = 0x3F ANSEL0 ANSEL1, 0 0x03. MOVLW MOVWF BCF MOVLW, 2 = ; Configure A/D ; for digital inputs ; ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISE. MOVWF, 2 = ; Set RE<0> as input ; RE<1> as output ; RE<2> as input",
    "11.5.1 PORTE IN 28-PIN DEVICES\nFor PIC18F2331/2431 devices, PORTE is not available. It is only available for PIC18F4331/4431 devices.",
    "REGISTER 11-1: TRISE REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = R/W-1. U-0, 6 = R/W-1. U-0, 7 = R/W-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = TRISE2. -, 6 = TRISE1. -, 7 = TRISE0. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 11-1: TRISE REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-3 Unimplemented: Read as ' 0 '\nbit 2\nTRISE2 : RE2 Direction Control bit\n1 = Input\n0 = Output\nbit 1\nTRISE1 : RE1 Direction Control bit\n1 = Input\n0 = Output\nbit 0\nTRISE0 : RE0 Direction Control bit\n1 = Input\n0 = Output",
    "TABLE 11-9: PORTE I/O SUMMARY\nRE0/AN6, Function = RE0. RE0/AN6, TRIS Setting = 0. RE0/AN6, I/O = O. RE0/AN6, I/O Type = DIG. RE0/AN6, Description = LATE<0> data output; not affected by analog input.. RE0/AN6, Function = RE0. RE0/AN6, TRIS Setting = 1. RE0/AN6, I/O = I. RE0/AN6, I/O Type = ST. RE0/AN6, Description = PORTE<0> data input; disabled when analog input is enabled.. RE0/AN6, Function = AN6. RE0/AN6, TRIS Setting = 1. RE0/AN6, I/O = I. RE0/AN6, I/O Type = ANA. RE0/AN6, Description = A/D Input Channel 6. Default input configuration on POR.. RE1/AN7, Function = RE1. RE1/AN7, TRIS Setting = 0. RE1/AN7, I/O = O.",
    "TABLE 11-9: PORTE I/O SUMMARY\nRE1/AN7, I/O Type = DIG. RE1/AN7, Description = LATE<1> data output; not affected by analog input.. RE1/AN7, Function = RE1. RE1/AN7, TRIS Setting = 1. RE1/AN7, I/O = I. RE1/AN7, I/O Type = ST. RE1/AN7, Description = PORTE<1> data input; disabled when analog input is enabled.. RE1/AN7, Function = AN7. RE1/AN7, TRIS Setting = 1. RE1/AN7, I/O = I. RE1/AN7, I/O Type = ANA. RE1/AN7, Description = A/D Input Channel 7. Default input configuration on POR.. RE2/AN8, Function = RE2. RE2/AN8, TRIS Setting = 0. RE2/AN8, I/O = O. RE2/AN8, I/O Type = DIG. RE2/AN8, Description = LATE<2> data output; not affected by analog input..",
    "TABLE 11-9: PORTE I/O SUMMARY\nRE2/AN8, Function = RE2. RE2/AN8, TRIS Setting = 1. RE2/AN8, I/O = I. RE2/AN8, I/O Type = ST. RE2/AN8, Description = PORTE<2> data input; disabled when analog input is enabled.. RE2/AN8, Function = AN8. RE2/AN8, TRIS Setting = 1. RE2/AN8, I/O = I. RE2/AN8, I/O Type = ANA. RE2/AN8, Description = A/D Input Channel 8. Default input configuration on POR.. MCLR/VPP/RE3 (1), Function = MCLR. MCLR/VPP/RE3 (1), TRIS Setting = -. MCLR/VPP/RE3 (1), I/O = I. MCLR/VPP/RE3 (1), I/O Type = ST. MCLR/VPP/RE3 (1), Description = External Master Clear input; enabled when MCLRE Configuration bit is set..",
    "TABLE 11-9: PORTE I/O SUMMARY\nMCLR/VPP/RE3 (1), Function = VPP. MCLR/VPP/RE3 (1), TRIS Setting = -. MCLR/VPP/RE3 (1), I/O = I. MCLR/VPP/RE3 (1), I/O Type = ANA. MCLR/VPP/RE3 (1), Description = High-Voltage Detection; used for ICSP\u2122 mode entry detection. Always available, regardless of pin mode.. MCLR/VPP/RE3 (1), Function = RE3. MCLR/VPP/RE3 (1), TRIS Setting = - (2). MCLR/VPP/RE3 (1), I/O = I. MCLR/VPP/RE3 (1), I/O Type = ST. MCLR/VPP/RE3 (1), Description = PORTE<3> data input; enabled when MCLRE Configuration bit is clear.",
    "TABLE 11-9: PORTE I/O SUMMARY\nLegend: DIG = Digital level output; TTL = TTL input buffer; ST = Schmitt Trigger input buffer; ANA = Analog level input/output; x = Don't care (TRIS bit does not affect port direction or is overridden for this option).\nNote\n1: All PORTE pins are only implemented on 40/44-pin devices.\n2: RE3 does not have a corresponding TRIS bit to control data direction.",
    "TABLE 11-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nPORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = RE3 (1). PORTE, Bit 2 = RE2. PORTE, Bit 1 = RE1. PORTE, Bit 0 = RE0. PORTE, Reset Values on Page: = 57. LATE, Bit 7 = -. LATE, Bit 6 = -. LATE, Bit 5 = -. LATE, Bit 4 = -. LATE, Bit 3 = -. LATE, Bit 2 = LATE Data Output Register. LATE, Bit 1 = LATE Data Output Register. LATE, Bit 0 = LATE Data Output Register. LATE, Reset Values on Page: = 57. TRISE, Bit 7 = -. TRISE, Bit 6 = -. TRISE, Bit 5 = -. TRISE, Bit 4 = -. TRISE, Bit 3 = -. TRISE, Bit 2 = PORTE Data Direction Register. TRISE, Bit 1 = PORTE Data Direction Register. TRISE, Bit 0 = PORTE Data Direction Register. TRISE, Reset Values on Page: = 57. ANSEL0, Bit 7 = ANS7",
    "TABLE 11-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\n(2). ANSEL0, Bit 6 = ANS6 (2). ANSEL0, Bit 5 = ANS5 (2). ANSEL0, Bit 4 = ANS4. ANSEL0, Bit 3 = ANS3. ANSEL0, Bit 2 = ANS2. ANSEL0, Bit 1 = ANS1. ANSEL0, Bit 0 = ANS0. ANSEL0, Reset Values on Page: = 56. ANSEL1, Bit 7 = -. ANSEL1, Bit 6 = -. ANSEL1, Bit 5 = -. ANSEL1, Bit 4 = -. ANSEL1, Bit 3 = -. ANSEL1, Bit 2 = -. ANSEL1, Bit 1 = -. ANSEL1, Bit 0 = ANS8 (2). ANSEL1, Reset Values on Page: = 56",
    "TABLE 11-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by PORTE.\nNote 1: Implemented only when Master Clear functionality is disabled (CONFIG3H<7> = 0 ). It is available for PIC18F4331/4431 devices only.\n2: ANS5 through ANS8 are available only on PIC18F4331/4431 devices.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "12.0 TIMER0 MODULE\nThe Timer0 module has the following features:\n- \u00b7 Software selectable as an 8-bit or 16-bit timer/counter\nFigure 12-1  shows  a  simplified  block  diagram  of  the Timer0 module in 8-bit mode and Figure 12-2 shows a simplified block diagram of the Timer0 module in 16-bit mode.\n\u00b7 Readable and writable\n\u00b7 Dedicated 8-bit software programmable prescaler\n\u00b7 Clock source selectable to be external or internal\n\u00b7 Interrupt-on-overflow from FFh to 00h in 8-bit mode and FFFFh to 0000h in 16-bit mode\n\u00b7 Edge select for external clock",
    "REGISTER 12-1: T0CON: TIMER0 CONTROL REGISTER\nTMR0ON, R/W-1 = T016BIT. TMR0ON, R/W-1 = T0CS. TMR0ON, R/W-1 = T0SE. TMR0ON, R/W-1 = PSA. TMR0ON, R/W-1 = T0PS2. TMR0ON, R/W-1 = T0PS1. TMR0ON, R/W-1 = T0PS0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0",
    "REGISTER 12-1: T0CON: TIMER0 CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nTMR0ON:\nTimer0 On/Off Control bit\n1 = Enables Timer0\n0 = Stops Timer0\nbit 6\nT016BIT: Timer0 16-Bit Control bit\n1 = Timer0 is configured as an 8-bit timer/counter\n0 = Timer0 is configured as a 16-bit timer/counter\nbit 5\nT0CS: Timer0 Clock Source Select bit\n1 = Transition on T0CKI pin input edge\n0 = Internal clock (FOSC/4)\nbit 4",
    "REGISTER 12-1: T0CON: TIMER0 CONTROL REGISTER\nT0SE: Timer0 Source Edge Select bit\n1 = Increment on high-to-low transition on T0CKI pin\n0 = Increment on low-to-high transition on T0CKI pin",
    "bit 3\nPSA: Timer0 Prescaler Assignment bit\n1 = TImer0 prescaler is not assigned. Timer0 clock input bypasses prescaler.\n0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.\nbit 2-0\nT0PS<2:0>: Timer0 Prescaler Select bits\n111 = 1:256 Prescale value\n110 = 1:128 Prescale value\n101 = 1:64   Prescale value\n100 = 1:32   Prescale value\n011 = 1:16   Prescale value\n010 = 1:8     Prescale value\n001\n= 1:4     Prescale value\n000\n= 1:2     Prescale value\nThe T0CON register (Register 12-1) is a readable and writable register that controls all the aspects of Timer0, including the prescale selection.",
    "12.1 Timer0 Operation\nTimer0 can operate as a timer or as a counter.",
    "12.2.1 SWITCHING PRESCALER ASSIGNMENT\nTimer  mode  is  selected  by  clearing  the  T0CS  bit.  In Timer mode, the Timer0 module will increment every instruction cycle (without prescaler). If the TMR0 register is written, the increment is inhibited for the following two instruction cycles. The user can work around this by writing an adjusted value to the TMR0 register.\nCounter mode is selected by setting the T0CS bit. In Counter mode, Timer0 will increment, either on every rising  or  falling  edge  of  pin,  RC3/T0CKI/T5CKI/INT0. The incrementing  edge  is  determined  by  the  Timer0 Source Edge Select bit (T0SE). Clearing the T0SE bit selects the rising edge.\nWhen an external clock input is used for Timer0, it must meet certain requirements. The requirements ensure the external clock can be synchronized with the internal phase clock (TOSC). Also, there is a delay in the actual incrementing of Timer0 after synchronization.",
    "12.2 Prescaler\nAn 8-bit counter is available as a prescaler for the Timer0 module. The prescaler is not readable or writable.\nThe PSA and T0PS<2:0> bits determine the prescaler assignment and prescale ratio.\nClearing  bit,  PSA,  will  assign  the  prescaler  to  the Timer0 module. When the prescaler is assigned to the Timer0 module, prescale values of 1:2, 1:4, ..., 1:256 are selectable.\nWhen assigned to the Timer0 module, all instructions writing to the TMR0 register (e.g., CLRF TMR0, MOVWF TMR0, BSF TMR0, x ..., etc.) will clear the prescaler count.\nNote:\nWriting  to  TMR0  when  the  prescaler  is assigned to Timer0 will clear the prescaler count,  but  will  not  change  the  prescaler assignment.\nThe prescaler assignment is fully under software control (i.e., it can be changed 'on-the-fly' during program execution).",
    "12.3 Timer0 Interrupt\nThe  TMR0  interrupt  is  generated  when  the  TMR0 register  overflows from  FFh  to  00h in 8-bit  mode, or FFFFh to 0000h in 16-bit mode. This overflow sets the TMR0IF bit. The interrupt can be masked by clearing the  TMR0IE  bit.  The  TMR0IF  bit  must  be  cleared  in software by the Timer0  module  Interrupt Service Routine  before  re-enabling  this  interrupt.  The  TMR0 interrupt  cannot  awaken  the  processor  from  Sleep mode, since the timer requires clock cycles, even when T0CS is set.",
    "12.4 16-Bit Mode Timer Reads and Writes\nTMR0H  is  not  the  high  byte  of  the  timer/counter  in 16-bit mode, but is actually a buffered version of the high byte of Timer0 (refer to Figure 12-2). The high byte of the Timer0 counter/timer is not directly readable nor writable.  TMR0H is  updated  with  the  contents  of  the high byte of Timer0 during a read of TMR0L. This provides the  ability  to  read  all  16  bits  of  Timer0  without having to verify that the read of the high and low byte were valid due to a rollover between successive reads of the high and low byte.\nA write to the high byte of Timer0 must also take place through the TMR0H Buffer register. Timer0 high byte is updated  with  the  contents  of  TMR0H  when  a  write occurs to TMR0L. This allows all 16 bits of Timer0 to be updated at once.",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0L, Bit 7 = Timer0 Register Low Byte. TMR0L, Bit 6 = Timer0 Register Low Byte. TMR0L, Bit 5 = Timer0 Register Low Byte. TMR0L, Bit 4 = Timer0 Register Low Byte. TMR0L, Bit 3 = Timer0 Register Low Byte. TMR0L, Bit 2 = Timer0 Register Low Byte. TMR0L, Bit 1 = Timer0 Register Low Byte. TMR0L, Bit 0 = Timer0 Register Low Byte. TMR0L, ResetValues on Page: = 55. TMR0H, Bit 7 = Timer0 Register High Byte. TMR0H, Bit 6 = Timer0 Register High Byte. TMR0H, Bit 5 = Timer0 Register High Byte. TMR0H, Bit 4 = Timer0 Register High Byte. TMR0H, Bit 3 = Timer0 Register High Byte. TMR0H, Bit 2 = Timer0 Register High Byte. TMR0H, Bit 1 = Timer0 Register High Byte. TMR0H,",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER0\nBit 0 = Timer0 Register High Byte. TMR0H, ResetValues on Page: = 55. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, ResetValues on Page: = 54. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T016BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, ResetValues on Page: = 55. TRISA, Bit 7 = TRISA7 (1). TRISA, Bit 6",
    "TABLE 12-1: REGISTERS ASSOCIATED WITH TIMER0\n= TRISA6 (1). TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, ResetValues on Page: = 57\nLegend: Shaded cells are not used by Timer0.\nNote 1: RA6 and RA7 are enabled as I/O pins depending on the oscillator mode selected in Configuration Word 1H.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "13.0 TIMER1 MODULE\nThe  Timer1  timer/counter  module  has  the  following features:\n- \u00b7 16-bit timer/counter\n(two 8-bit registers; TMR1H and TMR1L)\n\u00b7 Readable and writable (both registers)\n\u00b7 Internal or external clock select\n\u00b7 Interrupt-on-overflow from FFFFh to 0000h\n\u00b7 Reset from CCP module Special Event Trigger\n\u00b7 Status of system clock operation\nFigure 13-1 is a simplified block diagram of the Timer1 module.\nRegister 13-1 details the Timer1 Control register. This register  controls  the  operating  mode  of  the  Timer1 module and contains the Timer1 Oscillator Enable bit (T1OSCEN).  Timer1  can  be  enabled  or  disabled  by setting or clearing control bit, TMR1ON (T1CON<0>).",
    "13.0 TIMER1 MODULE\nThe Timer1 oscillator can be used as a secondary clock source in power-managed modes. When the T1RUN bit  is  set,  the  Timer1  oscillator  provides  the  system clock. If the Fail-Safe Clock Monitor is enabled and the Timer1 oscillator fails while providing the system clock, polling the T1RUN bit will indicate whether the clock is being  provided  by  the  Timer1  oscillator  or  another source.\nTimer1 can also be used to provide Real-Time Clock (RTC) functionality to applications with only a minimal addition of external components and code overhead.",
    "REGISTER 13-1: T1CON: TIMER1 CONTROL REGISTER\nRD16, R-0 = T1RUN. RD16, R/W-0 = T1CKPS1. RD16, R/W-0 = T1CKPS0. RD16, R/W-0 = T1OSCEN. RD16, R/W-0 = T1SYNC. RD16, R/W-0 = TMR1CS. RD16, R/W-0 = TMR1ON. bit 7, R-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = bit 0",
    "REGISTER 13-1: T1CON: TIMER1 CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7\nRD16: 16-Bit Read/Write Mode Enable bit\n1 = Enables register read/write of TImer1 in one 16-bit operation\n0 = Enables register read/write of Timer1 in two 8-bit operations\nbit 6\nT1RUN: Timer1 System Clock Status bit\n1 = Device clock is derived from Timer1 oscillator\n0 = Device clock is derived from another source",
    "bit 5-4\nT1CKPS<1:0>: Timer1 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value",
    "bit 3\nT1OSCEN: Timer1 Oscillator Enable bit\n1 = Timer1 oscillator is enabled\n0 = Timer1 oscillator is shut off\nThe oscillator inverter and feedback resistor are turned off to eliminate power drain.",
    "bit 2\nT1SYNC: Timer1 External Clock Input Synchronization Select bit\nWhen TMR1CS = 1 (External Clock):\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR1CS = 0 (Internal Clock):\nThis bit is ignored. Timer1 uses the internal clock when TMR1CS = 0 .",
    "bit 1\nTMR1CS: Timer1 Clock Source Select bit\n1 = External clock from pin RC0/T1OSO/T1CKI (on the rising edge)\n0 = Internal clock (FOSC/4)",
    "bit 0\nTMR1ON: Timer1 On bit\n1 = Enables Timer1\n0 = Stops Timer1",
    "13.1 Timer1 Operation\nTimer1 can operate in one of these modes:\n- \u00b7 As a timer\nWhen TMR1CS = 0 , Timer1 increments every instruction cycle. When TMR1CS = 1 , Timer1 increments on every  rising  edge  of  the  external  clock  input  or  the Timer1 oscillator, if enabled.\n\u00b7 As a synchronous counter\n\u00b7 As an asynchronous counter\nThe operating mode is determined by the Timer1 Clock Select bit, TMR1CS (T1CON<1>).\nWhen the Timer1 oscillator is enabled (T1OSCEN is set),  the  RC1/T1OSI/CCP2/FLTA  and  RC0/T1OSO/ T1CKI pins become inputs. That is, the TRISC<1:0> value is ignored and the pins are read as ' 0 '.\nTimer1 also has an internal 'Reset input'. This Reset can be generated by the CCP module (see Section 16.4.4 'Special Event Trigger' ).",
    "13.2 Timer1 Oscillator\nA crystal oscillator circuit is built in-between pins, T1OSI (input) and T1OSO (amplifier output). It is enabled by setting control bit, T1OSCEN (T1CON<3>). The oscillator is a low-power oscillator rated for 32 kHz crystals. It will  continue to run during all power-managed modes. The  circuit  for a  typical LP  oscillator  is shown  in Figure 13-3.  Table 13-1  shows  the  capacitor  selection for the Timer1 oscillator.\nThe user must provide a software time delay to ensure proper start-up of the Timer1 oscillator.",
    "TABLE 13-1: CAPACITOR SELECTION FOR THE TIMER OSCILLATOR\nOsc Type, 1 = Freq. Osc Type, 2 = C1. Osc Type, 3 = C2. LP, 1 = 32 kHz. LP, 2 = 27 pF (1). LP, 3 = 27 pF (1)\nNote 1: Microchip suggests this value as a starting point in validating the oscillator circuit.\n2: Higher capacitance increases the stability of the oscillator, but also increases the start-up time.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer  for appropriate values of external components.\n4: Capacitor values are for design guidance only.",
    "13.3 Timer1 Oscillator Layout Considerations\nThe Timer1 oscillator for PIC18F2331/2431/4331/4431 devices incorporates an additional low-power feature. When this option is selected, it allows the oscillator to automatically reduce its power consumption when the microcontroller is in Sleep mode. During normal device operation,  the  oscillator  draws  full  current.  As  high noise  environments  may  cause  excessive  oscillator instability in Sleep mode, this option is best suited for low noise applications, where power conservation is an important design consideration.\nThe  low-power  option  is  enabled  by  clearing  the T1OSCMX bit (CONFIG3L<5>). By default, the option is  disabled,  which  results  in  a  more  or  less  constant current draw for the Timer1 oscillator.\nDue to the low-power nature of the oscillator, it may also be sensitive to rapidly changing signals in close proximity.",
    "13.3 Timer1 Oscillator Layout Considerations\nThe oscillator circuit, shown in Figure 13-3, should be located  as  close  as  possible  to  the  microcontroller. There should be no circuits passing within the oscillator circuit  boundaries  other  than  VSS  or  VDD.  Refer  to Section 2.0  'Guidelines  for  Getting  Started  with PIC18F Microcontrollers' for additional information",
    "13.4 Timer1 Interrupt\nThe TMR1 register pair (TMR1H:TMR1L) increments from  0000h  to  FFFFh  and  rolls  over  to  0000h.  The Timer1 interrupt, if enabled, is generated on overflow, which is latched in Timer1 Interrupt Flag bit, TMR1IF (PIR1<0>). This interrupt can be enabled/disabled by setting/clearing  Timer1  Interrupt  Enable  bit,  TMR1IE (PIE1<0>).\nA write to the high byte of Timer1 must also take place through the TMR1H Buffer register. Timer1 high byte is updated  with  the  contents  of  TMR1H  when  a  write occurs to TMR1L. This allows a user to write all 16 bits to both the high and low bytes of Timer1 at once.",
    "13.5 Resetting Timer1 Using a CCP Trigger Output\nIf the CCP1 module is configured in Compare mode to generate a 'Special Event Trigger' (CCP1M<3:0> = 1011 ), this signal will reset Timer1 and start  an  A/D  conversion  if  the  A/D  module  is  enabled (see Section 16.4.4 'Special Event Trigger' for more information).\nNote:\nThe  Special Event Triggers from the CCP1 module will not set interrupt flag bit, TMR1IF (PIR1<0>).\nTimer1 must be configured for either Timer or Synchronized Counter mode to take advantage of this feature. If  Timer1  is  running  in  Asynchronous  Counter mode, this Reset operation may not work.\nIn  the  event  that  a  write  to  Timer1  coincides  with  a Special  Event  Trigger  from  CCP1,  the write will  take precedence.\nIn this mode of operation, the CCPR1H:CCPR1L register  pair  effectively  becomes  the  Period  register  for Timer1.",
    "13.6 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured for 16-bit reads and writes (see Figure 13-2). When the RD16 control bit (T1CON<7>) is set, the address for TMR1H is mapped to a buffer register for the high byte of Timer1. A read from TMR1L will load the contents of the high byte of Timer1 into the Timer1 High Byte Buffer register. This provides the user with the ability to accurately read all 16 bits of Timer1 without having to determine whether a read of the high byte, followed by a read of the low byte, is valid due to a rollover between reads.\nThe high byte of Timer1 is not directly readable or writable in this mode. All reads and writes must take place through the Timer1 High Byte Buffer register. Writes to TMR1H  do  not  clear the Timer1 prescaler. The prescaler is only cleared on writes to TMR1L.",
    "13.7 Using Timer1 as a Real-Time Clock (RTC)\nAdding an external LP oscillator to Timer1 (such as the one  described  in Section 13.2  'Timer1  Oscillator' ) gives users the option to include RTC functionality to their applications. This is accomplished with an inexpensive watch crystal to provide an accurate time base, and several lines of application code to calculate the time. When operating in Sleep mode and using a battery  or  supercapacitor  as  a  power  source,  it  can completely  eliminate  the  need  for  a  separate  RTC device and battery backup.\nThe  application code  routine, RTCisr , shown  in Example 13-1, demonstrates a simple method  to increment a counter at one-second intervals using an Interrupt  Service  Routine.  Incrementing  the  TMR1 register pair to overflow triggers the interrupt and calls the routine, which increments the seconds counter by one.  Additional  counters  for  minutes  and  hours  are incremented as the previous counter overflow.",
    "13.7 Using Timer1 as a Real-Time Clock (RTC)\nSince the register pair is 16 bits wide, counting up to overflow the register directly from a 32.768 kHz clock would  take  2  seconds.  To  force  the  overflow  at  the required one-second intervals, it is necessary to preload  it.  The  simplest  method  is  to  set  the  MSb  of TMR1H with a BSF instruction.  Note that the TMR1L register  is  never  preloaded  or  altered;  doing  so  may introduce cumulative error over many cycles.\nFor this method to be accurate, Timer1 must operate in Asynchronous mode and the Timer1 overflow interrupt must  be  enabled  (PIE1<0>  = 1 ) as  shown  in  the routine, RTCinit . The Timer1 oscillator must also be enabled and running at all times.",
    "EXAMPLE 13-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nMOVLW MOVWF CLRF MOVLW MOVWF CLRF CLRF MOVLW MOVWF BSF RETURN, 1 = 0x80 TMR1H TMR1L b'00001111' T1CON secs mins .12 hours PIE1, TMR1IE. MOVLW MOVWF CLRF MOVLW MOVWF CLRF CLRF MOVLW MOVWF BSF RETURN, 2 = ; ;. MOVLW MOVWF CLRF MOVLW MOVWF CLRF CLRF MOVLW MOVWF BSF RETURN, 3 = Preload TMR1 register pair for 1 second overflow Configure for external clock,. BSF, 1 = TMR1H, 7 PIR1, TMR1IF. BSF, 2 = ;. BSF, 3 = Preload for 1 sec overflow Clear interrupt flag. BCF INCF MOVLW CPFSGT RETURN CLRF INCF MOVLW",
    "EXAMPLE 13-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nCPFSGT RETURN CLRF INCF MOVLW CPFSGT, 1 = secs, F .59 secs secs F. BCF INCF MOVLW CPFSGT RETURN CLRF INCF MOVLW CPFSGT RETURN CLRF INCF MOVLW CPFSGT, 2 = ; ; ; ; ;. BCF INCF MOVLW CPFSGT RETURN CLRF INCF MOVLW CPFSGT RETURN CLRF INCF MOVLW CPFSGT, 3 = Increment 60 seconds No, done Clear seconds. , 1 = mins, .59. , 2 = . , 3 = Increment minutes. , 1 = mins. , 2 = . , 3 = 60 minutes elapsed?. , 1 = F. , 2 = ; ;. , 3 = clear minutes Increment hours. , 1 = .23 hours. , 2 = ;. , 3 = 24 hours elapsed?. RETURN MOVLW, 1 = . RETURN MOVLW, 2 = ;. RETURN MOVLW, 3 = .",
    "EXAMPLE 13-1: IMPLEMENTING A REAL-TIME CLOCK USING A TIMER1 INTERRUPT SERVICE\nMOVWF, 1 = . MOVWF, 2 = . MOVWF, 3 = . , 1 = .01. , 2 = . , 3 = No, done. , 1 = . , 2 = . , 3 = Reset hours to 1. , 1 = hours. , 2 = . , 3 = Done. , 1 = . , 2 = ;. , 3 = . , 1 = . , 2 = ;. , 3 = ;. RETURN, 1 = RETURN. RETURN, 2 = RETURN. RETURN, 3 = RETURN. hours,, 1 = hours,. hours,, 2 = hours,. hours,, 3 = hours,. mins, 1 = mins. mins, 2 = mins. mins, 3 = mins. ; No, done, 1 = ; No, done. ; No, done, 2 = ; No, done. ; No, done, 3 = ; No, done. ;, 1 = ;. ;, 2 = ;. ;, 3 = ;. ;, 1 = ;. ;, 2 = ;. ;, 3 = ;",
    "TABLE 13-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE.",
    "TABLE 13-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nPIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page: = 57. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page: = 57. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte.",
    "TABLE 13-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nTMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Reset Values on Page: = 55. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Reset Values on Page: = 55. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON,",
    "TABLE 13-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nBit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Reset Values on Page: = 55\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by the Timer1 module.",
    "14.1 Timer2 Operation\nThe Timer2 module has the following features:\n\u00b7 8-bit Timer register (TMR2)\n\u00b7 8-bit Period register (PR2)\n\u00b7 Readable and writable (both registers)\n\u00b7 Software programmable prescaler (1:1, 1:4, 1:16)\n\u00b7 Software programmable postscaler (1:1 to 1:16)\n\u00b7 Interrupt on TMR2 match with PR2\n\u00b7 SSP module optional use of TMR2 output to generate clock shift\nTimer2 has a control register, shown in Register 14-1. TMR2 can be shut off by clearing control bit, TMR2ON (T2CON<2>), to minimize power consumption. Figure 14-1 is a simplified block diagram of the Timer2 module. Register 14-1 shows the Timer2 Control register.  The  prescaler  and  postscaler  selection  of Timer2 are controlled by this register.",
    "14.1 Timer2 Operation\nTimer2  can  be  used  as  the  PWM  time  base  for  the PWM mode of the CCP module. The TMR2 register is readable  and  writable,  and  is  cleared  on  any  device Reset. The input clock (FOSC/4) has a prescale option of 1:1, 1:4 or 1:16, selected by control bits, T2CKPS<1:0>  (T2CON<1:0>).  The  match  output  of TMR2 goes through a 4-bit postscaler (which gives a 1:1  to  1:16  scaling  inclusive)  to  generate  a  TMR2 interrupt, latched in flag bit, TMR2IF (PIR1<1>).\nThe TMR2 and PR2 registers are both directly readable and  writable.  The  TMR2  register  is  cleared  on  any device Reset, while the PR2 register initializes at FFh.\nThe  prescaler  and  postscaler  counters  are  cleared when any of the following occurs:",
    "14.1 Timer2 Operation\n\u00b7 A write to the TMR2 register\n\u00b7 A write to the T2CON register\n\u00b7 Any device Reset (Power-on Reset, MCLR Reset, Watchdog Timer Reset or Brown-out Reset)\nTMR2 is not cleared when T2CON is written.",
    "REGISTER 14-1: T2CON: TIMER2 CONTROL REGISTER\n-, R/W-0 = TOUTPS3. -, R/W-0 = TOUTPS2. -, R/W-0 = TOUTPS1. -, R/W-0 = TOUTPS0. -, R/W-0 = TMR2ON. -, R/W-0 = T2CKPS1. -, R/W-0 = T2CKPS0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 14-1: T2CON: TIMER2 CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6-3\nTOUTPS<3:0>: Timer2 Output Postscale Select bits\n0000 = 1:1 Postscale\n0001 = 1:2 Postscale\n\u2022\n\u2022\n\u2022\n1111 = 1:16 Postscale",
    "bit 2 TMR2ON: Timer2 On bit\n1 = Timer2 is on\n0 = Timer2 is off\nbit 1-0\nT2CKPS<1:0>: Timer2 Clock Prescale Select bits\n00 = Prescaler is 1\n01 = Prescaler is 4\n1x = Prescaler is 16",
    "14.3 Output of TMR2\nTimer2 can also generate an optional device interrupt. The Timer2 output signal (TMR2 to PR2 match) provides the input for the 4-bit output counter/postscaler. This counter generates the TMR2 match interrupt flag which is latched in TMR2IF (PIR1<1>).\nThe interrupt  is  enabled  by  setting  the  TMR2  Match Interrupt  Enable  bit,  TMR2IE  (PIE1<1>).  A  range  of 16 postscale options (from 1:1 through 1:16 inclusive) can  be  selected  with  the postscaler control bits, T2OUTPS<3:0> (T2CON<6:3>).\nThe unscaled output of TMR2 is available primarily to the CCP modules, where it is used as a time base for operations  in  PWM  mode.  Timer2  can  be  optionally used  as  the  shift  clock  source  for  the  SSP  module operating in SPI mode.\nFor additional information, see Section 19.0 'Synchronous Serial Port (SSP) Module' .\nFIGURE 14-1: TIMER2 BLOCK DIAGRAM",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE.",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nPIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page: = 57. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page: = 57. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nRegister. TMR2, Reset Values on Page: = 55. T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Reset Values on Page: = 55. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Reset Values on Page: = 55",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by the Timer2 module.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "15.0 TIMER5 MODULE\nThe Timer5 module implements these features:\n\u00b7 16-bit timer/counter operation\n\u00b7 Synchronous and Asynchronous Counter modes\n\u00b7 Continuous Count and Single-Shot Operating modes\n\u00b7 Four programmable prescaler values (1:1 to 1:8)\n\u00b7 Interrupt generated on period match\n\u00b7 Special Event Trigger Reset function\n\u00b7 Double-buffered registers\n\u00b7 Operation during Sleep\n\u00b7 CPU wake-up from Sleep\n\u00b7 Selectable hardware Reset input with a wake-up feature\nTimer5 is a general purpose timer/counter that incorporates  additional  features  for  use  with  the  Motion Feedback Module (see Section 17.0 'Motion Feedback  Module' ).  It  may  also  be  used  as  a  general purpose timer or a Special Event Trigger delay timer. When  used  as  a  general  purpose  timer,  it  can  be configured to generate a delayed Special Event Trigger (e.g., an ADC Special Event Trigger) using a preprogrammed period delay.\nTimer5 is controlled through the Timer5 Control register (T5CON), shown in Register 15-1.  The  timer  can  be enabled or disabled by setting or clearing the control bit TMR5ON (T5CON<0>).",
    "15.0 TIMER5 MODULE\nA block diagram of Timer5 is shown in Figure 15-1.",
    "REGISTER 15-1: T5CON: TIMER5 CONTROL REGISTER\nT5SEN, R/W-0 = RESEN (1). T5SEN, R/W-0 = T5MOD. T5SEN, R/W-0 = T5PS1. T5SEN, R/W-0 = T5PS0. T5SEN, R/W-0 = T5SYNC (2). T5SEN, R/W-0 = TMR5CS. T5SEN, R/W-0 = TMR5ON. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 15-1: T5CON: TIMER5 CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 T5SEN: Timer5 Sleep Enable bit\n1 = Timer5 is enabled during Sleep\n0 = Timer5 is disabled during Sleep",
    "bit 6\nRESEN: Special Event Trigger Reset Enable bit (1)\n1 = Special Event Trigger Reset is disabled\n0 = Special Event Trigger Reset is enabled",
    "bit 5\nT5MOD: Timer5 Mode bit\n1 = Single-Shot mode is enabled\n0 = Continuous Count mode is enabled\nbit 4-3\nT5PS<1:0>: Timer5 Input Clock Prescale Select bits\n11 = 1:8\n10 = 1:4\n01 = 1:2\n00 = 1:1",
    "bit 2\nT5SYNC: Timer5 External Clock Input Synchronization Select bit (2)\nWhen TMR5CS = 1 :\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR5CS = 0 :\nThis bit is ignored. Timer5 uses the internal clock when TMR5CS = 0 .",
    "bit 1 TMR5CS: Timer5 Clock Source Select bit\n1 = External clock from the T5CKI pin\n0 = Internal clock (TCY)\nbit 0\nTMR5ON:\nTimer5 On bit\n1 = Timer5 is enabled\n0 = Timer5 is disabled\nNote 1: These bits are not implemented on PIC18F2331/2431 devices and read as ' 0 '.\n2: For Timer5 to operate during Sleep mode, T5SYNC must be set.",
    "15.1 Timer5 Operation\nTimer5 supports three configurations:\nTimer5 combines two 8-bit registers to function as a 16-bit timer. The TMR5L register is the actual low byte of the timer; it can be read and written to directly. The high byte is contained in an unmapped register; it is read and written to through TMR5H, which serves as a buffer. Each register increments from 00h to FFh.\nA second register pair, PR5H and PR5L, serves as the Period  register;  it  sets  the  maximum  count  for  the TMR5 register pair. When TMR5 reaches the value of PR5, the timer rolls over to 00h and sets the TMR5IF interrupt flag. A simplified block diagram of the Timer5 module is shown in Figure 2-1.",
    "Note:\nThe Timer5 may be used as a general purpose timer and as the time base resource to the Motion Feedback Module (Input Capture or Quadrature Encoder Interface).\n\u00b7 16-Bit Synchronous Timer\n\u00b7 16-Bit Synchronous Counter\n\u00b7 16-Bit Asynchronous Counter\nIn Synchronous  Timer  configuration, the timer is clocked  by  the  internal  device  clock.  The  optional Timer5 prescaler divides the input by 2, 4, 8 or not at all (1:1). The  TMR5  register  pair  increments  on  Q1. Clearing  TMR5CS  (= 0 )  selects  the  internal  device clock as the timer sampling clock.",
    "PIC18F2331/2431/4331/4431\nIn Synchronous Counter mode configuration, the timer is clocked  by  the  external  clock  (T5CKI)  with  the optional prescaler. The external T5CKI is selected by setting  the  TMR5CS  bit  (TMR5CS  = 1 );  the  internal clock  is  selected  by  clearing  TMR5CS.  The  external clock is synchronized to the internal clock by clearing the  T5SYNC bit.  The  input  on  T5CKI  is  sampled  on every Q2 and Q4 of the internal clock. The low to rise transition is  decoded on three adjacent samples and the Timer5 is incremented on the next Q1. The T5CKI minimum  pulse-width  high  and  low  time  must  be greater than TCY/2.",
    "PIC18F2331/2431/4331/4431\nIn Asynchronous Counter mode configuration, Timer5 is clocked  by  the  external  clock  (T5CKI)  with  the optional prescaler. In this mode, T5CKI is not synchronized  to  the  internal  clock.  By  setting  TMR5CS,  the external input clock (T5CKI) can be used as the counter sampling clock. When T5SYNC is set, the external clock is not synchronized to the internal device clock.\nThe  timer  count  is  not  reset  automatically  when  the module is disabled. The user may write the Counter register to initialize the counter.\nNote:\nThe  Timer5  module  does  NOT  prevent writes to the PR5 registers (PR5H:PR5L) while the timer is enabled. Writing to PR5 while  the  timer  is  enabled  may  result  in unexpected period match events.",
    "15.1.1 CONTINUOUS COUNT AND SINGLE-SHOT OPERATION\nTimer5  has  two  operating  modes:  Continuous  Count and Single-Shot.\nContinuous  Count  mode  is  selected  by  clearing  the T5MOD control bit (= 0 ). In this mode, the Timer5 time base will start incrementing according to the prescaler settings until a TMR5/PR5 match occurs, or until TMR5 rolls over (FFFFh to 0000h). The TMR5IF interrupt flag is set, the TMR5 register is reset on the following input clock edge and the timer continues to count for as long as the TMR5ON bit remains set.\nSingle-Shot mode is selected by setting T5MOD (= 1 ). In this mode, the Timer5 time base begins to increment according to the prescaler settings until a TMR5/PR5 match occurs. This causes the TMR5IF interrupt flag to be  set,  the  TMR5  register  pair  to  be  cleared  on  the following input clock edge and the TMR5ON bit to be cleared by the hardware to halt the timer.",
    "15.1.1 CONTINUOUS COUNT AND SINGLE-SHOT OPERATION\nThe Timer5 time base can only start incrementing in Single-Shot mode under two conditions:\n1. Timer5 is enabled (TMR5ON is set), or\n2. Timer5 is disabled and a Special Event Trigger Reset is present on the Timer5 Reset input. (See Section 15.7  'Timer5  Special  Event  Trigger Reset Input' for additional information.)",
    "15.2 16-Bit Read/Write and Write Modes\nAs noted, the actual high byte of the Timer5 register pair is mapped to TMR5H, which serves as a buffer. Reading TMR5L will load the contents of the high byte of the register pair into the TMR5H register. This allows the user to accurately read all 16 bits of the register pair without having to determine whether a read of the high byte, followed by the low byte, is valid due to a rollover between reads.\nSince the actual high byte of the Timer5 register pair is not directly readable or writable, it must be read and written to through the Timer5 High Byte Buffer register (TMR5H). The T5 high byte is updated with the contents of TMR5H when a write occurs to TMR5L. This allows a user to write all 16 bits to both the high and low bytes of Timer5 at once. Writes to TMR5H do not clear the Timer5 prescaler. The prescaler is only cleared on writes to TMR5L.",
    "15.2.1 16-BIT READ-MODIFY-WRITE\nRead-modify-write instructions, like BSF and BCF ,  will read the contents of a register, make the appropriate changes and place the result back into the register. The write portion of a read-modify-write instruction of TMR5H will not update the contents of the high byte of TMR5 until a write of TMR5L takes place. Only then will the contents of TMR5H be placed into the high byte of TMR5.",
    "15.3 Timer5 Prescaler\nThe Timer5 clock input (either TCY or the external clock) may  be  divided  by  using  the  Timer5  programmable prescaler. The prescaler control bits, T5PS<1:0> (T5CON<4:3>), select a prescale factor of 2, 4, 8 or no prescale.\nThe Timer5 prescaler is cleared by any of the following:\n\u00b7 A write to the Timer5 register\n\u00b7 Disabling Timer5 (TMR5ON = 0 )\n\u00b7 A device Reset such as Master Clear, POR or BOR\nNote:\nWriting  to  the  T5CON  register  does  not clear the Timer5.",
    "15.7.1 WAKE-UP ON IC1 EDGE\nThe  Timer5  module  includes  an  optional  input  noise filter, designed  to  reduce  spurious  signals  in  noisy operating environments. The filter ensures that the input is not permitted to change until a stable value has been registered for three consecutive sampling clock cycles.\nThe noise filter is part of the input filter network associated with the Motion Feedback Module (see Section 17.0 'Motion Feedback Module' ). All of the filters  are  controlled  using  the  Digital  Filter  Control (DFLTCON) register (Register 17-3). The Timer5 filter can be individually enabled or disabled by setting or clearing the FLT4EN bit (DFLTCON<6>). It is disabled on all Brown-out Resets.\nFor additional information, refer to Section 17.3 'Noise Filters' in the Motion Feedback Module.",
    "15.5 Timer5 Interrupt\nTimer5  has  the  ability  to  generate  an  interrupt  on  a period match. When the PR5 register is loaded with a new period value (00FFh), the Timer5 time base increments until its value is equal to the value of PR5. When a match occurs, the Timer5 interrupt is generated on the rising edge of Q4; TMR5IF is set on the next TCY.\nThe  interrupt  latency  (i.e.,  the  time  elapsed  from  the moment Timer5 rolls over until TMR5IF is set) will not exceed 1 TCY. When the Timer5 clock input is prescaled and  a  TMR5/PR5  match  occurs,  the  interrupt  will  be generated on the first Q4 rising edge after TMR5 resets.",
    "15.6 Timer5 Special Event Trigger Output\nA  Timer5  Special  Event  Trigger  is  generated  on  a TMR5/PR5  match.  The  Special Event Trigger is generated on the falling edge of Q3.\nTimer5  must  be  configured  for  either  Synchronous mode  (Counter  or  Timer)  to  take  advantage  of  the Special Event Trigger feature. If Timer5 is running in Asynchronous Counter mode, the Special Event Trigger may not work and should not be used.",
    "15.7 Timer5 Special Event Trigger Reset Input\nIn addition to the Special Event Trigger output, Timer5 has a Special Event Trigger Reset input that may be used with Input Capture Channel 1 (IC1) of the Motion Feedback Module.  To  use  the  Special  Event  Trigger Reset, the Capture 1 Control register, CAP1CON, must be  configured  for  one  of  the  Special  Event  Trigger modes (CAP1M<3:0> = 1110 or 1111 ).  The  Special Event  Trigger  Reset  can  be  disabled  by  setting  the RESEN control bit (T5CON<6>).\nThe Special Event Trigger Reset resets the Timer5 time base. This Reset occurs in either Continuous Count or Single-Shot modes.",
    "15.7 Timer5 Special Event Trigger Reset Input\nThe Timer5 Special Event Trigger Reset input can act as a Timer5 wake-up and a start-up pulse. Timer5 must be in Single-Shot mode and disabled (TMR5ON = 0 ). An active edge on the CAP1 input pin will set TMR5ON. The timer is subsequently incremented on the next following clock according to the prescaler and the Timer5 clock settings. A subsequent hardware time-out (such as TMR5/PR5 match) will clear the TMR5ON bit and stop the timer.",
    "15.7.2 DELAYED ACTION EVENT TRIGGER\nAn active edge on CAP1 can also be used to initiate some later action delayed by the Timer5 time base. In this  case,  Timer5  increments  as  before  after  being triggered.  When  the  hardware  time-out  occurs,  the Special Event Trigger output is generated and used to trigger another action, such as an A/D conversion. This allows a given hardware action to be referenced from a capture edge on CAP1 and delayed by the timer.\nThe event timing for the delayed action event trigger is discussed further in Section 17.1 'Input Capture' .",
    "15.7.3 SPECIAL EVENT TRIGGER RESET WHILE TIMER5 IS INCREMENTING\nIn the event that a bus write to Timer5 coincides with a Special Event Trigger Reset, the bus write will always take precedence over the Special Event Trigger Reset.",
    "15.8 Operation in Sleep Mode\nWhen Timer5 is configured for asynchronous operation, it will continue to increment each timer clock (or prescale multiple of clocks). Executing the SLEEP instruction will either stop the timer or let the timer continue, depending on the setting of the Timer5 Sleep Enable bit, T5SEN. If T5SEN is set (= 1 ), the timer continues to run when the SLEEP instruction is executed and the external clock is selected (TMR5CS = 1 ). If T5SEN is cleared, the timer stops when a SLEEP instruction is executed, regardless of the state of the TMR5CS bit.\nTo summarize, Timer5 will continue to increment when a SLEEP instruction is executed only if all of these bits are set:\n\u00b7 TMR5ON\n\u00b7 T5SEN\n\u00b7 TMR5CS\n\u00b7 T5SYNC",
    "15.8.1 INTERRUPT DETECT IN SLEEP MODE\nWhen  configured  as  described  above,  Timer5  will continue  to  increment  on  each  rising  edge  on  T5CKI while in Sleep mode. When a TMR5/PR5 match occurs, an interrupt is generated which can wake the part.",
    "TABLE 15-1: REGISTERS ASSOCIATED WITH TIMER5\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = -. IPR3, Bit 4 = PTIP. IPR3, Bit 3 = IC3DRIP. IPR3, Bit 2 = IC2QEIP. IPR3, Bit 1 = IC1IP. IPR3, Bit 0 = TMR5IP. IPR3, Reset Values on Page: = 56. PIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = -. PIE3, Bit 4 = PTIE. PIE3, Bit 3 = IC3DRIE. PIE3, Bit 2 =",
    "TABLE 15-1: REGISTERS ASSOCIATED WITH TIMER5\nIC2QEIE. PIE3, Bit 1 = IC1IE. PIE3, Bit 0 = TMR5IE. PIE3, Reset Values on Page: = 56. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = -. PIR3, Bit 4 = PTIF. PIR3, Bit 3 = IC3DRIF. PIR3, Bit 2 = IC2QEIF. PIR3, Bit 1 = IC1IF. PIR3, Bit 0 = TMR5IF. PIR3, Reset Values on Page: = 56. TMR5H, Bit 7 = Timer5 Register High Byte. TMR5H, Bit 6 = Timer5 Register High Byte. TMR5H, Bit 5 = Timer5 Register High Byte. TMR5H, Bit 4 = Timer5 Register High Byte. TMR5H, Bit 3 = Timer5 Register High Byte. TMR5H, Bit 2 = Timer5 Register High Byte. TMR5H, Bit 1 = Timer5 Register High Byte.",
    "TABLE 15-1: REGISTERS ASSOCIATED WITH TIMER5\nTMR5H, Bit 0 = Timer5 Register High Byte. TMR5H, Reset Values on Page: = 57. TMR5L, Bit 7 = TImer5 Register Low Byte. TMR5L, Bit 6 = TImer5 Register Low Byte. TMR5L, Bit 5 = TImer5 Register Low Byte. TMR5L, Bit 4 = TImer5 Register Low Byte. TMR5L, Bit 3 = TImer5 Register Low Byte. TMR5L, Bit 2 = TImer5 Register Low Byte. TMR5L, Bit 1 = TImer5 Register Low Byte. TMR5L, Bit 0 = TImer5 Register Low Byte. TMR5L, Reset Values on Page: = 57. PR5H, Bit 7 = Timer5 Period Register High Byte. PR5H, Bit 6 = Timer5 Period Register High Byte. PR5H, Bit 5 = Timer5 Period Register High Byte. PR5H, Bit 4 = Timer5 Period Register High Byte. PR5H, Bit 3 = Timer5 Period Register High Byte. PR5H, Bit 2 = Timer5 Period Register High",
    "TABLE 15-1: REGISTERS ASSOCIATED WITH TIMER5\nByte. PR5H, Bit 1 = Timer5 Period Register High Byte. PR5H, Bit 0 = Timer5 Period Register High Byte. PR5H, Reset Values on Page: = 57. PR5L, Bit 7 = Timer5 Period Register Low Byte. PR5L, Bit 6 = Timer5 Period Register Low Byte. PR5L, Bit 5 = Timer5 Period Register Low Byte. PR5L, Bit 4 = Timer5 Period Register Low Byte. PR5L, Bit 3 = Timer5 Period Register Low Byte. PR5L, Bit 2 = Timer5 Period Register Low Byte. PR5L, Bit 1 = Timer5 Period Register Low Byte. PR5L, Bit 0 = Timer5 Period Register Low Byte. PR5L, Reset Values on Page: = 57. T5CON, Bit 7 = T5SEN. T5CON, Bit 6 = RESEN. T5CON, Bit 5 = T5MOD. T5CON, Bit 4 = T5PS1. T5CON, Bit 3 = T5PS0. T5CON, Bit 2 = T5SYNC. T5CON, Bit 1 =",
    "TABLE 15-1: REGISTERS ASSOCIATED WITH TIMER5\nTMR5CS. T5CON, Bit 0 = TMR5ON. T5CON, Reset Values on Page: = 56. CAP1CON, Bit 7 = -. CAP1CON, Bit 6 = CAP1REN. CAP1CON, Bit 5 = -. CAP1CON, Bit 4 = -. CAP1CON, Bit 3 = CAP1M3. CAP1CON, Bit 2 = CAP1M2. CAP1CON, Bit 1 = CAP1M1. CAP1CON, Bit 0 = CAP1M0. CAP1CON, Reset Values on Page: = 59. DFLTCON, Bit 7 = -. DFLTCON, Bit 6 = FLT4EN. DFLTCON, Bit 5 = FLT3EN. DFLTCON, Bit 4 = FLT2EN. DFLTCON, Bit 3 = FLT1EN. DFLTCON, Bit 2 = FLTCK2. DFLTCON, Bit 1 = FLTCK1. DFLTCON, Bit 0 = FLTCK0. DFLTCON, Reset Values on Page: = 59",
    "TABLE 15-1: REGISTERS ASSOCIATED WITH TIMER5\nLegend: - = unimplemented. Shaded cells are not used by the Timer5 module.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "TABLE 16-1: CCP MODE - TIMER RESOURCES\nThe CCP (Capture/Compare/PWM) module contains a 16-bit register that can operate as a 16-bit Capture register, a 16-bit Compare register or a PWM Master/Slave Duty Cycle register. Table 16-1 shows the timer resources required for each of the CCP module modes.\nThe operation of CCP1 is identical to that of CCP2, with the exception of the Special Event Trigger. Therefore, operation of a CCP module is described with respect to CCP1, except where noted.",
    "16.1 CCP1 Module\nCapture Compare PWM, Timer Resources = Timer1 Timer1 Timer2",
    "16.2 CCP2 Module\nCapture/Compare/PWM Register 2 (CCPR2) is comprised of two 8-bit registers: CCPR2L (low byte) and CCPR2H (high byte). The CCP2CON register controls the operation of CCP2. All are readable and writable.\nCapture/Compare/PWM Register 1 (CCPR1) is comprised of two 8-bit registers:  CCPR1L (low byte) and  CCPR1H  (high  byte).  The  CCP1CON  register controls the operation of CCP1. All are readable and writable.",
    "REGISTER 16-1: CCPxCON: CCPx CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = DCxB1. -, 3 = DCxB0. -, 4 = CCPxM3. -, 5 = CCPxM2. -, 6 = CCPxM1. -, 7 = CCPxM0. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5-4 DCxB<1:0> : PWM Duty Cycle bit 1 and bit 0\nCapture mode:\nUnused.\nCompare mode:\nUnused.\nPWM mode:\nThese bits are the two LSBs (bit 1 and bit 0) of the 10-bit PWM duty cycle. The upper eight bits (DCxB<9:2>) of the duty cycle are found in CCPRxL.\nCCPxM<3:0> : CCPx Mode Select bits\n0000 = Capture/Compare/PWM disabled (resets CCPx module)\n0001 = Reserved\n0010 = Compare mode; toggle output on match (CCPxIF bit is set)",
    "Legend:\n0011 = Reserved\n0100 = Capture mode; every falling edge\n0101 = Capture mode; every rising edge\n0110 = Capture mode; every 4th rising edge\n0111 = Capture mode; every 16th rising edge\n1000 = Compare mode; initialize CCPx pin low; on compare match, force CCPx pin high (CCPxIF bit is set)\n1001 = Compare mode; initialize CCPx pin high; on compare match, force CCPx pin low (CCPxIF bit is set)\n1010 = Compare mode; generate software interrupt on compare match (CCPxIF bit is set, CCPx pin is unaffected)\n1011 = Compare mode; Special Event Trigger (CCPxIF bit is set)\n11xx\n=\nPWM mode",
    "16.3.3 SOFTWARE INTERRUPT\nIn Capture  mode,  CCPR1H:CCPR1L  captures  the 16-bit  value  of  the  TMR1  register  when  an  event occurs  on  pin  RC2/CCP1.  An  event  is  defined  as one of the following:\n\u00b7 every falling edge\n\u00b7 every rising edge\n\u00b7 every 4th rising edge\n\u00b7 every 16th rising edge\nThe  event  is  selected  by  control  bits,  CCP1M<3:0> (CCP1CON<3:0>).  When  a  capture  is made,  the interrupt request flag bit,  CCP1IF (PIR1<2>), is set; it must be cleared in software. If another capture occurs before  the  value  in  register  CCPR1  is  read,  the  old captured value is overwritten by the new captured value.",
    "16.3.1 CCP PIN CONFIGURATION\nIn Capture  mode,  the  RC2/CCP1  pin  should  be configured as an input by setting the TRISC<2> bit.\nNote:, 1 = If the RC2/CCP1 pin is configured as an output, a write to the port can cause a capture condition.",
    "16.3.2 TIMER1 MODE SELECTION\nTimer1  must  be  running  in  Timer  mode  or  Synchronized  Counter  mode  to  be  used  with  the  capture feature. In Asynchronous Counter mode, the capture operation may not work.\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user should keep bit, CCP1IE (PIE1<2>), clear to avoid false interrupts and should clear the flag bit, CCP1IF, following any such change in operating mode.",
    "16.3.4 CCP PRESCALER\nThere  are  four  prescaler  settings  specified  by  bits CCP1M<3:0>. Whenever the CCP module is turned off, or  the  CCP  module  is  not  in  Capture  mode,  the prescaler  counter  is  cleared.  This  means  that  any Reset will clear the prescaler counter.\nSwitching from one capture prescaler to another may generate an interrupt. Also, the prescaler counter will not be cleared, therefore, the first capture may be from a non-zero prescaler. Example 16-1 shows the recommended method for switching between capture prescalers.  This  example  also  clears  the  prescaler counter and will not generate the 'false' interrupt.",
    "EXAMPLE 16-1: CHANGING BETWEEN CAPTURE PRESCALERS\nCLRF MOVLW, 1 = CCP1CON. CLRF MOVLW, 2 = ; Turn CCP module off ; Load WREG with the ; new prescaler mode ; value and CCP ON. , 1 = NEW_CAPT_PS. , 2 = . MOVWF, 1 = CCP1CON. MOVWF, 2 = ; Load CCP1CON with ; this value",
    "16.4.2 TIMER1 MODE SELECTION\nIn Compare mode, the 16-bit CCPR1 (CCPR2) register value is constantly compared  against the TMR1 register  pair  value.  When  a  match  occurs,  the  RC2/ CCP1 (RC1/CCP2) pin:\n\u00b7 is driven high\n\u00b7 is driven low\n\u00b7 toggles output (high-to-low or low-to-high)\n\u00b7 remains unchanged (interrupt only)\nThe action on the pin is based on the value of control bits,  CCP1M<3:0> (CCP2M<3:0>). At the same time, interrupt flag bit CCP1IF (CCP2IF) is set.",
    "16.4.1 CCP PIN CONFIGURATION\nThe user must configure the CCP1 pin as an output by clearing the appropriate TRISC bit.\nNote:\nClearing the CCPxCON register will force the RC1 or RC2 compare output latch to the  default  low  level.  This  is  not  the PORTC I/O data latch.\nTimer1  must  be  running  in  Timer  mode  or  Synchronized  Counter  mode if  the CCP module is using the compare feature. In Asynchronous Counter mode, the compare operation may not work.",
    "16.4.3 SOFTWARE INTERRUPT MODE\nWhen generate software interrupt is chosen, the CCP1 pin is not affected. Only a CCP interrupt is generated (if enabled).",
    "16.4.4 SPECIAL EVENT TRIGGER\nIn this mode, an internal hardware trigger is generated which may be used to initiate an action.\nThe Special Event Trigger output of CCP1 resets the TMR1 register pair. This allows the CCPR1 register to effectively be a 16-bit programmable period register for Timer1.\nThe Special Event Trigger output of CCP2 resets the TMR1  register  pair.  Additionally,  the  CCP2  Special Event Trigger will  start  an  A/D  conversion  if  the  A/D module is enabled.\nNote:\nThe Special Event Trigger from the CCP2 module  will  not  set  the  Timer1  interrupt flag bit.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE AND TIMER1\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE AND TIMER1\nPIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page: = 57. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page: = 57. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE AND TIMER1\nTRISC, Reset Values on Page: = 57. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Reset Values on Page: = 55. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE AND TIMER1\n1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Reset Values on Page: = 55. T1CON, Bit 7 = RD16. T1CON, Bit 6 = T1RUN. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Reset Values on Page: = 55. CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Capture/Compare/PWM Register",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE AND TIMER1\n1 Low Byte. CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Reset Values on Page: = 56. CCPR1H, Bit 7 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 High Byte. CCPR1H,",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE AND TIMER1\nReset Values on Page: = 56. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Reset Values on Page: = 56. CCPR2L, Bit 7 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 6 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 5 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 4 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 3 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 2 = Capture/Compare/PWM Register 2 Low",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE AND TIMER1\nByte. CCPR2L, Bit 1 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 0 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Reset Values on Page: = 56. CCPR2H, Bit 7 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 6 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 5 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 4 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 3 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 2 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 1 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 0 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Reset Values on Page: = 56. CCP2CON, Bit 7 = -.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE AND TIMER1\nCCP2CON, Bit 6 = -. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Reset Values on Page: = 56. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = -. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = -. PIR2, Bit 0 = CCP2IF. PIR2, Reset Values on Page: = 57. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = -.",
    "TABLE 16-2: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE AND TIMER1\nPIE2, Bit 2 = LVDIE. PIE2, Bit 1 = -. PIE2, Bit 0 = CCP2IE. PIE2, Reset Values on Page: = 57. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = -. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = -. IPR2, Bit 0 = CCP2IP. IPR2, Reset Values on Page: = 57\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used by Capture, Compare and Timer1.",
    "16.5 PWM Mode\nIn Pulse-Width Modulation (PWM) mode, the CCP1 pin produces up to a 10-bit resolution PWM output. Since the CCP1 pin is multiplexed with the PORTC data latch, the TRISC<2> bit must be cleared to make the CCP1 pin an output.\nNote:, 1 = Clearing the CCP1CON register will force the CCP1 PWMoutput latch to the default low level. This is not the PORTC I/O data latch.\nFigure 16-3  shows  a  simplified  block  diagram  of  the CCP1 module in PWM mode.\nFor  a  step-by-step  procedure  on  how  to  set  up  the CCP1 module for PWM operation, see Section 16.5.3 'Setup for PWM Operation' .",
    "DIAGRAM\nA  PWM  output  (Figure 16-4)  has  a  time  base (period)  and  a  time  that  the  output  is  high  (duty cycle). The frequency of the PWM is the inverse of the period (1/period).",
    "16.5.1 PWM PERIOD\nThe  PWM  period  is  specified  by  writing  to  the  PR2 register. The PWM period can be calculated using the following equation:",
    "EQUATION 16-1:\nPWM Period = [(PR2) + 1] \u00b7 4 \u00b7 TOSC \u00b7 (TMR2 Prescale Value)\nPWM frequency is defined as 1/[PWM period]. When TMR2 is equal to PR2, the following three events occur on the next increment cycle:\n\u00b7 TMR2 is cleared\n\u00b7 The CCP1 pin is set (if PWM duty cycle = 0%, the CCP1 pin will not be set)\n\u00b7 The PWM duty cycle is copied from CCPR1L into CCPR1H\nNote:\nThe Timer2 postscaler (see Section 14.0 'Timer2  Module' ) is not  used  in  the determination of the PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.",
    "16.5.2 PWM DUTY CYCLE\nThe  PWM  duty  cycle  is  specified  by  writing  to  the CCPR1L register and to the CCP1CON<5:4> bits. Up to 10-bit resolution is available. The CCPR1L contains the eight MSbs and the CCP1CON<5:4> contains the two LSbs. This 10-bit value is represented by CCPR1L:CCP1CON<5:4>.  The  PWM  duty  cycle  is calculated by the following equation:",
    "EQUATION 16-2:\nPWM Duty Cycle = (CCPR1L:CCP1CON<5:4>) \u00b7 TOSC \u00b7 (TMR2 Prescale Value)\nCCPR1L and CCP1CON<5:4> can be written to at any time,  but  the  duty  cycle  value  is  not  copied  into CCPR1H until a match between PR2 and TMR2 occurs (i.e., the period is complete). In PWM mode, CCPR1H is a read-only register.",
    "PIC18F2331/2431/4331/4431\nThe  CCPR1H  register  and  a  2-bit  internal  latch  are used to double buffer the PWM duty cycle. This double buffering  is  essential  for  glitchless  PWM  operation. When  the  CCPR1H  and  2-bit  latch  match  TMR2, concatenated with an internal 2-bit Q clock or two bits of the TMR2 prescaler, the CCP1 pin is cleared. The maximum  PWM  resolution  (bits)  for  a  given  PWM frequency is given by the following equation:",
    "EQUATION 16-3:\n<!-- formula-not-decoded -->",
    "16.5.3 SETUP FOR PWM OPERATION\nThe following steps should be taken when configuring the CCP1 module for PWM operation:\n1. Set the PWM period by writing to the PR2 register.\n2. Set the PWM duty cycle by writing to the CCPR1L register and CCP1CON<5:4> bits.\n3. Make  the  CCP1  pin  an  output  by  clearing  the TRISC<2> bit.\n4. Set the TMR2 prescale value and enable Timer2 by writing to T2CON.\n5. Configure the CCP1 module for PWM operation.\nNote:\nIf the PWM duty cycle value is longer than the PWM period, the CCP1 pin will not be cleared.",
    "TABLE 16-3: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\nTimer Prescaler (1, 4, 16), 2.44 kHz = 16. Timer Prescaler (1, 4, 16), 9.77 kHz = 4. Timer Prescaler (1, 4, 16), 39.06 kHz = 1. Timer Prescaler (1, 4, 16), 156.25 kHz = 1. Timer Prescaler (1, 4, 16), 312.50 kHz = 1. Timer Prescaler (1, 4, 16), 416.67 kHz = 1. PR2 Value, 2.44 kHz = FFh. PR2 Value, 9.77 kHz = FFh. PR2 Value, 39.06 kHz = FFh. PR2 Value, 156.25 kHz = 3Fh. PR2 Value, 312.50 kHz = 1Fh. PR2 Value, 416.67 kHz = 17h. Maximum Resolution (bits), 2.44 kHz = 10. Maximum Resolution (bits), 9.77 kHz = 10. Maximum Resolution (bits), 39.06 kHz = 10. Maximum Resolution (bits), 156.25 kHz =",
    "TABLE 16-3: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\n8. Maximum Resolution (bits), 312.50 kHz = 7. Maximum Resolution (bits), 416.67 kHz = 6.58",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, ResetValues on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, ResetValues on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nSSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, ResetValues on Page: = 57. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, ResetValues on Page: = 57. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nPORTC Data Direction Register. TRISC, ResetValues on Page: = 57. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, ResetValues on Page: = 55. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, ResetValues on Page: = 55. T2CON, Bit 7 = -. T2CON, Bit",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, ResetValues on Page: = 55. CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= Capture/Compare/PWM Register 1 Low Byte. CCPR1L, ResetValues on Page: = 56. CCPR1H, Bit 7 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, ResetValues on Page: = 56. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nDC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, ResetValues on Page: = 56. CCPR2L, Bit 7 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 6 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 5 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 4 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 3 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 2 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 1 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 0 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L,",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nResetValues on Page: = 56. CCPR2H, Bit 7 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 6 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 5 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 4 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 3 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 2 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 1 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 0 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, ResetValues on Page: = 56. CCP2CON, Bit 7 = -. CCP2CON, Bit 6 = -. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nCCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, ResetValues on Page: = 56\nLegend: x = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by PWM and Timer2.",
    "17.0 MOTION FEEDBACK MODULE\nThe  Motion  Feedback  Module  (MFM)  is  a  special purpose  peripheral designed  for motion  feedback applications.  Together  with  the  Power  Control  PWM (PCPWM) module (see Section 18.0 'Power Control PWM  Module' ), it provides a variety of control solutions for a wide range of electric motors.\nMany of the features for the IC and QEI submodules are fully  programmable, creating a flexible peripheral structure  that  can  accommodate  a  wide  range  of in-system uses. An overview of the available features is presented in Table 17-1. A simplified block diagram of  the  entire  Motion  Feedback  Module  is  shown  in Figure 17-1.\nThe module actually consists of two hardware submodules:\n\u00b7 Input Capture (IC)\n\u00b7 Quadrature Encoder Interface (QEI)\nBecause the same input pins are common to the IC and QEI submodules, only one of these  two  submodules  may  be  used  at any given time. If both modules are on, the QEI submodule will take precedence.\nTogether  with  Timer5  (see Section 15.0  'Timer5 Module' ), these modules provide a number  of options for motion and control applications.",
    "TABLE 17-1: SUMMARY OF MOTION FEEDBACK MODULE FEATURES\nIC (3x), Mode(s) = \u2022 Synchronous \u2022 Input Capture. IC (3x), Features = \u2022 Flexible Input Capture modes \u2022 Available Prescaler \u2022 Selectable Time Base Reset \u2022 Special Event Trigger for ADC Sampling/Conversion or Optional TMR5 Reset Feature (CAP1 only) \u2022 Wake-up from Sleep function \u2022 Selectable Interrupt Frequency \u2022 Optional Noise Filter. IC (3x), Timer = TMR5. IC (3x),  = \u2022 3x Input Capture (edge capture, pulse width, period measurement, capture on change) \u2022 Special Event Triggers the A/D Conversion on the CAP1 Input. QEI, Mode(s) = QEI. QEI, Features = \u2022 Detect Position \u2022 Detect Direction of Rotation \u2022 Large Bandwidth (F CY/16) \u2022 Optional Noise Filter. QEI, Timer = 16-Bit Position Counter. QEI,",
    "TABLE 17-1: SUMMARY OF MOTION FEEDBACK MODULE FEATURES\n= \u2022 Position Measurement \u2022 Direction of Rotation Status. QEI, Mode(s) = Velocity Measurement. QEI, Features = \u2022 2x and 4x Update modes \u2022 Velocity Event Postscaler \u2022 Counter Overflow Flag for Low Rotation Speed \u2022 Utilizes Input Capture 1 Logic (IC1) \u2022 High and Low Velocity Support. QEI, Timer = TMR5. QEI,  = \u2022 Precise Velocity Measurement \u2022 Direction of Rotation Status",
    "17.1 Input Capture\nThe  Input  Capture  (IC)  submodule  implements  the following features:\n\u00b7 Three channels of independent input capture (16-bits/channel) on the CAP1, CAP2 and CAP3 pins\n\u00b7 Edge-Trigger, Period or Pulse-Width Measurement Operating modes for each channel\nInput Channel  1  (IC1)  includes  a  Special  Event Trigger  that  can  be  configured  for  use  in  Velocity Measurement  mode.  Its  block  diagram  is  shown  in Figure 17-2.  IC2  and  IC3  are  similar,  but  lack  the Special Event Trigger features or additional velocity measurement logic. A representative block diagram is shown in Figure 17-3. Please note that the time base is Timer5.\n\u00b7 Programmable prescaler on every input capture channel\n\u00b7 Special Event Trigger output (IC1 only)\n\u00b7 Selectable noise filters on each capture input",
    "PIC18F2331/2431/4331/4431\nThe three input capture channels are controlled through the Input Capture Control registers, CAP1CON, CAP2CON and CAP3CON. Each channel is configured independently with its dedicated register. The implementation of the registers is identical except for the  Special  Event  Trigger  (see Section 17.1.8 'Special  Event  Trigger  (CAP1  Only)' ).  The  typical Capture Control register is shown in Register 17-1.\nNote:\nThroughout  this  section,  references  to registers and bit names that may be associated with a specific capture channel will be referred to generically by the use of the term 'x'  in  place  of  the  channel  number. For example, 'CAPxREN' may refer to the Capture  Reset Enable bit in  CAP1CON, CAP2CON or CAP3CON.",
    "REGISTER 17-1: CAPxCON: INPUT CAPTURE x CONTROL REGISTER\nU-0, 1 = R/W-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = CAPxREN. -, 2 = -. -, 3 = -. -, 4 = CAPxM3. -, 5 = CAPxM2. -, 6 = CAPxM1. -, 7 = CAPxM0. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 17-1: CAPxCON: INPUT CAPTURE x CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6\nCAPxREN:\nTime Base Reset Enable bit\n1 = Enabled\n0 = Disable selected time base Reset on capture",
    "bit 3-0 CAPxM<3:0>: Input Capture x (ICx) Mode Select bits\n1111 = Special Event Trigger mode; the trigger occurs on every rising edge on CAP1 input (1)\n1110 = Special Event Trigger mode; the trigger occurs on every falling edge on CAP1 input (1)\n1101 = Unused\n1100 = Unused\n1011 = Unused\n1010 = Unused\n1001 = Unused\n1000 = Capture on every CAPx input state change\n0111 = Pulse-Width Measurement mode, every rising to falling edge\n0110 = Pulse-Width Measurement mode, every falling to rising edge\n0101 = Frequency Measurement mode, every rising edge\n0100 = Capture mode, every 16th rising edge\n0011 = Capture mode, every 4th rising edge\n0010 = Capture mode, every rising edge\n0001 = Capture mode, every falling edge\n0000 = Input Capture x (ICx) off\nNote 1: Special Event Trigger is only available on CAP1. For CAP2 and CAP3, this configuration is unused.",
    "PIC18F2331/2431/4331/4431\nWhen in Counter mode, the counter must be configured as the synchronous counter only (T5SYNC = 0 ). When  configured  in Asynchronous mode, the IC module will not work properly.",
    "17.1.1 EDGE CAPTURE MODE\nNote 1: Input capture prescalers are reset (cleared) when the input capture module is disabled (CAPxM = 0000 ).\n2: When the Input Capture mode is changed, without first disabling the module and entering the new Input Capture  mode,  a  false  interrupt  (or  Special Event Trigger on IC1) may be generated. The  user  should  either:  (1)  disable  the input  capture  before  entering  another mode, or (2) disable IC interrupts to avoid false interrupts during IC mode changes.\n3: During IC mode changes, the prescaler count will  not  be  cleared,  therefore,  the first capture in the new IC mode may be from the non-zero prescaler.",
    "17.1.1 EDGE CAPTURE MODE\nIn  this  mode,  the  value  of  the  time  base  is  captured either on every rising edge, every falling edge, every 4th rising edge, or every 16th rising edge. The edge present  on  the  input  capture  pin  (CAP1,  CAP2  or CAP3)  is  sampled  by  the  synchronizing  latch.  The signal is used to load the Input Capture Buffer (ICxBUF register) on the following Q1 clock (see Figure 17-4). Consequently, Timer5 is either reset to ' 0 ' (Q1 immediately  following  the  capture  event)  or  left  free running, depending on the setting of the Capture Reset Enable bit, CAPxREN, in the CAPxCON register.",
    "Note:\nOn  the  first  capture  edge  following  the setting  of  the  Input  Capture  mode  (i.e., MOVWF  CAP1CON ),  Timer5  contents  are always  captured  into  the  corresponding Input Capture  Buffer  (i.e., CAPxBUF). Timer5 can optionally be reset; however, this  is  dependent  on  the  setting  of  the Capture Reset Enable bit, CAPxREN (see Figure 17-4).",
    "FIGURE 17-4: EDGE CAPTURE MODE TIMING\nNote 1: TMR5 is a synchronous time base input to the input capture; prescaler = 1:1. It increments on the Q1 rising edge.\n2: IC1  is  configured  in  Edge  Capture  mode  (CAP1M<3:0>  = 0010 )  with  the  time  base  reset  upon  edge  capture (CAP1REN = 1 ) and no noise filter.\n3: TMR5 value is latched by CAP1BUF on TCY. In the event that a write to TMR5 coincides with an input capture event, the write will always take precedence. All Input Capture Buffers, CAP1BUF, CAP2BUF and CAP3BUF, are updated with the incremented value of the time base on the next TCY clock edge when the capture event takes place (see Note 4 when Reset occurs).\n4: TMR5 Reset is normally an asynchronous Reset signal to TMR5. When used with the input capture, it is active immediately after the time base value is captured.",
    "FIGURE 17-4: EDGE CAPTURE MODE TIMING\n5: TMR5 Reset pulse is disabled by clearing the CAP1REN bit (e.g., BCF CAP1CON, CAP1REN ).",
    "17.1.2 PERIOD MEASUREMENT MODE\nThe Period Measurement mode is selected by setting CAPxM<3:0> = 0101 . In this mode, the value of Timer5 is latched into the CAPxBUF register on the rising edge of the input capture trigger and Timer5 is subsequently reset to 0000h (optional by setting CAPxREN = 1 ) on the  next  TCY  (see  capture  and  Reset  relationship  in Figure 17-4).\nTimer5 is always reset on the edge when the measurement is first initiated. For example, when the measurement is  based  on  the  falling  to  rising  edge, Timer5 is first reset on the falling edge, and thereafter, the timer value is captured on the rising edge. Upon entry  into  the  Pulse-Width  Measurement  mode,  the very  first  edge  detected  on  the  CAPx  pin  is  always captured. The TMR5 value is reset on the first active edge (see Figure 17-5).",
    "17.1.3 PULSE-WIDTH MEASUREMENT MODE\nThe Pulse-Width Measurement mode can be configured for  two different  edge  sequences, such that the pulse width is based on either the falling to rising edge of the CAPx input pin (CAPxM<3:0> = 0110 ), or on the rising to falling edge (CAPxM<3:0> = 0111 ).",
    "FIGURE 17-5: PULSE-WIDTH MEASUREMENT MODE TIMING\nNote 1: TMR5 is a synchronous time base input to the input capture; prescaler = 1:1. It increments on every Q1 rising edge.\n2: IC1  is configured  in Pulse-Width  Measurement  mode  (CAP1M<3:0>  = 0111 , rising to falling pulse-width measurement). No noise filter on CAP1 input is used. The MOVWF instruction loads CAP1CON when W = 0111 .\n3: TMR5 value is latched by CAP1BUF on TCY rising edge. In the event that a write to TMR5 coincides with an input capture event, the write will always take precedence. All Input Capture Buffers, CAP1BUF, CAP2BUF and CAP3BUF, are updated with the incremented value of the time base on the next TCY clock edge when the capture event takes place (see Note 4 when Reset occurs).",
    "FIGURE 17-5: PULSE-WIDTH MEASUREMENT MODE TIMING\n4: TMR5 Reset is normally an asynchronous Reset signal to TMR5. When used in Pulse-Width Measurement mode, it is always present on the edge that first initiates the pulse-width measurement (i.e., when configured in the rising to falling Pulse-Width Measurement mode); it is active on each rising edge detected. In the falling to rising Pulse-Width Measurement mode, it is active on each falling edge detected.\n5: TMR5 Reset pulse is activated on the capture edge. The CAP1REN bit has no bearing in this mode.",
    "17.1.3.1 Pulse-Width Measurement Timing\nPulse-width measurement accuracy can only be ensured when the pulse-width high and low present on the  CAPx  input  exceeds  one  TCY  clock  cycle.  The limitations depend on the mode selected:",
    "17.1.4 INPUT CAPTURE ON STATE CHANGE\n\u00b7 When CAPxM<3:0> = 0110 (rising to falling edge delay), the CAPx input high pulse width (TCCH) must exceed TCY + 10 ns.\n\u00b7 When CAPxM<3:0> = 0111 (falling to rising edge delay), the CAPx input low pulse width (TCCL) must exceed TCY + 10 ns.\nNote 1: The Period Measurement mode will produce valid results upon sampling of the second rising  edge  of  the  input  capture. CAPxBUF values latched during the first active edge after initialization are invalid.\nWhen CAPxM<3:0> = 1000 , the value is captured on every  signal  change  on  the  CAPx  input.  If  all  three capture channels are configured in this mode, the three input captures can be used as the Hall effect sensor state  transition  detector. The  value of Timer5 can be captured,  Timer5  reset  and  the  interrupt  generated. Any change on CAP1, CAP2 or CAP3 is detected and the associated time base count is captured.",
    "17.1.4 INPUT CAPTURE ON STATE CHANGE\nFor position and velocity measurement in this mode, the timer can be optionally reset (see Section 17.1.6 'Timer5 Reset' for Reset options).\n- 2: The Pulse-Width Measurement mode will latch the value of the timer upon sampling of the first input signal edge by the input capture.",
    "FIGURE 17-6: INPUT CAPTURE ON STATE CHANGE (HALL EFFECT SENSOR MODE)\nNote 1: TMR5 can be selected as the time base for input capture. The time base can be optionally reset when the Capture Reset Enable bit is set (CAPxREN = 1 ).\n2: Detailed CAPxBUF event timing (all modes reflect the same capture and Reset timing) is shown in Figure 17-4. There are six commutation BLDC Hall effect sensor states shown. The other two remaining states (i.e., 000h and 111h ) are invalid in the normal operation. They remain to be decoded by the CPU firmware in BLDC motor application.",
    "17.1.5 ENTERING INPUT CAPTURE MODE AND CAPTURE TIMING\nThe  following  is  a  summary  of  functional  operation upon entering any of the Input Capture modes:",
    "17.1.5 ENTERING INPUT CAPTURE MODE AND CAPTURE TIMING\n1. After  the  module  is  configured  for  one  of  the Capture  modes  by  setting  the  Capture  Mode Select  bits  (CAPxM<3:0>),  the  first  detected edge captures the Timer5 value and stores it in the CAPxBUF register. The timer is then reset (depending on the setting of CAPxREN bit) and starts to increment according to its settings (see Figure 17-4, Figure 17-5 and Figure 17-6).\n2. On  all  edges,  the  capture  logic  performs  the following:\na) Input  Capture  mode  is  decoded  and  the active edge is identified.\nb) The CAPxREN bit is checked to determine whether Timer5 is reset or not.\nc) On every active edge, the Timer5 value is recorded in the Input Capture Buffer (CAPxBUF).\nd) Reset  Timer5  after  capturing  the  value  of the timer when the CAPxREN  bit is enabled.  Timer5  is  reset  on  every  active capture edge in this case.\ne) On  all  continuing  capture  edge  events, repeat steps (a) through (d) until the operational  mode  is  terminated,  either  by  user firmware, POR or BOR.",
    "17.1.6 TIMER5 RESET\nEvery input capture trigger can optionally reset (TMR5).  The  Capture  Reset  Enable  bit,  CAPxREN, gates the automatic Reset of the time base of the capture  event  with  this  enable  Reset  signal.  All  capture events reset the selected timer when CAPxREN is set. Resets are disabled when CAPxREN is cleared (see Figure 17-4, Figure 17-5 and Figure 17-6).\nNote:, 1 = The CAPxREN bit has no effect in Pulse-Width Measurement mode.",
    "17.1.7 IC INTERRUPTS\nThere  are  four  operating  modes  for  which  the  IC module can generate an interrupt and set one of the Interrupt Capture Flag bits (IC1IF, IC2QEIF or IC3DRIF). The interrupt flag that is set depends on the channel in which the event occurs. The modes are:\n\u00b7 Edge Capture (CAPxM<3:0> = 0001 0010 0011 , , or 0100 )\n\u00b7 Period Measurement Event (CAPxM<3:0> = 0101 )\n\u00b7 Pulse-Width Measurement Event (CAPxM<3:0> = 0110 or 0111 )\n\u00b7 State Change Event (CAPxM<3:0> = 1000 )",
    "Note:\nThe  Special  Event  Trigger  is  generated only in the Special Event Trigger mode on the  CAP1  input  (CAP1M<3:0>  = 1110 and 1111 ). IC1IF interrupt is not set in this mode.\n- f) The timer value is not affected when switching  into  and  out  of  various  Input  Capture modes.\nThe  timing  of  interrupt  and  Special  Event  Trigger events  is  shown  in  Figure 17-7.  Any  active  edge  is detected on the rising edge of Q2 and propagated on the  rising  edge  of  Q4  rising  edge.  If  an  active  edge happens to occur any later than this (on the falling edge of Q2, for example), then it will be recognized on the next Q2 rising edge.",
    "17.1.9 OPERATING MODES SUMMARY\nThe Special Event Trigger mode of IC1 (CAP1M<3:0> = 1110 or 1111 )  enables  the  Special Event Trigger signal. The trigger signal can be used as the Special Event  Trigger Reset  input to TMR5, resetting the timer when the specific event happens on IC1. The events are summarized in Table 17-2.",
    "TABLE 17-2: SPECIAL EVENT TRIGGER\n1110, Description = The trigger occurs on every falling edge on the CAP1 input.. 1111, Description = The trigger occurs on every rising edge on the CAP1 input.\nTable 17-3  shows  a  summary  of  the  input  capture configuration when used in conjunction with the TMR5 timer resource.",
    "17.1.10 OTHER OPERATING MODES\nAlthough  the  IC  and  QEI  submodules  are  mutually exclusive, the IC can be reconfigured to work with the QEI module to perform specific functions. In effect, the QEI 'borrows' hardware from the IC to perform these operations.\nFor  velocity  measurement,  the  QEI  uses  dedicated hardware in channel IC1. The CAP1BUF registers are remapped, becoming the VELR registers. Its operation and  use  are  described  in Section 17.2.6  'Velocity Measurement' .\nWhile in QEI mode, the CAP2BUF and CAP3BUF registers  of  channel  IC2  and  IC3  are  used  for  position determination.  They  are  remapped  as  the  POSCNT and MAXCNT Buffer registers, respectively.",
    "TABLE 17-3: INPUT CAPTURE TIME BASE RESET SUMMARY\nCAP1, CAPxM = 0001-0100. CAP1, Mode = Edge Capture. CAP1, Timer = TMR5. CAP1, Reset Timer on Capture = optional (1). CAP1, Description = Simple Edge Capture mode (includes a selectable prescaler).. CAP1, CAPxM = 0101. CAP1, Mode = Period Measurement. CAP1, Timer = TMR5. CAP1, Reset Timer on Capture = optional (1). CAP1, Description = Captures Timer5 on period boundaries.. CAP1, CAPxM = 0110-0111. CAP1, Mode = Pulse-Width Measurement. CAP1, Timer = TMR5. CAP1, Reset Timer on Capture = always. CAP1, Description = Captures Timer5 on pulse boundaries.. CAP1, CAPxM = 1000. CAP1, Mode = Input Capture on State Change. CAP1, Timer = TMR5. CAP1, Reset Timer on Capture = optional (1). CAP1, Description = Captures Timer5 on state change.. CAP1, CAPxM = 1110-1111.",
    "TABLE 17-3: INPUT CAPTURE TIME BASE RESET SUMMARY\nCAP1, Mode = Special Event Trigger (rising or falling edge). CAP1, Timer = TMR5. CAP1, Reset Timer on Capture = optional (2). CAP1, Description = Used as a Special Event Trigger to be used with the Timer5 or other peripheral modules.. CAP2, CAPxM = 0001-0100. CAP2, Mode = Edge Capture. CAP2, Timer = TMR5. CAP2, Reset Timer on Capture = optional (1). CAP2, Description = Simple Edge Capture mode (includes a selectable prescaler).. CAP2, CAPxM = 0101. CAP2, Mode = Period Measurement. CAP2, Timer = TMR5. CAP2, Reset Timer on Capture = optional (1). CAP2, Description = Captures Timer5 on period boundaries.. CAP2, CAPxM = 0110-0111. CAP2, Mode = Pulse-Width Measurement. CAP2, Timer = TMR5. CAP2, Reset Timer on Capture = always. CAP2, Description = Captures Timer5 on pulse boundaries.. CAP2, CAPxM = 1000.",
    "TABLE 17-3: INPUT CAPTURE TIME BASE RESET SUMMARY\nCAP2, Mode = Input Capture on State Change. CAP2, Timer = TMR5. CAP2, Reset Timer on Capture = optional (1). CAP2, Description = Captures Timer5 on state change.. CAP3, CAPxM = 0001-0100. CAP3, Mode = Edge Capture. CAP3, Timer = TMR5. CAP3, Reset Timer on Capture = optional (1). CAP3, Description = Simple Edge Capture mode (includes a selectable prescaler).. CAP3, CAPxM = 0101. CAP3, Mode = Period Measurement. CAP3, Timer = TMR5. CAP3, Reset Timer on Capture = optional (1). CAP3, Description = Captures Timer5 on period boundaries.. CAP3, CAPxM = 0110-0111. CAP3, Mode = Pulse-Width Measurement. CAP3, Timer = TMR5. CAP3, Reset Timer on Capture = always. CAP3, Description = Captures Timer5 on pulse boundaries.. CAP3, CAPxM = 1000. CAP3, Mode = Input Capture on State Change. CAP3, Timer",
    "TABLE 17-3: INPUT CAPTURE TIME BASE RESET SUMMARY\n= TMR5. CAP3, Reset Timer on Capture = optional (1). CAP3, Description = Captures Timer5 on state change.\nNote 1: Timer5 may be reset on capture events only when CAPxREN = 1 .\n2: Trigger mode will not reset Timer5 unless RESEN = 0 in the T5CON register.",
    "17.2 Quadrature Encoder Interface\nThe  Quadrature  Encoder  Interface  (QEI)  decodes speed and motion sensor information. It can be used in any  application  that  uses  a  quadrature  encoder  for feedback. The interface implements these features:\nThe QEI control logic detects the leading edge on the QEA or QEB phase input pins and generates the count pulse, which is sent to the position counter logic. It also samples the index input signal (INDX) and generates the direction of the rotation signal (up/down) and the velocity event signals.\n\u00b7 Three QEI inputs: two phase signals (QEA and QEB) and one index signal (INDX)\n\u00b7 Direction of movement detection with a direction change interrupt (IC3DRIF)\n\u00b7 16-bit up/down position counter\n\u00b7 Standard and High-Precision Position Tracking modes\n\u00b7 Two Position Update modes (x2 and x4)\n\u00b7 Velocity measurement with a programmable postscaler for high-speed velocity measurement\n\u00b7 Position counter interrupt (IC2QEIF in the PIR3 register)\n\u00b7 Velocity control interrupt (IC1IF in the PIR3 register)",
    "17.2 Quadrature Encoder Interface\nThe QEI submodule has three main components: the QEI  control  logic  block,  the  position  counter  and velocity postscaler.\nThe position counter acts as an integrator for tracking distance  traveled.  The  QEA  and  QEB  input  edges serve as the stimulus to create the input clock which advances  the  Position  Counter  register  (POSCNT). The register  is  incremented  on  either  the  QEA  input edge, or the QEA and QEB input edges, depending on the operating mode. It is reset either by a rollover on match  to  the  Period  register,  MAXCNT,  or  on  the external index pulse input signal (INDX). An interrupt is generated  on  a  Reset  of  POSCNT  if  the  position counter interrupt is enabled.\nThe  velocity  postscaler  down  samples  the  velocity pulses  used  to  increment  the  velocity  counter  by  a specified ratio. It essentially divides down the number of  velocity  pulses  to  one  output  per  so  many  inputs, preserving the pulse width in the process.\nA simplified block-diagram of the QEI module is shown in Figure 17-8.",
    "17.2.1 QEI CONFIGURATION\nThe QEI module shares its  input  pins  with  the  Input Capture (IC) module. The inputs are mutually exclusive; only the IC module or the QEI module (but not both) can be enabled at one time. Also, because the IC and QEI are multiplexed to the same input pins, the programmable noise filters can be dedicated to one module only.\nThe operation of the QEI is controlled by the QEICON Configuration register (see Register 17-2).\nNote:\nIn  the  event  that  both  QEI  and  IC  are enabled, QEI will take precedence and IC will remain disabled.",
    "REGISTER 17-2: QEICON: QUADRATURE ENCODER INTERFACE CONTROL REGISTER\nVELM, R/W-0 = QERR (1). VELM, R-0 = UP/DOWN. VELM, R/W-0 = QEIM2 (2,3). VELM, R/W-0 = QEIM1 (2,3). VELM, R/W-0 = QEIM0 (2,3). VELM, R/W-0 = PDEC1. VELM, R/W-0 = PDEC0. bit 7, R/W-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 17-2: QEICON: QUADRATURE ENCODER INTERFACE CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nVELM: Velocity Mode bit\n1 = Velocity mode disabled\n0 = Velocity mode enabled",
    "bit 6 QERR: QEI Error bit\n(1)\n1 = Position counter overflow or underflow (4)\n0 = No overflow or underflow\nbit 5\nUP/DOWN: Direction of Rotation Status bit\n1 = Forward\n0 = Reverse\nbit 4-2 QEIM<2:0>: QEI Mode bits (2,3)\n111 = Unused\n110 = QEI enabled in 4x Update mode; position counter is reset on period match (POSCNT = MAXCNT)\n101 = QEI enabled in 4x Update mode; INDX resets the position counter\n100 = Unused\n010 = QEI enabled in 2x Update mode; position counter is reset on period match (POSCNT = MAXCNT)\n001 = QEI enabled in 2x Update mode; INDX resets the position counter\n000 = QEI off",
    "bit 1-0 PDEC<1:0>: Velocity Pulse Reduction Ratio bits\n11 = 1:64\n10 = 1:16\n01 = 1:4\n00 = 1:1\nNote 1: QEI must be enabled and in Index mode.\n2: QEI mode select must be cleared (= 000 ) to enable CAP1, CAP2 or CAP3 inputs. If QEI and IC modules are both enabled, QEI will take precedence.\n3: Enabling one of the QEI operating modes remaps the IC Buffer registers, CAP1BUFH, CAP1BUFL, CAP2BUFH, CAP2BUFL, CAP3BUFH and CAP3BUFL, as the VELRH, VELRL, POSCNTH, POSCNTL, MAXCNTH and MAXCNTL registers (respectively) for the QEI.\n4: The QERR bit must be cleared in software.",
    "17.2.2 QEI MODES\nPosition  measurement  resolution  depends  on  how often the Position Counter  register, POSCNT,  is incremented.  There  are  two  QEI  Update  modes  to measure the rotor's position: QEI x2 and QEI x4.",
    "TABLE 17-4: QEI MODES\n000, Mode/ Reset = -. 000, Description = QEI disabled. (1). 001, Mode/ Reset = x2 update/ index pulse. 001, Description = Two clocks per QEA pulse. INDX resets POSCNT.. 010, Mode/ Reset = x2 update/ period match. 010, Description = Two clocks per QEA pulse. POSCNT is reset by the period match (MAXCNT).. 011, Mode/ Reset = -. 011, Description = Unused.. 100, Mode/ Reset = -. 100, Description = Unused.. 101, Mode/ Reset = x4 update/ index pulse. 101, Description = Four clocks per QEA and QEB pulse pair. INDX resets POSCNT.. 110, Mode/ Reset = x4 update/ period match. 110, Description = Four clocks per QEA and QEB pulse pair. POSCNT is reset by the period match (MAXCNT).. 111, Mode/ Reset = -. 111, Description = Unused.\nNote 1: QEI module is disabled. The position counter and the velocity measurement functions are fully disabled in this mode.",
    "17.2.2.1 QEI x2 Update Mode\nQEI x2 Update mode is selected by setting  the  QEI Mode Select bits (QEIM<2:0>) to ' 001 ' or ' 010 '. In this mode, the QEI logic detects every edge on the QEA input  only.  Every  rising  and  falling  edge  on  the  QEA signal clocks the position counter.\nThe position counter can be reset by either an input on the INDX pin (QEIM<2:0> = 001 ), or by a period match, even when the POSCNT register pair equals MAXCNT (QEIM<2:0> = 010 ).",
    "17.2.2.2 QEI x4 Update Mode\nQEI x4 Update mode provides for a finer resolution of the  rotor  position,  since  the  counter  increments  or decrements more frequently for each QEA/QEB input pulse pair than in QEI x2 mode. This mode is selected by setting the QEI mode select bits to ' 101 ' or ' 110 '. In QEI x4, the phase measurement is made on the rising and the falling edges of both QEA and QEB inputs. The position  counter  is  clocked  on  every  QEA  and  QEB edge.\nLike QEI x2 mode, the position counter can be reset by an input on the pin (QEIM<2:0> = 101 ), or by the period match event (QEIM<2:0> = 010 ).",
    "17.2.3 QEI OPERATION\nThe Position Counter register pair (POSCNTH: POSCNTL) acts as an integrator, whose value is proportional to the position of the sensor rotor that corresponds to the number of active edges detected. POSCNT can either increment or decrement, depending on a number of selectable factors which are decoded by the QEI logic block.  These  include  the  Count  mode  selected,  the phase  relationship  of  QEA  to  QEB  ('lead/lag'),  the direction  of  rotation  and  if  a  Reset  event  occurs.  The logic is detailed in the sections that follow.",
    "17.2.3.1 Edge and Phase Detect\nIn the first step, the active edges of QEA and QEB are detected, and the phase relationship between them is determined. The position counter is changed based on the selected QEI mode.\nIn QEI x2 Update mode, the position counter increments or decrements on every QEA edge based on the phase relationship of the QEA and QEB signals.\nIn QEI x4 Update mode, the position counter increments  or  decrements  on  every  QEA  and  QEB edge based on the phase relationship of the QEA and QEB  signals.  For  example,  if  QEA  leads  QEB,  the position  counter  is  incremented  by  ' 1 '.  If  QEB  lags QEA, the position counter is decremented by ' 1 '.",
    "17.2.3.2 Direction of Count\nThe QEI control logic generates a signal that sets the UP/DOWN bit (QEICON<5>); this, in turn, determines the  direction  of  the  count.  When  QEA  leads  QEB, UP/DOWN  is  set  (= 1 ) and  the  position  counter increments  on  every  active  edge.  When  QEA  lags QEB, UP/DOWN is cleared and the position counter decrements on every active edge.",
    "TABLE 17-5: DIRECTION OF ROTATION\nQEA Rising, Previous Signal Detected.Rising.QEA = . QEA Rising, Previous Signal Detected.Rising.QEB = . QEA Rising, Previous Signal Detected.Falling.QEA = . QEA Rising, Previous Signal Detected.Falling.QEB = x. QEA Rising, Pos. (1).Cntrl.. = INC. , Previous Signal Detected.Rising.QEA = . , Previous Signal Detected.Rising.QEB = x. , Previous Signal Detected.Falling.QEA = . , Previous Signal Detected.Falling.QEB = . , Pos. (1).Cntrl.. = DEC. QEA Falling, Previous Signal Detected.Rising.QEA = . QEA Falling, Previous Signal Detected.Rising.QEB = . QEA Falling, Previous Signal Detected.Falling.QEA = . QEA Falling, Previous Signal Detected.Falling.QEB = x. QEA Falling, Pos. (1).Cntrl.. = DEC. , Previous Signal Detected.Rising.QEA = . , Previous Signal Detected.Rising.QEB = x. , Previous Signal Detected.Falling.QEA = . ,",
    "TABLE 17-5: DIRECTION OF ROTATION\nPrevious Signal Detected.Falling.QEB = . , Pos. (1).Cntrl.. = INC. QEB Rising, Previous Signal Detected.Rising.QEA = x. QEB Rising, Previous Signal Detected.Rising.QEB = . QEB Rising, Previous Signal Detected.Falling.QEA = . QEB Rising, Previous Signal Detected.Falling.QEB = . QEB Rising, Pos. (1).Cntrl.. = INC. , Previous Signal Detected.Rising.QEA = . , Previous Signal Detected.Rising.QEB = . , Previous Signal Detected.Falling.QEA = x. , Previous Signal Detected.Falling.QEB = . , Pos. (1).Cntrl.. = DEC. QEB Falling, Previous Signal Detected.Rising.QEA = . QEB Falling, Previous Signal Detected.Rising.QEB = . QEB Falling, Previous Signal Detected.Falling.QEA = x. QEB Falling, Previous Signal Detected.Falling.QEB = . QEB Falling, Pos. (1).Cntrl.. = INC. , Previous Signal Detected.Rising.QEA",
    "TABLE 17-5: DIRECTION OF ROTATION\n= x. , Previous Signal Detected.Rising.QEB = . , Previous Signal Detected.Falling.QEA = . , Previous Signal Detected.Falling.QEB = . , Pos. (1).Cntrl.. = DEC\nNote 1: When UP/DOWN =  , the position counter 1 is incremented. When UP/DOWN = 0 , the position counter is decremented.",
    "17.2.4 QEI INTERRUPTS\nThe position counter will continue to increment or decrement until  one  of  the  following  events  takes  place. The type of event and the direction of rotation when it happens  determines  if  a  register  Reset  or  update occurs.\n- 1. An index pulse is detected on the INDX input (QEIM<2:0> = 001 ).\nIf the encoder is traveling in the forward direction, POSCNT is reset (00h) on the next clock edge  after  the  index  marker,  INDX,  has  been detected.  The  position  counter  resets  on  the QEA or QEB edge once the INDX rising edge has been detected.\nIf the encoder is traveling in the reverse direction, the value in the MAXCNT register is loaded into  POSCNT  on  the  next  quadrature  pulse edge  (QEA  or  QEB)  after  the  falling  edge  on INDX has been detected.\n- 2. A  POSTCNT/MAXCNT  period  match  occurs (QEIM<2:0> = 010 ).",
    "17.2.4 QEI INTERRUPTS\nIf the encoder is traveling in the forward direction, POSCNT is reset (00h) on the next clock edge when POSCNT = MAXCNT. An interrupt event is triggered on the next TCY after the Reset (see Figure 17-10)\nIf the encoder  is traveling in the reverse direction  and  the  value  of  POSCNT  reaches 00h, POSCNT is loaded with the contents of the MAXCNT register on the next clock  edge.  An interrupt event is triggered on the next TCY after the load operation (see Figure 17-10).\nThe value of the position counter is not affected during QEI  mode  changes,  nor  when  the  QEI  is  disabled altogether.\nThe position counter interrupt occurs and the interrupt flag (IC2QEIF) is set, based on the following events:\n\u00b7 A POSCNT/MAXCNT period match event (QEIM<2:0> = 010 or 110 )\n\u00b7 A POSCNT rollover (FFFFh to 0000h) in Period mode only (QEIM<2:0> = 010 or 110 )\n\u00b7 An index pulse detected on INDX",
    "17.2.4 QEI INTERRUPTS\nThe interrupt timing diagrams for IC2QEIF are shown in Figure 17-10 and Figure 17-11.\nWhen the direction has changed, the direction change interrupt  flag  (IC3DRIF)  is  set  on  the  following  TCY clock (see Figure 17-10).\nIf  the  position  counter  rolls  over  in  Index  mode,  the QERR bit will be set.",
    "17.2.5 QEI SAMPLE TIMING\nThe quadrature input signals, QEA and QEB, may vary in quadrature  frequency.  The  minimum  quadrature input period, TQEI, is 16 TCY.\nThe position count rate, FPOS, is directly proportional to the rotor's RPM, line count D and QEI Update mode (x2 versus x4); that is,",
    "EQUATION 17-1:\nFPOS = 4D \u00b7 RPM 60\nNote:\nThe  number  of  incremental  lines  in  the position encoder is typically set at D = 1024 and the QEI Update mode = x4.\nThe  maximum  position  count  rate  (i.e.,  x4  QEI Update mode, D = 1024) with FCY = 10 MIPS is equal to 2.5 MHz, which corresponds to FQEI of 625 kHz.\nFigure 17-9  shows  QEA  and  QEB  quadrature  input timing when sampled by the noise filter.",
    "FIGURE 17-10: QEI MODULE RESET TIMING ON PERIOD MATCH\nNote 1: The POSCNT register is shown in QEI x4 Update mode (POSCNT increments on every rising and every falling edge of QEA and QEB input signals). Asynchronous external QEA and QEB inputs are synchronized to the TCY clock by the input sampling FF in the noise filter (see Figure 17-14).\n2: When POSCNT = MAXCNT, POSCNT is reset to ' 0 ' on the next QEA rising edge. POSCNT is set to MAXCNT when POSCNT = 0 (when decrementing), which occurs on the next QEA falling edge.\n3: IC2QEIF is generated on the Q4 rising edge.\n4: Position counter is loaded with ' 0 ' (which is a rollover event in this case) on POSCNT = MAXCNT.\n5: Position counter is loaded with MAXCNT value (1527h) on underflow.\n6: IC2QEIF must be cleared in software.",
    "FIGURE 17-11: QEI MODULE RESET TIMING WITH THE INDEX INPUT\nNote 1: POSCNT register is shown in QEI x4 Update mode (POSCNT increments on every rising and every falling edge of QEA and QEB input signals).\n2: When an INDX Reset pulse is detected, POSCNT is reset to ' 0 ' on the next QEA or QEB edge. POSCNT is set to MAXCNT when POSCNT = 0 (when decrementing), which occurs on the next QEA or QEB edge. a similar Reset sequence occurs for the reverse direction, except that the INDX signal is recognized on its falling edge. The Reset is generated on the next QEA or QEB edge.\n3: IC2QEIF is enabled for one TCY clock cycle.\n4: The position counter is loaded with 0000h (i.e., Reset) on the next QEA or QEB edge when the INDX is high.\n5: The position counter is loaded with a MAXCNT value (e.g., 1527h) on the next QEA or QEB edge following the INDX falling edge input signal detect).",
    "FIGURE 17-11: QEI MODULE RESET TIMING WITH THE INDEX INPUT\n6: IC2QEIF must be cleared in software.",
    "17.2.6.1 Velocity Event Timing\nThe velocity  pulse  generator,  in  conjunction  with  the IC1  and  the  synchronous  TMR5  (in  synchronous operation), provides a method for high accuracy speed measurements at both low and high mechanical motor speeds. The Velocity mode is enabled when the VELM bit is cleared (= 0 ) and QEI is set to one of its operating modes (see Table 17-6).\nTo optimize register space, the Input Capture Channel 1  (IC1)  is  used  to  capture  TMR5  counter values.  Input  Capture  Buffer  register,  CAP1BUF,  is redefined in Velocity Measurement mode, VELM = 0 , as the Velocity Register Buffer (VELRH, VELRL).\nTABLE 17-6: VELOCITY PULSES\n\n001, Velocity Event Mode = x2 Velocity Event mode. The velocity. 010, Velocity Event Mode = pulse is generated on every QEA edge.. 101, Velocity Event Mode = x4 Velocity Event mode. The velocity. 110, Velocity Event Mode = pulse is generated on every QEA and QEB active edge.",
    "17.2.6.1 Velocity Event Timing\nThe event pulses are reduced by a fixed ratio by the velocity pulse divider. The divider is useful for high-speed measurements where the velocity events happen frequently. By producing a single output pulse for a given number of input event pulses, the counter can track larger pulse counts (i.e., distance travelled) for a given time interval. Time is measured by utilizing the TMR5 time base.\nEach velocity pulse serves as a capture pulse. With the TMR5 in Synchronous Timer mode, the value of TMR5 is captured on every output pulse of the postscaler. The counter  is  subsequently  reset  to  ' 0 '.  TMR5  is  reset upon a capture event.\nFigure 17-13 shows the velocity measurement timing diagram.",
    "FIGURE 17-13: VELOCITY MEASUREMENT TIMING (1)\nNote 1: Timing shown is for QEIM<2:0> = 101 110 , or 111 (x4 Update mode enabled) and the velocity postscaler divide ratio is set to divide-by-4 (PDEC<1:0> = 01 ).\n2: The VELR register latches the TMR5 count on the 'velcap' capture pulse. Timer5 must be set to the Synchronous Timer or Counter mode. In this example, it is set to the Synchronous Timer mode, where the TMR5 prescaler divide ratio = 1 (i.e., Timer5 Clock = TCY).",
    "FIGURE 17-13: VELOCITY MEASUREMENT TIMING (1)\n3: The TMR5 counter is reset on the next Q1 clock cycle following the 'velcap' pulse. The TMR5 value is unaffected when  the  Velocity  Measurement  mode  is  first  enabled  (VELM  = 0 ).  The  velocity  postscaler  values  must  be reconfigured  to  their  previous  settings  when  re-entering  Velocity  Measurement  mode.  While  making  speed measurements of very slow rotational speeds (e.g., servo-controller applications), the Velocity Measurement mode may not provide sufficient precision. The Pulse-Width Measurement mode may have to be used to provide the additional precision. In this case, the input pulse is measured on the CAP1 input pin.\n4: IC1IF interrupt is enabled by setting IC1IE as follows: BSF PIE2, IC1IE . Assume IC1E bit is placed in the PIE2 (Peripheral Interrupt Enable 2) register in the target device. The actual IC1IF bit is written on the Q2 rising edge.\n5: The post decimation value is changed from PDEC = 01 (decimate by 4) to PDEC = 00 (decimate by 1).",
    "17.2.6.3 CAP1REN in Velocity Mode\nThe  velocity  event  pulse  (velcap,  see  Figure 17-12) serves as the TMR5 capture trigger to IC1 while in the Velocity  mode.  The  number  of  velocity  events  are reduced by the velocity postscaler before they are used as the input capture clock. The velocity event reduction ratio  can  be  set  with  the  PDEC<1:0>  control  bits (QEICON<1:0>) to 1:4, 1:16, 1:64 or no reduction (1:1).\nThe  velocity postscaler settings are automatically reloaded  from  their  previous  values  as  the  Velocity mode is re-enabled.\nThe  TMR5  value  can  be  reset  (TMR5  register pair = 0000h) on a velocity event capture by setting the CAP1REN bit (CAP1CON<6>). When CAP1REN is cleared, the TMR5 time base will not be reset on any velocity event capture pulse. The VELR register pair,  however,  will  continue  to  be  updated with the current TMR5 value.",
    "17.3 Noise Filters\nThe  Motion  Feedback  Module  includes  three  noise rejection filters on RA2/AN2/VREF-/CAP1/INDX, RA3/AN3/VREF+/CAP2/QEA and RA4/AN4/CAP3/QEB. The filter block also includes a fourth filter for the T5CKI pin.  They  are  intended  to  help  reduce  spurious  noise spikes  which  may  cause  the  input  signals  to  become corrupted at the inputs. The filter ensures that the input signals are not permitted to change until a stable value has  been  registered  for  three  consecutive  sampling clock cycles.\nprogrammed  by  the  FLTCK<2:0>  Configuration  bits. TCY is used as the clock reference to the clock divider block.\nThe noise filters can either be added or removed from the  input  capture,  or  QEI  signal  path,  by  setting  or clearing the appropriate FLTxEN bit, respectively. Each capture channel provides for individual enable control of the filter output. The FLT4EN bit enables or disables the  noise  filter  available  on  the  T5CKI  input  in  the Timer5 module.",
    "17.3 Noise Filters\nThe filters are controlled using the Digital Filter Control (DFLTCON)  register  (see  Register 17-3).  The  filters can be individually enabled or disabled by setting or clearing the corresponding FLTxEN bit in the DFLTCON  register.  The  sampling  frequency,  which must  be  the  same  for  all  three  noise  filters,  can  be\nThe  filter  network  for  all  channels  is  disabled  on Power-on  and  Brown-out  Resets,  as  the  DFLTCON register is cleared on Resets. The operation of the filter is shown in the timing diagram in Figure 17-14.",
    "REGISTER 17-3: DFLTCON: DIGITAL FILTER CONTROL REGISTER\nU-0, 1 = R/W-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = FLT4EN. -, 2 = FLT3EN (1). -, 3 = FLT2EN (1). -, 4 = FLT1EN (1). -, 5 = FLTCK2. -, 6 = FLTCK1. -, 7 = FLTCK0",
    "REGISTER 17-3: DFLTCON: DIGITAL FILTER CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6 FLT4EN: Noise Filter Output Enable bit (T5CKI input)\n1 = Enabled\n0 = Disabled\nbit 5\nFLT3EN: Noise Filter Output Enable bit (CAP3/QEB input) (1)\n1 = Enabled\n0 = Disabled\nbit 4\nFLT2EN: Noise Filter Output Enable bit (CAP2/QEA input) (1)\n1 = Enabled\n0 = Disabled\nbit 3\nFLT1EN: Noise Filter Output Enable bit (CAP1/INDX Input) (1)\n1 = Enabled\n0 = Disabled\nbit 2-0\nFLTCK<2:0>: Noise Filter Clock Divider Ratio bits\n111 = Unused\n110 = 1:128\n101 = 1:64\n100 = 1:32\n011 = 1:16\n010 = 1:4\n001 = 1:2\n000 = 1:1\nNote 1: The noise filter output enables are functional in both QEI and IC Operating modes.\nNote:\nThe noise filter is intended for random high-frequency filtering and not continuous high-frequency filtering.",
    "17.5 Operation in Sleep Mode\nThe IC and QEI submodules can each generate three distinct interrupt signals; however, they share the use of the same three interrupt flags in register, PIR3. The meaning of a particular interrupt flag at any given time depends  on  which  module  is  active  at  the  time  the interrupt is set. The meaning of the flags in context are summarized in Table 17-7.\nWhen the IC submodule is active, the three flags (IC1IF, IC2QEIF and IC3DRIF) function as interrupt-on-capture event flags for their respective input capture channels. The channel must be configured for one of the events that will generate an interrupt (see Section 17.1.7 'IC Interrupts' for more information).\nWhen  the  QEI  is  enabled,  the  IC1IF  interrupt  flag indicates an interrupt caused by a velocity measurement event, usually  an  update  of  the  VELR register. The IC2QEIF interrupt indicates that a position measurement event has occurred. IC3DRIF indicates that a direction change has been detected.",
    "TABLE 17-7: MEANING OF IC AND QEI INTERRUPT FLAGS\nIC1IF, Meaning.IC Mode = IC1 Capture Event. IC1IF, Meaning.QEI Mode = Velocity Register Update. IC2QEIF, Meaning.IC Mode = IC2 Capture Event. IC2QEIF, Meaning.QEI Mode = Position Measurement Update. IC3DRIF, Meaning.IC Mode = IC3 Capture Event. IC3DRIF, Meaning.QEI Mode = Direction Change",
    "17.5.1 3x INPUT CAPTURE IN SLEEP MODE\nSince the input capture can operate only when its time base is configured in a Synchronous mode, the input capture will not capture any events. This is because the device's internal clock has been stopped and any internal  timers  in  Synchronous modes will not increment. The  prescaler  will  continue  to  count  the  events  (not synchronized).\nWhen the  specified  capture  event  occurs,  the  CAPx interrupt will be set. The Capture Buffer register will be updated upon wake-up from sleep to the current TMR5 value. If the CAPx interrupt is enabled, the device will wake-up from Sleep. This effectively enables all input capture channels to be used as the external interrupts.",
    "17.5.2 QEI IN SLEEP MODE\nAll QEI functions are halted in Sleep mode.",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, ResetValues on Page: = 54. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = -. IPR3, Bit 4 = PTIP. IPR3, Bit 3 = IC3DRIP. IPR3, Bit 2 = IC2QEIP. IPR3, Bit 1 = IC1IP. IPR3, Bit 0 = TMR5IP. IPR3, ResetValues on Page: = 56. PIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = -. PIE3, Bit 4 = PTIE. PIE3, Bit 3 = IC3DRIE. PIE3, Bit 2",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\n= IC2QEIE. PIE3, Bit 1 = IC1IE. PIE3, Bit 0 = TMR5IE. PIE3, ResetValues on Page: = 56. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = -. PIR3, Bit 4 = PTIF. PIR3, Bit 3 = IC3DRIF. PIR3, Bit 2 = IC2QEIF. PIR3, Bit 1 = IC1IF. PIR3, Bit 0 = TMR5IF. PIR3, ResetValues on Page: = 56. TMR5H, Bit 7 = Timer5 Register High Byte. TMR5H, Bit 6 = Timer5 Register High Byte. TMR5H, Bit 5 = Timer5 Register High Byte. TMR5H, Bit 4 = Timer5 Register High Byte. TMR5H, Bit 3 = Timer5 Register High Byte. TMR5H, Bit 2 = Timer5 Register High Byte. TMR5H, Bit 1 = Timer5 Register High",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\nByte. TMR5H, Bit 0 = Timer5 Register High Byte. TMR5H, ResetValues on Page: = 57. TMR5L, Bit 7 = Timer5 Register Low Byte. TMR5L, Bit 6 = Timer5 Register Low Byte. TMR5L, Bit 5 = Timer5 Register Low Byte. TMR5L, Bit 4 = Timer5 Register Low Byte. TMR5L, Bit 3 = Timer5 Register Low Byte. TMR5L, Bit 2 = Timer5 Register Low Byte. TMR5L, Bit 1 = Timer5 Register Low Byte. TMR5L, Bit 0 = Timer5 Register Low Byte. TMR5L, ResetValues on Page: = 57. PR5H, Bit 7 = Timer5 Period Register High Byte. PR5H, Bit 6 = Timer5 Period Register High Byte. PR5H, Bit 5 = Timer5 Period Register High Byte. PR5H, Bit 4 = Timer5 Period Register High Byte. PR5H, Bit 3 = Timer5 Period Register High Byte. PR5H, Bit 2 =",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\nTimer5 Period Register High Byte. PR5H, Bit 1 = Timer5 Period Register High Byte. PR5H, Bit 0 = Timer5 Period Register High Byte. PR5H, ResetValues on Page: = 57. PR5L, Bit 7 = Timer5 Period Register Low Byte. PR5L, Bit 6 = Timer5 Period Register Low Byte. PR5L, Bit 5 = Timer5 Period Register Low Byte. PR5L, Bit 4 = Timer5 Period Register Low Byte. PR5L, Bit 3 = Timer5 Period Register Low Byte. PR5L, Bit 2 = Timer5 Period Register Low Byte. PR5L, Bit 1 = Timer5 Period Register Low Byte. PR5L, Bit 0 = Timer5 Period Register Low Byte. PR5L, ResetValues on Page: = 57. T5CON, Bit 7 = T5SEN. T5CON, Bit 6 = RESEN. T5CON, Bit 5 = T5MOD. T5CON, Bit 4 = T5PS1. T5CON, Bit 3 = T5PS0. T5CON, Bit 2 = T5SYNC.",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\nT5CON, Bit 1 = TMR5CS. T5CON, Bit 0 = TMR5ON. T5CON, ResetValues on Page: = 57. CAP1BUFH/ VELRH, Bit 7 = Capture 1 Register High Byte/Velocity Register High Byte (1). CAP1BUFH/ VELRH, Bit 6 = Capture 1 Register High Byte/Velocity Register High Byte (1). CAP1BUFH/ VELRH, Bit 5 = Capture 1 Register High Byte/Velocity Register High Byte (1). CAP1BUFH/ VELRH, Bit 4 = Capture 1 Register High Byte/Velocity Register High Byte (1). CAP1BUFH/ VELRH, Bit 3 = Capture 1 Register High Byte/Velocity Register High Byte (1). CAP1BUFH/ VELRH, Bit 2 = Capture 1 Register High Byte/Velocity Register High Byte (1). CAP1BUFH/ VELRH, Bit 1 = Capture 1 Register High Byte/Velocity Register High Byte (1). CAP1BUFH/ VELRH, Bit 0 = Capture 1 Register",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\nHigh Byte/Velocity Register High Byte (1). CAP1BUFH/ VELRH, ResetValues on Page: = 58. CAP1BUFL/ VELRL, Bit 7 = Capture 1 Register Low Byte/Velocity Register Low Byte (1). CAP1BUFL/ VELRL, Bit 6 = Capture 1 Register Low Byte/Velocity Register Low Byte (1). CAP1BUFL/ VELRL, Bit 5 = Capture 1 Register Low Byte/Velocity Register Low Byte (1). CAP1BUFL/ VELRL, Bit 4 = Capture 1 Register Low Byte/Velocity Register Low Byte (1). CAP1BUFL/ VELRL, Bit 3 = Capture 1 Register Low Byte/Velocity Register Low Byte (1). CAP1BUFL/ VELRL, Bit 2 = Capture 1 Register Low Byte/Velocity Register Low Byte (1). CAP1BUFL/ VELRL, Bit 1 = Capture 1 Register Low Byte/Velocity Register Low Byte (1). CAP1BUFL/ VELRL, Bit 0 = Capture 1 Register Low Byte/Velocity Register Low Byte (1). CAP1BUFL/",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\nVELRL, ResetValues on Page: = 58. CAP2BUFH/ POSCNTH, Bit 7 = Capture 2 Register High Byte/QEI Position Counter Register High Byte (1). CAP2BUFH/ POSCNTH, Bit 6 = Capture 2 Register High Byte/QEI Position Counter Register High Byte (1). CAP2BUFH/ POSCNTH, Bit 5 = Capture 2 Register High Byte/QEI Position Counter Register High Byte (1). CAP2BUFH/ POSCNTH, Bit 4 = Capture 2 Register High Byte/QEI Position Counter Register High Byte (1). CAP2BUFH/ POSCNTH, Bit 3 = Capture 2 Register High Byte/QEI Position Counter Register High Byte (1). CAP2BUFH/ POSCNTH, Bit 2 = Capture 2 Register High Byte/QEI Position Counter Register High Byte (1). CAP2BUFH/ POSCNTH, Bit 1 = Capture 2 Register High Byte/QEI Position Counter Register High Byte (1). CAP2BUFH/ POSCNTH, Bit 0 =",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\nCapture 2 Register High Byte/QEI Position Counter Register High Byte (1). CAP2BUFH/ POSCNTH, ResetValues on Page: = 58. CAP2BUFL/ POSCNTL, Bit 7 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte (1). CAP2BUFL/ POSCNTL, Bit 6 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte (1). CAP2BUFL/ POSCNTL, Bit 5 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte (1). CAP2BUFL/ POSCNTL, Bit 4 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte (1). CAP2BUFL/ POSCNTL, Bit 3 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte (1). CAP2BUFL/ POSCNTL, Bit 2 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte (1). CAP2BUFL/ POSCNTL, Bit 1 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\n(1). CAP2BUFL/ POSCNTL, Bit 0 = Capture 2 Register Low Byte/QEI Position Counter Register Low Byte (1). CAP2BUFL/ POSCNTL, ResetValues on Page: = 58. CAP3BUFH/ MAXCNTH, Bit 7 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte (1). CAP3BUFH/ MAXCNTH, Bit 6 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte (1). CAP3BUFH/ MAXCNTH, Bit 5 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte (1). CAP3BUFH/ MAXCNTH, Bit 4 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte (1). CAP3BUFH/ MAXCNTH, Bit 3 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte (1). CAP3BUFH/ MAXCNTH, Bit 2 = Capture 3 Register High Byte/QEI Max. Count Limit",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\nRegister High Byte (1). CAP3BUFH/ MAXCNTH, Bit 1 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte (1). CAP3BUFH/ MAXCNTH, Bit 0 = Capture 3 Register High Byte/QEI Max. Count Limit Register High Byte (1). CAP3BUFH/ MAXCNTH, ResetValues on Page: = 58. CAP3BUFL/ MAXCNTL, Bit 7 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte (1). CAP3BUFL/ MAXCNTL, Bit 6 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte (1). CAP3BUFL/ MAXCNTL, Bit 5 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte (1). CAP3BUFL/ MAXCNTL, Bit 4 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte (1). CAP3BUFL/ MAXCNTL, Bit 3 = Capture 3 Register Low Byte/QEI Max.",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\nCount Limit Register Low Byte (1). CAP3BUFL/ MAXCNTL, Bit 2 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte (1). CAP3BUFL/ MAXCNTL, Bit 1 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte (1). CAP3BUFL/ MAXCNTL, Bit 0 = Capture 3 Register Low Byte/QEI Max. Count Limit Register Low Byte (1). CAP3BUFL/ MAXCNTL, ResetValues on Page: = 58. CAP1CON, Bit 7 = -. CAP1CON, Bit 6 = CAP1REN. CAP1CON, Bit 5 = -. CAP1CON, Bit 4 = -. CAP1CON, Bit 3 = CAP1M3. CAP1CON, Bit 2 = CAP1M2. CAP1CON, Bit 1 = CAP1M1. CAP1CON, Bit 0 = CAP1M0. CAP1CON, ResetValues on Page: = 59. CAP2CON, Bit 7 = -. CAP2CON, Bit 6 = CAP2REN.",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\nCAP2CON, Bit 5 = -. CAP2CON, Bit 4 = -. CAP2CON, Bit 3 = CAP2M3. CAP2CON, Bit 2 = CAP2M2. CAP2CON, Bit 1 = CAP2M1. CAP2CON, Bit 0 = CAP2M0. CAP2CON, ResetValues on Page: = 59. CAP3CON, Bit 7 = -. CAP3CON, Bit 6 = CAP3REN. CAP3CON, Bit 5 = -. CAP3CON, Bit 4 = -. CAP3CON, Bit 3 = CAP3M3. CAP3CON, Bit 2 = CAP3M2. CAP3CON, Bit 1 = CAP3M1. CAP3CON, Bit 0 = CAP3M0. CAP3CON, ResetValues on Page: = 59. DFLTCON, Bit 7 = -. DFLTCON, Bit 6 = FLT4EN. DFLTCON, Bit 5 = FLT3EN. DFLTCON, Bit 4 = FLT2EN. DFLTCON, Bit 3 = FLT1EN.",
    "TABLE 17-8: REGISTERS ASSOCIATED WITH THE MOTION FEEDBACK MODULE\nDFLTCON, Bit 2 = FLTCK2. DFLTCON, Bit 1 = FLTCK1. DFLTCON, Bit 0 = FLTCK0. DFLTCON, ResetValues on Page: = 59. QEICON, Bit 7 = VELM. QEICON, Bit 6 = QERR. QEICON, Bit 5 = UP/DOWN. QEICON, Bit 4 = QEIM2. QEICON, Bit 3 = QEIM1. QEICON, Bit 2 = QEIM0. QEICON, Bit 1 = PDEC1. QEICON, Bit 0 = PDEC0. QEICON, ResetValues on Page: = 56\nLegend:\n- = unimplemented. Shaded cells are not used by the Motion Feedback Module.\nNote 1: Register name and function determined by which submodule is selected (IC/QEI, respectively). See Section 17.1.10 'Other Operating Modes' for more information.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "18.0 POWER CONTROL PWM MODULE\nThe PWM module has the following features:\nThe Power Control PWM module simplifies the task of generating multiple, synchronized Pulse-Width Modulated  (PWM)  outputs  for  use  in  the  control  of motor controllers and power conversion applications. In  particular,  the  following  power  and  motion  control applications are supported by the PWM module:",
    "18.0 POWER CONTROL PWM MODULE\n\u00b7 Three-Phase and Single-Phase AC Induction Motors\n\u00b7 Switched Reluctance Motors\n\u00b7 Brushless DC (BLDC) Motors\n\u00b7 Uninterruptible Power Supplies (UPS)\n\u00b7 Multiple DC Brush Motors\n\u00b7 Up to eight PWM I/O pins with four duty cycle generators. Pins can be paired to get a complete half-bridge control.\n\u00b7 Up to 14-bit resolution, depending upon the PWM period.\n\u00b7 'On-the-fly' PWM frequency changes.\n\u00b7 Edge and Center-Aligned Output modes.\n\u00b7 Single-Pulse Generation mode.\n\u00b7 Programmable dead-time control between paired PWMs.\n\u00b7 Interrupt support for asymmetrical updates in Center-Aligned mode.\n\u00b7 Output override for Electrically Commutated Motor (ECM) operation; for example, BLDC.\n\u00b7 Special Event Trigger comparator for scheduling other peripheral events.\n\u00b7 PWM outputs disable feature sets PWM outputs to their inactive state when in Debug mode.",
    "18.0 POWER CONTROL PWM MODULE\nThe Power Control PWM module supports three PWM generators and six output channels on PIC18F2331/2431  devices,  and  four  generators  and eight channels on PIC18F4331/4431 devices. A simplified block diagram of the module is shown in Figure 18-1.  Figure 18-2  and  Figure 18-3  show  how the  module  hardware  is  configured  for  each  PWM output  pair  for  the  Complementary  and  Independent Output modes.\nEach  functional  unit  of  the  PWM  module  will  be discussed in subsequent sections.",
    "FIGURE 18-1: POWER CONTROL PWM MODULE BLOCK DIAGRAM\nNote 1: Only PWM Generator 3 is shown in detail. The other generators are identical; their details are omitted for clarity.\n2: PWM Generator 3 and its logic, PWM Channels 6 and 7, and FLTB and its associated logic are not implemented on PIC18F2331/2431 devices.",
    "FIGURE 18-3: PWM MODULE BLOCK DIAGRAM, ONE OUTPUT PAIR, INDEPENDENT MODE\nThis  module  contains  four  duty  cycle  generators, numbered 0 through 3. The module has eight PWM output  pins,  numbered  0  through  7.  The  eight  PWM outputs are grouped into output pairs of even and odd numbered outputs. In Complementary modes, the even PWM  pins  must  always  be  the  complement  of  the corresponding odd PWM pin. For example, PWM0 will be  the  complement  of  PWM1,  PWM2  will  be  the complement  of  PWM3  and  so  on.  The  dead-time generator  inserts  an  OFF  period  called  'dead  time' between the going OFF of one pin to the going ON of the  complementary pin  of  the  paired  pins.  This  is  to prevent damage to the power switching devices that will be connected to the PWM output pins.\nThe time base for the PWM module is provided by its own  12-bit  timer,  which  also  incorporates  selectable prescaler and postscaler options.",
    "18.2 Module Functionality\nThe operation of the PWM module is controlled by a total of 22  registers.  Eight  of  these  are  used  to configure the features of the module:\n\u00b7 PWM Timer Control Register 0 (PTCON0)\n\u00b7 PWM Timer Control Register 1 (PTCON1)\n\u00b7 PWM Control Register 0 (PWMCON0)\n\u00b7 PWM Control Register 1 (PWMCON1)\n\u00b7 Dead-Time Control Register (DTCON)\n\u00b7 Output Override Control Register (OVDCOND)\n\u00b7 Output State Register (OVDCONS)\n\u00b7 Fault Configuration Register (FLTCONFIG)\nThere  are  also  14  registers  that  are  configured  as seven register pairs of 16 bits. These are used for the configuration values of specific features. They are:",
    "18.2 Module Functionality\n\u00b7 PWM Time Base Registers (PTMRH and PTMRL)\n\u00b7 PWM Time Base Period Registers (PTPERH and PTPERL)\n\u00b7 PWM Special Event Trigger Compare Registers (SEVTCMPH and SEVTCMPL)\n\u00b7 PWM Duty Cycle #0 Registers (PDC0H and PDC0L)\n\u00b7 PWM Duty Cycle #1 Registers (PDC1H and PDC1L)\n\u00b7 PWM Duty Cycle #2 Registers (PDC2H and PDC2L)\n\u00b7 PWM Duty Cycle #3 Registers (PDC3H and PDC3L)\nAll of these register pairs are double-buffered.\nThe PWM module supports several modes of operation that are beneficial for specific power and motor control applications. Each mode of operation is described in subsequent sections.\nThe PWM module is composed of several functional blocks. The operation of each is explained separately in relation to the several modes of operation:",
    "18.2 Module Functionality\n\u00b7 PWM Time Base\n\u00b7 PWM Time Base Interrupts\n\u00b7 PWM Period\n\u00b7 PWM Duty Cycle\n\u00b7 Dead-Time Generators\n\u00b7 PWM Output Overrides\n\u00b7 PWM Fault Inputs\n\u00b7 PWM Special Event Trigger",
    "18.3 PWM Time Base\nThe PWM time base is provided by a 12-bit timer with prescaler and postscaler functions. A simplified block diagram of the PWM time base is shown in Figure 18-4. The PWM  time  base  is configured through the PTCON0  and  PTCON1  registers.  The  time  base  is enabled or disabled by respectively setting or clearing the PTEN bit in the PTCON1 register.",
    "Note:\nThe PTMR register pair (PTMRL:PTMRH) is not  cleared  when  the  PTEN  bit  is cleared in software.",
    "FIGURE 18-4: PWM TIME BASE BLOCK DIAGRAM\nThe PWM time base can be configured for four different modes of operation:\n\u00b7 Free-Running mode\n\u00b7 Single-Shot mode\n\u00b7 Continuous Up/Down Count mode\n\u00b7 Continuous Up/Down Count mode with interrupts for double updates\nThese four modes are selected by the PTMOD<1:0> bits in the PTCON0 register. The Free-Running mode produces edge-aligned PWM generation. The Continuous Up/Down Count modes produce center-aligned PWM  generation. The Single-Shot mode allows the PWM module to support pulse control of  certain  Electronically  Commutated  Motors  (ECMs) and produces edge-aligned operation.",
    "REGISTER 18-1: PTCON0: PWM TIMER CONTROL REGISTER 0\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PTOPS3, 1 = PTOPS2. PTOPS3, 2 = PTOPS1. PTOPS3, 3 = PTOPS0. PTOPS3, 4 = PTCKPS1. PTOPS3, 5 = PTCKPS0. PTOPS3, 6 = PTMOD1. PTOPS3, 7 = PTMOD0. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 18-1: PTCON0: PWM TIMER CONTROL REGISTER 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-4 PTOPS<3:0>: PWM Time Base Output Postscale Select bits\n0000 = 1:1 Postscale\n0001 = 1:2 Postscale\n.\n.\n.\n1111 = 1:16 Postscale",
    "bit 3-2 PTCKPS<1:0>: PWM Time Base Input Clock Prescale Select bits\n00 = PWM time base input clock is FOSC/4 (1:1 prescale)\n01 = PWM time base input clock is FOSC/16 (1:4 prescale)\n10 = PWM time base input clock is FOSC/64 (1:16 prescale)\n11 = PWM time base input clock is FOSC/256 (1:64 prescale)",
    "bit 1-0 PTMOD<1:0>: PWM Time Base Mode Select bits\n11 = PWM time base operates in a Continuous Up/Down Count mode with interrupts for double PWM updates\n10 = PWM time base operates in a Continuous Up/Down Count mode\n01 = PWM time base configured for Single-Shot mode\n00 = PWM time base operates in a Free-Running mode",
    "REGISTER 18-2: PTCON1: PWM TIMER CONTROL REGISTER 1\nR/W-0, 1 = R-0. R/W-0, 2 = U-0. R/W-0, 3 = U-0. R/W-0, 4 = U-0. R/W-0, 5 = U-0. R/W-0, 6 = U-0. R/W-0, 7 = U-0. PTEN, 1 = PTDIR. PTEN, 2 = -. PTEN, 3 = -. PTEN, 4 = -. PTEN, 5 = -. PTEN, 6 = -. PTEN, 7 = -. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 18-2: PTCON1: PWM TIMER CONTROL REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7\nPTEN: PWM Time Base Timer Enable bit\n1 = PWM time base is on\n0 = PWM time base is off",
    "bit 6\nPTDIR: PWM Time Base Count Direction Status bit\n1 = PWM time base counts down\n0 = PWM time base counts up\nbit 5-0\nUnimplemented:\nRead as ' 0 '",
    "REGISTER 18-3: PWMCON0: PWM CONTROL REGISTER 0\n-, R/W-1 (1) = PWMEN2. -, R/W-1 (1) = PWMEN1. -, R/W-1 (1) = PWMEN0. -, R/W-0 = PMOD3 (3). -, R/W-0 = PMOD2. -, R/W-0 = PMOD1. -, R/W-0 = PMOD0. bit 7 bit 0, R/W-1 (1) = bit 7 bit 0. bit 7 bit 0, R/W-1 (1) = bit 7 bit 0. bit 7 bit 0, R/W-1 (1) = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 18-3: PWMCON0: PWM CONTROL REGISTER 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 6-4 PWMEN<2:0>: PWM Module Enable bits (1)\n111 = All odd PWM I/O pins are enabled for PWM output (2)\n110 = PWM1, PWM3 pins are enabled for PWM output\n101 = All PWM I/O pins are enabled for PWM output (2)\n100 = PWM0, PWM1, PWM2, PWM3, PWM4 and PWM5 pins are enabled for PWM output\n011 = PWM0, PWM1, PWM2 and PWM3 I/O pins are enabled for PWM output\n010 = PWM0 and PWM1 pins are enabled for PWM output\n001 = PWM1 pin is enabled for PWM output\n000 = PWM module is disabled; all PWM I/O pins are general purpose I/O",
    "For PMOD0:\n1 = PWM I/O pin pair (PWM0, PWM1) is in the Independent mode\n0 = PWM I/O pin pair (PWM0, PWM1) is in the Complementary mode",
    "For PMOD1:\n1 = PWM I/O pin pair (PWM2, PWM3) is in the Independent mode\n0 = PWM I/O pin pair (PWM2, PWM3) is in the Complementary mode",
    "For PMOD2:\n1 = PWM I/O pin pair (PWM4, PWM5) is in the Independent mode\n0 = PWM I/O pin pair (PWM4, PWM5) is in the Complementary mode",
    "For PMOD3: (3)\n1 = PWM I/O pin pair (PWM6, PWM7) is in the Independent mode\n0 = PWM I/O pin pair (PWM6, PWM7) is in the Complementary mode",
    "Note 1: Reset condition of the PWMEN bits depends on the PWMPIN Configuration bit.\n2: When PWMEN<2:0> = 101 , PWM<5:0> outputs are enabled for PIC18F2331/2431 devices; PWM<7:0> outputs are enabled for PIC18F4331/4431 devices.\nWhen PWMEN<2:0> = 111 , PWM Outputs 1, 3 and 5 are enabled in PIC18F2331/2431 devices; PWM Outputs 1, 3, 5 and 7 are enabled in PIC18F4331/4431 devices.\n3: Unimplemented in PIC18F2331/2431 devices; maintain these bits clear.",
    "REGISTER 18-4: PWMCON1: PWM CONTROL REGISTER 1\nSEVOPS3, R/W-0 = SEVOPS2. SEVOPS3, R/W-0 = SEVOPS1. SEVOPS3, R/W-0 = SEVOPS0. SEVOPS3, R/W-0 = SEVTDIR. SEVOPS3, U-0 = -. SEVOPS3, R/W-0 = UDIS. SEVOPS3, R/W-0 = OSYNC. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 18-4: PWMCON1: PWM CONTROL REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-4 SEVOPS<3:0>: PWM Special Event Trigger Output Postscale Select bits\n0000 = 1:1 Postscale\n0001 = 1:2 Postscale\n.\n.\n.\n1111 = 1:16 Postscale",
    "bit 3 SEVTDIR: Special Event Trigger Time Base Direction bit\n1 = A Special Event Trigger will occur when the PWM time base is counting downwards\n0 = A Special Event Trigger will occur when the PWM time base is counting upwards",
    "bit 2 Unimplemented: Read as ' 0 '\nbit 1\nUDIS: PWM Update Disable bit\n1 = Updates from Duty Cycle and Period Buffer registers are disabled\n0 = Updates from Duty Cycle and Period Buffer registers are enabled",
    "bit 0\nOSYNC: PWM Output Override Synchronization bit\n1 = Output overrides via the OVDCON register are synchronized to the PWM time base\n0 = Output overrides via the OVDCON register are asynchronous",
    "18.3.1 FREE-RUNNING MODE\nIn the Free-Running mode, the PWM Time Base registers (PTMRL and PTMRH) will begin counting upwards until the value in the PWM Time Base Period register, PTPER  (PTPERL  and  PTPERH),  is  matched.  The PTMR  registers  will  be  reset  on  the  following  input clock  edge  and  the  time  base  will  continue  counting upwards as long as the PTEN bit remains set.\nNote:\nSince  the  PWM  compare  outputs  are driven to the active state when the PWM time  base  is  counting  downwards  and matches the duty cycle value, the PWM outputs  are  held  inactive  during  the  first half of  the first  period  of  the  Continuous Up/Down Count mode until PTMR begins to count down from the PTPER value.",
    "18.3.2 SINGLE-SHOT MODE\nIn the Single-Shot mode, the PWM time base will begin counting upwards when the PTEN bit is set. When the value in the PTMR register matches the PTPER register,  the  PTMR  register  will  be  reset  on  the  following input clock edge and the PTEN bit will be cleared by the hardware to halt the time base.",
    "18.3.3 CONTINUOUS UP/DOWN COUNT MODES\nIn Continuous Up/Down Count modes, the PWM time base  counts  upwards  until  the  value  in  the  PTPER register  matches  with  the  PTMR  register.  On  the following input clock edge, the timer counts downwards. The PTDIR bit in the PTCON1 register is read-only  and  indicates  the  counting  direction.  The PTDIR bit is set when the timer counts downwards.",
    "18.3.4 PWM TIME BASE PRESCALER\nThe  input  clock  to  PTMR  (FOSC/4)  has  prescaler options of 1:1, 1:4, 1:16 or 1:64. These are selected by control  bits,  PTCKPS<1:0>,  in  the  PTCON0  register. The  prescaler  counter  is  cleared  when  any  of  the following occurs:\n\u00b7 Write to the PTMR register\n\u00b7 Write to the PTCON (PTCON0 or PTCON1) register\n\u00b7 Any device Reset\nNote:\nThe  PTMR  register  is  not  cleared  when PTCONx is written.",
    "PIC18F2331/2431/4331/4431\nTable 18-1 shows the minimum PWM frequencies that can  be  generated  with  the  PWM  time  base  and  the prescaler. An operating frequency of 40 MHz (FCYC = 10 MHz) and PTPER = 0xFFF is assumed in the table. The PWM module must be capable of generating  PWM  signals  at  the  line  frequency  (50 Hz  or 60 Hz) for certain power control applications.\nTABLE 18-1: MINIMUM PWM FREQUENCY",
    "Minimum PWM Frequencies vs. Prescaler Value for FCYC = 10 MIPS (PTPER = 0FFFh)\n1:1, PWM Frequency Edge-Aligned = 2441 Hz. 1:1, PWM Frequency Center-Aligned = 1221 Hz. 1:4, PWM Frequency Edge-Aligned = 610 Hz. 1:4, PWM Frequency Center-Aligned = 305 Hz. 1:16, PWM Frequency Edge-Aligned = 153 Hz. 1:16, PWM Frequency Center-Aligned = 76 Hz. 1:64, PWM Frequency Edge-Aligned = 38 Hz. 1:64, PWM Frequency Center-Aligned = 19 Hz",
    "18.3.5 PWM TIME BASE POSTSCALER\nThe match output of PTMR  can optionally be postscaled  through  a  4-bit  postscaler  (which  gives  a 1:1 to 1:16 scaling inclusive) to generate an interrupt. The  postscaler  counter  is  cleared  when  any  of  the following occurs:\n\u00b7 Write to the PTMR register\n\u00b7 Write to the PTCON register\n\u00b7 Any device Reset\nThe  PTMR  register  is  not  cleared  when  PTCON  is written.",
    "18.4 PWM Time Base Interrupts\nThe PWM timer can generate interrupts based on the modes of operation selected by the PTMOD<1:0> bits and the postscaler bits (PTOPS<3:0>).",
    "18.4.1 INTERRUPTS IN FREE-RUNNING MODE\nWhen the PWM time base is in the Free-Running mode (PTMOD<1:0>  = 00 ),  an  interrupt  event  is  generated each time a match with the PTPER register occurs. The PTMR register is reset to zero in the following clock edge.\nUsing a postscaler selection other than 1:1 will reduce the frequency of interrupt events.",
    "18.4.3 INTERRUPTS IN CONTINUOUS UP/DOWN COUNT MODE\nWhen the PWM time base is in the Single-Shot mode (PTMOD<1:0> = 01 ), an interrupt event is generated when a  match  with  the  PTPER  register  occurs.  The PWM Time Base register (PTMR) is reset to zero on the  following  input  clock  edge  and  the  PTEN  bit  is cleared. The postscaler selection bits have no effect in this Timer mode.\nIn the Continuous Up/Down Count mode (PTMOD<1:0> = 10 ), an interrupt event is generated each  time  the  value  of  the  PTMR  register  becomes zero and the PWM time base begins to count upwards. The postscaler selection bits may be used in this mode of  the  timer  to  reduce  the  frequency  of  the  interrupt events. Figure 18-7 shows the interrupts in Continuous Up/Down Count mode.",
    "FIGURE 18-6: PWM TIME BASE INTERRUPT TIMING, SINGLE-SHOT MODE\n, 1 = Qc. , 2 = Qc. , 3 = Qc. , 4 = Qc. , 5 = Qc. , 6 = Qc. , 7 = Qc. , 8 = Qc Qc. , 9 = Qc. , 10 = Qc. , 11 = Qc. , 12 = Qc. , 13 = Qc. , 14 = Qc Qc. , 15 = Qc. , 16 = Qc. , 17 = Qc. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = 2. , 7 = . , 8 = . , 9 = . , 10 = . , 11 = . , 12 = . , 13 = . , 14 = . , 15 = . , 16 = . , 17 = . PTMR, 1 = . PTMR, 2 = FFEh. PTMR, 3 = . PTMR, 4 = . PTMR, 5 = FFFh. PTMR, 6 = . PTMR, 7 = . PTMR, 8 = . PTMR, 9 = . PTMR, 10 = 000h. PTMR, 11 =",
    "FIGURE 18-6: PWM TIME BASE INTERRUPT TIMING, SINGLE-SHOT MODE\n. PTMR, 12 = . PTMR, 13 = 000h. PTMR, 14 = . PTMR, 15 = . PTMR, 16 = 000h. PTMR, 17 = . , 1 = . , 2 = . , 3 = . , 4 = 1. , 5 = . , 6 = . , 7 = . , 8 = . , 9 = . , 10 = . , 11 = . , 12 = . , 13 = . , 14 = . , 15 = . , 16 = . , 17 = . , 1 = 1. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 8 = 1. , 9 = . , 10 = . , 11 = . , 12 = . , 13 = . , 14 = . , 15 = . , 16 = . , 17 = . PTMR_INT_REQ, 1 = . PTMR_INT_REQ, 2 = . PTMR_INT_REQ, 3 = . PTMR_INT_REQ, 4 = .",
    "FIGURE 18-6: PWM TIME BASE INTERRUPT TIMING, SINGLE-SHOT MODE\nPTMR_INT_REQ, 5 = . PTMR_INT_REQ, 6 = . PTMR_INT_REQ, 7 = . PTMR_INT_REQ, 8 = . PTMR_INT_REQ, 9 = . PTMR_INT_REQ, 10 = . PTMR_INT_REQ, 11 = . PTMR_INT_REQ, 12 = . PTMR_INT_REQ, 13 = . PTMR_INT_REQ, 14 = . PTMR_INT_REQ, 15 = . PTMR_INT_REQ, 16 = . PTMR_INT_REQ, 17 = . PTIF bit, 1 = . PTIF bit, 2 = . PTIF bit, 3 = . PTIF bit, 4 = . PTIF bit, 5 = . PTIF bit, 6 = . PTIF bit, 7 = . PTIF bit, 8 = . PTIF bit, 9 = . PTIF bit, 10 = . PTIF bit, 11 = . PTIF bit, 12 =",
    "FIGURE 18-6: PWM TIME BASE INTERRUPT TIMING, SINGLE-SHOT MODE\n. PTIF bit, 13 = . PTIF bit, 14 = . PTIF bit, 15 = . PTIF bit, 16 = . PTIF bit, 17 = ",
    "FIGURE 18-7: PWM TIME BASE INTERRUPT, CONTINUOUS UP/DOWN COUNT MODE\n, 1 = Qc. , 2 = Qc. , 3 = Qc. , 4 = Qc Qc. , 5 = Qc. , 6 = Qc Qc. , 7 = Qc. , 8 = Qc. , 9 = Qc Qc. , 10 = Qc. , 11 = Qc. , 12 = Qc Qc. , 13 = Qc. , 14 = Qc Qc. PTMR 002h 001h 001h 002h 000h, 1 = PTMR 002h 001h 001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 2 = PTMR 002h 001h 001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 3 = PTMR 002h 001h 001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 4 = PTMR 002h 001h 001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 5 = PTMR 002h 001h",
    "FIGURE 18-7: PWM TIME BASE INTERRUPT, CONTINUOUS UP/DOWN COUNT MODE\n001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 6 = PTMR 002h 001h 001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 7 = PTMR 002h 001h 001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 8 = PTMR 002h 001h 001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 9 = PTMR 002h 001h 001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 10 = PTMR 002h 001h 001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 11 = PTMR 002h 001h 001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 12 = PTMR 002h 001h",
    "FIGURE 18-7: PWM TIME BASE INTERRUPT, CONTINUOUS UP/DOWN COUNT MODE\n001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 13 = PTMR 002h 001h 001h 002h 000h. PTMR 002h 001h 001h 002h 000h, 14 = PTMR 002h 001h 001h 002h 000h. PTDIR bit, 1 = PTDIR bit. PTDIR bit, 2 = PTDIR bit. PTDIR bit, 3 = PTDIR bit. PTDIR bit, 4 = PTDIR bit. PTDIR bit, 5 = PTDIR bit. PTDIR bit, 6 = PTDIR bit. PTDIR bit, 7 = PTDIR bit. PTDIR bit, 8 = PTDIR bit. PTDIR bit, 9 = PTDIR bit. PTDIR bit, 10 = PTDIR bit. PTDIR bit, 11 = PTDIR bit. PTDIR bit, 12 = PTDIR bit. PTDIR bit, 13 = PTDIR bit. PTDIR bit, 14",
    "FIGURE 18-7: PWM TIME BASE INTERRUPT, CONTINUOUS UP/DOWN COUNT MODE\n= PTDIR bit. 1 PTMR_INT_REQ, 1 = 1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 2 = 1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 3 = 1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 4 = 1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 5 = 1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 6 = 1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 7 = 1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 8 = 1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 9 = 1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 10 = 1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 11 =",
    "FIGURE 18-7: PWM TIME BASE INTERRUPT, CONTINUOUS UP/DOWN COUNT MODE\n1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 12 = 1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 13 = 1 PTMR_INT_REQ. 1 PTMR_INT_REQ, 14 = 1 PTMR_INT_REQ. PTIF bit, 1 = PTIF bit. PTIF bit, 2 = PTIF bit. PTIF bit, 3 = PTIF bit. PTIF bit, 4 = PTIF bit. PTIF bit, 5 = PTIF bit. PTIF bit, 6 = PTIF bit. PTIF bit, 7 = PTIF bit. PTIF bit, 8 = PTIF bit. PTIF bit, 9 = PTIF bit. PTIF bit, 10 = PTIF bit. PTIF bit, 11 = PTIF bit. PTIF bit, 12 = PTIF bit. PTIF bit, 13 = PTIF bit. PTIF bit, 14 = PTIF bit",
    "18.4.4 INTERRUPTS IN DOUBLE UPDATE MODE\nNote:\nThis mode is available in Continuous Up/Down Count mode. In the Double Update mode (PTMOD<1:0> = 11 ), an  interrupt  event  is  generated  each  time  the  PTMR register  is  equal  to  zero  and  each  time  the  PTMR matches with  PTPER register.  Figure 18-8  shows  the interrupts  in  Continuous  Up/Down  Count  mode  with double updates.\nThe  Double  Update  mode  provides  two  additional functions to the user in Center-Aligned mode.\n1. The control loop bandwidth is doubled because the PWM duty cycles can be updated twice per period.\n2. Asymmetrical  center-aligned  PWM  waveforms can be generated, which are useful for minimizing output waveform distortion in certain motor control applications.",
    "FIGURE 18-8: PWM TIME BASE INTERRUPT, CONTINUOUS UP/DOWN COUNT MODE WITH DOUBLE UPDATES\nDo  not  change  the  PTMOD  bits  while PTEN  is  active;  it  will  yield  unexpected results. To change the PWM Timer mode of operation, first clear the PTEN bit, load the  PTMOD  bits  with  the  required  data and then set PTEN.",
    "18.5 PWM Period\nThe PWM period is defined by the PTPER register pair (PTPERL and PTPERH). The PWM period has 12-bit resolution by combining 4 LSBs of PTPERH and 8 bits of PTPERL. PTPER is a double-buffered register used to set the counting period for the PWM time base.\nThe  PTPER  register  contents  are  loaded  into  the PTPER register at the following times:\n\u00b7 Free-Running and Single-Shot modes: When the PTMR register is reset to zero after a match with the PTPER register.\n\u00b7 Continuous Up/Down Count modes: When the PTMR register is zero. The value held in the PTPER register is automatically loaded into the PTPER register when the PWM time base is disabled (PTEN = 0 ). Figure 18-9 and Figure 18-10 indicate the times when the contents of the PTPER register are loaded into the actual PTPER register.\nThe PWM period can be calculated from the following formulas:",
    "EQUATION 18-1: PWM PERIOD FOR FREE-RUNNING MODE\nTPWM =, 1 = (PTPER + 1) x PTMRPS FOSC /4",
    "EQUATION 18-2: PWM PERIOD FOR UP/DOWN COUNT MODE\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nThe PWM frequency is the inverse of period; or:",
    "EQUATION 18-3: PWM FREQUENCY\n<!-- formula-not-decoded -->\nThe  maximum  resolution  (in  bits)  for  a  given  device oscillator and PWM frequency can be determined from the following formula:",
    "EQUATION 18-4: PWM RESOLUTION\n<!-- formula-not-decoded -->\nThe PWM resolutions and frequencies are shown for a selection  of  execution  speeds  and  PTPER  values  in Table 18-2.  The  PWM  frequencies  in  Table 18-2  are calculated for Edge-Aligned PWM mode. For Center-Aligned  mode,  the  PWM  frequencies  will  be approximately  one-half  the  values  indicated  in  this table.",
    "PWM Frequency = 1/TPWM\n40 MHz, MIPS = 10. 40 MHz, PTPER Value = 0FFFh. 40 MHz, PWM Resolution = 14 bits. 40 MHz, PWM Frequency = 2.4 kHz. 40 MHz, MIPS = 10. 40 MHz, PTPER Value = 07FFh. 40 MHz, PWM Resolution = 13 bits. 40 MHz, PWM Frequency = 4.9 kHz. 40 MHz, MIPS = 10. 40 MHz, PTPER Value = 03FFh. 40 MHz, PWM Resolution = 12 bits. 40 MHz, PWM Frequency = 9.8 kHz. 40 MHz, MIPS = 10. 40 MHz, PTPER Value = 01FFh. 40 MHz, PWM Resolution = 11 bits. 40 MHz, PWM Frequency = 19.5 kHz. 40 MHz, MIPS = 10. 40 MHz, PTPER Value = FFh. 40 MHz, PWM Resolution = 10 bits. 40 MHz, PWM Frequency = 39.0 kHz. 40 MHz, MIPS = 10. 40 MHz, PTPER Value = 7Fh. 40 MHz, PWM Resolution = 9 bits. 40",
    "PWM Frequency = 1/TPWM\nMHz, PWM Frequency = 78.1 kHz. 40 MHz, MIPS = 10. 40 MHz, PTPER Value = 3Fh. 40 MHz, PWM Resolution = 8 bits. 40 MHz, PWM Frequency = 156.2 kHz. 40 MHz, MIPS = 10. 40 MHz, PTPER Value = 1Fh. 40 MHz, PWM Resolution = 7 bits. 40 MHz, PWM Frequency = 312.5 kHz. 40 MHz, MIPS = 10. 40 MHz, PTPER Value = 0Fh. 40 MHz, PWM Resolution = 6 bits. 40 MHz, PWM Frequency = 625 kHz. 25 MHz, MIPS = 6.25. 25 MHz, PTPER Value = 0FFFh. 25 MHz, PWM Resolution = 14 bits. 25 MHz, PWM Frequency = 1.5 kHz. 25 MHz, MIPS = 6.25. 25 MHz, PTPER Value = 03FFh. 25 MHz, PWM Resolution = 12 bits. 25 MHz, PWM Frequency = 6.1 kHz. 25 MHz, MIPS = 6.25. 25 MHz, PTPER Value",
    "PWM Frequency = 1/TPWM\n= FFh. 25 MHz, PWM Resolution = 10 bits. 25 MHz, PWM Frequency = 24.4 kHz. 10 MHz, MIPS = 2.5. 10 MHz, PTPER Value = 0FFFh. 10 MHz, PWM Resolution = 14 bits. 10 MHz, PWM Frequency = 610 Hz. 10 MHz, MIPS = 2.5. 10 MHz, PTPER Value = 03FFh. 10 MHz, PWM Resolution = 12 bits. 10 MHz, PWM Frequency = 2.4 kHz. 10 MHz, MIPS = 2.5. 10 MHz, PTPER Value = FFh. 10 MHz, PWM Resolution = 10 bits. 10 MHz, PWM Frequency = 9.8 kHz. 5 MHz, MIPS = 1.25. 5 MHz, PTPER Value = 0FFFh. 5 MHz, PWM Resolution = 14 bits. 5 MHz, PWM Frequency = 305 Hz. 5 MHz, MIPS = 1.25. 5 MHz, PTPER Value = 03FFh. 5 MHz, PWM Resolution = 12 bits. 5 MHz, PWM Frequency =",
    "PWM Frequency = 1/TPWM\n1.2 kHz. 5 MHz, MIPS = 1.25. 5 MHz, PTPER Value = FFh. 5 MHz, PWM Resolution = 10 bits. 5 MHz, PWM Frequency = 4.9 kHz. 4 MHz, MIPS = 1. 4 MHz, PTPER Value = 0FFFh. 4 MHz, PWM Resolution = 14 bits. 4 MHz, PWM Frequency = 244 Hz. 4 MHz, MIPS = 1. 4 MHz, PTPER Value = 03FFh. 4 MHz, PWM Resolution = 12 bits. 4 MHz, PWM Frequency = 976 Hz. 4 MHz, MIPS = 1. 4 MHz, PTPER Value = FFh. 4 MHz, PWM Resolution = 10 bits. 4 MHz, PWM Frequency = 3.9 kHz\nNote: For center-aligned operation, PWM frequencies will be approximately 1/2 the value indicated in the table.",
    "FIGURE 18-9: PWM PERIOD BUFFER UPDATES IN FREE-RUNNING MODE\nFIGURE 18-10: PWM PERIOD BUFFER UPDATES IN CONTINUOUS UP/DOWN COUNT MODE",
    "18.6 PWM Duty Cycle\nPWM duty cycle is defined by the PDCx (PDCxL and PDCxH) registers. There are a total of four PWM Duty Cycle registers for four  pairs  of  PWM  channels.  The Duty Cycle registers have 14-bit resolution by combining six LSbs of PDCxH with the 8 bits of PDCxL. PDCx is a double-buffered register used to set the counting period for the PWM time base.\nThe value in each Duty Cycle register determines the amount of time that the PWM output is in the active state. The upper 12 bits of PDCx holds the actual duty cycle  value  from  PTMRH/L<11:0>,  while  the  lower 2 bits  control  which  internal  Q  clock  the  duty  cycle match will occur. This 2-bit value is decoded from the Q clocks as shown in Figure 18-11 (when the prescaler is 1:1 or PTCKPS<1:0> = 00 ).",
    "18.6.1 PWM DUTY CYCLE REGISTERS\nThere are four 14-bit Special Function Registers used to specify duty cycle values for the PWM module:\n\u00b7 PDC0 (PDC0L and PDC0H)\n\u00b7 PDC1 (PDC1L and PDC1H)\n\u00b7 PDC2 (PDC2L and PDC2H)\n\u00b7 PDC3 (PDC3L and PDC3H)\nIn  Edge-Aligned mode, the PWM period starts at Q1 and ends when the Duty Cycle register matches the PTMR register as follows. The duty cycle match is considered when the upper 12 bits of the PDCx are equal to the PTMR and the lower 2 bits are equal to Q1, Q2, Q3 or Q4, depending on the lower two bits of the PDCx (when the prescaler is 1:1 or PTCKPS<1:0> = 00 ) .",
    "Note:\nWhen the prescaler is not 1:1 (PTCKPS<1:0> \uf0b9 ~ 00 ), the  duty  cycle match  occurs  at  the  Q1  clock  of  the instruction  cycle  when  the  PTMR  and PDCx match occurs.\nEach compare unit has logic that allows override of the PWM signals. This logic also ensures that the PWM signals  will  complement  each  other  (with  dead-time insertion) in Complementary mode (see Section 18.7 'Dead-Time Generators' ).",
    "18.6.3 EDGE-ALIGNED PWM\nThe four PWM Duty Cycle registers are double-buffered to allow glitchless updates of the PWM outputs.  For  each  duty  cycle  block,  there  is  a  Duty Cycle Buffer register that is accessible by the user and a  second  Duty  Cycle  register  that  holds  the  actual compare value used in the present PWM period.\nIn Edge-Aligned PWM Output mode, a new duty cycle value will be updated whenever a PTMR match with the PTPER register occurs and PTMR is reset as shown in Figure 18-12. Also, the contents of the duty cycle buffers are automatically loaded into the Duty Cycle registers when the PWM time base is disabled (PTEN = 0 ).",
    "18.6.3 EDGE-ALIGNED PWM\nWhen  the  PWM  time  base  is  in  the  Continuous Up/Down Count mode, new duty cycle values will be updated when the value of the PTMR register is zero and the PWM time base begins to count upwards. The contents  of  the  duty  cycle  buffers  are  automatically loaded into  the  Duty  Cycle  registers  when  the  PWM time base is disabled (PTEN = 0 ). Figure 18-13 shows the timings when the duty cycle update occurs for the Continuous Up/Down Count mode. In this mode, up to one entire PWM period is available for calculating and loading the new PWM duty cycle before changes take effect.",
    "18.6.3 EDGE-ALIGNED PWM\nEdge-aligned PWM  signals  are  produced  by  the module when the PWM  time base is in the Free-Running  mode  or  the  Single-Shot  mode.  For edge-aligned  PWM  outputs,  the  output  for  a  given PWM  channel  has  a  period  specified  by  the  value loaded  in  PTPER  and  a  duty  cycle  specified  by  the appropriate  Duty  Cycle  register  (see  Figure 18-12). The PWM output is driven active at the beginning of the period  (PTMR  = 0 )  and  is  driven  inactive  when  the value in the Duty Cycle register matches PTMR. A new cycle is started when PTMR matches the PTPER as explained in the PWM period section.\nIf the value in a particular Duty Cycle register is zero, then the output on the corresponding PWM pin will be inactive for the entire PWM period. In addition, the output on the PWM pin will be active for the entire PWM period if the value in the Duty Cycle register is greater than the value held in the PTPER register.\nFIGURE 18-12: EDGE-ALIGNED PWM",
    "18.6.3 EDGE-ALIGNED PWM\nWhen  the  PWM  time  base  is  in  the  Continuous Up/Down Count mode with double updates, new duty cycle  values  will  be  updated  when  the  value  of  the PTMR register is zero and when the value of the PTMR register matches the value in the PTPER register. The contents  of  the  duty  cycle  buffers  are  automatically loaded into the Duty Cycle registers during both of the previously  described  conditions.  Figure 18-14  shows the duty cycle updates for Continuous Up/Down Count mode with double updates. In this mode, only up to half of a PWM period is available for calculating and loading the new PWM duty cycle before changes take effect.\nFIGURE 18-13: DUTY CYCLE UPDATE TIMES IN CONTINUOUS UP/DOWN COUNT MODE",
    "18.6.4 CENTER-ALIGNED PWM\nCenter-aligned  PWM  signals  are  produced  by  the module when the PWM time base is configured in a Continuous Up/Down Count mode (see Figure 18-15). The PWM compare output is driven to the active state when the value of the Duty Cycle register matches the value  of  PTMR  and  the  PWM  time  base  is  counting downwards (PTDIR = 1 ).  The  PWM compare  output will be driven to the inactive state when the PWM time base is counting upwards (PTDIR = 0 ) and the value in the PTMR register matches the duty cycle value. If the value in a particular Duty Cycle register is zero, then the  output  on  the  corresponding  PWM  pin  will  be inactive  for  the  entire  PWM  period.  In  addition,  the output on the PWM pin will be active for the entire PWM period if the value in the Duty Cycle register is equal to or greater than the value in the PTPER register.",
    "Note:\nWhen the PWM is started in Center-Aligned  mode,  the  PWM  Time Base Period  register  (PTPER) is  loaded into the PWM Time Base register (PTMR) and the PTMR is configured automatically to  start  down  counting.  This  is  done  to ensure that all the PWM signals don't start at the same time.\nFIGURE 18-15: START OF CENTER-ALIGNED PWM",
    "18.6.5 COMPLEMENTARY PWM OPERATION\nFIGURE 18-16:\nThe Complementary mode of PWM operation is useful to  drive  one  or  more  power  switches  in  half-bridge configuration as shown in Figure 18-16. This inverter topology  is  typical  for  a  3-phase  induction  motor, brushless  DC  motor  or  a  3-phase  Uninterruptible Power Supply (UPS) control applications.\nEach  upper/lower  power  switch  pair  is  fed  by  a complementary  PWM  signal.  Dead  time may  be optionally inserted during device switching, where both outputs are inactive for a short period (see Section 18.7 'Dead-Time Generators' ).\nIn  Complementary  mode,  the  duty  cycle  comparison units are assigned to the PWM outputs as follows:\n\u00b7 PDC0 register controls PWM1/PWM0 outputs\n\u00b7 PDC1 register controls PWM3/PWM2 outputs\n\u00b7 PDC2 register controls PWM5/PWM4 outputs\n\u00b7 PDC3 register controls PWM7/PWM6 outputs",
    "18.6.5 COMPLEMENTARY PWM OPERATION\nPWM1/3/5/7 are the main PWMs that are controlled by the PDCx registers and PWM0/2/4/6 are the complemented  outputs.  When  using  the  PWMs  to control the half bridge, the odd numbered PWMs can be used to control the upper power switch and the even numbered PWMs used for the lower switches.\nTYPICAL LOAD FOR COMPLEMENTARY PWM OUTPUTS\nThe Complementary mode is selected for each PWM I/O pin pair by clearing the appropriate PMODx bit in the PWMCON0 register. The PWM I/O pins are set to Complementary  mode  by  default  upon  all  kinds  of device Resets.",
    "18.7.1 DEAD-TIME INSERTION\nIn  power  inverter  applications,  where  the  PWMs  are used in Complementary mode to control the upper and lower switches of a half-bridge, a dead-time insertion is highly  recommended. The  dead-time insertion keeps both  outputs  in  inactive  state  for  a  brief  time.  This avoids  any  overlap  in  the  switching  during  the  state change  of  the  power  devices  due  to  TON  and  TOFF characteristics.\nBecause  the  power  output  devices  cannot  switch instantaneously,  some  amount  of  time  must  be  provided between the turn-off event of one PWM output in a  complementary  pair  and  the  turn-on  event  of  the other transistor. The PWM module allows dead time to be  programmed.  The  following  sections  explain  the dead-time block in detail.",
    "18.7.1 DEAD-TIME INSERTION\nEach complementary output pair for the PWM module has a 6-bit down  counter used to produce the dead-time insertion.  As  shown  in  Figure 18-17,  each dead-time unit has a rising and falling edge detector connected  to  the  duty  cycle  comparison  output.  The dead time is loaded into the timer on the detected PWM edge event. Depending on whether the edge is rising or falling,  one  of  the  transitions  on  the  complementary outputs is delayed until the timer counts down to zero. A timing diagram, indicating the dead-time insertion for one pair of PWM outputs, is shown in Figure 18-18.",
    "REGISTER 18-5: DTCON: DEAD-TIME CONTROL REGISTER\nDTPS1, R/W-0 = DTPS0. DTPS1, R/W-0 = DT5. DTPS1, R/W-0 = DT4. DTPS1, R/W-0 = DT3. DTPS1, R/W-0 = DT2. DTPS1, R/W-0 = DT1. DTPS1, R/W-0 = DT0. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 18-5: DTCON: DEAD-TIME CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-6\nDTPS<1:0>: Dead-Time Unit A Prescale Select bits\n11 =  Clock source for dead-time unit is FOSC/16\n10 =  Clock source for dead-time unit is FOSC/8\n01 =  Clock source for dead-time unit is FOSC/4\n00 =  Clock source for dead-time unit is FOSC/2\nbit 5-0\nDT<5:0>: Unsigned 6-Bit Dead-Time Value for Dead-Time Unit bits",
    "18.7.2 DEAD-TIME RANGES\nThe amount of dead time provided by the dead-time unit is selected by specifying the input clock prescaler value and a 6-bit unsigned value defined in the DTCON register.  Four  input  clock  prescaler  selections  have been provided to allow a suitable range of dead times based  on  the  device  operating  frequency.  FOSC/2, FOSC/4, FOSC/8 and FOSC/16 are the clock prescaler options available using the DTPS<1:0> control bits in the DTCON register.\nAfter  selecting  an  appropriate  prescaler  value,  the dead time is adjusted by loading a 6-bit unsigned value into  DTCON<5:0>.  The  dead-time  unit  prescaler  is cleared on any of the following events:\n\u00b7 On a load of the down timer due to a duty cycle comparison edge event;\n\u00b7 On a write to the DTCON register; or\n\u00b7 On any device Reset.",
    "18.7.3 DECREMENTING THE DEAD-TIME COUNTER\nThe dead-time counter is clocked from any of the Q clocks based on the following conditions.",
    "18.7.3 DECREMENTING THE DEAD-TIME COUNTER\n1. The dead-time counter is clocked on Q1 when:\n\u00b7 The DTPS bits are set to any of the following dead-time prescaler settings: FOSC/4, FOSC/8, FOSC/16\n\u00b7 The PWM Time Base Prescale bits (PTCKPS) are set to any of the following prescale ratios: FOSC/16, FOSC/64, FOSC/256\n2. The dead-time counter is clocked by a pair of Q clocks when the PWM Time Base Prescale bits are set to 1:1 (PTCKPS<1:0> = 00 , FOSC/4) and the dead-time counter is clocked by the FOSC/2 (DTPS<1:0> = 00 ).\n3. The dead-time counter is  clocked  using  every other Q clock, depending on the two LSbs in the Duty Cycle registers:\n\u00b7 If the PWM duty cycle match occurs on Q1 or Q3, then the dead-time counter is clocked using every Q1 and Q3.",
    "18.7.3 DECREMENTING THE DEAD-TIME COUNTER\n\u00b7 If the PWM duty cycle match occurs on Q2 or Q4, then the dead-time counter is clocked using every Q2 and Q4.\n4. When the DTPS<1:0> bits are set to any of the other dead-time prescaler settings (i.e., FOSC/4, FOSC/8  or  FOSC/16)  and  the  PWM  time  base prescaler is set to 1:1, the dead-time counter is clocked by the Q clock corresponding to the Q clocks  on  which  the  PWM  duty  cycle  match occurs.",
    "PIC18F2331/2431/4331/4431\nThe actual dead time is calculated from the DTCON register as follows:",
    "18.7.4 DEAD-TIME DISTORTION\nDead Time = Dead-Time Value/(FOSC/Prescaler)\nTable 18-3  shows  example  dead-time  ranges  as  a function of the input clock prescaler selected and the device operating frequency.",
    "TABLE 18-3: EXAMPLE DEAD-TIME RANGES\n40, MIPS = 10. 40, Prescaler Selection = FOSC/2. 40, Dead-Time Min = 50 ns. 40, Dead-Time Max = 3.2 \uf06d s. 40, MIPS = 10. 40, Prescaler Selection = FOSC/4. 40, Dead-Time Min = 100 ns. 40, Dead-Time Max = 6.4 \uf06d s. 40, MIPS = 10. 40, Prescaler Selection = FOSC/8. 40, Dead-Time Min = 200 ns. 40, Dead-Time Max = 12.8 \uf06d s. 40, MIPS = 10. 40, Prescaler Selection = FOSC/16. 40, Dead-Time Min = 400 ns. 40, Dead-Time Max = 25.6 \uf06d s. 32, MIPS = 8. 32, Prescaler Selection = FOSC/2. 32, Dead-Time Min = 62.5 ns. 32, Dead-Time Max = 4 \uf06d s. 32, MIPS = 8. 32, Prescaler Selection = FOSC/4. 32, Dead-Time Min = 125 ns. 32, Dead-Time Max",
    "TABLE 18-3: EXAMPLE DEAD-TIME RANGES\n= 8 \uf06d s. 32, MIPS = 8. 32, Prescaler Selection = FOSC/8. 32, Dead-Time Min = 250 ns. 32, Dead-Time Max = 16 \uf06d s. 32, MIPS = 8. 32, Prescaler Selection = FOSC/16. 32, Dead-Time Min = 500 ns. 32, Dead-Time Max = 32 \uf06d s. 25, MIPS = 6.25. 25, Prescaler Selection = FOSC/2. 25, Dead-Time Min = 80 ns. 25, Dead-Time Max = 5.12 \uf06d s. 25, MIPS = 6.25. 25, Prescaler Selection = FOSC/4. 25, Dead-Time Min = 160 ns. 25, Dead-Time Max = 10.2 \uf06d s. 25, MIPS = 6.25. 25, Prescaler Selection = FOSC/8. 25, Dead-Time Min = 320 ns. 25, Dead-Time Max = 20.5 \uf06d s. 25, MIPS = 6.25. 25, Prescaler Selection = FOSC/16. 25, Dead-Time Min = 640",
    "TABLE 18-3: EXAMPLE DEAD-TIME RANGES\nns. 25, Dead-Time Max = 41 \uf06d s. 20, MIPS = 5. 20, Prescaler Selection = FOSC/2. 20, Dead-Time Min = 100 ns. 20, Dead-Time Max = 6.4 \uf06d s. 20, MIPS = 5. 20, Prescaler Selection = FOSC/4. 20, Dead-Time Min = 200 ns. 20, Dead-Time Max = 12.8 \uf06d s. 20, MIPS = 5. 20, Prescaler Selection = FOSC/8. 20, Dead-Time Min = 400 ns. 20, Dead-Time Max = 25.6 \uf06d s. 20, MIPS = 5. 20, Prescaler Selection = FOSC/16. 20, Dead-Time Min = 800 ns. 20, Dead-Time Max = 51.2 \uf06d s. 10, MIPS = 2.5. 10, Prescaler Selection = FOSC/2. 10, Dead-Time Min = 200 ns. 10, Dead-Time Max = 12.8 \uf06d s. 10, MIPS = 2.5. 10, Prescaler Selection = FOSC/4.",
    "TABLE 18-3: EXAMPLE DEAD-TIME RANGES\n10, Dead-Time Min = 400 ns. 10, Dead-Time Max = 25.6 \uf06d s. 10, MIPS = 2.5. 10, Prescaler Selection = FOSC/8. 10, Dead-Time Min = 800 ns. 10, Dead-Time Max = 51.2 \uf06d s. 10, MIPS = 2.5. 10, Prescaler Selection = FOSC/16. 10, Dead-Time Min = 1.6 \uf06d s. 10, Dead-Time Max = 102.4 \uf06d s. 5, MIPS = 1.25. 5, Prescaler Selection = FOSC/2. 5, Dead-Time Min = 400 ns. 5, Dead-Time Max = 25.6 \uf06d s. 5, MIPS = 1.25. 5, Prescaler Selection = FOSC/4. 5, Dead-Time Min = 800 ns. 5, Dead-Time Max = 51.2 \uf06d s. 5, MIPS = 1.25. 5, Prescaler Selection = FOSC/8. 5, Dead-Time Min = 1.6 \uf06d s. 5, Dead-Time Max = 102.4 \uf06d s.",
    "TABLE 18-3: EXAMPLE DEAD-TIME RANGES\n5, MIPS = 1.25. 5, Prescaler Selection = FOSC/16. 5, Dead-Time Min = 3.2 \uf06d s. 5, Dead-Time Max = 204.8 \uf06d s. 4, MIPS = 1. 4, Prescaler Selection = FOSC/2. 4, Dead-Time Min = 0.5 \uf06d s. 4, Dead-Time Max = 32 \uf06d s. 4, MIPS = 1. 4, Prescaler Selection = FOSC/4. 4, Dead-Time Min = 1 \uf06d s. 4, Dead-Time Max = 64 \uf06d s. 4, MIPS = 1. 4, Prescaler Selection = FOSC/8. 4, Dead-Time Min = 2 \uf06d s. 4, Dead-Time Max = 128 \uf06d s. 4, MIPS = 1. 4, Prescaler Selection = FOSC/16. 4, Dead-Time Min = 4 \uf06d s. 4, Dead-Time Max = 256 \uf06d s",
    "TABLE 18-3: EXAMPLE DEAD-TIME RANGES\nNote 1: For small PWM duty cycles, the ratio of dead time to the active PWM time may become large. In this case, the inserted dead  time  will  introduce  distortion  into waveforms produced by the PWM module. The user can ensure that dead-time distortion is minimized by keeping  the  PWM  duty  cycle  at  least three times larger than the dead time. A similar effect occurs for duty cycles at or near  100%.  The  maximum  duty  cycle used in the application should be chosen such  that  the  minimum  inactive  time  of the  signal  is  at  least  three  times  larger than  the  dead  time.  If  the  dead  time  is greater or equal to the duty cycle of one of the PWM output pairs, then that PWM pair will be inactive for the whole period.\n2: Changing the dead-time values in DTCON when the PWM is enabled may result in an undesired situation. Disable the  PWM  (PTEN  = 0 )  before  changing the dead-time value",
    "18.8 Independent PWM Output\nIndependent PWM mode is used for driving the loads (as shown in Figure 18-19) for driving one winding of a switched  reluctance  motor.  A  particular  PWM  output pair  is  configured  in  the  Independent  Output  mode when the corresponding PMOD bit in the PWMCON0 register  is  set.  No  dead-time  control  is  implemented between the PWM I/O pins when the module is operating in the Independent PWM mode and both I/O pins are allowed to be active simultaneously. This mode can also be used to drive stepper motors.",
    "18.8.1 DUTY CYCLE ASSIGNMENT IN THE INDEPENDENT PWM MODE\nIn the Independent PWM mode, each duty cycle generator is connected to both PWM output pins in a given PWM output pair. The odd and even PWM output pins are  driven  with  a  single  PWM  duty  cycle  generator. PWM1 and  PWM0  are  driven  by  the  PWM  channel which  uses  the  PDC0  register  to  set  the  duty  cycle, PWM3 and PWM2 with PDC1, PWM5 and PWM4 with PDC2,  and  PWM7  and  PWM6  with  PDC3  (see Figure 18-3 and Register 18-4).",
    "18.8.2 PWM CHANNEL OVERRIDE\nPWM  output  may  be  manually  overridden  for  each PWM  channel  by  using  the  appropriate  bits  in  the OVDCOND and OVDCONS registers. The user may select the following signal output options for each PWM output pin operating in the Independent PWM mode:\n- \u00b7 I/O pin outputs PWM signal\nOVDCOND  and  OVDCONS  registers  are  used  to define  the  PWM  override  options.  The  OVDCOND register contains eight bits, POVD<7:0>, that determine which PWM I/O pins will be overridden. The OVDCONS register  contains  eight  bits,  POUT<7:0>, that determine the state of the PWM I/O pins when a particular output is overridden via the POVD bits.\n\u00b7 I/O pin inactive\n\u00b7 I/O pin active\nRefer to Section 18.10 'PWM Output Override' for details for all the override functions.",
    "18.9 Single-Pulse PWM Operation\nThe single-pulse  PWM  operation  is  available  only  in Edge-Aligned mode. In this mode, the PWM module will produce single-pulse output. Single-pulse operation is configured when the PTMOD<1:0> bits are set  to  ' 01 ' in  the  PTCON0  register.  This  mode  of operation is useful for driving certain types of ECMs.\nIn Single-Pulse mode, the PWM I/O pin(s) are driven to the active state when the PTEN bit is set. When the PWM timer match with the Duty Cycle register occurs, the PWM I/O pin is driven to the inactive state. When the PWM timer match with the PTPER register occurs, the PTMR register is cleared, all active PWM I/O pins are driven to the inactive state, the PTEN bit is cleared and  an  interrupt  is  generated  if  the  corresponding interrupt bit is set.",
    "Note:\nPTPER and PDCx values are held as they are after the single-pulse output. To have another cycle of single pulse, only PTEN has to be enabled.",
    "18.10 PWM Output Override\nThe PWM output override bits allow the user to manually  drive  the  PWM I/O pins to specified logic states, independent of the duty cycle comparison units. The PWM override bits are useful when controlling various types of ECMs like a BLDC motor.\nThe POVD bits are active-low control bits. When the POVD bits  are  set,  the  corresponding  POUT  bit  will have no effect on the PWM output. In other words, the pins corresponding to POVD bits that are set will have the duty PWM cycle set by the PDCx registers. When one of the POVD bits is cleared, the output on the corresponding  PWM  I/O  pin  will  be  determined  by  the state  of  the  POUT  bit.  When  a  POUT  bit  is  set,  the PWM pin will be driven to its active  state. When the POUT bit is cleared, the PWM pin will be driven to its inactive state.",
    "18.10.1 COMPLEMENTARY OUTPUT MODE\nThe  even  numbered  PWM  I/O  pins  have  override restrictions when a pair of PWM I/O pins are operating in the Complementary mode (PMODx = 0 ). In Complementary  mode,  if  the  even  numbered  pin  is  driven active by clearing the corresponding POVD bit and by setting POUT bits in the OVDCOND and OVDCONS registers, the output signal is forced to be the complement  of  the  odd  numbered  I/O  pin  in  the  pair  (see Figure 18-2 for details).",
    "18.10.2 OVERRIDE SYNCHRONIZATION\nIf the OSYNC bit in the PWMCON1 register is set, all output  overrides  performed  via  the  OVDCOND  and OVDCONS registers will be synchronized to the PWM time base. Synchronous output overrides will occur on the following conditions:\n\u00b7 When the PWM is in Edge-Aligned mode, synchronization occurs when PTMR is zero.\n\u00b7 When the PWM is in Center-Aligned mode, synchronization occurs when PTMR is zero and when the value of PTMR matches PTPER.\nNote 1: In  the  Complementary  mode,  the  even channel  cannot  be  forced  active  by  a Fault  or  override  event  when  the  odd channel  is  active.  The  even  channel  is always the complement of the odd channel with dead time inserted, before the  odd  channel  can  be  driven  to  its active state, as shown in Figure 18-20.\n2: Dead time is inserted in the PWM channels even when they are in Override mode.",
    "PIC18F2331/2431/4331/4431\nAssume: POVD0 = 0 ; POVD1 = 0 ; PMOD0 = 0",
    "18.10.3 OUTPUT OVERRIDE EXAMPLES\nFigure 18-21  shows  an  example  of  a  waveform  that might  be  generated  using  the  PWM  output  override feature.  The  figure  shows  a  six-step  commutation sequence  for  a  BLDC  motor.  The  motor  is  driven through a 3-phase inverter as shown in Figure 18-16. When the  appropriate  rotor  position  is  detected,  the PWM outputs are  switched  to  the  next  commutation state in the sequence. In this example, the PWM outputs are driven to specific logic states. The OVDCOND and OVDCONS register values used to generate the signals in Figure 18-21 are given in Table 18-4.\nThe PWM Duty Cycle registers may be used in conjunction with the OVDCOND and OVDCONS registers. The Duty Cycle registers control the average voltage across the load and the OVDCOND and OVDCONS registers control the commutation sequence. Figure 18-22 shows the waveforms, while Table 18-4 and Table 18-5 show the OVDCOND and OVDCONS register values used to generate the signals.",
    "REGISTER 18-6: OVDCOND: OUTPUT OVERRIDE CONTROL REGISTER\nPOVD7 (1), R/W-1 = POVD6 (1). POVD7 (1), R/W-1 = POVD5. POVD7 (1), R/W-1 = POVD4. POVD7 (1), R/W-1 = POVD3. POVD7 (1), R/W-1 = POVD2. POVD7 (1), R/W-1 = POVD1. POVD7 (1), R/W-1 = POVD0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0",
    "REGISTER 18-6: OVDCOND: OUTPUT OVERRIDE CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 POVD<7:0>: PWM Output Override bits\n1 = Output on PWM I/O pin is controlled by the value in the Duty Cycle register and the PWM time base\n0 = Output on PWM I/O pin is controlled by the value in the corresponding POUT bit\nNote 1: Unimplemented in PIC18F2331/2431 devices; maintain these bits clear.",
    "REGISTER 18-7: OVDCONS: OUTPUT STATE REGISTER (1,2)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. POUT7 (1), 1 = POUT6 (1). POUT7 (1), 2 = POUT5. POUT7 (1), 3 = POUT4. POUT7 (1), 4 = POUT3. POUT7 (1), 5 = POUT2. POUT7 (1), 6 = POUT1. POUT7 (1), 7 = POUT0. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit",
    "REGISTER 18-7: OVDCONS: OUTPUT STATE REGISTER (1,2)\n0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 POUT<7:0>: PWM Manual Output bits\n1 = Output on PWM I/O pin is active when the corresponding PWM output override bit is cleared\n0 = Output on PWM I/O pin is inactive when the corresponding PWM output override bit is cleared\nNote 1: Unimplemented in PIC18F2331/2431 devices; maintain these bits clear.\n2: With PWMs configured in Complementary mode, the output of even numbered PWM (PM0,2,4) will be complementary of the output of odd PWM (PWM1,3,5), irrespective of the POUT bit setting.",
    "FIGURE 18-21: PWM OUTPUT OVERRIDE EXAMPLE #1\nFIGURE 18-22:\nPWM OUTPUT OVERRIDE EXAMPLE #2\nTABLE 18-4: PWM OUTPUT OVERRIDE EXAMPLE #1\n1, OVDCOND (POVD) = 00000000b. 1, OVDCONS (POUT) = 00100100b. 2, OVDCOND (POVD) = 00000000b. 2, OVDCONS (POUT) = 00100001b. 3, OVDCOND (POVD) = 00000000b. 3, OVDCONS (POUT) = 00001001b. 4, OVDCOND (POVD) = 00000000b. 4, OVDCONS (POUT) = 00011000b. 5, OVDCOND (POVD) = 00000000b. 5, OVDCONS (POUT) = 00010010b. 6, OVDCOND (POVD) = 00000000b. 6, OVDCONS (POUT) = 00000110b",
    "PWM OUTPUT OVERRIDE EXAMPLE #2\n1, OVDCOND (POVD) = 11000011b. 1, OVDCONS (POUT) = 00000000b. 2, OVDCOND (POVD) = 11110000b. 2, OVDCONS (POUT) = 00000000b. 3, OVDCOND (POVD) = 00111100b. 3, OVDCONS (POUT) = 00000000b. 4, OVDCOND (POVD) = 00001111b. 4, OVDCONS (POUT) = 00000000b",
    "18.11.2 OUTPUT POLARITY CONTROL\nThere are three device Configuration bits associated with  the  PWM  module  that  provide  PWM  output  pin control defined in the CONFIG3L Configuration register. They are:\n\u00b7 HPOL\n\u00b7 LPOL\n\u00b7 PWMPIN\nThese three Configuration bits work in conjunction with the  three  PWM  Enable  bits  (PWMEN<2:0>)  in  the PWMCON0 register. The Configuration bits and PWM enable bits ensure that the PWM pins are in the correct states after a device Reset occurs.",
    "18.11.1 OUTPUT PIN CONTROL\nThe  PWMEN<2:0>  control  bits  enable  each  PWM output pin as required in the application.\nAll PWM I/O pins are general purpose I/O. When a pair of  pins  are  enabled  for  PWM  output,  the  PORT  and TRIS registers controlling the pins are disabled. Refer to Figure 18-23 for details.\nThe polarity of the PWM I/O pins is set during device programming via the HPOL and LPOL Configuration bits in the  CONFIG3L  Configuration  register.  The HPOL Configuration bit sets the output polarity for the high  side  PWM  outputs:  PWM1,  PWM3,  PWM5  and PWM7.  The  polarity  is  active-low  when  HPOL  is cleared (= 0 ), and active-high when it is set (= 1 ).\nThe LPOL Configuration bit sets the output polarity for the low side PWM outputs: PWM0, PWM2, PWM4 and PWM6. As with HPOL, they are active-low when LPOL is cleared and active-high when it is set.",
    "18.11.1 OUTPUT PIN CONTROL\nAll output signals generated by the PWM module are referenced to the polarity control bits, including those generated  by  Fault  inputs  or  manual  override  (see Section 18.10 'PWM Output Override' ).\nThe default polarity Configuration bits have the PWM I/O pins in active-high output polarity.",
    "18.12.1 FAULT PIN ENABLE BITS\nThe PWMPIN Configuration bit determines the PWM output pins to be PWM output pins or digital I/O pins, after the device comes out of Reset. If the PWMPIN Configuration bit is unprogrammed (default), the PWMEN<2:0> control bits will be cleared on a device Reset. Consequently, all PWM outputs will be tri-stated and controlled by the corresponding PORT and TRIS registers.  If  the  PWMPIN  Configuration  bit  is  programmed  low,  the  PWMEN<2:0>  control  bits  will  be set, as follows, on a device Reset:\n\u00b7 PWMEN<2:0> = 101 if device has 8 PWM pins (PIC18F4331/4431 devices)\n\u00b7 PWMEN<2:0> = 100 if device has 6 PWM pins (PIC18F2331/2431 devices)\nAll PWM pins will be enabled for PWM output and will have  the  output  polarity  defined  by  the  HPOL  and LPOL Configuration bits.",
    "18.12 PWM Fault Inputs\nThere are two Fault inputs associated with the PWM module. The main purpose of the input Fault pins is to disable the PWM output signals and drive them into an inactive state. The  action of the Fault inputs is performed  directly  in  hardware  so  that  when  a  Fault occurs,  it  can  be  managed  quickly  and  the  PWM outputs are put into an inactive state to save the power devices connected to the PWMs.\nThe PWM Fault inputs are FLTA and FLTB, which can come from I/O pins, the CPU or another module. The FLTA and FLTB pins are active-low inputs so it is easy to 'OR' many sources to the same input. FLTB and its associated logic are not implemented on PIC18F2331/2431 devices.\nThe FLTCONFIG register (Register 18-8) defines the settings of FLTA and FLTB inputs.\nNote:\nThe  inactive  state  of  the  PWM  pins  are dependent on the HPOL and LPOL Configuration  bit  settings,  which  define  the active and inactive state for PWM outputs.",
    "18.12 PWM Fault Inputs\nBy  setting  the  bits, FLTAEN  and  FLTBEN  in  the FLTCONFIG register,  the  corresponding  Fault  inputs are  enabled.  If  both  bits  are  cleared,  then  the  Fault inputs have no effect on the PWM module.",
    "18.12.2 MFAULT INPUT MODES\nThe FLTAMOD and FLTBMOD bits in the FLTCONFIG register determine the modes of PWM I/O pins that are deactivated when they are overridden by Fault input.\nThe FLTAS and FLTBS bits in the FLTCONFIG register give the status of Fault A and Fault B inputs.\nEach of the Fault inputs have two modes of operation:",
    "\u00b7 Inactive Mode (FLTxMOD = 0 )\nThis is a Catastrophic Fault Management mode. When the Fault occurs in this mode, the PWM outputs are deactivated. The PWM pins will remain in Inactivate  mode  until  the  Fault  is  cleared  (Fault input is driven high) and the corresponding Fault Status bit has been cleared in software. The PWM outputs are enabled immediately at the beginning of the following PWM period, after the Fault Status bit (FLTxS) is cleared.",
    "\u00b7 Cycle-by-Cycle Mode (FLTxMOD = 1 )\nWhen  the  Fault  occurs  in  this  mode,  the  PWM outputs  are  deactivated.  The  PWM  outputs  will remain  in  the  defined  Fault  states  (all  PWM outputs inactive) for as long as the Fault pin is held low.  After  the  Fault  pin  is  driven  high,  the  PWM outputs will return to normal operation at the beginning of the following PWM period and the FLTxS bit is automatically cleared.",
    "18.12.4 PWM OUTPUTS IN DEBUG MODE\nWhile  in  the  Fault  state  (i.e.,  one  or  both  FLTA  and FLTB inputs are active), the PWM output signals are driven into their inactive states. The selection of which PWM outputs are deactivated (while in the Fault state) is determined by the FLTCON bit in the FLTCONFIG register as follows:\n\u00b7 FLTCON = 1 : When FLTA or FLTB is asserted, the PWM outputs (i.e., PWM<7:0>) are driven into their inactive state.\n\u00b7 FLTCON = 0 : When FLTA or FLTB is asserted, only PWM<5:0> outputs are driven inactive, leaving PWM<7:6> activated.",
    "Note:\nDisabling only three PWM channels and leaving one PWM channel enabled when in  the  Fault  state,  allows  the flexibility  to have at least one PWM channel enabled. None of the PWM outputs can be enabled (driven with the PWM Duty Cycle registers) while FLTCON = 1 and the Fault condition is present.\nThe BRFEN bit in the FLTCONFIG register controls the simulation of a Fault condition, when a breakpoint is hit, while  debugging  the  application  using  an  In-Circuit Emulator (ICE) or an In-Circuit Debugger (ICD). Setting the  BRFEN  to  high,  enables  the  Fault  condition  on breakpoint, thus driving the PWM outputs to the inactive state. This is done to avoid any continuous keeping of status on the PWM pin, which may result in damage of the power devices connected to the PWM outputs.\nIf  BRFEN  = 0 ,  the  Fault  condition  on  breakpoint  is disabled.",
    "Note:\nIt  is  highly  recommended  to  enable  the Fault condition on breakpoint if a debugging  tool  is  used  while  developing  the firmware and high-power circuitry. When the device  is ready  to program  after debugging  the  firmware,  the  BRFEN  bit can be disabled.",
    "REGISTER 18-8: FLTCONFIG: FAULT CONFIGURATION REGISTER\nBRFEN, R/W-0 = FLTBS (1). BRFEN, R/W-0 = FLTBMOD (1). BRFEN, R/W-0 = FLTBEN (1). BRFEN, R/W-0 = FLTCON (2). BRFEN, R/W-0 = FLTAS. BRFEN, R/W-0 = FLTAMOD. BRFEN, R/W-0 = FLTAEN. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 18-8: FLTCONFIG: FAULT CONFIGURATION REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 BRFEN: Breakpoint Fault Enable bit\n1 = Enable Fault condition on a breakpoint (i.e., only when PWMPIN = 1 )\n0 = Disable Fault condition",
    "bit 6 FLTBS: Fault B Status bit (1)\n- 1 = FLTB is asserted:\nif FLTBMOD = 0 , cleared by the user;\nif FLTBMOD = 1 , cleared automatically at beginning of the new period when FLTB is deasserted\n- 0 = No Fault",
    "bit 5 FLTBMOD: Fault B Mode bit (1)\n1 =  Cycle-by-Cycle mode: Pins are inactive for the remainder of the current PWM period or until FLTB is deasserted; FLTBS is cleared automatically when FLTB is inactive (no Fault present)\n0 = Inactive mode: Pins are deactivated (catastrophic failure) until FLTB is deasserted and FLTBS is cleared by the user only",
    "bit 4 FLTBEN: Fault B Enable bit (1)\n- 1 = Enable Fault B\n0 = Disable Fault B",
    "bit 3 FLTCON: Fault Configuration bit (2)\n1 = FLTA, FLTB or both deactivates all PWM outputs\n0 = FLTA or FLTB deactivates PWM<5:0>",
    "bit 2 FLTAS: Fault A Status bit\n- 1 = FLTA is asserted:\nif FLTAMOD = 0 , cleared by the user;\nif FLTAMOD = 1 , cleared automatically at beginning of the new period when FLTA is deasserted\n- 0 = No Fault",
    "bit 1 FLTAMOD: Fault A Mode bit\n1 =  Cycle-by-Cycle mode: Pins are inactive for the remainder of the current PWM period or until FLTA is deasserted; FLTAS is cleared automatically\n0 = Inactive mode: Pins are deactivated (catastrophic failure) until FLTA is deasserted and FLTAS is cleared by the user only",
    "bit 0 FLTAEN: Fault A Enable bit\n1 = Enable Fault A\n0 = Disable Fault A",
    "Note 1: Unimplemented in PIC18F2331/2431 devices; maintain these bits clear.\n- 2: PWM<7:6> are implemented only on PIC18F4331/4431 devices. On PIC18F2331/2431 devices, setting or clearing FLTCON has no effect.",
    "18.13 PWM Update Lockout\nFor a complex PWM application, the user may need to write up to four Duty Cycle registers and the PWM Time Base Period register, PTPER, at a given time. In some applications, it is important that all buffer registers be written before the new duty cycle and period values are loaded for use by the module.\nThe  PTMR  value  for  which  a  Special  Event  Trigger should occur is loaded into the SEVTCMP register pair. The SEVTDIR bit in the PWMCON1 register specifies the counting phase when the PWM time base is in a Continuous Up/Down Count mode.\nA  PWM  update  lockout  feature  may  optionally  be enabled so the user may specify when new duty cycle buffer  values  are  valid.  The  PWM  update  lockout feature is enabled by setting the control bit, UDIS, in the PWMCON1 register. This bit affects all Duty Cycle Buffer  registers  and  the  PWM  Time  Base  Period register, PTPER.\nTo perform a PWM update lockout:",
    "18.13 PWM Update Lockout\n1. Set the UDIS bit.\n2. Write  all  Duty  Cycle  registers  and  PTPER,  if applicable.\n3. Clear the UDIS bit to re-enable updates.\n4. With this, when UDIS bit is cleared, the buffer values will be loaded to the actual registers. This makes a synchronous loading of the registers.",
    "18.14 PWM Special Event Trigger\nThe PWM module has a Special Event Trigger capability that allows A/D conversions to be synchronized to the PWM time base. The A/D sampling and conversion time may be programmed to occur at any point within the PWM period. The Special Event Trigger allows the user to minimize the delay between the time when A/D conversion results are acquired and the time when the duty cycle value is updated.\nThe PWM  16-bit Special Event Trigger register, SEVTCMP (high and low), and five control bits in the PWMCON1 register are used to control its operation.\nIf the SEVTDIR bit is cleared, the Special Event Trigger will  occur on the upward counting cycle of the PWM time base. If SEVTDIR is set, the Special Event Trigger will  occur  on  the  downward  count cycle of  the PWM time base. The SEVTDIR bit has effect only when the PWM timer is in the Continuous Up/Down Count mode.",
    "18.14.1 SPECIAL EVENT TRIGGER ENABLE\nThe PWM module will always produce Special Event Trigger pulses. This signal may optionally be used by the A/D module. Refer to Section 21.0 '10-Bit High-Speed Analog-to-Digital Converter (A/D) Module' for details.",
    "18.14.2 SPECIAL EVENT TRIGGER POSTSCALER\nThe PWM Special Event Trigger has a postscaler that allows a 1:1 to 1:16 postscale ratio. The postscaler is configured by writing the SEVOPS<3:0> control bits in the PWMCON1 register.\nThe Special Event Trigger output postscaler is cleared on any write to the SEVTCMP register pair, or on any device Reset.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. IPR3, Bit 7 = -. IPR3, Bit 6 = -. IPR3, Bit 5 = -. IPR3, Bit 4 = PTIP. IPR3, Bit 3 = IC3DRIP. IPR3, Bit 2 = IC2QEIP. IPR3, Bit 1 = IC1IP. IPR3, Bit 0 = TMR5IP. IPR3, Reset Values on Page: = 56. PIE3, Bit 7 = -. PIE3, Bit 6 = -. PIE3, Bit 5 = -. PIE3, Bit 4 = PTIE. PIE3, Bit 3 = IC3DRIE. PIE3, Bit",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\n2 = IC2QEIE. PIE3, Bit 1 = IC1IE. PIE3, Bit 0 = TMR5IE. PIE3, Reset Values on Page: = 56. PIR3, Bit 7 = -. PIR3, Bit 6 = -. PIR3, Bit 5 = -. PIR3, Bit 4 = PTIF. PIR3, Bit 3 = IC3DRIF. PIR3, Bit 2 = IC2QEIF. PIR3, Bit 1 = IC1IF. PIR3, Bit 0 = TMR5IF. PIR3, Reset Values on Page: = 56. PTCON0, Bit 7 = PTOPS3. PTCON0, Bit 6 = PTOPS2. PTCON0, Bit 5 = PTOPS1. PTCON0, Bit 4 = PTOPS0. PTCON0, Bit 3 = PTCKPS1. PTCON0, Bit 2 = PTCKPS0. PTCON0, Bit 1 = PTMOD1. PTCON0, Bit 0 = PTMOD0. PTCON0, Reset Values on Page: =",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\n58. PTCON1, Bit 7 = PTEN. PTCON1, Bit 6 = PTDIR. PTCON1, Bit 5 = -. PTCON1, Bit 4 = -. PTCON1, Bit 3 = -. PTCON1, Bit 2 = -. PTCON1, Bit 1 = -. PTCON1, Bit 0 = -. PTCON1, Reset Values on Page: = 58. PTMRL (1), Bit 7 = PWMTime Base Register (lower 8 bits). PTMRL (1), Bit 6 = PWMTime Base Register (lower 8 bits). PTMRL (1), Bit 5 = PWMTime Base Register (lower 8 bits). PTMRL (1), Bit 4 = PWMTime Base Register (lower 8 bits). PTMRL (1), Bit 3 = PWMTime Base Register (lower 8 bits). PTMRL (1), Bit 2 = PWMTime Base Register (lower 8 bits). PTMRL (1), Bit 1 = PWMTime Base Register (lower 8",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\nbits). PTMRL (1), Bit 0 = PWMTime Base Register (lower 8 bits). PTMRL (1), Reset Values on Page: = 58. PTMRH (1), Bit 7 = UNUSED. PTMRH (1), Bit 6 = UNUSED. PTMRH (1), Bit 5 = UNUSED. PTMRH (1), Bit 4 = UNUSED. PTMRH (1), Bit 3 = PWMTime Base Register (upper 4 bits). PTMRH (1), Bit 2 = PWMTime Base Register (upper 4 bits). PTMRH (1), Bit 1 = PWMTime Base Register (upper 4 bits). PTMRH (1), Bit 0 = PWMTime Base Register (upper 4 bits). PTMRH (1), Reset Values on Page: = 58. PTPERL (1), Bit 7 = PWMTime Base Period Register (lower 8 bits). PTPERL (1), Bit 6 = PWMTime Base Period Register (lower 8 bits). PTPERL",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\n(1), Bit 5 = PWMTime Base Period Register (lower 8 bits). PTPERL (1), Bit 4 = PWMTime Base Period Register (lower 8 bits). PTPERL (1), Bit 3 = PWMTime Base Period Register (lower 8 bits). PTPERL (1), Bit 2 = PWMTime Base Period Register (lower 8 bits). PTPERL (1), Bit 1 = PWMTime Base Period Register (lower 8 bits). PTPERL (1), Bit 0 = PWMTime Base Period Register (lower 8 bits). PTPERL (1), Reset Values on Page: = 58. PTPERH (1), Bit 7 = UNUSED. PTPERH (1), Bit 6 = UNUSED. PTPERH (1), Bit 5 = UNUSED. PTPERH (1), Bit 4 = UNUSED. PTPERH (1), Bit 3 = PWMTime Base Period Register (upper 4 bits). PTPERH (1), Bit 2 = PWMTime Base Period Register (upper 4",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\nbits). PTPERH (1), Bit 1 = PWMTime Base Period Register (upper 4 bits). PTPERH (1), Bit 0 = PWMTime Base Period Register (upper 4 bits). PTPERH (1), Reset Values on Page: = 58. SEVTCMPL (1), Bit 7 = PWMSpecial Event Compare Register (lower 8 bits). SEVTCMPL (1), Bit 6 = PWMSpecial Event Compare Register (lower 8 bits). SEVTCMPL (1), Bit 5 = PWMSpecial Event Compare Register (lower 8 bits). SEVTCMPL (1), Bit 4 = PWMSpecial Event Compare Register (lower 8 bits). SEVTCMPL (1), Bit 3 = PWMSpecial Event Compare Register (lower 8 bits). SEVTCMPL (1), Bit 2 = PWMSpecial Event Compare Register (lower 8 bits). SEVTCMPL (1), Bit 1 = PWMSpecial Event Compare Register",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\n(lower 8 bits). SEVTCMPL (1), Bit 0 = PWMSpecial Event Compare Register (lower 8 bits). SEVTCMPL (1), Reset Values on Page: = 58. SEVTCMPH (1), Bit 7 = UNUSED. SEVTCMPH (1), Bit 6 = UNUSED. SEVTCMPH (1), Bit 5 = UNUSED. SEVTCMPH (1), Bit 4 = UNUSED. SEVTCMPH (1), Bit 3 = PWMSpecial Event Compare Register (upper 4 bits). SEVTCMPH (1), Bit 2 = PWMSpecial Event Compare Register (upper 4 bits). SEVTCMPH (1), Bit 1 = PWMSpecial Event Compare Register (upper 4 bits). SEVTCMPH (1), Bit 0 = PWMSpecial Event Compare Register (upper 4 bits). SEVTCMPH (1), Reset Values on Page: = 58. PWMCON0, Bit 7 = -.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\nPWMCON0, Bit 6 = PWMEN2. PWMCON0, Bit 5 = PWMEN1. PWMCON0, Bit 4 = PWMEN0. PWMCON0, Bit 3 = PMOD3 (2). PWMCON0, Bit 2 = PMOD2. PWMCON0, Bit 1 = PMOD1. PWMCON0, Bit 0 = PMOD0. PWMCON0, Reset Values on Page: = 58. PWMCON1, Bit 7 = SEVOPS3. PWMCON1, Bit 6 = SEVOPS2. PWMCON1, Bit 5 = SEVOPS1. PWMCON1, Bit 4 = SEVOPS0. PWMCON1, Bit 3 = SEVTDIR. PWMCON1, Bit 2 = -. PWMCON1, Bit 1 = UDIS. PWMCON1, Bit 0 = OSYNC. PWMCON1, Reset Values on Page: = 58. DTCON, Bit 7 =",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\nDTPS1. DTCON, Bit 6 = DTPS0. DTCON, Bit 5 = DT5. DTCON, Bit 4 = DT4. DTCON, Bit 3 = DT3. DTCON, Bit 2 = DT2. DTCON, Bit 1 = DT1. DTCON, Bit 0 = DT0. DTCON, Reset Values on Page: = 58. FLTCONFIG, Bit 7 = BRFEN. FLTCONFIG, Bit 6 = FLTBS (2). FLTCONFIG, Bit 5 = FLTBMOD (2). FLTCONFIG, Bit 4 = FLTBEN (2). FLTCONFIG, Bit 3 = FLTCON. FLTCONFIG, Bit 2 = FLTAS. FLTCONFIG, Bit 1 = FLTAMOD. FLTCONFIG, Bit 0 = FLTAEN. FLTCONFIG, Reset Values on Page: = 58. OVDCOND, Bit 7 = POVD7 (2). OVDCOND, Bit 6 = POVD6 (2). OVDCOND, Bit",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\n5 = POVD5. OVDCOND, Bit 4 = POVD4. OVDCOND, Bit 3 = POVD3. OVDCOND, Bit 2 = POVD2. OVDCOND, Bit 1 = POVD1. OVDCOND, Bit 0 = POVD0. OVDCOND, Reset Values on Page: = 58. OVDCONS, Bit 7 = POUT7 (2). OVDCONS, Bit 6 = POUT6 (2). OVDCONS, Bit 5 = POUT5. OVDCONS, Bit 4 = POUT4. OVDCONS, Bit 3 = POUT3. OVDCONS, Bit 2 = POUT2. OVDCONS, Bit 1 = POUT1. OVDCONS, Bit 0 = POUT0. OVDCONS, Reset Values on Page: = 58. PDC0L (1), Bit 7 = PWMDuty Cycle #0L Register (lower 8 bits). PDC0L (1), Bit 6 = PWMDuty Cycle #0L",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\nRegister (lower 8 bits). PDC0L (1), Bit 5 = PWMDuty Cycle #0L Register (lower 8 bits). PDC0L (1), Bit 4 = PWMDuty Cycle #0L Register (lower 8 bits). PDC0L (1), Bit 3 = PWMDuty Cycle #0L Register (lower 8 bits). PDC0L (1), Bit 2 = PWMDuty Cycle #0L Register (lower 8 bits). PDC0L (1), Bit 1 = PWMDuty Cycle #0L Register (lower 8 bits). PDC0L (1), Bit 0 = PWMDuty Cycle #0L Register (lower 8 bits). PDC0L (1), Reset Values on Page: = 58. PDC0H (1), Bit 7 = UNUSED. PDC0H (1), Bit 6 = UNUSED. PDC0H (1), Bit 5 = PWMDuty Cycle #0H Register (upper 6 bits).",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\nPDC0H (1), Bit 4 = PWMDuty Cycle #0H Register (upper 6 bits). PDC0H (1), Bit 3 = PWMDuty Cycle #0H Register (upper 6 bits). PDC0H (1), Bit 2 = PWMDuty Cycle #0H Register (upper 6 bits). PDC0H (1), Bit 1 = PWMDuty Cycle #0H Register (upper 6 bits). PDC0H (1), Bit 0 = PWMDuty Cycle #0H Register (upper 6 bits). PDC0H (1), Reset Values on Page: = 58. PDC1L (1), Bit 7 = PWMDuty Cycle #1L register (lower 8 bits). PDC1L (1), Bit 6 = PWMDuty Cycle #1L register (lower 8 bits). PDC1L (1), Bit 5 = PWMDuty Cycle #1L register (lower 8 bits). PDC1L (1), Bit",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\n4 = PWMDuty Cycle #1L register (lower 8 bits). PDC1L (1), Bit 3 = PWMDuty Cycle #1L register (lower 8 bits). PDC1L (1), Bit 2 = PWMDuty Cycle #1L register (lower 8 bits). PDC1L (1), Bit 1 = PWMDuty Cycle #1L register (lower 8 bits). PDC1L (1), Bit 0 = PWMDuty Cycle #1L register (lower 8 bits). PDC1L (1), Reset Values on Page: = 58. PDC1H (1), Bit 7 = UNUSED. PDC1H (1), Bit 6 = UNUSED. PDC1H (1), Bit 5 = PWMDuty Cycle #1H Register (upper 6 bits). PDC1H (1), Bit 4 = PWMDuty Cycle #1H Register (upper 6 bits). PDC1H (1), Bit 3 = PWMDuty Cycle",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\n#1H Register (upper 6 bits). PDC1H (1), Bit 2 = PWMDuty Cycle #1H Register (upper 6 bits). PDC1H (1), Bit 1 = PWMDuty Cycle #1H Register (upper 6 bits). PDC1H (1), Bit 0 = PWMDuty Cycle #1H Register (upper 6 bits). PDC1H (1), Reset Values on Page: = 58. PDC2L (1), Bit 7 = PWMDuty Cycle #2L Register (lower 8 bits). PDC2L (1), Bit 6 = PWMDuty Cycle #2L Register (lower 8 bits). PDC2L (1), Bit 5 = PWMDuty Cycle #2L Register (lower 8 bits). PDC2L (1), Bit 4 = PWMDuty Cycle #2L Register (lower 8 bits). PDC2L (1), Bit 3 = PWMDuty Cycle #2L Register (lower 8",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\nbits). PDC2L (1), Bit 2 = PWMDuty Cycle #2L Register (lower 8 bits). PDC2L (1), Bit 1 = PWMDuty Cycle #2L Register (lower 8 bits). PDC2L (1), Bit 0 = PWMDuty Cycle #2L Register (lower 8 bits). PDC2L (1), Reset Values on Page: = 58. PDC2H (1), Bit 7 = UNUSED. PDC2H (1), Bit 6 = UNUSED. PDC2H (1), Bit 5 = PWMDuty Cycle #2H Register (upper 6 bits). PDC2H (1), Bit 4 = PWMDuty Cycle #2H Register (upper 6 bits). PDC2H (1), Bit 3 = PWMDuty Cycle #2H Register (upper 6 bits). PDC2H (1), Bit 2 = PWMDuty Cycle #2H Register (upper 6 bits). PDC2H",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\n(1), Bit 1 = PWMDuty Cycle #2H Register (upper 6 bits). PDC2H (1), Bit 0 = PWMDuty Cycle #2H Register (upper 6 bits). PDC2H (1), Reset Values on Page: = 58. PDC3L (1,2), Bit 7 = PWMDuty Cycle #3L Register (lower 8 bits). PDC3L (1,2), Bit 6 = PWMDuty Cycle #3L Register (lower 8 bits). PDC3L (1,2), Bit 5 = PWMDuty Cycle #3L Register (lower 8 bits). PDC3L (1,2), Bit 4 = PWMDuty Cycle #3L Register (lower 8 bits). PDC3L (1,2), Bit 3 = PWMDuty Cycle #3L Register (lower 8 bits). PDC3L (1,2), Bit 2 = PWMDuty Cycle #3L Register (lower 8 bits).",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\nPDC3L (1,2), Bit 1 = PWMDuty Cycle #3L Register (lower 8 bits). PDC3L (1,2), Bit 0 = PWMDuty Cycle #3L Register (lower 8 bits). PDC3L (1,2), Reset Values on Page: = 58. PDC3H (1,2), Bit 7 = UNUSED. PDC3H (1,2), Bit 6 = UNUSED. PDC3H (1,2), Bit 5 = PWMDuty Cycle #3H Register (upper 6 bits). PDC3H (1,2), Bit 4 = PWMDuty Cycle #3H Register (upper 6 bits). PDC3H (1,2), Bit 3 = PWMDuty Cycle #3H Register (upper 6 bits). PDC3H (1,2), Bit 2 = PWMDuty Cycle #3H Register (upper 6 bits). PDC3H (1,2), Bit 1 = PWMDuty Cycle",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH THE POWER CONTROL PWM MODULE\n#3H Register (upper 6 bits). PDC3H (1,2), Bit 0 = PWMDuty Cycle #3H Register (upper 6 bits). PDC3H (1,2), Reset Values on Page: = 58\nLegend:\n- = Unimplemented, read as ' 0 '. Shaded cells are not used with the power control PWM.\nNote\n1: Double-buffered register pairs. Refer to text for explanation of how these registers are read and written to.\n2: Unimplemented in PIC18F2331/2431 devices; maintain these bits clear. Reset values shown are for PIC18F4331/4431 devices.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "19.1 SSP Module Overview\nThe Synchronous Serial Port (SSP) module is a serial interface  useful  for  communicating with other peripheral or microcontroller devices. These peripheral devices  may  be  serial  EEPROMs,  shift  registers, display drivers, A/D Converters, etc. The SSP module can operate in one of two modes:\n\u00b7 Serial Peripheral Interface (SPI)\n\u00b7 Inter-Integrated Circuit (I C\u2122) 2\nAn overview of I 2 C operations and additional information  on  the  SSP  module  can  be  found  in  the 'PIC \u00ae   Mid-Range  MCU  Family  Reference  Manual' (DS33023).\nRefer  to  application  note AN578,  'Use  of  the  SSP Module in the I 2 C \u2122 Multi-Master Environment' (DS00578).\nThis  section  contains  register  definitions  and  operational  characteristics  of  the  SPI  module.  Additional information  on  the  SPI  module  can  be  found  in  the 'PIC \u00ae   Mid-Range  MCU  Family  Reference  Manual' (DS33023).\nSPI  mode  allows  8  bits  of  data  to  be  synchronously transmitted and received simultaneously. To accomplish communication, typically three pins are used:",
    "19.1 SSP Module Overview\n\u00b7 Serial Data Out (SDO)\n\u00b7 Serial Data In (SDI)\n\u00b7 Serial Clock (SCK)\nAdditionally, a fourth pin may be used when in a Slave mode of operation:\n- \u00b7 Slave Select (SS)\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control  bits  in the  SSPCON  (SSPCON<5:0>)  and SSPSTAT<7:6> registers. These control bits allow the following to be specified:\n\u00b7 Master mode (SCK is the clock output)\n\u00b7 Slave mode (SCK is the clock input)\n\u00b7 Clock polarity (Idle state of SCK)\n\u00b7 Clock edge (output data on rising/falling edge of SCK)\n\u00b7 Clock rate (Master mode only)\n\u00b7 Slave Select mode (Slave mode only)",
    "REGISTER 19-1: SSPSTAT: SYNCHRONOUS SERIAL PORT STATUS REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P. SMP, 4 = S. SMP, 5 = R/W. SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "REGISTER 19-1: SSPSTAT: SYNCHRONOUS SERIAL PORT STATUS REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7\nSMP: Sample bit\nSPI Master mode:\n1 = Input data sampled at end of data output time\n0 = Input data sampled at middle of data output time\nSPI Slave mode:\nSMP must be cleared when SPI is used in Slave mode.\nCKE : SPI Clock Edge Select bit (Figure 19-2, Figure 19-3 and Figure 19-4)\nSPI mode, CKP = 0 :\n1 = Data transmitted on rising edge of SCK\n0 = Data transmitted on falling edge of SCK",
    "SPI mode, CKP = 1 :\n1 = Data transmitted on falling edge of SCK\n0 = Data transmitted on rising edge of SCK",
    "I  C\u2122 mode: 2\nThis bit must be maintained clear.\nbit 5 D/A : Data/Address bit (I 2 C mode only)\n1 = Indicates that the last byte received or transmitted was data\n0 = Indicates that the last byte received or transmitted was address",
    "bit 4 P : Stop bit (I 2 C mode only)\nThis bit is cleared when the SSP module is disabled or when the Start bit is detected last; SSPEN is cleared.\n1 = Indicates that a Stop bit has been detected last (this bit is ' 0 ' on Reset)\n0 = Stop bit was not detected last\nS\n: Start bit (I\n2 C mode only)\nThis bit is cleared when the SSP module is disabled or when the Stop bit is detected last; SSPEN is cleared.\n1 = Indicates that a Start bit has been detected last (this bit is ' 0 ' on Reset)\n0 = Start bit was not detected last",
    "bit 2 R/W : Read/Write Information bit (I 2 C mode only)\nThis bit holds the R/W bit information following the last address match. This bit is only valid from the address match to the next Start bit, Stop bit or ACK bit.\n1 = Read\n0 = Write",
    "bit 1 UA : Update Address bit (10-Bit I 2 C mode only)\n1 = Indicates that the user needs to update the address in the SSPADD register\n0 = Address does not need to be updated",
    "bit 0 BF : Buffer Full Status bit\nReceive (SPI and I 2 C modes):\n1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty\nTransmit (I  C mode only): 2\n1 = Transmit in progress, SSPBUF is full\n0 = Transmit complete, SSPBUF is empty\nbit 6\nbit 3\nbit 6\nbit 5",
    "REGISTER 19-2: SSPCON: SYNCHRONOUS SERIAL PORT CONTROL REGISTER\nWCOL, R/W-0 = SSPOV (1). WCOL, R/W-0 = SSPEN (2). WCOL, R/W-0 = CKP. WCOL, R/W-0 = SSPM3 (3). WCOL, R/W-0 = SSPM2 (3). WCOL, R/W-0 = SSPM1 (3). WCOL, R/W-0 = SSPM0 (3). bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 19-2: SSPCON: SYNCHRONOUS SERIAL PORT CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 WCOL: Write Collision Detect bit\n1 = The SSPBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision\nSSPOV\n: Receive Overflow Indicator bit\n(1)",
    "In SPI mode:\n1 = A new byte is received while the SSPBUF register is still holding the previous data. In case of overflow, the data in SSPSR is lost. Overflow can only occur in Slave mode. The user must read the SSPBUF, even if only transmitting data, to avoid setting overflow. In Master mode, the overflow bit is not set since each new reception (and transmission) is initiated by writing to the SSPBUF register.\n0 = No overflow",
    "In I   C\u2122 mode: 2\n1 = A byte is received while the SSPBUF register is still holding the previous byte. SSPOV is a 'don't care' in Transmit mode. SSPOV must be cleared in software in either mode.\n0 = No overflow\nSSPEN\n: Synchronous Serial Port Enable bit\n(2)\nIn SPI mode:\n1 = Enables serial port and configures SCK, SDO and SDI as serial port pins\n0 = Disables serial port and configures these pins as I/O port pins",
    "In I   C mode: 2\n1 = Enables the serial port and configures the SDA and SCL pins as serial port pins\n0 = Disables serial port and configures these pins as I/O port pins\nIn both modes, when enabled, these pins must be properly configured as input or output.",
    "In SPI mode:\n1 = Idle state for clock is a high level\n0 = Idle state for clock is a low level",
    "In I   C mode: 2\nSCK release control.\n1 = Enables clock\n0 = Holds clock low (clock stretch). (Used to ensure data setup time.)\nNote 1: In Master mode, the overflow bit is not set since each new reception (and transmission) is initiated by writing to the SSPBUF register.\n2: When enabled, these pins must be properly configured as inputs or outputs.\n3: Bit combinations not specifically listed here are either reserved or implemented in I 2 C\u2122 mode only.",
    "REGISTER 19-2: SSPCON: SYNCHRONOUS SERIAL PORT CONTROL REGISTER (CONTINUED)\nSSPM<3:0> : Synchronous Serial Port Mode Select bits (3)\nbit 3-0\n0000 = SPI Master mode, Clock = FOSC/4\n0001 = SPI Master mode, Clock = FOSC/16\n0010 = SPI Master mode, Clock = FOSC/64\n0011 = SPI Master mode, Clock = TMR2 output/2\n0100 = SPI Slave mode, Clock = SCK pin, SS pin control enabled\n0101 = SPI Slave mode, Clock = SCK pin, SS pin control disabled, SS can be used as I/O pin\n0110 = I 2 C Slave mode, 7-bit address\n0111 = I 2 C Slave mode, 10-bit address\n1011 = I 2 C Firmware Controlled Master mode (slave Idle)\n1110 = I 2 C Slave mode, 7-bit address with Start and Stop bit interrupts enabled\n1111 = I 2 C Slave mode, 10-bit address with Start and Stop bit interrupts enabled",
    "REGISTER 19-2: SSPCON: SYNCHRONOUS SERIAL PORT CONTROL REGISTER (CONTINUED)\nNote 1: In Master mode, the overflow bit is not set since each new reception (and transmission) is initiated by writing to the SSPBUF register.\n2: When enabled, these pins must be properly configured as inputs or outputs.\n3: Bit combinations not specifically listed here are either reserved or implemented in I 2 C\u2122 mode only.",
    "PIC18F2331/2431/4331/4431\nFIGURE 19-1:",
    "SSP BLOCK DIAGRAM (SPI MODE)\nTo  enable  the  serial  port,  SSP  Enable  bit,  SSPEN (SSPCON<5>), must be set. To reset or reconfigure SPI mode, clear bit SSPEN, reinitialize the SSPCON register and then set bit SSPEN. This configures the SDI, SDO, SCK and SS pins as serial port pins. For the pins to behave as the serial port function, they must have  their  data  direction  bits  (in  the  TRISC  register) appropriately programmed. That is:",
    "SSP BLOCK DIAGRAM (SPI MODE)\n\u00b7 Serial Data Out (SDO) - RC7/RX/DT/SDO or RD1/SDO\n\u00b7 SDI must have TRISC<4> or TRISD<2> set\n\u00b7 SDO must have TRISC<7> or TRISD<1> cleared\n\u00b7 SCK (Master mode) must have TRISC<5> or TRISD<3> cleared\n\u00b7 SCK (Slave mode) must have TRISC<5> or TRISD<3> set\n\u00b7 SS must have TRISA<6> set\nNote 1: When  the  SPI  is  in  Slave  mode,  with the SS pin control enabled, (SSPCON<3:0> = 0100 ), the SPI module will reset if the SS pin is set to VDD.\n2: If  the  SPI  is  used  in  Slave  mode  with CKE = 1 , then the SS pin control must be enabled.",
    "SSP BLOCK DIAGRAM (SPI MODE)\n3: When the SPI is in Slave mode with SS pin control enabled (SSPCON<3:0> = 0100 ), the state of the SS pin can affect the state read  back  from  the  TRISC<6>  bit.  The peripheral OE signal from the SSP module into PORTC controls the state that is read back from the TRISC<6> bit (see Section 11.3 'PORTC, TRISC and LATC Registers' for information on PORTC). If Read-Modify-Write  instructions,  such  as BSF , are performed on the TRISC register while the SS pin is high, this will cause the TRISC<6> bit to be set, thus disabling the SDO output.",
    "TABLE 19-1: REGISTERS ASSOCIATED WITH SPI OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, ResetValues on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, ResetValues on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE.",
    "TABLE 19-1: REGISTERS ASSOCIATED WITH SPI OPERATION\nPIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, ResetValues on Page: = 57. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, ResetValues on Page: = 57. SSPBUF, Bit 7 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = SSP",
    "TABLE 19-1: REGISTERS ASSOCIATED WITH SPI OPERATION\nReceive Buffer/Transmit Register. SSPBUF, Bit 1 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 0 = SSP Receive Buffer/Transmit Register. SSPBUF, ResetValues on Page: = 55. SSPCON, Bit 7 = WCOL. SSPCON, Bit 6 = SSPOV. SSPCON, Bit 5 = SSPEN. SSPCON, Bit 4 = CKP. SSPCON, Bit 3 = SSPM3. SSPCON, Bit 2 = SSPM2. SSPCON, Bit 1 = SSPM1. SSPCON, Bit 0 = SSPM0. SSPCON, ResetValues on Page: = 55. TRISA, Bit 7 = TRISA7 (1). TRISA, Bit 6 = TRISA6 (2). TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data",
    "TABLE 19-1: REGISTERS ASSOCIATED WITH SPI OPERATION\nDirection Register. TRISA, ResetValues on Page: = 57. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, ResetValues on Page: = 55\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used by the SSP in SPI mode.\nNote 1: RA7 and associated bits are configured as port pins in INTIO2 Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: RA6 and associated bits are configured as port pins in RCIO, ECIO and INTIO2 (with port function on RA6) Oscillator modes only and read ' 0 ' in all other oscillator modes.",
    "19.3 SSP I 2 C Operation\nThe SSP module, in I 2 C mode, fully implements all slave functions  except  general  call  support  and  provides interrupts on Start and Stop bits in hardware to facilitate firmware implementations of the master functions. The SSP module implements the standard mode specifications, as well as 7-bit and 10-bit addressing.\nTwo pins are used for data transfer. These are the SCK/ SCL pin, which is the clock (SCL), and the SDI/SDA pin, which is the data (SDA). The user must configure these pins as inputs or outputs through the TRISC<5:4> or TRISD<3:2> bits.\nThe SSP module functions are enabled by setting SSP Enable bit SSPEN (SSPCON<5>).",
    "SSP BLOCK DIAGRAM (I 2 C\u2122 MODE)\n- Note 1: When SSPMX = 1 in CONFIG3H: SCK/SCL is multiplexed to the RC5 pin, SDA/ SDI is multiplexed to the RC4 pin and SDO is multiplexed to pin, RC7.\nWhen SSPMX = 0 in CONFIG3H: SCK/SCL is multiplexed to the RD3 pin, SDA/ SDI is multiplexed to the RD2 pin and SDO is multiplexed to pin, RD1.\nThe SSP module has five registers for I 2 C operation. These are the:\n\u00b7 SSP Control Register (SSPCON)\n\u00b7 SSP Status Register (SSPSTAT)\n\u00b7 Serial Receive/Transmit Buffer (SSPBUF)\n\u00b7 SSP Shift Register (SSPSR) - Not directly accessible\n\u00b7 SSP Address Register (SSPADD)\nThe SSPCON register allows control of the I 2 C operation.  Four mode selection bits (SSPCON<3:0>) allow one of the following I 2 C modes to be selected:",
    "SSP BLOCK DIAGRAM (I 2 C\u2122 MODE)\n\u00b7 I 2 C Slave mode (7-bit address)\n\u00b7 I 2 C Slave mode (10-bit address)\n\u00b7 I 2 C Slave mode (7-bit address), with Start and Stop bit interrupts enabled to support Firmware Controlled Master mode\n\u00b7 I 2 C Slave mode (10-bit address), with Start and Stop bit interrupts enabled to support Firmware Controlled Master mode\n\u00b7 I 2 C Start and Stop bit interrupts enabled to support Firmware Controlled Master mode; Slave is Idle\nSelection  of  any  I 2 C  mode,  with  the  SSPEN  bit  set, forces  the  SCL  and  SDA  pins  to  be  open-drain, provided  these  pins  are  programmed  as  inputs  by setting the appropriate TRISC or TRISD bits. Pull-up resistors must be provided externally to the SCL and SDA pins for proper operation of the I 2 C module.\nAdditional  information  on  SSP  I 2 C  operation  can  be found in the 'PIC \u00ae  Mid-Range MCU Family Reference Manual' (DS33023).",
    "19.3.1 SLAVE MODE\nIn Slave mode, the SCL and SDA pins must be configured as inputs (TRISC<5:4> or TRISD<3:2> set). The SSP module will override the input state with the output data when required (slave-transmitter).\nWhen an address is matched, or the data transfer after an address match is received, the hardware automatically will generate the Acknowledge (ACK) pulse and then load the SSPBUF register with the received value currently in the SSPSR register.\nThere are certain conditions  that will  cause the  SSP module not to give this ACK pulse. They include (either or both):\na) The Buffer Full bit, BF (SSPSTAT<0>), was set before the transfer was received.\nb) The SSP Overflow bit, SSPOV (SSPCON<6>), was set before the transfer was received.",
    "19.3.1 SLAVE MODE\nIn  this  case,  the  SSPSR register value is not loaded into  the  SSPBUF,  but  bit,  SSPIF  (PIR1<3>),  is  set. Table 19-2 shows what happens when a data transfer byte  is  received,  given  the  status  of  bits  BF  and SSPOV. The shaded cells show the condition where user  software  did  not  properly  clear  the  overflow condition.  Flag  bit,  BF,  is  cleared  by  reading  the SSPBUF register, while bit, SSPOV, is cleared through software.\nThe SCL clock input must have a minimum high and low for proper operation. The high and low times of the I 2 C  specification,  as  well  as  the  requirements  of  the SSP module, are shown in timing Parameter 100 and Parameter 101.",
    "19.3.1.1 Addressing\nOnce the SSP module has been enabled, it waits for a Start condition to occur. Following the Start condition, the 8 bits are shifted into the SSPSR register. All incoming bits are sampled with the rising edge of the clock (SCL)  line.  The  value  of  register  SSPSR<7:1>  is compared to the value of the SSPADD register. The address is compared on the falling edge of the eighth clock (SCL) pulse. If the addresses match, and the BF and SSPOV bits are clear, the following events occur:\na) The  SSPSR  register  value  is  loaded  into  the SSPBUF register.\nb) The Buffer Full bit, BF, is set.\nc) An ACK pulse is generated.\nd) SSP Interrupt Flag bit, SSPIF (PIR1<3>), is set (interrupt is generated if enabled) on the falling edge of the ninth SCL pulse.\nThe sequence of events for 10-Bit Addressing mode is as follows, with Steps 7-9 for slave-transmitter:",
    "19.3.1.1 Addressing\n1. Receive first (high) byte of address (SSPIF, BF and UA bits are set).\n2. Update the SSPADD register with second (low) byte of address (clears bit, UA, and releases the SCL line).\n3. Read the SSPBUF register (clears bit, BF) and clear flag bit, SSPIF.\n4. Receive second (low) byte of address (SSPIF, BF and UA bits are set).\n5. Update the SSPADD register with the first (high) byte of address. If match releases SCL line, this will clear bit, UA.\n6. Read the SSPBUF register (clears bit, BF) and clear flag bit, SSPIF.\n7. Receive Repeated Start condition.",
    "19.3.1.1 Addressing\nIn 10-Bit Addressing mode, two address bytes need to be received by the slave (Figure 19-7). The five Most Significant bits (MSbs) of the first address byte specify if this is a 10-bit address. Bit R/W (SSPSTAT<2>) must specify  a  write  so  the  slave  device  will  receive  the second  address  byte.  For  a  10-bit  address,  the  first byte would equal ' 1111 0 A9 A8 0 ', where A9 and A8 are the two MSbs of the address.\n8. Receive first (high) byte of address (SSPIF and BF bits are set).\n9. Read the SSPBUF register (clears bit, BF) and clear flag bit, SSPIF.",
    "TABLE 19-2: DATA TRANSFER RECEIVED BYTE ACTIONS\n0, Status Bits as Data Transfer is Received.SSPOV = 0. 0, SSPSR \uf0ae SSPBUF.SSPSR \uf0ae SSPBUF = Yes. 0, Generate ACK Pulse.Generate ACK Pulse = Yes. 0, Set SSPIF Bit (SSP interrupt occurs if enabled).Set SSPIF Bit (SSP interrupt occurs if enabled) = Yes. 1, Status Bits as Data Transfer is Received.SSPOV = 0. 1, SSPSR \uf0ae SSPBUF.SSPSR \uf0ae SSPBUF = No. 1, Generate ACK Pulse.Generate ACK Pulse = No. 1, Set SSPIF Bit (SSP interrupt occurs if enabled).Set SSPIF Bit (SSP interrupt occurs if enabled) = Yes. 1, Status Bits as Data Transfer is Received.SSPOV = 1. 1, SSPSR \uf0ae SSPBUF.SSPSR \uf0ae SSPBUF = No. 1, Generate ACK Pulse.Generate ACK Pulse = No. 1, Set SSPIF Bit (SSP interrupt occurs if enabled).Set SSPIF Bit (SSP interrupt occurs if enabled) = Yes.",
    "TABLE 19-2: DATA TRANSFER RECEIVED BYTE ACTIONS\n0, Status Bits as Data Transfer is Received.SSPOV = 1. 0, SSPSR \uf0ae SSPBUF.SSPSR \uf0ae SSPBUF = No. 0, Generate ACK Pulse.Generate ACK Pulse = No. 0, Set SSPIF Bit (SSP interrupt occurs if enabled).Set SSPIF Bit (SSP interrupt occurs if enabled) = Yes\nNote: Shaded cells show the conditions where the user software did not properly clear the overflow condition.",
    "19.3.1.2 Reception\nWhen the R/W bit of the address byte is clear and an address  match  occurs,  the  R/W  bit  of  the  SSPSTAT register is cleared. The received address is loaded into the SSPBUF register.\nWhen the address byte overflow condition exists, then the no Acknowledge (ACK) pulse is given. An overflow condition is defined as either bit BF (SSPSTAT<0>) is set, or bit SSPOV (SSPCON<6>) is set. This is an error condition due to the user's firmware.\nAn SSP interrupt is generated for each data transfer byte.  Flag  bit,  SSPIF  (PIR1<3>),  must  be  cleared  in software. The SSPSTAT register is used to determine the status of the byte.",
    "19.3.1.3 Transmission\nWhen the R/W bit of the incoming address byte is set and  an  address  match  occurs,  the  R/W  bit  of  the SSPSTAT  register  is  set.  The  received  address  is loaded into the SSPBUF register. The ACK pulse will be sent on the ninth bit and pin, SCK/SCL, is held low. The transmit  data  must  be  loaded  into  the  SSPBUF register, which also loads the SSPSR register. Then, pin, SCK/SCL, should be enabled by setting bit, CKP (SSPCON<4>). The master must monitor the SCL pin prior to asserting  another  clock  pulse.  The  slave devices may be holding off the master by stretching the clock. The eight data bits are shifted out on the falling edge of the SCL input. This ensures that the SDA signal is valid during the SCL high time (Figure 19-7).\nAn SSP interrupt is generated for each data transfer byte. Flag bit, SSPIF, must be cleared in software and the SSPSTAT register is used to determine the status of the byte. Flag bit, SSPIF, is set on the falling edge of the ninth clock pulse.",
    "19.3.1.3 Transmission\nAs a slave-transmitter, the ACK pulse from the masterreceiver is latched on the rising edge of the ninth SCL input pulse. If the SDA line was high (not ACK), then the data transfer is complete. When the ACK is latched by the  slave,  the  slave  logic  is  reset  and  the  slave  then monitors  for  another  occurrence  of  the  Start  bit.  If  the SDA  line  was  low  (ACK),  the  transmit  data  must  be loaded into the SSPBUF register, which also loads the SSPSR register. Then pin, SCK/SCL, should be enabled by setting bit CKP .\nFIGURE 19-7: I",
    "19.3.3 MULTI-MASTER MODE\nMaster  mode  of  operation  is  supported  in  firmware using interrupt generation on the detection of the Start and Stop conditions. The Stop (P) and Start (S) bits are cleared  from  a  Reset  or  when  the  SSP  module  is disabled.  The  Stop  (P)  and  Start  (S)  bits  will  toggle based on the Start and Stop conditions. Control of the I 2 C bus may be taken when the P bit is set, or the bus is Idle and both the S and P bits are clear.",
    "19.3.3 MULTI-MASTER MODE\nIn Master mode, the SCL and SDA lines are manipulated  by  clearing  the  corresponding  TRISC<5:4>  or TRISD<3:2>  bits.  The  output  level  is  always  low, regardless of the value(s) in PORTC<5:4> or PORTD<3:2>. So when transmitting data, a ' 1 ' data bit must have the TRISC<4> bit set (input) and a ' 0 ' data bit must have the TRISC<4> bit cleared (output). The same  scenario  is  true  for  the  SCL  line  with  the TRISC<4> or TRISD<2> bit. Pull-up resistors must be provided externally to the SCL and SDA pins for proper operation of the I 2 C module.\nThe following events will cause the SSP Interrupt Flag bit, SSPIF,  to  be  set  (SSP  interrupt  will  occur  if enabled):\n\u00b7 Start condition\n\u00b7 Stop condition\n\u00b7 Data transfer byte transmitted/received",
    "19.3.3 MULTI-MASTER MODE\nMaster mode of operation can be done with either the Slave  mode  Idle  (SSPM<3:0>  = 1011 )  or  with  the Slave active. When both Master and Slave modes are enabled, the software needs to differentiate the source(s) of the interrupt.\nIn Multi-Master mode, the interrupt generation on the detection of the  Start  and  Stop  conditions  allows  the determination of when the bus is free. The Stop (P) and Start (S) bits are cleared from a Reset or when the SSP module is disabled. The Stop (P) and Start (S) bits will toggle based on the Start and Stop conditions. Control of the I 2 C bus may be taken when bit P (SSPSTAT<4>) is set, or the bus is Idle and both the S and P bits clear. When the bus is busy, enabling the SSP interrupt will generate the interrupt when the Stop condition occurs.",
    "19.3.3 MULTI-MASTER MODE\nIn Multi-Master mode, the SDA line must be monitored to see if the signal level is the expected output level. This check only needs to be done when a high level is output. If  a  high  level  is  expected  and  a  low  level  is present, the device needs to release the SDA and SCL lines (set TRISC<5:4> or TRISD<3:2>). There are two stages where this arbitration can be lost, these are:\n\u00b7 Address Transfer\n\u00b7 Data Transfer\nWhen the slave logic is enabled, the slave continues to receive.  If  arbitration  was  lost  during  the  address transfer stage, communication to the device may be in progress.  If  addressed,  an  ACK  pulse  will  be  generated.  If  arbitration  was  lost  during  the  data  transfer stage, the device will need to retransfer the data at a later time.",
    "TABLE 19-3: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE.",
    "TABLE 19-3: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\nPIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page: = 57. SSPBUF, Bit 7 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 0 = SSP Receive Buffer/Transmit Register. SSPBUF, Reset Values on Page: = 55. SSPADD, Bit 7 = SSP Address Register (I 2 C mode). SSPADD, Bit 6 = SSP Address Register (I 2 C mode). SSPADD, Bit 5 = SSP Address Register (I 2 C mode).",
    "TABLE 19-3: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\nSSPADD, Bit 4 = SSP Address Register (I 2 C mode). SSPADD, Bit 3 = SSP Address Register (I 2 C mode). SSPADD, Bit 2 = SSP Address Register (I 2 C mode). SSPADD, Bit 1 = SSP Address Register (I 2 C mode). SSPADD, Bit 0 = SSP Address Register (I 2 C mode). SSPADD, Reset Values on Page: = 55. SSPCON, Bit 7 = WCOL. SSPCON, Bit 6 = SSPOV. SSPCON, Bit 5 = SSPEN. SSPCON, Bit 4 = CKP. SSPCON, Bit 3 = SSPM3. SSPCON, Bit 2 = SSPM2. SSPCON, Bit 1 = SSPM1. SSPCON, Bit 0 = SSPM0. SSPCON, Reset Values on Page: = 55. SSPSTAT, Bit 7 = SMP (1). SSPSTAT, Bit 6 = CKE (1). SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 =",
    "TABLE 19-3: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\nP. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Reset Values on Page: = 55. TRISC (2), Bit 7 = PORTC Data Direction Register. TRISC (2), Bit 6 = PORTC Data Direction Register. TRISC (2), Bit 5 = PORTC Data Direction Register. TRISC (2), Bit 4 = PORTC Data Direction Register. TRISC (2), Bit 3 = PORTC Data Direction Register. TRISC (2), Bit 2 = PORTC Data Direction Register. TRISC (2), Bit 1 = PORTC Data Direction Register. TRISC (2), Bit 0 = PORTC Data Direction Register. TRISC (2), Reset Values on Page: = 57. TRISD (2), Bit 7 = PORTD Data Direction Register. TRISD (2), Bit 6 = PORTD Data Direction Register. TRISD (2), Bit 5 = PORTD Data Direction Register. TRISD (2), Bit 4 = PORTD Data",
    "TABLE 19-3: REGISTERS ASSOCIATED WITH I 2 C\u2122 OPERATION\nDirection Register. TRISD (2), Bit 3 = PORTD Data Direction Register. TRISD (2), Bit 2 = PORTD Data Direction Register. TRISD (2), Bit 1 = PORTD Data Direction Register. TRISD (2), Bit 0 = PORTD Data Direction Register. TRISD (2), Reset Values on Page: = 57\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used by the SSP module in I 2 C mode.\nNote 1:\nMaintain these bits clear in I 2 C mode.\n2: Depending upon the setting of SSPMX in CONFIG3H, these pins are multiplexed to PORTC or PORTD.",
    "20.0 ENHANCED UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\nThe Enhanced Universal Synchronous Asynchronous Receiver Transmitter (EUSART) module is one of the two serial  I/O  modules available  in  the  PIC18F2331/ 2431/4331/4431 family of microcontrollers. EUSART is also known as a Serial Communications Interface or SCI.\nThe  EUSART  can  be  configured  as  a  full-duplex asynchronous  system  that  can  communicate  with peripheral devices, such as CRT  terminals and personal computers. It can also be configured as a halfduplex  synchronous  system  that  can  communicate with peripheral devices, such as A/D or D/A integrated circuits, serial EEPROMs, etc.\nThe EUSART module implements additional features, including automatic baud rate detection and calibration, automatic wake-up on Sync Break reception and 12-bit Break character transmit. These features make  it ideally suited for use  in Local Interconnect Network (LIN/J2602) bus systems.\nThe  EUSART  can  be  configured  in  the  following modes:",
    "20.0 ENHANCED UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (EUSART)\n\u00b7 Asynchronous (full-duplex) with:\n-Auto-wake-up on character reception\n-Auto-baud calibration\n-12-bit Break character transmission\n\u00b7 Synchronous - Master (half-duplex) with selectable clock polarity\n\u00b7 Synchronous - Slave (half-duplex) with selectable clock polarity\nIn order to configure pins, TX and RX, as the Enhanced Universal Synchronous Asynchronous Receiver Transmitter:\n\u00b7 SPEN (RCSTA<7>) bit must be set ( = 1 ),\n\u00b7 TRISC<6> bit must be set ( = 1 ), and\n\u00b7 TRISC<7> bit must be set ( = 1 ).",
    "Note:\nThe  EUSART  control  will  automatically reconfigure the pin from input to output as needed.\nThe  operation  of  the  Enhanced  USART  module  is controlled through three registers:\n\u00b7 Transmit Status and Control (TXSTA)\n\u00b7 Receive Status and Control (RCSTA)\n\u00b7 Baud Rate Control (BAUDCON)\nThese are detailed on the following pages in Register 20-1, Register 20-2 and Register 20-3, respectively.",
    "20.1 Asynchronous Operation in Power-Managed Modes\nThe  EUSART  may  operate  in  Asynchronous  mode while the peripheral clocks are being provided by the internal  oscillator  block.  This  makes  it  possible  to remove the crystal or resonator that is commonly connected as the primary clock on the OSC1 and OSC2 pins.\nThe factory calibrates the internal oscillator block output  (INTOSC)  for  8 MHz  (see  Table 26-6).  However, this frequency may  drift as VDD  or temperature changes,  and  this  directly  affects  the  asynchronous baud  rate.  Two  methods  may  be  used  to  adjust  the baud  rate  clock,  but  both  require  a  reference  clock source of some kind.\nThe  first (preferred) method  uses  the  OSCTUNE register to adjust the INTOSC output back to 8 MHz. Adjusting the value in the OSCTUNE register allows for fine resolution changes to the system clock source (see Section 3.6.4  'INTOSC  Frequency  Drift' for  more information).",
    "20.1 Asynchronous Operation in Power-Managed Modes\nThe other method adjusts the value in the Baud Rate Generator  (BRG).  There  may  not  be  fine  enough resolution when adjusting the Baud Rate Generator to compensate  for  a  gradual  change  in  the  peripheral clock frequency.",
    "REGISTER 20-1: TXSTA: TRANSMIT STATUS AND CONTROL REGISTER\nCSRC, R/W-0 = TX9. CSRC, R/W-0 = TXEN (1). CSRC, R/W-0 = SYNC. CSRC, R/W-0 = SENDB. CSRC, R/W-0 = BRGH. CSRC, R-1 = TRMT. CSRC, R/W-0 = TX9D. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R-1 = bit 7. bit 7, R/W-0 = bit 0",
    "REGISTER 20-1: TXSTA: TRANSMIT STATUS AND CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 CSRC: Clock Source Select bit\nAsynchronous mode:\nDon't care.\nSynchronous mode:\n1 = Master mode (clock generated internally from BRG)\n0 = Slave mode (clock from external source)",
    "bit 6\nTX9: 9-Bit Transmit Enable bit\n1 = Selects 9-bit transmission\n0 = Selects 8-bit transmission",
    "bit 5 TXEN: Transmit Enable bit (1)\n1 = Transmit enabled\n0 = Transmit disabled",
    "bit 4\nSYNC: EUSART Mode Select bit\n1 = Synchronous mode\n0 = Asynchronous mode\nbit 3\nSENDB: Send Break Character bit\nAsynchronous mode:\n1 = Send Sync Break on next transmission (cleared by hardware upon completion)\n0 = Sync Break transmission completed\nSynchronous mode:\nDon't care.",
    "bit 2\nBRGH: High Baud Rate Select bit\nAsynchronous mode:\n1 = High speed\n0 = Low speed\nSynchronous mode:\nUnused in this mode.",
    "bit 1\nTRMT: Transmit Shift Register Status bit\n1 = TSR is empty\n0 = TSR is full",
    "bit 0\nTX9D: 9th Bit of Transmit Data\nCan be address/data bit or a parity bit.\nNote 1: SREN/CREN overrides TXEN in Sync mode.",
    "REGISTER 20-2: RCSTA: RECEIVE STATUS AND CONTROL REGISTER\nSPEN, R/W-0 = RX9. SPEN, R/W-0 = SREN. SPEN, R/W-0 = CREN. SPEN, R/W-0 = ADDEN. SPEN, R-0 = FERR. SPEN, R-0 = OERR. SPEN, R-x = RX9D. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R-x = bit 0",
    "REGISTER 20-2: RCSTA: RECEIVE STATUS AND CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 SPEN: Serial Port Enable bit\n1 = Serial port enabled\n0 = Serial port disabled",
    "bit 6 RX9: 9-Bit Receive Enable bit\n1 = Selects 9-bit reception\n0 = Selects 8-bit reception",
    "bit 5 SREN:\nSingle Receive Enable bit\nAsynchronous mode:\nDon't care.",
    "Synchronous mode - Master:\n1 = Enables single receive\n0 = Disables single receive\nThis bit is cleared after reception is complete.\nSynchronous mode - Slave:\nDon't care.",
    "bit 4 CREN: Continuous Receive Enable bit\nAsynchronous mode:\n1 = Enables receiver\n0 = Disables receiver\nSynchronous mode:\n1 = Enables continuous receive until enable bit, CREN, is cleared (CREN overrides SREN)\n0 = Disables continuous receive\nADDEN: Address Detect Enable bit\nAsynchronous mode 9-Bit (RX9 = 1 ):\n1 = Enables address detection, enables interrupt and loads the receive buffer when RSR<8> is set\n0 = Disables address detection, all bytes are received and ninth bit can be used as parity bit\nAsynchronous mode 8-Bit (RX9 = 0 ):\nDon't care.",
    "bit 2 FERR: Framing Error bit\n1 = Framing error (can be cleared by reading RCREGx register and receiving next valid byte)\n0 = No framing error",
    "bit 1 OERR: Overrun Error bit\n1 = Overrun error (can be cleared by clearing bit, CREN)\n0 = No overrun error\nRX9D: 9th Bit of Received Data\nThis can be address/data bit or a parity bit and must be calculated by user firmware.",
    "REGISTER 20-3: BAUDCON: BAUD RATE CONTROL REGISTER\n-, R-1 = RCIDL. -, U-0 = -. -, R/W-1 = SCKP. -, R/W-0 = BRG16. -, U-0 = -. -, R/W-0 = WUE. -, R/W-0 = ABDEN. bit 7 bit 0, R-1 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-1 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 20-3: BAUDCON: BAUD RATE CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6\nRCIDL: Receive Operation Idle Status bit\n1 = Receiver is Idle\n0 = Receive in progress",
    "bit 5\nUnimplemented: Read as ' 0 '",
    "bit 4 SCKP:\nSynchronous Clock Polarity Select bit\nAsynchronous mode:\nUnused in this mode.",
    "Synchronous mode:\n1 = Idle state for clock (CK) is a high level\n0 = Idle state for clock (CK) is a low level",
    "bit 3 BRG16: 16-Bit Baud Rate Register Enable bit\n1 = 16-bit Baud Rate Generator - SPBRGH and SPBRG\n0 = 8-bit Baud Rate Generator - SPBRG only (Compatible mode), SPBRGH value ignored",
    "bit 1 WUE: Wake-up Enable bit\nAsynchronous mode:\n1 = EUSART will continue to sample the RX pin - interrupt generated on falling edge; bit cleared in hardware on following rising edge\n0 = RX pin not monitored or rising edge detected",
    "Synchronous mode:\nUnused in this mode.",
    "bit 0 ABDEN: Auto-Baud Detect Enable bit\nAsynchronous mode:\n1 = Enable baud rate measurement on the next character - requires reception of a Sync field (55h); cleared in hardware upon completion.\n0 = Baud rate measurement disabled or completed",
    "Synchronous mode:\nUnused in this mode.",
    "20.2.1 POWER-MANAGED MODE OPERATION\nThe BRG is a dedicated 8-bit or 16-bit generator, that supports  both  the  Asynchronous  and  Synchronous modes of the EUSART. By default, the BRG operates in 8-bit mode. Setting the BRG16 bit (BAUDCON<3>) selects 16-bit mode.\nThe SPBRGH:SPBRG register pair controls the period of  a  free-running  timer.  In  Asynchronous  mode,  bits BRGH (TXSTA<2>) and BRG16 also control the baud rate.  In  Synchronous  mode,  bit  BRGH  is  ignored. Table 20-1  shows the formula for computation of the baud  rate  for  different  EUSART  modes,  which  only apply in Master mode (internally generated clock).",
    "20.2.1 POWER-MANAGED MODE OPERATION\nGiven  the  desired  baud  rate  and  FOSC,  the  nearest integer value for the SPBRGH:SPBRG registers can be calculated using the formulas in Table 20-1. From this, the error in baud rate can be determined. An example calculation  is  shown  in  Example 20-1.  Typical  baud rates  and  error  values  for  the  various  Asynchronous modes are shown in Table 20-2. It may be advantageous to use the high baud rate (BRGH = 1 ), or  the  16-bit  BRG,  to  reduce  the  baud  rate  error  or achieve a slow baud rate for a fast oscillator frequency.\nWriting a new value to the SPBRGH:SPBRG registers causes  the  BRG timer to be reset (or cleared).  This ensures  the  BRG does not  wait  for  a  timer  overflow before outputting the new baud rate.",
    "TABLE 20-1: BAUD RATE FORMULAS\n0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-Bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[64 (n + 1)]. 0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 1. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-Bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[16 (n + 1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 16-Bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[16 (n + 1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 1. 0,",
    "TABLE 20-1: BAUD RATE FORMULAS\nBRG/EUSART Mode.BRG/EUSART Mode = 16-Bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]. 1, Configuration Bits.BRG16 = 0. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 8-Bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]. 1, Configuration Bits.BRG16 = 1. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 16-Bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]\nLegend: x = Don't care, n = value of SPBRGH:SPBRG register pair",
    "TABLE 20-1: BAUD RATE FORMULAS\nThe system clock is used to generate the desired baud rate. However,  when  a  power-managed  mode  is entered,  the  clock  source  may  be  operating  at  a different frequency than in PRI_RUN mode. In Sleep mode,  no  clocks  are  present  and  in  PRI_IDLE,  the primary clock source continues to provide clocks to the Baud  Rate  Generator. However,  in other powermanaged  modes,  the  clock  frequency  will  probably change. This may require the value in SPBRG to be adjusted.\nIf the system clock is changed during an active receive operation, a receive error or data loss may result. To avoid this problem, check the status of the RCIDL bit and make sure that the receive operation is Idle before changing the system clock.",
    "20.2.2 SAMPLING\nThe data on the RC7/RX/DT/SDO pin is sampled three times by a majority detect circuit to determine if a high or a low level is present at the RX pin.",
    "EXAMPLE 20-1: CALCULATING BAUD RATE ERROR\nFor a device with FOSC of 16 MHz, desired baud rate of 9600, Asynchronous mode, 8-bit BRG:\nDesired Baud Rate = FOSC/(64 ([SPBRGH:SPBRG] + 1))\nSolving for SPBRGH:SPBRG:\nX = ((FOSC/Desired Baud Rate)/64) - 1\n= ((16000000/9600)/64) - 1\n= [25.042] = 25\nCalculated Baud Rate = 16000000/(64 (25 + 1))\n= 9615\nError\n= (Calculated Baud Rate - Desired Baud Rate)/Desired Baud Rate\n= (9615 - 9600)/9600 = 0.16%",
    "TABLE 20-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nTXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, ResetValues on Page: = 56. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, ResetValues on Page: = 56. BAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE.",
    "TABLE 20-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nBAUDCON, Bit 0 = ABDEN. BAUDCON, ResetValues on Page: = 56. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, ResetValues on Page: = 56. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART",
    "TABLE 20-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nBaud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, ResetValues on Page: = 56\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used by the BRG.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 1.221. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 255. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 2.441. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 2.4, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n64. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 0 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 31. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 15. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n, BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 15. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 7. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 4. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 52.083. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -9.58. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 2. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\nvalue (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 104.167. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -9.58. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 2. 115.2, SYNC = 0 , BRGH =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 78.125. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -32.18. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 0.3, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 1.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 12. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 8.929. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -6.99. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 6. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 20.833. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 2.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRG16 = 0.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -45.75. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES\n115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n10.000 MHz.Actual Rate (K) = 2.441. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 255. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n9.766. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 40.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 129. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 19.230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 1 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 21. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n10.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 55.555. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n21. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 1",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n, BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 1.201.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 1 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.FOSC = 4.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 8332. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 4165. 0.3, SYNC = 0 , BRGH = 0 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.02. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 2082. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 1665. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.02. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 2082. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 1041. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 1.200.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -0.03. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 520. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 415. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 2.402. 2.4, SYNC = 0 , BRGH = 0 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 40.000 MHz.% Error = 0.06. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 1040. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 2.399. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 520. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 259. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.16. 9.6, SYNC",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 259. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 10.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nvalue (decimal) = 129. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 19.230. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n20.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 21. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n55.555. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n8.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.04. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 832. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 415. 0.3, SYNC = 0 , BRGH = 0 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 2.404.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 0 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n(decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 ,",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K)",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 33332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.00.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 16665. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 8332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.01. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 6665. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n8332. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 4165. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.02.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 2082. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 1665. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.02. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 4165. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 2.400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2082. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.402. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.06. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 1040. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2.400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n-0.04. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 832. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.606. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.06. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 1040. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n(K) = 9.596. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 520. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nvalue (decimal) = 259. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 19.193. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= -0.03. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 520. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 259. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K)",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 19.230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n103. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 57.803. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.35. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 172. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 57.471. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n-0.22. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 86. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n57.142. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = 0.79. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 34. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 114.943. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -0.22. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n86. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 116.279. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.94. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 42. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -1.36.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 117.647. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -2.12. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 16",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.01. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 3332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.04.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 1665. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.04. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 832. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.04. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 832. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) =",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n415. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 1.201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 415. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 2.403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 207. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 2.403.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 103. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 103.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 19.230.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 19.230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 12.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 58.824. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 2.12. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 16. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 55.555. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = 3.55.",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 8. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 111.111. 115.2, SYNC",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = -3.55. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1",
    "TABLE 20-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n, BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "20.2.3 AUTO-BAUD RATE DETECT\nThe Enhanced USART module supports the automatic detection and calibration of baud rate. This feature is active only in Asynchronous mode and while the WUE bit is clear.\nThis allows the user to verify that no carry occurred for 8bit modes by checking for 00h in the SPBRGH register. Refer to Table 20-4 for counter clock rates to the BRG.\nThe automatic baud rate measurement sequence (Figure 20-1) begins whenever a Start bit is received and the ABDEN bit is set. The calculation is self-averaging.\nIn the Auto-Baud Rate Detect (ABD) mode, the clock to the BRG is reversed. Rather than the BRG clocking the incoming RX signal, the RX signal is timing the BRG. In ABD mode, the internal Baud Rate Generator is used as a counter to time the bit period of the incoming serial byte stream.",
    "20.2.3 AUTO-BAUD RATE DETECT\nOnce the ABDEN bit is set, the state machine will clear the BRG and look for a Start bit. The Auto-Baud Detect must receive a byte with the value of 55h (ASCII 'U', which  is  also  the  LIN/J2602  bus  Sync  character)  in order to calculate the proper bit rate. The measurement takes over both a low and a high bit time in order to minimize  any  effects  caused  by  asymmetry  of  the incoming signal. After a Start bit, the SPBRG begins counting up, using the preselected clock source on the first rising edge of RX. After eight bits on the RX pin, or the fifth rising edge, an accumulated value totalling the proper  BRG  period  is  left  in  the  SPBRGH:SPBRG registers. Once the 5th edge is seen (should correspond to the Stop bit), the ABDEN  bit is automatically cleared.",
    "20.2.3 AUTO-BAUD RATE DETECT\nWhile  the  ABD  sequence  takes  place,  the  EUSART state machine is held in Idle. The RCIF interrupt is set once the fifth rising edge on RX is detected. The value in  the  RCREG  needs  to  be  read  to  clear  the  RCIF interrupt. RCREG content should be discarded.\nNote 1: If the WUE bit is set with the ABDEN bit, Auto-Baud Rate Detection will occur on the  byte following the  Break  character (see Section 20.3.4 'Auto-Wake-up on Sync Break Character' ).\n2: It  is  up  to  the  user  to  determine  that  the incoming character baud rate is within the range of the selected BRG clock source. Some combinations of oscillator frequency and EUSART baud rates are not possible due to bit error rates. Overall system timing and  communication  baud  rates  must  be taken  into  consideration  when  using  the Auto-Baud Rate Detection feature.\n3: To  maximize  baud  rate  range,  setting the  BRG16  bit  is  recommended  if  the auto-baud feature is used.\nTABLE 20-4: BRG COUNTER CLOCK RATES",
    "20.2.3 AUTO-BAUD RATE DETECT\nWhile calibrating the baud rate period, the BRG registers are clocked at 1/8th the preconfigured clock rate. The BRG clock can be configured by the BRG16 and BRGH bits. The BRG16 bit must be set to use both SPBRG and SPBRGH as a 16-bit counter.\n0, BRGH = 0. 0, BRG Counter Clock = FOSC/512. 0, BRGH = 1. 0, BRG Counter Clock = FOSC/256. 1, BRGH = 0. 1, BRG Counter Clock = FOSC/128. 1, BRGH = 1. 1, BRG Counter Clock = FOSC/32",
    "FIGURE 20-1: AUTOMATIC BAUD RATE CALCULATION (1)\nBRG Value, 1 = XXXXh. BRG Value, 2 = 0000h. BRG Value, 3 = 001Ch Edge #5. RX Pin, 1 = . RX Pin, 2 = Start. RX Pin, 3 = Bit 0 Bit 1 Bit 2 Bit 3 Bit 4 Bit 5 Bit 6 Bit 7 Stop Bit. BRG Clock, 1 = BRG Clock. BRG Clock, 2 = BRG Clock. BRG Clock, 3 = BRG Clock. ABDEN bit, 1 = by user. ABDEN bit, 2 = . ABDEN bit, 3 = Auto-Cleared. RCIF bit (Interrupt), 1 = . RCIF bit (Interrupt), 2 = . RCIF bit (Interrupt), 3 = . Read RCREG, 1 = . Read RCREG, 2 = . Read RCREG, 3 = . SPBRG SPBRGH, 1 = . SPBRG SPBRGH, 2 = XXXXh. SPBRG SPBRGH, 3 = 1Ch 00h. Note 1: The, 1 = ABD sequence requires the EUSART module to be configured in Asynchronous",
    "FIGURE 20-1: AUTOMATIC BAUD RATE CALCULATION (1)\nmode and. Note 1: The, 2 = XXXXh. Note 1: The, 3 = WUE = 0 .",
    "20.3 EUSART Asynchronous Mode\nThe Asynchronous mode of operation is selected by clearing the SYNC bit (TXSTA<4>). In this mode, the EUSART uses standard Non-Return-to-Zero (NRZ) format (one Start bit, eight or nine data bits and one Stop bit). The most common data format is 8 bits. An on-chip dedicated  8-bit/16-bit  Baud  Rate  Generator  can  be used to derive standard baud rate frequencies from the oscillator.\nThe EUSART transmits and receives the LSb first. The EUSART's  transmitter  and  receiver  are  functionally independent, but use the same data format and baud rate. The Baud Rate Generator produces a clock, either x16 or x64 of the bit shift rate, depending on the BRGH and BRG16 bits (TXSTA<2> and BAUDCON<3>). Parity is not  supported  by  the  hardware  but  can  be implemented in software and stored as the 9th data bit.",
    "20.3 EUSART Asynchronous Mode\nOnce the TXREG register transfers the data to the TSR register  (occurs  in  one  TCY),  the  TXREG  register  is empty and flag bit, TXIF (PIR1<4>), is set. This interrupt can be enabled/disabled by setting/clearing enable bit, TXIE (PIE1<4>). Flag bit, TXIF, will be set, regardless of the state of enable bit TXIE and cannot be cleared  in  software.  Flag  bit,  TXIF,  is  not  cleared immediately upon loading the Transmit Buffer register, TXREG. TXIF becomes valid in the second instruction cycle following the load instruction. Polling TXIF immediately  following  a  load  of  TXREG  will  return invalid results.\nAsynchronous  mode  is  available  in  all  Low-Power modes; it is available in Sleep mode only when AutoWake-up on Sync Break is enabled. When in PRI_IDLE mode, no changes to the Baud Rate Generator values are required; however, other Low-Power mode clocks may  operate  at  another  frequency  than  the  primary clock. Therefore, the Baud Rate Generator values may need to be adjusted.",
    "20.3 EUSART Asynchronous Mode\nWhen operating in Asynchronous mode, the EUSART module consists of the following important elements:\n\u00b7 Baud Rate Generator\n\u00b7 Sampling Circuit\n\u00b7 Asynchronous Transmitter\n\u00b7 Asynchronous Receiver\n\u00b7 Auto-Wake-up on Sync Break Character\n\u00b7 12-Bit Break Character Transmit\n\u00b7 Auto-Baud Rate Detection",
    "20.3.1 EUSART ASYNCHRONOUS TRANSMITTER\nThe  EUSART transmitter  block  diagram  is  shown  in Figure 20-2. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The Shift register obtains its data from the Read/Write Transmit Buffer register, TXREG.  The  TXREG  register  is  loaded  with  data  in software. The TSR register is not loaded until the Stop bit  has  been  transmitted  from  the  previous  load.  As soon as the Stop bit is transmitted, the TSR is loaded with new data from the TXREG register (if available).\nWhile flag bit, TXIF, indicates the status of the TXREG register,  another  bit,  TRMT  (TXSTA<1>),  shows  the status of the TSR register. Status bit, TRMT, is a readonly bit, which is set when the TSR register is empty. No interrupt logic is tied to this bit, so the user has to poll this bit in order to determine if the TSR register is empty.",
    "20.3.1 EUSART ASYNCHRONOUS TRANSMITTER\nNote 1: The TSR register is not mapped in data memory, so it is not available to the user.\n2: Flag  bit,  TXIF,  is  set  when  enable  bit, TXEN, is set.\nTo set up an Asynchronous Transmission:\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate.  Set or clear the  BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit, SYNC, and setting bit, SPEN.\n3. If interrupts are desired, set enable bit, TXIE.\n4. If 9-bit transmission is desired, set transmit bit, TX9. Can be used as address/data bit.\n5. Enable  the  transmission  by  setting  bit,  TXEN, which will also set bit, TXIF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit, TX9D.\n7. Load data to the TXREG  register (starts transmission).",
    "20.3.1 EUSART ASYNCHRONOUS TRANSMITTER\nIf using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 20-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, ResetValues on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, ResetValues on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 =",
    "TABLE 20-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nSSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, ResetValues on Page: = 57. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, ResetValues on Page: = 57. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, ResetValues on Page: = 56.",
    "TABLE 20-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nTXREG, Bit 7 = EUSART Transmit Register. TXREG, Bit 6 = EUSART Transmit Register. TXREG, Bit 5 = EUSART Transmit Register. TXREG, Bit 4 = EUSART Transmit Register. TXREG, Bit 3 = EUSART Transmit Register. TXREG, Bit 2 = EUSART Transmit Register. TXREG, Bit 1 = EUSART Transmit Register. TXREG, Bit 0 = EUSART Transmit Register. TXREG, ResetValues on Page: = 56. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, ResetValues on Page: = 56. BAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP.",
    "TABLE 20-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nBAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, ResetValues on Page: = 56. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, ResetValues on Page: = 56. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator",
    "TABLE 20-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nRegister Low Byte. SPBRG, Bit 5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, ResetValues on Page: = 56\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used for asynchronous transmission.",
    "20.3.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\nThe receiver block diagram is  shown in Figure 20-5. The data is received on the RC7/RX/DT/SDO pin and drives the data recovery block. The data recovery block is actually a high-speed shifter operating at x16 times the baud rate, whereas the main receive serial shifter operates at the bit rate or at FOSC. This mode would typically be used in RS-232 systems.\nTo set up an Asynchronous Reception:",
    "20.3.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate. Set or clear the BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit, SYNC, and setting bit, SPEN.\n3. If interrupts are desired, set enable bit, RCIE.\n4. If 9-bit reception is desired, set bit, RX9.\n5. Enable the reception by setting bit, CREN.\n6. Flag bit, RCIF, will be set when reception is complete and an interrupt will be generated if enable bit, RCIE, was set.\n7. Read the RCSTA register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n8. Read  the  8-bit  received  data  by  reading  the RCREG register.\n9. If any error occurred, clear the error by clearing enable bit, CREN.\nThis mode would typically be used in RS-485 systems. To  set  up  an  Asynchronous  Reception  with  Address Detect Enable:",
    "20.3.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate.  Set or clear the  BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n2. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n3. If interrupts are required, set the RCEN bit and select the desired priority level with the RCIP bit.\n4. Set the RX9 bit to enable 9-bit reception.\n5. Set the ADDEN bit to enable address detect.\n6. Enable reception by setting the CREN bit.\n7. The RCIF bit will be set when reception is complete. The interrupt will be Acknowledged if the RCIE and GIE bits are set.\n8. Read the  RCSTA  register  to  determine  if  any error occurred during reception, as well as read bit 9 of data (if applicable).\n9. Read RCREG to determine if the device is being addressed.\n10. If any error occurred, clear the CREN bit.",
    "20.3.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n11. If  the  device  has  been  addressed,  clear  the ADDEN bit  to  allow  all  received  data  into  the receive buffer and interrupt the CPU.\n10. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "PIC18F2331/2431/4331/4431\nTo set up an Asynchronous Transmission:\n1. Initialize the SPBRG register for the appropriate baud rate. If a high-speed baud rate is desired, set  bit,  BRGH  (see Section 20.2  'EUSART Baud Rate Generator (BRG)' ).\n2. Enable the asynchronous serial port by clearing bit, SYNC, and setting bit, SPEN.\n3. If interrupts are desired, set enable bit, TXIE.\n5. Enable  the  transmission  by  setting  bit,  TXEN, which will also set bit, TXIF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit, TX9D.\n7. Load data to the TXREG  register (starts transmission).\nIf using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.\n- 4. If 9-bit transmission is desired, set transmit bit, TX9. Can be used as address/data bit.",
    "TABLE 20-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, ResetValues on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, ResetValues on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 =",
    "TABLE 20-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nSSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, ResetValues on Page: = 57. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, ResetValues on Page: = 57. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, ResetValues on Page: = 56.",
    "TABLE 20-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nRCREG, Bit 7 = EUSART Receive Register. RCREG, Bit 6 = EUSART Receive Register. RCREG, Bit 5 = EUSART Receive Register. RCREG, Bit 4 = EUSART Receive Register. RCREG, Bit 3 = EUSART Receive Register. RCREG, Bit 2 = EUSART Receive Register. RCREG, Bit 1 = EUSART Receive Register. RCREG, Bit 0 = EUSART Receive Register. RCREG, ResetValues on Page: = 56. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, ResetValues on Page: = 56. BAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP.",
    "TABLE 20-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nBAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, ResetValues on Page: = 56. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, ResetValues on Page: = 56. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator",
    "TABLE 20-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nRegister Low Byte. SPBRG, Bit 5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, ResetValues on Page: = 56\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used for asynchronous reception.",
    "20.3.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nDuring  Sleep  mode,  all  clocks  to  the  EUSART  are suspended. Because of this, the Baud Rate Generator is inactive and a proper byte reception cannot be performed. The auto-wake-up feature allows the controller to wake-up due to activity on the RX/DT line, while the EUSART is operating in Asynchronous mode.\nand  cause  data  or  framing  errors.  To  work  properly, therefore, the initial characters in the transmission must be all ' 0 's. This can be 00h (8 bits) for standard RS-232 devices, or 000h (12 bits) for LIN/J2602 bus.",
    "20.3.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nThe  auto-wake-up  feature  is  enabled  by  setting  the WUE bit (BAUDCON<1>). Once set, the typical receive sequence  on  RX/DT  is  disabled  and  the  EUSART remains in an Idle state, monitoring for a wake-up event independent of the CPU mode. A wake-up event consists of a high-to-low transition on the RX/DT line. (This coincides with the start of a Sync Break or a Wake-up Signal character for the LIN/J2602 protocol.)\nFollowing a wake-up event, the module generates an RCIF  interrupt.  The  interrupt  is  generated  synchronously  to  the  Q  clocks  in  normal  operating  modes (Figure 20-7),  and  asynchronously  if  the  device  is  in Sleep  mode  (Figure 20-8).  The  interrupt  condition  is cleared by reading the RCREG register.",
    "20.3.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nThe WUE bit is automatically cleared once a low-tohigh transition is observed on the RX line following the wake-up event. At this point, the EUSART module is in Idle mode and returns to normal operation. This signals to the user that the Sync Break event is over.",
    "20.3.4.1 Special Considerations Using Auto-Wake-up\nSince Auto-Wake-up functions by sensing rising edge transitions on RX/DT, information with any state changes before the Stop bit may signal a false end-of-character\nOscillator start-up time must  also  be  considered, especially in applications using oscillators with longer start-up intervals (i.e., LP, XT or HS/PLL mode). The Sync Break (or Wake-up Signal) character must be of sufficient length, and be followed by a sufficient interval, to allow enough time for the selected oscillator to start and provide proper initialization of the EUSART.",
    "20.3.4.2 Special Considerations Using the WUE Bit\nThe timing of WUE and RCIF events may cause some confusion when it comes to determining the validity of received data. As noted, setting the WUE bit places the EUSART in an Idle mode. The wake-up event causes a receive interrupt by setting the RCIF bit. The WUE bit is cleared after this when a rising edge is seen on RX/ DT. The interrupt condition is then cleared by reading the RCREG register. Ordinarily, the data in RCREG will be dummy data and should be discarded.\nThe fact that the WUE bit has been cleared (or is still set), and the RCIF flag is set, should not be used as an indicator of the integrity of the data in RCREG. Users should  consider  implementing  a  parallel  method  in firmware to verify received data integrity.\nTo assure that no actual data is lost, check the RCIDL bit to verify that a receive operation is not in process. If a receive operation is not occurring, the WUE bit may then be set just prior to entering the Sleep mode.",
    "AUTO-WAKE-UP BIT (WUE) TIMINGS DURING NORMAL OPERATION\nFIGURE 20-8:",
    "AUTO-WAKE-UP BIT (WUE) TIMINGS DURING SLEEP\nNote 1: If the wake-up event requires long oscillator warm-up time, the auto-clear of the WUE bit can occur while the stposc signal is still active. This sequence should not depend on the presence of Q clocks.\n- 2: The EUSART remains in Idle while the WUE bit is set.",
    "20.3.5.1 Break and Sync Transmit Sequence\nThe  Enhanced  USART  module  has  the  capability  of sending  the  special  Break  character  sequences  that are required by the LIN/J2602 bus standard. The Break character transmit consists of a Start bit, followed by twelve ' 0 ' bits and a Stop bit. The Frame Break character is sent  whenever  the  SENDB  and  TXEN  bits (TXSTA<3> and TXSTA<5>) are set while the Transmit Shift register is loaded with data. Note that the value of data written to TXREG will be ignored and all ' 0 's will be transmitted.\nThe SENDB bit is automatically reset by hardware after the corresponding Stop bit is sent. This allows the user to preload the transmit FIFO with the next transmit byte following the Break  character  (typically, the Sync character in the LIN/J2602 specification).\nNote that the data value written to the TXREG for the Break character is ignored. The write simply serves the purpose of initiating the proper sequence.\nThe TRMT bit indicates when the transmit operation is active or Idle, just as it does during normal transmission.  See  Figure 20-9  for  the  timing  of  the  Break character sequence.",
    "20.3.5.1 Break and Sync Transmit Sequence\nThe  following  sequence  will  send  a  message  frame header made up of a Break, followed by an Auto-Baud Sync byte. This sequence is typical of a LIN/J2602 bus master.\n1. Configure the EUSART for the desired mode.\n2. Set  the  TXEN  and  SENDB  bits  to  setup  the Break character.\n3. Load  the  TXREG  with  a  dummy  character  to initiate transmission (the value is ignored).\n4. Write '55h' to TXREG to load the Sync character into the transmit FIFO buffer.\n5. After the Break has been sent, the SENDB bit is reset  by  hardware.  The  Sync  character  now transmits in the preconfigured mode.\nWhen the TXREG becomes empty, as indicated by the TXIF, the next data byte can be written to TXREG.",
    "20.3.6 RECEIVING A BREAK CHARACTER\nThe  Enhanced  USART  module can  receive  a  Break character in two ways.\nThe first method forces configuration of the baud rate at a frequency of 9/13 of the typical speed. This allows for the Stop bit transition to be at the correct sampling location (13 bits for Break versus Start bit and 8 data bits for typical data).\nThe  second  method  uses  the  auto-wake-up  feature described in Section 20.3.4 'Auto-Wake-up on Sync Break  Character' . By enabling this feature, the EUSART will sample the next two transitions on RX/DT, cause an RCIF interrupt and receive the next data byte followed by another interrupt.\nNote  that  following  a  Break  character,  the  user  will typically  want  to  enable  the  Auto-Baud  Rate  Detect feature. For both methods, the user can set the ABD bit before placing the EUSART in its Sleep mode.",
    "20.4 EUSART Synchronous Master Mode\nThe Synchronous Master mode is entered by setting the CSRC bit (TXSTA<7>). In this mode, the data is transmitted in a half-duplex manner (i.e., transmission and reception do not occur at the same time). When transmitting  data,  the  reception  is  inhibited  and  vice versa.  Synchronous  mode  is  entered  by  setting  bit SYNC  (TXSTA<4>).  In  addition,  enable  bit  SPEN (RCSTA<7>) is set in order to configure the RC6/TX/ CK/SS  and  RC7/RX/DT/SDO  I/O  pins  to  CK  (clock) and DT (data) lines, respectively.\nThe Master mode indicates that the processor transmits the master clock on the CK line. Clock polarity is selected  with  the  SCKP  bit  (BAUDCON<4>).  Setting SCKP sets the Idle state on CK as high, while clearing the bit, sets the Idle state low. This option is provided to support Microwire devices with this module.",
    "20.4.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\nOnce the TXREG register transfers the data to the TSR register (occurs in one TCYCLE), the TXREG is empty and interrupt bit, TXIF (PIR1<4>), is set. The interrupt can be enabled/disabled by setting/clearing enable bit, TXIE (PIE1<4>). Flag bit, TXIF, will be set, regardless of the state of enable bit, TXIE, and cannot be cleared in software. It will reset only when new data is loaded into the TXREG register.\nWhile flag bit, TXIF, indicates the status of the TXREG register,  another  bit,  TRMT  (TXSTA<1>),  shows  the status of the TSR register. TRMT is a read-only bit which is set when the TSR is empty. No interrupt logic is tied to this bit, so the user must poll this bit in order to determine if the TSR register is empty. The TSR is not mapped in data memory, so it is not available to the user.\nTo set up a Synchronous Master Transmission:",
    "20.4.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\n- 1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate.  Set or clear the  BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\nThe  EUSART transmitter  block  diagram  is  shown  in Figure 20-2. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The Shift register obtains its data from the Read/Write Transmit Buffer register, TXREG.  The  TXREG  register  is  loaded  with  data  in software. The TSR register is not loaded until the last bit  has  been  transmitted  from  the  previous  load.  As soon as the last bit is transmitted, the TSR is loaded with new data from the TXREG (if available).",
    "20.4.1 EUSART SYNCHRONOUS MASTER TRANSMISSION\n2. Enable  the  synchronous  master  serial  port  by setting bits, SYNC, SPEN and CSRC.\n3. If interrupts are desired, set enable bit, TXIE.\n4. If 9-bit transmission is desired, set bit, TX9.\n5. Enable the transmission by setting bit, TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit, TX9D.\n7. Start transmission by loading data to the TXREG register.\n8. If  using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 20-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE.",
    "TABLE 20-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nPIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page: = 57. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page: = 57. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Reset Values on Page: = 56. TXREG, Bit 7 =",
    "TABLE 20-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nEUSART Transmit Register. TXREG, Bit 6 = EUSART Transmit Register. TXREG, Bit 5 = EUSART Transmit Register. TXREG, Bit 4 = EUSART Transmit Register. TXREG, Bit 3 = EUSART Transmit Register. TXREG, Bit 2 = EUSART Transmit Register. TXREG, Bit 1 = EUSART Transmit Register. TXREG, Bit 0 = EUSART Transmit Register. TXREG, Reset Values on Page: = 56. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Reset Values on Page: = 56. BAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 =",
    "TABLE 20-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nBRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Reset Values on Page: = 56. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Reset Values on Page: = 56. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit",
    "TABLE 20-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\n5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Reset Values on Page: = 56\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous master transmission.",
    "20.4.2 EUSART SYNCHRONOUS MASTER RECEPTION\nOnce  Synchronous  mode  is  selected,  reception  is enabled by setting either the Single Receive Enable bit, SREN  (RCSTA<5>), or the Continuous Receive Enable bit, CREN (RCSTA<4>). Data is sampled on the RC7/RX/DT/SDO pin on the falling edge of the clock.\nIf enable bit SREN is set, only a single word is received. If enable bit CREN is set, the reception is continuous until CREN is cleared. If both bits are set, then CREN takes precedence.\nTo set up a Synchronous Master Reception:",
    "20.4.2 EUSART SYNCHRONOUS MASTER RECEPTION\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate. Set or clear the BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n3. Ensure bits, CREN and SREN, are clear.\n4. If interrupts are desired, set enable bit, RCIE.\n5. If 9-bit reception is desired, set bit, RX9.\n6. If a single reception is required, set bit, SREN. For continuous reception, set bit, CREN.\n7. Interrupt flag bit, RCIF, will be set when reception  is  complete  and  an  interrupt  will  be generated if the enable bit, RCIE, was set.\n8. Read the RCSTA register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n9. Read  the  8-bit  received  data  by  reading  the RCREG register.\n10. If any error occurred, clear the error by clearing bit, CREN.\n2. Enable  the  synchronous  master  serial  port  by setting bits, SYNC, SPEN and CSRC.",
    "20.4.2 EUSART SYNCHRONOUS MASTER RECEPTION\n11. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 20-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE.",
    "TABLE 20-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nPIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page: = 57. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page: = 57. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Reset Values on Page: = 56. RCREG, Bit 7 =",
    "TABLE 20-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nEUSART Receive Register. RCREG, Bit 6 = EUSART Receive Register. RCREG, Bit 5 = EUSART Receive Register. RCREG, Bit 4 = EUSART Receive Register. RCREG, Bit 3 = EUSART Receive Register. RCREG, Bit 2 = EUSART Receive Register. RCREG, Bit 1 = EUSART Receive Register. RCREG, Bit 0 = EUSART Receive Register. RCREG, Reset Values on Page: = 56. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Reset Values on Page: = 56. BAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 =",
    "TABLE 20-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nBRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Reset Values on Page: = 56. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Reset Values on Page: = 56. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit",
    "TABLE 20-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\n5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Reset Values on Page: = 56\nLegend:\n- = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous master reception.",
    "20.5 EUSART Synchronous Slave Mode\nSynchronous  Slave  mode  is  entered  by  clearing  bit, CSRC  (TXSTA<7>).  This mode  differs from the Synchronous  Master  mode  in  that  the  shift  clock  is supplied externally at the RC6/TX/CK/SS pin (instead of  being  supplied  internally  in  Master  mode).  This allows the device to transfer or receive data while in any low-power mode.",
    "20.5.1 EUSART SYNCHRONOUS SLAVE TRANSMIT\nThe operation of the Synchronous Master and Slave modes are identical, except in the case of Sleep mode.\nIf  two  words  are  written  to  the  TXREG  and  then  the SLEEP instruction is executed, the following will occur:\na) The  first  word  will  immediately  transfer  to  the TSR register and transmit.\nb) The second word will remain in TXREG register.\nc) Flag bit, TXIF, will not be set.\nd) When the first word has been shifted out of TSR, the TXREG register will transfer the second word to the TSR and flag bit, TXIF, will now be set.\ne) If enable bit, TXIE, is set, the interrupt will wake the  chip  from  Sleep.  If  the  global  interrupt  is enabled, the program will branch to the interrupt vector.",
    "TABLE 20-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE.",
    "TABLE 20-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nPIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page: = 57. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page: = 57. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Reset Values on Page: = 56. TXREG, Bit 7 =",
    "TABLE 20-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nEUSART Transmit Register. TXREG, Bit 6 = EUSART Transmit Register. TXREG, Bit 5 = EUSART Transmit Register. TXREG, Bit 4 = EUSART Transmit Register. TXREG, Bit 3 = EUSART Transmit Register. TXREG, Bit 2 = EUSART Transmit Register. TXREG, Bit 1 = EUSART Transmit Register. TXREG, Bit 0 = EUSART Transmit Register. TXREG, Reset Values on Page: = 56. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Reset Values on Page: = 56. BAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 =",
    "TABLE 20-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nBRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Reset Values on Page: = 56. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Reset Values on Page: = 56. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit",
    "TABLE 20-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\n5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Reset Values on Page: = 56\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous slave transmission.\nTo set up a Synchronous Slave Transmission:",
    "TABLE 20-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\n1. Enable  the  synchronous  slave  serial  port  by setting bits, SYNC and SPEN, and clearing bit, CSRC.\n2. Clear bits, CREN and SREN.\n3. If interrupts are desired, set enable bit, TXIE.\n4. If 9-bit transmission is desired, set bit, TX9.\n5. Enable the transmission by setting enable bit, TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit, TX9D.\n7. Start transmission by loading data to the TXREG register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "20.5.2 EUSART SYNCHRONOUS SLAVE RECEPTION\nTo set up a Synchronous Slave Reception:\nThe operation of the Synchronous Master and Slave modes is identical, except in the case of Sleep, or any Idle  mode  and  bit  SREN,  which  is  a  'don't  care'  in Slave mode.\nIf  receive is enabled by setting the CREN bit prior to entering Sleep or any Idle mode, then a word may be received while in this Low-Power mode. Once the word is received, the RSR register will transfer the data to the RCREG register. If the RCIE enable bit is set, the interrupt  generated  will  wake  the  chip  from  Low-Power mode. If the global interrupt is enabled, the program will branch to the interrupt vector.",
    "20.5.2 EUSART SYNCHRONOUS SLAVE RECEPTION\n1. Enable  the  synchronous  master  serial  port  by setting bits, SYNC and SPEN, and clearing bit, CSRC.\n2. If interrupts are desired, set enable bit, RCIE.\n3. If 9-bit reception is desired, set bit, RX9.\n4. To enable reception, set enable bit, CREN.\n5. Flag  bit,  RCIF,  will  be  set  when  reception  is complete.  An  interrupt will be  generated  if enable bit, RCIE, was set.\n6. Read the RCSTA register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n7. Read  the  8-bit  received  data  by  reading  the RCREG register.\n8. If any error occurred, clear the error by clearing bit, CREN.\n9. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 20-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, ResetValues on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, ResetValues on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 =",
    "TABLE 20-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nSSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, ResetValues on Page: = 57. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, ResetValues on Page: = 57. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, ResetValues on Page: = 56.",
    "TABLE 20-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nRCREG, Bit 7 = EUSART Receive Register. RCREG, Bit 6 = EUSART Receive Register. RCREG, Bit 5 = EUSART Receive Register. RCREG, Bit 4 = EUSART Receive Register. RCREG, Bit 3 = EUSART Receive Register. RCREG, Bit 2 = EUSART Receive Register. RCREG, Bit 1 = EUSART Receive Register. RCREG, Bit 0 = EUSART Receive Register. RCREG, ResetValues on Page: = 56. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, ResetValues on Page: = 56. BAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP.",
    "TABLE 20-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nBAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, ResetValues on Page: = 56. SPBRGH, Bit 7 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 6 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 5 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 4 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 3 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 2 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 1 = EUSART Baud Rate Generator Register High Byte. SPBRGH, Bit 0 = EUSART Baud Rate Generator Register High Byte. SPBRGH, ResetValues on Page: = 56. SPBRG, Bit 7 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 6 = EUSART Baud Rate Generator",
    "TABLE 20-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nRegister Low Byte. SPBRG, Bit 5 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 4 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 3 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 2 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 1 = EUSART Baud Rate Generator Register Low Byte. SPBRG, Bit 0 = EUSART Baud Rate Generator Register Low Byte. SPBRG, ResetValues on Page: = 56\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous slave reception.",
    "21.0 10-BIT HIGH-SPEED ANALOG-TO-DIGITAL CONVERTER (A/D) MODULE\nThe high-speed Analog-to-Digital (A/D) Converter module  allows  conversion  of  an  analog  signal  to  a corresponding 10-bit digital number.\nThe A/D module supports up to 5 input channels on PIC18F2331/2431 devices, and up to 9 channels on the PIC18F4331/4431 devices.\nThis high-speed 10-bit A/D module offers the following features:\n\u00b7 Up to 200K samples per second\n\u00b7 Two sample and hold inputs for dual-channel simultaneous sampling\n\u00b7 Selectable Simultaneous or Sequential Sampling modes\n\u00b7 4-word data buffer for A/D results\n\u00b7 Selectable data acquisition timing\n\u00b7 Selectable A/D event trigger\n\u00b7 Operation in Sleep using internal oscillator\nThese features lend themselves to many applications including motor control, sensor interfacing, data acquisition and process control. In many cases, these features will reduce the software overhead associated with standard A/D modules.\nThe module has 9 registers:",
    "21.0 10-BIT HIGH-SPEED ANALOG-TO-DIGITAL CONVERTER (A/D) MODULE\n\u00b7 A/D Result High Register (ADRESH)\n\u00b7 A/D Result Low Register (ADRESL)\n\u00b7 A/D Control Register 0 (ADCON0)\n\u00b7 A/D Control Register 1 (ADCON1)\n\u00b7 A/D Control Register 2 (ADCON2)\n\u00b7 A/D Control Register 3 (ADCON3)\n\u00b7 A/D Channel Select Register (ADCHS)\n\u00b7 Analog I/O Select Register 0 (ANSEL0)\n\u00b7 Analog I/O Select Register 1 (ANSEL1)",
    "REGISTER 21-1: ADCON0: A/D CONTROL REGISTER 0\n-, U-0 = -. -, R/W-0 = ACONV. -, R/W-0 = ACSCH. -, R/W-0 = ACMOD1. -, R/W-0 = ACMOD0. -, R/W-0 = GO/DONE. -, R/W-0 = ADON. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 21-1: ADCON0: A/D CONTROL REGISTER 0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5 ACONV : Auto-Conversion Continuous Loop or Single-Shot Mode Select bit\n1 = Continuous Loop mode enabled\n0 = Single-Shot mode enabled\nACSCH : Auto-Conversion Single or Multi-Channel Mode bit\n1 = Multi-Channel mode enabled, Single Channel mode disabled\n0 = Single Channel mode enabled, Multi-Channel mode disabled",
    "bit 3-2\nACMOD<1:0>: Auto-Conversion Mode Sequence Select bits\nIf ACSCH = 1 :\n- 00 = Sequential Mode 1 (SEQM1); two samples are taken in sequence:\n2nd sample: Group B (1)\n1st sample: Group A (1)\n- 01 = Sequential Mode 2 (SEQM2); four samples are taken in sequence:\n2nd sample: Group B (1)\n1st sample: Group A (1)\n3rd sample: Group C (1)\n4th sample: Group D (1)\n= Simultaneous Mode 1 (STNM1); two samples are taken simultaneously:\n1st sample: Group A and Group B\n10 (1)\n= Simultaneous Mode 2 (STNM2); two samples are taken simultaneously:\n2nd sample: Group C and Group D\n- 11 1st sample: Group A and Group B (1) (1)",
    "If ACSCH = 0 , Auto-Conversion Single Channel Sequence Mode Enabled:\n00 = Single Channel Mode 1 (SCM1); Group A is taken and converted (1)\n01 = Single Channel Mode 2 (SCM2); Group B is taken and converted (1)\n10 = Single Channel Mode 3 (SCM3); Group C is taken and converted (1)\n11 = Single Channel Mode 4 (SCM4); Group D is taken and converted (1)\nGO/DONE\n: A/D Conversion Status bit\n1 = A/D  conversion  cycle  in  progress.  Setting  this  bit  starts  the  A/D  conversion  cycle.  If  AutoConversion  Single-Shot  mode  is  enabled  (ACONV  = 0 ),  this  bit  is  automatically  cleared  by hardware when the A/D conversion (single or multi-channel depending on ACMOD settings) has completed. If Auto-Conversion Continuous Loop mode is enabled (ACONV = 1 ), this bit remains set after the user/trigger has set it (continuous conversions). It may be cleared manually by the user to stop the conversions.\n0 = A/D conversion or multiple conversions completed/not in progress",
    "bit 0 ADON: A/D On bit\n1 = A/D Converter module is enabled (after brief power-up delay, starts continuous sampling)\n0 = A/D Converter module is disabled",
    "bit 4\nbit 1",
    "REGISTER 21-2: ADCON1: A/D CONTROL REGISTER 1\nVCFG1, R/W-0 = VCFG0. VCFG1, U-0 = -. VCFG1, R/W-0 = FIFOEN. VCFG1, R-0 = BFEMT. VCFG1, R-0 = BFOVL. VCFG1, R-0 = ADPNT1. VCFG1, R-0 = ADPNT0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0. bit 7 bit 0, R-0 = bit 7 bit 0",
    "REGISTER 21-2: ADCON1: A/D CONTROL REGISTER 1\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-6\nVCFG<1:0>: A/D VREF+ and A/D VREF- Source Selection bits\n00 = VREF+ = AVDD, VREF- = AVSS (AN2 and AN3 are analog inputs or digital I/O)\n01 = VREF+ = External VREF+, VREF- = AVSS (AN2 is an analog input or digital I/O)",
    "REGISTER 21-2: ADCON1: A/D CONTROL REGISTER 1\n10 = VREF+ = AVDD, VREF- = External VREF- (AN3 is an analog input or digital I/O)\n11 = VREF+ = External VREF-, VREF- = External VREF-",
    "bit 4 FIFOEN : FIFO Buffer Enable bit\n1 = FIFO is enabled\n0 = FIFO is disabled",
    "bit 3\nBFEMT : Buffer Empty bit\n1 = FIFO is empty\n0 = FIFO is not empty (at least one of four locations has unread A/D result data)",
    "bit 2\nBFOVFL : Buffer Overflow bit\n1 = A/D result has overwritten a buffer location that has unread data\n0 = A/D result has not overflowed",
    "bit 1-0\nADPNT<1:0> : Buffer Read Pointer Location bits\nDesignates the location to be read next.\n00 =  Buffer Address 0\n01 =  Buffer Address 1\n10 =  Buffer Address 2\n11 =  Buffer Address 3",
    "REGISTER 21-3: ADCON2: A/D CONTROL REGISTER 2\nADFM, R/W-0 = ACQT3. ADFM, R/W-0 = ACQT2. ADFM, R/W-0 = ACQT1. ADFM, R/W-0 = ACQT0. ADFM, R/W-0 = ADCS2. ADFM, R/W-0 = ADCS1. ADFM, R/W-0 = ADCS0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 21-3: ADCON2: A/D CONTROL REGISTER 2\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7 ADFM: A/D Result Format Select bit\n1 = Right justified\n0 = Left justified",
    "bit 6-3\nACQT<3:0> : A/D Acquisition Time Select bits\n0000 = No delay (conversion starts immediately when GO/DONE is set) (1)\n0001 = 2 TAD\n0010 = 4 TAD\n0011 = 6 TAD\n0100 = 8 TAD\n0101 = 10 TAD\n0110 = 12 TAD\n0111 = 16 TAD\n1000 = 20 TAD\n1001 = 24 TAD\n1010 = 28 TAD\n1011 = 32 TAD\n1100 = 36 TAD\n1101 = 40 TAD\n1110 = 48 TAD\n1111 = 64 TAD",
    "bit 2-0 ADCS<2:0>: A/D Conversion Clock Select bits\n000 = FOSC/2\n001 = FOSC/8\n010 = FOSC/32\n011 = FRC/4\n100 = FOSC/4\n101 = FOSC/16\n110 = FOSC/64\n111 = FRC (Internal A/D RC Oscillator)\nNote 1: If the A/D RC clock source is selected, a delay of one TCY (instruction cycle) is added before the A/D clock starts. This allows the SLEEP instruction to be executed before starting a conversion.",
    "REGISTER 21-4: ADCON3: A/D CONTROL REGISTER 3\nADRS1, R/W-0 = ADRS0. ADRS1, U-0 = -. ADRS1, R/W-0 = SSRC4 (1). ADRS1, R/W-0 = SSRC3 (1). ADRS1, R/W-0 = SSRC2 (1). ADRS1, R/W-0 = SSRC1 (1). ADRS1, R/W-0 = SSRC0 (1). bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, U-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 21-4: ADCON3: A/D CONTROL REGISTER 3\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-6 ADRS<1:0> : A/D Result Buffer Depth Interrupt Select Control for Continuous Loop Mode bits\nThe ADRS bits are ignored in Single-Shot mode.\n00 = Interrupt is generated when each word is written to the buffer\n01 = Interrupt is generated when the 2nd and 4th words are written to the buffer\n10 = Interrupt is generated when the 4th word is written to the buffer\n11 = Unimplemented bit 5 Unimplemented: Read as ' 0 '\nbit 4-0 SSRC<4:0>: A/D Trigger Source Select bits (1)\n00000 = All triggers disabled xxxx1 = External interrupt RC3/INT0 starts A/D sequence\nxxx1x = Timer5 starts A/D sequence xx1xx = Input Capture 1 (IC1) starts A/D sequence\nx1xxx = CCP2 compare match starts A/D sequence\n1xxxx = Power Control PWM module rising edge starts A/D sequence",
    "bit 7-6 ADRS<1:0> : A/D Result Buffer Depth Interrupt Select Control for Continuous Loop Mode bits\nNote 1: The SSRC<4:0> bits can be set such that any of the triggers will start a conversion (e.g., SSRC<4:0> = 00101 will trigger the A/D conversion sequence when RC3/INT0 or Input Capture 1 event occurs).",
    "REGISTER 21-5: ADCHS: A/D CHANNEL SELECT REGISTER\nGDSEL1, R/W-0 = GDSEL0. GDSEL1, R/W-0 = GBSEL1. GDSEL1, R/W-0 = GBSEL0. GDSEL1, R/W-0 = GCSEL1. GDSEL1, R/W-0 = GCSEL0. GDSEL1, R/W-0 = GASEL1. GDSEL1, R/W-0 = GASEL0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0. bit 7 bit 0, R/W-0 = bit 7 bit 0",
    "REGISTER 21-5: ADCHS: A/D CHANNEL SELECT REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7-6\nGDSEL<1:0> : Group D Select bits\nS/H-2 positive input.\n00 = AN3\n01 = AN7 (1)\n1x = Reserved",
    "bit 5-4\nGBSEL<1:0> : Group B Select bits\nS/H-2 positive input.\n00 = AN1\n01 = AN5 (1)\n1x = Reserved\nbit 3-2\nGCSEL<1:0> : Group C Select bits\nS/H-1 positive input.\n00 = AN2\n01 = AN6 (1)\n1x = Reserved",
    "bit 1-0\nGASEL<1:0> : Group A Select bits\nS/H-1 positive input.\n00 = AN0\n01 = AN4\n10 = AN8 (1)\n11 = Reserved\nNote 1: AN5 through AN8 are available only in PIC18F4331/4431 devices.",
    "REGISTER 21-6: ANSEL0: ANALOG SELECT REGISTER 0 (1)\nANS7 (2), R/W-1 = ANS6 (2). ANS7 (2), R/W-1 = ANS5 (2). ANS7 (2), R/W-1 = ANS4. ANS7 (2), R/W-1 = ANS3. ANS7 (2), R/W-1 = ANS2. ANS7 (2), R/W-1 = ANS1. ANS7 (2), R/W-1 = ANS0. bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = bit 0",
    "REGISTER 21-6: ANSEL0: ANALOG SELECT REGISTER 0 (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-0 ANS<7:0>: Analog Input Function Select bits\nCorrespond to pins, AN<7:0>.\n1 = Analog input\n0 = Digital I/O\nNote 1: Setting a pin to an analog input disables the digital input buffer. The corresponding TRIS bit should be set for an input and cleared for an output (analog or digital). The ANSx bits directly correspond to the ANx pins (e.g., ANS0 = AN0, ANS1 = AN1, etc.). Unused ANSx bits are read as ' 0 '.\n2: ANS7 through ANS5 are available only on PIC18F4331/4431 devices.",
    "REGISTER 21-7: ANSEL1: ANALOG SELECT REGISTER 1 (1)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = ANS8 (2). bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 21-7: ANSEL1: ANALOG SELECT REGISTER 1 (1)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-1 Unimplemented: Read as ' 0 '\nbit 0 ANS8: Analog Input Function Select bit (2)\n1 = Analog input\n0 = Digital I/O\nNote 1: Setting a pin to an analog input disables the digital input buffer. The corresponding TRIS bit should be set for an input and cleared for an output (analog or digital). The ANSx bits directly correspond to the ANx pins (e.g., ANS8 = AN8, ANS9 = AN9, etc.). Unused ANSx bits are read as ' 0 '.\n2: ANS8 is available only on PIC18F4331/4431 devices.",
    "PIC18F2331/2431/4331/4431\nThe A/D channels are grouped into four sets of 2 or 3 channels.  For  the  PIC18F2331/2431  devices,  AN0 and AN4 are in Group A, AN1 is in Group B, AN2 is in Group C and AN3 is in Group D. For the PIC18F4331/ 4431 devices, AN0, AN4 and AN8 are in Group A, AN1 and AN5 are in Group B, AN2 and AN6 are in Group C and AN3 and AN7 are in Group D. The selected channel  in  each  group  is  selected  by  configuring  the  A/D Channel Select Register, ADCHS.\nThe analog voltage reference is software selectable to either the device's positive and negative analog supply voltage (AVDD and AVSS), or the voltage level on the RA3/AN3/VREF+/CAP2/QEA and RA2/AN2/VREF-/ CAP1/INDX,  or  some  combination  of  supply  and external sources. Register ADCON1  controls  the voltage reference settings.",
    "PIC18F2331/2431/4331/4431\nThe A/D Converter has a unique feature of being able to  operate  while  the  device  is  in  Sleep  mode.  To operate  in  Sleep,  the  A/D  conversion  clock  must  be derived from the A/D's internal RC oscillator.\nA device Reset forces all registers to their Reset state. This forces the A/D module to be turned off and any conversion in progress is aborted.\nEach port pin associated with the A/D Converter can individually be configured as an analog input or digital I/O  using  the  ANSEL0  and  ANSEL1  registers.  The ADRESH and ADRESL registers contain the value in the result buffer pointed to by ADPNT<1:0> (ADCON1<1:0>). The result buffer is a 4-deep circular buffer  that  has  a  Buffer  Empty  status  bit,  BFEMT (ADCON1<3>),  and  a  Buffer  Overflow  status  bit, BFOVFL (ADCON1<2>).\nFIGURE 21-1: A/D BLOCK DIAGRAM",
    "21.1 Configuring the A/D Converter\nThe A/D Converter has two types of conversions, two modes  of  operation  and  eight  different  Sequencing modes. These features are controlled by the ACONV bit  (ADCON0<5>),  ACSCH  bit  (ADCON0<4>)  and ACMOD<1:0> bits (ADCON0<3:2>). In addition, the A/D channels are divided into four groups as defined in the ADCHS register. Table 21-1 shows the sequence configurations as controlled by the ACSCH and ACMOD<1:0> bits.\nContinuous Loop mode allows the defined sequence to be executed in a continuous loop when ACONV = 1 . In this  mode,  either  the  user  can  trigger  the  start  of conversion by setting the GO/DONE bit, or one of the A/D triggers can start the conversion. The interrupt flag, ADIF,  is  set  based  on  the  configuration  of  the  bits, ADRS<1:0> (ADCON3<7:6>). In Simultaneous modes, STNM1 and STNM2 acquisition time must be configured to ensure proper conversion of the analog input signals.",
    "21.1.2 CONVERSION MODE\nTwo types of conversions exist in the high-speed 10-bit A/D  Converter  module  that  are  selected  using  the ACONV bit. Single-Shot mode allows a single conversion or sequence to be enabled when ACONV = 0 . At the end of the sequence, the GO/DONE bit will be automatically cleared and the interrupt flag, ADIF, will be set. When using Single-Shot mode and configured for Simultaneous mode, STNM2, acquisition time must be used  to  ensure  proper  conversion  of  the  analog  input signals.\nThe  ACSCH  bit  (ADCON0<4>)  controls  how  many channels are used in the configured sequence. When clear, the A/D is configured for single channel conversion and will convert the group selected by the ACMOD<1:0>  bits  and  the  channel  selected  by  the GxSEL<1:0> bits (ADCHS register). When ACSCH = 1 , the  A/D  is  configured  for  multiple  channel  conversion and the sequence is defined by ACMOD<1:0>.",
    "TABLE 21-1: AUTO-CONVERSION SEQUENCE CONFIGURATIONS\nMulti-Channel Sequential Mode 1 (SEQM1), ACSCH = 1. Multi-Channel Sequential Mode 1 (SEQM1), ACMOD<1:0> = 00. Multi-Channel Sequential Mode 1 (SEQM1), Description = Groups A and B are sampled and converted sequentially.. Multi-Channel Sequential Mode 2 (SEQM2), ACSCH = 1. Multi-Channel Sequential Mode 2 (SEQM2), ACMOD<1:0> = 01. Multi-Channel Sequential Mode 2 (SEQM2), Description = Groups A, B, C and D are sampled and converted sequentially.. Multi-Channel Simultaneous Mode1 (STNM1), ACSCH = 1. Multi-Channel Simultaneous Mode1 (STNM1), ACMOD<1:0> = 10. Multi-Channel Simultaneous Mode1 (STNM1), Description = Groups A and B are sampled simultaneously and converted sequentially.. Multi-Channel Simultaneous Mode2 (STNM2), ACSCH = 1. Multi-Channel Simultaneous Mode2 (STNM2),",
    "TABLE 21-1: AUTO-CONVERSION SEQUENCE CONFIGURATIONS\nACMOD<1:0> = 11. Multi-Channel Simultaneous Mode2 (STNM2), Description = Groups A and B are sampled simultaneously, then converted sequentially. Then, Group C and D are sampled simultaneously, then converted sequentially.. Single Channel Mode 1 (SCM1), ACSCH = 0. Single Channel Mode 1 (SCM1), ACMOD<1:0> = 00. Single Channel Mode 1 (SCM1), Description = Group A is sampled and converted.. Single Channel Mode 2 (SCM2), ACSCH = 0. Single Channel Mode 2 (SCM2), ACMOD<1:0> = 01. Single Channel Mode 2 (SCM2), Description = Group B is sampled and converted.. Single Channel Mode 3 (SCM3), ACSCH = 0. Single Channel Mode 3 (SCM3), ACMOD<1:0> = 10. Single Channel Mode 3 (SCM3), Description = Group C is sampled and converted.. Single Channel Mode 4 (SCM4), ACSCH = 0. Single Channel Mode 4",
    "TABLE 21-1: AUTO-CONVERSION SEQUENCE CONFIGURATIONS\n(SCM4), ACMOD<1:0> = 11. Single Channel Mode 4 (SCM4), Description = Group D is sampled and converted.",
    "21.1.3 CONVERSION SEQUENCING\nThe ACMOD<1:0> bits control the sequencing of the A/D  conversions.  When  ACSCH  = 0 , the  A/D  is configured to sample and convert a single channel. The ACMOD bits select which group to perform the conversions  and  the  GxSEL<1:0>  bits  select  which channel in the group is to be converted. If Single-Shot mode is enabled, the A/D interrupt flag will be set after the channel is converted. If Continuous Loop mode is enabled, the A/D interrupt flag will be set according to the ADRS<1:0> bits.\nWhen  ACSCH  = 1 , multiple  channel  sequencing  is enabled and two submodes can be selected. The first mode is Sequential mode with two settings. The first setting is called SEQM1, and first samples and converts the selected  Group  A  channel,  and  then  samples  and converts  the  selected  Group  B  channel.  The  second mode is called SEQM2, and it samples and converts a Group A channel, Group B channel, Group C channel and finally, a Group D channel.",
    "21.1.3 CONVERSION SEQUENCING\nThe second multiple channel sequencing submode is Simultaneous Sampling mode. In this mode, there are also two settings. The first setting is called STNM1, and uses  the  two  sample  and  hold  circuits  on  the  A/D module.  The  selected  Group  A  and  B  channels  are simultaneously sampled and then the Group A channel is converted followed by the conversion of the Group B channel.  The  second  setting  is  called  STNM2,  and starts  the  same  as  STNM1,  but  follows  it  with  a simultaneous sample of Group C and D channels. The A/D  module  will  then  convert  the  Group  C  channel followed by the Group D channel.",
    "21.1.4 TRIGGERING A/D CONVERSIONS\nThe PIC18F2331/2431/4331/4431 devices are capable of triggering conversions from many different sources. The same method used by all other microcontrollers of setting the GO/DONE bit still works. The other trigger sources are:\n\u00b7 RC3/INT0 Pin\n\u00b7 Timer5 Overflow\n\u00b7 Input Capture 1 (IC1)\n\u00b7 CCP2 Compare Match\n\u00b7 Power Control PWM Rising Edge\nThese triggers are enabled using the SSRC<4:0> bits (ADCON3<4:0>). Any combination of the five sources can trigger  a  conversion by  simply  setting  the  corresponding bit in ADCON3. When the trigger occurs, the GO/DONE bit is automatically set by the hardware and then cleared once the conversion completes.",
    "21.1.5 A/D MODULE INITIALIZATION STEPS\nThe following steps should be followed to initialize the A/D module:",
    "21.1.5 A/D MODULE INITIALIZATION STEPS\n1. Configure the A/D module:\na) Configure the analog pins, voltage reference and digital I/O.\nb) Select the A/D input channels.\nc) Select the A/D Auto-Conversion mode (Single-Shot or Continuous Loop).\nd) Select the A/D conversion clock.\ne) Select the A/D conversion trigger.\n2. Configure the A/D interrupt (if required):\na) Set the GIE bit.\nb) Set the PEIE bit.\nc) Set the ADIE bit.\nd) Clear the ADIF bit.\ne) Select the A/D trigger setting.\nf) Select the A/D interrupt priority.\n3. Turn on ADC:\na) Set the ADON bit in the ADCON0 register.\nb) Wait  the  required  power-up  setup  time, about 5-10 \uf06d s.\n4. Start the sample/conversion sequence:\na) Sample for a minimum of 2 TAD and start the conversion by setting the GO/DONE bit. The  GO/DONE  bit  is  set  by  the  user  in software or by the module if initiated by a trigger.",
    "21.1.5 A/D MODULE INITIALIZATION STEPS\nb) If T ACQ is assigned a value (multiple of TAD), then  setting  the  GO/DONE  bit  starts  a sample period of the TACQ value, then starts a conversion.\n5. Wait for A/D conversion/conversions to complete using one of the following options:\na) Poll for the GO/DONE bit to be cleared if in Single-Shot mode.\nb) Wait for the A/D Interrupt Flag (ADIF) to be set.\nc) Poll  for  the  BFEMT  bit  to  be  cleared  to signify that at least the first conversion has completed.\n6. Read  the  A/D  results,  clear  the  ADIF  flag, reconfigure the trigger.",
    "21.3 A/D Acquisition Requirements\nThe  A/D  module  has  a  4-level  result  buffer  with  an address range of 0 to 3, enabled by setting the FIFOEN bit in the ADCON1 register. This buffer is implemented in a circular fashion, where the A/D result is stored in one  location  and  the  address  is  incremented.  If  the address is greater than 3, the pointer is wrapped back around to 0. The result buffer has a Buffer Empty Flag, BFEMT, indicating when any data is in the buffer. It also has a Buffer Overflow Flag, BFOVFL, which indicates when a new sample has overwritten a location that was not previously read.\nAssociated with the buffer is a pointer to the address for the next read operation. The ADPNT<1:0>  bits configure  the  address  for  the  next  read  operation. These bits are read-only.",
    "21.3 A/D Acquisition Requirements\nThe  Result  Buffer  also  has  a  configurable  interrupt trigger level that is configured by the ADRS<1:0> bits. The  user  has  three  selections:  interrupt  flag  set  on every write to the buffer, interrupt on every second write to  the  buffer,  or  interrupt  on  every  fourth  write  to  the buffer.  ADPNT<1:0>  are  reset  to  ' 00 ' every  time  a conversion sequence is started (either by setting the GO/DONE bit or on a trigger).\nNote:\nWhen  right  justified, reading  ADRESL increments  the  ADPNT<1:0> bits.  When left justified, reading ADRESH increments the ADPNT<1:0> bits.",
    "21.3 A/D Acquisition Requirements\nFor the A/D Converter to meet its specified accuracy, the charge holding capacitor (CHOLD) must be allowed to fully charge to the input channel voltage level. The analog  input  model  is  shown  in  Figure 21-2.  The source  impedance  (RS)  and  the  internal  sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD. The sampling switch (RSS) impedance varies over the device voltage (VDD). The source impedance affects the offset voltage at the analog input (due to pin leakage current). The maximum  recommended  impedance  for  analog sources is 2.5 k \uf057 .  After the analog input channel is selected (changed), the channel must be sampled for at least the minimum acquisition time before starting a conversion.\nNote:\nWhen  the conversion is started, the holding capacitor is disconnected from the input pin.\nTo calculate the minimum acquisition time, Equation 21-1  may be  used.  This  equation  assumes that 1/2 LSb error is used (1024 steps for the A/D). The 1/2 LSb error is the maximum error allowed for the A/D to meet its specified resolution.",
    "21.3 A/D Acquisition Requirements\nExample 21-1 shows the calculation  of  the  minimum required acquisition time TACQ.  In this case,  the converter module is fully powered up at the outset and therefore, the amplifier settling time, TAMP, is negligible. This calculation is based on the following application system assumptions:\nCHOLD\n= 9 pF\nRs\n= 100 \uf057\uf020\nConversion Error\n\uf0a3 1/2 LSb\nVDD\n= 5V \uf0ae Rss = 6 k \uf057\nTemperature\n= 50\u00b0C (system max.)\nVHOLD\n= 0V @ time = 0",
    "EQUATION 21-1: ACQUISITION TIME\nTACQ = Amplifier Settling Time + Holding Capacitor Charging Time + Temperature Coefficient\n= TAMP + TC + TCOFF",
    "EQUATION 21-2: MINIMUM A/D HOLDING CAPACITOR CHARGING TIME\nVHOLD\n=\n(VREF - (VREF/2048)) \u2022 (1 - e (-TC/CHOLD(RIC + RSS + RS)) )\nor\nTC\n=\n-(CHOLD)(RIC + RSS + RS) ln(1/2048)",
    "EXAMPLE 21-1: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\n```\nTACQ = TAMP + TC + TCOFF TAMP = Negligible TCOFF = (Temp - 25\u00b0C)(0.005 \uf06d s/\u00b0C) (50\u00b0C - 25\u00b0C)(0.005 \uf06d s/\u00b0C) = .13 \uf06d s Temperature coefficient is only required for temperatures > 25\u00b0C. Below 25\u00b0C, TCOFF = 0 \uf06d s. TC = -(CHOLD) (RIC + RSS + RS) ln(1/2047) \uf06d s -(9 pF) (1 k \uf057 + 6 k \uf057 + 100 \uf057 ) ln(0.0004883) \uf06d s = .49 \uf06d s TACQ = 0 + .49 \uf06d s + .13 \uf06d s = .62 \uf06d s Note: If the converter module has been in Sleep mode, TAMP is 2.0 \uf06d s from the time the part exits Sleep mode.\n```",
    "21.4 A/D Voltage References\nIf  external voltage references are used instead of the internal AVDD and AVSS sources, the source impedance  of  the  VREF+  and  VREF-  voltage  sources must be considered. During acquisition, currents supplied by these sources are insignificant. However, during conversion, the A/D module sinks and sources current through the reference sources.\nIn  order  to  maintain  the  A/D  accuracy,  the  voltage reference  source  impedances  should  be  kept  low  to reduce voltage changes. These voltage changes occur as  reference  currents flow through  the  reference source impedance.\nNote: When using external references, the source impedance of the external voltage references must be less than 75 \uf057 in order to achieve the specified ADC resolution. A higher  reference  source  impedance  will increase  the  ADC  offset  and  gain  errors. Resistive voltage dividers will not provide a low enough source impedance. To ensure the best possible ADC performance, external VREF inputs should be buffered with an op amp or other low-impedance circuit.",
    "21.5 Selecting and Configuring Automatic Acquisition Time\nThe ADCON2 register allows the user to select an acquisition time that occurs each time an A/D conversion is triggered.\nIf desired,  the  ACQT  bits  can  be  set  to  select  a programmable  acquisition  time  for  the  A/D  module. When triggered, the A/D module continues to sample the input for the selected acquisition time, then automatically begins a conversion. Since the acquisition time is programmed, there may be no need to  wait  for  an  acquisition  time  between  selecting  a channel and triggering the A/D. If an acquisition time is programmed, there is nothing to indicate if the acquisition  time  has  ended  or  if  the  conversion  has begun.",
    "21.6 Selecting the A/D Conversion Clock\nThe A/D conversion time per bit is defined as TAD. The A/D conversion requires 12 TAD per 10-bit conversion. The  source  of  the  A/D  conversion  clock  is  software selectable. There are eight possible options for TAD:\n\u00b7 2 TOSC\n\u00b7 4 TOSC\n\u00b7 8 TOSC\n\u00b7 16 TOSC\n\u00b7 32 TOSC\n\u00b7 64 TOSC\n\u00b7 Internal RC Oscillator\n\u00b7 Internal RC Oscillator/4\nFor correct A/D conversions, the A/D conversion clock (TAD) must be as short as possible, but greater than the minimum  TAD  (approximately  416 ns,  see  parameter A11 for more information).\nWhen the GO/DONE bit is set, sampling is stopped and a conversion begins. The user is responsible for ensuring the required acquisition time has  passed  between selecting  the  desired  input  channel  and  the  start  of conversion.  This  occurs  when  the  ACQT<3:0>  bits (ADCON2<6:3>) remain in their Reset state (' 0000 ').\nTable 21-2 shows the resultant TAD times derived from the  device  operating  frequencies  and  the  A/D  clock source selected.",
    "TABLE 21-2: TAD vs. DEVICE OPERATING FREQUENCIES\n2 T OSC, AD Clock Source (T AD).ADCS<2:0> = 000. 2 T OSC, Maximum Device Frequency.PIC18FXX31 = 4.8 MHz. 2 T OSC, Maximum Device Frequency.PIC18LFXX31 (4) = 666 kHz. 4 T OSC, AD Clock Source (T AD).ADCS<2:0> = 100. 4 T OSC, Maximum Device Frequency.PIC18FXX31 = 9.6 MHz. 4 T OSC, Maximum Device Frequency.PIC18LFXX31 (4) = 1.33 MHz. 8 T OSC, AD Clock Source (T AD).ADCS<2:0> = 001. 8 T OSC, Maximum Device Frequency.PIC18FXX31 = 19.2 MHz. 8 T OSC, Maximum Device Frequency.PIC18LFXX31 (4) = 2.66 MHz. 16 T OSC, AD Clock Source (T AD).ADCS<2:0> = 101. 16 T OSC, Maximum Device Frequency.PIC18FXX31 = 38.4 MHz. 16 T OSC,",
    "TABLE 21-2: TAD vs. DEVICE OPERATING FREQUENCIES\nMaximum Device Frequency.PIC18LFXX31 (4) = 5.33 MHz. 32 T OSC, AD Clock Source (T AD).ADCS<2:0> = 010. 32 T OSC, Maximum Device Frequency.PIC18FXX31 = 40.0 MHz. 32 T OSC, Maximum Device Frequency.PIC18LFXX31 (4) = 10.65 MHz. 64 T OSC, AD Clock Source (T AD).ADCS<2:0> = 110. 64 T OSC, Maximum Device Frequency.PIC18FXX31 = 40.0 MHz. 64 T OSC, Maximum Device Frequency.PIC18LFXX31 (4) = 21.33 MHz. RC/4 (3), AD Clock Source (T AD).ADCS<2:0> = 011. RC/4 (3), Maximum Device Frequency.PIC18FXX31 = 1.00 MHz (1). RC/4 (3), Maximum Device Frequency.PIC18LFXX31 (4) = 1.00 MHz (2). RC (3), AD Clock Source (T",
    "TABLE 21-2: TAD vs. DEVICE OPERATING FREQUENCIES\nAD).ADCS<2:0> = 111. RC (3), Maximum Device Frequency.PIC18FXX31 = 4.0 MHz (2). RC (3), Maximum Device Frequency.PIC18LFXX31 (4) = 4.0 MHz (2)\nNote\n1: The RC source has a typical TAD time of 2-6 \uf06d s.\n2: The RC source has a typical TAD time of 0.5-1.5 \uf06d s.\n3: For device frequencies above 1 MHz, the device must be in Sleep for the entire conversion or the A/D accuracy may be out of specification unless in Single-Shot mode.\n4: Low-power devices only.",
    "21.8 Configuring Analog Port Pins\nThe selection of the automatic acquisition time and A/D conversion  clock  is  determined  in  part  by  the  clock source and frequency while in a power-managed mode.\nIf the A/D is expected to operate while the device is in a power-managed mode, the ACQT<3:0> and ADCS<2:0>  bits  in  ADCON2  should  be  updated  in accordance with the power-managed mode clock that will be used. After the power-managed mode is entered (either  of  the  power-managed  Run  modes),  an  A/D acquisition  or  conversion  may  be  started.  Once  an acquisition or conversion is started, the device should continue to be clocked by the same power-managed mode clock source until the conversion has been completed. If  desired,  the  device  may  be  placed into  the corresponding  power-managed  Idle  mode  during  the conversion.\nIf  the  power-managed  mode  clock  frequency  is  less than  1 MHz,  the  A/D  RC  clock  source  should  be selected.",
    "21.8 Configuring Analog Port Pins\nOperation in Sleep mode requires the A/D RC clock to be selected. If bits, ACQT<3:0>, are set to ' 0000 ' and a conversion is started, the conversion will be delayed one instruction cycle to allow execution of the SLEEP instruction and entry to Sleep mode. The IDLEN and SCS bits in the OSCCON register must have already been cleared prior to starting the conversion.\nNote:\nThe A/D can operate in Sleep mode only when configured for Single-Shot mode. If the part is in Sleep mode, and it is possible for a source other than the A/D module to wake the part, the user must poll ADCON0<GO/DONE> to ensure it is clear before reading the result.\nThe ANSEL0, ANSEL1, TRISA and TRISE registers all configure the A/D port pins. The port pins needed as analog inputs must have their corresponding TRIS bits set (input). If the TRIS bit is cleared (output), the digital output level (VOH or VOL) will be converted.",
    "21.8 Configuring Analog Port Pins\nThe A/D operation is independent of the state of the ANSEL0, ANSEL1 and TRIS bits.\nNote 1: When reading the PORT register, all pins configured as analog input channels will read as cleared (a low level). Pins configured as digital inputs will convert an analog input. Analog levels on a digitally configured input will be accurately converted.\n2: Analog  levels  on  any  pin  defined  as  a digital  input  may  cause  the  digital  input buffer  to  consume  current  out  of  the device's specification limits.",
    "21.9 A/D Conversions\nFigure 21-3 shows the operation of the A/D Converter after the GO/DONE  bit has been set and the ACQT<2:0> bits are cleared. A conversion is started after the following instruction to allow entry into Sleep mode before the conversion begins. The internal A/D RC oscillator must be selected to perform a conversion in Sleep.\nClearing  the  GO/DONE  bit  during  a  conversion  will abort the current conversion. The resulting buffer location will contain the partially completed A/D conversion sample. This will not set the ADIF flag, therefore, the user must read the buffer location before a conversion sequence overwrites it.\nFigure 21-4  shows  the  operation of the A/D Converter after  the GO/DONE bit has been set, the ACQT<3:0> bits  are  set  to  ' 010 '  and  a  4  T AD  acquisition  time  is selected before the conversion starts.\nAfter  the  A/D  conversion  is  completed  or  aborted,  a 2 TAD wait is required before the next acquisition can be started.  After  this  wait,  acquisition  on  the  selected channel is automatically started.\nNote:",
    "21.9 A/D Conversions\nThe GO/DONE bit should NOT be set in the same instruction that turns on the A/D.",
    "FIGURE 21-4: A/D CONVERSION TAD CYCLES   (ACQT<3:0> = 0010 , TACQ = 4 TAD)\nNote 1: In Continuous modes, next conversion starts at the end of TAD12.",
    "21.9.1 A/D RESULT REGISTER\nThe  ADRESH:ADRESL  register  pair  is  the  location where the 10-bit A/D result is loaded at the completion of the A/D conversion. This register pair is 16 bits wide. The A/D module gives the flexibility to left or right justify the 10-bit result in  the 16-bit  result register.  The A/D\nFormat  Select  bit  (ADFM)  controls  this  justification. Figure 21-5  shows  the  operation  of  the  A/D  result justification. The extra bits are loaded with ' 0 's. When an  A/D  result  will  not  overwrite  these  locations  (A/D disable), these registers may be used as two general purpose 8-bit registers.",
    "EQUATION 21-3: CONVERSION TIME FOR MULTI-CHANNEL MODES\nSequential Mode:\nT = (TACQ) A + (TCON) A  + [(TACQ) B  - 12 TAD] + (TCON) B  + [(TACQ) C  - 12 TAD] + (TCON) C  + [(TACQ) D  - 12 TAD] + (TCON) D\nSimultaneous Mode:\nT = TACQ + (TCON) A  + (TCON) B  + TACQ + (TCON) C  + (TCON) D",
    "TABLE 21-3: SUMMARY OF A/D REGISTERS\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Reset Values on Page: = 54. PIR1, Bit 7 = -. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Reset Values on Page: = 57. PIE1, Bit 7 = -. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit",
    "TABLE 21-3: SUMMARY OF A/D REGISTERS\n2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Reset Values on Page: = 57. IPR1, Bit 7 = -. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Reset Values on Page: = 57. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = -. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = -. PIR2, Bit 0 = CCP2IF. PIR2, Reset Values on Page: = 57. PIE2, Bit 7 =",
    "TABLE 21-3: SUMMARY OF A/D REGISTERS\nOSCFIE. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = -. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = -. PIE2, Bit 0 = CCP2IE. PIE2, Reset Values on Page: = 57. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = -. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = -. IPR2, Bit 0 = CCP2IP. IPR2, Reset Values on Page: = 57. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit",
    "TABLE 21-3: SUMMARY OF A/D REGISTERS\n2 = A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte. ADRESH, Reset Values on Page: = 56. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Reset Values on Page: = 56. ADCON0, Bit 7 = -. ADCON0, Bit 6 = -. ADCON0, Bit 5 = ACONV. ADCON0, Bit 4 = ACSCH. ADCON0, Bit 3 = ACMOD1. ADCON0, Bit 2 = ACMOD0.",
    "TABLE 21-3: SUMMARY OF A/D REGISTERS\nADCON0, Bit 1 = GO/DONE. ADCON0, Bit 0 = ADON. ADCON0, Reset Values on Page: = 56. ADCON1, Bit 7 = VCFG1. ADCON1, Bit 6 = VCFG0. ADCON1, Bit 5 = -. ADCON1, Bit 4 = FIFOEN. ADCON1, Bit 3 = BFEMT. ADCON1, Bit 2 = BFOVFL. ADCON1, Bit 1 = ADPNT1. ADCON1, Bit 0 = ADPNT0. ADCON1, Reset Values on Page: = 56. ADCON2, Bit 7 = ADFM. ADCON2, Bit 6 = ACQT3. ADCON2, Bit 5 = ACQT2. ADCON2, Bit 4 = ACQT1. ADCON2, Bit 3 = ACQT0. ADCON2, Bit 2 = ADCS2. ADCON2, Bit 1 = ADCS1. ADCON2, Bit 0 = ADCS0. ADCON2, Reset Values on Page: = 56. ADCON3, Bit 7 =",
    "TABLE 21-3: SUMMARY OF A/D REGISTERS\nADRS1. ADCON3, Bit 6 = ADRS0. ADCON3, Bit 5 = -. ADCON3, Bit 4 = SSRC4. ADCON3, Bit 3 = SSRC3. ADCON3, Bit 2 = SSRC2. ADCON3, Bit 1 = SSRC1. ADCON3, Bit 0 = SSRC0. ADCON3, Reset Values on Page: = 56. ADCHS, Bit 7 = GDSEL1. ADCHS, Bit 6 = GDSEL0. ADCHS, Bit 5 = GBSEL1. ADCHS, Bit 4 = GBSEL0. ADCHS, Bit 3 = GCSEL1. ADCHS, Bit 2 = GCSEL0. ADCHS, Bit 1 = GASEL1. ADCHS, Bit 0 = GASEL0. ADCHS, Reset Values on Page: = 56. ANSEL0, Bit 7 = ANS7 (6). ANSEL0, Bit 6 = ANS6 (6). ANSEL0, Bit 5 = ANS5 (6). ANSEL0, Bit 4 = ANS4. ANSEL0, Bit 3",
    "TABLE 21-3: SUMMARY OF A/D REGISTERS\n= ANS3. ANSEL0, Bit 2 = ANS2. ANSEL0, Bit 1 = ANS1. ANSEL0, Bit 0 = ANS0. ANSEL0, Reset Values on Page: = 56. ANSEL1, Bit 7 = -. ANSEL1, Bit 6 = -. ANSEL1, Bit 5 = -. ANSEL1, Bit 4 = -. ANSEL1, Bit 3 = -. ANSEL1, Bit 2 = -. ANSEL1, Bit 1 = -. ANSEL1, Bit 0 = ANS8 (5). ANSEL1, Reset Values on Page: = 56. PORTA, Bit 7 = RA7 (4). PORTA, Bit 6 = RA6 (4). PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Reset Values on Page: = 57. TRISA, Bit 7 = TRISA7 (4). TRISA, Bit",
    "TABLE 21-3: SUMMARY OF A/D REGISTERS\n6 = TRISA6 (4). TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Reset Values on Page: = 57. PORTE (2), Bit 7 = -. PORTE (2), Bit 6 = -. PORTE (2), Bit 5 = -. PORTE (2), Bit 4 = -. PORTE (2), Bit 3 = RE3 (1,3). PORTE (2), Bit 2 = RA2 (3). PORTE (2), Bit 1 = RA1 (3). PORTE (2), Bit 0 = RA0 (3). PORTE (2), Reset Values on Page: = 57. TRISE (3), Bit 7 = -. TRISE (3), Bit 6 = -. TRISE (3), Bit 5 = -. TRISE (3), Bit 4 =",
    "TABLE 21-3: SUMMARY OF A/D REGISTERS\n-. TRISE (3), Bit 3 = -. TRISE (3), Bit 2 = PORTE Data Direction Register. TRISE (3), Bit 1 = PORTE Data Direction Register. TRISE (3), Bit 0 = PORTE Data Direction Register. TRISE (3), Reset Values on Page: = 57. LATE (3), Bit 7 = -. LATE (3), Bit 6 = -. LATE (3), Bit 5 = -. LATE (3), Bit 4 = -. LATE (3), Bit 3 = -. LATE (3), Bit 2 = LATE Data Output Register. LATE (3), Bit 1 = LATE Data Output Register. LATE (3), Bit 0 = LATE Data Output Register. LATE (3), Reset Values on Page: = 57\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are not used for A/D conversion.",
    "TABLE 21-3: SUMMARY OF A/D REGISTERS\nNote 1:\nThe RE3 port bit is available only as an input pin when the MCLRE bit in the CONFIG3H register is ' 0 '.\n2: This register is not implemented on PIC18F2331/2431 devices.\n3: These bits are not implemented on PIC18F2331/2431 devices.\n4: These pins may be configured as port pins depending on the oscillator mode selected.\n5: ANS5 through ANS8 are available only on the PIC18F4331/4431 devices.\n6: Not available on 28-pin devices.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "22.0 LOW-VOLTAGE DETECT (LVD)\nPIC18F2331/2431/4331/4431  devices  have  a  LowVoltage Detect module (LVD), a programmable circuit that enables the user to specify a device voltage trip point. If the device experiences an excursion below the trip  point,  an  interrupt  flag  is  set.  If  the  interrupt  is enabled, the program execution will branch to the interrupt vector address and the software can then respond to the interrupt.\nThe  block  diagram  for  the  LVD  module  is  shown  in Figure 22-1.\nThe module is enabled by setting the LVDEN bit, but the circuitry requires some time to stabilize each time that it is enabled. The IRVST bit is a read-only bit used to indicate when the circuit is stable. The module can only generate an interrupt after the circuit is stable and the IRVST bit is set. The module monitors for drops in VDD below a predetermined set point.\nThe Low-Voltage Detect Control register (Register 22-1) completely  controls  the  operation  of  the  LVD  module. This allows the circuitry to be 'turned off' by the user under  software  control,  which  minimizes  the  current consumption for the device.",
    "REGISTER 22-1: LVDCON: LOW-VOLTAGE DETECT CONTROL REGISTER\n-, U-0 = -. -, R-0 = IRVST. -, R/W-0 = LVDEN. -, R/W-0 = LVDL3 (1). -, R/W-1 = LVDL2 (1). -, R/W-0 = LVDL1 (1). -, R/W-1 = LVDL0 (1). bit 7, U-0 = bit 7. bit 7, R-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-1 = bit 7. bit 7, R/W-0 = bit 7. bit 7, R/W-1 = bit 0",
    "REGISTER 22-1: LVDCON: LOW-VOLTAGE DETECT CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5\nIRVST: Internal Reference Voltage Stable Flag bit\n1 = Indicates that the Low-Voltage Detect logic will generate the interrupt flag at the specified voltage range\n0 = Indicates that the Low-Voltage Detect logic will not generate the  interrupt flag at the specified voltage range and the LVD interrupt should not be enabled\nbit 4\nLVDEN: Low-Voltage Detect Power Enable bit\n1 = Enables LVD, powers up LVD circuit\n0 = Disables LVD, powers down LVD circuit\nbit 3-0\nLVDL<3:0>: Low-Voltage Detection Limit bits (1)\n1111 = External analog input is used (input comes from the LVDIN pin)\n1110 = Maximum setting\n.\n.\n.\n0010 = Minimum setting\n0001 = Reserved\n0000 = Reserved\nNote 1: LVDL<3:0> bit modes, which result in a trip point below the valid operating voltage of the device, are not tested.",
    "22.2 LVD Setup\nWhen the LVD module is enabled, a comparator uses an  internally  generated  reference  voltage  as  the  set point.  The  set  point  is  compared  with  the  trip  point, where each node in the resistor divider represents a trip point voltage. The 'trip point' voltage is the voltage level at which the device detects a low-voltage event, depending on the configuration of the module. When the supply voltage is equal to the trip point, the voltage tapped off of the resistor array is equal to the internal reference voltage generated by the voltage reference module. The comparator then generates an interrupt signal by setting the LVDIF bit.\nThe trip point voltage is software programmable to any one  of 16  values, selected by programming  the LVDL<3:0> bits (LVDCON<3:0>).",
    "22.2 LVD Setup\nThe LVD module has an additional feature that allows the user to supply the trip voltage to the module from an external  source.  This  mode  is  enabled  when  bits, LVDL<3:0>, are set to ' 1111 '. In this state, the comparator  input  is  multiplexed  from  the  external  input  pin, LVDIN.  This  gives  users  flexibility  because  it  allows them to configure the Low-Voltage Detect interrupt to occur at any voltage in the valid operating range.\nThe  following  steps  are  needed  to  set  up  the  LVD module:\n1. Disable the module by clearing the LVDEN bit (LVDCON<4>).\n2. Write  the  value  to  the  LVDL<3:0>  bits  that selects the desired LVD trip point.\n3. Enable the LVD module by setting the LVDEN bit.\n4. Clear  the  LVD  interrupt  flag  (PIR2<2>),  which may have been set from a previous interrupt.\n5. Enable the LVD  interrupt, if interrupts are desired,  by  setting  the  LVDIE  and  GIE  bits (PIE<2> and INTCON<7>).",
    "22.2 LVD Setup\nAn interrupt will not be generated until the IRVST bit is set.",
    "22.3 Current Consumption\nWhen the module is enabled, the LVD comparator and voltage divider are enabled and will consume static current. The total current consumption, when enabled, is specified in electrical specification Parameter D022B.\nDepending on the application, the LVD module does not need to be operating constantly. To decrease the current requirements, the LVD circuitry may only need to  be  enabled for  short  periods  where  the  voltage  is checked. After doing the check, the LVD module may be disabled.",
    "22.4 LVD Start-up Time\nThe  internal  reference  voltage  of  the  LVD  module, specified  in  electrical  specification  Parameter  D420, may be  used  by  other  internal  circuitry,  such  as  the Programmable Brown-out Reset. If the LVD, or other circuits  using  the  voltage  reference,  are  disabled  to lower the device's current consumption, the reference voltage circuit will require time to become stable before a low-voltage condition can be reliably detected. This start-up time, TIRVST, is an interval that is independent of  device  clock  speed.  It  is  specified  in  electrical specification Parameter 36.\nThe LVD interrupt flag is not enabled until TIRVST has expired and a stable reference voltage is reached. For this reason, brief excursions beyond the set point may not be detected during this interval (refer to Figure 22-2).",
    "22.7 Applications\nWhen enabled, the LVD circuitry continues to operate during  Sleep.  If  the  device  voltage  crosses  the  trip point, the LVDIF bit will be set and the device will wakeup from Sleep. Device execution will continue from the interrupt vector address if interrupts have been globally enabled.",
    "22.6 Effects of a Reset\nA device Reset forces all registers to their Reset state. This forces the LVD module to be turned off.\nFigure 22-3 shows a possible application voltage curve (typically for batteries). Over time, the device voltage decreases.  When  the  device  voltage  equals  voltage, VA, the LVD logic generates an interrupt. This occurs at time, TA. The application software then has the time, until the device voltage is no longer in valid operating range,  to  perform  'housekeeping  tasks'  and  to  shut down the system. Voltage point, VB, is the minimum valid  operating  voltage  specification.  This  occurs  at time, TB. The difference, TB - TA, is the total time for shutdown.\nFIGURE 22-3: TYPICAL LOW-VOLTAGE DETECT APPLICATION",
    "TABLE 22-1: REGISTERS ASSOCIATED WITH LOW-VOLTAGE DETECT MODULE\nLVDCON, Bit 7 = -. LVDCON, Bit 6 = -. LVDCON, Bit 5 = IRVST. LVDCON, Bit 4 = LVDEN. LVDCON, Bit 3 = LVDL3. LVDCON, Bit 2 = LVDL2. LVDCON, Bit 1 = LVDL1. LVDCON, Bit 0 = LVDL0. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. IPR2, Bit 7 = OSCFIP. IPR2, Bit 6 = -. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = -. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = -.",
    "TABLE 22-1: REGISTERS ASSOCIATED WITH LOW-VOLTAGE DETECT MODULE\nIPR2, Bit 0 = CCP2IP. PIR2, Bit 7 = OSCFIF. PIR2, Bit 6 = -. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = -. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = -. PIR2, Bit 0 = CCP2IF. PIE2, Bit 7 = OSCFIE. PIE2, Bit 6 = -. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = -. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = -. PIE2, Bit 0 = CCP2IE\nLegend: - = unimplemented, read as ' 0 '. Shaded cells are unused by the LVD module.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "23.1 Configuration Bits\nPIC18F2331/2431/4331/4431  devices  include  several features intended to maximize system reliability and minimize cost through elimination of external components. These are:\n\u00b7 Oscillator Selection\n\u00b7 Resets:\n-Power-on Reset (POR)\n-Power-up Timer (PWRT)\n-Oscillator Start-up Timer (OST)\n-Brown-out Reset (BOR)\n\u00b7 Interrupts\n\u00b7 Watchdog Timer (WDT)\n\u00b7 Fail-Safe Clock Monitor\n\u00b7 Two-Speed Start-up\n\u00b7 Code Protection\n\u00b7 ID Locations\n\u00b7 In-Circuit Serial Programming\u2122 (ICSP\u2122)\nThe  oscillator  can  be  configured  for  the  application depending on frequency, power, accuracy and cost. All of  the  options  are  discussed  in  detail  in Section 3.0 'Oscillator Configurations' .\nA complete discussion of device Resets and interrupts is available in previous sections of this data sheet.",
    "23.1 Configuration Bits\nIn  addition  to  their  Power-up  and  Oscillator  Start-up Timers provided for Resets,  PIC18F2331/2431/4331/ 4431 devices have a Watchdog Timer, which is either permanently  enabled  via  the  Configuration  bits,  or software-controlled (if configured as disabled).\nThe inclusion of an internal RC oscillator also provides the  additional  benefits  of  a  Fail-Safe  Clock  Monitor (FSCM) and Two-Speed Start-up. FSCM provides for background  monitoring  of  the  peripheral  clock  and automatic switchover in the event of its failure.  TwoSpeed Start-up  enables  code  to  be  executed  almost immediately on start-up, while the primary clock source completes its start-up delays.\nAll  of  these  features  are  enabled  and  configured  by setting the appropriate Configuration register bits.\nThe Configuration bits  can  be  programmed  (read  as ' 0 '), or  left  unprogrammed  (read  as  ' 1 '), to  select various device configurations. These bits are mapped starting at program memory location 300000h.",
    "23.1 Configuration Bits\nThe user will note that address 300000h is beyond the user program memory space. In fact, it belongs to the configuration memory space (300000h-3FFFFFh), which  can  only  be  accessed  using  table  reads  and table writes.\nProgramming the Configuration registers is done in a manner similar to programming the Flash memory. The EECON1 register WR bit starts a self-timed write to the Configuration  register.  In  normal  operation  mode,  a TBLWT instruction  with  the  TBLPTR  pointing  to  the Configuration register sets up the address and the data for the Configuration register write. Setting the WR bit starts  a  long write  to  the  Configuration  register.  The Configuration registers are written a byte at a time. To write or erase a configuration cell, a TBLWT instruction can write a ' 1 ' or a ' 0 ' into the cell. For additional details on Flash programming, refer to Section 8.5 'Writing to Flash Program Memory' .",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\n300000h, File Name = CONFIG1L. 300000h, Bit 7 = -. 300000h, Bit 6 = -. 300000h, Bit 5 = -. 300000h, Bit 4 = -. 300000h, Bit 3 = -. 300000h, Bit 2 = -. 300000h, Bit 1 = -. 300000h, Bit 0 = -. 300000h, Default/ Unprogrammed Value = ---- ----. 300000h, Default/ Unprogrammed Value = ---- ----. 300001h, File Name = CONFIG1H. 300001h, Bit 7 = IESO. 300001h, Bit 6 = FCMEN. 300001h, Bit 5 = -. 300001h, Bit 4 = -. 300001h, Bit 3 = FOSC3. 300001h, Bit 2 = FOSC2. 300001h, Bit 1 = FOSC1. 300001h, Bit 0 = FOSC0. 300001h, Default/ Unprogrammed Value = 11-- 1111.",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\n300001h, Default/ Unprogrammed Value = 11-- 1111. 300002h, File Name = CONFIG2L. 300002h, Bit 7 = -. 300002h, Bit 6 = -. 300002h, Bit 5 = -. 300002h, Bit 4 = -. 300002h, Bit 3 = BORV1. 300002h, Bit 2 = BORV0. 300002h, Bit 1 = BOREN. 300002h, Bit 0 = PWRTEN. 300002h, Default/ Unprogrammed Value = ---- 1111. 300002h, Default/ Unprogrammed Value = ---- 1111. 300003h, File Name = CONFIG2H. 300003h, Bit 7 = -. 300003h, Bit 6 = -. 300003h, Bit 5 = WINEN. 300003h, Bit 4 = WDTPS3. 300003h, Bit 3 = WDTPS2. 300003h, Bit 2 = WDTPS1.",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\n300003h, Bit 1 = WDTPS0. 300003h, Bit 0 = WDTEN. 300003h, Default/ Unprogrammed Value = --11 1111. 300003h, Default/ Unprogrammed Value = --11 1111. 300004h, File Name = CONFIG3L. 300004h, Bit 7 = -. 300004h, Bit 6 = -. 300004h, Bit 5 = T1OSCMX. 300004h, Bit 4 = HPOL. 300004h, Bit 3 = LPOL. 300004h, Bit 2 = PWMPIN. 300004h, Bit 1 = -. 300004h, Bit 0 = -. 300004h, Default/ Unprogrammed Value = --11 11--. 300004h, Default/ Unprogrammed Value = --11 11--. 300005h, File Name = CONFIG3H. 300005h, Bit 7 = MCLRE (1). 300005h, Bit 6 = -.",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\n300005h, Bit 5 = -. 300005h, Bit 4 = EXCLKMX (1). 300005h, Bit 3 = PWM4MX (1). 300005h, Bit 2 = SSPMX (1). 300005h, Bit 1 = -. 300005h, Bit 0 = FLTAMX (1). 300005h, Default/ Unprogrammed Value = 1--1 11-1. 300005h, Default/ Unprogrammed Value = 1--1 11-1. 300006h, File Name = CONFIG4L. 300006h, Bit 7 = DEBUG. 300006h, Bit 6 = -. 300006h, Bit 5 = -. 300006h, Bit 4 = -. 300006h, Bit 3 = -. 300006h, Bit 2 = LVP. 300006h, Bit 1 = -. 300006h, Bit 0 = STVREN. 300006h, Default/ Unprogrammed Value = 1---",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\n-1-1. 300006h, Default/ Unprogrammed Value = 1--- -1-1. 300007h, File Name = CONFIG4H. 300007h, Bit 7 = -. 300007h, Bit 6 = -. 300007h, Bit 5 = -. 300007h, Bit 4 = -. 300007h, Bit 3 = -. 300007h, Bit 2 = -. 300007h, Bit 1 = -. 300007h, Bit 0 = -. 300007h, Default/ Unprogrammed Value = ---- ----. 300007h, Default/ Unprogrammed Value = ---- ----. 300008h, File Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = CP3 (1). 300008h, Bit 2 = CP2",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\n(1). 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300008h, Default/ Unprogrammed Value = ---- 1111. 300008h, Default/ Unprogrammed Value = ---- 1111. 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -. 300009h, Bit 0 = -. 300009h, Default/ Unprogrammed Value = 11-- ----. 300009h, Default/ Unprogrammed Value = 11-- ----. 30000Ah, File Name = CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -.",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\n30000Ah, Bit 4 = -. 30000Ah, Bit 3 = WRT3 (1). 30000Ah, Bit 2 = WRT2 (1). 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Ah, Default/ Unprogrammed Value = ---- 1111. 30000Ah, Default/ Unprogrammed Value = ---- 1111. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Bh, Default/ Unprogrammed Value = 111- ----. 30000Bh, Default/ Unprogrammed Value = 111- ----. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 =",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\n-. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = EBTR3 (1). 30000Ch, Bit 2 = EBTR2 (1). 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Ch, Default/ Unprogrammed Value = ---- 1111. 30000Ch, Default/ Unprogrammed Value = ---- 1111. 30000Dh, File Name = CONFIG7H. 30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -. 30000Dh, Default/ Unprogrammed Value = -1-- ----. 30000Dh, Default/ Unprogrammed Value = -1--",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\n----. 3FFFFEh, File Name = DEVID1 (2). 3FFFFEh, Bit 7 = DEV2. 3FFFFEh, Bit 6 = DEV1. 3FFFFEh, Bit 5 = DEV0. 3FFFFEh, Bit 4 = REV4. 3FFFFEh, Bit 3 = REV3. 3FFFFEh, Bit 2 = REV2. 3FFFFEh, Bit 1 = REV1. 3FFFFEh, Bit 0 = REV0. 3FFFFEh, Default/ Unprogrammed Value = xxxx. 3FFFFEh, Default/ Unprogrammed Value = xxxx (2). 3FFFFFh, File Name = DEVID2 (2). 3FFFFFh, Bit 7 = DEV10. 3FFFFFh, Bit 6 = DEV9. 3FFFFFh, Bit 5 = DEV8. 3FFFFFh, Bit 4 = DEV7. 3FFFFFh, Bit 3 = DEV6. 3FFFFFh, Bit 2 = DEV5. 3FFFFFh, Bit 1 = DEV4.",
    "TABLE 23-1: CONFIGURATION BITS AND DEVICE IDs\n3FFFFFh, Bit 0 = DEV3. 3FFFFFh, Default/ Unprogrammed Value = 0000. 3FFFFFh, Default/ Unprogrammed Value = 0101\nLegend: x = unknown, u = unchanged, -= unimplemented. Shaded cells are unimplemented, read as ' 0 '.\nNote\n1: Unimplemented in PIC18F2331/4331 devices; maintain this bit set.\n2: See Register 23-13 for DEVID1 values. DEVID registers are read-only and cannot be programmed by the user.",
    "REGISTER 23-1: CONFIG1H: CONFIGURATION REGISTER 1 HIGH (BYTE ADDRESS 300001h)\nIESO, R/P-1 = FCMEN. IESO, U-0 = -. IESO, U-0 = -. IESO, R/P-1 = FOSC3. IESO, R/P-1 = FOSC2. IESO, R/P-1 = FOSC1. IESO, R/P-1 = FOSC0. bit 7, R/P-1 = bit 7. bit 7, U-0 = bit 7. bit 7, U-0 = bit 7. bit 7, R/P-1 = bit 7. bit 7, R/P-1 = bit 7. bit 7, R/P-1 = bit 7. bit 7, R/P-1 = bit 0\nLegend:, 1 = Legend:. R = Readable bit P = Programmable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = U = Unchanged from programmed state",
    "bit 7 IESO: Internal External Switchover bit\n1 = Internal External Switchover mode enabled\n0 = Internal External Switchover mode disabled\nbit 6\nFCMEN: Fail-Safe Clock Monitor Enable bit\n1 = Fail-Safe Clock Monitor enabled\n0 = Fail-Safe Clock Monitor disabled\nbit 5-4\nUnimplemented: Read as ' 0 '\nbit 3-0\nFOSC<3:0>: Oscillator Selection bits\n11xx = External RC oscillator, CLKO function on RA6\n1001 = Internal oscillator block, CLKO function on RA6 and port function on RA7 (INTIO1)\n1000 = Internal oscillator block, port function on RA6 and port function on RA7 (INTIO2)\n0111 = External RC oscillator, port function on RA6\n0110 = HS oscillator, PLL enabled (clock frequency = 4 x FOSC1)\n0101 = EC oscillator, port function on RA6 (ECIO)\n0100 = EC oscillator, CLKO function on RA6 (EC)\n0010 = HS oscillator\n0001 = XT oscillator\n0000 = LP oscillator",
    "REGISTER 23-2: CONFIG2L: CONFIGURATION REGISTER 2 LOW (BYTE ADDRESS 300002h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = BORV1. -, 5 = BORV0. -, 6 = BOREN (1). -, 7 = PWRTEN (1). bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nU = Unchanged from programmed state\nbit 7-4 Unimplemented: Read as ' 0 '\nbit 3-2 BORV<1:0>: Brown-out Reset Voltage bits\n11 = Reserved\n10 = VBOR set to 2.7V\n01 = VBOR set to 4.2V\n00 = VBOR set to 4.5V\nbit 1\nBOREN: Brown-out Reset Enable bit (1)\n1 = Brown-out Reset is enabled\n0 = Brown-out Reset is disabled\nbit 0\nPWRTEN: Power-up Timer Enable bit (1)\n1 = PWRT is disabled\n0 = PWRT is enabled\nNote 1: Having BOREN = 1 does not automatically override the PWRTEN to ' 0 ', nor automatically enables the Power-up Timer.",
    "REGISTER 23-3: CONFIG2H: CONFIGURATION REGISTER 2 HIGH (BYTE ADDRESS 300003h)\n-, U-0 = -. -, R/P-1 = WINEN. -, R/P-1 = WDTPS3. -, R/P-1 = WDTPS2. -, R/P-1 = WDTPS1. -, R/P-1 = WDTPS0. -, R/P-1 = WDTEN. bit 7, U-0 = bit 7. bit 7, R/P-1 = bit 7. bit 7, R/P-1 = bit 7. bit 7, R/P-1 = bit 7. bit 7, R/P-1 = bit 7. bit 7, R/P-1 = bit 7. bit 7, R/P-1 = bit 0\nLegend:, 1 = Legend:. R = Readable bit P = Programmable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = U = Unchanged from programmed state",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5\nWINEN: Watchdog Timer Window Enable bit\n1 = WDT window is disabled\n0 = WDT window is enabled\nbit 4-1\nWDTPS<3:0>: Watchdog Timer Postscale Select bits\n1111 = 1:32,768\n1110 = 1:16,384\n1101 = 1:8,192\n1100 = 1:4,096\n1011 = 1:2,048\n1010 = 1:1,024\n1001 = 1:512\n1000 = 1:256\n0111 = 1:128\n0110 = 1:64\n0101 = 1:32\n0100 = 1:16\n0011 = 1:8\n0010 = 1:4\n0001 = 1:2\n0000 = 1:1",
    "bit 0\nWDTEN: Watchdog Timer Enable bit\n1 = WDT is enabled\n0 = WDT is disabled (control is placed on the SWDTEN bit)",
    "REGISTER 23-4: CONFIG3L: CONFIGURATION REGISTER 3 LOW (BYTE ADDRESS 300004h)\n-, U = -. -, R/P-1 = T1OSCMX. -, R/P-1 = HPOL (1). -, R/P-1 = LPOL (1). -, R/P-1 = PWMPIN (3). -, U = -. -, U = -. bit 7 bit 0, U = bit 7 bit 0. bit 7 bit 0, R/P-1 = bit 7 bit 0. bit 7 bit 0, R/P-1 = bit 7 bit 0. bit 7 bit 0, R/P-1 = bit 7 bit 0. bit 7 bit 0, R/P-1 = bit 7 bit 0. bit 7 bit 0, U = bit 7 bit 0. bit 7 bit 0, U = bit 7 bit 0",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nU = Unchanged from programmed state",
    "Legend:\nbit 5, Unimplemented: Read as ' 0 = T1OSCMX: Timer1 Oscillator Mode bit 1 = Low-power Timer1 operation when microcontroller is in Sleep mode 0 = Standard (legacy) Timer1 oscillator operation. bit 4, Unimplemented: Read as ' 0 = HPOL: High Side Transistors Polarity bit (i.e., Odd PWM Output Polarity Control bit) (1) 1 = PWM1, 3, 5 and 7 are active-high (default) (2) 0 = PWM1, 3, 5 and 7 are active-low (2). bit 3, Unimplemented: Read as ' 0 = LPOL: Low Side Transistors Polarity bit (i.e., Even PWM Output Polarity Control bit) (1) 1 = PWM0, 2, 4 and 6 are active-high (default) (2) 0 = PWM0, 2, 4 and 6 are active-low (2). bit 2, Unimplemented: Read as ' 0 = PWMPIN: PWM Output",
    "Legend:\nPins Reset State Control bit (3) 1 = PWM outputs are disabled upon Reset (default) 0 = PWM outputs drive active states upon Reset\nbit 1-0 Unimplemented: Read as ' 0 '\nNote 1: Polarity control bits, HPOL and LPOL, define PWM signal output active and inactive states; PWM states generated by the Fault inputs or PWM manual override.\n2: PWM6 and PWM7 output channels are only available on PIC18F4331/4431 devices.\n3: When PWMPIN = 0 , PWMEN<2:0> = 101 if the device has eight PWM output pins (40 and 44-pin devices) and PWMEN<2:0> = 100 if the device has six PWM output pins (28-pin devices). PWM output polarity is defined by HPOL and LPOL.",
    "REGISTER 23-5:\nCONFIG3H: CONFIGURATION REGISTER 3 HIGH (BYTE ADDRESS 300005h)\nR/P-1\nU\nU\nR/P-1\nR/P-1\nR/P-1\nU\nR/P-1\nMCLRE (1)\n-\n-\nEXCLKMX (1)\nPWM4MX (1)\nSSPMX (1)\n-\nFLTAMX (1)\nbit 7\nbit 0",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nU = Unchanged from programmed state\nbit 7\nMCLRE: MCLR Pin Enable bit (1)\n1 = MCLR pin is enabled; RE3 input pin is disabled\n0 = RE3 input pin is enabled; MCLR is disabled",
    "bit 6-5\nUnimplemented: Read as ' 0 '\nbit 4\nEXCLKMX: TMR0/T5CKI External Clock MUX bit (1)\n1 = TMR0/T5CKI external clock input is multiplexed with RC3\n0 = TMR0/T5CKI external clock input is multiplexed with RD0",
    "bit 3\nPWM4MX: PWM4 MUX bit (1)\n1 = PWM4 output is multiplexed with RB5\n0 = PWM4 output is multiplexed with RD5",
    "bit 2\nSSPMX: SSP I/O MUX bit (1)\n1 = SCK/SCL clocks and SDA/SDI data are multiplexed with RC5 and RC4, respectively. SDO output is multiplexed with RC7.\n0 = SCK/SCL clocks and SDA/SDI data are multiplexed with RD3 and RD2, respectively. SDO output is multiplexed with RD1.",
    "bit 1 Unimplemented: Read as ' 0 '\nbit 0 FLTAMX:\nFLTA MUX bit (1)\n1 = FLTA input is multiplexed with RC1\n0 = FLTA input is multiplexed with RD4\nNote 1: Unimplemented in PIC18F2331/2431 devices; maintain this bit set.",
    "REGISTER 23-6: CONFIG4L: CONFIGURATION REGISTER 4 LOW (BYTE ADDRESS 300006h)\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = R/P-1. R/P-1, 6 = U-0. R/P-1, 7 = R/P-1. DEBUG, 1 = -. DEBUG, 2 = -. DEBUG, 3 = -. DEBUG, 4 = -. DEBUG, 5 = LVP. DEBUG, 6 = -. DEBUG, 7 = STVREN. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nU = Unchanged from programmed state\nbit 7\nDEBUG:\nBackground Debugger Enable bit\n1 = Background debugger is disabled; RB6 and RB7 are configured as general purpose I/O pins 0 = Background debugger is enabled; RB6 and RB7 are dedicated to In-Circuit Debug\nbit 6-3\nUnimplemented: Read as ' 0 '\nbit 2\nLVP:\nSingle-Supply ICSP\u2122 Enable bit\n1 = Single-Supply ICSP is enabled\n0 = Single-Supply ICSP is disabled\nbit 1\nUnimplemented: Read as ' 0 '\nbit 0\nSTVREN: Stack Full/Underflow Reset Enable bit\n1 = Stack full/underflow will cause Reset\n0 = Stack full/underflow will not cause Reset",
    "REGISTER 23-7: CONFIG5L: CONFIGURATION REGISTER 5 LOW (BYTE ADDRESS 300008h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = CP3 (1,2). -, 5 = CP2 (1,2). -, 6 = CP1 (2). -, 7 = CP0 (2). bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 23-7: CONFIG5L: CONFIGURATION REGISTER 5 LOW (BYTE ADDRESS 300008h)\nLegend:, 1 = Legend:. R = Readable bit C = Clearable, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = U = Unchanged from programmed state\nbit 7-4, 1 = Unimplemented: Read as ' 0. bit 3, 1 = CP3: Code Protection bit (1,2) 1 = Block 3 is not code-protected. bit 2, 1 = CP2: Code Protection bit (1,2) 1 = Block 2 is not code-protected 0 = Block 2 is code-protected. bit 1, 1 = CP1: Code Protection bit (2) 1 = Block 1 is not code-protected 0 = Block 1 is code-protected. bit 0, 1 = CP0: Code Protection bit (2) 1 = Block 0 is not code-protected 0 = Block 0 is code-protected\nNote 1: Unimplemented in PIC18F2331/4331 devices; maintain this bit set.\n2: Refer to Figure 23-5 for block boundary addresses.",
    "REGISTER 23-8: CONFIG5H: CONFIGURATION REGISTER 5 HIGH (BYTE ADDRESS 300009h)\nR/C-1, 1 = R/C-1. R/C-1, 2 = U-0. R/C-1, 3 = U-0. R/C-1, 4 = U-0. R/C-1, 5 = U-0. R/C-1, 6 = U-0. R/C-1, 7 = U-0. CPD (1), 1 = CPB (1). CPD (1), 2 = -. CPD (1), 3 = -. CPD (1), 4 = -. CPD (1), 5 = -. CPD (1), 6 = -. CPD (1), 7 = -. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit",
    "REGISTER 23-8: CONFIG5H: CONFIGURATION REGISTER 5 HIGH (BYTE ADDRESS 300009h)\n7 bit 0, 7 = bit 7 bit 0\nLegend:, 1 = Legend:. R = Readable bit C = Clearable, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = U = Unchanged from programmed state\nbit 7 CPD: Data EEPROM Code Protection bit (1)\n1 = Data EEPROM is not code-protected\n0 = Data EEPROM is code-protected\nbit 6\nCPB: Boot Block Code Protection bit (1)\n1 = Boot Block is not code-protected\n0 = Boot Block is code-protected\nbit 5-0\nUnimplemented: Read as ' 0 '\nNote 1: Refer to Figure 23-5 for block boundary addresses.",
    "REGISTER 23-9: CONFIG6L: CONFIGURATION REGISTER 6 LOW (BYTE ADDRESS 30000Ah)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = WRT3 (1,2). -, 5 = WRT2 (1,2). -, 6 = WRT1 (2). -, 7 = WRT0 (2). bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 23-9: CONFIG6L: CONFIGURATION REGISTER 6 LOW (BYTE ADDRESS 30000Ah)\nLegend:, 1 = Legend:. R = Readable bit P = Programmable, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = U = Unchanged from programmed state\nbit 7-4, 1 = Unimplemented: Read as ' 0 ' (1,2). bit 3, 1 = WRT3: Write Protection bit 1 = Block 3 is not write-protected 0 = Block 3 is write-protected. bit 2, 1 = WRT2: Write Protection bit (1,2) 1 = Block 2 is not write-protected 0 = Block 2 is write-protected. bit 1, 1 = WRT1: Write Protection bit (2) 1 = Block 1 is not write-protected 0 = Block 1 is write-protected. bit 0, 1 = WRT0: Write Protection bit (2) 1 = Block 0 is not write-protected 0 = Block 0 is write-protected",
    "REGISTER 23-9: CONFIG6L: CONFIGURATION REGISTER 6 LOW (BYTE ADDRESS 30000Ah)\nNote 1: Unimplemented in PIC18F2331/4331 devices; maintain this bit set.\n2: Refer to Figure 23-5 for block boundary addresses.",
    "REGISTER 23-10: CONFIG6H: CONFIGURATION REGISTER 6 HIGH (BYTE ADDRESS 30000Bh)\nWRTD (2), R/P-1 = WRTB (2). WRTD (2), R-1 = WRTC (1,2). WRTD (2), U-0 = -. WRTD (2), U-0 = -. WRTD (2), U-0 = -. WRTD (2), U-0 = -. WRTD (2), U-0 = -. bit 7, R/P-1 = . bit 7, R-1 = . bit 7, U-0 = . bit 7, U-0 = . bit 7, U-0 = . bit 7, U-0 = . bit 7, U-0 = bit 0\nLegend:, 1 = Legend:. R = Readable bit P = Programmable, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = U = Unchanged from programmed state\nbit 7\nWRTD: Data EEPROM Write Protection bit (2)",
    "REGISTER 23-10: CONFIG6H: CONFIGURATION REGISTER 6 HIGH (BYTE ADDRESS 30000Bh)\n1 = Data EEPROM is not write-protected\n0 = Data EEPROM is write-protected\nbit 6\nWRTB: Boot Block Write Protection bit (2)\n1 = Boot block is not write-protected\n0 = Boot block is write-protected\nbit 5\nWRTC: Configuration Register Write Protection bit (1,2)\n1 = Configuration registers are not write-protected\n0 = Configuration registers are write-protected\nbit 4-0\nUnimplemented: Read as ' 0 '\nNote 1: This bit is read-only in normal execution mode; it can be written only in Program mode.\n2: Refer to Figure 23-5 for block boundary addresses.",
    "REGISTER 23-11: CONFIG7L: CONFIGURATION REGISTER 7 LOW (BYTE ADDRESS 30000Ch)\nU-0\nU-0\nU-0\nU-0\nR/P-1\nR/P-1\nR/P-1\nR/P-1\n-\n-\n-\n-\nEBTR3 (1,2,3)\nEBTR2 (1,2,3)\nEBTR1 (2,3)\nEBTR0 (2,3)\nbit 7\nbit 0",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nU = Unchanged from programmed state",
    "bit 7-4 Unimplemented: Read as ' 0 '\nbit 3\nEBTR3: Table Read Protection bit (1,2,3)\n1 = Block 3 is not protected from table reads executed in other blocks\n0 = Block 3 is protected from table reads executed in other blocks\nbit 2 EBTR2: Table Read Protection bit\n(1,2,3)\n1 = Block 2 is not protected from table reads executed in other blocks\n0 = Block 2 is protected from table reads executed in other blocks\nbit 1 EBTR1: Table Read Protection bit\n(2,3)\n1 = Block 1 is not protected from table reads executed in other blocks\n0 = Block 1 is protected from table reads executed in other blocks\nbit 0\nEBTR0: Table Read Protection bit (2,3)\n1 = Block 0 is not protected from table reads executed in other blocks\n0 = Block 0 is protected from table reads executed in other blocks\nNote 1: Unimplemented in PIC18F2331/4331 devices; maintain this bit set.\n2: Refer to Figure 23-5 for block boundary addresses.\n3: Enabling the corresponding CPx bit is recommended to protect the block from external read operations.",
    "REGISTER 23-12: CONFIG7H: CONFIGURATION REGISTER 7 HIGH (BYTE ADDRESS 30000Dh)\nU-0, 1 = R/P-1. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = U-0. -, 1 = EBTRB (1,2). -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = -. bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 23-12: CONFIG7H: CONFIGURATION REGISTER 7 HIGH (BYTE ADDRESS 30000Dh)\nLegend:, 1 = Legend:. R = Readable bit P = Programmable, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = U = Unchanged from programmed state",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6\nEBTRB: Boot Block Table Read Protection bit (1,2)\n1 = Boot block is not protected from table reads executed in other blocks\n0 = Boot block is protected from table reads executed in other blocks\nbit 5-0\nUnimplemented: Read as ' 0 '\nNote 1: Enabling the corresponding CPx bit is recommended to protect the block from external read operations.\n2: Refer to Figure 23-5 for block boundary addresses.",
    "REGISTER 23-13: DEVID1: DEVICE ID REGISTER 1 FOR PIC18F2331/2431/4331/4431 DEVICES\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV2, 1 = DEV1. DEV2, 2 = DEV0. DEV2, 3 = REV4. DEV2, 4 = REV3. DEV2, 5 = REV2. DEV2, 6 = REV1. DEV2, 7 = REV0. bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0\nLegend:, 1 = Legend:. R = Readable bit P = Programmable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = U = Unchanged from programmed state",
    "bit 7-5 DEV<2:0>: Device ID bits\nThese bits are used with the DEV<10:3> bits in the Device ID Register 2 to identify the part number.\n000 = PIC18F4331\n001 = PIC18F4431\n100 = PIC18F2331\n101 = PIC18F2431\nbit 4-0 REV<4:0>: Revision ID bits\nThese bits are used to indicate the device revision.",
    "REGISTER 23-14: DEVID2: DEVICE ID REGISTER 2 FOR PIC18F2331/2431/4331/4431 DEVICES\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV10 (1), 1 = DEV9 (1). DEV10 (1), 2 = DEV8 (1). DEV10 (1), 3 = DEV7 (1). DEV10 (1), 4 = DEV6 (1). DEV10 (1), 5 = DEV5 (1). DEV10 (1), 6 = DEV4 (1). DEV10 (1), 7 = DEV3 (1). bit 7, 1 = bit 7. bit 7, 2 = bit 7. bit 7, 3 = bit 7. bit 7, 4 = bit 7. bit 7, 5 = bit 7. bit 7, 6 = bit 7. bit 7, 7 = bit 0",
    "REGISTER 23-14: DEVID2: DEVICE ID REGISTER 2 FOR PIC18F2331/2431/4331/4431 DEVICES\nLegend:, 1 = Legend:. R = Readable bit P = Programmable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = U = Unchanged from programmed state",
    "bit 7-0 DEV<10:3>: Device ID bits (1)\nThese bits are used with the DEV<2:0> bits in the Device ID Register 1 to identify the part number\n0000 0101 = PIC18F2331/2431/4331/4431 devices\nNote 1: These values for DEV<10:3> may be shared with other devices. The specific device is always identified by using the entire DEV<10:0> bit sequence.",
    "23.2 Watchdog Timer (WDT)\nFor PIC18F2331/2431/4331/4431 devices, the WDT is driven  by  the  INTRC  source.  When  the  WDT  is enabled, the clock source is also enabled. The nominal WDT period is 4 ms and has the same stability as the INTRC oscillator.\nThe 4 ms period of the WDT is multiplied by a 16-bit postscaler. Any  output  of  the  WDT  postscaler  is selected by a multiplexer, controlled by bits in Configuration Register 2H (see Register 23-3). Available periods range from 4 ms to 131.072 seconds (2.18 minutes). The WDT and postscaler are cleared when  any  of  the  following  events  occur:  execute  a SLEEP or CLRWDT instruction, the IRCF bits (OSCCON<6:4>) are changed or a clock failure has occurred (see Section 23.4.1 'FSCM and the Watchdog Timer' ).",
    "23.2 Watchdog Timer (WDT)\nAdjustments to the internal oscillator clock period using the  OSCTUNE  register  also  affect  the  period  of  the WDT by the same factor. For example, if the INTRC period  is  increased  by  3%,  then  the  WDT  period  is increased by 3%.\nNote 1: The CLRWDT and SLEEP instructions clear  the  WDT  and  postscaler  counts when executed.\n2: Changing  the  setting  of  the  IRCF  bits (OSCCON<6:4>)  clears  the  WDT  and postscaler counts.\n3: When a CLRWDT instruction is executed, the postscaler count will be cleared.\n4: If WINEN = 0 , then CLRWDT must be executed only when WDTW = 1 ; otherwise, a device Reset will result.",
    "23.2.1 CONTROL REGISTER\nRegister 23-15 shows the WDTCON register. This is a readable and writable register. The SWDTEN bit allows software to enable or disable the WDT, but only if the Configuration bit has disabled the WDT. The WDTW bit is a read-only bit that indicates when the WDT count is in the fourth quadrant (i.e., when the 8-bit WDT value is b 11000000 ' ' or greater).",
    "REGISTER 23-15: WDTCON: WATCHDOG TIMER CONTROL REGISTER\nR-0, 1 = U-0. R-0, 2 = U-0. R-0, 3 = U-0. R-0, 4 = U-0. R-0, 5 = U-0. R-0, 6 = U-0. R-0, 7 = R/W-0. WDTW, 1 = -. WDTW, 2 = -. WDTW, 3 = -. WDTW, 4 = -. WDTW, 5 = -. WDTW, 6 = -. WDTW, 7 = SWDTEN (1). bit 7 bit 0, 1 = bit 7 bit 0. bit 7 bit 0, 2 = bit 7 bit 0. bit 7 bit 0, 3 = bit 7 bit 0. bit 7 bit 0, 4 = bit 7 bit 0. bit 7 bit 0, 5 = bit 7 bit 0. bit 7 bit 0, 6 = bit 7 bit 0. bit 7 bit 0, 7 = bit 7 bit 0",
    "REGISTER 23-15: WDTCON: WATCHDOG TIMER CONTROL REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nbit 7\nWDTW: Watchdog Timer Window bit\n1 = WDT count is in fourth quadrant\n0 = WDT count is not in fourth quadrant\nbit 6-1\nUnimplemented : Read as ' 0 '\nbit 0\nSWDTEN: Software Enable/Disable for Watchdog Timer bit (1)\n1 = WDT is turned on\n0 = WDT is turned off",
    "REGISTER 23-15: WDTCON: WATCHDOG TIMER CONTROL REGISTER\nNote 1: If the WDTEN Configuration bit = 1 , then WDT is always enabled, irrespective of this control bit. If WDTEN Configuration bit = 0 , then it is possible to turn WDT on/off with this control bit.",
    "TABLE 23-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nCONFIG2H, Bit 7 = -. CONFIG2H, Bit 6 = -. CONFIG2H, Bit 5 = WINEN. CONFIG2H, Bit 4 = WDTPS3. CONFIG2H, Bit 3 = WDTPS2. CONFIG2H, Bit 2 = WDTPS2. CONFIG2H, Bit 1 = WDTPS0. CONFIG2H, Bit 0 = WDTEN. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. WDTCON, Bit 7 = WDTW. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTEN",
    "TABLE 23-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nLegend: Shaded cells are not used by the Watchdog Timer.",
    "23.3 Two-Speed Start-up\nThe Two-Speed Start-up feature helps to minimize the latency period from oscillator start-up to code execution by allowing the microcontroller to use the INTRC oscillator as a clock source until the primary clock source is available.  It  is  enabled  by  setting  the  IESO  bit  in Configuration Register 1H (CONFIG1H<7>).\nTwo-Speed  Start-up  is  available  only  if  the  primary oscillator mode is LP, XT, HS or HSPLL (Crystal-Based modes). Other sources do not require a OST start-up delay; for these, Two-Speed Start-up is disabled.\nWhen enabled, Resets and wake-ups from Sleep mode cause  the  device  to  configure  itself  to  run  from  the internal oscillator block as the clock source, following the time-out of the Power-up Timer after a Power-on Reset is enabled. This allows almost immediate code execution  while  the  primary  oscillator  starts  and  the OST is running. Once the OST times out, the device automatically switches to PRI_RUN mode.",
    "23.3 Two-Speed Start-up\nBecause  the  OSCCON  register  is  cleared  on  Reset events, the INTOSC (or postscaler) clock source is not initially available after a Reset event; the INTRC clock is used directly at its base frequency. To use a higher clock  speed  on  wake-up,  the  INTOSC  or  postscaler clock sources can be selected to provide a higher clock speed  by  setting  bits  IRCF<2:0>  immediately  after Reset. For wake-ups from Sleep, the INTOSC or postscaler clock sources  can  be  selected  by  setting IRCF<2:0> prior to entering Sleep mode.\nIn all other power-managed modes, Two-Speed Startup  is  not  used.  The  device  will  be  clocked  by  the currently selected clock source until the primary clock source  becomes  available.  The  setting  of  the  IESO Configuration bit is ignored.",
    "23.3.1 SPECIAL CONSIDERATIONS FOR USING TWO-SPEED START-UP\nWhile using the INTRC oscillator in Two-Speed Startup, the device still obeys the normal command sequences for entering power-managed modes, including serial SLEEP instructions (refer to Section 4.1.4 'Multiple Sleep Commands' ). In practice,  this  means  that  user  code  can  change  the SCS<1:0>  bit  settings  and  issue SLEEP commands before the OST times out. This would allow an application to briefly wake-up, perform routine 'housekeeping' tasks and return to Sleep before the device starts to operate from the primary oscillator.\nUser code can also check if the primary clock source is currently providing the system clocking by checking the status of the OSTS bit (OSCCON<3>). If the bit is set, the  primary  oscillator  is  providing  the  system  clock. Otherwise, the internal oscillator block is providing the clock during wake-up from Reset or Sleep mode.",
    "23.4 Fail-Safe Clock Monitor\nThe Fail-Safe Clock Monitor (FSCM)  allows the microcontroller to continue operation, in the event of an external  oscillator  failure,  by  automatically  switching the  system  clock  to  the  internal  oscillator  block.  The FSCM  function  is  enabled  by  setting  the  Fail-Safe Clock Monitor Enable bit, FCMEN (CONFIG1H<6>).\nTo use a higher clock speed on wake-up, the INTOSC or postscaler clock sources can be selected to provide a higher clock speed by setting bits, IRCF<2:0>, immediately  after  Reset.  For  wake-ups  from  Sleep,  the INTOSC or postscaler clock sources can be selected by setting the IRCF<2:0> bits prior to entering Sleep mode.",
    "23.4 Fail-Safe Clock Monitor\nWhen FSCM is enabled, the INTRC oscillator runs at all times to monitor clocks to peripherals and provide an instant backup clock in the event of a clock failure. Clock monitoring (shown in Figure 23-3) is accomplished by creating a sample clock signal, which is the INTRC output divided by 64. This allows ample time  between  FSCM  sample  clocks  for  a  peripheral clock edge to occur. The peripheral system clock and the sample clock are presented as inputs to the Clock Monitor latch (CM). The CM is set on the falling edge of the system clock source, but cleared on the rising edge of the sample clock.\nFIGURE 23-3: FSCM BLOCK DIAGRAM\nClock  failure  is  tested  for  on  the  falling  edge  of  the sample  clock.  If  a  sample  clock  falling  edge  occurs while  the  CM  is  still  set,  a  clock  failure  has  been detected (Figure 23-4). This causes the following:",
    "23.4 Fail-Safe Clock Monitor\n\u00b7 the FSCM generates an oscillator fail interrupt by setting bit, OSCFIF (PIR2<7>);\n\u00b7 the system clock source is switched to the internal oscillator block (OSCCON is not updated to show the current clock source - this is the fail-safe condition); and\n\u00b7 the WDT is reset.\nSince the postscaler frequency from the internal oscillator block may not be sufficiently stable, it may be desirable  to  select  another  clock  configuration  and enter an alternate power-managed mode (see Section 23.3.1  'Special  Considerations  for  Using Two-Speed  Start-up' and Section 4.1.4  'Multiple Sleep  Commands' for  more  details).  This  can  be done  to  attempt  a  partial  recovery  or execute  a controlled shutdown.\nAdjustments to the internal  oscillator  block  using  the OSCTUNE register also affect the period of the FSCM by the same factor. This can usually be neglected, as the clock frequency being monitored is generally much higher than the sample clock frequency.",
    "23.4 Fail-Safe Clock Monitor\nThe FSCM will detect failures of the primary or secondary clock sources only. If  the internal  oscillator  block fails, no failure would be detected, nor would any action be possible.",
    "23.4.1 FSCM AND THE WATCHDOG TIMER\nBoth  the  FSCM  and  the  WDT  are  clocked  by  the INTRC  oscillator.  Since  the  WDT  operates  with  a separate divider and counter, disabling the WDT has no effect on the operation of the INTRC oscillator when the FSCM is enabled.\nAs already noted, the clock source is switched to the INTOSC  clock  when  a  clock  failure is detected. Depending on the frequency selected by the IRCF<2:0> bits, this may mean a substantial change in the  speed  of  code  execution.  If  the  WDT  is  enabled with a small prescale value, a decrease in clock speed allows  a  WDT  time-out  to  occur  and  a  subsequent device Reset. For this reason, Fail-Safe Clock Monitor events also reset the WDT and postscaler, allowing it to start timing from when execution speed was changed and decreasing the likelihood of an erroneous time-out.",
    "23.4.2 EXITING FAIL-SAFE OPERATION\nThe fail-safe  condition  is  terminated  by  either  a  device Reset, or by entering a power-managed mode. On Reset, the controller starts the primary clock source specified in Configuration  Register  1H  (with  any  required  start-up delays that are required for the oscillator mode, such as the OST or PLL timer). The INTOSC multiplexer provides the system clock until the primary clock source becomes ready (similar to a Two-Speed Start-up). The clock system source is then switched to the primary clock (indicated by the OSTS bit in the OSCCON register becoming set). The Fail-Safe  Clock  Monitor  then  resumes  monitoring  the peripheral clock.\nThe  primary  clock  source  may  never  become  ready during start-up. In this case, operation is clocked by the INTOSC multiplexer. The OSCCON register will remain in its Reset state until a power-managed mode is entered.\nEntering  a power-managed  mode  by  loading  the OSCCON register and executing a SLEEP instruction will  clear  the  fail-safe  condition.  When  the  fail-safe condition  is  cleared,  the  clock  monitor  will  resume monitoring the peripheral clock.",
    "PIC18F2331/2431/4331/4431\nFIGURE 23-4:\nFSCM TIMING DIAGRAM",
    "23.4.4 POR OR WAKE FROM SLEEP\nAs previously mentioned, entering a power-managed mode  clears  the  fail-safe  condition.  By  entering  a power-managed  mode,  the  clock  multiplexer  selects the  clock  source  selected  by  the  OSCCON  register. Fail-safe monitoring of the power-managed  clock source resumes in the power-managed mode.\nIf  an  oscillator  failure  occurs  during  power-managed operation, the subsequent events depend on whether or  not  the  oscillator  failure  interrupt  is  enabled.  If enabled (OSCFIF = 1 ), code execution will be clocked by  the  INTOSC  multiplexer.  An  automatic  transition back to the failed clock source will not occur.\nIf  the interrupt is disabled, the device will not exit the power-managed mode on oscillator failure. Instead, the device will continue to operate as before, but clocked by the INTOSC multiplexer. While in Idle mode, subsequent interrupts will cause the CPU to begin executing instructions while being clocked by the INTOSC multiplexer. The device will not transition to a different clock source until the fail-safe condition is cleared.",
    "23.4.4 POR OR WAKE FROM SLEEP\nThe FSCM is designed to detect oscillator failure at any point  after  the  device  has  exited  Power-on  Reset (POR) or low-power Sleep mode. When the primary system clock is EC, RC or INTRC modes, monitoring can begin immediately following these events.\nFor  oscillator  modes  involving  a  crystal  or  resonator (HS,  HSPLL,  LP  or  XT),  the  situation  is  somewhat different.  Since  the  oscillator  may  require  a  start-up time considerably longer than the FCSM sample clock time, a false clock failure may be detected. To prevent this, the internal oscillator block is automatically configured as the system clock and functions until the primary clock is stable (the OST and PLL timers have timed  out).  This  is  identical  to  Two-Speed  Start-up mode.  Once  the  primary  clock  is  stable,  the  INTRC returns to its role as the FSCM source.\nNote:",
    "23.4.4 POR OR WAKE FROM SLEEP\nThe same logic that prevents false oscillator failure interrupts on POR or wake from Sleep will also prevent the detection of  the  oscillator's  failure  to start at  all following these events. This can be avoided  by  monitoring  the  OSTS  bit  and using a timing routine to determine if the oscillator is taking  too  long to  start. Even so,  no  oscillator  failure  interrupt  will  be flagged.\nAs noted in Section 23.3.1 'Special Considerations for Using Two-Speed Start-up' , it is also possible to select another clock configuration, and enter an alternate power-managed mode, while waiting for the primary system clock to become stable. When the new powered-managed mode is selected, the primary clock is disabled.",
    "23.5 Program Verification and Code Protection\nEach of the five blocks has three code protection bits associated with them. They are:\nThe  overall  structure  of  the  code  protection  on  the PIC18  Flash  devices  differs  significantly  from  other PIC \u00ae  devices.\n\u00b7 Code-Protect bit (CPn)\n\u00b7 Write-Protect bit (WRTn)\n\u00b7 External Block Table Read bit (EBTRn)\nThe user program memory is divided into five blocks. One  of  these  is  a  Boot  Block  of  512  bytes.  The remainder of the memory is divided into four blocks on binary boundaries.\nFigure 23-5 shows the program memory organization for  8  and  16-Kbyte  devices,  and  the  specific  code protection bit  associated with each block. The actual locations of the bits are summarized in Table 23-3.",
    "FIGURE 23-5: CODE-PROTECTED PROGRAM MEMORY FOR PIC18F2331/2431/4331/4431\nMEMORY SIZE/DEVICE, 1 = MEMORY SIZE/DEVICE. MEMORY SIZE/DEVICE, 2 = MEMORY SIZE/DEVICE. MEMORY SIZE/DEVICE, 3 = MEMORY SIZE/DEVICE. MEMORY SIZE/DEVICE, 4 = MEMORY SIZE/DEVICE. Address, 1 = Range. Address, 2 = 16 Kbytes (PIC18F2431/4431). Address, 3 = Address Range. Address, 4 = Block Code Protection Controlled By: 8 Kbytes (PIC18F2331/4331). 0000h 0FFFh, 1 = . 0000h 0FFFh, 2 = Boot Block. 0000h 0FFFh, 3 = 0000h 01FFh. 0000h 0FFFh, 4 = Boot Block CPB, WRTB, EBTRB. , 1 = 0200h 0FFFh. , 2 = Block 0. , 3 = 0200h 0FFFh. , 4 = Block 0 CP0, WRT0, EBTR0. , 1 = 1000h 1FFFh. , 2 = Block 1. ,",
    "FIGURE 23-5: CODE-PROTECTED PROGRAM MEMORY FOR PIC18F2331/2431/4331/4431\n3 = 1000h 1FFFh. , 4 = Block 1 CP1,. Unimplemented Read ' 0 's, 1 = . Unimplemented Read ' 0 's, 2 = Block 2. Unimplemented Read ' 0 's, 3 = 2000h 2FFFh. Unimplemented Read ' 0 's, 4 = CP2, WRT2, EBTR2. Unimplemented Read ' 0 's, 1 = 3FFFh. Unimplemented Read ' 0 's, 2 = Block 3. Unimplemented Read ' 0 's, 3 = 3000h 3FFFh. Unimplemented Read ' 0 's, 4 = CP3, WRT3, EBTR3",
    "TABLE 23-3: SUMMARY OF CODE PROTECTION REGISTERS\n300008h, File Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = CP3 (1). 300008h, Bit 2 = CP2 (1). 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -. 300009h, Bit 0 = -. 30000Ah, File Name = CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -. 30000Ah, Bit 4",
    "TABLE 23-3: SUMMARY OF CODE PROTECTION REGISTERS\n= -. 30000Ah, Bit 3 = WRT3 (1). 30000Ah, Bit 2 = WRT2 (1). 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = EBTR3 (1). 30000Ch, Bit 2 = EBTR2 (1). 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0.",
    "TABLE 23-3: SUMMARY OF CODE PROTECTION REGISTERS\n30000Dh, File Name = CONFIG7H. 30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -\nLegend: Shaded cells are unimplemented.\nNote 1: Unimplemented in PIC18F2331/4331 devices; maintain this bit set.",
    "23.5.1 PROGRAM MEMORY CODE PROTECTION\nNote:\nThe program memory may be read to, or written from, any  location  using  the  table  read  and  table  write instructions.  The  Device  ID  may  be  read  with  table reads.  The  Configuration  registers  may  be  read  and written with the table read and table write instructions.\nIn normal execution mode, the CPn bits have no direct effect. CPn bits inhibit external reads and writes. A block of user memory may be protected from table writes if the WRTn Configuration bit is  ' 0 '.  The  EBTRn  bits  control table reads. For a block of user memory with the EBTRn bit set to ' 0 ', a table read instruction that executes from within that block is allowed to read. A table read instruction that executes from a location outside of that block is not  allowed  to  read,  and  will  result  in  reading  ' 0 's. Figures 23-6 through 23-8 illustrate table write and table read protection.",
    "23.5.1 PROGRAM MEMORY CODE PROTECTION\nCode protection bits may only be written to a ' 0 ' from a ' 1 ' state. It is not possible to write  a  ' 1 '  to  a  bit  in  the  ' 0 '  state.  Code protection bits are only set to ' 1 ' by a full chip erase or block erase function. The full chip erase and block erase functions can only be initiated via ICSP or an external programmer.",
    "TABLE WRITE (WRTn) DISALLOWED\nTBLPTR = 0002FFh PC = 0007FEh, Program Memory = 0007FFh 000800h TBLWT *. TBLPTR = 0002FFh PC = 0007FEh, Configuration Bit Settings = WRT0, EBTR0 = 01. PC = 0017FEh, Program Memory = 000FFFh 001000h TBLWT *. PC = 0017FEh, Configuration Bit Settings = WRT1, EBTR1 = 11 WRT2, EBTR2 = 11 WRT3, EBTR3 = 11. Results: All table writes are disabled to Blockn whenever WRTn =, Program Memory = 001FFFh. Results: All table writes are disabled to Blockn whenever WRTn =, Configuration Bit Settings = . 0 ., Program Memory = 0 .. 0 ., Configuration Bit Settings = 0 .",
    "EXTERNAL BLOCK TABLE READ (EBTRn) DISALLOWED\nTBLPTR = 0002FFh, Program Memory = . TBLPTR = 0002FFh, Configuration Bit Settings = WRT0, EBTR0 = 10. PC = 000FFEh, Program Memory = 000800h 000FFFh TBLRD *. PC = 000FFEh, Configuration Bit Settings = WRT1, EBTR1 = 11 WRT2, EBTR2 = 11 WRT3, EBTR3 = 11. Results: All table reads from external blocks to Blockn The TABLAT register returns a value of ' 0 '., Program Memory = 0017FFh 001800h 001FFFh are. Results: All table reads from external blocks to Blockn The TABLAT register returns a value of ' 0 '., Configuration Bit Settings = disabled whenever EBTRn",
    "FIGURE 23-8: EXTERNAL BLOCK TABLE READ (EBTRn) ALLOWED\nTBLPTR = 0002FFh PC = 0007FEh, Program Memory = 0007FFh TBLRD *. TBLPTR = 0002FFh PC = 0007FEh, Configuration Bit Settings = WRT0, EBTR0 = 10. Results: Table reads permitted within Blockn, even The TABLAT register returns the value of, Program Memory = 0017FFh 001800h 001FFFh when EBTRBn = the data at the location. Results: Table reads permitted within Blockn, even The TABLAT register returns the value of, Configuration Bit Settings = WRT2, EBTR2 = 11 WRT3, EBTR3 = 11 0 .",
    "23.5.2 DATA EEPROM CODE PROTECTION\nThe entire  data  EEPROM  is  protected  from  external reads and writes by two bits: CPD and WRTD. CPD inhibits  external  reads  and  writes  of  data  EEPROM. WRTD inhibits external writes to data EEPROM. The CPU can continue  to  read  and  write  data  EEPROM regardless of the protection bit settings.",
    "23.5.3 CONFIGURATION REGISTER PROTECTION\nThe  Configuration  registers  can  be  write-protected. The WRTC bit controls protection of the Configuration registers. In normal execution mode, the WRTC bit is readable only. WRTC can only be written via ICSP or an external programmer.",
    "23.6 ID Locations\nEight memory locations (200000h-200007h) are designated as ID locations, where the user can store checksum or other code identification numbers. These locations are both readable and writable during normal execution through the TBLRD and TBLWT instructions, or during program/verify. The ID locations can be read when the device is code-protected.",
    "23.7 In-Circuit Serial Programming\nPIC18F2331/2431/4331/4431 microcontrollers can be serially programmed while in the end application circuit. This is simply done with two lines for clock and data, and  three  other  lines  for  power,  ground  and  the programming voltage. This allows customers to manufacture boards with unprogrammed devices, and then program  the  microcontroller  just  before  shipping  the product. This also allows the most recent firmware or a custom firmware to be programmed.",
    "23.8 In-Circuit Debugger\nWhen the DEBUG bit in the CONFIG4L Configuration register is programmed to a ' 0 ', the In-Circuit Debugger functionality  is  enabled.  This  function  allows  simple debugging  functions  when  used  with  MPLAB \u00ae   IDE. When  the  microcontroller  has  this  feature  enabled, some  resources  are  not  available  for  general  use. Table 23-4 shows which resources are required by the background debugger.",
    "TABLE 23-4: DEBUGGER RESOURCES\nI/O pins:, 1 = RB6, RB7. Stack:, 1 = 2 levels. Program Memory:, 1 = <1 Kbytes. Data Memory:, 1 = 16 bytes\nTo use the In-Circuit Debugger function of the microcontroller, the design must implement In-Circuit Serial Programming  connections  to  MCLR/VPP,  VDD,  VSS, RB7  and  RB6.  This  will  interface  to  the  In-Circuit Debugger module available from Microchip or one of the third party development tool companies.",
    "23.9 Single-Supply ICSP\u2122 Programming\nThe LVP bit in Configuration Register 4L (CONFIG4L<2>) enables Single-Supply ICSP Programming. When LVP is enabled, the microcontroller can be programmed without requiring high voltage being applied to the MCLR/VPP pin, but the RB5/PGM pin is then dedicated to controlling Program mode entry and is not available as a general purpose I/O pin.\nLVP is enabled in erased devices.\nWhile  programming,  using  Single-Supply  Programming, VDD is applied to the MCLR/VPP pin as in normal execution mode. To enter Programming mode, VDD is applied to the PGM pin.\nNote 1: High-voltage programming is always available,  regardless  of  the  state  of  the LVP bit or the PGM pin, by applying VIHH to the MCLR pin.\n2: When  Single-Supply Programming is enabled, the RB5 pin can no longer be used as a general purpose I/O pin.\n3: When LVP is enabled externally, pull the PGM pin to VSS to allow normal program execution.",
    "23.9 Single-Supply ICSP\u2122 Programming\nIf Single-Supply ICSP Programming mode will not be used,  the  LVP  bit  can  be  cleared  and  RB5/PGM becomes available as the digital I/O pin RB5. The LVP bit  may  be  set  or  cleared  only  when  using  standard high-voltage programming (VIHH applied to the MCLR/ VPP  pin).  Once  LVP  has  been  disabled,  only  the standard  high-voltage  programming  is  available  and must be used to program the device.\nMemory that is not code-protected can be erased using either a block erase, or erased row by row, then written at any specified VDD. If code-protected memory is to be erased, a block erase is required. If a block erase is to be performed when using Single-Supply Programming, the device must be supplied with VDD   of 4.5V to 5.5V.",
    "24.0 INSTRUCTION SET SUMMARY\nThe PIC18 instruction set adds many enhancements to the previous PIC \u00ae  instruction sets, while maintaining an easy migration from these PIC instruction sets.\nMost instructions are a single program memory word (16 bits), but there are three instructions that require two program memory locations.\nEach single-word instruction  is  a 16-bit word  divided into an opcode, which specifies the instruction type and one  or  more  operands,  which  further  specify  the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\n\u00b7 Byte-oriented operations\n\u00b7 Bit-oriented operations\n\u00b7 Literal operations\n\u00b7 Control operations\nThe PIC18 instruction set summary in Table 24-2 lists byte-oriented , bit-oriented , literal and control operations. Table 24-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The destination of the result (specified by 'd')\n3. The accessed memory (specified by 'a')\nThe  file  register  designator,  'f',  specifies  which  file register is to be used by the instruction.",
    "24.0 INSTRUCTION SET SUMMARY\nThe destination designator, 'd', specifies where the result of the operation is to be placed. If 'd' is ' 0 ', the result is placed  in  the  WREG  register.  If  'd'  is  ' 1 ',  the  result  is placed in the file register specified in the instruction.\nAll bit-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The bit in the file register (specified by 'b')\n3. The accessed memory (specified by 'a')\nThe bit field designator, 'b', selects the number of the bit affected by the operation, while the file register designator, 'f', represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\n\u00b7 A literal value to be loaded into a file register (specified by 'k')\n\u00b7 The desired FSR register to load the literal value into (specified by 'f')\n\u00b7 No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "24.0 INSTRUCTION SET SUMMARY\n\u00b7 A program memory address (specified by 'n')\n\u00b7 The mode of the call or return instructions (specified by 's')\n\u00b7 The mode of the table read and table write instructions (specified by 'm')\n\u00b7 No operand required (specified by '-')\nAll  instructions  are  a  single  word,  except  for  three double-word instructions. These three instructions were made double word instructions so that all the required information is available in these 32 bits. In the second word,  the  4  MSbs  are  ' 1 's. If this  second  word  is executed as an instruction (by itself), it will execute as a NOP .\nAll  single-word  instructions  are  executed  in  a  single instruction cycle, unless a conditional test is true or the program counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles with the additional instruction cycle(s) executed as a NOP .\nThe double word instructions execute in two instruction cycles.",
    "24.0 INSTRUCTION SET SUMMARY\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \uf06d s. If a conditional test is true or the program counter is changed as a result of an instruction, the instruction execution time is 2 \uf06d s. Two-word branch instructions (if true) would take 3 \uf06d s.\nFigure 24-1 shows the general formats that the instructions can have.\nAll examples use the format ' nnh ' to represent a hexadecimal  number,  where  ' h ' signifies  a  hexadecimal digit.\nThe  Instruction  Set  Summary,  shown  in  Table 24-2, lists the instructions recognized  by  the  Microchip Assembler (MPASM TM Assembler). Section 24.2 'Instruction  Set' provides  a  description  of  each instruction.",
    "24.1 Read-Modify-Write Operations\nAny instruction that specifies a file register as part of the instruction performs a Read-Modify-Write (R-M-W) operation.  The  register  is  read,  the  data  is  modified, and the result is stored according to either the instruction or the destination designator, 'd'. A read operation is performed on a register even if the instruction writes to that register.\nFor example, a ' BCF  PORTB, 1 '  instruction  will  read PORTB, clear bit 1 of the data, then write the result back to  PORTB.  The  read  operation  would  have  the  unintended result that any condition that sets the RBIF flag would be cleared. The R-M-W operation may also copy the level of an input pin to its corresponding output latch.",
    "TABLE 24-1: OPCODE FIELD DESCRIPTIONS\na, Description = RAM access bit: a = 0 : RAM location in Access RAM (BSR register is ignored) a = 1 : RAM bank is specified by BSR register. bbb, Description = Bit address within an 8-bit file register (0 to 7).. BSR, Description = Bank Select Register. Used to select the current RAM bank.. d, Description = Destination select bit: d = 0 : store result in WREG d = 1 : store result in file register f. dest, Description = Destination either the WREG register or the specified register file locations.. f, Description = 8-bit register file address (0x00 to 0xFF).. fs, Description = 12-bit register file address (0x000 to 0xFFF). This is the source address.. fd, Description = 12-bit register file address (0x000 to 0xFFF). This is the destination address.. k, Description = Literal field, constant data or label (may be either an 8-bit, 12-bit or a 20-bit value).. label, Description = Label name.. mm, Description",
    "TABLE 24-1: OPCODE FIELD DESCRIPTIONS\n= The mode of the TBLPTR register for the table read and table write instructions. Only used with table read and table write instructions: No Change to register (such as TBLPTR with table reads and writes).. * *+, Description = Post-Increment register (such as TBLPTR with table reads and writes).. +*, Description = Post-Decrement register (such as TBLPTR with table reads and Pre-Increment register (such as TBLPTR with table reads and writes).. *-, Description = writes).. n, Description = The relative address (2's complement number) for relative branch instructions, or the direct address for Call/Branch and Return instructions.. PRODH, Description = Product of Multiply High Byte.. PRODL, Description = Product of Multiply Low Byte.. s, Description = Fast Call/Return Mode Select bit: s = 0 : do not update into/from Shadow registers s = 1 : certain registers loaded into/from shadow registers (Fast mode). u, Description = Unused or Unchanged.. WREG, Description = Working register (accumulator).. x, Description",
    "TABLE 24-1: OPCODE FIELD DESCRIPTIONS\n= Don't care (' 0 ' or ' 1 '). The assembler will generate code with x = 0 . It is the recommended form of use for compatibility with Microchip software tools.. TBLPTR, Description = 21-bit Table Pointer (points to a Program Memory location).. TABLAT, Description = 8-bit Table Latch.. TOS, Description = Top-of-Stack.. PC, Description = Program Counter.. PCL, Description = Program Counter Low Byte.. PCH, Description = Program Counter High Byte. Program Counter High Byte Latch.. PCLATH, Description = . PCLATU, Description = Program Counter Upper Byte Latch.. GIE, Description = Global Interrupt Enable bit.. WDT, Description = Watchdog Timer.. TO, Description = Time-out bit.. PD, Description = Power-Down bit.. [ ], Description = . , Description = Optional.. ( ), Description = Contents.. \uf0ae, Description = Assigned to.. < >, Description = Register bit field.. \uf0ce italics, Description = In the set of. User-defined term (font is Courier New).",
    "GENERAL FORMAT FOR INSTRUCTIONS\n, 7 0.ADDWF MYREG, W, B.register....0 #) 0 f (Destination FILE #).0 (FILE #) register (f).8 7 0 k (literal) value.MOVLW 0x7F.select bank address.....operations.8 7 0..GOTO Label..n<7:0>.(literal) 0..n<19:8> (literal).11....0.n<7:0> (literal)...(literal).0..0 n<10:0> (literal).BRA MYFUNC..0..n<7:0> (literal) BC = ",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nBYTE-ORIENTED FILE REGISTER OPERATIONS,  = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Description. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Cycles. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Status.Affected = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Notes. = BYTE-ORIENTED FILE REGISTER OPERATIONS. ADDWF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, d, a. ADDWF, Description. = Add WREG and f. ADDWF, Cycles. = 1. ADDWF, 16-Bit Instruction Word.MSb = 0010. ADDWF, 16-Bit Instruction Word. = 01da. ADDWF, 16-Bit Instruction Word. = ffff. ADDWF, 16-Bit Instruction Word.LSb = ffff. ADDWF, Status.Affected = C, DC, Z, OV, N. ADDWF, Notes. = 1, 2. ADDWFC,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, d, a. ADDWFC, Description. = Add WREG and Carry bit to f. ADDWFC, Cycles. = 1. ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word. = 00da. ADDWFC, 16-Bit Instruction Word. = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status.Affected = C, DC, Z, OV, N. ADDWFC, Notes. = 1, 2. ANDWF,  = f, d, a. ANDWF, Description. = AND WREG with f. ANDWF, Cycles. = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001. ANDWF, 16-Bit Instruction Word. = 01da. ANDWF, 16-Bit Instruction Word. = ffff. ANDWF, 16-Bit Instruction Word.LSb = ffff. ANDWF, Status.Affected = Z, N. ANDWF, Notes. = 1,2. CLRF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, a. CLRF, Description. = Clear f. CLRF, Cycles. = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word. = 101a. CLRF, 16-Bit Instruction Word. = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status.Affected = Z. CLRF, Notes. = 2. COMF,  = f, d, a. COMF, Description. = Complement f. COMF, Cycles. = 1. COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction Word. = 11da. COMF, 16-Bit Instruction Word. = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status.Affected = Z, N. COMF, Notes. = 1, 2. CPFSEQ,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, a. CPFSEQ, Description. = Compare f with WREG, Skip = 1. CPFSEQ, Cycles. = (2 or 3). CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word. = 001a. CPFSEQ, 16-Bit Instruction Word. = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status.Affected = None. CPFSEQ, Notes. = 4. CPFSGT,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, a. CPFSGT, Description. = Compare f with WREG, Skip > 1. CPFSGT, Cycles. = (2 or 3). CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word. = 010a. CPFSGT, 16-Bit Instruction Word. = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT, Status.Affected = None. CPFSGT, Notes. = 4. CPFSLT,  = f, a. CPFSLT, Description. = Compare f with WREG, Skip < 1. CPFSLT, Cycles. = (2 or 3). CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word. = 000a. CPFSLT, 16-Bit Instruction Word. = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff. CPFSLT, Status.Affected = None. CPFSLT, Notes. = 1, 2. DECF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, d, a. DECF, Description. = Decrement f. DECF, Cycles. = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word. = 01da. DECF, 16-Bit Instruction Word. = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status.Affected = C, DC, Z, OV, N. DECF, Notes. = 1, 2, 3, 4. DECFSZ,  = f, d, a. DECFSZ, Description. = Decrement f, Skip if 0. DECFSZ, Cycles. = 1 (2 or 3). DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word. = 11da. DECFSZ, 16-Bit Instruction Word. = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status.Affected = None. DECFSZ, Notes. = 1, 2, 3, 4. DCFSNZ,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, d, a. DCFSNZ, Description. = Decrement f, Skip if Not 0. DCFSNZ, Cycles. = 1 (2 or 3). DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word. = 11da. DCFSNZ, 16-Bit Instruction Word. = ffff. DCFSNZ, 16-Bit Instruction Word.LSb = ffff. DCFSNZ, Status.Affected = None. DCFSNZ, Notes. = 1, 2. INCF,  = f, d, a. INCF, Description. = Increment f. INCF, Cycles. = 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF, 16-Bit Instruction Word. = 10da. INCF, 16-Bit Instruction Word. = ffff. INCF, 16-Bit Instruction Word.LSb = ffff. INCF, Status.Affected = C, DC, Z, OV, N. INCF, Notes. = 1, 2, 3, 4. INCFSZ,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, d, a. INCFSZ, Description. = Increment f, Skip if 0. INCFSZ, Cycles. = 1 (2 or 3). INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word. = 11da. INCFSZ, 16-Bit Instruction Word. = ffff. INCFSZ, 16-Bit Instruction Word.LSb = ffff. INCFSZ, Status.Affected = None. INCFSZ, Notes. = 4. INFSNZ,  = f, d, a. INFSNZ, Description. = Increment f, Skip if Not 0. INFSNZ, Cycles. = 1 (2 or 3). INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ, 16-Bit Instruction Word. = 10da. INFSNZ, 16-Bit Instruction Word. = ffff. INFSNZ, 16-Bit Instruction Word.LSb = ffff. INFSNZ, Status.Affected = None. INFSNZ, Notes. = 1, 2. IORWF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, d, a. IORWF, Description. = Inclusive OR WREG with f. IORWF, Cycles. = 1. IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word. = 00da. IORWF, 16-Bit Instruction Word. = ffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status.Affected = Z, N. IORWF, Notes. = 1, 2. MOVF,  = f, d, a. MOVF, Description. = Move f. MOVF, Cycles. = . MOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word. = 00da. MOVF, 16-Bit Instruction Word. = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status.Affected = Z, N. MOVF, Notes. = 1. MOVFF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f s , f d. MOVFF, Description. = Move f s (source) to 1st word f d (destination) 2nd word 1 2. MOVFF, Cycles. = . MOVFF, 16-Bit Instruction Word.MSb = 1100. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction Word.LSb = ffff. MOVFF, Status.Affected = None. MOVFF, Notes. = . MOVWF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, a. MOVWF, Description. = Move WREG to f. MOVWF, Cycles. = 1. MOVWF, 16-Bit Instruction Word.MSb = 1111 0110. MOVWF, 16-Bit Instruction Word. = ffff 111a. MOVWF, 16-Bit Instruction Word. = ffff ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff ffff. MOVWF, Status.Affected = None. MOVWF, Notes. = . MULWF,  = f, a. MULWF, Description. = Multiply WREG with f. MULWF, Cycles. = 1. MULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word. = 001a. MULWF, 16-Bit Instruction Word. = ffff. MULWF, 16-Bit Instruction Word.LSb = ffff. MULWF, Status.Affected = None. MULWF, Notes. = . NEGF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, a. NEGF, Description. = Negate f. NEGF, Cycles. = 1. NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word. = 110a. NEGF, 16-Bit Instruction Word. = ffff. NEGF, 16-Bit Instruction Word.LSb = ffff. NEGF, Status.Affected = C, DC, Z, OV, N. NEGF, Notes. = 1, 2. RLCF,  = f, d, a. RLCF, Description. = Rotate Left f through Carry. RLCF, Cycles. = 1. RLCF, 16-Bit Instruction Word.MSb = 0011. RLCF, 16-Bit Instruction Word. = 01da. RLCF, 16-Bit Instruction Word. = ffff. RLCF, 16-Bit Instruction Word.LSb = ffff. RLCF, Status.Affected = C, Z, N. RLCF, Notes. = . RLNCF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, d, a. RLNCF, Description. = Rotate Left f (No Carry). RLNCF, Cycles. = 1. RLNCF, 16-Bit Instruction Word.MSb = 0100. RLNCF, 16-Bit Instruction Word. = 01da. RLNCF, 16-Bit Instruction Word. = ffff. RLNCF, 16-Bit Instruction Word.LSb = ffff. RLNCF, Status.Affected = Z, N. RLNCF, Notes. = 1, 2. RRCF,  = f, d, a. RRCF, Description. = Rotate Right f through Carry. RRCF, Cycles. = 1. RRCF, 16-Bit Instruction Word.MSb = 0011. RRCF, 16-Bit Instruction Word. = 00da. RRCF, 16-Bit Instruction Word. = ffff. RRCF, 16-Bit Instruction Word.LSb = ffff. RRCF, Status.Affected = C, Z, N. RRCF, Notes. = . RRNCF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, d, a. RRNCF, Description. = Rotate Right f (No Carry). RRNCF, Cycles. = 1. RRNCF, 16-Bit Instruction Word.MSb = 0100. RRNCF, 16-Bit Instruction Word. = 00da. RRNCF, 16-Bit Instruction Word. = ffff. RRNCF, 16-Bit Instruction Word.LSb = ffff. RRNCF, Status.Affected = Z, N. RRNCF, Notes. = . SETF,  = f, a. SETF, Description. = Set f. SETF, Cycles. = 1. SETF, 16-Bit Instruction Word.MSb = 0110. SETF, 16-Bit Instruction Word. = 100a. SETF, 16-Bit Instruction Word. = ffff. SETF, 16-Bit Instruction Word.LSb = ffff. SETF, Status.Affected = None. SETF, Notes. = . SUBFWB,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, d, a. SUBFWB, Description. = Subtract f from WREG with Borrow. SUBFWB, Cycles. = 1. SUBFWB, 16-Bit Instruction Word.MSb = 0101. SUBFWB, 16-Bit Instruction Word. = 01da. SUBFWB, 16-Bit Instruction Word. = ffff. SUBFWB, 16-Bit Instruction Word.LSb = ffff. SUBFWB, Status.Affected = C, DC, Z, OV, N. SUBFWB, Notes. = 1, 2. SUBWF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, d, a. SUBWF, Description. = Subtract WREG from f. SUBWF, Cycles. = 1. SUBWF, 16-Bit Instruction Word.MSb = 0101. SUBWF, 16-Bit Instruction Word. = 11da. SUBWF, 16-Bit Instruction Word. = ffff. SUBWF, 16-Bit Instruction Word.LSb = ffff. SUBWF, Status.Affected = C, DC, Z, OV, N. SUBWF, Notes. = . SUBWFB,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, d, a. SUBWFB, Description. = Subtract WREG from f with Borrow. SUBWFB, Cycles. = 1. SUBWFB, 16-Bit Instruction Word.MSb = 0101. SUBWFB, 16-Bit Instruction Word. = 10da. SUBWFB, 16-Bit Instruction Word. = ffff. SUBWFB, 16-Bit Instruction Word.LSb = ffff. SUBWFB, Status.Affected = C, DC, Z, OV, N. SUBWFB, Notes. = . SWAPF,  = f, d, a. SWAPF, Description. = Swap Nibbles in f. SWAPF, Cycles. = 1. SWAPF, 16-Bit Instruction Word.MSb = 0011. SWAPF, 16-Bit Instruction Word. = 10da. SWAPF, 16-Bit Instruction Word. = ffff. SWAPF, 16-Bit Instruction Word.LSb = . SWAPF, Status.Affected = . SWAPF, Notes. = 1, 2. TSTFSZ,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, a. TSTFSZ, Description. = Test f, Skip if 0. TSTFSZ, Cycles. = 1 (2 or 3). TSTFSZ, 16-Bit Instruction Word.MSb = 0110. TSTFSZ, 16-Bit Instruction Word. = 011a. TSTFSZ, 16-Bit Instruction Word. = ffff. TSTFSZ, 16-Bit Instruction Word.LSb = ffff ffff. TSTFSZ, Status.Affected = None None. TSTFSZ, Notes. = 4 1, 2. XORWF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, d, a. XORWF, Description. = Exclusive OR WREG with f. XORWF, Cycles. = 1. XORWF, 16-Bit Instruction Word.MSb = . XORWF, 16-Bit Instruction Word. = . XORWF, 16-Bit Instruction Word. = . XORWF, 16-Bit Instruction Word.LSb = . XORWF, Status.Affected = . XORWF, Notes. = . 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS, Description. = 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS, Cycles. = 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nOPERATIONS, 16-Bit Instruction Word.LSb = 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS, Status.Affected = 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS. 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS, Notes. = 0001 10da ffff ffff Z, N BIT-ORIENTED FILE REGISTER OPERATIONS. BCF,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, b, a. BCF, Description. = Bit Clear f. BCF, Cycles. = 1. BCF, 16-Bit Instruction Word.MSb = 1001. BCF, 16-Bit Instruction Word. = bbba. BCF, 16-Bit Instruction Word. = ffff. BCF, 16-Bit Instruction Word.LSb = ffff. BCF, Status.Affected = None. BCF, Notes. = 1, 2. BSF,  = f, b, a. BSF, Description. = Bit Set f. BSF, Cycles. = 1. BSF, 16-Bit Instruction Word.MSb = 1000. BSF, 16-Bit Instruction Word. = bbba. BSF, 16-Bit Instruction Word. = ffff. BSF, 16-Bit Instruction Word.LSb = ffff. BSF, Status.Affected = None. BSF, Notes. = 1, 2. BTFSC,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, b, a. BTFSC, Description. = Bit Test f, Skip if Clear. BTFSC, Cycles. = 1 (2 or 3). BTFSC, 16-Bit Instruction Word.MSb = 1011. BTFSC, 16-Bit Instruction Word. = bbba. BTFSC, 16-Bit Instruction Word. = ffff. BTFSC, 16-Bit Instruction Word.LSb = ffff. BTFSC, Status.Affected = None. BTFSC, Notes. = 3, 4. BTFSS,  = f, b, a. BTFSS, Description. = Bit Test f, Skip if Set. BTFSS, Cycles. = 1 (2 or 3). BTFSS, 16-Bit Instruction Word.MSb = 1010. BTFSS, 16-Bit Instruction Word. = bbba. BTFSS, 16-Bit Instruction Word. = ffff. BTFSS, 16-Bit Instruction Word.LSb = ffff. BTFSS, Status.Affected = None. BTFSS, Notes. = 3, 4. BTG,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\n= f, b, a. BTG, Description. = Bit Toggle f. BTG, Cycles. = 1. BTG, 16-Bit Instruction Word.MSb = 0111. BTG, 16-Bit Instruction Word. = bbba. BTG, 16-Bit Instruction Word. = ffff. BTG, 16-Bit Instruction Word.LSb = ffff. BTG, Status.Affected = None. BTG, Notes. = 1, 2",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET\nNote 1: When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as an input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and, where applicable, d = 1 ), the prescaler will be cleared if assigned.\n3: If the Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nCONTROL OPERATIONS, Mnemonic,.Operands = CONTROL OPERATIONS. CONTROL OPERATIONS, Description. = CONTROL OPERATIONS. CONTROL OPERATIONS, Cycles. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, Status Affected. = CONTROL OPERATIONS. CONTROL OPERATIONS, Notes. = CONTROL OPERATIONS. BC, Mnemonic,.Operands = n. BC, Description. = Branch if Carry. BC, Cycles. = 1 (2). BC, 16-Bit Instruction Word.MSb = 1110. BC, 16-Bit Instruction Word.MSb = 0010. BC, 16-Bit Instruction Word. = nnnn. BC, 16-Bit Instruction Word.LSb = nnnn. BC, Status Affected. = None. BC, Notes. = . BN, Mnemonic,.Operands = n. BN, Description. = Branch if Negative. BN, Cycles. = 1 (2).",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nBN, 16-Bit Instruction Word.MSb = 1110. BN, 16-Bit Instruction Word.MSb = 0110. BN, 16-Bit Instruction Word. = nnnn. BN, 16-Bit Instruction Word.LSb = nnnn. BN, Status Affected. = None. BN, Notes. = . BNC, Mnemonic,.Operands = n. BNC, Description. = Branch if Not Carry. BNC, Cycles. = 1 (2). BNC, 16-Bit Instruction Word.MSb = 1110. BNC, 16-Bit Instruction Word.MSb = 0011. BNC, 16-Bit Instruction Word. = nnnn. BNC, 16-Bit Instruction Word.LSb = nnnn. BNC, Status Affected. = None. BNC, Notes. = . BNN, Mnemonic,.Operands = n. BNN, Description. = Branch if Not Negative. BNN, Cycles. = 1 (2). BNN, 16-Bit Instruction Word.MSb = 1110. BNN, 16-Bit Instruction",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nWord.MSb = 0111. BNN, 16-Bit Instruction Word. = nnnn. BNN, 16-Bit Instruction Word.LSb = nnnn. BNN, Status Affected. = None. BNN, Notes. = . BNOV, Mnemonic,.Operands = n. BNOV, Description. = Branch if Not Overflow. BNOV, Cycles. = 1 (2). BNOV, 16-Bit Instruction Word.MSb = 1110. BNOV, 16-Bit Instruction Word.MSb = 0101. BNOV, 16-Bit Instruction Word. = nnnn. BNOV, 16-Bit Instruction Word.LSb = nnnn. BNOV, Status Affected. = None. BNOV, Notes. = . BNZ, Mnemonic,.Operands = n. BNZ, Description. = Branch if Not Zero. BNZ, Cycles. = 2. BNZ, 16-Bit Instruction Word.MSb = 1110. BNZ, 16-Bit Instruction Word.MSb = 0001. BNZ, 16-Bit Instruction Word. =",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nnnnn. BNZ, 16-Bit Instruction Word.LSb = nnnn. BNZ, Status Affected. = None. BNZ, Notes. = . BOV, Mnemonic,.Operands = n. BOV, Description. = Branch if Overflow. BOV, Cycles. = 1 (2). BOV, 16-Bit Instruction Word.MSb = 1110. BOV, 16-Bit Instruction Word.MSb = 0100. BOV, 16-Bit Instruction Word. = nnnn. BOV, 16-Bit Instruction Word.LSb = nnnn. BOV, Status Affected. = None. BOV, Notes. = . BRA, Mnemonic,.Operands = n. BRA, Description. = Branch Unconditionally. BRA, Cycles. = 1 (2). BRA, 16-Bit Instruction Word.MSb = 1101. BRA, 16-Bit Instruction Word.MSb = 0nnn. BRA, 16-Bit Instruction Word. = nnnn. BRA, 16-Bit Instruction Word.LSb = nnnn. BRA, Status",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nAffected. = None. BRA, Notes. = . BZ, Mnemonic,.Operands = n. BZ, Description. = Branch if Zero. BZ, Cycles. = 1 (2). BZ, 16-Bit Instruction Word.MSb = 1110. BZ, 16-Bit Instruction Word.MSb = 0000. BZ, 16-Bit Instruction Word. = nnnn. BZ, 16-Bit Instruction Word.LSb = nnnn. BZ, Status Affected. = None. BZ, Notes. = . CALL, Mnemonic,.Operands = n, s. CALL, Description. = Call Subroutine 1st word 2nd word. CALL, Cycles. = 2. CALL, 16-Bit Instruction Word.MSb = 1110. CALL, 16-Bit Instruction Word.MSb = 110s kkkk. CALL, 16-Bit Instruction Word. = kkkk kkkk. CALL, 16-Bit Instruction Word.LSb = kkkk kkkk. CALL, Status Affected. = None. CALL, Notes. = . CLRWDT,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nMnemonic,.Operands = -. CLRWDT, Description. = Clear Watchdog Timer. CLRWDT, Cycles. = 1. CLRWDT, 16-Bit Instruction Word.MSb = 1111 0000. CLRWDT, 16-Bit Instruction Word.MSb = 0000. CLRWDT, 16-Bit Instruction Word. = 0000. CLRWDT, 16-Bit Instruction Word.LSb = 0100. CLRWDT, Status Affected. = TO, PD. CLRWDT, Notes. = . DAW, Mnemonic,.Operands = -. DAW, Description. = Decimal Adjust WREG. DAW, Cycles. = 1. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word.LSb = 0111. DAW, Status Affected. = C, DC. DAW, Notes. = . GOTO, Mnemonic,.Operands",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= n. GOTO, Description. = Go to Address 1st word. GOTO, Cycles. = 2. GOTO, 16-Bit Instruction Word.MSb = 1110. GOTO, 16-Bit Instruction Word.MSb = 1111. GOTO, 16-Bit Instruction Word. = kkkk. GOTO, 16-Bit Instruction Word.LSb = kkkk. GOTO, Status Affected. = None. GOTO, Notes. = . NOP, Mnemonic,.Operands = -. NOP, Description. = No Operation. NOP, Cycles. = 1. NOP, 16-Bit Instruction Word.MSb = 1111 0000. NOP, 16-Bit Instruction Word.MSb = kkkk 0000. NOP, 16-Bit Instruction Word. = kkkk 0000. NOP, 16-Bit Instruction Word.LSb = kkkk 0000. NOP, Status Affected. = None. NOP, Notes. = . NOP, Mnemonic,.Operands = -. NOP, Description. = No Operation. NOP, Cycles.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= 1. NOP, 16-Bit Instruction Word.MSb = 1111. NOP, 16-Bit Instruction Word.MSb = xxxx. NOP, 16-Bit Instruction Word. = xxxx. NOP, 16-Bit Instruction Word.LSb = xxxx. NOP, Status Affected. = None. NOP, Notes. = 4. POP, Mnemonic,.Operands = -. POP, Description. = Pop Top of Return Stack (TOS) 1. POP, Cycles. = . POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word.LSb = 0110. POP, Status Affected. = None. POP, Notes. = . PUSH, Mnemonic,.Operands = -. PUSH, Description. = Push Top of Return Stack (TOS) 1. PUSH, Cycles. = . PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word.MSb =",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n0000. PUSH, 16-Bit Instruction Word. = 0000. PUSH, 16-Bit Instruction Word.LSb = 0101. PUSH, Status Affected. = None. PUSH, Notes. = . RCALL, Mnemonic,.Operands = n. RCALL, Description. = Relative Call. RCALL, Cycles. = 2. RCALL, 16-Bit Instruction Word.MSb = 1101. RCALL, 16-Bit Instruction Word.MSb = 1nnn. RCALL, 16-Bit Instruction Word. = nnnn. RCALL, 16-Bit Instruction Word.LSb = nnnn. RCALL, Status Affected. = None. RCALL, Notes. = . RESET, Mnemonic,.Operands = . RESET, Description. = Software Device Reset. RESET, Cycles. = 1. RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word. = 1111. RESET, 16-Bit Instruction Word.LSb = 1111. RESET, Status Affected. = All. RESET,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNotes. = . RETFIE, Mnemonic,.Operands = s. RETFIE, Description. = Return from Interrupt Enable. RETFIE, Cycles. = 2. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word. = 0001. RETFIE, 16-Bit Instruction Word.LSb = 000s. RETFIE, Status Affected. = GIE/GIEH, PEIE/GIEL. RETFIE, Notes. = . RETLW, Mnemonic,.Operands = k. RETLW, Description. = Return with Literal in WREG. RETLW, Cycles. = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected. = None.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nRETLW, Notes. = . RETURN, Mnemonic,.Operands = s. RETURN, Description. = Return from Subroutine. RETURN, Cycles. = 2. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word. = 0001. RETURN, 16-Bit Instruction Word.LSb = 001s. RETURN, Status Affected. = None. RETURN, Notes. = . SLEEP, Mnemonic,.Operands = -. SLEEP, Description. = Go into Standby mode. SLEEP, Cycles. = 1. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word. = 0000. SLEEP, 16-Bit Instruction Word.LSb = 0011. SLEEP, Status Affected. = TO, PD. SLEEP, Notes. = ",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNote 1: When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as an input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and, where applicable, d = 1 ), the prescaler will be cleared if assigned.\n3: If the Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nLITERAL OPERATIONS, Mnemonic,.Operands = LITERAL OPERATIONS. LITERAL OPERATIONS, Description.Description = LITERAL OPERATIONS. LITERAL OPERATIONS, Cycles.Cycles = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, Status Affected.Status Affected = LITERAL OPERATIONS. LITERAL OPERATIONS, Notes.Notes = LITERAL OPERATIONS. ADDLW, Mnemonic,.Operands = k. ADDLW, Description.Description = Add Literal and WREG. ADDLW, Cycles.Cycles = 1. ADDLW, 16-Bit Instruction Word.MSb = 0000. ADDLW, 16-Bit Instruction Word.MSb = 1111. ADDLW, 16-Bit Instruction Word. = kkkk. ADDLW, 16-Bit Instruction Word.LSb = kkkk. ADDLW, Status Affected.Status Affected = C, DC, Z, OV, N. ADDLW,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNotes.Notes = . ANDLW, Mnemonic,.Operands = k. ANDLW, Description.Description = AND Literal with WREG. ANDLW, Cycles.Cycles = 1. ANDLW, 16-Bit Instruction Word.MSb = 0000. ANDLW, 16-Bit Instruction Word.MSb = 1011. ANDLW, 16-Bit Instruction Word. = kkkk. ANDLW, 16-Bit Instruction Word.LSb = kkkk. ANDLW, Status Affected.Status Affected = Z, N. ANDLW, Notes.Notes = . IORLW, Mnemonic,.Operands = k. IORLW, Description.Description = Inclusive OR Literal with WREG. IORLW, Cycles.Cycles = 1. IORLW, 16-Bit Instruction Word.MSb = 0000. IORLW, 16-Bit Instruction Word.MSb = 1001. IORLW, 16-Bit Instruction Word. = kkkk. IORLW, 16-Bit Instruction Word.LSb = kkkk. IORLW, Status Affected.Status",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nAffected = Z, N. IORLW, Notes.Notes = . LFSR, Mnemonic,.Operands = f, k. LFSR, Description.Description = Load Literal (12-bit) 2nd word. LFSR, Cycles.Cycles = 2. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word. = 00ff. LFSR, 16-Bit Instruction Word.LSb = kkkk. LFSR, Status Affected.Status Affected = None. LFSR, Notes.Notes = . , Mnemonic,.Operands = . , Description.Description = to FSRx 1st word. , Cycles.Cycles = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word.MSb = 0000. , 16-Bit Instruction Word. = kkkk. , 16-Bit Instruction Word.LSb = kkkk. , Status Affected.Status Affected = . , Notes.Notes = . MOVLB,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nMnemonic,.Operands = k. MOVLB, Description.Description = Move Literal to BSR<3:0>. MOVLB, Cycles.Cycles = 1. MOVLB, 16-Bit Instruction Word.MSb = 0000. MOVLB, 16-Bit Instruction Word.MSb = 0001. MOVLB, 16-Bit Instruction Word. = 0000. MOVLB, 16-Bit Instruction Word.LSb = kkkk. MOVLB, Status Affected.Status Affected = None. MOVLB, Notes.Notes = . MOVLW, Mnemonic,.Operands = k. MOVLW, Description.Description = Move Literal to WREG. MOVLW, Cycles.Cycles = 1. MOVLW, 16-Bit Instruction Word.MSb = 0000. MOVLW, 16-Bit Instruction Word.MSb = 1110. MOVLW, 16-Bit Instruction Word. = kkkk. MOVLW, 16-Bit Instruction Word.LSb = kkkk. MOVLW, Status Affected.Status",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nAffected = None. MOVLW, Notes.Notes = . MULLW, Mnemonic,.Operands = k. MULLW, Description.Description = Multiply Literal with WREG. MULLW, Cycles.Cycles = 1. MULLW, 16-Bit Instruction Word.MSb = 0000. MULLW, 16-Bit Instruction Word.MSb = 1101. MULLW, 16-Bit Instruction Word. = kkkk. MULLW, 16-Bit Instruction Word.LSb = kkkk. MULLW, Status Affected.Status Affected = None. MULLW, Notes.Notes = . RETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with Literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nRETLW, Status Affected.Status Affected = None. RETLW, Notes.Notes = . SUBLW, Mnemonic,.Operands = k. SUBLW, Description.Description = Subtract WREG from Literal. SUBLW, Cycles.Cycles = 1. SUBLW, 16-Bit Instruction Word.MSb = 0000. SUBLW, 16-Bit Instruction Word.MSb = 1000. SUBLW, 16-Bit Instruction Word. = kkkk. SUBLW, 16-Bit Instruction Word.LSb = kkkk. SUBLW, Status Affected.Status Affected = C, DC, Z, OV, N. SUBLW, Notes.Notes = . XORLW, Mnemonic,.Operands = k. XORLW, Description.Description = Exclusive OR Literal with WREG. XORLW, Cycles.Cycles = 1. XORLW, 16-Bit Instruction Word.MSb = 0000. XORLW, 16-Bit Instruction Word.MSb = 1010. XORLW, 16-Bit Instruction Word.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n= kkkk. XORLW, 16-Bit Instruction Word.LSb = kkkk. XORLW, Status Affected.Status Affected = Z, N. XORLW, Notes.Notes = . DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Mnemonic,.Operands = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Description.Description = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Cycles.Cycles = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word. = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.LSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Status Affected.Status Affected = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Notes.Notes = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. TBLRD*, Mnemonic,.Operands = TBLRD*. TBLRD*,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nDescription.Description = Table Read. TBLRD*, Cycles.Cycles = 2. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word. = 0000. TBLRD*, 16-Bit Instruction Word.LSb = 1000. TBLRD*, Status Affected.Status Affected = None. TBLRD*, Notes.Notes = . TBLRD*+, Mnemonic,.Operands = TBLRD*+. TBLRD*+, Description.Description = Table Read with Post-Increment. TBLRD*+, Cycles.Cycles = . TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected.Status Affected = None.",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nTBLRD*+, Notes.Notes = . TBLRD*-, Mnemonic,.Operands = TBLRD*-. TBLRD*-, Description.Description = Table Read with Post-Decrement. TBLRD*-, Cycles.Cycles = . TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word.LSb = 1010. TBLRD*-, Status Affected.Status Affected = None. TBLRD*-, Notes.Notes = . TBLRD+*, Mnemonic,.Operands = TBLRD+*. TBLRD+*, Description.Description = Table Read with Pre-Increment. TBLRD+*, Cycles.Cycles = . TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word.MSb =",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\n0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected.Status Affected = None. TBLRD+*, Notes.Notes = . TBLWT*, Mnemonic,.Operands = TBLWT*. TBLWT*, Description.Description = Table Write. TBLWT*, Cycles.Cycles = 2 (5). TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word.LSb = 1100. TBLWT*, Status Affected.Status Affected = None. TBLWT*, Notes.Notes = . TBLWT*+, Mnemonic,.Operands = TBLWT*+. TBLWT*+, Description.Description = Table Write with Post-Increment. TBLWT*+,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nCycles.Cycles = . TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word.LSb = 1101. TBLWT*+, Status Affected.Status Affected = None. TBLWT*+, Notes.Notes = . TBLWT*-, Mnemonic,.Operands = TBLWT*-. TBLWT*-, Description.Description = Table Write with Post-Decrement. TBLWT*-, Cycles.Cycles = . TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word.LSb = 1110. TBLWT*-, Status Affected.Status Affected = None. TBLWT*-,",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNotes.Notes = . TBLWT+*, Mnemonic,.Operands = TBLWT+*. TBLWT+*, Description.Description = Table Write with Pre-Increment. TBLWT+*, Cycles.Cycles = . TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word.LSb = 1111. TBLWT+*, Status Affected.Status Affected = None. TBLWT+*, Notes.Notes = ",
    "TABLE 24-2: PIC18FXXXX INSTRUCTION SET (CONTINUED)\nNote 1: When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as an input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and, where applicable, d = 1 ), the prescaler will be cleared if assigned.\n3: If the Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "24.2 Instruction Set\nSyntax:, ADD Literal to W = [ label ] ADDLW. Syntax:, ADD Literal to W = [ label ] ADDLW. Syntax:, ADD Literal to W = k. Syntax:, ADD Literal to W = . Operands:, ADD Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, ADD Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, ADD Literal to W = . Operands:, ADD Literal to W = . Operation:, ADD Literal to W = (W) + k \uf0ae W. Operation:, ADD Literal to W = (W) + k \uf0ae W. Operation:, ADD Literal to W = . Operation:, ADD Literal to W = . Status Affected:, ADD Literal to W = N, OV, C, DC, Z. Status Affected:, ADD Literal to W = N, OV, C, DC, Z. Status Affected:, ADD Literal to W = . Status Affected:, ADD Literal to W = . Encoding:, ADD Literal to W = 0000. Encoding:, ADD Literal to W = 1111. Encoding:, ADD Literal to W = kkkk. Encoding:, ADD Literal to W = kkkk.",
    "24.2 Instruction Set\nDescription:, ADD Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Words:, ADD Literal to W = 1. Words:, ADD Literal to W = . Words:, ADD Literal to W = . Words:, ADD Literal to W = . Cycles:, ADD Literal to W = 1. Cycles:, ADD Literal to W = . Cycles:, ADD Literal to W = . Cycles:, ADD Literal to W = . Q Cycle Activity:, ADD Literal to W = . Q Cycle Activity:, ADD Literal to W = . Q Cycle Activity:, ADD Literal to W = . Q Cycle Activity:, ADD Literal to W = . Q1, ADD Literal to W =",
    "24.2 Instruction Set\nQ2. Q1, ADD Literal to W = Q3. Q1, ADD Literal to W = . Q1, ADD Literal to W = Q4. Decode, ADD Literal to W = Read literal 'k'. Decode, ADD Literal to W = Process Data. Decode, ADD Literal to W = . Decode, ADD Literal to W = Write to W. Example:, ADD Literal to W = ADDLW. Example:, ADD Literal to W = 0x15. Example:, ADD Literal to W = . Example:, ADD Literal to W = . Before Instruction, ADD Literal to W = Before Instruction. Before Instruction, ADD Literal to W = . Before Instruction, ADD Literal to W = . Before Instruction, ADD Literal to W = . After Instruction W =, ADD Literal to W = 0x25. After Instruction W =, ADD Literal to W = . After Instruction W =, ADD Literal to W = . After Instruction W =, ADD Literal to W = ",
    "24.2 Instruction Set\nSyntax:, ADD Wto f = [ label ] ADDWF. Syntax:, ADD Wto f = [ label ] ADDWF. Syntax:, ADD Wto f = f [,d [,a]]. Syntax:, ADD Wto f = f [,d [,a]]. Operands:, ADD Wto f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, ADD Wto f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, ADD Wto f = . Operands:, ADD Wto f = . Operation:, ADD Wto f = (W) + (f) \uf0ae dest. Operation:, ADD Wto f = (W) + (f) \uf0ae dest. Operation:, ADD Wto f = . Operation:, ADD Wto f = . Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:, ADD Wto f = . Status Affected:, ADD Wto f = .",
    "24.2 Instruction Set\nEncoding:, ADD Wto f = 0010. Encoding:, ADD Wto f = 01da. Encoding:, ADD Wto f = ffff. Encoding:, ADD Wto f = ffff. Description:, ADD Wto f = Add Wto register, 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, ADD Wto f = Add Wto register, 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, ADD Wto f = Add Wto register, 'f'. If 'd' is ' 0 ', the result is stored in W. If",
    "24.2 Instruction Set\n'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, ADD Wto f = Add Wto register, 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Words:, ADD Wto f = 1. Words:, ADD Wto f = 1. Words:, ADD Wto f = . Words:, ADD Wto f = . Cycles:, ADD Wto f = 1. Cycles:, ADD Wto f = 1. Cycles:, ADD Wto f = . Cycles:, ADD Wto f = . Q Cycle Activity:, ADD Wto f = Q Cycle Activity:. Q Cycle Activity:, ADD Wto f = Q Cycle Activity:. Q Cycle Activity:, ADD",
    "24.2 Instruction Set\nWto f = Q Cycle Activity:. Q Cycle Activity:, ADD Wto f = Q Cycle Activity:. Q1, ADD Wto f = Q2. Q1, ADD Wto f = Q3. Q1, ADD Wto f = Q4. Q1, ADD Wto f = Q4. Decode, ADD Wto f = Read register 'f'. Decode, ADD Wto f = Process Data. Decode, ADD Wto f = Write to destination. Decode, ADD Wto f = Write to destination. Example:, ADD Wto f = ADDWF. Example:, ADD Wto f = REG,. Example:, ADD Wto f = W. Example:, ADD Wto f = W. Before Instruction, ADD Wto f = Before Instruction. Before Instruction, ADD Wto f = . Before Instruction, ADD Wto f = . Before Instruction, ADD Wto f = . W, ADD Wto f = 0x17. W, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . REG, ADD Wto f = 0xC2. REG, ADD Wto f",
    "24.2 Instruction Set\n= . REG, ADD Wto f = . REG, ADD Wto f = . After Instruction, ADD Wto f = After Instruction. After Instruction, ADD Wto f = . After Instruction, ADD Wto f = . After Instruction, ADD Wto f = . W, ADD Wto f = 0xD9. W, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . REG, ADD Wto f = 0xC2. REG, ADD Wto f = . REG, ADD Wto f = . REG, ADD Wto f = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, ADD Wand Carry bit to f = [ label ] ADDWFC. Syntax:, ADD Wand Carry bit to f = [ label ] ADDWFC. Syntax:, ADD Wand Carry bit to f = f [,d [,a]]. Syntax:, ADD Wand Carry bit to f = f [,d [,a]]. Operands:, ADD Wand Carry bit to f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1] a \uf0ce\uf020 [0,1]. Operands:, ADD Wand Carry bit to f = 0 \uf0a3 f \uf0a3 255 d \uf0ce\uf020 [0,1] a \uf0ce\uf020 [0,1]. Operands:, ADD Wand Carry bit to f = . Operands:, ADD Wand Carry bit to f = . Operation:, ADD Wand Carry bit to f = (W) + (f) + (C) \uf0ae dest. Operation:, ADD Wand Carry bit to f = (W) + (f) + (C) \uf0ae dest. Operation:, ADD Wand Carry bit to f = (W) + (f) + (C) \uf0ae dest. Operation:, ADD Wand Carry bit to f = (W) + (f) +",
    "PIC18F2331/2431/4331/4431\n(C) \uf0ae dest. Status Affected:, ADD Wand Carry bit to f = N, OV, C, DC, Z. Status Affected:, ADD Wand Carry bit to f = N, OV, C, DC, Z. Status Affected:, ADD Wand Carry bit to f = N, OV, C, DC, Z. Status Affected:, ADD Wand Carry bit to f = N, OV, C, DC, Z. Encoding:, ADD Wand Carry bit to f = 0010. Encoding:, ADD Wand Carry bit to f = 00da. Encoding:, ADD Wand Carry bit to f = ffff. Encoding:, ADD Wand Carry bit to f = ffff. Description:, ADD Wand Carry bit to f = Add W, the Carry flag and data memory location, 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location, 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be",
    "PIC18F2331/2431/4331/4431\noverridden.. Description:, ADD Wand Carry bit to f = Add W, the Carry flag and data memory location, 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location, 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden.. Description:, ADD Wand Carry bit to f = Add W, the Carry flag and data memory location, 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location, 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden.. Description:, ADD Wand Carry bit to f = Add W, the Carry flag and data memory location, 'f'. If 'd' is ' 0 ', the result is placed in",
    "PIC18F2331/2431/4331/4431\nW. If 'd' is ' 1 ', the result is placed in data memory location, 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden.. Words:, ADD Wand Carry bit to f = 1. Words:, ADD Wand Carry bit to f = 1. Words:, ADD Wand Carry bit to f = 1. Words:, ADD Wand Carry bit to f = 1. Cycles:, ADD Wand Carry bit to f = 1. Cycles:, ADD Wand Carry bit to f = 1. Cycles:, ADD Wand Carry bit to f = 1. Cycles:, ADD Wand Carry bit to f = 1. Q Cycle Activity:, ADD Wand Carry bit to f = Q Cycle Activity:. Q Cycle Activity:, ADD Wand Carry bit to f = Q Cycle Activity:. Q Cycle Activity:, ADD Wand Carry bit to f = Q Cycle Activity:. Q Cycle Activity:, ADD Wand Carry bit to f = Q Cycle Activity:. Q1, ADD Wand Carry bit to f = Q2. Q1, ADD Wand",
    "PIC18F2331/2431/4331/4431\nCarry bit to f = Q3. Q1, ADD Wand Carry bit to f = Q4. Q1, ADD Wand Carry bit to f = Q4. Decode, ADD Wand Carry bit to f = Read register 'f'. Decode, ADD Wand Carry bit to f = Process Data. Decode, ADD Wand Carry bit to f = Write to destination. Decode, ADD Wand Carry bit to f = Write to destination",
    "Example:\nADDWFC\nREG, W\nBefore Instruction\nCarry bit =\n1\nREG\n=\n0x02\nW\n=\n0x4D\nAfter Instruction\nCarry bit\n=\n0\nREG\n=\n0x02\nW\n=\n0x50",
    "Example:\nSyntax:, AND Literal with W = [ label ] ANDLW. Syntax:, AND Literal with W = [ label ] ANDLW. Syntax:, AND Literal with W = k. Syntax:, AND Literal with W = . Operands:, AND Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND Literal with W = . Operands:, AND Literal with W = . Operation:, AND Literal with W = (W) .AND. k \uf0ae W. Operation:, AND Literal with W = (W) .AND. k \uf0ae W. Operation:, AND Literal with W = . Operation:, AND Literal with W = . Status Affected:, AND Literal with W = N, Z. Status Affected:, AND Literal with W = N, Z. Status Affected:, AND Literal with W = . Status Affected:, AND Literal with W = . Encoding:, AND Literal with W = 0000. Encoding:, AND Literal with W = 1011. Encoding:, AND Literal with W = kkkk. Encoding:, AND Literal with W = kkkk. Description:, AND Literal with W = The contents of Ware ANDed with",
    "Example:\nthe 8-bit literal 'k'. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Words:, AND Literal with W = 1. Words:, AND Literal with W = . Words:, AND Literal with W = . Words:, AND Literal with W = . Cycles:, AND Literal with W = 1. Cycles:, AND Literal with W = . Cycles:, AND Literal with W = . Cycles:, AND Literal with W = . Q Cycle Activity: Q1, AND Literal with W = Q2. Q Cycle Activity: Q1, AND Literal with W = Q3. Q Cycle Activity: Q1, AND Literal with W = . Q Cycle Activity: Q1, AND Literal with W = Q4. Decode, AND Literal with W = Read",
    "Example:\nliteral 'k'. Decode, AND Literal with W = Process. Decode, AND Literal with W = . Decode, AND Literal with W = Write to W\nANDLW\nBefore Instruction\nW\n=\n0xA3\nAfter Instruction\nW\n=\n0x03\n0x5F",
    "AND W with f\nSyntax:\n[\nlabel\n]  ANDWF      f [,d [,a]]\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce\uf020 [0,1]\na \uf0ce\uf020 [0,1]\nOperation:\n(W) .AND. (f) \uf0ae dest\nStatus Affected:\nN, Z\nEncoding:\n0001\n01da\nffff\nffff\nDescription:\nThe contents of W are ANDed with\nregister, 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite to\ndestination",
    "Example:\nANDWF\nREG, W\nBefore Instruction\nW\n=\n0x17\nREG\n=\n0xC2\nAfter Instruction\nW\n=\n0x02\nREG\n=\n0xC2",
    "Example:\nSyntax:, Branch if Carry = [ label ] BC n. Syntax:, Branch if Carry = [ label ] BC n. Syntax:, Branch if Carry = [ label ] BC n. Syntax:, Branch if Carry = [ label ] BC n. Syntax:, Branch if Carry = [ label ] BC n. Operands:, Branch if Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Carry = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Carry = if Carry bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Carry = if Carry bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Carry = if Carry bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Carry = if Carry bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Carry = if Carry bit is ' 1 ', (PC) + 2 + 2n \uf0ae",
    "Example:\nPC. Status Affected:, Branch if Carry = None. Status Affected:, Branch if Carry = None. Status Affected:, Branch if Carry = None. Status Affected:, Branch if Carry = None. Status Affected:, Branch if Carry = None. Encoding:, Branch if Carry = 1110. Encoding:, Branch if Carry = 1110. Encoding:, Branch if Carry = 0010. Encoding:, Branch if Carry = nnnn. Encoding:, Branch if Carry = nnnn. Description:, Branch if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a",
    "Example:\ntwo-cycle instruction.. Description:, Branch if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch if Carry = 1. Words:, Branch if Carry =",
    "Example:\n1. Words:, Branch if Carry = 1. Words:, Branch if Carry = 1. Words:, Branch if Carry = 1. Cycles:, Branch if Carry = 1(2). Cycles:, Branch if Carry = 1(2). Cycles:, Branch if Carry = 1(2). Cycles:, Branch if Carry = 1(2). Cycles:, Branch if Carry = 1(2). Q Cycle Activity: If Jump:, Branch if Carry = . Q Cycle Activity: If Jump:, Branch if Carry = . Q Cycle Activity: If Jump:, Branch if Carry = . Q Cycle Activity: If Jump:, Branch if Carry = . Q Cycle Activity: If Jump:, Branch if Carry = . Q1, Branch if Carry = Q2. Q1, Branch if Carry = . Q1, Branch if Carry = Q3. Q1, Branch if Carry = . Q1, Branch if Carry = Q4. , Branch if Carry = Decode. , Branch if Carry = Read literal 'n'. , Branch if Carry = Process Data. , Branch if Carry = Process Data. , Branch if Carry = Write to PC. , Branch if Carry = No operation. , Branch",
    "Example:\nif Carry = No operation. , Branch if Carry = No operation. , Branch if Carry = No operation. , Branch if Carry = No operation. If No Jump:, Branch if Carry = If No Jump:. If No Jump:, Branch if Carry = If No Jump:. If No Jump:, Branch if Carry = If No Jump:. If No Jump:, Branch if Carry = If No Jump:. If No Jump:, Branch if Carry = If No Jump:. , Branch if Carry = Q1. , Branch if Carry = Q2. , Branch if Carry = Q3. , Branch if Carry = Q3. , Branch if Carry = Q4. , Branch if Carry = Decode. , Branch if Carry = Read literal 'n'. , Branch if Carry = Process Data. , Branch if Carry = Process Data. , Branch if Carry = No operation. Example:, Branch if Carry = Example:. Example:, Branch if Carry = HERE. Example:, Branch if Carry = BC. Example:, Branch if Carry = JUMP. Example:, Branch if Carry = . Before Instruction PC, Branch if Carry = Before Instruction PC. Before Instruction PC, Branch if Carry = =. Before Instruction PC,",
    "Example:\nBranch if Carry = address. Before Instruction PC, Branch if Carry = (HERE). Before Instruction PC, Branch if Carry = . After Instruction If Carry =, Branch if Carry = PC. After Instruction If Carry =, Branch if Carry = =. After Instruction If Carry =, Branch if Carry = 1; address. After Instruction If Carry =, Branch if Carry = (JUMP). After Instruction If Carry =, Branch if Carry = . If Carry = PC =, Branch if Carry = If Carry = PC =. If Carry = PC =, Branch if Carry = . If Carry = PC =, Branch if Carry = 0; address. If Carry = PC =, Branch if Carry = (HERE. If Carry = PC =, Branch if Carry = + 2)",
    "PIC18F2331/2431/4331/4431\nSyntax:, Bit Clear f = [ label ] BCF. Syntax:, Bit Clear f = [ label ] BCF. Syntax:, Bit Clear f = f,b[,a]. Syntax:, Bit Clear f = f,b[,a]. Syntax:, Bit Clear f = f,b[,a]. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = . Operands:, Bit Clear f = . Operands:, Bit Clear f = . Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = . Operation:, Bit Clear f = . Operation:, Bit Clear f = . Affected:, Bit Clear f = None. Affected:, Bit Clear f = None. Affected:, Bit Clear f = Status. Affected:, Bit Clear f = Status. Affected:, Bit Clear f = Status. Encoding:, Bit Clear f =",
    "PIC18F2331/2431/4331/4431\n1001. Encoding:, Bit Clear f = bbba. Encoding:, Bit Clear f = bbba. Encoding:, Bit Clear f = ffff. Encoding:, Bit Clear f = ffff. Description:, Bit Clear f = Bit 'b' in register, 'f', is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Clear f = Bit 'b' in register, 'f', is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Clear f = Bit 'b' in register, 'f', is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit",
    "PIC18F2331/2431/4331/4431\nClear f = Bit 'b' in register, 'f', is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Clear f = Bit 'b' in register, 'f', is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. , Bit Clear f = 1. , Bit Clear f = 1. , Bit Clear f = Words:. , Bit Clear f = Words:. , Bit Clear f = Words:. , Bit Clear f = 1. , Bit Clear f = 1. , Bit Clear f = Cycles:. , Bit Clear f = Cycles:. , Bit Clear f = Cycles:. Q Cycle Activity: Q1, Bit Clear f = Q2. Q Cycle Activity: Q1, Bit Clear f = . Q Cycle Activity: Q1, Bit Clear f = Q3.",
    "PIC18F2331/2431/4331/4431\nQ Cycle Activity: Q1, Bit Clear f = Q3. Q Cycle Activity: Q1, Bit Clear f = Q4. Decode, Bit Clear f = Read register 'f'. Decode, Bit Clear f = Read register 'f'. Decode, Bit Clear f = Process Data. Decode, Bit Clear f = Process Data. Decode, Bit Clear f = Write register 'f'. Example:, Bit Clear f = BCF. Example:, Bit Clear f = FLAG_REG, 7. Example:, Bit Clear f = FLAG_REG, 7. Example:, Bit Clear f = FLAG_REG, 7. Example:, Bit Clear f = FLAG_REG, 7. Before Instruction FLAG_REG = 0xC7, Bit Clear f = Before Instruction FLAG_REG = 0xC7. Before Instruction FLAG_REG = 0xC7, Bit Clear f = After Instruction. Before Instruction FLAG_REG = 0xC7, Bit Clear f = After Instruction. Before Instruction FLAG_REG = 0xC7, Bit Clear f = After Instruction. Before Instruction FLAG_REG = 0xC7, Bit Clear",
    "PIC18F2331/2431/4331/4431\nf = After Instruction",
    "PIC18F2331/2431/4331/4431\nSyntax:, Branch if Negative = Syntax:. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Operands:, Branch if Negative = Operands:. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Negative = Operation:. Operation:, Branch if Negative = if Negative bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if Negative bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if Negative bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if Negative bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if",
    "PIC18F2331/2431/4331/4431\nNegative = Status Affected:. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Encoding:, Branch if Negative = Encoding:. Encoding:, Branch if Negative = 1110. Encoding:, Branch if Negative = 0110. Encoding:, Branch if Negative = nnnn. Encoding:, Branch if Negative = nnnn. Description:, Branch if Negative = Description:. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address",
    "PIC18F2331/2431/4331/4431\nwill be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch if Negative = Words:. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Cycles:, Branch if Negative = Cycles:. Cycles:, Branch if Negative = 1(2).",
    "PIC18F2331/2431/4331/4431\nCycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Q Cycle Activity: If Jump:, Branch if Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Negative = . Q Cycle Activity: If Jump:, Branch if Negative = . Q Cycle Activity: If Jump:, Branch if Negative = . Q Cycle Activity: If Jump:, Branch if Negative = . , Branch if Negative = Q1. , Branch if Negative = Q2. , Branch if Negative = Q3. , Branch if Negative = . , Branch if Negative = Q4. , Branch if Negative = Decode. , Branch if Negative = Read literal 'n'. , Branch if Negative = Process Data. , Branch if Negative = Process Data. , Branch if Negative = Write to PC. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. If No Jump:, Branch if Negative = If No",
    "PIC18F2331/2431/4331/4431\nJump:. If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . , Branch if Negative = Q1. , Branch if Negative = Q2. , Branch if Negative = Q2. , Branch if Negative = Q3. , Branch if Negative = Q4. , Branch if Negative = Decode. , Branch if Negative = Read literal 'n'. , Branch if Negative = Read literal 'n'. , Branch if Negative = Process Data. , Branch if Negative = No operation. Example:, Branch if Negative = Example:. Example:, Branch if Negative = HERE. Example:, Branch if Negative = BN. Example:, Branch if Negative = Jump. Example:, Branch if Negative = . Before Instruction PC, Branch if Negative = Before Instruction PC. Before Instruction PC, Branch if Negative = =. Before Instruction PC, Branch if Negative = address. Before Instruction PC, Branch if Negative = (HERE). Before Instruction PC, Branch if Negative = . After Instruction If Negative, Branch if Negative = After Instruction If Negative. After",
    "PIC18F2331/2431/4331/4431\nInstruction If Negative, Branch if Negative = = =. After Instruction If Negative, Branch if Negative = 1; address (Jump). After Instruction If Negative, Branch if Negative = . After Instruction If Negative, Branch if Negative = . If Negative PC, Branch if Negative = If Negative PC. If Negative PC, Branch if Negative = = =. If Negative PC, Branch if Negative = 0; address. If Negative PC, Branch if Negative = (HERE. If Negative PC, Branch if Negative = + 2)",
    "PIC18F2331/2431/4331/4431\nSyntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Carry = if Carry bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if Carry bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if Carry bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if Carry bit is ' 0 ', (PC)",
    "PIC18F2331/2431/4331/4431\n+ 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if Carry bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Encoding:, Branch if Not Carry = 1110. Encoding:, Branch if Not Carry = 0011. Encoding:, Branch if Not Carry = nnnn. Encoding:, Branch if Not Carry = nnnn. Encoding:, Branch if Not Carry = nnnn. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then",
    "PIC18F2331/2431/4331/4431\nthe program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The",
    "PIC18F2331/2431/4331/4431\n2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Q Cycle Activity: If Jump:, Branch if Not Carry = . Q Cycle Activity: If Jump:, Branch if Not Carry = . Q Cycle Activity: If Jump:, Branch if Not Carry = . Q Cycle Activity: If Jump:, Branch if Not Carry = . Q Cycle Activity: If Jump:, Branch if Not Carry = . Q1,",
    "PIC18F2331/2431/4331/4431\nBranch if Not Carry = Q2. Q1, Branch if Not Carry = . Q1, Branch if Not Carry = Q3. Q1, Branch if Not Carry = Q4. Q1, Branch if Not Carry = Q4. Decode, Branch if Not Carry = Read literal 'n'. Decode, Branch if Not Carry = Read literal 'n'. Decode, Branch if Not Carry = Process Data. Decode, Branch if Not Carry = Write to PC. Decode, Branch if Not Carry = Write to PC. No operation, Branch if Not Carry = No operation. No operation, Branch if Not Carry = No operation. No operation, Branch if Not Carry = No operation. No operation, Branch if Not Carry = No operation. No operation, Branch if Not Carry = No operation. If No Jump:, Branch if Not Carry = . If No Jump:, Branch if Not Carry = . If No Jump:, Branch if Not Carry = . If No Jump:, Branch if Not Carry = . If No Jump:, Branch if Not Carry = . Q1, Branch if Not Carry = Q2. Q1, Branch if Not Carry =",
    "PIC18F2331/2431/4331/4431\nQ2. Q1, Branch if Not Carry = Q3. Q1, Branch if Not Carry = Q4. Q1, Branch if Not Carry = Q4. Decode, Branch if Not Carry = Read literal 'n'. Decode, Branch if Not Carry = Read literal 'n'. Decode, Branch if Not Carry = Process Data. Decode, Branch if Not Carry = No operation. Decode, Branch if Not Carry = No operation. Example:, Branch if Not Carry = HERE. Example:, Branch if Not Carry = . Example:, Branch if Not Carry = Jump. Example:, Branch if Not Carry = . Example:, Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = BNC. , Branch if Not Carry = . , Branch if Not Carry = . PC, Branch if Not Carry = Instruction. PC, Branch if Not Carry = . PC, Branch if Not Carry = . PC, Branch if Not Carry = . PC, Branch if Not Carry = . After Instruction Carry, Branch if Not Carry = . After Instruction Carry, Branch if Not Carry =",
    "PIC18F2331/2431/4331/4431\n=. After Instruction Carry, Branch if Not Carry = . After Instruction Carry, Branch if Not Carry = 0;. After Instruction Carry, Branch if Not Carry = 0;. , Branch if Not Carry = . , Branch if Not Carry = =. , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = + 2). , Branch if Not Carry = + 2). , Branch if Not Carry = PC. , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = (HERE. , Branch if Not Carry = (HERE. , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = address. , Branch if Not Carry = address. If Carry, Branch if Not Carry = . If Carry, Branch if Not Carry =",
    "PIC18F2331/2431/4331/4431\n. If Carry, Branch if Not Carry = . If Carry, Branch if Not Carry = . If Carry, Branch if Not Carry = . , Branch if Not Carry = =. , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = 1;. , Branch if Not Carry = . , Branch if Not Carry = address. , Branch if Not Carry = address. PC, Branch if Not Carry = . PC, Branch if Not Carry = . PC, Branch if Not Carry = . PC, Branch if Not Carry = . PC, Branch if Not Carry = . , Branch if Not Carry = =. , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = (Jump). If, Branch if Not Carry = . If, Branch if Not Carry = . If, Branch if Not Carry = .",
    "PIC18F2331/2431/4331/4431\nIf, Branch if Not Carry = . If, Branch if Not Carry = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Negative = if Negative bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ', (PC)",
    "PIC18F2331/2431/4331/4431\n+ 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 0111. Encoding:, Branch if Not Negative = nnnn. Encoding:, Branch if Not Negative = nnnn. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the",
    "PIC18F2331/2431/4331/4431\nprogram will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's",
    "PIC18F2331/2431/4331/4431\ncomplement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Q Cycle If Jump:, Branch if Not Negative = Activity:. Q Cycle If Jump:, Branch if Not Negative = Activity:. Q Cycle If Jump:, Branch if Not Negative = Activity:. Q Cycle If Jump:, Branch if Not Negative = Activity:. Q Cycle If Jump:, Branch if Not Negative = Activity:. Q1, Branch if Not",
    "PIC18F2331/2431/4331/4431\nNegative = Q2. Q1, Branch if Not Negative = . Q1, Branch if Not Negative = Q3. Q1, Branch if Not Negative = . Q1, Branch if Not Negative = Q4. , Branch if Not Negative = Decode. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Process Data. , Branch if Not Negative = Process Data. , Branch if Not Negative = Write to PC. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. If No Jump:, Branch if Not Negative = If No Jump:. If No Jump:, Branch if Not Negative = If No Jump:. If No Jump:, Branch if Not Negative = If No Jump:. If No Jump:, Branch if Not Negative = If No Jump:. If No Jump:, Branch if Not Negative = If No Jump:. , Branch if Not Negative = Q1. , Branch if Not Negative = Q2. , Branch if Not Negative = Q3. ,",
    "PIC18F2331/2431/4331/4431\nBranch if Not Negative = Q3. , Branch if Not Negative = Q4. , Branch if Not Negative = Decode. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Process Data. , Branch if Not Negative = Process Data. , Branch if Not Negative = No operation. Example:, Branch if Not Negative = Example:. Example:, Branch if Not Negative = HERE. Example:, Branch if Not Negative = BNN. Example:, Branch if Not Negative = Jump. Example:, Branch if Not Negative = . Before Instruction PC, Branch if Not Negative = Before Instruction PC. Before Instruction PC, Branch if Not Negative = =. Before Instruction PC, Branch if Not Negative = address. Before Instruction PC, Branch if Not Negative = (HERE). Before Instruction PC, Branch if Not Negative = . After Instruction If Negative, Branch if Not Negative = PC. After Instruction If Negative, Branch if Not Negative = = =. After Instruction If Negative, Branch if Not Negative = 0; address. After Instruction If Negative, Branch if Not Negative = (Jump). After Instruction If Negative, Branch if Not Negative = . If Negative = PC",
    "PIC18F2331/2431/4331/4431\n=, Branch if Not Negative = If Negative = PC =. If Negative = PC =, Branch if Not Negative = . If Negative = PC =, Branch if Not Negative = 1; address. If Negative = PC =, Branch if Not Negative = (HERE. If Negative = PC =, Branch if Not Negative = + 2)",
    "PIC18F2331/2431/4331/4431\nBNOV, 1 = BNOV. BNOV, 2 = Branch if Not Overflow. BNOV, 3 = Branch if Not Overflow. BNOV, 4 = Branch if Not Overflow. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] BNOV n. Syntax:, 3 = [ label ] BNOV n. Syntax:, 4 = [ label ] BNOV n. Operands:, 1 = Operands:. Operands:, 2 = -128 \uf0a3 n \uf0a3 127. Operands:, 3 = -128 \uf0a3 n \uf0a3 127. Operands:, 4 = -128 \uf0a3 n \uf0a3 127. Operation:, 1 = Operation:. Operation:, 2 = if Overflow bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Operation:, 3 = if Overflow bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Operation:, 4 = if Overflow bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None.",
    "PIC18F2331/2431/4331/4431\nEncoding:, 1 = Encoding:. Encoding:, 2 = 1110. Encoding:, 3 = 0101. Encoding:, 4 = nnnn. Description:, 1 = Description:. Description:, 2 = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 3 = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, 4 = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch",
    "PIC18F2331/2431/4331/4431\nthe next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1(2). Cycles:, 3 = 1(2). Cycles:, 4 = 1(2). Q Cycle Activity: If Jump:, 1 = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, 2 = . Q Cycle Activity: If Jump:, 3 = . Q Cycle Activity: If Jump:, 4 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read literal 'n'. , 3 = Process Data. , 4 = Process Data. , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = No operation. If No Jump:, 1 = If No Jump:. If No Jump:, 2 = . If No",
    "PIC18F2331/2431/4331/4431\nJump:, 3 = . If No Jump:, 4 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = Q3. , 1 = Decode. , 2 = Read literal 'n'. , 3 = Process Data. , 4 = Process Data. Example:, 1 = Example:. Example:, 2 = HERE. Example:, 3 = BNOV. Example:, 4 = Jump. Before Instruction PC = address (HERE), 1 = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), 2 = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), 3 = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), 4 = Before Instruction PC = address (HERE). , 1 = After Instruction. , 2 = . , 3 = . , 4 = . , 1 = If Overflow PC. , 2 = = =. , 3 = 0; address. , 4 = (Jump). , 1 = If Overflow PC. , 2 = = =. , 3 = 1; address.",
    "PIC18F2331/2431/4331/4431\n, 4 = (HERE",
    "PIC18F2331/2431/4331/4431\nSyntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Zero = if Zero bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if Zero bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if Zero bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if Zero bit is ' 0 ', (PC)",
    "PIC18F2331/2431/4331/4431\n+ 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if Zero bit is ' 0 ', (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Encoding:, Branch if Not Zero = 1110. Encoding:, Branch if Not Zero = 1110. Encoding:, Branch if Not Zero = 0001. Encoding:, Branch if Not Zero = nnnn. Encoding:, Branch if Not Zero = nnnn. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the",
    "PIC18F2331/2431/4331/4431\nprogram will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's",
    "PIC18F2331/2431/4331/4431\ncomplement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Q Cycle Activity: If Jump:, Branch if Not Zero = . Q Cycle Activity: If Jump:, Branch if Not Zero = . Q Cycle Activity: If Jump:, Branch if Not Zero = . Q Cycle Activity: If Jump:, Branch if Not Zero = . Q Cycle Activity: If Jump:, Branch if Not Zero = . Q1, Branch if Not",
    "PIC18F2331/2431/4331/4431\nZero = Q2. Q1, Branch if Not Zero = . Q1, Branch if Not Zero = Q3. Q1, Branch if Not Zero = . Q1, Branch if Not Zero = Q4. , Branch if Not Zero = Decode. , Branch if Not Zero = Read literal 'n'. , Branch if Not Zero = Process Data. , Branch if Not Zero = Process Data. , Branch if Not Zero = Write to PC. , Branch if Not Zero = No operation. , Branch if Not Zero = No operation. , Branch if Not Zero = No operation. , Branch if Not Zero = No operation. , Branch if Not Zero = No operation. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. , Branch if Not Zero = Q1. , Branch if Not Zero = Q2. , Branch if Not Zero = Q3. ,",
    "PIC18F2331/2431/4331/4431\nBranch if Not Zero = Q3. , Branch if Not Zero = Q4. , Branch if Not Zero = Decode. , Branch if Not Zero = Read literal 'n'. , Branch if Not Zero = Process Data. , Branch if Not Zero = Process Data. , Branch if Not Zero = No operation. Example:, Branch if Not Zero = Example:. Example:, Branch if Not Zero = HERE. Example:, Branch if Not Zero = BNZ. Example:, Branch if Not Zero = Jump. Example:, Branch if Not Zero = . Before Instruction PC, Branch if Not Zero = Before Instruction PC. Before Instruction PC, Branch if Not Zero = =. Before Instruction PC, Branch if Not Zero = address. Before Instruction PC, Branch if Not Zero = (HERE). Before Instruction PC, Branch if Not Zero = . After Instruction If Zero, Branch if Not Zero = PC. After Instruction If Zero, Branch if Not Zero = = =. After Instruction If Zero, Branch if Not Zero = 0; address. After Instruction If Zero, Branch if Not Zero = (Jump). After Instruction If Zero, Branch if Not Zero = . , Branch if Not",
    "PIC18F2331/2431/4331/4431\nZero = If Zero PC. , Branch if Not Zero = = =. , Branch if Not Zero = 1; address. , Branch if Not Zero = (HERE. , Branch if Not Zero = + 2)",
    "PIC18F2331/2431/4331/4431\nSyntax:, Unconditional Branch = [ label ] BRA n. Syntax:, Unconditional Branch = [ label ] BRA n. Syntax:, Unconditional Branch = [ label ] BRA n. Syntax:, Unconditional Branch = [ label ] BRA n. Operands:, Unconditional Branch = -1024 \uf0a3 n \uf0a3 1023. Operands:, Unconditional Branch = -1024 \uf0a3 n \uf0a3 1023. Operands:, Unconditional Branch = -1024 \uf0a3 n \uf0a3 1023. Operands:, Unconditional Branch = -1024 \uf0a3 n \uf0a3 1023. Operation:, Unconditional Branch = (PC) + 2 + 2n \uf0ae PC. Operation:, Unconditional Branch = (PC) + 2 + 2n \uf0ae PC. Operation:, Unconditional Branch = (PC) + 2 + 2n \uf0ae PC. Operation:, Unconditional Branch = (PC) + 2 + 2n \uf0ae PC. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Encoding:, Unconditional",
    "PIC18F2331/2431/4331/4431\nBranch = 1101. Encoding:, Unconditional Branch = 0nnn. Encoding:, Unconditional Branch = nnnn. Encoding:, Unconditional Branch = nnnn. Description:, Unconditional Branch = Add the 2's complement number, '2n', to the PC. Since the PC will have incre- mented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Unconditional Branch = Add the 2's complement number, '2n', to the PC. Since the PC will have incre- mented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Unconditional Branch = Add the 2's complement number, '2n', to the PC. Since the PC will have incre- mented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Unconditional Branch = Add the",
    "PIC18F2331/2431/4331/4431\n2's complement number, '2n', to the PC. Since the PC will have incre- mented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Words:, Unconditional Branch = 1. Words:, Unconditional Branch = 1. Words:, Unconditional Branch = 1. Words:, Unconditional Branch = 1. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Q Cycle Activity:, Unconditional Branch = . Q Cycle Activity:, Unconditional Branch = . Q Cycle Activity:, Unconditional Branch = . Q Cycle Activity:, Unconditional Branch = . Q1, Unconditional Branch = . Q1, Unconditional Branch = . Q1, Unconditional Branch = . Q1, Unconditional Branch = . , Unconditional Branch = Q2. , Unconditional Branch = Q2. , Unconditional Branch = Q3. ,",
    "PIC18F2331/2431/4331/4431\nUnconditional Branch = Q4. Decode, Unconditional Branch = Read literal 'n'. Decode, Unconditional Branch = Read literal 'n'. Decode, Unconditional Branch = Process Data. Decode, Unconditional Branch = Write to PC. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. Example:, Unconditional Branch = HERE. Example:, Unconditional Branch = BRA. Example:, Unconditional Branch = Jump. Example:, Unconditional Branch = . Before Instruction PC, Unconditional Branch = =. Before Instruction PC, Unconditional Branch = address. Before Instruction PC, Unconditional Branch = (HERE). Before Instruction PC, Unconditional Branch = . After Instruction PC, Unconditional Branch = =. After Instruction PC, Unconditional Branch = address. After Instruction PC, Unconditional Branch = (Jump). After Instruction PC, Unconditional Branch = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, Bit Set f = [ label ] BSF f,b[,a]. Syntax:, Bit Set f = [ label ] BSF f,b[,a]. Syntax:, Bit Set f = [ label ] BSF f,b[,a]. Syntax:, Bit Set f = [ label ] BSF f,b[,a]. Operands:, Bit Set f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7. Operands:, Bit Set f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7. Operands:, Bit Set f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7. Operands:, Bit Set f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7. Operation:, Bit Set f = 1 \uf0ae f<b>. Operation:, Bit Set f = 1 \uf0ae f<b>. Operation:, Bit Set f = 1 \uf0ae f<b>. Operation:, Bit Set f = 1 \uf0ae f<b>. Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = None. Encoding:, Bit Set f = 1000.",
    "PIC18F2331/2431/4331/4431\nEncoding:, Bit Set f = bbba. Encoding:, Bit Set f = . Encoding:, Bit Set f = ffff. Description:, Bit Set f = Bit 'b' in register, 'f', is set. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register, 'f', is set. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register, 'f', is set. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register, 'f', is",
    "PIC18F2331/2431/4331/4431\nset. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Bit Set f = 1. Words:, Bit Set f = 1. Words:, Bit Set f = 1. Words:, Bit Set f = 1. Cycles:, Bit Set f = 1. Cycles:, Bit Set f = 1. Cycles:, Bit Set f = 1. Cycles:, Bit Set f = 1. Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q1, Bit Set f = Q2. Q1, Bit Set f = Q2. Q1, Bit Set f = Q3. Q1, Bit Set f = Q3. Decode, Bit Set f = Read register 'f'. Decode, Bit Set f = Read register 'f'. Decode, Bit Set f = Process Data. Decode, Bit Set f = Process",
    "PIC18F2331/2431/4331/4431\nData. Example:, Bit Set f = BSF. Example:, Bit Set f = FLAG_REG, 7. Example:, Bit Set f = FLAG_REG, 7. Example:, Bit Set f = FLAG_REG, 7. Before Instruction FLAG_REG, Bit Set f = =. Before Instruction FLAG_REG, Bit Set f = 0x0A. Before Instruction FLAG_REG, Bit Set f = 0x0A. Before Instruction FLAG_REG, Bit Set f = 0x0A. After Instruction FLAG_REG, Bit Set f = =. After Instruction FLAG_REG, Bit Set f = 0x8A. After Instruction FLAG_REG, Bit Set f = 0x8A. After Instruction FLAG_REG, Bit Set f = 0x8A",
    "Bit Test File, Skip if Clear\nSyntax:\n[ label ]  BTFSC   f,b[,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b \uf0a3 7\na \uf0ce\uf020 [0,1]\nOperation:\nskip if (f<b>) = 0\nStatus Affected:\nNone\nEncoding:\n1011\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register, 'f', is ' 0 ', then the next instruction is skipped.\nIf bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded, and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Bit Test File, Skip if Set\nSyntax:\n[ label ]  BTFSS  f,b[,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b < 7\na \uf0ce\uf020 [0,1]\nOperation:\nskip if (f<b>) = 1\nStatus Affected:\nNone\nEncoding:\n1010\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register, 'f', is ' 1 ', then the next instruction is skipped.\nIf bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution, is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation\nIf skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE\nFALSE\nBTFSC FLAG, 1\n:\nTRUE\n:\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf FLAG<1>\n=\n0;\nPC\n=\naddress\n(TRUE)\nIf FLAG<1>\n=\n1;\nPC\n=\naddress\n(FALSE)\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation\nIf skip:\nQ1\nNo\nQ2\nNo\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation\nQ4",
    "Q Cycle Activity:\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nBefore Instruction PC, HERE = =. Before Instruction PC, BTFSS : = address. Before Instruction PC, FLAG, = (HERE). After Instruction If FLAG<1> PC, HERE = = =. After Instruction If FLAG<1> PC, BTFSS : = 0; address. After Instruction If FLAG<1> PC, FLAG, = (FALSE). If FLAG<1> PC, HERE = = =. If FLAG<1> PC, BTFSS : = 1; address. If FLAG<1> PC, FLAG, = (TRUE)",
    "PIC18F2331/2431/4331/4431\nSyntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f =",
    "PIC18F2331/2431/4331/4431\n(f<b>) \uf0ae f<b>. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Encoding:, Bit Toggle f = 0111. Encoding:, Bit Toggle f = bbba. Encoding:, Bit Toggle f = ffff. Encoding:, Bit Toggle f = ffff. Description:, Bit Toggle f = Bit 'b' in data memory location, 'f', is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Toggle f = Bit 'b' in data memory location, 'f', is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Toggle f",
    "PIC18F2331/2431/4331/4431\n= Bit 'b' in data memory location, 'f', is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Toggle f = Bit 'b' in data memory location, 'f', is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Q Cycle Activity:, Bit Toggle f = . Q Cycle Activity:, Bit Toggle f = . Q Cycle Activity:, Bit Toggle f = .",
    "PIC18F2331/2431/4331/4431\nQ Cycle Activity:, Bit Toggle f = . Q1, Bit Toggle f = Q2. Q1, Bit Toggle f = Q3. Q1, Bit Toggle f = Q4. Q1, Bit Toggle f = Q4. Decode, Bit Toggle f = Read register 'f'. Decode, Bit Toggle f = Process Data. Decode, Bit Toggle f = Write register 'f'. Decode, Bit Toggle f = Write register 'f'. Example: Before, Bit Toggle f = BTG. Example: Before, Bit Toggle f = PORTC,. Example: Before, Bit Toggle f = 4. Example: Before, Bit Toggle f = . Instruction: PORTC = After Instruction: PORTC =, Bit Toggle f = 0111 0110. Instruction: PORTC = After Instruction: PORTC =, Bit Toggle f = 0101 [0x75] 0101 [0x65]. Instruction: PORTC = After Instruction: PORTC =, Bit Toggle f = . Instruction: PORTC = After Instruction: PORTC =, Bit Toggle f",
    "PIC18F2331/2431/4331/4431\n= \nSyntax:, Branch if Overflow = [ label ] BOV n. Syntax:, Branch if Overflow = [ label ] BOV n. Syntax:, Branch if Overflow = [ label ] BOV n. Syntax:, Branch if Overflow = [ label ] BOV n. Syntax:, Branch if Overflow = [ label ] BOV n. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Overflow = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Overflow = if Overflow bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Overflow = if Overflow bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Overflow = if Overflow bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Overflow = if Overflow bit is ' 1",
    "PIC18F2331/2431/4331/4431\n', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Overflow = if Overflow bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Status Affected:, Branch if Overflow = None. Encoding:, Branch if Overflow = 1110. Encoding:, Branch if Overflow = 1110. Encoding:, Branch if Overflow = 0100. Encoding:, Branch if Overflow = nnnn. Encoding:, Branch if Overflow = nnnn. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Overflow = If the Overflow",
    "PIC18F2331/2431/4331/4431\nbit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Overflow = If the Overflow bit is ' 1",
    "PIC18F2331/2431/4331/4431\n', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch if Overflow = 1. Words:, Branch if Overflow = 1. Words:, Branch if Overflow = 1. Words:, Branch if Overflow = 1. Words:, Branch if Overflow = 1. Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Cycles:, Branch if Overflow = 1(2). Q Cycle If Jump:, Branch if Overflow = Activity:. Q Cycle If Jump:, Branch if Overflow = Activity:. Q Cycle If Jump:, Branch if Overflow = Activity:. Q Cycle If Jump:, Branch if Overflow = Activity:. Q Cycle If Jump:, Branch if",
    "PIC18F2331/2431/4331/4431\nOverflow = Activity:. Q1, Branch if Overflow = Q2. Q1, Branch if Overflow = . Q1, Branch if Overflow = Q3. Q1, Branch if Overflow = . Q1, Branch if Overflow = Q4. , Branch if Overflow = Decode. , Branch if Overflow = Read literal 'n'. , Branch if Overflow = Process Data. , Branch if Overflow = Process Data. , Branch if Overflow = Write to PC. , Branch if Overflow = No operation. , Branch if Overflow = No operation. , Branch if Overflow = No operation. , Branch if Overflow = No operation. , Branch if Overflow = No operation. If No Jump:, Branch if Overflow = If No Jump:. If No Jump:, Branch if Overflow = If No Jump:. If No Jump:, Branch if Overflow = If No Jump:. If No Jump:, Branch if Overflow = If No Jump:. If No Jump:, Branch if Overflow = If No Jump:. , Branch if Overflow = Q1. , Branch if Overflow =",
    "PIC18F2331/2431/4331/4431\nQ2. , Branch if Overflow = Q3. , Branch if Overflow = Q3. , Branch if Overflow = Q4. , Branch if Overflow = Decode. , Branch if Overflow = Read literal 'n'. , Branch if Overflow = Process Data. , Branch if Overflow = Process Data. , Branch if Overflow = No operation. Example:, Branch if Overflow = Example:. Example:, Branch if Overflow = HERE. Example:, Branch if Overflow = BOV. Example:, Branch if Overflow = JUMP. Example:, Branch if Overflow = . Before Instruction PC, Branch if Overflow = Before Instruction PC. Before Instruction PC, Branch if Overflow = =. Before Instruction PC, Branch if Overflow = address. Before Instruction PC, Branch if Overflow = (HERE). Before Instruction PC, Branch if Overflow = . After Instruction If Overflow, Branch if Overflow = PC. After Instruction If Overflow, Branch if Overflow = = =. After Instruction If Overflow, Branch if Overflow = 1; address. After Instruction If Overflow, Branch if Overflow =",
    "PIC18F2331/2431/4331/4431\n(JUMP). After Instruction If Overflow, Branch if Overflow = . If Overflow = PC =, Branch if Overflow = If Overflow = PC =. If Overflow = PC =, Branch if Overflow = . If Overflow = PC =, Branch if Overflow = 0; address. If Overflow = PC =, Branch if Overflow = (HERE. If Overflow = PC =, Branch if Overflow = + 2)",
    "PIC18F2331/2431/4331/4431\nSyntax:, Branch if Zero = [ label ] BZ n. Syntax:, Branch if Zero = [ label ] BZ n. Syntax:, Branch if Zero = [ label ] BZ n. Syntax:, Branch if Zero = [ label ] BZ n. Syntax:, Branch if Zero = [ label ] BZ n. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Zero = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Zero = if Zero bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Zero = if Zero bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Zero = if Zero bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Zero = if Zero bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Zero =",
    "PIC18F2331/2431/4331/4431\nif Zero bit is ' 1 ', (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Encoding:, Branch if Zero = 1110. Encoding:, Branch if Zero = 0000. Encoding:, Branch if Zero = nnnn. Encoding:, Branch if Zero = . Encoding:, Branch if Zero = nnnn. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have",
    "PIC18F2331/2431/4331/4431\nincremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number, '2n', is added to the PC. Since the PC will have incremented to fetch the next instruction, the new",
    "PIC18F2331/2431/4331/4431\naddress will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch if Zero = 1. Words:, Branch if Zero = 1. Words:, Branch if Zero = 1. Words:, Branch if Zero = 1. Words:, Branch if Zero = 1. Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Q Cycle Activity: If Jump:, Branch if Zero = . Q Cycle Activity: If Jump:, Branch if Zero = . Q Cycle Activity: If Jump:, Branch if Zero = . Q Cycle Activity: If Jump:, Branch if Zero = . Q Cycle Activity: If Jump:, Branch if Zero = . Q1, Branch if Zero = Q2. Q1, Branch if Zero = . Q1, Branch if Zero = Q3. Q1, Branch if Zero = . Q1, Branch if Zero = Q4. , Branch if Zero =",
    "PIC18F2331/2431/4331/4431\nDecode. , Branch if Zero = Read literal 'n'. , Branch if Zero = Process Data. , Branch if Zero = Process Data. , Branch if Zero = Write to PC. , Branch if Zero = No operation. , Branch if Zero = No operation. , Branch if Zero = No operation. , Branch if Zero = No operation. , Branch if Zero = No operation. If No Jump:, Branch if Zero = If No Jump:. If No Jump:, Branch if Zero = If No Jump:. If No Jump:, Branch if Zero = If No Jump:. If No Jump:, Branch if Zero = If No Jump:. If No Jump:, Branch if Zero = If No Jump:. , Branch if Zero = Q1. , Branch if Zero = Q2. , Branch if Zero = Q3. , Branch if Zero = Q3. , Branch if Zero = Q4. , Branch if Zero = Decode. , Branch if Zero = Read literal 'n'. , Branch if Zero = Process Data. , Branch if Zero = Process Data. , Branch if Zero = No operation. Example:, Branch if Zero = Example:.",
    "PIC18F2331/2431/4331/4431\nExample:, Branch if Zero = HERE. Example:, Branch if Zero = BZ. Example:, Branch if Zero = Jump. Example:, Branch if Zero = . Before Instruction PC, Branch if Zero = Before Instruction PC. Before Instruction PC, Branch if Zero = =. Before Instruction PC, Branch if Zero = address. Before Instruction PC, Branch if Zero = (HERE). Before Instruction PC, Branch if Zero = . After Instruction If Zero, Branch if Zero = PC. After Instruction If Zero, Branch if Zero = = =. After Instruction If Zero, Branch if Zero = 1; address. After Instruction If Zero, Branch if Zero = (Jump). After Instruction If Zero, Branch if Zero = . If Zero = PC =, Branch if Zero = If Zero = PC =. If Zero = PC =, Branch if Zero = . If Zero = PC =, Branch if Zero = 0; address. If Zero = PC =, Branch if Zero = (HERE. If Zero = PC =, Branch if Zero = + 2)",
    "PIC18F2331/2431/4331/4431\nSyntax:, Subroutine Call = [ label ] CALL k [,s]. Syntax:, Subroutine Call = [ label ] CALL k [,s]. Syntax:, Subroutine Call = [ label ] CALL k [,s]. Syntax:, Subroutine Call = [ label ] CALL k [,s]. Syntax:, Subroutine Call = [ label ] CALL k [,s]. Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, Subroutine Call = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operation:, Subroutine Call = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>; if s = 1 : (W) \uf0ae WS, (STATUS) \uf0ae STATUSS, (BSR) \uf0ae",
    "PIC18F2331/2431/4331/4431\nBSRS. Operation:, Subroutine Call = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>; if s = 1 : (W) \uf0ae WS, (STATUS) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, Subroutine Call = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>; if s = 1 : (W) \uf0ae WS, (STATUS) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, Subroutine Call = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>; if s = 1 : (W) \uf0ae WS, (STATUS) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, Subroutine Call = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>; if s = 1 : (W) \uf0ae WS, (STATUS) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Status",
    "PIC18F2331/2431/4331/4431\nAffected:, Subroutine Call = None. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = 110s k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = 110s k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Subroutine Call = kkkk 0 kkkk 8. Description:, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, the return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, STATUS and BSR registers are also pushed",
    "PIC18F2331/2431/4331/4431\ninto their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs. Then, the 20-bit value, 'k', is loaded into PC<20:1>. is a two-cycle. Description:, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, the return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, STATUS and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs. Then, the 20-bit value, 'k', is loaded into PC<20:1>. is a two-cycle. Description:, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, the return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, STATUS and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 ,",
    "PIC18F2331/2431/4331/4431\nno update occurs. Then, the 20-bit value, 'k', is loaded into PC<20:1>. is a two-cycle. Description:, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, the return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, STATUS and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs. Then, the 20-bit value, 'k', is loaded into PC<20:1>. is a two-cycle. Description:, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, the return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, STATUS and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs. Then, the 20-bit value, 'k', is loaded into",
    "PIC18F2331/2431/4331/4431\nPC<20:1>. is a two-cycle. Words:, Subroutine Call = 2. Words:, Subroutine Call = 2. Words:, Subroutine Call = 2. Words:, Subroutine Call = 2. Words:, Subroutine Call = 2. Cycles:, Subroutine Call = 2. Cycles:, Subroutine Call = 2. Cycles:, Subroutine Call = 2. Cycles:, Subroutine Call = 2. Cycles:, Subroutine Call = 2. Q Cycle Activity: Q1, Subroutine Call = Q2. Q Cycle Activity: Q1, Subroutine Call = Q2. Q Cycle Activity: Q1, Subroutine Call = Q3. Q Cycle Activity: Q1, Subroutine Call = . Q Cycle Activity: Q1, Subroutine Call = Q4. Decode, Subroutine Call = Read literal 'k'<7:0>,. Decode, Subroutine Call = Read literal 'k'<7:0>,. Decode, Subroutine Call = Push PC to Stack. Decode,",
    "PIC18F2331/2431/4331/4431\nSubroutine Call = Push PC to Stack. Decode, Subroutine Call = Read literal 'k'<19:8>, Write to PC. No operation, Subroutine Call = No operation. No operation, Subroutine Call = No operation. No operation, Subroutine Call = No operation. No operation, Subroutine Call = No operation. No operation, Subroutine Call = No operation. Example: HERE, Subroutine Call = Example: HERE. Example: HERE, Subroutine Call = Example: HERE. Example: HERE, Subroutine Call = CALL. Example: HERE, Subroutine Call = THERE,FAST. Example: HERE, Subroutine Call = THERE,FAST. Before Instruction PC = address (HERE), Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), Subroutine Call = Before Instruction PC = address",
    "PIC18F2331/2431/4331/4431\n(HERE). Before Instruction PC = address (HERE), Subroutine Call = Before Instruction PC = address (HERE). , Subroutine Call = =. , Subroutine Call = =. , Subroutine Call = . , Subroutine Call = . , Subroutine Call = . After Instruction, Subroutine Call = After Instruction. After Instruction, Subroutine Call = After Instruction. After Instruction, Subroutine Call = After Instruction. After Instruction, Subroutine Call = After Instruction. After Instruction, Subroutine Call = After Instruction. PC, Subroutine Call = address. PC, Subroutine Call = address. PC, Subroutine Call = (THERE). PC, Subroutine Call = . PC, Subroutine Call = . TOS, Subroutine Call = address. TOS, Subroutine Call = address. TOS, Subroutine Call = (HERE. TOS, Subroutine Call = + 4). TOS, Subroutine Call = . WS, Subroutine Call = W. WS, Subroutine Call = W. WS, Subroutine",
    "PIC18F2331/2431/4331/4431\nCall = . WS, Subroutine Call = . WS, Subroutine Call = . BSRS, Subroutine Call = BSR. BSRS, Subroutine Call = BSR. BSRS, Subroutine Call = . BSRS, Subroutine Call = . BSRS, Subroutine Call = . STATUSS =, Subroutine Call = STATUS. STATUSS =, Subroutine Call = STATUS. STATUSS =, Subroutine Call = . STATUSS =, Subroutine Call = . STATUSS =, Subroutine Call = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, Clear f = [ label ] CLRF f [,a]. Syntax:, Clear f = [ label ] CLRF f [,a]. Syntax:, Clear f = [ label ] CLRF f [,a]. Syntax:, Clear f = [ label ] CLRF f [,a]. Syntax:, Clear f = [ label ] CLRF f [,a]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operation:, Clear f = 000h \uf0ae f, 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f, 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f, 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f, 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f, 1 \uf0ae Z. Status Affected:, Clear f =",
    "PIC18F2331/2431/4331/4431\nZ. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Encoding:, Clear f = 0110. Encoding:, Clear f = 0110. Encoding:, Clear f = 101a. Encoding:, Clear f = ffff. Encoding:, Clear f = ffff. Description:, Clear f = Clears the contents of the specified reg- ister. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Clear f = Clears the contents of the specified reg- ister. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Clear f = Clears the contents of the specified reg- ister. If 'a' is ' 0 ', the Access Bank will be selected, overriding the",
    "PIC18F2331/2431/4331/4431\nBSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Clear f = Clears the contents of the specified reg- ister. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Clear f = Clears the contents of the specified reg- ister. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear",
    "PIC18F2331/2431/4331/4431\nf = . Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q1, Clear f = Q2. Q1, Clear f = Q2. Q1, Clear f = Q3. Q1, Clear f = Q3. Q1, Clear f = Q4. Decode, Clear f = Read register 'f'. Decode, Clear f = Read register 'f'. Decode, Clear f = Process Data. Decode, Clear f = Process Data. Decode, Clear f = Write register 'f'. Example: CLRF, Clear f = Example: CLRF. Example: CLRF, Clear f = FLAG_REG. Example: CLRF, Clear f = FLAG_REG. Example: CLRF, Clear f = FLAG_REG. Example: CLRF, Clear f = FLAG_REG. Before Instruction FLAG_REG =, Clear f = Before Instruction FLAG_REG =. Before Instruction FLAG_REG =, Clear f = 0x5A. Before Instruction FLAG_REG =, Clear f = 0x5A. Before Instruction FLAG_REG",
    "PIC18F2331/2431/4331/4431\n=, Clear f = 0x5A. Before Instruction FLAG_REG =, Clear f = 0x5A",
    "PIC18F2331/2431/4331/4431\nSyntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer",
    "PIC18F2331/2431/4331/4431\n= TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = . Encoding:, Clear Watchdog Timer = 0000. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post- scaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post- scaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post- scaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the post- scaler of the WDT. Status bits TO and PD are set.. Words:, Clear Watchdog Timer = 1.",
    "PIC18F2331/2431/4331/4431\nWords:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Q Cycle Activity:, Clear Watchdog Timer = . Q Cycle Activity:, Clear Watchdog Timer = . Q Cycle Activity:, Clear Watchdog Timer = . Q Cycle Activity:, Clear Watchdog Timer = . Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = Q3. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = Process Data. Example: CLRWDT, Clear Watchdog Timer = Example: CLRWDT. Example: CLRWDT, Clear Watchdog Timer = Example: CLRWDT. Example:",
    "PIC18F2331/2431/4331/4431\nCLRWDT, Clear Watchdog Timer = Example: CLRWDT. Example: CLRWDT, Clear Watchdog Timer = Example: CLRWDT. Before Instruction WDT Counter, Clear Watchdog Timer = Before Instruction WDT Counter. Before Instruction WDT Counter, Clear Watchdog Timer = = ?. Before Instruction WDT Counter, Clear Watchdog Timer = . Before Instruction WDT Counter, Clear Watchdog Timer = . After Instruction, Clear Watchdog Timer = After Instruction. After Instruction, Clear Watchdog Timer = . After Instruction, Clear Watchdog Timer = . After Instruction, Clear Watchdog Timer = . WDT Counter, Clear Watchdog Timer = WDT Counter. WDT Counter, Clear Watchdog Timer = =. WDT Counter, Clear Watchdog Timer = 0x00. WDT Counter, Clear Watchdog Timer = 0x00. WDT Postscaler, Clear Watchdog Timer = WDT Postscaler. WDT Postscaler, Clear Watchdog Timer = =. WDT Postscaler, Clear Watchdog Timer = 0. WDT Postscaler, Clear Watchdog Timer = 0. TO, Clear Watchdog Timer =",
    "PIC18F2331/2431/4331/4431\nTO. TO, Clear Watchdog Timer = =. TO, Clear Watchdog Timer = 1. TO, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = PD. PD, Clear Watchdog Timer = =. PD, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = 1",
    "PIC18F2331/2431/4331/4431\nSyntax:, Complement f = [ label ] COMF. Syntax:, Complement f = [ label ] COMF. Syntax:, Complement f = f [,d [,a]]. Syntax:, Complement f = f [,d [,a]]. Operands:, Complement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Complement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Complement f = . Operands:, Complement f = . Operation:, Complement f = (f) \uf0ae dest. Operation:, Complement f = (f) \uf0ae dest. Operation:, Complement f = . Operation:, Complement f = . Status Affected:, Complement f = N, Z. Status Affected:, Complement f = N, Z. Status Affected:, Complement f = . Status Affected:, Complement f = . Encoding:, Complement f = 0001. Encoding:, Complement f = 11da. Encoding:, Complement f = ffff. Encoding:, Complement f = ffff. Description:, Complement f = The contents of register,",
    "PIC18F2331/2431/4331/4431\n'f', are comple- mented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is 0 , the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Complement f = The contents of register, 'f', are comple- mented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is 0 , the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Complement f = The contents of register, 'f', are comple- mented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored",
    "PIC18F2331/2431/4331/4431\nback in register, 'f'. If 'a' is 0 , the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Complement f = The contents of register, 'f', are comple- mented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is 0 , the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Complement f = 1. Words:, Complement f = 1. Words:, Complement f = . Words:, Complement f = . Cycles:, Complement f = 1. Cycles:, Complement f = . Cycles:, Complement f = . Cycles:, Complement f = . Q Cycle Activity:, Complement f = . Q Cycle Activity:, Complement f = . Q Cycle Activity:, Complement f = . Q Cycle Activity:,",
    "PIC18F2331/2431/4331/4431\nComplement f = . Q1, Complement f = Q2. Q1, Complement f = Q3. Q1, Complement f = . Q1, Complement f = Q4. Decode, Complement f = Read register 'f'. Decode, Complement f = Process Data. Decode, Complement f = . Decode, Complement f = Write to destination. Example:, Complement f = COMF. Example:, Complement f = REG, W. Example:, Complement f = . Example:, Complement f = . Before Instruction, Complement f = Before Instruction. Before Instruction, Complement f = . Before Instruction, Complement f = . Before Instruction, Complement f = . REG, Complement f = = 0x13. REG, Complement f = . REG, Complement f = . REG, Complement f = . After Instruction, Complement f = After Instruction. After Instruction, Complement f = . After Instruction, Complement f = . After Instruction, Complement f = . REG, Complement f = = 0x13 =. REG, Complement f = . REG, Complement f = . REG, Complement f = . W, Complement f = 0xEC. W, Complement f = .",
    "PIC18F2331/2431/4331/4431\nW, Complement f = . W, Complement f = ",
    "Compare f with W, Skip if f = W\nSyntax:\n[ label ]   CPFSEQ    f [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce [0,1]\nOperation:\n(f) - (W),\nskip if (f) = (W)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n001a\nffff\nffff\nDescription:\nCompares the contents of data memory location, 'f', to the contents of W by performing an unsigned subtraction. If 'f' = W  then the fetched instruction is , discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nDecode\nQ1\nNo\nQ2\nRead register 'f'\nQ2\nNo\nQ3\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nNo operation\nNo\nNo operation\nNo\nNo operation\nNo\nQ4\nNo operation\nQ4\nNo operation\nQ4\nNo operation\nNo operation\noperation operation\noperation\nExample:\nHERE     CPFSEQ REG\nNEQUAL   :\nEQUAL    :\nBefore Instruction\nPC Address\n= HERE\nW\n= ?\nREG\n= ?\nAfter Instruction\nIf REG\n= W;\nPC\n= Address (EQUAL)\nIf REG\n\uf0b9 W;\nPC\n= Address (NEQUAL)\nIf skip:",
    "PIC18F2331/2431/4331/4431\nSyntax:, Compare f with W, Skip if f > W = [ label ] CPFSGT f [,a]. Syntax:, Compare f with W, Skip if f > W = [ label ] CPFSGT f [,a]. Syntax:, Compare f with W, Skip if f > W = [ label ] CPFSGT f [,a]. Syntax:, Compare f with W, Skip if f > W = [ label ] CPFSGT f [,a]. Syntax:, Compare f with W, Skip if f > W = [ label ] CPFSGT f [,a]. Operands:, Compare f with W, Skip if f > W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f > W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f > W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f > W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f",
    "PIC18F2331/2431/4331/4431\n> W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Compare f with W, Skip if f > W = (f) \uf02d\uf020\uf028 W), skip if (f) > (W) (unsigned comparison). Operation:, Compare f with W, Skip if f > W = (f) \uf02d\uf020\uf028 W), skip if (f) > (W) (unsigned comparison). Operation:, Compare f with W, Skip if f > W = (f) \uf02d\uf020\uf028 W), skip if (f) > (W) (unsigned comparison). Operation:, Compare f with W, Skip if f > W = (f) \uf02d\uf020\uf028 W), skip if (f) > (W) (unsigned comparison). Operation:, Compare f with W, Skip if f > W = (f) \uf02d\uf020\uf028 W), skip if (f) > (W) (unsigned comparison). Status Affected:, Compare f with W, Skip if f > W = None. Status Affected:, Compare f with W, Skip if f > W = None. Status Affected:, Compare f with W, Skip if f > W = None. Status Affected:, Compare f with",
    "PIC18F2331/2431/4331/4431\nW, Skip if f > W = None. Status Affected:, Compare f with W, Skip if f > W = None. Encoding:, Compare f with W, Skip if f > W = 0110. Encoding:, Compare f with W, Skip if f > W = 0110. Encoding:, Compare f with W, Skip if f > W = 010a. Encoding:, Compare f with W, Skip if f > W = ffff. Encoding:, Compare f with W, Skip if f > W = ffff. Description:, Compare f with W, Skip if f > W = Compares the contents of data memory location, 'f', to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two- cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will. Description:, Compare f with W, Skip if f > W = Compares",
    "PIC18F2331/2431/4331/4431\nthe contents of data memory location, 'f', to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two- cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will. Description:, Compare f with W, Skip if f > W = Compares the contents of data memory location, 'f', to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two- cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will. Description:, Compare f with W, Skip if f > W = Compares the contents of data memory location, 'f', to the contents",
    "PIC18F2331/2431/4331/4431\nof the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two- cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will. Description:, Compare f with W, Skip if f > W = Compares the contents of data memory location, 'f', to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two- cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will. Words:, Compare f with W, Skip if f > W = . Words:, Compare f with W, Skip if f > W = . Words:, Compare f with W, Skip if f > W",
    "PIC18F2331/2431/4331/4431\n= . Words:, Compare f with W, Skip if f > W = . Words:, Compare f with W, Skip if f > W = . Cycles:, Compare f with W, Skip if f > W = 1(2) Note: 3 cycles if skip and followed. Cycles:, Compare f with W, Skip if f > W = 1(2) Note: 3 cycles if skip and followed. Cycles:, Compare f with W, Skip if f > W = 1(2) Note: 3 cycles if skip and followed. Cycles:, Compare f with W, Skip if f > W = 1(2) Note: 3 cycles if skip and followed. Cycles:, Compare f with W, Skip if f > W = 1(2) Note: 3 cycles if skip and followed. Q Cycle Activity:, Compare f with W, Skip if f > W = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, Skip if f > W = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, Skip if f > W = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, Skip if",
    "PIC18F2331/2431/4331/4431\nf > W = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, Skip if f > W = Q Cycle Activity:. Q1, Compare f with W, Skip if f > W = Q2. Q1, Compare f with W, Skip if f > W = Q2. Q1, Compare f with W, Skip if f > W = Q3. Q1, Compare f with W, Skip if f > W = Q4. Q1, Compare f with W, Skip if f > W = Q4. Decode, Compare f with W, Skip if f > W = Read register 'f'. Decode, Compare f with W, Skip if f > W = Read register 'f'. Decode, Compare f with W, Skip if f > W = Process Data. Decode, Compare f with W, Skip if f > W = No operation. Decode, Compare f with W, Skip if f > W = No operation. If skip:, Compare f with W, Skip if f > W = If skip:. If skip:, Compare f with W, Skip if f > W = If",
    "PIC18F2331/2431/4331/4431\nskip:. If skip:, Compare f with W, Skip if f > W = If skip:. If skip:, Compare f with W, Skip if f > W = If skip:. If skip:, Compare f with W, Skip if f > W = If skip:. Q1, Compare f with W, Skip if f > W = Q2. Q1, Compare f with W, Skip if f > W = Q2. Q1, Compare f with W, Skip if f > W = Q3. Q1, Compare f with W, Skip if f > W = Q4. Q1, Compare f with W, Skip if f > W = Q4. No, Compare f with W, Skip if f > W = No. No, Compare f with W, Skip if f > W = No. No, Compare f with W, Skip if f > W = No. No, Compare f with W, Skip if f > W = No. No, Compare f with W, Skip if f > W = No. operation, Compare f with W, Skip if f > W = operation. operation, Compare f with W,",
    "PIC18F2331/2431/4331/4431\nSkip if f > W = operation. operation, Compare f with W, Skip if f > W = operation. operation, Compare f with W, Skip if f > W = operation. operation, Compare f with W, Skip if f > W = operation. If skip and followed by 2-word instruction:, Compare f with W, Skip if f > W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, Skip if f > W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, Skip if f > W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, Skip if f > W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, Skip if f > W = If skip and followed by 2-word instruction:. Q1, Compare f with W, Skip if f > W = Q2. Q1, Compare f with",
    "PIC18F2331/2431/4331/4431\nW, Skip if f > W = Q2. Q1, Compare f with W, Skip if f > W = Q3. Q1, Compare f with W, Skip if f > W = Q4. Q1, Compare f with W, Skip if f > W = Q4. No operation, Compare f with W, Skip if f > W = No operation. No operation, Compare f with W, Skip if f > W = No operation. No operation, Compare f with W, Skip if f > W = No operation. No operation, Compare f with W, Skip if f > W = No operation. No operation, Compare f with W, Skip if f > W = No operation. No operation, Compare f with W, Skip if f > W = No operation. No operation, Compare f with W, Skip if f > W = No operation. No operation, Compare f with W, Skip if f > W = No operation. No operation, Compare f with W, Skip if f > W = No operation. No operation, Compare f with W, Skip if f > W = No operation. Example:, Compare f with W, Skip if",
    "PIC18F2331/2431/4331/4431\nf > W = HERE NGREATER. Example:, Compare f with W, Skip if f > W = HERE NGREATER. Example:, Compare f with W, Skip if f > W = CPFSGT REG : :. Example:, Compare f with W, Skip if f > W = CPFSGT REG : :. Example:, Compare f with W, Skip if f > W = CPFSGT REG : :. Before Instruction, Compare f with W, Skip if f > W = Before Instruction. Before Instruction, Compare f with W, Skip if f > W = Before Instruction. Before Instruction, Compare f with W, Skip if f > W = Before Instruction. Before Instruction, Compare f with W, Skip if f > W = Before Instruction. Before Instruction, Compare f with W, Skip if f > W = Before Instruction. PC W, Compare f with W, Skip if f > W = = =. PC W, Compare f with W, Skip if f > W = Address (HERE). PC W, Compare f with W, Skip if f > W = Address (HERE). PC W, Compare f with W, Skip if f",
    "PIC18F2331/2431/4331/4431\n> W = Address (HERE). PC W, Compare f with W, Skip if f > W = Address (HERE). After Instruction, Compare f with W, Skip if f > W = After Instruction. After Instruction, Compare f with W, Skip if f > W = After Instruction. After Instruction, Compare f with W, Skip if f > W = After Instruction. After Instruction, Compare f with W, Skip if f > W = After Instruction. After Instruction, Compare f with W, Skip if f > W = After Instruction. If REG PC, Compare f with W, Skip if f > W = \uf03e =. If REG PC, Compare f with W, Skip if f > W = W;. If REG PC, Compare f with W, Skip if f > W = W;. If REG PC, Compare f with W, Skip if f > W = W;. If REG PC, Compare f with W, Skip if f > W = W;. If REG, Compare f with W, Skip if f > W = \uf0a3. If REG, Compare f with W, Skip if f > W = Address (GREATER) W;. If REG, Compare f",
    "PIC18F2331/2431/4331/4431\nwith W, Skip if f > W = Address (GREATER) W;. If REG, Compare f with W, Skip if f > W = Address (GREATER) W;. If REG, Compare f with W, Skip if f > W = Address (GREATER) W;. PC, Compare f with W, Skip if f > W = =. PC, Compare f with W, Skip if f > W = Address (NGREATER). PC, Compare f with W, Skip if f > W = Address (NGREATER). PC, Compare f with W, Skip if f > W = Address (NGREATER). PC, Compare f with W, Skip if f > W = Address (NGREATER)",
    "PIC18F2331/2431/4331/4431\nSyntax:, Compare f with W, Skip if f < W = [ label ] CPFSLT. Syntax:, Compare f with W, Skip if f < W = [ label ] CPFSLT. Syntax:, Compare f with W, Skip if f < W = f [,a]. Syntax:, Compare f with W, Skip if f < W = . Operands:, Compare f with W, Skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, Skip if f < W = . Operands:, Compare f with W, Skip if f < W = . Operation:, Compare f with W, Skip if f < W = (f) - \uf020\uf028 W), skip if (f) < (W) (unsigned comparison). Operation:, Compare f with W, Skip if f < W = (f) - \uf020\uf028 W), skip if (f) < (W) (unsigned comparison). Operation:, Compare f with W, Skip if f < W",
    "PIC18F2331/2431/4331/4431\n= . Operation:, Compare f with W, Skip if f < W = . Status Affected:, Compare f with W, Skip if f < W = None. Status Affected:, Compare f with W, Skip if f < W = . Status Affected:, Compare f with W, Skip if f < W = . Status Affected:, Compare f with W, Skip if f < W = . Encoding:, Compare f with W, Skip if f < W = 0110. Encoding:, Compare f with W, Skip if f < W = 000a. Encoding:, Compare f with W, Skip if f < W = ffff. Encoding:, Compare f with W, Skip if f < W = ffff. Description:, Compare f with W, Skip if f < W = Compares the contents of data memory location, 'f', to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be",
    "PIC18F2331/2431/4331/4431\nselected. If 'a' is ' 1 ', the BSR will not be overridden.. Description:, Compare f with W, Skip if f < W = Compares the contents of data memory location, 'f', to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden.. Description:, Compare f with W, Skip if f < W = Compares the contents of data memory location, 'f', to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not",
    "PIC18F2331/2431/4331/4431\nbe overridden.. Description:, Compare f with W, Skip if f < W = Compares the contents of data memory location, 'f', to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden.. Words:, Compare f with W, Skip if f < W = 1. Words:, Compare f with W, Skip if f < W = . Words:, Compare f with W, Skip if f < W = . Words:, Compare f with W, Skip if f < W = . Cycles:, Compare f with W, Skip if f < W = 1(2) Note:. Cycles:, Compare f with W, Skip if f < W = cycles if skip. Cycles:, Compare f with W, Skip if f < W = . Cycles:, Compare f with W,",
    "PIC18F2331/2431/4331/4431\nSkip if f < W = followed",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. If skip:, Q2 = If skip:. If skip:, Q3 = If skip:. If skip:, Q4 = If skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation,",
    "Q Cycle Activity:\nQ3 = No operation. No operation, Q4 = No operation\nExample:\nHERE    CPFSLT REG\nNLESS   :\nLESS    :\nBefore Instruction\nPC\n=\nAddress (HERE)\nW\n=\n?\nAfter Instruction\nIf REG\n<\nW;\nPC\n=\nAddress (LESS)\nIf REG\n\uf0b3 W;\nPC\n= Address (NLESS)",
    "Decimal Adjust W Register\nSyntax:\n[\nlabel\n]   DAW\nOperands:\nNone\nOperation:\nIf [W<3:0> > 9] or [DC = 1 ] then, (W<3:0>) + 6 \uf0ae W<3:0>; else, ( W<3:0>) \uf0ae W<3:0>;\nIf [W<7:4> 9] or [C = 1 ] then, ( W<7:4>) + 6 \uf0ae W<7:4>; else, (W<7:4>) \uf0ae W<7:4>\nStatus Affected:\nC, DC\nEncoding:\n0000\n0000\n0000\n0111\nDescription:\nDAW adjusts the 8-bit value in W,\nresulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result. The Carry bit may be set by DAW regardless of its setting prior to the DAW instruction.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister W\nProcess\nData\nWrite\nW\nExample 1:\nDAW\nBefore Instruction\nW\n=\n0xA5\nC\n=\n0\nDC\n=\n0\nAfter Instruction\nW\n=\n0x05\nC\n=\n1\nDC\n=\n0",
    "Example 2:\nBefore Instruction\nW\n=\n0xCE\nC\n=\n0\nDC\n=\n0\nAfter Instruction\nW\n=\n0x34\nC\n=\n1\nDC\n=\n0",
    "Example 2:\nSyntax:, Decrement f = [ label ] DECF f [,d [,a]]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae",
    "Example 2:\ndest. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Encoding:, Decrement f = 0000. Encoding:, Decrement f = 01da. Encoding:, Decrement f = ffff. Encoding:, Decrement f = ffff. Description:, Decrement f = Decrement register, 'f',. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Decrement f = Decrement register, 'f',. If 'd' is ' 0 ',",
    "Example 2:\nthe result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Decrement f = Decrement register, 'f',. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Decrement f = Decrement register, 'f',. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a'",
    "Example 2:\n= 1 , then the bank will be selected as per the BSR value.. Words:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q1, Decrement f = Q2. Q1, Decrement f = Q3. Q1, Decrement f = . Q1, Decrement f = Q4. Decode, Decrement f = Read register 'f'. Decode, Decrement f = Process Data. Decode, Decrement f = . Decode, Decrement f = Write to destination. Example:, Decrement f = DECF. Example:, Decrement f = CNT,.",
    "Example 2:\nExample:, Decrement f = . Example:, Decrement f = . Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = . Before Instruction, Decrement f = . Before Instruction, Decrement f = . CNT, Decrement f = = 0x01. CNT, Decrement f = . CNT, Decrement f = . CNT, Decrement f = . Z, Decrement f = = 0. Z, Decrement f = . Z, Decrement f = . Z, Decrement f = . After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = . After Instruction, Decrement f = . After Instruction, Decrement f = . CNT Z, Decrement f = = 0x00 =. CNT Z, Decrement f = . CNT Z, Decrement f = . CNT Z, Decrement f = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, Decrement f, Skip if 0 = [ label ] DECFSZ. Syntax:, Decrement f, Skip if 0 = [ label ] DECFSZ. Syntax:, Decrement f, Skip if 0 = f [,d [,a]]. Syntax:, Decrement f, Skip if 0 = . Operands:, Decrement f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Decrement f, Skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, Decrement f, Skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0.",
    "PIC18F2331/2431/4331/4431\nOperation:, Decrement f, Skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, Decrement f, Skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Status Affected:, Decrement f, Skip if 0 = None. Status Affected:, Decrement f, Skip if 0 = . Status Affected:, Decrement f, Skip if 0 = . Status Affected:, Decrement f, Skip if 0 = . Encoding:, Decrement f, Skip if 0 = 0010. Encoding:, Decrement f, Skip if 0 = 11da. Encoding:, Decrement f, Skip if 0 = ffff. Encoding:, Decrement f, Skip if 0 = ffff. Description:, Decrement f, Skip if 0 = The contents of register, 'f', are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is ' 0 ', the next",
    "PIC18F2331/2431/4331/4431\ninstruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Decrement f, Skip if 0 = The contents of register, 'f', are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is ' 0 ', the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Decrement f, Skip if 0 = The contents of register, 'f', are decremented. If",
    "PIC18F2331/2431/4331/4431\n'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is ' 0 ', the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Decrement f, Skip if 0 = The contents of register, 'f', are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is ' 0 ', the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If",
    "PIC18F2331/2431/4331/4431\n'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Decrement f, Skip if 0 = 1. Words:, Decrement f, Skip if 0 = . Words:, Decrement f, Skip if 0 = . Words:, Decrement f, Skip if 0 = . Cycles:, Decrement f, Skip if 0 = 1(2). Cycles:, Decrement f, Skip if 0 = . Cycles:, Decrement f, Skip if 0 = . Cycles:, Decrement f, Skip if 0 = \nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "PIC18F2331/2431/4331/4431\nSyntax:, Decrement f, Skip if Not 0 = [ label ] DCFSNZ. Syntax:, Decrement f, Skip if Not 0 = [ label ] DCFSNZ. Syntax:, Decrement f, Skip if Not 0 = f [,d [,a]]. Syntax:, Decrement f, Skip if Not 0 = . Operands:, Decrement f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, Skip if Not 0 = . Operands:, Decrement f, Skip if Not 0 = . Operation:, Decrement f, Skip if Not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, Skip if Not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, Skip if Not 0 = . Operation:, Decrement f, Skip",
    "PIC18F2331/2431/4331/4431\nif Not 0 = . Status Affected:, Decrement f, Skip if Not 0 = None. Status Affected:, Decrement f, Skip if Not 0 = None. Status Affected:, Decrement f, Skip if Not 0 = . Status Affected:, Decrement f, Skip if Not 0 = . Encoding:, Decrement f, Skip if Not 0 = 0100. Encoding:, Decrement f, Skip if Not 0 = 11da. Encoding:, Decrement f, Skip if Not 0 = ffff. Encoding:, Decrement f, Skip if Not 0 = ffff. Description:, Decrement f, Skip if Not 0 = The contents of register, 'f', are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is not ' 0 ', the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ',",
    "PIC18F2331/2431/4331/4431\nthe Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Decrement f, Skip if Not 0 = The contents of register, 'f', are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is not ' 0 ', the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Decrement f, Skip if Not 0 = The contents of register, 'f', are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is not ' 0 ', the next instruction,",
    "PIC18F2331/2431/4331/4431\nwhich is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Decrement f, Skip if Not 0 = The contents of register, 'f', are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is not ' 0 ', the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Words:, Decrement f, Skip if Not 0 = 1. Words:, Decrement f, Skip if Not 0 = . Words:, Decrement f, Skip if Not 0 = .",
    "PIC18F2331/2431/4331/4431\nWords:, Decrement f, Skip if Not 0 = . Cycles:, Decrement f, Skip if Not 0 = 1(2) Note:. Cycles:, Decrement f, Skip if Not 0 = . Cycles:, Decrement f, Skip if Not 0 = . Cycles:, Decrement f, Skip if Not 0 = ",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. If skip:, Q2 = . If skip:, Q3 = . If skip:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word, Q2 = skip and followed by 2-word. skip and followed by 2-word, Q3 = instruction:. skip and followed by 2-word, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. Example:, Q2 = HERE. Example:, Q3 = DECFSZ",
    "Q Cycle Activity:\nGOTO. Example:, Q4 = CNT LOOP. Before Instruction PC =, Q2 = . Before Instruction PC =, Q3 = . Before Instruction PC =, Q4 = . After, Q2 = Address. After, Q3 = (HERE). After, Q4 = . Instruction, Q2 = Instruction. Instruction, Q3 = . Instruction, Q4 = . CNT, Q2 = = CNT - 1. CNT, Q3 = . CNT, Q4 = . If CNT, Q2 = =. If CNT, Q3 = . If CNT, Q4 = . PC, Q2 = 0; = Address. PC, Q3 = (CONTINUE). PC, Q4 = . If CNT, Q2 = \uf0b9 0;. If CNT, Q3 = . If CNT, Q4 = . PC, Q2 = = Address. PC, Q3 = (HERE + 2). PC, Q4 = ",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. If skip:, Q2 = If skip:. If skip:, Q3 = If skip:. If skip:, Q4 = If skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No",
    "Q Cycle Activity:\noperation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE    DCFSNZ  TEMP\nZERO    :\nNZERO   :\nBefore Instruction TEMP\n=\n?\nAfter Instruction\nTEMP\n=\nTEMP - 1,\nIf TEMP\n=\n0;\nPC\n=\nAddress\n(ZERO)\nIf TEMP\n\uf0b9\n0;\nPC\n= Address (NZERO)",
    "PIC18F2331/2431/4331/4431\nSyntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Encoding: 1st word (k<7:0>) 2nd",
    "PIC18F2331/2431/4331/4431\nword(k<19:8>), Unconditional Branch = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = 1111 k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = kkkk 0 kkkk 8. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value, 'k', is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value, 'k', is loaded into PC<20:1>. GOTO is always a two-cycle instruction..",
    "PIC18F2331/2431/4331/4431\nDescription:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value, 'k', is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value, 'k', is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle",
    "PIC18F2331/2431/4331/4431\nActivity:, Unconditional Branch = Q Cycle Activity:. Q1, Unconditional Branch = Q2. Q1, Unconditional Branch = Q3. Q1, Unconditional Branch = . Q1, Unconditional Branch = Q4. Decode, Unconditional Branch = Read literal 'k'<7:0>,. Decode, Unconditional Branch = No operation. Decode, Unconditional Branch = No operation. Decode, Unconditional Branch = Read literal 'k'<19:8>, Write to PC. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation. No operation, Unconditional Branch = No operation\nExample:\nGOTO THERE\nAfter Instruction\nPC = Address (THERE)",
    "PIC18F2331/2431/4331/4431\nSyntax:, Increment f = [ label ] INCF f [,d [,a]]. Syntax:, Increment f = [ label ] INCF f [,d [,a]]. Syntax:, Increment f = [ label ] INCF f [,d [,a]]. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = (f) + 1 \uf0ae dest. Status Affected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f =",
    "PIC18F2331/2431/4331/4431\nC, DC, N, OV, Z. Encoding:, Increment f = 0010. Encoding:, Increment f = 10da ffff. Encoding:, Increment f = ffff. Description:, Increment f = The contents of register, 'f', are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Increment f = The contents of register, 'f', are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the",
    "PIC18F2331/2431/4331/4431\nbank will be selected as per the BSR value.. Description:, Increment f = The contents of register, 'f', are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Increment f = 1. Words:, Increment f = 1. Words:, Increment f = 1. Cycles:, Increment f = 1. Cycles:, Increment f = 1. Cycles:, Increment f = 1. Q Cycle Activity:, Increment f = Q Cycle Activity:. Q Cycle Activity:, Increment f = Q Cycle Activity:. Q Cycle Activity:, Increment f = Q Cycle Activity:. Q1, Increment f = Q2. Q1, Increment f =",
    "PIC18F2331/2431/4331/4431\nQ3. Q1, Increment f = Q4. Decode, Increment f = Read register 'f'. Decode, Increment f = Process Data. Decode, Increment f = Write to destination. Example:, Increment f = INCF. Example:, Increment f = CNT,. Example:, Increment f = . Before Instruction, Increment f = Before Instruction. Before Instruction, Increment f = Before Instruction. Before Instruction, Increment f = Before Instruction. CNT, Increment f = = 0xFF = 0. CNT, Increment f = . CNT, Increment f = . Z, Increment f = . Z, Increment f = . Z, Increment f = . C, Increment f = = ?. C, Increment f = . C, Increment f = . DC, Increment f = = ?. DC, Increment f = . DC, Increment f = . After Instruction, Increment f = After Instruction. After Instruction, Increment",
    "PIC18F2331/2431/4331/4431\nf = After Instruction. After Instruction, Increment f = After Instruction. CNT, Increment f = = 0x00. CNT, Increment f = . CNT, Increment f = . Z, Increment f = = 1. Z, Increment f = . Z, Increment f = . C, Increment f = = 1. C, Increment f = . C, Increment f = . DC, Increment f = = 1. DC, Increment f = . DC, Increment f = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, Increment f, Skip if 0 = [ label ] INCFSZ. Syntax:, Increment f, Skip if 0 = [ label ] INCFSZ. Syntax:, Increment f, Skip if 0 = f [,d [,a]]. Syntax:, Increment f, Skip if 0 = f [,d [,a]]. Operands:, Increment f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if 0 = . Operands:, Increment f, Skip if 0 = . Operation:, Increment f, Skip if 0 = (f) + 1 \uf0ae dest, skip if result = 0. Operation:, Increment f, Skip if 0 = (f) + 1 \uf0ae dest, skip if result = 0. Operation:, Increment f, Skip if 0 = . Operation:, Increment f, Skip",
    "PIC18F2331/2431/4331/4431\nif 0 = . Status Affected:, Increment f, Skip if 0 = None. Status Affected:, Increment f, Skip if 0 = None. Status Affected:, Increment f, Skip if 0 = . Status Affected:, Increment f, Skip if 0 = . Encoding:, Increment f, Skip if 0 = 0011. Encoding:, Increment f, Skip if 0 = 11da. Encoding:, Increment f, Skip if 0 = ffff. Encoding:, Increment f, Skip if 0 = ffff. Description:, Increment f, Skip if 0 = The contents of register, 'f', are. Description:, Increment f, Skip if 0 = The contents of register, 'f', are. Description:, Increment f, Skip if 0 = The contents of register, 'f', are. Description:, Increment f, Skip if 0 = The contents of register, 'f', are",
    "PIC18F2331/2431/4331/4431\nThe contents of register, 'f', are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is ' 0 ', the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nSyntax:, Increment f, Skip if Not 0 = [ label ] INFSNZ. Syntax:, Increment f, Skip if Not 0 = [ label ] INFSNZ. Syntax:, Increment f, Skip if Not 0 = f [,d [,a]]. Syntax:, Increment f, Skip if Not 0 = . Operands:, Increment f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if Not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, Skip if Not 0 = . Operands:, Increment f, Skip if Not 0 = . Operation:, Increment f, Skip if Not 0 = (f) + 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Increment f, Skip if Not 0 = (f) + 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Increment f, Skip if Not 0 = . Operation:, Increment f, Skip if Not 0 = . Status Affected:,",
    "Q Cycle Activity:\nIncrement f, Skip if Not 0 = None. Status Affected:, Increment f, Skip if Not 0 = None. Status Affected:, Increment f, Skip if Not 0 = . Status Affected:, Increment f, Skip if Not 0 = . Encoding:, Increment f, Skip if Not 0 = 0100. Encoding:, Increment f, Skip if Not 0 = 10da. Encoding:, Increment f, Skip if Not 0 = ffff. Encoding:, Increment f, Skip if Not 0 = ffff. Description:, Increment f, Skip if Not 0 = The contents of register, 'f', are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is not ' 0 ', the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' =",
    "Q Cycle Activity:\n1 , then the bank will be. Description:, Increment f, Skip if Not 0 = The contents of register, 'f', are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is not ' 0 ', the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Increment f, Skip if Not 0 = The contents of register, 'f', are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is not ' 0 ', the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a'",
    "Q Cycle Activity:\nis ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Increment f, Skip if Not 0 = The contents of register, 'f', are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If the result is not ' 0 ', the next instruction, which is already fetched, is discarded, and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Words:, Increment f, Skip if Not 0 = 1. Words:, Increment f, Skip if Not 0 = 1. Words:, Increment f, Skip if Not 0 = . Words:, Increment f, Skip if Not 0 = . Cycles:, Increment f, Skip if Not 0 = 1(2). Cycles:, Increment",
    "Q Cycle Activity:\nf, Skip if Not 0 = . Cycles:, Increment f, Skip if Not 0 = . Cycles:, Increment f, Skip if Not 0 = . , Increment f, Skip if Not 0 = Note:. , Increment f, Skip if Not 0 = 3 cycles if skip and followed by a 2-word instruction.. , Increment f, Skip if Not 0 = 3 cycles if skip and followed by a 2-word instruction.. , Increment f, Skip if Not 0 = 3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nskip:, Q2.Read register 'f' = skip:. skip:, Q3.Process Data = skip:. skip:, Q4.Write to destination = skip:. Q1, Q2.Read register 'f' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.Write to destination = Q4. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.Write to destination = No operation. skip and followed by 2-word instruction:, Q2.Read register 'f' = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3.Process Data = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4.Write to destination = skip and followed by 2-word instruction:. Q1, Q2.Read register 'f' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.Write to destination = Q4. No operation, Q2.Read register",
    "Q Cycle Activity:\n'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.Write to destination = No operation. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.Write to destination = No operation. Example:, Q2.Read register 'f' = HERE NZERO. Example:, Q3.Process Data = INCFSZ CNT :. Example:, Q4.Write to destination = . Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3.Process Data = Before Instruction. Before Instruction, Q4.Write to destination = Before Instruction. PC, Q2.Read register 'f' = = Address. PC, Q3.Process Data = (HERE). PC, Q4.Write to destination = . After Instruction, Q2.Read register 'f' = After Instruction. After Instruction, Q3.Process Data = After Instruction. After Instruction, Q4.Write to destination = After Instruction. CNT, Q2.Read register 'f' = = CNT + 1. CNT,",
    "Q Cycle Activity:\nQ3.Process Data = . CNT, Q4.Write to destination = . If CNT, Q2.Read register 'f' = = 0;. If CNT, Q3.Process Data = . If CNT, Q4.Write to destination = . PC, Q2.Read register 'f' = = Address. PC, Q3.Process Data = (ZERO). PC, Q4.Write to destination = . If CNT, Q2.Read register 'f' = \uf0b9 0;. If CNT, Q3.Process Data = . If CNT, Q4.Write to destination = . PC, Q2.Read register 'f' = = Address. PC, Q3.Process Data = (NZERO). PC, Q4.Write to destination = ",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. skip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No",
    "Q Cycle Activity:\noperation. No operation, Q4 = No operation\nExample:\nHERE    INFSNZ  REG\nZERO\nNZERO\nBefore Instruction, 1 = Before Instruction. Before Instruction, 2 = Before Instruction. PC, 1 = =. PC, 2 = Address (HERE). After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. REG, 1 = =. REG, 2 = REG + 1. If REG, 1 = \uf0b9. If REG, 2 = 0;. PC, 1 = =. PC, 2 = Address (NZERO). If REG, 1 = =. If REG, 2 = 0;. PC, 1 = =. PC, 2 = Address (ZERO)",
    "PIC18F2331/2431/4331/4431\nSyntax:, Inclusive OR Literal with W = [ label ] IORLW k. Syntax:, Inclusive OR Literal with W = [ label ] IORLW k. Syntax:, Inclusive OR Literal with W = [ label ] IORLW k. Syntax:, Inclusive OR Literal with W = [ label ] IORLW k. Operands:, Inclusive OR Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Inclusive OR Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Inclusive OR Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Inclusive OR Literal with W = 0 \uf0a3 k \uf0a3 255. Operation:, Inclusive OR Literal with W = (W) .OR. k \uf0ae W. Operation:, Inclusive OR Literal with W = (W) .OR. k \uf0ae W. Operation:, Inclusive OR Literal with W = (W) .OR. k \uf0ae W. Operation:, Inclusive OR Literal with W = (W) .OR. k \uf0ae W. Status Affected:, Inclusive OR Literal with W = N, Z. Status Affected:, Inclusive OR Literal with W = N, Z. Status Affected:, Inclusive OR Literal with W = N, Z. Status Affected:,",
    "PIC18F2331/2431/4331/4431\nInclusive OR Literal with W = N, Z. Encoding:, Inclusive OR Literal with W = 0000. Encoding:, Inclusive OR Literal with W = 1001. Encoding:, Inclusive OR Literal with W = kkkk. Encoding:, Inclusive OR Literal with W = kkkk. Description:, Inclusive OR Literal with W = The contents of Ware ORed with the 8-bit literal, 'k'. The result is placed in W.. Description:, Inclusive OR Literal with W = The contents of Ware ORed with the 8-bit literal, 'k'. The result is placed in W.. Description:, Inclusive OR Literal with W = The contents of Ware ORed with the 8-bit literal, 'k'. The result is placed in W.. Description:, Inclusive OR Literal with W = The contents of Ware ORed with the 8-bit literal, 'k'. The result is placed in W.. Words:, Inclusive OR Literal with W = 1. Words:, Inclusive OR Literal with W = 1. Words:, Inclusive OR Literal with W = 1. Words:, Inclusive OR Literal with W = 1.",
    "PIC18F2331/2431/4331/4431\nCycles:, Inclusive OR Literal with W = 1. Cycles:, Inclusive OR Literal with W = 1. Cycles:, Inclusive OR Literal with W = 1. Cycles:, Inclusive OR Literal with W = 1. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q1, Inclusive OR Literal with W = Q2. Q1, Inclusive OR Literal with W = Q3. Q1, Inclusive OR Literal with W = Q3. Q1, Inclusive OR Literal with W = Q4. Decode, Inclusive OR Literal with W = Read literal 'k'. Decode, Inclusive OR Literal with W = Process Data. Decode, Inclusive OR Literal with W = Process Data. Decode, Inclusive OR Literal with W = Write to W. Example:, Inclusive OR Literal with W = IORLW. Example:, Inclusive OR Literal with W = 0x35. Example:, Inclusive OR Literal with W",
    "PIC18F2331/2431/4331/4431\n= 0x35. Example:, Inclusive OR Literal with W = 0x35. Before Instruction, Inclusive OR Literal with W = Before Instruction. Before Instruction, Inclusive OR Literal with W = Before Instruction. Before Instruction, Inclusive OR Literal with W = Before Instruction. Before Instruction, Inclusive OR Literal with W = Before Instruction. W, Inclusive OR Literal with W = 0x9A. W, Inclusive OR Literal with W = . W, Inclusive OR Literal with W = . W, Inclusive OR Literal with W = . After Instruction W =, Inclusive OR Literal with W = 0xBF. After Instruction W =, Inclusive OR Literal with W = . After Instruction W =, Inclusive OR Literal with W = . After Instruction W =, Inclusive OR Literal with W = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, Inclusive OR Wwith f = [ label ] IORWF. Syntax:, Inclusive OR Wwith f = [ label ] IORWF. Syntax:, Inclusive OR Wwith f = f [,d [,a]]. Syntax:, Inclusive OR Wwith f = f [,d [,a]]. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Inclusive OR Wwith f = . Operands:, Inclusive OR Wwith f = . Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Status Affected:, Inclusive OR Wwith f = N,",
    "PIC18F2331/2431/4331/4431\nZ. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Encoding:, Inclusive OR Wwith f = 0001. Encoding:, Inclusive OR Wwith f = 00da. Encoding:, Inclusive OR Wwith f = ffff. Encoding:, Inclusive OR Wwith f = ffff. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register, 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register, 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in",
    "PIC18F2331/2431/4331/4431\nregister, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register, 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register, 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected",
    "PIC18F2331/2431/4331/4431\nas per the BSR value.. Words:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Q Cycle Activity:, Inclusive OR Wwith f = . Q Cycle Activity:, Inclusive OR Wwith f = . Q Cycle Activity:, Inclusive OR Wwith f = . Q Cycle Activity:, Inclusive OR Wwith f = . Q1, Inclusive OR Wwith f = Q2. Q1, Inclusive OR Wwith f = Q3. Q1, Inclusive OR Wwith f = . Q1, Inclusive OR Wwith f = Q4. Decode, Inclusive OR Wwith f = Read register 'f'. Decode, Inclusive OR Wwith f = Process Data. Decode, Inclusive OR Wwith f = Process Data. Decode, Inclusive OR Wwith f = Write to destination.",
    "PIC18F2331/2431/4331/4431\nExample:, Inclusive OR Wwith f = IORWF. Example:, Inclusive OR Wwith f = RESULT, W. Example:, Inclusive OR Wwith f = RESULT, W. Example:, Inclusive OR Wwith f = RESULT, W. Before Instruction, Inclusive OR Wwith f = Before Instruction. Before Instruction, Inclusive OR Wwith f = Before Instruction. Before Instruction, Inclusive OR Wwith f = Before Instruction. Before Instruction, Inclusive OR Wwith f = Before Instruction. RESULT, Inclusive OR Wwith f = 0x13. RESULT, Inclusive OR Wwith f = . RESULT, Inclusive OR Wwith f = . RESULT, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = 0x91. W, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = . After Instruction RESULT = W =, Inclusive OR Wwith f = 0x13 0x93. After Instruction RESULT = W =, Inclusive OR Wwith f = . After Instruction RESULT = W =, Inclusive OR Wwith f = . After Instruction RESULT = W =, Inclusive OR Wwith f = ",
    "LFSR\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "Load FSR\n[\nlabel\n]    LFSR   f,k\n0\n\uf0a3\nf\n\uf0a3\n2\n0\n\uf0a3\nk\n\uf0a3\n4095\nk \uf0ae FSRf\nNone\n1110\n1110\n00ff",
    "PIC18F2331/2431/4331/4431\nkkk\n1111\n0000\nk7 kkk k 11\nkkkk\nSyntax:, Move f = [ label ]. Syntax:, Move f = MOVF. Syntax:, Move f = f [,d [,a]]. Syntax:, Move f = . Operands:, Move f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Move f = . Operands:, Move f = . Operands:, Move f = . , Move f = a \uf0ce [0,1]. , Move f = . , Move f = . , Move f = . Operation:, Move f = f \uf0ae dest. Operation:, Move f = . Operation:, Move f = . Operation:, Move f = . Status Affected:, Move f = N, Z. Status Affected:, Move f = . Status Affected:, Move f = . Status Affected:, Move f = . Encoding:, Move f = 0101. Encoding:, Move f = 00da. Encoding:, Move f = ffff. Encoding:, Move f = ffff",
    "PIC18F2331/2431/4331/4431\nThe 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.\n2\n2\nQ Cycle Activity:\nDecode, Q2 = Read literal 'k' MSB. Decode, Q3 = Process Data. Decode, Q4 = Write literal 'k' MSB to FSRfH. Decode, Q2 = Read literal 'k' LSB. Decode, Q3 = Process Data. Decode, Q4 = Write literal 'k' to FSRfL\nExample:\nLFSR 2, 0x3AB\nAfter Instruction\nFSR2H\nFSR2L\nDescription:",
    "PIC18F2331/2431/4331/4431\nThe contents of register, 'f', are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. Location, 'f', can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.\nWords:\nCycles:\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write W",
    "Example:\nMOVF   REG, W\nBefore Instruction\nREG\n=\n0x22\nW\n= 0xFF\nAfter Instruction\nREG\n= 0x22\nW\n=\n0x22\n= 0x03\n= 0xAB",
    "PIC18F2331/2431/4331/4431\nMOVFF",
    "Move f to f\nSyntax:\n[\nlabel\n]    MOVFF   f ,f\ns\nd\nOperands:\n0\n\uf0a3\nf\ns\n\uf0a3\n4095\n0\n\uf0a3\nf\nd\n\uf0a3\n4095\nOperation:\n(f s ) \uf0ae f d\nStatus Affected:\nNone\nEncoding:\n1st word (source) 2nd word (destin.)\n1100\n1111\nffff\nffff\nffff\nffff\nffffs\nffffd\nDescription:\nThe contents of source register, 'f s ', are moved to destination register, 'f d '. Location of source, 'f ', can be any- s where in the 4096-byte data space (000h to FFFh) and location of destina- tion, 'f d ', can also be anywhere from 000h to FFFh.\nEither source or destination can be W\n(a useful special situation).\nMOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port).\nThe MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.\nThe MOVFF instruction should not be used to modify interrupt settings while any interrupt is enabled (see the note on page 97).\nWords:\n2\nCycles:",
    "Move f to f\n2 (3)",
    "Move f to f\nSyntax:, Move Literal to Low Nibble in BSR = [ label ] MOVLB k. Syntax:, Move Literal to Low Nibble in BSR = [ label ] MOVLB k. Syntax:, Move Literal to Low Nibble in BSR = [ label ] MOVLB k. Syntax:, Move Literal to Low Nibble in BSR = [ label ] MOVLB k. Operands:, Move Literal to Low Nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to Low Nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to Low Nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to Low Nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operation:, Move Literal to Low Nibble in BSR = k \uf0ae BSR. Operation:, Move Literal to Low Nibble in BSR = k \uf0ae BSR. Operation:, Move Literal to Low Nibble in BSR = k \uf0ae BSR. Operation:, Move Literal to Low Nibble in BSR = k \uf0ae BSR. Status Affected:, Move Literal to Low Nibble in BSR = None. Status Affected:, Move Literal to Low Nibble in",
    "Move f to f\nBSR = None. Status Affected:, Move Literal to Low Nibble in BSR = None. Status Affected:, Move Literal to Low Nibble in BSR = None. Encoding:, Move Literal to Low Nibble in BSR = 0000. Encoding:, Move Literal to Low Nibble in BSR = 0001. Encoding:, Move Literal to Low Nibble in BSR = . Encoding:, Move Literal to Low Nibble in BSR = kkkk. Description:, Move Literal to Low Nibble in BSR = The 8-bit literal, 'k', is loaded into the Bank Select Register (BSR).. Description:, Move Literal to Low Nibble in BSR = The 8-bit literal, 'k', is loaded into the Bank Select Register (BSR).. Description:, Move Literal to Low Nibble in BSR = The 8-bit literal, 'k', is loaded into the Bank Select Register (BSR).. Description:, Move Literal to Low Nibble in BSR = The 8-bit literal, 'k', is loaded into the Bank Select Register (BSR).. Words:, Move Literal to Low",
    "Move f to f\nNibble in BSR = 1. Words:, Move Literal to Low Nibble in BSR = 1. Words:, Move Literal to Low Nibble in BSR = 1. Words:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Q Cycle Activity:, Move Literal to Low Nibble in BSR = . Q Cycle Activity:, Move Literal to Low Nibble in BSR = . Q Cycle Activity:, Move Literal to Low Nibble in BSR = . Q Cycle Activity:, Move Literal to Low Nibble in BSR = . Q1, Move Literal to Low Nibble in BSR = Q2 Q3. Q1, Move Literal to Low Nibble in BSR = Q2 Q3. Q1, Move Literal to Low Nibble in BSR = Q4. Q1, Move Literal to Low Nibble in BSR = Q4. Decode, Move Literal to Low",
    "Move f to f\nNibble in BSR = Read literal 'k' Process Data. Decode, Move Literal to Low Nibble in BSR = Read literal 'k' Process Data. Decode, Move Literal to Low Nibble in BSR = Write literal 'k' to BSR. Decode, Move Literal to Low Nibble in BSR = Write literal 'k' to BSR. Example:, Move Literal to Low Nibble in BSR = MOVLB. Example:, Move Literal to Low Nibble in BSR = 5. Example:, Move Literal to Low Nibble in BSR = . Example:, Move Literal to Low Nibble in BSR = . Before Instruction BSR register, Move Literal to Low Nibble in BSR = =. Before Instruction BSR register, Move Literal to Low Nibble in BSR = 0x02. Before Instruction BSR register, Move Literal to Low Nibble in BSR = . Before Instruction BSR register, Move Literal to Low Nibble in BSR = . After Instruction BSR register, Move Literal to Low Nibble in BSR = =. After Instruction BSR register, Move Literal to Low Nibble in BSR = 0x05. After",
    "Move f to f\nInstruction BSR register, Move Literal to Low Nibble in BSR = . After Instruction BSR register, Move Literal to Low Nibble in BSR = \nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode, 1 = Read register 'f' (src). Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f' (dest)\nExample:\nMOVFF   REG1, REG2\nBefore Instruction\nREG1\n= 0x33\nREG2\n= 0x11\nAfter Instruction\nREG1\n= 0x33\nREG2\n= 0x33",
    "PIC18F2331/2431/4331/4431\nSyntax:, Move Literal to W = [ label ]. Syntax:, Move Literal to W = MOVLW. Syntax:, Move Literal to W = k. Syntax:, Move Literal to W = . Operands:, Move Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move Literal to W = . Operands:, Move Literal to W = . Operation:, Move Literal to W = k \uf0ae W. Operation:, Move Literal to W = k \uf0ae W. Operation:, Move Literal to W = . Operation:, Move Literal to W = . Status Affected:, Move Literal to W = None. Status Affected:, Move Literal to W = None. Status Affected:, Move Literal to W = . Status Affected:, Move Literal to W = . Encoding:, Move Literal to W = 0000. Encoding:, Move Literal to W = 1110. Encoding:, Move Literal to W = kkkk. Encoding:, Move Literal to W = kkkk. Description:, Move Literal to W = The 8-bit literal, 'k', is loaded into W..",
    "PIC18F2331/2431/4331/4431\nDescription:, Move Literal to W = The 8-bit literal, 'k', is loaded into W.. Description:, Move Literal to W = The 8-bit literal, 'k', is loaded into W.. Description:, Move Literal to W = The 8-bit literal, 'k', is loaded into W.. Words:, Move Literal to W = 1. Words:, Move Literal to W = 1. Words:, Move Literal to W = . Words:, Move Literal to W = . Cycles:, Move Literal to W = 1. Cycles:, Move Literal to W = 1. Cycles:, Move Literal to W = . Cycles:, Move Literal to W = . Q Cycle Activity:, Move Literal to W = . Q Cycle Activity:, Move Literal to W = . Q Cycle Activity:, Move Literal to W = . Q Cycle Activity:, Move Literal to W = . Q1, Move Literal to W = Q2. Q1, Move Literal to W = Q3. Q1, Move Literal to W = . Q1, Move Literal to W = Q4. Decode, Move Literal to W =",
    "PIC18F2331/2431/4331/4431\nRead literal 'k'. Decode, Move Literal to W = Process Data. Decode, Move Literal to W = . Decode, Move Literal to W = Write to W. Example:, Move Literal to W = MOVLW. Example:, Move Literal to W = 0x5A. Example:, Move Literal to W = . Example:, Move Literal to W = . After Instruction W =, Move Literal to W = 0x5A. After Instruction W =, Move Literal to W = . After Instruction W =, Move Literal to W = . After Instruction W =, Move Literal to W = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, Move Wto f = [ label ]. Syntax:,  = MOVWF. Syntax:,  = f [,a]. Syntax:,  = . Syntax:,  = . Operands:, Move Wto f = 0 255 a \uf0ce [0,1]. Operands:,  = \uf0a3 f \uf0a3. Operands:,  = . Operands:,  = . Operands:,  = . Operation:, Move Wto f = (W) \uf0ae. Operation:,  = f. Operation:,  = . Operation:,  = . Operation:,  = . Status Affected:, Move Wto f = None. Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Encoding:, Move Wto f = 0110. Encoding:,  = 111a. Encoding:,  = ffff. Encoding:,  = ffff. Encoding:,",
    "PIC18F2331/2431/4331/4431\n= . Description:, Move Wto f = Move data from Wto register, 'f'. Location, 'f', can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:,  = . Description:,  = . Description:,  = . Description:,  = . Words:, Move Wto f = . Words:,  = 1. Words:,  = . Words:,  = . Words:,  = . Cycles:, Move Wto f = 1. Cycles:,  = . Cycles:,  = . Cycles:,  = . Cycles:,  = . Q Cycle Activity:, Move Wto f = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q1, Move Wto f = Q2. Q1,  = Q3. Q1,  = . Q1,  = Q4. Q1,",
    "PIC18F2331/2431/4331/4431\n= . Decode, Move Wto f = . Decode,  = Read register 'f'. Decode,  = Process Data. Decode,  = Write register. Decode,  = . , Move Wto f = MOVWF. ,  = . ,  = . ,  = 'f'. ,  = . Example:, Move Wto f = . Example:,  = . Example:,  = . Example:,  = . Example:,  = . W, Move Wto f = . W,  = . W,  = . W,  = . W,  = . , Move Wto f = =. ,  = . ,  = . ,  = . ,  = . , Move Wto f = . ,  = 0x4F. ,  = . ,  = . ,  = . W, Move Wto f = . W,  = . W,  = . W,  = . W,  = . REG, Move Wto f = . REG,  = . REG,  = . REG,  = . REG,  = . After, Move Wto f = . After,  = . After,  = . After,  = . After,",
    "PIC18F2331/2431/4331/4431\n= . REG, Move Wto f = . REG,  = . REG,  = . REG,  = . REG,  = . Before Instruction, Move Wto f = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . , Move Wto f = . ,  = 0x4F. ,  = . ,  = . ,  = . , Move Wto f = =. ,  = 0xFF. ,  = . ,  = . ,  = . , Move Wto f = . ,  = 0x4F. ,  = . ,  = . ,  = . , Move Wto f = =. ,  = . ,  = . ,  = . ,  = . Instruction, Move Wto f = . Instruction,  = . Instruction,  = . Instruction,  = . Instruction,  = . , Move Wto f = . ,  = . ,  = . ,  = . ,  = =",
    "Multiply Literal with W\nSyntax:\n[ label\n]    MULLW     k\nOperands:\n0 \uf0a3 k \uf0a3 255\nOperation:\n(W) x k \uf0ae PRODH:PRODL\nStatus Affected:\nNone\nEncoding:\n0000\n1101\nkkkk\nkkkk\nDescription:\nAn unsigned multiplication is carried out between the contents of W and the 8-bit literal, 'k'. The 16-bit result is placed in PRODH:PRODL register pair. PRODH contains the high byte. W is unchanged.\nNone of the Status flags are affected. Note that neither Overflow nor Carry is possible in this operation. A Zero result is possible but not detected.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral 'k'\nProcess Data\nWrite registers PRODH: PRODL",
    "Example:\nMULLW   0xC4\nBefore Instruction\nW\n=\n0xE2\nPRODH\n=\n?\nPRODL\n=\n?\nAfter Instruction\nW\n= 0xE2\nPRODH\n=\n0xAD\nPRODL\n=\n0x08",
    "Example:\nSyntax:, Multiply Wwith f = [ label ]. Syntax:, Multiply Wwith f = MULWF. Syntax:, Multiply Wwith f = f [,a]. Syntax:, Multiply Wwith f = . Operands:, Multiply Wwith f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Multiply Wwith f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Multiply Wwith f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Multiply Wwith f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Multiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f =",
    "Example:\nNone. Status Affected:, Multiply Wwith f = None. Encoding:, Multiply Wwith f = 0000. Encoding:, Multiply Wwith f = 001a. Encoding:, Multiply Wwith f = ffff. Encoding:, Multiply Wwith f = ffff\nDescription:\nAn unsigned multiplication is carried out between the contents of W and the register file location, 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both W and 'f' are unchanged. None of the Status flags are affected. Note that neither Overflow nor Carry is possible in this operation. A Zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a'= 1 , then the bank will be selected as per the BSR value.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write registers PRODH: PRODL",
    "Example:\nBefore Instruction, MULWF = . Before Instruction, REG = . W, MULWF = =. W, REG = 0xC4. REG, MULWF = =. REG, REG = 0xB5. PRODH, MULWF = =. PRODH, REG = ?. PRODL, MULWF = =. PRODL, REG = ?. After Instruction, MULWF = . After Instruction, REG = . W, MULWF = =. W, REG = 0xC4. REG, MULWF = =. REG, REG = 0xB5. PRODH, MULWF = =. PRODH, REG = 0x8A. PRODL, MULWF = =. PRODL, REG = 0x94",
    "PIC18F2331/2431/4331/4431\nSyntax:, Negate f = [ label ]. Syntax:, Negate f = NEGF. Syntax:, Negate f = f [,a]. Syntax:, Negate f = . Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C,",
    "PIC18F2331/2431/4331/4431\nDC, Z. Encoding:, Negate f = 0110. Encoding:, Negate f = 110a. Encoding:, Negate f = ffff. Encoding:, Negate f = ffff. Description:, Negate f = Location, 'f', is negated using two's complement. The result is placed in the data memory location, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location, 'f', is negated using two's complement. The result is placed in the data memory location, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location, 'f', is negated using two's complement. The result is placed in the data memory location, 'f'. If",
    "PIC18F2331/2431/4331/4431\n'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location, 'f', is negated using two's complement. The result is placed in the data memory location, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Negate f = 1. Words:, Negate f = 1. Words:, Negate f = 1. Words:, Negate f = 1. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Q Cycle Activity: Q1, Negate f = . Q Cycle Activity: Q1, Negate f = . Q Cycle Activity: Q1, Negate f = . Q Cycle Activity: Q1, Negate f =",
    "PIC18F2331/2431/4331/4431\n. , Negate f = Q2. , Negate f = Q3. , Negate f = . , Negate f = Q4. Decode, Negate f = Read register 'f'. Decode, Negate f = Process Data. Decode, Negate f = . Decode, Negate f = Write register 'f'",
    "Example:\nNEGF\nREG, 1\nBefore Instruction\nREG\n=\n0011 1010 [0x3A]\nAfter Instruction\nREG\n=\n1100 0110 [0xC6]",
    "Example:\nSyntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Operands:, No Operation = None. Operands:, No Operation = None. Operands:, No Operation = None. Operands:, No Operation = None. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Encoding:, No Operation = 0000 1111. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Words:, No Operation = 1. Words:, No Operation =",
    "Example:\n1. Words:, No Operation = 1. Words:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Q Cycle Activity: Q1, No Operation = Q2. Q Cycle Activity: Q1, No Operation = Q3. Q Cycle Activity: Q1, No Operation = . Q Cycle Activity: Q1, No Operation = Q4. Decode, No Operation = No operation. Decode, No Operation = No operation. Decode, No Operation = . Decode, No Operation = No operation\nNone.",
    "Push Top of Return Stack\nSyntax:, 1 = [ label ] POP. Syntax:, 2 = [ label ] POP. Syntax:, 3 = [ label ] POP. Syntax:, 4 = [ label ] POP. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = (TOS) \uf0ae bit bucket. Operation:, 2 = (TOS) \uf0ae bit bucket. Operation:, 3 = (TOS) \uf0ae bit bucket. Operation:, 4 = (TOS) \uf0ae bit bucket. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0000. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Encoding:, 4 = 0110. Description:, 1 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 2 = The TOS value is",
    "Push Top of Return Stack\npulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 3 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, 4 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = .",
    "Push Top of Return Stack\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q3. Q1, 4 = Q4. Decode, 1 = No operation. Decode, 2 = POP TOS value. Decode, 3 = POP TOS value. Decode, 4 = No operation. Example:, 1 = POP. Example:, 2 = . Example:, 3 = . Example:, 4 = . Before Instruction, 1 = Before Instruction. Before Instruction, 2 = . Before Instruction, 3 = . Before Instruction, 4 = . TOS, 1 = TOS. TOS, 2 = =. TOS, 3 = 0x0031A2. TOS, 4 = . Stack (1 level down), 1 = Stack (1 level down). Stack (1 level down), 2 = =. Stack (1 level down), 3 = 0x014332. Stack (1 level down), 4 = . After Instruction, 1 = After Instruction. After Instruction, 2 = . After Instruction, 3 = . After Instruction, 4 = . TOS, 1 = TOS. TOS, 2 = =. TOS, 3 =",
    "Push Top of Return Stack\n0x014332. TOS, 4 = . PC, 1 = PC. PC, 2 = =. PC, 3 = NEW. PC, 4 = ",
    "Push Top of Return Stack\nSyntax:, 1 = [ label ] PUSH. Syntax:, 2 = [ label ] PUSH. Syntax:, 3 = [ label ] PUSH. Syntax:, 4 = [ label ] PUSH. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = (PC + 2) \uf0ae TOS. Operation:, 2 = (PC + 2) \uf0ae TOS. Operation:, 3 = (PC + 2) \uf0ae TOS. Operation:, 4 = (PC + 2) \uf0ae TOS. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0000. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Encoding:, 4 = 0101. Description:, 1 = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows to implement a software stack by modifying TOS, and then push it onto the return stack.. Description:, 2 = The PC + 2",
    "Push Top of Return Stack\nis pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows to implement a software stack by modifying TOS, and then push it onto the return stack.. Description:, 3 = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows to implement a software stack by modifying TOS, and then push it onto the return stack.. Description:, 4 = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows to implement a software stack by modifying TOS, and then push it onto the return stack.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity: Q1, 1 = Q2. Q Cycle Activity: Q1, 2 = Q3. Q Cycle Activity: Q1, 3 = Q3. Q Cycle Activity:",
    "Push Top of Return Stack\nQ1, 4 = Q4. Decode, 1 = PUSH PC + 2 onto return stack. Decode, 2 = No operation. Decode, 3 = No operation. Decode, 4 = No operation. Example:, 1 = PUSH. Example:, 2 = PUSH. Example:, 3 = PUSH. Example:, 4 = PUSH. Before Instruction TOS, 1 = Before Instruction TOS. Before Instruction TOS, 2 = =. Before Instruction TOS, 3 = 0x00345A. Before Instruction TOS, 4 = 0x00345A. PC, 1 = PC. PC, 2 = =. PC, 3 = 0x000124. PC, 4 = 0x000124. After Instruction PC, 1 = After Instruction PC. After Instruction PC, 2 = =. After Instruction PC, 3 = 0x000126. After Instruction PC, 4 = 0x000126. TOS, 1 = TOS. TOS, 2 = =. TOS, 3 = 0x000126. TOS, 4 = 0x000126. Stack (1 level down), 1 = Stack (1 level down). Stack",
    "Push Top of Return Stack\n(1 level down), 2 = =. Stack (1 level down), 3 = 0x00345A. Stack (1 level down), 4 = 0x00345A",
    "PIC18F2331/2431/4331/4431\nSyntax:, Relative Call = [ label ] RCALL n. Syntax:, Relative Call = [ label ] RCALL n. Syntax:, Relative Call = [ label ] RCALL n. Syntax:, Relative Call = [ label ] RCALL n. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None.",
    "PIC18F2331/2431/4331/4431\nEncoding:, Relative Call = 1101. Encoding:, Relative Call = 1nnn. Encoding:, Relative Call = nnnn. Encoding:, Relative Call = nnnn. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location.",
    "PIC18F2331/2431/4331/4431\nFirst, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Words:, Relative Call = 1. Words:, Relative Call = 1. Words:, Relative Call = 1. Words:, Relative Call = 1. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Q Cycle Activity:, Relative Call = . Q Cycle Activity:, Relative Call = . Q Cycle",
    "PIC18F2331/2431/4331/4431\nActivity:, Relative Call = . Q Cycle Activity:, Relative Call = . Q1, Relative Call = Q2. Q1, Relative Call = Q3. Q1, Relative Call = . Q1, Relative Call = Q4. Decode, Relative Call = Read literal 'n' PUSH PC to stack. Decode, Relative Call = Process Data. Decode, Relative Call = . Decode, Relative Call = Write to PC. No operation, Relative Call = No operation. No operation, Relative Call = No operation. No operation, Relative Call = . No operation, Relative Call = No operation\nExample:\nHERE\nRCALL Jump\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nAfter Instruction\nPC =\nAddress\n(Jump)\nTOS =\nAddress\n(HERE + 2)",
    "PIC18F2331/2431/4331/4431\nSyntax:, Reset = [ label ]. Syntax:, Reset = RESET. Syntax:, Reset = RESET. Syntax:, Reset = RESET. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Encoding:, Reset = 0000. Encoding:, Reset = 0000. Encoding:, Reset = 1111. Encoding:, Reset = 1111. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset",
    "PIC18F2331/2431/4331/4431\nin software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q1, Reset = Q2. Q1, Reset = Q3. Q1, Reset = . Q1, Reset = Q4. Decode, Reset = Start Reset. Decode, Reset = No operation. Decode, Reset = . Decode, Reset = No operation",
    "Example:\nRESET\nAfter Instruction\nRegisters =\nReset Value\nFlags*\n=\nReset Value",
    "Return from Interrupt\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\n[\nlabel\n]    RETFIE   [s]\ns \uf0ce [0,1]\n(TOS) \uf0ae PC,\n1 \uf0ae GIE/GIEH or PEIE/GIEL;\nif s = 1 :\n(WS) \uf0ae W,\n(STATUSS) \uf0ae STATUS,\n(BSRS)\n\uf0ae BSR,\nPCLATU, PCLATH are unchanged\nGIE/GIEH, PEIE/GIEL.\n0000\n0000\n0001\n000s\nReturn from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low-priority global interrupt enable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0 , no update of these registers occurs.\n1\n2",
    "Return from Interrupt\nSyntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to",
    "Return from Interrupt\nW = None. Status Affected:, Return Literal to W = None. Encoding:, Return Literal to W = 0000. Encoding:, Return Literal to W = 1100. Encoding:, Return Literal to W = kkkk. Encoding:, Return Literal to W = kkkk. Description:, Return Literal to W = Wis loaded with the 8-bit literal, 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the 8-bit literal, 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the 8-bit literal, 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the 8-bit literal, 'k'. The program counter is loaded from the top of the stack (the return",
    "Return from Interrupt\naddress). The high address latch (PCLATH) remains unchanged.. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q1, Return Literal to W = Q2. Q1, Return Literal to W = Q3. Q1, Return Literal to W = . Q1, Return Literal to W = Q4. Decode, Return Literal to W = Read literal 'k'. Decode, Return Literal to W = Process Data. Decode, Return Literal to W = . Decode, Return Literal to W = POP PC from stack, Write to W. No operation, Return",
    "Return from Interrupt\nLiteral to W = No operation. No operation, Return Literal to W = No operation. No operation, Return Literal to W = . No operation, Return Literal to W = No operation\nQ Cycle Activity:\nDecode, Q2 = No operation. Decode, Q3 = No operation. Decode, Q4 = POP PC from stack Set GIEH or GIEL. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nRETFIE  1\nAfter Interrupt\nPC\n=\nTOS\nW\n=\nWS\nBSR\n=\nBSRS\nSTATUS\n= STATUSS\nGIE/GIEH, PEIE/GIEL\n=\n1",
    "Example:\nCALL TABLE\n; W contains table\n; offset value\n; W now has\n; table value\n:\nTABLE\nADDWF PCL\n; W = offset\nRETLW k0\n; Begin table\nRETLW k1\n;\n:\n:\nRETLW kn\n; End of table\nBefore Instruction\nW\n=\n0x07\nAfter Instruction\nW =\nvalue of kn",
    "PIC18F2331/2431/4331/4431\nSyntax:, Return from Subroutine = [ label ]. Syntax:, Return from Subroutine = RETURN [s]. Syntax:, Return from Subroutine = RETURN [s]. Syntax:, Return from Subroutine = RETURN [s]. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operation:, Return from Subroutine = (TOS) \uf0ae PC; if s = 1 : (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Subroutine = (TOS) \uf0ae PC; if s = 1 : (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Subroutine = (TOS) \uf0ae PC; if s = 1 : (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae",
    "PIC18F2331/2431/4331/4431\nBSR,. Operation:, Return from Subroutine = (TOS) \uf0ae PC; if s = 1 : (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Encoding:, Return from Subroutine = 0000. Encoding:, Return from Subroutine = 0000. Encoding:, Return from Subroutine = 0001. Encoding:, Return from Subroutine = 001s. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0 , no update of these registers occurs.. Description:, Return from Subroutine = Return from",
    "PIC18F2331/2431/4331/4431\nsubroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0 , no update of these registers occurs.. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If 's' = 0 , no update of these registers occurs.. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, STATUS and BSR. If 's'",
    "PIC18F2331/2431/4331/4431\n= 0 , no update of these registers occurs.. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q1, Return from Subroutine = Q2. Q1, Return from Subroutine = Q3. Q1, Return from Subroutine = . Q1, Return from Subroutine = Q4. Decode, Return from Subroutine = . Decode, Return from Subroutine = No operation. Decode, Return from Subroutine = Process",
    "PIC18F2331/2431/4331/4431\nData. Decode, Return from Subroutine = POP PC from stack. No operation, Return from Subroutine = . No operation, Return from Subroutine = No operation. No operation, Return from Subroutine = No operation. No operation, Return from Subroutine = No operation\nExample:\nRETURN\nAfter Interrupt PC = TOS",
    "PIC18F2331/2431/4331/4431\nSyntax:, Rotate Left f through Carry = [ label ]. Syntax:, Rotate Left f through Carry = RLCF. Syntax:, Rotate Left f through Carry = f [,d [,a]]. Syntax:, Rotate Left f through Carry = f [,d [,a]]. Syntax:, Rotate Left f through Carry = f [,d [,a]]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae",
    "PIC18F2331/2431/4331/4431\nC, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f",
    "PIC18F2331/2431/4331/4431\nthrough Carry = C, N, Z. Encoding:, Rotate Left f through Carry = 0011. Encoding:, Rotate Left f through Carry = 01da. Encoding:, Rotate Left f through Carry = ffff. Encoding:, Rotate Left f through Carry = ffff. Encoding:, Rotate Left f through Carry = ffff. Description:, Rotate Left f through Carry = The contents of register, 'f', are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in regis- ter, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected. Description:, Rotate Left f through Carry = The contents of register, 'f', are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in regis- ter,",
    "PIC18F2331/2431/4331/4431\n'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected. Description:, Rotate Left f through Carry = The contents of register, 'f', are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in regis- ter, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected. Description:, Rotate Left f through Carry = The contents of register, 'f', are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in regis- ter, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If",
    "PIC18F2331/2431/4331/4431\n'a' = 1 , then the bank will be selected. Description:, Rotate Left f through Carry = The contents of register, 'f', are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in regis- ter, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Q Cycle Activity:, Rotate Left f through Carry = . Q",
    "PIC18F2331/2431/4331/4431\nCycle Activity:, Rotate Left f through Carry = . Q Cycle Activity:, Rotate Left f through Carry = . Q Cycle Activity:, Rotate Left f through Carry = . Q Cycle Activity:, Rotate Left f through Carry = . Q1, Rotate Left f through Carry = . Q1, Rotate Left f through Carry = . Q1, Rotate Left f through Carry = . Q1, Rotate Left f through Carry = . Q1, Rotate Left f through Carry = . Decode, Rotate Left f through Carry = Q2. Decode, Rotate Left f through Carry = Q3. Decode, Rotate Left f through Carry = Q3. Decode, Rotate Left f through Carry = Q4. Decode, Rotate Left f through Carry = Q4. , Rotate Left f through Carry = Read register 'f' Process Data. , Rotate Left f through Carry = Read register 'f' Process Data. , Rotate Left f through Carry = Read register 'f' Process Data. , Rotate Left f through Carry = Write to destination. , Rotate Left f through Carry = Write to destination. Example: RLCF REG, W Before Instruction, Rotate Left f through Carry =",
    "PIC18F2331/2431/4331/4431\nExample: RLCF REG, W Before Instruction. Example: RLCF REG, W Before Instruction, Rotate Left f through Carry = Example: RLCF REG, W Before Instruction. Example: RLCF REG, W Before Instruction, Rotate Left f through Carry = Example: RLCF REG, W Before Instruction. Example: RLCF REG, W Before Instruction, Rotate Left f through Carry = Example: RLCF REG, W Before Instruction. Example: RLCF REG, W Before Instruction, Rotate Left f through Carry = Example: RLCF REG, W Before Instruction. REG, Rotate Left f through Carry = = 1110. REG, Rotate Left f through Carry = 0110. REG, Rotate Left f through Carry = . REG, Rotate Left f through Carry = . REG, Rotate Left f through Carry = . C, Rotate Left f through Carry = = 0. C, Rotate Left f through Carry = . C, Rotate Left f through Carry = . C, Rotate Left f through Carry = . C, Rotate Left f through Carry = . After Instruction, Rotate Left f through Carry = After Instruction. After Instruction, Rotate Left f through Carry = After",
    "PIC18F2331/2431/4331/4431\nInstruction. After Instruction, Rotate Left f through Carry = After Instruction. After Instruction, Rotate Left f through Carry = After Instruction. After Instruction, Rotate Left f through Carry = After Instruction. REG, Rotate Left f through Carry = = 1110. REG, Rotate Left f through Carry = 0110. REG, Rotate Left f through Carry = . REG, Rotate Left f through Carry = . REG, Rotate Left f through Carry = . W, Rotate Left f through Carry = = 1100. W, Rotate Left f through Carry = 1100. W, Rotate Left f through Carry = . W, Rotate Left f through Carry = . W, Rotate Left f through Carry = . C, Rotate Left f through Carry = = 1. C, Rotate Left f through Carry = . C, Rotate Left f through Carry = . C, Rotate Left f through Carry = . C, Rotate Left f through Carry = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, Rotate Left f (No Carry) = [ label ]. Syntax:, Rotate Left f (No Carry) = RLNCF. Syntax:, Rotate Left f (No Carry) = f [,d [,a]]. Syntax:, Rotate Left f (No Carry) = f [,d [,a]]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae",
    "PIC18F2331/2431/4331/4431\ndest<n + 1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \uf0ae dest<n + 1>, (f<7>) \uf0ae dest<0>. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Encoding:, Rotate Left f (No Carry) = 0100. Encoding:, Rotate Left f (No Carry) = 01da. Encoding:, Rotate Left f (No Carry) = ffff. Encoding:, Rotate Left f (No Carry) = ffff. Description:, Rotate Left f (No Carry) = The contents of register, 'f', are rotated one bit to the left.",
    "PIC18F2331/2431/4331/4431\nIf 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overrid- ing the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR. Description:, Rotate Left f (No Carry) = The contents of register, 'f', are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overrid- ing the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR. Description:, Rotate Left f (No Carry) = The contents of register, 'f', are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd'",
    "PIC18F2331/2431/4331/4431\nis ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overrid- ing the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR. Description:, Rotate Left f (No Carry) = The contents of register, 'f', are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overrid- ing the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR. Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f (No Carry) = register f. Words:, Rotate Left f (No Carry) = register f. Words:, Rotate Left f (No Carry) = . Cycles:, Rotate Left f (No Carry) = 1.",
    "PIC18F2331/2431/4331/4431\nCycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = . Q Cycle Activity: Q1, Rotate Left f (No Carry) = Q2. Q Cycle Activity: Q1, Rotate Left f (No Carry) = Q3. Q Cycle Activity: Q1, Rotate Left f (No Carry) = . Q Cycle Activity: Q1, Rotate Left f (No Carry) = Q4. Decode, Rotate Left f (No Carry) = Read register 'f'. Decode, Rotate Left f (No Carry) = Process Data. Decode, Rotate Left f (No Carry) = Process Data. Decode, Rotate Left f (No Carry) = Write to destination. Example:, Rotate Left f (No Carry) = RLNCF. Example:, Rotate Left f (No Carry) = REG. Example:, Rotate Left f (No Carry) = . Example:, Rotate Left f (No Carry) = . Before Instruction REG =, Rotate Left f (No Carry) = 1010. Before Instruction REG =,",
    "PIC18F2331/2431/4331/4431\nRotate Left f (No Carry) = 1011. Before Instruction REG =, Rotate Left f (No Carry) = . Before Instruction REG =, Rotate Left f (No Carry) = . After Instruction REG =, Rotate Left f (No Carry) = 0101. After Instruction REG =, Rotate Left f (No Carry) = 0111. After Instruction REG =, Rotate Left f (No Carry) = 0111. After Instruction REG =, Rotate Left f (No Carry) = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, Rotate Right f through Carry = [ label ] RRCF f [,d [,a]]. Syntax:, Rotate Right f through Carry = [ label ] RRCF f [,d [,a]]. Syntax:, Rotate Right f through Carry = [ label ] RRCF f [,d [,a]]. Syntax:, Rotate Right f through Carry = [ label ] RRCF f [,d [,a]]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae",
    "PIC18F2331/2431/4331/4431\ndest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 00da. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff. Description:, Rotate",
    "PIC18F2331/2431/4331/4431\nRight f through Carry = The contents of register, 'f', are rotated one bit to the right through the Carry Flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, Rotate Right f through Carry = The contents of register, 'f', are rotated one bit to the right through the Carry Flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, Rotate Right f through Carry = The contents of register, 'f', are rotated",
    "PIC18F2331/2431/4331/4431\none bit to the right through the Carry Flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, Rotate Right f through Carry = The contents of register, 'f', are rotated one bit to the right through the Carry Flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Words:,",
    "PIC18F2331/2431/4331/4431\nRotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Q Cycle Activity:, Rotate Right f through Carry = . Q Cycle Activity:, Rotate Right f through Carry = . Q Cycle Activity:, Rotate Right f through Carry = . Q Cycle Activity:, Rotate Right f through Carry = . Q1 Decode, Rotate Right f through Carry = Q2. Q1 Decode, Rotate Right f through Carry = Q3. Q1 Decode, Rotate Right f through Carry = Q4. Q1 Decode, Rotate Right f through Carry = Q4. , Rotate Right f through Carry = Read register 'f'. , Rotate Right f through Carry = Process Data. , Rotate Right f through Carry = Write to destination. , Rotate Right f through Carry = Write to destination. Example:, Rotate Right f through Carry = RRCF. Example:, Rotate Right f through Carry = REG, W. Example:, Rotate Right f through Carry = . Example:, Rotate Right",
    "PIC18F2331/2431/4331/4431\nf through Carry = . Before Instruction, Rotate Right f through Carry = Before Instruction. Before Instruction, Rotate Right f through Carry = Before Instruction. Before Instruction, Rotate Right f through Carry = Before Instruction. Before Instruction, Rotate Right f through Carry = Before Instruction. REG, Rotate Right f through Carry = = 1110. REG, Rotate Right f through Carry = 0110. REG, Rotate Right f through Carry = . REG, Rotate Right f through Carry = . After Instruction REG W, Rotate Right f through Carry = = 1110 = 0111. After Instruction REG W, Rotate Right f through Carry = 0110 0011. After Instruction REG W, Rotate Right f through Carry = . After Instruction REG W, Rotate Right f through Carry = . C, Rotate Right f through Carry = = 0. C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . C, Rotate Right f through Carry = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, Rotate Right f (No Carry) = [ label ] RRNCF f [,d [,a]]. Syntax:, Rotate Right f (No Carry) = [ label ] RRNCF f [,d [,a]]. Syntax:, Rotate Right f (No Carry) = [ label ] RRNCF f [,d [,a]]. Syntax:, Rotate Right f (No Carry) = [ label ] RRNCF f [,d [,a]]. Syntax:, Rotate Right f (No Carry) = [ label ] RRNCF f [,d [,a]]. Operands:, Rotate Right f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce",
    "PIC18F2331/2431/4331/4431\n[0,1]. Operands:, Rotate Right f (No Carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \uf0ae dest<n - 1>, (f<0>) \uf0ae dest<7>. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f",
    "PIC18F2331/2431/4331/4431\n(No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = N, Z. Encoding:, Rotate Right f (No Carry) = 0100. Encoding:, Rotate Right f (No Carry) = 00da. Encoding:, Rotate Right f (No Carry) = 00da. Encoding:, Rotate Right f (No Carry) = ffff. Encoding:, Rotate Right f (No Carry) = ffff. Description:, Rotate Right f (No Carry) = The contents of register, 'f', are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:,",
    "PIC18F2331/2431/4331/4431\nRotate Right f (No Carry) = The contents of register, 'f', are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, Rotate Right f (No Carry) = The contents of register, 'f', are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, Rotate Right f (No Carry) = The contents of register, 'f', are",
    "PIC18F2331/2431/4331/4431\nrotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, Rotate Right f (No Carry) = The contents of register, 'f', are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Words:, Rotate Right f (No Carry) = 1. Words:, Rotate Right f (No Carry) = 1. Words:, Rotate Right f (No Carry) = 1.",
    "PIC18F2331/2431/4331/4431\nWords:, Rotate Right f (No Carry) = 1. Words:, Rotate Right f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = 1. Q Cycle Activity:, Rotate Right f (No Carry) = . Q Cycle Activity:, Rotate Right f (No Carry) = . Q Cycle Activity:, Rotate Right f (No Carry) = . Q Cycle Activity:, Rotate Right f (No Carry) = . Q Cycle Activity:, Rotate Right f (No Carry) = . Q1, Rotate Right f (No Carry) = Q2. Q1, Rotate Right f (No Carry) = Q2. Q1, Rotate Right f (No Carry) = Q3. Q1, Rotate Right f (No Carry) = Q3. Q1, Rotate Right f (No Carry) = Q4. Decode, Rotate Right f (No Carry) =",
    "PIC18F2331/2431/4331/4431\nRead register 'f'. Decode, Rotate Right f (No Carry) = Read register 'f'. Decode, Rotate Right f (No Carry) = Process Data. Decode, Rotate Right f (No Carry) = Process Data. Decode, Rotate Right f (No Carry) = Write to destination. Example 1:, Rotate Right f (No Carry) = RRNCF REG, 1, 0. Example 1:, Rotate Right f (No Carry) = RRNCF REG, 1, 0. Example 1:, Rotate Right f (No Carry) = RRNCF REG, 1, 0. Example 1:, Rotate Right f (No Carry) = RRNCF REG, 1, 0. Example 1:, Rotate Right f (No Carry) = RRNCF REG, 1, 0. Before Instruction, Rotate Right f (No Carry) = Before Instruction. Before Instruction, Rotate Right f (No Carry) = Before Instruction. Before Instruction, Rotate Right f (No Carry) = Before Instruction. Before Instruction, Rotate Right f (No Carry) = Before Instruction. Before Instruction, Rotate Right f (No Carry) = Before Instruction.",
    "PIC18F2331/2431/4331/4431\nREG, Rotate Right f (No Carry) = = 1101. REG, Rotate Right f (No Carry) = 0111. REG, Rotate Right f (No Carry) = 0111. REG, Rotate Right f (No Carry) = 0111. REG, Rotate Right f (No Carry) = 0111. After Instruction REG =, Rotate Right f (No Carry) = 1110. After Instruction REG =, Rotate Right f (No Carry) = 1011. After Instruction REG =, Rotate Right f (No Carry) = 1011. After Instruction REG =, Rotate Right f (No Carry) = 1011. After Instruction REG =, Rotate Right f (No Carry) = 1011. Example 2:, Rotate Right f (No Carry) = RRNCF. Example 2:, Rotate Right f (No Carry) = REG, W. Example 2:, Rotate Right f (No Carry) = REG, W. Example 2:, Rotate Right f (No Carry) = REG, W. Example 2:, Rotate Right f (No Carry) = REG, W. Before Instruction, Rotate Right f (No Carry) = Before Instruction. Before",
    "PIC18F2331/2431/4331/4431\nInstruction, Rotate Right f (No Carry) = Before Instruction. Before Instruction, Rotate Right f (No Carry) = Before Instruction. Before Instruction, Rotate Right f (No Carry) = Before Instruction. Before Instruction, Rotate Right f (No Carry) = Before Instruction. W, Rotate Right f (No Carry) = = ?. W, Rotate Right f (No Carry) = . W, Rotate Right f (No Carry) = . W, Rotate Right f (No Carry) = . W, Rotate Right f (No Carry) = . REG, Rotate Right f (No Carry) = = 1101. REG, Rotate Right f (No Carry) = 0111. REG, Rotate Right f (No Carry) = 0111. REG, Rotate Right f (No Carry) = 0111. REG, Rotate Right f (No Carry) = 0111. After Instruction, Rotate Right f (No Carry) = After Instruction. After Instruction, Rotate Right f (No Carry) = After Instruction. After Instruction, Rotate Right f (No Carry) = After Instruction. After Instruction, Rotate Right f (No Carry) = After Instruction. After Instruction, Rotate Right f (No",
    "PIC18F2331/2431/4331/4431\nCarry) = After Instruction. W, Rotate Right f (No Carry) = = 1110. W, Rotate Right f (No Carry) = 1011. W, Rotate Right f (No Carry) = 1011. W, Rotate Right f (No Carry) = 1011. W, Rotate Right f (No Carry) = 1011. REG, Rotate Right f (No Carry) = = 1101. REG, Rotate Right f (No Carry) = 0111. REG, Rotate Right f (No Carry) = 0111. REG, Rotate Right f (No Carry) = 0111. REG, Rotate Right f (No Carry) = 0111",
    "Set f\nSyntax:\n[ label ] SETF    f [,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\na \uf0ce\uf020 [0,1]\nOperation:\nFFh \uf0ae f\nStatus Affected:\nNone\nEncoding:\n0110\n100a\nffff\nffff\nDescription:\nThe contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite\nregister 'f'\nExample:\nSETF\nREG\nBefore Instruction REG\n=\n0x5A\nAfter Instruction\nREG\n=\n0xFF",
    "PIC18F2331/2431/4331/4431\nSyntax:, Enter Sleep Mode = [ label ] SLEEP. Syntax:, Enter Sleep Mode = [ label ] SLEEP. Syntax:, Enter Sleep Mode = [ label ] SLEEP. Syntax:, Enter Sleep Mode = [ label ] SLEEP. Operands:, Enter Sleep Mode = None. Operands:, Enter Sleep Mode = None. Operands:, Enter Sleep Mode = None. Operands:, Enter Sleep Mode = None. Operation:, Enter Sleep Mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler,. Operation:, Enter Sleep Mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler,. Operation:, Enter Sleep Mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler,. Operation:, Enter Sleep Mode = 00h \uf0ae WDT, 0 \uf0ae WDT postscaler,. Status Affected:, Enter Sleep Mode = TO, PD. Status Affected:, Enter Sleep Mode = TO, PD. Status Affected:, Enter Sleep Mode = TO, PD. Status Affected:, Enter Sleep Mode = TO, PD. Encoding:, Enter Sleep Mode = 0000. Encoding:, Enter Sleep Mode = 0000. Encoding:, Enter Sleep Mode",
    "PIC18F2331/2431/4331/4431\n= 0000. Encoding:, Enter Sleep Mode = 0011\nDescription:\nThe Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared.\nThe processor is put into Sleep mode with the oscillator stopped.\nWords:\nCycles:\n1\n1\nQ Cycle Activity:\nExample:\nSLEEP\nBefore Instruction\nTO\n=\n?\nPD\n=\n?\nAfter Instruction\nTO\n=\n1 \u2020\nPD\n=\n0\n- \u2020   If WDT causes wake-up, this bit is cleared.",
    "PIC18F2331/2431/4331/4431\nSyntax:, Subtract f from Wwith Borrow = [ label ] SUBFWB f [,d [,a]]. Syntax:, Subtract f from Wwith Borrow = [ label ] SUBFWB f [,d [,a]]. Syntax:, Subtract f from Wwith Borrow = [ label ] SUBFWB f [,d [,a]]. Syntax:, Subtract f from Wwith Borrow = [ label ] SUBFWB f [,d [,a]]. Syntax:, Subtract f from Wwith Borrow = [ label ] SUBFWB f [,d [,a]]. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255. Operands:, Subtract f from Wwith Borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255. Operation:, Subtract f from Wwith Borrow =",
    "PIC18F2331/2431/4331/4431\nd \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Subtract f from Wwith Borrow = d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Subtract f from Wwith Borrow = d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Subtract f from Wwith Borrow = d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Subtract f from Wwith Borrow = d \uf0ce [0,1] a \uf0ce [0,1]. , Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. , Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. , Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. , Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. , Subtract f from Wwith Borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Status Affected:, Subtract f from",
    "PIC18F2331/2431/4331/4431\nWwith Borrow = N,. Status Affected:, Subtract f from Wwith Borrow = OV, C,. Status Affected:, Subtract f from Wwith Borrow = DC, Z. Status Affected:, Subtract f from Wwith Borrow = . Status Affected:, Subtract f from Wwith Borrow = . Encoding:, Subtract f from Wwith Borrow = 0101. Encoding:, Subtract f from Wwith Borrow = . Encoding:, Subtract f from Wwith Borrow = 01da. Encoding:, Subtract f from Wwith Borrow = ffff. Encoding:, Subtract f from Wwith Borrow = . Description:, Subtract f from Wwith Borrow = Subtract register, 'f', and the Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If",
    "PIC18F2331/2431/4331/4431\n'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, Subtract f from Wwith Borrow = Subtract register, 'f', and the Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, Subtract f from Wwith Borrow = Subtract register, 'f', and the Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If",
    "PIC18F2331/2431/4331/4431\n'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, Subtract f from Wwith Borrow = Subtract register, 'f', and the Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, Subtract f from Wwith Borrow = Subtract register, 'f', and the Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If",
    "PIC18F2331/2431/4331/4431\n'a' is ' 1 ', then the bank will be selected as per the BSR value.. Words:, Subtract f from Wwith Borrow = 1. Words:, Subtract f from Wwith Borrow = 1. Words:, Subtract f from Wwith Borrow = 1. Words:, Subtract f from Wwith Borrow = 1. Words:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Q Cycle Activity:, Subtract f from Wwith Borrow = Q Cycle Activity:. Q Cycle Activity:, Subtract f from Wwith Borrow = Q Cycle Activity:. Q Cycle Activity:, Subtract f from Wwith Borrow = Q Cycle Activity:. Q Cycle Activity:, Subtract f from Wwith Borrow = Q Cycle Activity:. Q Cycle",
    "PIC18F2331/2431/4331/4431\nActivity:, Subtract f from Wwith Borrow = Q Cycle Activity:. Q1, Subtract f from Wwith Borrow = Q2. Q1, Subtract f from Wwith Borrow = Q2. Q1, Subtract f from Wwith Borrow = Q3. Q1, Subtract f from Wwith Borrow = Q3. Q1, Subtract f from Wwith Borrow = Q4. Decode, Subtract f from Wwith Borrow = Read register 'f'. Decode, Subtract f from Wwith Borrow = Read register 'f'. Decode, Subtract f from Wwith Borrow = Process Data. Decode, Subtract f from Wwith Borrow = Process Data. Decode, Subtract f from Wwith Borrow = Write to destination. Example 1: SUBFWB, Subtract f from Wwith Borrow = Example 1: SUBFWB. Example 1: SUBFWB, Subtract f from Wwith Borrow = Example 1: SUBFWB. Example 1: SUBFWB, Subtract f from Wwith Borrow =",
    "PIC18F2331/2431/4331/4431\nREG. Example 1: SUBFWB, Subtract f from Wwith Borrow = REG. Example 1: SUBFWB, Subtract f from Wwith Borrow = REG. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. REG, Subtract f from Wwith Borrow = =. REG, Subtract f from Wwith Borrow = 0x03. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = =. W, Subtract f from Wwith Borrow = 0x02. W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith",
    "PIC18F2331/2431/4331/4431\nBorrow = . C, Subtract f from Wwith Borrow = =. C, Subtract f from Wwith Borrow = 0x01. C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. REG, Subtract f from Wwith Borrow = =. REG, Subtract f from Wwith Borrow = 0xFF. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = =. W, Subtract f from Wwith Borrow = 0x02. W, Subtract f from",
    "PIC18F2331/2431/4331/4431\nWwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = =. C, Subtract f from Wwith Borrow = 0x00. C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = =. Z, Subtract f from Wwith Borrow = 0x00. Z, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = . , Subtract f from Wwith Borrow = =. , Subtract f from Wwith Borrow =",
    "PIC18F2331/2431/4331/4431\n0x01. , Subtract f from Wwith Borrow = ; result is negative. , Subtract f from Wwith Borrow = ; result is negative. , Subtract f from Wwith Borrow = ; result is negative. Example 2: SUBFWB, Subtract f from Wwith Borrow = Example 2: SUBFWB. Example 2: SUBFWB, Subtract f from Wwith Borrow = Example 2: SUBFWB. Example 2: SUBFWB, Subtract f from Wwith Borrow = REG, 0, 0. Example 2: SUBFWB, Subtract f from Wwith Borrow = REG, 0, 0. Example 2: SUBFWB, Subtract f from Wwith Borrow = REG, 0, 0. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before",
    "PIC18F2331/2431/4331/4431\nInstruction. REG, Subtract f from Wwith Borrow = =. REG, Subtract f from Wwith Borrow = 2. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = =. W, Subtract f from Wwith Borrow = 5. W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = =. C, Subtract f from Wwith Borrow = 1. C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from",
    "PIC18F2331/2431/4331/4431\nWwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. REG, Subtract f from Wwith Borrow = =. REG, Subtract f from Wwith Borrow = 2. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = =. W, Subtract f from Wwith Borrow = 3. W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = =. C, Subtract f from Wwith Borrow = 1. C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = =. Z, Subtract f from Wwith Borrow = 0. Z, Subtract f from",
    "PIC18F2331/2431/4331/4431\nWwith Borrow = . Z, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = =. N, Subtract f from Wwith Borrow = 0. N, Subtract f from Wwith Borrow = ; result is positive. N, Subtract f from Wwith Borrow = ; result is positive. N, Subtract f from Wwith Borrow = ; result is positive. Example 3: SUBFWB, Subtract f from Wwith Borrow = Example 3: SUBFWB. Example 3: SUBFWB, Subtract f from Wwith Borrow = Example 3: SUBFWB. Example 3: SUBFWB, Subtract f from Wwith Borrow = REG, 1, 0. Example 3: SUBFWB, Subtract f from Wwith Borrow = REG, 1, 0. Example 3: SUBFWB, Subtract f from Wwith Borrow = REG, 1, 0. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction,",
    "PIC18F2331/2431/4331/4431\nSubtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. Before Instruction, Subtract f from Wwith Borrow = Before Instruction. REG, Subtract f from Wwith Borrow = =. REG, Subtract f from Wwith Borrow = 1. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = =. W, Subtract f from Wwith Borrow = 2. W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = =. C, Subtract f from Wwith Borrow = 0. C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow = . C, Subtract f from Wwith Borrow =",
    "PIC18F2331/2431/4331/4431\n. After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. After Instruction, Subtract f from Wwith Borrow = After Instruction. REG, Subtract f from Wwith Borrow = =. REG, Subtract f from Wwith Borrow = 0. REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . REG, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = =. W, Subtract f from Wwith Borrow = 2. W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . W, Subtract f from Wwith Borrow = . C Z, Subtract f from Wwith Borrow = = =. C Z, Subtract f from Wwith Borrow = 1 1. C Z, Subtract f from Wwith Borrow =",
    "PIC18F2331/2431/4331/4431\n. C Z, Subtract f from Wwith Borrow = . C Z, Subtract f from Wwith Borrow = . N, Subtract f from Wwith Borrow = =. N, Subtract f from Wwith Borrow = 0. N, Subtract f from Wwith Borrow = ; result is zero. N, Subtract f from Wwith Borrow = ; result is zero. N, Subtract f from Wwith Borrow = ; result is zero",
    "SUBLW\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "Subtract W from Literal\n[ label\n] SUBLW   k\n0 \uf0a3\uf020 k \uf0a3\uf020 255\nk - (W) \uf0ae\uf020 W\nN, OV, C, DC, Z\n0000\n1000\nkkkk kkkk\nW is subtracted from the 8-bit literal, 'k'. The result is placed in W.\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read literal 'k'. Decode, Q3 = Process Data. Decode, Q4 = Write to W",
    "Example 1:\nSUBLW\n0x02\nBefore Instruction\nW\n=\n1\nC\n=\n?\nAfter Instruction\nW\n=\n1\nC\n=\n1      ; result is positive\nZ\n=\n0\nN\n=\n0\nExample 2:\nSUBLW\n0x02\nBefore Instruction\nW\n=\n2\nC\n=\n?\nAfter Instruction\nW\n=\n0\nC\n=\n1      ; result is zero\nZ\n=\n1\nN\n=\n0\nExample 3:\nSUBLW\n0x02\nBefore Instruction\nW\n=\n3\nC\n=\n?\nAfter Instruction\nW\n=\nFF   ; (2's complement)\nC\n=\n0     ; result is negative\nZ\n=\n0\nN\n=\n1",
    "Example 1:\nSyntax:, Subtract Wfrom = [ label ]. Syntax:, f = [ label ]. Syntax:, f = SUBWF f. Syntax:, f = [,d [,a]]. Syntax:, f = [,d [,a]]. Operands:, Subtract Wfrom = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1]. Operands:, f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1]. Operands:, f = . Operands:, f = . Operands:, f = . Operation:, Subtract Wfrom = (f) - (W) \uf0ae\uf020 dest. Operation:, f = (f) - (W) \uf0ae\uf020 dest. Operation:, f = . Operation:, f = . Operation:, f = . Status Affected:, Subtract Wfrom = N, OV, C, DC,. Status Affected:, f = N, OV, C, DC,. Status Affected:, f = . Status Affected:, f = . Status Affected:, f = . Encoding:, Subtract Wfrom = 0101. Encoding:, f = 0101.",
    "Example 1:\nEncoding:, f = 11da. Encoding:, f = ffff. Encoding:, f = ffff. Description:, Subtract Wfrom = Subtract Wfrom register, 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If = 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, f = Subtract Wfrom register, 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If = 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, f = Subtract",
    "Example 1:\nWfrom register, 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If = 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, f = Subtract Wfrom register, 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If = 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, f = Subtract Wfrom register, 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is",
    "Example 1:\n' 1 ', the result is stored back in register, 'f'. If = 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Words:, Subtract Wfrom = 1. Words:, f = 1. Words:, f = . Words:, f = . Words:, f = . Cycles:, Subtract Wfrom = 1. Cycles:, f = 1. Cycles:, f = . Cycles:, f = . Cycles:, f = . Q Cycle Activity:, Subtract Wfrom = Q Cycle Activity:. Q Cycle Activity:, f = Q Cycle Activity:. Q Cycle Activity:, f = Q Cycle Activity:. Q Cycle Activity:, f = Q Cycle Activity:. Q Cycle Activity:, f = Q Cycle Activity:. Q1, Subtract Wfrom = Q2. Q1, f = Q2. Q1, f = Q3. Q1, f = Q4. Q1, f = Q4. Decode, Subtract",
    "Example 1:\nWfrom = Read register 'f'. Decode, f = Read register 'f'. Decode, f = Process Data. Decode, f = Write to destination. Decode, f = Write to destination. 1:, Subtract Wfrom = . 1:, f = . 1:, f = . 1:, f = . 1:, f = . Example SUBWF REG Before Instruction, Subtract Wfrom = Example SUBWF REG Before Instruction. Example SUBWF REG Before Instruction, f = Example SUBWF REG Before Instruction. Example SUBWF REG Before Instruction, f = Example SUBWF REG Before Instruction. Example SUBWF REG Before Instruction, f = Example SUBWF REG Before Instruction. Example SUBWF REG Before Instruction, f = Example SUBWF REG Before Instruction. REG =, Subtract Wfrom = 3. REG =, f = 3. REG =, f = . REG =, f = . REG =, f = . W, Subtract Wfrom = 2. W, f = 2. W, f = . W, f = . W, f = . C, Subtract",
    "Example 1:\nWfrom = = =. C, f = = =. C, f = . C, f = . C, f = . , Subtract Wfrom = ?. , f = ?. , f = . , f = . , f = . After Instruction, Subtract Wfrom = . After Instruction, f = . After Instruction, f = . After Instruction, f = . After Instruction, f = . REG =, Subtract Wfrom = 1. REG =, f = 1. REG =, f = . REG =, f = . REG =, f = . W =, Subtract Wfrom = 2. W =, f = 2. W =, f = ; result is positive. W =, f = ; result is positive. W =, f = ; result is positive. C, Subtract Wfrom = 0. C, f = 0. C, f = . C, f = . C, f = . Z, Subtract Wfrom = = 1 = =. Z, f = = 1 = =. Z, f = . Z, f = . Z, f = . N, Subtract",
    "Example 1:\nWfrom = . N, f = . N, f = . N, f = . N, f = . 2:, Subtract Wfrom = 0. 2:, f = 0. 2:, f = . 2:, f = . 2:, f = . Example SUBWF REG, W Before Instruction, Subtract Wfrom = Example SUBWF REG, W Before Instruction. Example SUBWF REG, W Before Instruction, f = Example SUBWF REG, W Before Instruction. Example SUBWF REG, W Before Instruction, f = Example SUBWF REG, W Before Instruction. Example SUBWF REG, W Before Instruction, f = Example SUBWF REG, W Before Instruction. Example SUBWF REG, W Before Instruction, f = Example SUBWF REG, W Before Instruction. REG =, Subtract Wfrom = 2. REG =, f = 2. REG =, f = . REG =, f = . REG =, f = . W =, Subtract Wfrom = 2. W =, f = 2. W =, f = . W =, f = . W =, f = . C",
    "Example 1:\n=, Subtract Wfrom = ?. C =, f = ?. C =, f = . C =, f = . C =, f = . After Instruction, Subtract Wfrom = 2. After Instruction, f = 2. After Instruction, f = . After Instruction, f = . After Instruction, f = . REG = W, Subtract Wfrom = 0. REG = W, f = 0. REG = W, f = . REG = W, f = . REG = W, f = . C =, Subtract Wfrom = 1. C =, f = 1. C =, f = . C =, f = zero. C =, f = . Z =, Subtract Wfrom = 1 0. Z =, f = 1 0. Z =, f = . Z =, f = . Z =, f = . N =, Subtract Wfrom = . N =, f = . N =, f = . N =, f = . N =, f = . 3:, Subtract Wfrom = . 3:, f = . 3:, f = . 3:,",
    "Example 1:\nf = . 3:, f = . Example, Subtract Wfrom = SUBWF. Example, f = SUBWF. Example, f = REG. Example, f = REG. Example, f = . , Subtract Wfrom = 0x01 0x02. , f = 0x01 0x02. , f = . , f = . , f = . REG = W, Subtract Wfrom = . REG = W, f = . REG = W, f = . REG = W, f = . REG = W, f = . C =, Subtract Wfrom = ?. C =, f = ?. C =, f = . C =, f = . C =, f = . After Instruction, Subtract Wfrom = . After Instruction, f = . After Instruction, f = . After Instruction, f = . After Instruction, f = . REG, Subtract Wfrom = = 0xFFh. REG, f = = 0xFFh. REG, f = ; (2's complement). REG, f = ; (2's complement). REG, f = ;",
    "Example 1:\n(2's complement). W, Subtract Wfrom = = 0x02. W, f = = 0x02. W, f = . W, f = . W, f = . C, Subtract Wfrom = =. C, f = =. C, f = . C, f = . C, f = . , Subtract Wfrom = =. , f = =. , f = . , f = . , f = . Z, Subtract Wfrom = 0x00. Z, f = 0x00. Z, f = . Z, f = . Z, f = . , Subtract Wfrom = 0x00. , f = 0x00. , f = . , f = negative. , f = negative. , Subtract Wfrom = 0x01. , f = 0x01. , f = . , f = . , f = . , Subtract Wfrom = =. , f = =. , f = . , f = . , f = . N, Subtract Wfrom = . N, f = . N, f = .",
    "Example 1:\nN, f = . N, f = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, Subtract Wfrom f with Borrow = [ label ]. Syntax:, Subtract Wfrom f with Borrow = SUBWFB. Syntax:, Subtract Wfrom f with Borrow = f [,d [,a]]. Syntax:, Subtract Wfrom f with Borrow = . Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020",
    "PIC18F2331/2431/4331/4431\ndest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Encoding:, Subtract Wfrom f with Borrow = 0101. Encoding:, Subtract Wfrom f with Borrow = 10da. Encoding:, Subtract Wfrom f with Borrow = ffff. Encoding:, Subtract Wfrom f with Borrow = ffff. Description:, Subtract Wfrom f with Borrow = Subtract Wandthe Carry flag",
    "PIC18F2331/2431/4331/4431\n(borrow) from register, 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be. Description:, Subtract Wfrom f with Borrow = Subtract Wandthe Carry flag (borrow) from register, 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be. Description:, Subtract Wfrom f with Borrow = Subtract Wandthe Carry flag (borrow) from register, 'f' (2's complement method). If",
    "PIC18F2331/2431/4331/4431\n'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be. Description:, Subtract Wfrom f with Borrow = Subtract Wandthe Carry flag (borrow) from register, 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = . Words:, Subtract Wfrom f with Borrow = . Words:, Subtract Wfrom f with Borrow =",
    "PIC18F2331/2431/4331/4431\n. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = . Cycles:, Subtract Wfrom f with Borrow = . Cycles:, Subtract Wfrom f with Borrow = \nQ Cycle Activity:",
    "PIC18F2331/2431/4331/4431\nExample 1: SUBWFB, Q2.Read register = Example 1: SUBWFB. Example 1: SUBWFB, 'f' = . Example 1: SUBWFB, Q3.Process Data = REG, 1, 0. Example 1: SUBWFB, Q4.Write to destination = . Before Instruction, Q2.Read register = Before Instruction. Before Instruction, 'f' = . Before Instruction, Q3.Process Data = . Before Instruction, Q4.Write to destination = . REG, Q2.Read register = =. REG, 'f' = 0x19. REG, Q3.Process Data = (0001. REG, Q4.Write to destination = 1001). W, Q2.Read register = =. W, 'f' = 0x0D. W, Q3.Process Data = (0000 1101). W, Q4.Write to destination = . C, Q2.Read register = =. C, 'f' = 0x01. C, Q3.Process Data = . C, Q4.Write to destination = . After Instruction,",
    "PIC18F2331/2431/4331/4431\nQ2.Read register = After Instruction. After Instruction, 'f' = . After Instruction, Q3.Process Data = . After Instruction, Q4.Write to destination = . REG, Q2.Read register = =. REG, 'f' = 0x0C. REG, Q3.Process Data = (0000. REG, Q4.Write to destination = 1011). W, Q2.Read register = =. W, 'f' = 0x0D. W, Q3.Process Data = (0000. W, Q4.Write to destination = 1101). C, Q2.Read register = =. C, 'f' = 0x01. C, Q3.Process Data = . C, Q4.Write to destination = . Z, Q2.Read register = =. Z, 'f' = 0x00. Z, Q3.Process Data = . Z, Q4.Write to destination = . N, Q2.Read register = =. N, 'f' = 0x00. N, Q3.Process Data = ; result is positive.",
    "PIC18F2331/2431/4331/4431\nN, Q4.Write to destination = ; result is positive. Example 2:, Q2.Read register = Example 2:. Example 2:, 'f' = SUBWFB. Example 2:, Q3.Process Data = REG, 0, 0. Example 2:, Q4.Write to destination = . Before Instruction, Q2.Read register = Before Instruction. Before Instruction, 'f' = . Before Instruction, Q3.Process Data = . Before Instruction, Q4.Write to destination = . REG, Q2.Read register = =. REG, 'f' = 0x1B. REG, Q3.Process Data = (0001. REG, Q4.Write to destination = 1011). W, Q2.Read register = =. W, 'f' = 0x1A. W, Q3.Process Data = (0001. W, Q4.Write to destination = 1010). C, Q2.Read register = =. C, 'f' = 0x00. C, Q3.Process Data = . C, Q4.Write to destination = . After",
    "PIC18F2331/2431/4331/4431\nInstruction, Q2.Read register = After Instruction. After Instruction, 'f' = . After Instruction, Q3.Process Data = . After Instruction, Q4.Write to destination = . REG, Q2.Read register = =. REG, 'f' = 0x1B. REG, Q3.Process Data = (0001 1011). REG, Q4.Write to destination = . W, Q2.Read register = =. W, 'f' = 0x00. W, Q3.Process Data = . W, Q4.Write to destination = . C, Q2.Read register = =. C, 'f' = 0x01. C, Q3.Process Data = . C, Q4.Write to destination = . Z, Q2.Read register = =. Z, 'f' = 0x01. Z, Q3.Process Data = ; result is zero. Z, Q4.Write to destination = . N, Q2.Read register = =. N, 'f' = 0x00. N, Q3.Process Data = . N, Q4.Write",
    "PIC18F2331/2431/4331/4431\nto destination = . Example 3:, Q2.Read register = Example 3:. Example 3:, 'f' = SUBWFB. Example 3:, Q3.Process Data = REG, 1,. Example 3:, Q4.Write to destination = . Before Instruction, Q2.Read register = Before Instruction. Before Instruction, 'f' = . Before Instruction, Q3.Process Data = . Before Instruction, Q4.Write to destination = . REG, Q2.Read register = =. REG, 'f' = 0x03. REG, Q3.Process Data = (0000 0011). REG, Q4.Write to destination = . W, Q2.Read register = =. W, 'f' = 0x0E. W, Q3.Process Data = (0000. W, Q4.Write to destination = 1101). C, Q2.Read register = =. C, 'f' = 0x01. C, Q3.Process Data = . C, Q4.Write to destination = . After Instruction, Q2.Read register = After Instruction. After",
    "PIC18F2331/2431/4331/4431\nInstruction, 'f' = . After Instruction, Q3.Process Data = . After Instruction, Q4.Write to destination = . REG, Q2.Read register = =. REG, 'f' = 0xF5. REG, Q3.Process Data = (1111. REG, Q4.Write to destination = 0100). , Q2.Read register = . , 'f' = . , Q3.Process Data = ; [2's comp]. , Q4.Write to destination = . W, Q2.Read register = =. W, 'f' = 0x0E. W, Q3.Process Data = (0000. W, Q4.Write to destination = 1101). C, Q2.Read register = =. C, 'f' = 0x00. C, Q3.Process Data = . C, Q4.Write to destination = . Z, Q2.Read register = =. Z, 'f' = 0x00. Z, Q3.Process Data = . Z, Q4.Write to destination = . N,",
    "PIC18F2331/2431/4331/4431\nQ2.Read register = =. N, 'f' = 0x01. N, Q3.Process Data = ; result is negative. N, Q4.Write to destination = ",
    "PIC18F2331/2431/4331/4431\nSyntax:, Swap f = [ label ]. Syntax:, Swap f = SWAPF. Syntax:, Swap f = f [,d [,a]]. Syntax:, Swap f = . Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae",
    "PIC18F2331/2431/4331/4431\ndest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Encoding:, Swap f = 0011. Encoding:, Swap f = 10da. Encoding:, Swap f = ffff. Encoding:, Swap f = ffff\nDescription:\nThe upper and lower nibbles of register, 'f', are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\n1\n1\nQ2\nRead register 'f'",
    "Example:\nSWAPF\nBefore Instruction\nREG\n=\n0x53\nAfter Instruction\nREG\n=\n0x35\nQ3\nProcess Data\nREG\nQ4\nWrite to destination",
    "PIC18F2331/2431/4331/4431\nSyntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT, TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT, (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT, (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*,. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT, TBLPTR - No Change; if",
    "PIC18F2331/2431/4331/4431\nTBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT, (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT, (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*,. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT, TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT, (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT, (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*,. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Encoding:, Table Read = 0000. Encoding:, Table Read = 0000 0000. Encoding:, Table Read = 10nn nn = 0 * =1 *+.",
    "PIC18F2331/2431/4331/4431\nDescription:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte",
    "PIC18F2331/2431/4331/4431\nof Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Q Cycle Activity:, Table Read = . Q Cycle Activity:, Table Read = . Q",
    "PIC18F2331/2431/4331/4431\nCycle Activity:, Table Read = . Q1, Table Read = . Q1, Table Read = . Q1, Table Read = . , Table Read = Q2. , Table Read = Q3. , Table Read = Q4. Decode, Table Read = No operation. Decode, Table Read = No operation. Decode, Table Read = No operation. No operation, Table Read = No operation (Read Program Memory). No operation, Table Read = No operation. No operation, Table Read = No operation (Write TABLAT)",
    "Table Read (cont'd)\nBefore Instruction TABLAT, TBLRD = Before Instruction TABLAT. Before Instruction TABLAT, ; = =. Before Instruction TABLAT,  = 0x55. TBLPTR, TBLRD = TBLPTR. TBLPTR, ; = =. TBLPTR,  = 0x00A356. MEMORY(0x00A356), TBLRD = MEMORY(0x00A356). MEMORY(0x00A356), ; = =. MEMORY(0x00A356),  = 0x34. After Instruction TABLAT, TBLRD = After Instruction TABLAT. After Instruction TABLAT, ; = =. After Instruction TABLAT,  = 0x34. TBLPTR, TBLRD = TBLPTR. TBLPTR, ; = =. TBLPTR,  = 0x00A357. Example 2:, TBLRD = TBLRD +*. Example 2:, ; = ;. Example 2:,  = . Before Instruction TABLAT, TBLRD = Before Instruction TABLAT. Before Instruction TABLAT, ; = =. Before Instruction TABLAT,",
    "Table Read (cont'd)\n= 0xAA. TBLPTR, TBLRD = TBLPTR. TBLPTR, ; = =. TBLPTR,  = 0x01A357. MEMORY(0x01A357), TBLRD = MEMORY(0x01A357). MEMORY(0x01A357), ; = =. MEMORY(0x01A357),  = 0x12. MEMORY(0x01A358), TBLRD = MEMORY(0x01A358). MEMORY(0x01A358), ; = =. MEMORY(0x01A358),  = 0x34. After Instruction TABLAT, TBLRD = After Instruction TABLAT. After Instruction TABLAT, ; = =. After Instruction TABLAT,  = 0x34. TBLPTR, TBLRD = TBLPTR. TBLPTR, ; = =. TBLPTR,  = 0x01A358",
    "PIC18F2331/2431/4331/4431\nSyntax:, Table Write = [ label ]. Syntax:, Table Write = TBLWT ( *; *+; *-; +*). Syntax:, Table Write = TBLWT ( *; *+; *-; +*). Syntax:, Table Write = TBLWT ( *; *+; *-; +*). Operands:, Table Write = None. Operands:, Table Write = None. Operands:, Table Write = None. Operands:, Table Write = None. Operation:, Table Write = if TBLWT*, (TABLAT) \uf0ae Holding Register, TBLPTR - No Change; if TBLWT*+, (TABLAT) \uf0ae Holding Register, (TBLPTR) + 1 \uf0ae TBLPTR; if TBLWT*-, (TABLAT) \uf0ae Holding Register, (TBLPTR) - 1 \uf0ae TBLPTR; if TBLWT+*, (TBLPTR) + 1 \uf0ae TBLPTR, (TABLAT) \uf0ae Holding Register. Operation:, Table Write = if TBLWT*, (TABLAT) \uf0ae Holding Register, TBLPTR - No Change; if",
    "PIC18F2331/2431/4331/4431\nTBLWT*+, (TABLAT) \uf0ae Holding Register, (TBLPTR) + 1 \uf0ae TBLPTR; if TBLWT*-, (TABLAT) \uf0ae Holding Register, (TBLPTR) - 1 \uf0ae TBLPTR; if TBLWT+*, (TBLPTR) + 1 \uf0ae TBLPTR, (TABLAT) \uf0ae Holding Register. Operation:, Table Write = if TBLWT*, (TABLAT) \uf0ae Holding Register, TBLPTR - No Change; if TBLWT*+, (TABLAT) \uf0ae Holding Register, (TBLPTR) + 1 \uf0ae TBLPTR; if TBLWT*-, (TABLAT) \uf0ae Holding Register, (TBLPTR) - 1 \uf0ae TBLPTR; if TBLWT+*, (TBLPTR) + 1 \uf0ae TBLPTR, (TABLAT) \uf0ae Holding Register. Operation:, Table Write = if TBLWT*, (TABLAT) \uf0ae Holding Register, TBLPTR - No Change; if TBLWT*+, (TABLAT) \uf0ae Holding Register, (TBLPTR) + 1 \uf0ae TBLPTR; if TBLWT*-, (TABLAT) \uf0ae Holding Register,",
    "PIC18F2331/2431/4331/4431\n(TBLPTR) - 1 \uf0ae TBLPTR; if TBLWT+*, (TBLPTR) + 1 \uf0ae TBLPTR, (TABLAT) \uf0ae Holding Register. Status Affected:, Table Write = None. Status Affected:, Table Write = None. Status Affected:, Table Write = None. Status Affected:, Table Write = None. Encoding:, Table Write = 0000. Encoding:, Table Write = 0000. Encoding:, Table Write = 0000. Encoding:, Table Write = 11nn nn = 0 *. , Table Write = . , Table Write = . , Table Write = . , Table Write = =1 *+. , Table Write = . , Table Write = . , Table Write = . , Table Write = =2 *-. , Table Write = . , Table Write = . , Table Write = . , Table Write = =3 +*\nDescription:",
    "PIC18F2331/2431/4331/4431\nThis instruction uses the 3 LSBs of TBLPTR to determine which of the 8 holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). (Refer to Section 8.0 'Flash Program Memory' for additional details on programming Flash memory.) The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. The LSb of the TBLPTR selects which byte of the program memory location to access.\nTBLPTR[0] = 0 :\nLeast Significant Byte of Program Memory Word\nTBLPTR[0] = 1 :\nMost Significant Byte of Program Memory Word\nThe TBLWT instruction can modify the value of TBLPTR as follows:\n\u00b7 no change\n\u00b7 post-increment\n\u00b7 post-decrement\n\u00b7 pre-increment",
    "TBLWT Table Write  (Continued)\nWords:\n1\nCycles: 2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation (Read TABLAT). No operation, No operation = No operation. No operation, No operation = No operation (Write to Holding Register )",
    "Example 1:\nTBLWT  *+;\nBefore Instruction\nTABLAT TBLPTR HOLDING REGISTER (0x00A356)\n= 0x55\n= 0x00A356\n= 0xFF\nAfter Instructions (table write completion)\nTABLAT TBLPTR HOLDING REGISTER (0x00A356)\n=\n0x55\n= 0x00A357\n= 0x55",
    "Example 2:\nTBLWT  +*;\nBefore Instruction\nTABLAT\n=\nTBLPTR\nHOLDING REGISTER\n(0x01389A)\nHOLDING REGISTER\n(0x01389B)\n=\n0xFF\nAfter Instruction (table write completion)\nTABLAT\n=\n0x34\nTBLPTR\nHOLDING REGISTER\n(0x01389A)\nHOLDING REGISTER\n(0x01389B)\n= 0x01389B\n= 0xFF\n=\n0x34\n0x34\n= 0x01389A\n=\n0xFF",
    "PIC18F2331/2431/4331/4431\nSyntax:, Test f, Skip if 0 = [ label ]. Syntax:, Test f, Skip if 0 = TSTFSZ f [,a]. Syntax:, Test f, Skip if 0 = . Operands:, Test f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, Skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Test f, Skip if 0 = skip if f = 0. Operation:, Test f, Skip if 0 = skip if f = 0. Operation:, Test f, Skip if 0 = skip if f = 0. Status Affected:, Test f, Skip if 0 = None. Status Affected:, Test f, Skip if 0 = None. Status Affected:, Test f, Skip if 0 = None. Encoding:, Test f, Skip if 0 = 0110. Encoding:, Test f, Skip if 0 = 011a ffff. Encoding:, Test f, Skip if 0 = ffff. Description:, Test f,",
    "PIC18F2331/2431/4331/4431\nSkip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution, is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Description:, Test f, Skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution, is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Description:, Test f, Skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution, is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is",
    "PIC18F2331/2431/4331/4431\n' 1 ', then the bank will be selected as per. Words:, Test f, Skip if 0 = 1. Words:, Test f, Skip if 0 = 1. Words:, Test f, Skip if 0 = 1. Cycles:, Test f, Skip if 0 = 1(2). Cycles:, Test f, Skip if 0 = 1(2). Cycles:, Test f, Skip if 0 = 1(2)",
    "PIC18F2331/2431/4331/4431\nSyntax:, XORLW = Syntax:. Syntax:, Exclusive OR Literal with W = [ label ] XORLW. Syntax:, Exclusive OR Literal with W = [ label ] XORLW. Syntax:, Exclusive OR Literal with W = k. Operands:, XORLW = Operands:. Operands:, Exclusive OR Literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR Literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR Literal with W = . Operation:, XORLW = Operation:. Operation:, Exclusive OR Literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR Literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR Literal with W = . Status Affected:, XORLW = Status Affected:. Status Affected:, Exclusive OR Literal with W = N, Z. Status Affected:, Exclusive OR Literal with W = N, Z. Status Affected:, Exclusive OR Literal with W = . Encoding:, XORLW = Encoding:. Encoding:, Exclusive OR Literal with W = 0000.",
    "PIC18F2331/2431/4331/4431\nEncoding:, Exclusive OR Literal with W = 1010. Encoding:, Exclusive OR Literal with W = kkkk. Description:, XORLW = Description:. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal, 'k'. The result is placed in W.. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal, 'k'. The result is placed in W.. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal, 'k'. The result is placed in W.. Words:, XORLW = Words:. Words:, Exclusive OR Literal with W = 1. Words:, Exclusive OR Literal with W = 1. Words:, Exclusive OR Literal with W = . Cycles:, XORLW = Cycles:. Cycles:, Exclusive OR Literal with W = 1. Cycles:, Exclusive OR Literal with W = 1. Cycles:, Exclusive OR Literal with W = . Q Cycle Activity:, XORLW = Q Cycle Activity:. Q Cycle",
    "PIC18F2331/2431/4331/4431\nActivity:, Exclusive OR Literal with W = . Q Cycle Activity:, Exclusive OR Literal with W = . Q Cycle Activity:, Exclusive OR Literal with W = . , XORLW = Q1. , Exclusive OR Literal with W = Q2. , Exclusive OR Literal with W = Q3. , Exclusive OR Literal with W = . , XORLW = Decode. , Exclusive OR Literal with W = Read literal 'k'. , Exclusive OR Literal with W = Process Data. , Exclusive OR Literal with W = \nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. If skip:, Q2 = If skip:. If skip:, Q3 = If skip:. If skip:, Q4 = If skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation,",
    "Q Cycle Activity:\nQ3 = No operation. No operation, Q4 = No operation\nExample:\nHERE    TSTFSZ  CNT NZERO    : ZERO   :\nBefore Instruction\nPC = Address (HERE)\nAfter Instruction\nIf CNT\n= 0x00,\nPC\n=\nAddress\n(ZERO)\nIf CNT\n\uf0b9 0x00,\nPC\n=\nAddress\n(NZERO)",
    "Example:\nXORLW\n0xAF\nBefore Instruction\nW\n=\n0xB5\nAfter Instruction\nW\n=\n0x1A",
    "PIC18F2331/2431/4331/4431\nSyntax:, XORWF = Syntax:. Syntax:, Exclusive OR Wwith f = [ label ]. Syntax:, Exclusive OR Wwith f = XORWF. Syntax:, Exclusive OR Wwith f = f [,d [,a]]. Operands:, XORWF = Operands:. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, XORWF = Operation:. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Status Affected:, XORWF = Status Affected:. Status Affected:,",
    "PIC18F2331/2431/4331/4431\nExclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Encoding:, XORWF = Encoding:. Encoding:, Exclusive OR Wwith f = 0001. Encoding:, Exclusive OR Wwith f = 10da. Encoding:, Exclusive OR Wwith f = ffff. Description:, XORWF = Description:. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register, 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register, 'f'. If 'd' is ' 0 ', the result is stored in W. If",
    "PIC18F2331/2431/4331/4431\n'd' is ' 1 ', the result is stored back in the register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register, 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register, 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value.. Words:, XORWF = Words:. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Cycles:, XORWF = Cycles:. Cycles:, Exclusive OR Wwith f = 1. Cycles:,",
    "PIC18F2331/2431/4331/4431\nExclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Q Cycle Activity:, XORWF = Q1. Q Cycle Activity:, Exclusive OR Wwith f = Q2. Q Cycle Activity:, Exclusive OR Wwith f = Q3. Q Cycle Activity:, Exclusive OR Wwith f = . , XORWF = Decode. , Exclusive OR Wwith f = Read register 'f'. , Exclusive OR Wwith f = Process Data. , Exclusive OR Wwith f = ",
    "Example:\nXORWF   REG\nBefore Instruction\nREG\n=\n0xAF\nW\n=\n0xB5\nAfter Instruction\nREG\n=\n0x1A\nW\n=\n0xB5",
    "25.0 DEVELOPMENT SUPPORT\nThe  PIC \u00ae   microcontrollers  and  dsPIC \u00ae digital  signal controllers are supported with a full range of software and hardware development tools:",
    "25.1 MPLAB Integrated Development Environment Software\n\u00b7 Integrated Development Environment\n-MPLAB \u00ae  IDE Software\n\u00b7 Compilers/Assemblers/Linkers\n-MPLAB C Compiler for Various Device Families\n-HI-TECH C for Various Device Families\n-MPASM TM  Assembler\n-MPLINK TM  Object Linker/ MPLIB TM  Object Librarian\n-MPLAB Assembler/Linker/Librarian for Various Device Families\n\u00b7 Simulators\n-MPLAB SIM Software Simulator\n\u00b7 Emulators\n-MPLAB REAL ICE\u2122 In-Circuit Emulator\n\u00b7 In-Circuit Debuggers\n-MPLAB ICD 3\n-PICkit\u2122 3 Debug Express\n\u00b7 Device Programmers\n-PICkit\u2122 2 Programmer\n-MPLAB PM3 Device Programmer\n\u00b7 Low-Cost Demonstration/Development Boards, Evaluation Kits, and Starter Kits\nThe MPLAB IDE software brings an ease of software development  previously  unseen  in  the  8/16/32-bit microcontroller market. The MPLAB IDE is a Windows \u00ae operating system-based application that contains:",
    "25.1 MPLAB Integrated Development Environment Software\n\u00b7 A single graphical interface to all debugging tools\n-Simulator\n-Programmer (sold separately)\n-In-Circuit Emulator (sold separately)\n-In-Circuit Debugger (sold separately)\n\u00b7 A full-featured editor with color-coded context\n\u00b7 A multiple project manager\n\u00b7 Customizable data windows with direct edit of contents\n\u00b7 High-level source code debugging\n\u00b7 Mouse over variable inspection\n\u00b7 Drag and drop variables from source to watch windows\n\u00b7 Extensive on-line help\n\u00b7 Integration of select third party tools, such as IAR C Compilers\nThe MPLAB IDE allows you to:\n\u00b7 Edit your source files (either C or assembly)\n\u00b7 One-touch compile or assemble, and download to emulator and simulator tools (automatically updates all project information)\n\u00b7 Debug using:\n-Source files (C or assembly)\n-Mixed C and assembly\n-Machine code\nMPLAB  IDE  supports  multiple  debugging  tools  in  a single development paradigm, from the cost-effective simulators,  through  low-cost  in-circuit  debuggers,  to full-featured  emulators.  This  eliminates  the  learning curve when upgrading to tools with increased flexibility and power.",
    "25.5 MPLINK Object Linker/ MPLIB Object Librarian\nThe MPLAB C Compiler code development systems are complete ANSI C compilers for Microchip's PIC18, PIC24 and PIC32 families of microcontrollers and the dsPIC30 and dsPIC33 families of digital signal controllers. These  compilers  provide  powerful  integration capabilities,  superior  code  optimization  and  ease  of use.\nFor easy source level debugging, the compilers provide symbol information that is optimized to the MPLAB IDE debugger.",
    "25.3 HI-TECH C for Various Device Families\nThe HI-TECH C Compiler code development systems are  complete  ANSI  C  compilers  for  Microchip's  PIC family of microcontrollers and the dsPIC family of digital signal  controllers.  These  compilers  provide  powerful integration  capabilities,  omniscient  code  generation and ease of use.\nFor easy source level debugging, the compilers provide symbol information that is optimized to the MPLAB IDE debugger.\nThe compilers include a macro assembler, linker, preprocessor, and one-step driver, and can run on multiple platforms.",
    "25.4 MPASM Assembler\nThe  MPASM  Assembler  is  a  full-featured,  universal macro assembler for PIC10/12/16/18 MCUs.\nThe MPASM Assembler generates relocatable object files for the MPLINK Object Linker, Intel \u00ae  standard HEX files,  MAP  files  to  detail  memory  usage  and  symbol reference, absolute LST files that contain source lines and  generated  machine  code  and  COFF  files  for debugging.\nThe MPASM Assembler features include:\n\u00b7 Integration into MPLAB IDE projects\n\u00b7 User-defined macros to streamline assembly code\n\u00b7 Conditional assembly for multi-purpose source files\n\u00b7 Directives that allow complete control over the assembly process\nThe  MPLINK  Object  Linker  combines relocatable objects  created  by  the  MPASM  Assembler  and  the MPLAB C18 C Compiler. It can link relocatable objects from  precompiled  libraries,  using  directives  from  a linker script.",
    "25.4 MPASM Assembler\nThe MPLIB Object Librarian manages the creation and modification of library files of precompiled code. When a routine from a library is called from a source file, only the modules that contain that routine will be linked in with  the  application.  This  allows  large  libraries  to  be used efficiently in many different applications.\nThe object linker/library features include:\n\u00b7 Efficient linking of single libraries instead of many smaller files\n\u00b7 Enhanced code maintainability by grouping related modules together\n\u00b7 Flexible creation of libraries with easy module listing, replacement, deletion and extraction",
    "25.6 MPLAB Assembler, Linker and Librarian for Various Device Families\nMPLAB  Assembler  produces  relocatable machine code  from  symbolic  assembly  language  for  PIC24, PIC32 and dsPIC devices. MPLAB C Compiler uses the assembler to produce its object file. The assembler generates  relocatable  object  files  that  can  then  be archived or linked with other relocatable object files and archives to create an executable file. Notable features of the assembler include:\n\u00b7 Support for the entire device instruction set\n\u00b7 Support for fixed-point and floating-point data\n\u00b7 Command line interface\n\u00b7 Rich directive set\n\u00b7 Flexible macro language\n\u00b7 MPLAB IDE compatibility",
    "25.7 MPLAB SIM Software Simulator\nThe  MPLAB  SIM  Software  Simulator  allows  code development in a PC-hosted environment by simulating the PIC MCUs and dsPIC \u00ae  DSCs on an instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a comprehensive stimulus controller. Registers can be logged to files for further run-time analysis. The trace buffer and logic analyzer display extend the power of the simulator to record and track program execution, actions on I/O, most peripherals and internal registers.\nThe  MPLAB  SIM  Software  Simulator  fully  supports symbolic  debugging  using  the  MPLAB  C Compilers, and  the  MPASM  and  MPLAB  Assemblers.  The  software  simulator  offers  the  flexibility  to  develop  and debug code outside of the hardware laboratory environment, making it an excellent, economical software development tool.",
    "25.8 MPLAB REAL ICE In-Circuit Emulator System\nMPLAB  REAL  ICE  In-Circuit Emulator System  is Microchip's  next  generation  high-speed  emulator  for Microchip Flash DSC and MCU devices. It debugs and programs PIC \u00ae  Flash MCUs and dsPIC \u00ae  Flash DSCs with the easy-to-use, powerful graphical user interface of the MPLAB Integrated Development Environment (IDE), included with each kit.\nThe emulator is connected to the design engineer's PC using a high-speed USB 2.0 interface and is connected to the target with either a connector compatible with incircuit debugger systems (RJ11) or with the new highspeed,  noise  tolerant,  Low-Voltage  Differential  Signal (LVDS) interconnection (CAT5).",
    "25.8 MPLAB REAL ICE In-Circuit Emulator System\nThe emulator is field upgradable through future firmware downloads  in  MPLAB  IDE.  In  upcoming  releases  of MPLAB IDE, new devices will be supported, and new features will be  added.  MPLAB  REAL  ICE  offers significant advantages over competitive emulators including low-cost, full-speed emulation, run-time variable watches, trace analysis, complex breakpoints, a ruggedized probe interface and long (up to three meters) interconnection cables.",
    "25.9 MPLAB ICD 3 In-Circuit Debugger System\nMPLAB ICD 3 In-Circuit  Debugger  System  is  Microchip's most cost effective high-speed hardware debugger/programmer for Microchip Flash Digital Signal Controller (DSC) and microcontroller (MCU) devices.  It  debugs  and  programs  PIC \u00ae   Flash  microcontrollers  and  dsPIC \u00ae   DSCs  with  the  powerful,  yet easy-to-use graphical user interface of MPLAB Integrated Development Environment (IDE).\nThe MPLAB ICD 3 In-Circuit Debugger probe is connected to the design engineer's PC using a high-speed USB 2.0 interface and is connected to the target with a connector compatible with the MPLAB ICD 2 or MPLAB REAL ICE systems (RJ-11). MPLAB ICD 3 supports all MPLAB ICD 2 headers.",
    "25.10 PICkit 3 In-Circuit Debugger/ Programmer and PICkit 3 Debug Express\nThe MPLAB PICkit 3 allows debugging and programming of PIC \u00ae  and dsPIC \u00ae  Flash microcontrollers at a most affordable price point using the powerful graphical user interface of the MPLAB Integrated Development Environment (IDE). The MPLAB PICkit 3 is connected to  the  design  engineer's  PC  using  a  full  speed  USB interface  and  can  be  connected  to  the  target  via  an Microchip  debug  (RJ-11)  connector  (compatible  with MPLAB ICD 3 and MPLAB REAL ICE). The connector uses two device I/O pins and the Reset line to implement  in-circuit  debugging  and  In-Circuit  Serial  Programming\u2122.\nThe PICkit 3 Debug Express include the PICkit 3, demo board and microcontroller, hookup cables and CDROM with user's guide, lessons, tutorial, compiler and MPLAB IDE software.",
    "25.13 Demonstration/Development Boards, Evaluation Kits, and Starter Kits\nThe PICkit\u2122 2 Development Programmer/Debugger is a low-cost development tool with an easy to use interface for programming and debugging Microchip's Flash families of microcontrollers. The full featured Windows \u00ae   programming  interface  supports  baseline (PIC10F, PIC12F5xx, PIC16F5xx), midrange (PIC12F6xx, PIC16F), PIC18F, PIC24, dsPIC30, dsPIC33, and PIC32 families of 8-bit, 16-bit, and 32-bit microcontrollers, and many Microchip Serial EEPROM products. With Microchip's powerful MPLAB Integrated Development Environment (IDE) the PICkit\u2122 2 enables in-circuit debugging on most PIC \u00ae  microcontrollers.  In-Circuit-Debugging  runs,  halts  and  single steps  the  program  while  the  PIC  microcontroller  is embedded in the application. When halted at a breakpoint, the file registers can be examined and modified.",
    "25.13 Demonstration/Development Boards, Evaluation Kits, and Starter Kits\nThe PICkit 2 Debug Express include the PICkit 2, demo board and microcontroller, hookup cables and CDROM with user's guide, lessons, tutorial, compiler and MPLAB IDE software.",
    "25.12 MPLAB PM3 Device Programmer\nThe MPLAB PM3 Device Programmer is a universal, CE compliant device programmer with programmable voltage verification at VDDMIN and VDDMAX for maximum  reliability.  It  features  a  large  LCD  display (128 x 64) for menus and error messages and a modular,  detachable  socket  assembly  to  support  various package types. The ICSP\u2122 cable assembly is included as a standard item. In Stand-Alone mode, the MPLAB PM3 Device Programmer can read, verify and program PIC devices without a PC connection. It can also set code  protection in this mode.  The  MPLAB  PM3 connects to the host PC via an RS-232 or USB cable. The MPLAB PM3 has high-speed communications and optimized  algorithms  for  quick  programming  of  large memory devices and incorporates an MMC card for file storage and data applications.\nA  wide  variety  of demonstration,  development  and evaluation  boards  for  various  PIC  MCUs  and  dsPIC DSCs allows quick application development on fully functional systems. Most boards include prototyping areas for adding custom circuitry and provide application firmware and source code for examination and modification.",
    "25.12 MPLAB PM3 Device Programmer\nThe boards support a variety of features, including LEDs, temperature sensors, switches, speakers, RS-232 interfaces, LCD displays, potentiometers and additional EEPROM memory.\nThe  demonstration  and  development  boards  can  be used in teaching environments, for prototyping custom circuits and for learning about various microcontroller applications.\nIn addition to the PICDEM\u2122 and dsPICDEM\u2122 demonstration/development board series of circuits, Microchip has a line of evaluation kits and demonstration software for  analog  filter  design,  KEELOQ \u00ae security  ICs,  CAN, IrDA \u00ae ,  PowerSmart  battery  management,  SEEVAL \u00ae evaluation system, Sigma-Delta ADC, flow rate sensing, plus many more.\nAlso available are starter kits that contain everything needed to experience the specified device. This usually includes a single application and debug capability, all on one board.\nCheck the Microchip web page (www.microchip.com) for  the  complete  list  of  demonstration,  development and evaluation kits.",
    "Absolute Maximum Ratings (\u2020)\nAmbient temperature under bias.............................................................................................................-55\u00b0C to +125\u00b0C",
    "Absolute Maximum Ratings (\u2020)\nStorage temperature .............................................................................................................................. -65\u00b0C to +150\u00b0C\nVoltage on any pin with respect to VSS (except VDD, MCLR, and RA4) ......................................... -0.3V to (VDD + 0.3V)",
    "Absolute Maximum Ratings (\u2020)\nVoltage on VDD with respect to VSS  .........................................................................................................  -0.3V to +7.5V\nVoltage on MCLR with respect to VSS (Note 2)\n......................................................................................... 0V to +13.25V",
    "Absolute Maximum Ratings (\u2020)\nVoltage on RA4 with respect to Vss............................................................................................................... 0V to +8.5V\nTotal power dissipation (Note 1)",
    "Absolute Maximum Ratings (\u2020)\n...............................................................................................................................1.0W",
    "Absolute Maximum Ratings (\u2020)\nMaximum current out of VSS pin ...........................................................................................................................300 mA",
    "Absolute Maximum Ratings (\u2020)\nMaximum current into VDD pin ..............................................................................................................................250 mA\nInput clamp current, IIK (VI < 0 or VI > VDD)\n\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e \uf0b1\n20 mA\nOutput clamp current, IOK (VO < 0 or VO > VDD)\n\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e \uf0b1\n20 mA",
    "Absolute Maximum Ratings (\u2020)\nMaximum output current sunk by any I/O pin..........................................................................................................25 mA\nMaximum output current sourced by any I/O pin ....................................................................................................25 mA",
    "Absolute Maximum Ratings (\u2020)\nMaximum current sunk by all ports .......................................................................................................................200 mA \uf020\nMaximum current sourced by all ports ..................................................................................................................200 mA",
    "Absolute Maximum Ratings (\u2020)\nNote 1: Power dissipation is calculated as follows:\nPdis = VDD x {IDD -\uf0e5 IOH} + \uf0e5 {(VDD - VOH) x IOH} + \uf0e5 (VOL x IOL)\n- 2: Voltage spikes below VSS at the MCLR/VPP pin, inducing currents greater than 80 mA, may cause latch-up. Thus, a series resistor of 50-100 \uf057 should be used when applying a 'low' level to the MCLR/VPP pin, rather than pulling this pin directly to VSS.\n\u2020 NOTICE: Stresses above those listed under 'Absolute Maximum Ratings' may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure to maximum rating conditions for extended periods may affect device reliability.",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nPIC18LF2331/2431/4331/4431\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18F2331/2431/4331/4431\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nD001, Symbol = VDD. D001, Characteristic = Supply Voltage. D001, Min = Supply Voltage. D001, Typ = Supply Voltage. D001, Max = Supply Voltage. D001, Units = Supply Voltage. D001, Conditions = Supply Voltage. , Symbol = . , Characteristic = PIC18LF2X31/4X31. , Min = 2.0. , Typ = -. , Max = 5.5. , Units = V. , Conditions = . , Symbol = . , Characteristic = PIC18F2X31/4X31. , Min = 4.2. , Typ = -. , Max = 5.5. , Units = V. , Conditions = . D001C, Symbol = AVDD. D001C, Characteristic = Analog Supply Voltage. D001C, Min = VDD - 0.3. D001C, Typ = -. D001C, Max = VDD",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\n+ 0.3. D001C, Units = V. D001C, Conditions = . D001D, Symbol = AVSS. D001D, Characteristic = Analog Ground Voltage. D001D, Min = VSS - 0.3. D001D, Typ = -. D001D, Max = VSS + 0.3. D001D, Units = V. D001D, Conditions = . D002, Symbol = VDR. D002, Characteristic = RAM Data Retention Voltage (1). D002, Min = 1.5. D002, Typ = -. D002, Max = -. D002, Units = V. D002, Conditions = . D003, Symbol = VPOR. D003, Characteristic = VDD Start Voltage to Ensure Internal Power-on Reset Signal. D003, Min = -. D003, Typ = -. D003,",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nMax = 0.7. D003, Units = V. D003, Conditions = See section on Power-on Reset for details. D004, Symbol = SVDD. D004, Characteristic = VDD Rise Rate to Ensure Internal Power-on Reset Signal. D004, Min = 0.05. D004, Typ = -. D004, Max = -. D004, Units = V/ms. D004, Conditions = See section on Power-on Reset for details. D005A, Symbol = VBOR. D005A, Characteristic = Brown-out Reset Voltage. D005A, Min = Brown-out Reset Voltage. D005A, Typ = Brown-out Reset Voltage. D005A, Max = Brown-out Reset Voltage. D005A, Units = Brown-out Reset Voltage. D005A, Conditions = Brown-out Reset Voltage. , Symbol = . , Characteristic =",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nPIC18LF2X31/4X31 BORV<1:0> = 11. , Min = Industrial N/A. , Typ = Low Voltage N/A. , Max = (-10 \uf0b0 N/A. , Units = C to +85 V. , Conditions = \uf0b0 C) Reserved. , Symbol = . , Characteristic = BORV<1:0> = 10. , Min = 2.50. , Typ = 2.72. , Max = 2.94. , Units = V. , Conditions = . , Symbol = . , Characteristic = BORV<1:0> = 01. , Min = 3.88. , Typ = 4.22. , Max = 4.56. , Units = V. , Conditions = . , Symbol = . , Characteristic = BORV<1:0> = 00. , Min = 4.18. , Typ = 4.54. , Max = 4.90. , Units = V. , Conditions = .",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nD005B, Symbol = . D005B, Characteristic = PIC18LF2X31/4X31 Industrial Low Voltage (-40 \uf0b0 C to -10 \uf0b0 C). D005B, Min = PIC18LF2X31/4X31 Industrial Low Voltage (-40 \uf0b0 C to -10 \uf0b0 C). D005B, Typ = PIC18LF2X31/4X31 Industrial Low Voltage (-40 \uf0b0 C to -10 \uf0b0 C). D005B, Max = PIC18LF2X31/4X31 Industrial Low Voltage (-40 \uf0b0 C to -10 \uf0b0 C). D005B, Units = PIC18LF2X31/4X31 Industrial Low Voltage (-40 \uf0b0 C to -10 \uf0b0 C). D005B, Conditions = PIC18LF2X31/4X31 Industrial Low Voltage (-40 \uf0b0 C to -10 \uf0b0 C). , Symbol = . , Characteristic = BORV<1:0> = 11. , Min =",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nN/A. , Typ = N/A. , Max = N/A. , Units = V. , Conditions = Reserved. , Symbol = . , Characteristic = BORV<1:0>= 10. , Min = 2.34. , Typ = 2.72. , Max = 3.10. , Units = V. , Conditions = . , Symbol = . , Characteristic = BORV<1:0> = 01. , Min = 3.63. , Typ = 4.22. , Max = 4.81. , Units = V. , Conditions = . , Symbol = . , Characteristic = BORV<1:0> = 00. , Min = 3.90. , Typ = 4.54. , Max = 5.18. , Units = V. , Conditions = . D005C, Symbol = . D005C, Characteristic = PIC18F2X31/4X31 Industrial (-10 \uf0b0 C to +85 \uf0b0 C).",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nD005C, Min = PIC18F2X31/4X31 Industrial (-10 \uf0b0 C to +85 \uf0b0 C). D005C, Typ = PIC18F2X31/4X31 Industrial (-10 \uf0b0 C to +85 \uf0b0 C). D005C, Max = PIC18F2X31/4X31 Industrial (-10 \uf0b0 C to +85 \uf0b0 C). D005C, Units = PIC18F2X31/4X31 Industrial (-10 \uf0b0 C to +85 \uf0b0 C). D005C, Conditions = PIC18F2X31/4X31 Industrial (-10 \uf0b0 C to +85 \uf0b0 C). , Symbol = . , Characteristic = BORV<1:0>= 1x. , Min = N/A. , Typ = N/A. , Max = N/A. , Units = V. , Conditions = Reserved. , Symbol = . , Characteristic = BORV<1:0> = 01. , Min",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\n= 3.88. , Typ = 4.22. , Max = 4.56. , Units = V. , Conditions = (Note 2). , Symbol = . , Characteristic = BORV<1:0> = 00. , Min = 4.18. , Typ = 4.54. , Max = 4.90. , Units = V. , Conditions = (Note 2). D005D, Symbol = . D005D, Characteristic = PIC18F2X31/4X31 Industrial (-40 \uf0b0 C to -10 \uf0b0 C). D005D, Min = PIC18F2X31/4X31 Industrial (-40 \uf0b0 C to -10 \uf0b0 C). D005D, Typ = PIC18F2X31/4X31 Industrial (-40 \uf0b0 C to -10 \uf0b0 C). D005D, Max = PIC18F2X31/4X31 Industrial (-40 \uf0b0 C to -10 \uf0b0 C). D005D,",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nUnits = PIC18F2X31/4X31 Industrial (-40 \uf0b0 C to -10 \uf0b0 C). D005D, Conditions = PIC18F2X31/4X31 Industrial (-40 \uf0b0 C to -10 \uf0b0 C). , Symbol = . , Characteristic = BORV<1:0>= 1x. , Min = N/A. , Typ = N/A. , Max = N/A. , Units = V. , Conditions = Reserved. , Symbol = . , Characteristic = BORV<1:0> = 01. , Min = N/A. , Typ = N/A. , Max = N/A. , Units = V. , Conditions = Reserved. , Symbol = . , Characteristic = BORV<1:0> = 00. , Min = 3.90. , Typ = 4.54. , Max = 5.18. , Units = V. , Conditions = (Note 2). D005E, Symbol =",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\n. D005E, Characteristic = PIC18F2X31/4X31 Extended (-10 \uf0b0 C to +85 \uf0b0 C). D005E, Min = PIC18F2X31/4X31 Extended (-10 \uf0b0 C to +85 \uf0b0 C). D005E, Typ = PIC18F2X31/4X31 Extended (-10 \uf0b0 C to +85 \uf0b0 C). D005E, Max = PIC18F2X31/4X31 Extended (-10 \uf0b0 C to +85 \uf0b0 C). D005E, Units = PIC18F2X31/4X31 Extended (-10 \uf0b0 C to +85 \uf0b0 C). D005E, Conditions = PIC18F2X31/4X31 Extended (-10 \uf0b0 C to +85 \uf0b0 C). , Symbol = . , Characteristic = BORV<1:0> = 1x. , Min = N/A. , Typ = N/A. , Max = N/A. ,",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nUnits = V. , Conditions = Reserved. , Symbol = . , Characteristic = BORV<1:0> = 01. , Min = 3.88. , Typ = 4.22. , Max = 4.56. , Units = V. , Conditions = (Note 2). , Symbol = . , Characteristic = BORV<1:0> = 00. , Min = 4.18. , Typ = 4.54. , Max = 4.90. , Units = V. , Conditions = (Note 2). D005F, Symbol = . D005F, Characteristic = PIC18F2X31/4X31 Extended (-40 \uf0b0 C to -10 \uf0b0 C, +85 \uf0b0 C to +125 \uf0b0 C). D005F, Min = PIC18F2X31/4X31 Extended (-40 \uf0b0 C to -10 \uf0b0 C, +85 \uf0b0 C to +125 \uf0b0 C). D005F, Typ =",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nPIC18F2X31/4X31 Extended (-40 \uf0b0 C to -10 \uf0b0 C, +85 \uf0b0 C to +125 \uf0b0 C). D005F, Max = PIC18F2X31/4X31 Extended (-40 \uf0b0 C to -10 \uf0b0 C, +85 \uf0b0 C to +125 \uf0b0 C). D005F, Units = PIC18F2X31/4X31 Extended (-40 \uf0b0 C to -10 \uf0b0 C, +85 \uf0b0 C to +125 \uf0b0 C). D005F, Conditions = PIC18F2X31/4X31 Extended (-40 \uf0b0 C to -10 \uf0b0 C, +85 \uf0b0 C to +125 \uf0b0 C). , Symbol = . , Characteristic = BORV<1:0> = 1x. , Min = N/A. , Typ = N/A. , Max = N/A. , Units = V. , Conditions = Reserved. , Symbol = . , Characteristic = BORV<1:0> = 01. , Min =",
    "26.1 DC Characteristics: Supply Voltage PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nN/A. , Typ = N/A. , Max = N/A. , Units = V. , Conditions = Reserved. , Symbol = . , Characteristic = BORV<1:0> = 00. , Min = 3.90. , Typ = 4.54. , Max = 5.18. , Units = V. , Conditions = (Note 2)\nLegend: Shading of rows is to assist in readability of the table.\nNote 1: This is the limit to which VDD can be lowered in Sleep mode, or during a device Reset, without losing RAM data.\n2: When BOR is on and BORV<1:0> = 0x , the device will operate correctly at 40 MHz for any VDD at which the BOR allows execution.",
    "PIC18F2331/2431/4331/4431\n26.2 DC Characteristics: Power-Down and Supply Current PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nPIC18LF2331/2431/4331/4431\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18F2331/2431/4331/4431\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F2331/2431/4331/4431\n, Device = Power-Down Current (I PD ) (1). , Typ = Power-Down Current (I PD ) (1). , Max = Power-Down Current (I PD ) (1). , Units = Power-Down Current (I PD ) (1). , Conditions = Power-Down Current (I PD ) (1). , Conditions = Power-Down Current (I PD ) (1). , Device = PIC18LF2X31/4X31. , Typ = 0.1. , Max = 0.5. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V ( Sleep mode). , Device = PIC18LF2X31/4X31. , Typ = 0.1. , Max = 0.5. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V ( Sleep mode). , Device = PIC18LF2X31/4X31. , Typ = 0.2. , Max = 1.9. , Units = \uf06d A. , Conditions =",
    "PIC18F2331/2431/4331/4431\n+85\u00b0C. , Conditions = VDD = 2.0V ( Sleep mode). , Device = PIC18LF2X31/4X31. , Typ = 0.1. , Max = 0.5. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V ( Sleep mode). , Device = PIC18LF2X31/4X31. , Typ = 0.1. , Max = 0.5. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V ( Sleep mode). , Device = PIC18LF2X31/4X31. , Typ = 0.3. , Max = 1.9. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V ( Sleep mode). , Device = All devices. , Typ = 0.1. , Max = 2.0. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V ( Sleep mode). , Device",
    "PIC18F2331/2431/4331/4431\n= All devices. , Typ = 0.1. , Max = 2.0. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V ( Sleep mode). , Device = All devices. , Typ = 0.4. , Max = 6.5. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V ( Sleep mode). , Device = All devices. , Typ = 5. , Max = 33. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V ( Sleep mode)\nLegend: Shading of rows is to assist in readability of the table.",
    "PIC18F2331/2431/4331/4431\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "PIC18F2331/2431/4331/4431\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula: Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard, low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nPIC18LF2331/2431/4331/4431\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\nPIC18F2331/2431/4331/4431\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3\n+85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\n, Device = Supply Current (I DD) (2,3). , Typ = . , Max = . , Units = . , Conditions = . , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 8. , Max = 40. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 9. , Max = 40. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 11. , Max = 40. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 25. , Max = 68. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device =",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nPIC18LF2X31/4X31. , Typ = 25. , Max = 68. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 20. , Max = 68. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 55. , Max = 180. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = All devices. , Typ = 55. , Max = 180. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = All devices. , Typ = 50. , Max = 180. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 0.25. , Max = 1. , Units = mA. , Conditions = +125\u00b0C. , Conditions",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\n= . , Device = PIC18LF2X31/4X31. , Typ = 140. , Max = 220. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 145. , Max = 220. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 155. , Max = 220. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 215. , Max = 330. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 225. , Max = 330. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device =",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nPIC18LF2X31/4X31. , Typ = 235. , Max = 330. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 385. , Max = 550. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = All devices. , Typ = 390. , Max = 550. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = All devices. , Typ = 405. , Max = 550. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 0.7. , Max = 2.8. , Units = mA. , Conditions = +125\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 410. , Max = 600. , Units = \uf06d A. , Conditions = -40\u00b0C.",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\n, Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 425. , Max = 600. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 435. , Max = 600. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 650. , Max = 900. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 670. , Max = 900. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 680. , Max = 900. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device =",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nAll devices. , Typ = 1.2. , Max = 1.8. , Units = mA. , Conditions = -40\u00b0C. , Conditions = . , Device = All devices. , Typ = 1.2. , Max = 1.8. , Units = mA. , Conditions = +25\u00b0C. , Conditions = . , Device = All devices. , Typ = 1.2. , Max = 1.8. , Units = mA. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 2.2. , Max = 6. , Units = mA. , Conditions = +125\u00b0C. , Conditions = ",
    "Legend:\nShading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend:\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula: Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard, low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F2331/2431/4331/4431\n26.2 DC Characteristics: Power-Down and Supply Current PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nPIC18LF2331/2431/4331/4431\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18F2331/2431/4331/4431\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F2331/2431/4331/4431\n, Device = Supply Current (I DD) (2,3). , Typ = . , Max = . , Units = . , Conditions = . , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 4.7. , Max = 8. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 5.0. , Max = 8. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 5.8. , Max = 11. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 7.0. , Max = 11. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 7.8. , Max = 11. , Units = \uf06d",
    "PIC18F2331/2431/4331/4431\nA. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 8.7. , Max = 15. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 12. , Max = 16. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = All devices. , Typ = 14. , Max = 16. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = All devices. , Typ = 14. , Max = 22. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 200. , Max = 850. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 75. , Max = 150. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device =",
    "PIC18F2331/2431/4331/4431\nPIC18LF2X31/4X31. , Typ = 85. , Max = 150. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 95. , Max = 150. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 110. , Max = 180. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 125. , Max = 180. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 135. , Max = 180. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 180. , Max = 300. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . ,",
    "PIC18F2331/2431/4331/4431\nDevice = All devices. , Typ = 195. , Max = 300. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = All devices. , Typ = 200. , Max = 300. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 300. , Max = 750. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 175. , Max = 275. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 185. , Max = 275. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 195. , Max = 275. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. ,",
    "PIC18F2331/2431/4331/4431\nTyp = 265. , Max = 375. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 280. , Max = 375. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 300. , Max = 375. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 475. , Max = 800. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = . , Device = All devices. , Typ = 500. , Max = 800. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = . , Device = All devices. , Typ = 505. , Max = 800. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = . , Device = All devices. , Typ = 0.7. , Max = 1.6. , Units = mA. , Conditions =",
    "PIC18F2331/2431/4331/4431\n+125\u00b0C. , Conditions = ",
    "Legend: Note\nShading of rows is to assist in readability of the table.\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend: Note\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula: Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard, low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nPIC18LF2331/2431/4331/4431\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\nPIC18F2331/2431/4331/4431\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3\n+85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\n, Device = Supply Current (I DD) (2,3). , Typ = . , Max = . , Units = . , Conditions = . , Conditions = . , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 150. , Max = 250. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 150. , Max = 250. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 160. , Max = 250. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ =",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\n340. , Max = 350. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHZ. , Device = PIC18LF2X31/4X31. , Typ = 300. , Max = 350. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHZ. , Device = PIC18LF2X31/4X31. , Typ = 280. , Max = 350. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = ( PRI_RUN. , Device = All devices. , Typ = 0.72. , Max = 1.0. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\ndevices. , Typ = 0.63. , Max = 1.0. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ = 0.57. , Max = 1.0. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ = 0.9. , Max = 2.1. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = PIC18LF2X31/4X31. , Typ = 440. , Max = 600. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device =",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nPIC18LF2X31/4X31. , Typ = 450. , Max = 600. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 460. , Max = 600. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 0.80. , Max = 1.0. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz. , Device = PIC18LF2X31/4X31. , Typ = 0.78. , Max = 1.0. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD =",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\n3.0V. , Conditions = ( PRI_RUN. , Device = PIC18LF2X31/4X31. , Typ = 0.77. , Max = 1.0. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz. , Device = All devices. , Typ = 1.6. , Max = 2.0. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ = 1.5. , Max = 2.0. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ = 1.5. , Max = 2.0. , Units = mA. , Conditions =",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\n+85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ = 2.0. , Max = 4.2. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ = 10. , Max = 28. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 25 MHz ( PRI_RUN , EC oscillator). , Device = All devices. , Typ = 9.5. , Max = 12. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 40 MHZ ( PRI_RUN ,. , Device = All devices. , Typ = 9.7. , Max",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\n= 12. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 40 MHZ ( PRI_RUN ,. , Device = All devices. , Typ = 9.9. , Max = 12. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 40 MHZ ( PRI_RUN ,. , Device = All devices. , Typ = 11.9. , Max = 15. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ = 12.1. , Max = 15. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ =",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\n12.3. , Max = 15. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator)\nLegend:\nShading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula: Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard, low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F2331/2431/4331/4431\n26.2 DC Characteristics: Power-Down and Supply Current PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nPIC18LF2331/2431/4331/4431\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18F2331/2431/4331/4431\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F2331/2431/4331/4431\nSupply, Device = Current (I DD) (2,3). Supply, Typ = . Supply, Max = . Supply, Units = . Supply, Conditions = . Supply, Conditions = . Supply, Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 35. , Max = 50. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 35. , Max = 50. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 35. , Max = 60. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 55. , Max = 80. , Units = \uf06d A. , Conditions =",
    "PIC18F2331/2431/4331/4431\n-40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHz. , Device = PIC18LF2X31/4X31. , Typ = 50. , Max = 80. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHz. , Device = PIC18LF2X31/4X31. , Typ = 60. , Max = 100. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = PRI_IDLE. , Device = All devices. , Typ = 105. , Max = 150. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ = 110. , Max = 150. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC",
    "PIC18F2331/2431/4331/4431\noscillator). , Device = All devices. , Typ = 115. , Max = 150. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ = 300. , Max = 400. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = PIC18LF2X31/4X31. , Typ = 135. , Max = 180. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 140. , Max = 180. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 140. , Max = 180. , Units = \uf06d",
    "PIC18F2331/2431/4331/4431\nA. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 215. , Max = 280. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz. , Device = PIC18LF2X31/4X31. , Typ = 225. , Max = 280. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz. , Device = PIC18LF2X31/4X31. , Typ = 230. , Max = 280. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = PRI_IDLE. , Device = All devices. , Typ = 410. , Max = 525. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions",
    "PIC18F2331/2431/4331/4431\n= EC oscillator). , Device = All devices. , Typ = 420. , Max = 525. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ = 430. , Max = 525. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ = 1.2. , Max = 1.7. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = EC oscillator). , Device = All devices. , Typ = 18. , Max = 22. , Units = mA. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 25 MHz ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ = 3.2.",
    "PIC18F2331/2431/4331/4431\n, Max = 4.1. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 4.2 V. , Conditions = FOSC = 40 MHz. , Device = All devices. , Typ = 3.2. , Max = 4.1. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 4.2 V. , Conditions = FOSC = 40 MHz. , Device = All devices. , Typ = 3.3. , Max = 4.1. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 4.2 V. , Conditions = FOSC = 40 MHz. , Device = All devices. , Typ = 4.0. , Max = 5.1. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ = 4.1. , Max = 5.1. , Units = mA. , Conditions =",
    "PIC18F2331/2431/4331/4431\n+25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = ( PRI_IDLE mode, EC oscillator). , Device = All devices. , Typ = 4.1. , Max = 5.1. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = ( PRI_IDLE mode, EC oscillator)\nLegend:\nShading of rows is to assist in readability of the table.\nNote",
    "PIC18F2331/2431/4331/4431\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "PIC18F2331/2431/4331/4431\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula: Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard, low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nPIC18LF2331/2431/4331/4431\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\nPIC18F2331/2431/4331/4431\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3\n+85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nSupply, Device = Current (I DD) (2,3). Supply, Typ = . Supply, Max = . Supply, Units = . Supply, Conditions = . Supply, Conditions = . Supply, Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 5.1. , Max = 9. , Units = \uf06d A. , Conditions = -10\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 5.8. , Max = 9. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 7.9. , Max = 11. , Units = \uf06d A. , Conditions = +70\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device =",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nPIC18LF2X31/4X31. , Typ = 7.9. , Max = 12. , Units = \uf06d A. , Conditions = -10\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 8.9. , Max = 12. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 10.5. , Max = 14. , Units = \uf06d A. , Conditions = +70\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = All devices. , Typ = 12.5. , Max = 20. , Units = \uf06d A. , Conditions = -10\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. ,",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nTyp = 16.3. , Max = 20. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 18.9. , Max = 25. , Units = \uf06d A. , Conditions = +70\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 150. , Max = 850. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 9.2. , Max = 15. , Units = \uf06d A. , Conditions = -10\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 9.6. , Max = 15. , Units = \uf06d",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nA. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 12.7. , Max = 18. , Units = \uf06d A. , Conditions = +70\u00b0C. , Conditions = VDD = 2.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 22.0. , Max = 30. , Units = \uf06d A. , Conditions = -10\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 21.0. , Max = 30. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = PIC18LF2X31/4X31. , Typ = 20.0. , Max = 35.",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\n, Units = \uf06d A. , Conditions = +70\u00b0C. , Conditions = VDD = 3.0V. , Conditions = . , Device = All devices. , Typ = 30. , Max = 80. , Units = \uf06d A. , Conditions = -10\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 45. , Max = 80. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 45. , Max = 85. , Units = \uf06d A. , Conditions = +70\u00b0C. , Conditions = VDD = 5.0V. , Conditions = . , Device = All devices. , Typ = 250. , Max = 850. , Units = \uf06d A. , Conditions = +125\u00b0C. , Conditions = VDD = 5.0V. , Conditions = ",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nLegend: Shading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula: Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard, low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "PIC18F2331/2431/4331/4431\n26.2 DC Characteristics: Power-Down and Supply Current PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nPIC18LF2331/2431/4331/4431\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18F2331/2431/4331/4431\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F2331/2431/4331/4431\n, Device = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). , Typ = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). , Max = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). , Units = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). , Conditions = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). , Conditions = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). , Conditions = Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD). D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 1.5. D022 ( \uf044 I WDT), Max = 4.0. D022 ( \uf044 I",
    "PIC18F2331/2431/4331/4431\nWDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = -40\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 2.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 2.2. D022 ( \uf044 I WDT), Max = 4.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +25\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 2.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 3.1. D022 ( \uf044 I WDT), Max = 5.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +85\u00b0C. D022 ( \uf044 I",
    "PIC18F2331/2431/4331/4431\nWDT), Conditions = VDD = 2.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 2.5. D022 ( \uf044 I WDT), Max = 6.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = -40\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 3.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 3.3. D022 ( \uf044 I WDT), Max = 6.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +25\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 3.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044",
    "PIC18F2331/2431/4331/4431\nI WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 4.7. D022 ( \uf044 I WDT), Max = 7.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +85\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 3.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 3.7. D022 ( \uf044 I WDT), Max = 10.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = -40\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 5.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 4.5. D022",
    "PIC18F2331/2431/4331/4431\n( \uf044 I WDT), Max = 10.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +25\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 5.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 6.1. D022 ( \uf044 I WDT), Max = 13.0. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT), Conditions = +85\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 5.0V. D022 ( \uf044 I WDT), Conditions = . D022 ( \uf044 I WDT), Device = Watchdog Timer. D022 ( \uf044 I WDT), Typ = 22. D022 ( \uf044 I WDT), Max = 44. D022 ( \uf044 I WDT), Units = \uf06d A. D022 ( \uf044 I WDT),",
    "PIC18F2331/2431/4331/4431\nConditions = +125\u00b0C. D022 ( \uf044 I WDT), Conditions = VDD = 5.0V. D022 ( \uf044 I WDT), Conditions = . D022A ( \uf044 I BOR), Device = Brown-out Reset. D022A ( \uf044 I BOR), Typ = 19. D022A ( \uf044 I BOR), Max = 35.0. D022A ( \uf044 I BOR), Units = \uf06d A. D022A ( \uf044 I BOR), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022A ( \uf044 I BOR), Conditions = VDD = 3.0V. D022A ( \uf044 I BOR), Conditions = . D022A ( \uf044 I BOR), Device = Brown-out Reset. D022A ( \uf044 I BOR), Typ = 24. D022A ( \uf044 I BOR), Max = 45.0. D022A ( \uf044 I BOR), Units = \uf06d A. D022A ( \uf044 I BOR), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022A ( \uf044 I",
    "PIC18F2331/2431/4331/4431\nBOR), Conditions = VDD = 5.0V. D022A ( \uf044 I BOR), Conditions = . D022A ( \uf044 I BOR), Device = Brown-out Reset. D022A ( \uf044 I BOR), Typ = 40. D022A ( \uf044 I BOR), Max = 75. D022A ( \uf044 I BOR), Units = \uf06d A. D022A ( \uf044 I BOR), Conditions = +125\u00b0C. D022A ( \uf044 I BOR), Conditions = VDD = 5.0V. D022A ( \uf044 I BOR), Conditions = . D022B ( \uf044 I LVD ), Device = Low-Voltage Detect. D022B ( \uf044 I LVD ), Typ = 8.5. D022B ( \uf044 I LVD ), Max = 25.0. D022B ( \uf044 I LVD ), Units = \uf06d A. D022B ( \uf044 I LVD ), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022B ( \uf044 I LVD ), Conditions = VDD = 2.0V VDD",
    "PIC18F2331/2431/4331/4431\n= 3.0V. D022B ( \uf044 I LVD ), Conditions = . D022B ( \uf044 I LVD ), Device = Low-Voltage Detect. D022B ( \uf044 I LVD ), Typ = 16. D022B ( \uf044 I LVD ), Max = 35.0. D022B ( \uf044 I LVD ), Units = \uf06d A. D022B ( \uf044 I LVD ), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022B ( \uf044 I LVD ), Conditions = . D022B ( \uf044 I LVD ), Conditions = . D022B ( \uf044 I LVD ), Device = Low-Voltage Detect. D022B ( \uf044 I LVD ), Typ = 20. D022B ( \uf044 I LVD ), Max = 45.0. D022B ( \uf044 I LVD ), Units = \uf06d A. D022B ( \uf044 I LVD ), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D022B ( \uf044 I LVD ), Conditions = VDD = 5.0V. D022B ( \uf044 I LVD ), Conditions = .",
    "PIC18F2331/2431/4331/4431\nD022B ( \uf044 I LVD ), Device = Low-Voltage Detect. D022B ( \uf044 I LVD ), Typ = 35. D022B ( \uf044 I LVD ), Max = 66. D022B ( \uf044 I LVD ), Units = \uf06d A. D022B ( \uf044 I LVD ), Conditions = +125\u00b0C. D022B ( \uf044 I LVD ), Conditions = VDD = 5.0V. D022B ( \uf044 I LVD ), Conditions = . D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 1.7. D025 ( \uf044 I OSCB), Max = 3.5. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = -40 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 2.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1",
    "PIC18F2331/2431/4331/4431\nOscillator. D025 ( \uf044 I OSCB), Typ = 1.8. D025 ( \uf044 I OSCB), Max = 3.5. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +25\u00b0C. D025 ( \uf044 I OSCB), Conditions = VDD = 2.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 2.1. D025 ( \uf044 I OSCB), Max = 4.5. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +85\u00b0C. D025 ( \uf044 I OSCB), Conditions = VDD = 2.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025",
    "PIC18F2331/2431/4331/4431\n( \uf044 I OSCB), Typ = 2.2. D025 ( \uf044 I OSCB), Max = 4.5. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = -40 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 3.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 2.6. D025 ( \uf044 I OSCB), Max = 4.5. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +25\u00b0C. D025 ( \uf044 I OSCB), Conditions = VDD = 3.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ =",
    "PIC18F2331/2431/4331/4431\n2.8. D025 ( \uf044 I OSCB), Max = 5.5. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +85\u00b0C. D025 ( \uf044 I OSCB), Conditions = VDD = 3.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 3.0. D025 ( \uf044 I OSCB), Max = 6.0. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = -40 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions = VDD = 5.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 3.3. D025 ( \uf044 I",
    "PIC18F2331/2431/4331/4431\nOSCB), Max = 6.0. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +25\u00b0C. D025 ( \uf044 I OSCB), Conditions = VDD = 5.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 3.6. D025 ( \uf044 I OSCB), Max = 7.0. D025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +85\u00b0C. D025 ( \uf044 I OSCB), Conditions = VDD = 5.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D025 ( \uf044 I OSCB), Device = Timer1 Oscillator. D025 ( \uf044 I OSCB), Typ = 42. D025 ( \uf044 I OSCB), Max = 70.",
    "PIC18F2331/2431/4331/4431\nD025 ( \uf044 I OSCB), Units = \uf06d A. D025 ( \uf044 I OSCB), Conditions = +125\u00b0C. D025 ( \uf044 I OSCB), Conditions = VDD = 5.0V. D025 ( \uf044 I OSCB), Conditions = 32 kHz on Timer1 (4). D026 ( \uf044 I AD), Device = A/D Converter. D026 ( \uf044 I AD), Typ = 1.0. D026 ( \uf044 I AD), Max = 3.0. D026 ( \uf044 I AD), Units = \uf06d A. D026 ( \uf044 I AD), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D026 ( \uf044 I AD), Conditions = VDD = 2.0V. D026 ( \uf044 I AD), Conditions = . D026 ( \uf044 I AD), Device = A/D Converter. D026 ( \uf044 I AD), Typ = 1.0. D026 ( \uf044 I AD), Max = 4.0. D026 ( \uf044 I AD), Units = \uf06d A. D026 ( \uf044 I AD), Conditions = -40 \uf0b0 C",
    "PIC18F2331/2431/4331/4431\nto +85 \uf0b0 C. D026 ( \uf044 I AD), Conditions = VDD = 3.0V. D026 ( \uf044 I AD), Conditions = . D026 ( \uf044 I AD), Device = A/D Converter. D026 ( \uf044 I AD), Typ = 2.0. D026 ( \uf044 I AD), Max = 10.0. D026 ( \uf044 I AD), Units = \uf06d A. D026 ( \uf044 I AD), Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D026 ( \uf044 I AD), Conditions = VDD = 5.0V. D026 ( \uf044 I AD), Conditions = . D026 ( \uf044 I AD), Device = A/D Converter. D026 ( \uf044 I AD), Typ = 150. D026 ( \uf044 I AD), Max = 950. D026 ( \uf044 I AD), Units = \uf06d A. D026 ( \uf044 I AD), Conditions = +125\u00b0C. D026 ( \uf044 I AD), Conditions = VDD = 5.0V. D026 ( \uf044 I AD), Conditions = ",
    "Legend:\nShading of rows is to assist in readability of the table.\nNote\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS, and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.",
    "Legend:\n3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula: Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n4: Standard, low-cost 32 kHz crystals have an operating temperature range of -10\u00b0C to +70\u00b0C. Extended temperature crystals are available at a much higher cost.",
    "26.3 DC Characteristics: PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nDC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3\uf020 TA \uf0a3 +125\u00b0C for extended",
    "26.3 DC Characteristics: PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nD030, Symbol = VIL. D030, Characteristic = Input Low Voltage I/O Ports: with TTL Buffer. D030, Min = VSS - VSS VSS VSS VSS. D030, Max = 0.15 VDD 0.8 0.2 VDD 0.3 VDD 0.2 VDD 0.3 VDD 0.2 VDD. D030, Units = V V V V V V V. D030, Conditions = VDD < 4.5V 4.5V \uf0a3 VDD \uf0a3\uf020 5.5V I 2 C\u2122enabled LP, XT, HS, HSPLL modes (1) EC mode (1). D032 D032A D033 D040, Symbol = VIH. D032 D032A D033 D040, Characteristic = MCLR OSC1 and T1OSI OSC1 Input High Voltage I/O Ports: with TTL Buffer. D032",
    "26.3 DC Characteristics: PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nD032A D033 D040, Min = VSS 0.25 VDD + 0.8V. D032 D032A D033 D040, Max = VDD. D032 D032A D033 D040, Units = . D032 D032A D033 D040, Conditions = VDD < 4.5V 4.5V \uf0a3 VDD \uf0a3\uf020 5.5V. D040A D041 D042, Symbol = . D040A D041 D042, Characteristic = with Schmitt Trigger Buffer RC3 and RC4 MCLR OSC1 and T1OSI. D040A D041 D042, Min = 2.0 0.8 VDD 0.7 VDD 0.8 VDD. D040A D041 D042, Max = VDD VDD VDD VDD. D040A D041 D042, Units = V V V",
    "26.3 DC Characteristics: PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nV V. D040A D041 D042, Conditions = I 2 C\u2122enabled. D042A D043, Symbol = I IL. D042A D043, Characteristic = OSC1 Input Leakage Current (2,3) I/O Ports. D042A D043, Min = 0.7 VDD 0.8 VDD. D042A D043, Max = VDD VDD +200 nA. D042A D043, Units = V V \uf06d A. D042A D043, Conditions = LP, XT, HS, HSPLL modes (1) EC mode (1). D060, Symbol = . D060, Characteristic = . D060, Min = - -. D060, Max = +50 nA. D060, Units = . D060, Conditions = VDD < 5.5V, VSS \uf0a3\uf020 VPIN \uf0a3\uf020 VDD, Pin at high-impedance.",
    "26.3 DC Characteristics: PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\nD061, Symbol = . D061, Characteristic = . D061, Min = - -. D061, Max = \uf0b1 1 \uf0b1 1. D061, Units = . D061, Conditions = VDD < 3V, VSS \uf0a3\uf020 VPIN \uf0a3\uf020 VDD, Pin at high-impedance. , Symbol = . , Characteristic = MCLR. , Min = . , Max = . , Units = \uf06d A. , Conditions = Vss \uf0a3\uf020 VPIN \uf0a3\uf020 VDD. D063, Symbol = I PU. D063, Characteristic = OSC1 Weak Pull-up Current. D063, Min = . D063, Max = . D063, Units = \uf06d A. D063, Conditions = Vss \uf0a3\uf020 VPIN \uf0a3\uf020 VDD. D070, Symbol = I PURB. D070, Characteristic = PORTB Weak Pull-up Current. D070, Min = 50. D070, Max = . D070, Units =",
    "26.3 DC Characteristics: PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial)\n. D070, Conditions = . , Symbol = . , Characteristic = . , Min = . , Max = 400. , Units = \uf06d A. , Conditions = VDD = 5V, VPIN = VSS\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PIC \u00ae  device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.",
    "26.3 DC Characteristics: PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nDC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3\uf020 TA \uf0a3 +125\u00b0C for extended",
    "26.3 DC Characteristics: PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nD080, Symbol = VOL. D080, Characteristic = Output Low Voltage I/O Ports. D080, Min = -. D080, Max = 0.6. D080, Units = V. D080, Conditions = I OL = 8.5 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D083, Symbol = . D083, Characteristic = OSC2/CLKO (RC, RCIO, EC, ECIO modes). D083, Min = -. D083, Max = 0.6. D083, Units = V. D083, Conditions = I OL = 1.6 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D090, Symbol = VOH. D090, Characteristic = Output High Voltage (3) I/O Ports. D090, Min = VDD - 0.7.",
    "26.3 DC Characteristics: PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nD090, Max = -. D090, Units = V. D090, Conditions = I OH = -3.0 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D092, Symbol = . D092, Characteristic = OSC2/CLKO (RC, RCIO, EC, ECIO modes). D092, Min = VDD - 0.7. D092, Max = -. D092, Units = V. D092, Conditions = I OH = -1.3 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D100, Symbol = COSC2. D100, Characteristic = Capacitive Loading Specs on Output Pins OSC2 Pin. D100, Min = -. D100, Max = 15. D100, Units = pF. D100, Conditions = In XT, HS and LP modes when external clock",
    "26.3 DC Characteristics: PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nis used to drive OSC1. D101, Symbol = CIO. D101, Characteristic = All I/O Pins and OSC2 (in RC mode). D101, Min = -. D101, Max = 50. D101, Units = pF. D101, Conditions = To meet the AC Timing Specifications. D102, Symbol = CB. D102, Characteristic = SCL, SDA. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = I 2 C\u2122Specification",
    "26.3 DC Characteristics: PIC18F2331/2431/4331/4431 (Industrial, Extended) PIC18LF2331/2431/4331/4431 (Industrial) (Continued)\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PIC \u00ae  device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.",
    "DC CHARACTERISTICS\nOperating temperature -40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3\uf020 TA \uf0a3 +125\u00b0C for extended",
    "DC CHARACTERISTICS\n, Sym = . , Characteristic = Internal Program Memory Programming Specifications (1). , Min = . , Typ\u2020 = . , Max = . , Units = . , Conditions = . D110, Sym = VPP. D110, Characteristic = Voltage on MCLR/VPP pin. D110, Min = 9.00. D110, Typ\u2020 = -. D110, Max = 13.25. D110, Units = V. D110, Conditions = (Note 3). D112, Sym = I PP. D112, Characteristic = Current into MCLR/VPP pin. D112, Min = -. D112, Typ\u2020 = -. D112, Max = 300. D112, Units = \uf06d A. D112, Conditions = . D113, Sym = I DDP. D113, Characteristic = Supply Current during Programming. D113, Min = -. D113, Typ\u2020 = -. D113, Max = 1. D113, Units = mA. D113, Conditions = . , Sym = . , Characteristic = Data EEPROM",
    "DC CHARACTERISTICS\nMemory. , Min = . , Typ\u2020 = . , Max = . , Units = . , Conditions = . D120, Sym = ED. D120, Characteristic = Byte Endurance. D120, Min = 100K. D120, Typ\u2020 = 1M. D120, Max = -. D120, Units = E/W. D120, Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D121, Sym = VDRW. D121, Characteristic = VDD for Read/Write. D121, Min = VMIN. D121, Typ\u2020 = -. D121, Max = 5.5. D121, Units = V. D121, Conditions = Using EECON to read/write VMIN = Minimum operating voltage. D122, Sym = TDEW. D122, Characteristic = Erase/Write Cycle Time. D122, Min = -. D122, Typ\u2020 = 4. D122, Max = -. D122, Units = ms. D122, Conditions = . D123, Sym = TRETD. D123, Characteristic",
    "DC CHARACTERISTICS\n= Characteristic Retention. D123, Min = 40. D123, Typ\u2020 = -. D123, Max = -. D123, Units = Year. D123, Conditions = Provided no other specifications are violated. D124, Sym = TREF. D124, Characteristic = Number of Total Erase/Write Cycles before Refresh (2). D124, Min = 1M. D124, Typ\u2020 = 10M. D124, Max = -. D124, Units = E/W. D124, Conditions = -40\u00b0C to +85\u00b0C. , Sym = . , Characteristic = Program Flash Memory. , Min = . , Typ\u2020 = . , Max = . , Units = . , Conditions = . D130, Sym = EP. D130, Characteristic = Cell Endurance. D130, Min = 10K. D130, Typ\u2020 = 100K. D130, Max = -. D130, Units = E/W. D130, Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D131, Sym = VPR. D131, Characteristic",
    "DC CHARACTERISTICS\n= VDD for Read. D131, Min = VMIN. D131, Typ\u2020 = -. D131, Max = 5.5. D131, Units = V. D131, Conditions = VMIN = Minimum operating voltage. D132, Sym = VIE. D132, Characteristic = VDD for Block Erase. D132, Min = 4.5. D132, Typ\u2020 = -. D132, Max = 5.5. D132, Units = V. D132, Conditions = Using ICSP\u2122 port. D132A, Sym = VIW. D132A, Characteristic = VDD for Externally Timed Erase or Write. D132A, Min = 4.5. D132A, Typ\u2020 = -. D132A, Max = 5.5. D132A, Units = V. D132A, Conditions = Using ICSP port. D132B, Sym = VPEW. D132B, Characteristic = VDD for Self-Timed Write. D132B, Min = VMIN. D132B, Typ\u2020 =",
    "DC CHARACTERISTICS\n-. D132B, Max = 5.5. D132B, Units = V. D132B, Conditions = VMIN = Minimum operating voltage. D133, Sym = TIE. D133, Characteristic = ICSP\u2122 Block Erase Cycle Time. D133, Min = -. D133, Typ\u2020 = 4. D133, Max = -. D133, Units = ms. D133, Conditions = VDD > 4.5V. D133A, Sym = TIW. D133A, Characteristic = ICSP Erase or Write Cycle Time (externally timed). D133A, Min = 1. D133A, Typ\u2020 = -. D133A, Max = -. D133A, Units = ms. D133A, Conditions = VDD > 4.5V. D133A, Sym = TIW. D133A, Characteristic = Self-Timed Write Cycle Time. D133A, Min = -. D133A, Typ\u2020 = 2. D133A, Max = -. D133A, Units = ms.",
    "DC CHARACTERISTICS\nD133A, Conditions = . D134, Sym = TRETD. D134, Characteristic = Characteristic Retention. D134, Min = 40. D134, Typ\u2020 = 100. D134, Max = -. D134, Units = Year. D134, Conditions = Provided no other specifications are violated\n\u2020 Data in 'Typ' column is at 5.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: These specifications are for programming the on-chip program memory through the use of table write instructions.\n2: Refer to Section 7.9 'Using the Data EEPROM' for a more detailed discussion on data EEPROM endurance.\n3: Required only if Single-Supply Programming is disabled.",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nPIC18LF2331/2431/4331/4431\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nPIC18F2331/2431/4331/4431\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420A, Symbol = VLVD. D420A, Characteristic = Voltage on VDD Transition High-to-Low. D420A, Characteristic = Voltage on VDD Transition High-to-Low. D420A, Min = Industrial Low Voltage (-10\u00b0C to +85\u00b0C). D420A, Typ\u2020 = Industrial Low Voltage (-10\u00b0C to +85\u00b0C). D420A, Max = Industrial Low Voltage (-10\u00b0C to +85\u00b0C). D420A, Units = Industrial Low Voltage (-10\u00b0C to +85\u00b0C). D420A, Conditions = Industrial Low Voltage (-10\u00b0C to +85\u00b0C). D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 0000. D420A, Min = N/A. D420A, Typ\u2020 = N/A. D420A, Max = N/A. D420A,",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nUnits = V. D420A, Conditions = Reserved. D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 0001. D420A, Min = N/A. D420A, Typ\u2020 = N/A. D420A, Max = N/A. D420A, Units = V. D420A, Conditions = Reserved. D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 0010. D420A, Min = 2.08. D420A, Typ\u2020 = 2.26. D420A, Max = 2.44. D420A, Units = V. D420A, Conditions = . D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS\n= LVDL<3:0> = 0011. D420A, Min = 2.26. D420A, Typ\u2020 = 2.45. D420A, Max = 2.65. D420A, Units = V. D420A, Conditions = . D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 0100. D420A, Min = 2.35. D420A, Typ\u2020 = 2.55. D420A, Max = 2.76. D420A, Units = V. D420A, Conditions = . D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 0101. D420A, Min = 2.55. D420A, Typ\u2020 = 2.77. D420A, Max = 2.99.",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420A, Units = V. D420A, Conditions = . D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 0110. D420A, Min = 2.64. D420A, Typ\u2020 = 2.87. D420A, Max = 3.10. D420A, Units = V. D420A, Conditions = . D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 0111. D420A, Min = 2.82. D420A, Typ\u2020 = 3.07. D420A, Max = 3.31. D420A, Units = V. D420A, Conditions = . D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31.",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420A, Characteristic = LVDL<3:0> = 1000. D420A, Min = 3.09. D420A, Typ\u2020 = 3.36. D420A, Max = 3.63. D420A, Units = V. D420A, Conditions = . D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 1001. D420A, Min = 3.29. D420A, Typ\u2020 = 3.57. D420A, Max = 3.86. D420A, Units = V. D420A, Conditions = . D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 1010. D420A, Min = 3.38. D420A, Typ\u2020 = 3.67. D420A, Max",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS\n= 3.96. D420A, Units = V. D420A, Conditions = . D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 1011. D420A, Min = 3.56. D420A, Typ\u2020 = 3.87. D420A, Max = 4.18. D420A, Units = V. D420A, Conditions = . D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 1100. D420A, Min = 3.75. D420A, Typ\u2020 = 4.07. D420A, Max = 4.40. D420A, Units = V. D420A, Conditions = . D420A, Symbol = . D420A, Characteristic = LVD",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS\nPIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 1101. D420A, Min = 3.93. D420A, Typ\u2020 = 4.28. D420A, Max = 4.62. D420A, Units = V. D420A, Conditions = . D420A, Symbol = . D420A, Characteristic = LVD PIC18LF2X31/4X31. D420A, Characteristic = LVDL<3:0> = 1110. D420A, Min = 4.23. D420A, Typ\u2020 = 4.60. D420A, Max = 4.96. D420A, Units = V. D420A, Conditions = \nLegend: Shading of rows is to assist in readability of the table.\n\u2020 Production tested at TAMB = 25\u00b0C. Specifications over temperature limits ensured by characterization.",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nPIC18LF2331/2431/4331/4431\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nPIC18F2331/2431/4331/4431\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nD420B, Symbol = VLVD. D420B, Characteristic = LVD Voltage on VDD Transition High-to-Low. D420B, Characteristic = LVD Voltage on VDD Transition High-to-Low. D420B, Min = Industrial Low Voltage (-40\u00b0C to -10\u00b0C). D420B, Typ\u2020 = Industrial Low Voltage (-40\u00b0C to -10\u00b0C). D420B, Max = Industrial Low Voltage (-40\u00b0C to -10\u00b0C). D420B, Units = Industrial Low Voltage (-40\u00b0C to -10\u00b0C). D420B, Conditions = Industrial Low Voltage (-40\u00b0C to -10\u00b0C). D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 0000. D420B, Min = N/A. D420B, Typ\u2020 = N/A. D420B, Max =",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nN/A. D420B, Units = V. D420B, Conditions = Reserved. D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 0001. D420B, Min = N/A. D420B, Typ\u2020 = N/A. D420B, Max = N/A. D420B, Units = V. D420B, Conditions = Reserved. D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 0010. D420B, Min = 1.99. D420B, Typ\u2020 = 2.26. D420B, Max = 2.53. D420B, Units = V. D420B, Conditions = . D420B, Symbol = VLVD. D420B, Characteristic =",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nPIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 0011. D420B, Min = 2.16. D420B, Typ\u2020 = 2.45. D420B, Max = 2.75. D420B, Units = V. D420B, Conditions = . D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 0100. D420B, Min = 2.25. D420B, Typ\u2020 = 2.55. D420B, Max = 2.86. D420B, Units = V. D420B, Conditions = . D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 0101. D420B, Min = 2.43.",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nD420B, Typ\u2020 = 2.77. D420B, Max = 3.10. D420B, Units = V. D420B, Conditions = . D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 0110. D420B, Min = 2.53. D420B, Typ\u2020 = 2.87. D420B, Max = 3.21. D420B, Units = V. D420B, Conditions = . D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 0111. D420B, Min = 2.70. D420B, Typ\u2020 = 3.07. D420B, Max = 3.43. D420B, Units = V. D420B, Conditions = .",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nD420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 1000. D420B, Min = 2.96. D420B, Typ\u2020 = 3.36. D420B, Max = 3.77. D420B, Units = V. D420B, Conditions = . D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 1001. D420B, Min = 3.14. D420B, Typ\u2020 = 3.57. D420B, Max = 4.00. D420B, Units = V. D420B, Conditions = . D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0>",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\n= 1010. D420B, Min = 3.23. D420B, Typ\u2020 = 3.67. D420B, Max = 4.11. D420B, Units = V. D420B, Conditions = . D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 1011. D420B, Min = 3.41. D420B, Typ\u2020 = 3.87. D420B, Max = 4.34. D420B, Units = V. D420B, Conditions = . D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 1100. D420B, Min = 3.58. D420B, Typ\u2020 = 4.07. D420B, Max = 4.56. D420B,",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nUnits = V. D420B, Conditions = . D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 1101. D420B, Min = 3.76. D420B, Typ\u2020 = 4.28. D420B, Max = 4.79. D420B, Units = V. D420B, Conditions = . D420B, Symbol = VLVD. D420B, Characteristic = PIC18LF2X31/4X31. D420B, Characteristic = LVDL<3:0> = 1110. D420B, Min = 4.04. D420B, Typ\u2020 = 4.60. D420B, Max = 5.15. D420B, Units = V. D420B, Conditions = . D420C, Symbol = VLVD. D420C, Characteristic = LVD Voltage on VDD Transition High-to-Low.",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nD420C, Characteristic = LVD Voltage on VDD Transition High-to-Low. D420C, Min = Industrial (-10\u00b0C to +85\u00b0C). D420C, Typ\u2020 = Industrial (-10\u00b0C to +85\u00b0C). D420C, Max = Industrial (-10\u00b0C to +85\u00b0C). D420C, Units = Industrial (-10\u00b0C to +85\u00b0C). D420C, Conditions = Industrial (-10\u00b0C to +85\u00b0C). D420C, Symbol = VLVD. D420C, Characteristic = PIC18F2X31/4X31. D420C, Characteristic = LVDL<3:0> = 1101. D420C, Min = 3.93. D420C, Typ\u2020 = 4.28. D420C, Max = 4.62. D420C, Units = V. D420C, Conditions = . D420C, Symbol = VLVD. D420C, Characteristic =",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nPIC18F2X31/4X31. D420C, Characteristic = LVDL<3:0> = 1110. D420C, Min = 4.23. D420C, Typ\u2020 = 4.60. D420C, Max = 4.96. D420C, Units = V. D420C, Conditions = . D420D, Symbol = VLVD. D420D, Characteristic = LVD Voltage on VDD Transition High-to-Low. D420D, Characteristic = LVD Voltage on VDD Transition High-to-Low. D420D, Min = Industrial (-40\u00b0C to -10\u00b0C). D420D, Typ\u2020 = Industrial (-40\u00b0C to -10\u00b0C). D420D, Max = Industrial (-40\u00b0C to -10\u00b0C). D420D, Units = Industrial (-40\u00b0C to -10\u00b0C). D420D, Conditions = Industrial (-40\u00b0C to -10\u00b0C). D420D, Symbol =",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nVLVD. D420D, Characteristic = PIC18F2X31/4X31. D420D, Characteristic = LVDL<3:0> = 1101. D420D, Min = 3.76. D420D, Typ\u2020 = 4.28. D420D, Max = 4.79. D420D, Units = V. D420D, Conditions = Reserved. D420D, Symbol = VLVD. D420D, Characteristic = PIC18F2X31/4X31. D420D, Characteristic = LVDL<3:0> = 1110. D420D, Min = 4.04. D420D, Typ\u2020 = 4.60. D420D, Max = 5.15. D420D, Units = V. D420D, Conditions = . D420E, Symbol = VLVD. D420E, Characteristic = LVD Voltage on VDD Transition High-to-Low. D420E, Characteristic = LVD Voltage on VDD Transition",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nHigh-to-Low. D420E, Min = Extended (-10\u00b0C to +85\u00b0C). D420E, Typ\u2020 = Extended (-10\u00b0C to +85\u00b0C). D420E, Max = Extended (-10\u00b0C to +85\u00b0C). D420E, Units = Extended (-10\u00b0C to +85\u00b0C). D420E, Conditions = Extended (-10\u00b0C to +85\u00b0C). D420E, Symbol = VLVD. D420E, Characteristic = PIC18F2X31/4X31. D420E, Characteristic = LVDL<3:0> = 1101. D420E, Min = 3.94. D420E, Typ\u2020 = 4.28. D420E, Max = 4.62. D420E, Units = V. D420E, Conditions = . D420E, Symbol = VLVD. D420E, Characteristic = PIC18F2X31/4X31. D420E, Characteristic",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\n= LVDL<3:0> = 1110. D420E, Min = 4.23. D420E, Typ\u2020 = 4.60. D420E, Max = 4.96. D420E, Units = V. D420E, Conditions = . D420F, Symbol = VLVD. D420F, Characteristic = LVD Voltage on VDD Transition High-to-Low. D420F, Characteristic = LVD Voltage on VDD Transition High-to-Low. D420F, Min = Extended (-40\u00b0C to -10\u00b0C, +85\u00b0C to +125\u00b0C). D420F, Typ\u2020 = Extended (-40\u00b0C to -10\u00b0C, +85\u00b0C to +125\u00b0C). D420F, Max = Extended (-40\u00b0C to -10\u00b0C, +85\u00b0C to +125\u00b0C). D420F, Units = Extended (-40\u00b0C to -10\u00b0C, +85\u00b0C to +125\u00b0C). D420F,",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\nConditions = Extended (-40\u00b0C to -10\u00b0C, +85\u00b0C to +125\u00b0C). D420F, Symbol = VLVD. D420F, Characteristic = PIC18F2X31/4X31. D420F, Characteristic = LVDL<3:0> = 1101. D420F, Min = 3.77. D420F, Typ\u2020 = 4.28. D420F, Max = 4.79. D420F, Units = V. D420F, Conditions = Reserved. D420F, Symbol = VLVD. D420F, Characteristic = PIC18F2X31/4X31. D420F, Characteristic = LVDL<3:0> = 1110. D420F, Min = 4.05. D420F, Typ\u2020 = 4.60. D420F, Max = 5.15. D420F, Units = V. D420F, Conditions = \nLegend:\nShading of rows is to assist in readability of the table.",
    "TABLE 26-2: LOW-VOLTAGE DETECT CHARACTERISTICS (CONTINUED)\n- \u2020 Production tested at TAMB = 25\u00b0C. Specifications over temperature limits ensured by characterization.",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\nThe  timing  parameter  symbols  have  been  created following one of the following formats:",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\nT, 1. TppS2ppS.2. TppS = T. T, 3. T CC: ST.4. Ts = . T, (I 2 C specifications only) 2.(I C specifications only) = . F, 1. TppS2ppS.2. TppS = Frequency. F, 3. T CC: ST.4. Ts = T. F, (I 2 C specifications only) 2.(I C specifications only) = Time. Lowercase letters (pp) and their meanings:, 1. TppS2ppS.2. TppS = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, 3. T CC: ST.4. Ts = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, (I 2 C specifications only) 2.(I C specifications only) = Lowercase letters (pp) and their meanings:. pp, 1. TppS2ppS.2. TppS = pp. pp, 3. T CC: ST.4. Ts = . pp, (I 2 C specifications only)",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\n2.(I C specifications only) = . cc, 1. TppS2ppS.2. TppS = CCP1. cc, 3. T CC: ST.4. Ts = osc. cc, (I 2 C specifications only) 2.(I C specifications only) = OSC1. ck, 1. TppS2ppS.2. TppS = CLKO. ck, 3. T CC: ST.4. Ts = rd. ck, (I 2 C specifications only) 2.(I C specifications only) = RD. cs, 1. TppS2ppS.2. TppS = CS. cs, 3. T CC: ST.4. Ts = rw. cs, (I 2 C specifications only) 2.(I C specifications only) = RD or WR. di, 1. TppS2ppS.2. TppS = SDI. di, 3. T CC: ST.4. Ts = sc. di, (I 2 C specifications only) 2.(I C specifications only) = SCK. do, 1. TppS2ppS.2. TppS = SDO. do, 3. T",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\nCC: ST.4. Ts = ss. do, (I 2 C specifications only) 2.(I C specifications only) = SS. dt, 1. TppS2ppS.2. TppS = Data in. dt, 3. T CC: ST.4. Ts = t0. dt, (I 2 C specifications only) 2.(I C specifications only) = T0CKI. io, 1. TppS2ppS.2. TppS = I/O port. io, 3. T CC: ST.4. Ts = t1. io, (I 2 C specifications only) 2.(I C specifications only) = T1CKI. mc, 1. TppS2ppS.2. TppS = MCLR. mc, 3. T CC: ST.4. Ts = wr. mc, (I 2 C specifications only) 2.(I C specifications only) = WR. Uppercase letters and their meanings:, 1. TppS2ppS.2. TppS = Uppercase letters and their meanings:. Uppercase letters and their meanings:, 3. T CC: ST.4. Ts = Uppercase letters and their",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\nmeanings:. Uppercase letters and their meanings:, (I 2 C specifications only) 2.(I C specifications only) = Uppercase letters and their meanings:. S, 1. TppS2ppS.2. TppS = S. S, 3. T CC: ST.4. Ts = . S, (I 2 C specifications only) 2.(I C specifications only) = . F, 1. TppS2ppS.2. TppS = Fall. F, 3. T CC: ST.4. Ts = P. F, (I 2 C specifications only) 2.(I C specifications only) = Period. H, 1. TppS2ppS.2. TppS = High. H, 3. T CC: ST.4. Ts = R. H, (I 2 C specifications only) 2.(I C specifications only) = Rise. I, 1. TppS2ppS.2. TppS = Invalid (High-Impedance). I, 3. T CC: ST.4. Ts = V. I, (I 2 C specifications only) 2.(I C specifications only) = Valid. L, 1.",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\nTppS2ppS.2. TppS = Low. L, 3. T CC: ST.4. Ts = Z. L, (I 2 C specifications only) 2.(I C specifications only) = High-Impedance. I 2 C only, 1. TppS2ppS.2. TppS = I 2 C only. I 2 C only, 3. T CC: ST.4. Ts = . I 2 C only, (I 2 C specifications only) 2.(I C specifications only) = . AA, 1. TppS2ppS.2. TppS = output access. AA, 3. T CC: ST.4. Ts = High. AA, (I 2 C specifications only) 2.(I C specifications only) = High. BUF, 1. TppS2ppS.2. TppS = Bus free. BUF, 3. T CC: ST.4. Ts = Low. BUF, (I 2 C specifications only) 2.(I C specifications only) = Low. T CC: ST (I 2 C specifications only), 1. TppS2ppS.2. TppS = T CC: ST",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\n(I 2 C specifications only). T CC: ST (I 2 C specifications only), 3. T CC: ST.4. Ts = T CC: ST (I 2 C specifications only). T CC: ST (I 2 C specifications only), (I 2 C specifications only) 2.(I C specifications only) = T CC: ST (I 2 C specifications only). CC, 1. TppS2ppS.2. TppS = CC. CC, 3. T CC: ST.4. Ts = . CC, (I 2 C specifications only) 2.(I C specifications only) = . HD, 1. TppS2ppS.2. TppS = Hold. HD, 3. T CC: ST.4. Ts = SU. HD, (I 2 C specifications only) 2.(I C specifications only) = Setup. ST, 1. TppS2ppS.2. TppS = ST. ST, 3. T CC: ST.4. Ts = ST. ST, (I 2 C specifications only) 2.(I C specifications only) = ST. DAT, 1. TppS2ppS.2. TppS",
    "26.4.1 TIMING PARAMETER SYMBOLOGY\n= DATA input hold. DAT, 3. T CC: ST.4. Ts = STO. DAT, (I 2 C specifications only) 2.(I C specifications only) = Stop condition. STA, 1. TppS2ppS.2. TppS = Start condition. STA, 3. T CC: ST.4. Ts = . STA, (I 2 C specifications only) 2.(I C specifications only) = ",
    "26.4.2 TIMING CONDITIONS\nNote:\nThe temperature and voltages specified in Table 26-3 apply  to  all timing  specifications  unless  otherwise noted. Figure 26-4 specifies the load conditions for the timing specifications.\nBecause of space limitations, the generic terms 'PIC18FXX31' and 'PIC18LFXX31' are used throughout this section to refer to the PIC18F2331/2431/4331/4431 and PIC18LF2331/2431/4331/4431 families of devices specifically, and only those devices.",
    "TABLE 26-3: TEMPERATURE AND VOLTAGE SPECIFICATIONS - AC\nAC CHARACTERISTICS, 1 = Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3\uf020 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3\uf020 +125\u00b0C for extended Operating voltage VDD range as described in DC spec Section 26.1 and Section 26.3 . LF parts operate for industrial temperatures only.",
    "TABLE 26-4: EXTERNAL CLOCK TIMING REQUIREMENTS\n1A, Symbol = FOSC. 1A, Characteristic = External CLKI Frequency (1) Oscillator Frequency (1). 1A, Min = DC DC 0.1 4 4 5. 1A, Max = 40 4 4 25 10 200. 1A, Units = MHz MHz MHz MHz MHz kHz. 1A, Conditions = EC, ECIO RC osc XT osc HS osc HS + PLL osc LP Osc mode. 1, Symbol = T OSC. 1, Characteristic = External CLKI Period (1) Oscillator Period (1). 1, Min = 25 250 250 25 100 25. 1, Max = - - 10,000 250 250 -. 1, Units = ns ns ns ns ns \uf06d s. 1, Conditions = EC, ECIO RC osc XT osc HS osc HS + PLL osc. 2, Symbol = T CY. 2, Characteristic = Instruction Cycle Time (1). 2, Min = 100. 2, Max = -. 2, Units = ns. 2, Conditions = T CY = 4/F OSC. 3, Symbol = TosL, TosH. 3, Characteristic = External Clock in",
    "TABLE 26-4: EXTERNAL CLOCK TIMING REQUIREMENTS\n(OSC1) High or Low Time. 3, Min = 30 2.5 10. 3, Max = - - -. 3, Units = ns \uf06d s ns. 3, Conditions = XT osc LP osc HS osc. 4, Symbol = TosR, TosF. 4, Characteristic = External Clock in (OSC1) Rise or Fall Time. 4, Min = - - -. 4, Max = 20 50 7.5. 4, Units = ns ns. 4, Conditions = XT osc LP osc\nNote 1: Instruction cycle period (TCY) equals four times the input oscillator time base period for all configurations except PLL. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min.' values with an external clock applied to the OSC1/CLKI pin. When an external clock input is used, the 'max.' cycle time limit is 'DC' (no clock) for all devices.",
    "TABLE 26-5: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2V TO 5.5V)\nF10, Sym = FOSC. F10, Characteristic = Oscillator Frequency Range. F10, Min = 4. F10, Typ\u2020 = -. F10, Max = 10. F10, Units = MHz. F10, Conditions = HS mode only. F11, Sym = FSYS. F11, Characteristic = On-Chip VCO System Frequency. F11, Min = 16. F11, Typ\u2020 = -. F11, Max = 40. F11, Units = MHz. F11, Conditions = HS mode only. F12, Sym = TPLL. F12, Characteristic = PLL Start-up Time (Lock Time). F12, Min = -. F12, Typ\u2020 = -. F12, Max = 2. F12, Units = ms. F12, Conditions = . F13, Sym = \uf044 CLK. F13, Characteristic = CLKO Stability (Jitter). F13, Min = -2. F13, Typ\u2020 = -. F13, Max = +2.",
    "TABLE 26-5: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2V TO 5.5V)\nF13, Units = %. F13, Conditions = \n- \u2020 Data in 'Typ' column is at 5V, 25 C unless otherwise stated. These parameters are for design guidance only \uf0b0 and are not tested.",
    "TABLE 26-6: INTERNAL RC ACCURACY\nPIC18F2331/2431/4331/4431 (Industrial), PIC18LF2331/2431/4331/4431 (Industrial) = PIC18F2331/2431/4331/4431 (Industrial). PIC18F2331/2431/4331/4431 (Industrial), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = Standard Operating Operating temperature. PIC18F2331/2431/4331/4431 (Industrial), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = Standard Operating Operating temperature. PIC18F2331/2431/4331/4431 (Industrial), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = Standard Operating Operating temperature. PIC18F2331/2431/4331/4431 (Industrial), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3",
    "TABLE 26-6: INTERNAL RC ACCURACY\n+85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended. PIC18F2331/2431/4331/4431 (Industrial), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended. PIC18F2331/2431/4331/4431 (Industrial), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended. Param No., PIC18LF2331/2431/4331/4431 (Industrial) = Device. Param No., Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = Min. Param No., Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial =",
    "TABLE 26-6: INTERNAL RC ACCURACY\nTyp. Param No., Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = Max. Param No., Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = Units. Param No., Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = . Param No., Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = Conditions. INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1), PIC18LF2331/2431/4331/4431 (Industrial) = INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1). INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1), Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 26-6: INTERNAL RC ACCURACY\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1). INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1). INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1). INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz",
    "TABLE 26-6: INTERNAL RC ACCURACY\n(1), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1). INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1). INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = INTOSC Accuracy @Freq = 8 MHz, 4 MHz, 2 MHz, 1 MHz, 500 kHz, 250 kHz, 125 kHz (1). F2,",
    "TABLE 26-6: INTERNAL RC ACCURACY\nPIC18LF2331/2431/4331/4431 (Industrial) = PIC18LF2331/2431/4331/4431. F2, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = -15. F2, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = +/-5. F2, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = +15. F2, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = %. F2, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = 25\u00b0C. F2, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = VDD = 3.0V. F3, PIC18LF2331/2431/4331/4431 (Industrial) = All devices. F3, Standard Operating Conditions (unless otherwise",
    "TABLE 26-6: INTERNAL RC ACCURACY\nstated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = -15. F3, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = +/-5. F3, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = +15. F3, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = %. F3, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = 25\u00b0C. F3, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = VDD = 5.0V. INTRC Accuracy @Freq = 31 kHz (2), PIC18LF2331/2431/4331/4431 (Industrial) = INTRC Accuracy @Freq = 31 kHz (2). INTRC Accuracy @Freq = 31 kHz (2), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "TABLE 26-6: INTERNAL RC ACCURACY\n+85\u00b0C for industrial = INTRC Accuracy @Freq = 31 kHz (2). INTRC Accuracy @Freq = 31 kHz (2), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = INTRC Accuracy @Freq = 31 kHz (2). INTRC Accuracy @Freq = 31 kHz (2), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = INTRC Accuracy @Freq = 31 kHz (2). INTRC Accuracy @Freq = 31 kHz (2), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = INTRC Accuracy @Freq = 31 kHz (2). INTRC Accuracy @Freq = 31 kHz (2), Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = INTRC Accuracy @Freq = 31 kHz (2). INTRC Accuracy @Freq = 31 kHz (2), Standard Operating Conditions (unless otherwise stated) Operating",
    "TABLE 26-6: INTERNAL RC ACCURACY\ntemperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = INTRC Accuracy @Freq = 31 kHz (2). F5, PIC18LF2331/2431/4331/4431 (Industrial) = PIC18LF2331/2431/4331/4431. F5, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = 26.562. F5, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = -. F5, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = 35.938. F5, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = kHz. F5, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = 25\u00b0C. F5, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = VDD = 3.0V.",
    "TABLE 26-6: INTERNAL RC ACCURACY\nF6, PIC18LF2331/2431/4331/4431 (Industrial) = All devices. F6, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = 26.562. F6, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = -. F6, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = 35.938. F6, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = kHz. F6, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = 25\u00b0C. F6, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial = VDD = 5.0V",
    "TABLE 26-6: INTERNAL RC ACCURACY\nLegend: Shading of rows is to assist in readability of the table.\nNote 1: Frequency calibrated at 25\u00b0C. OSCTUNE register can be used to compensate for temperature drift.\n2: INTRC frequency after calibration.",
    "TABLE 26-7: CLKO AND I/O TIMING REQUIREMENTS\n10, Symbol = TosH2ckL. 10, Characteristic = OSC1 \uf0ad to CLKO \uf0af. 10, Characteristic = OSC1 \uf0ad to CLKO \uf0af. 10, Min = -. 10, Typ\u2020 = 75. 10, Max = 200. 10, Units = ns. 10, Conditions = (Note 1). 11, Symbol = TosH2ckH. 11, Characteristic = OSC1 \uf0ad to CLKO \uf0ad. 11, Characteristic = OSC1 \uf0ad to CLKO \uf0ad. 11, Min = -. 11, Typ\u2020 = 75. 11, Max = 200. 11, Units = ns. 11, Conditions = (Note 1). 12, Symbol = TckR. 12, Characteristic = CLKO Rise Time. 12, Characteristic = CLKO Rise Time. 12, Min = -. 12, Typ\u2020 = 35. 12, Max = 100. 12, Units = ns. 12, Conditions = (Note 1). 13, Symbol = TckF. 13, Characteristic = CLKO Fall Time. 13, Characteristic = CLKO Fall Time. 13, Min = -. 13, Typ\u2020 = 35. 13, Max = 100. 13, Units",
    "TABLE 26-7: CLKO AND I/O TIMING REQUIREMENTS\n= ns. 13, Conditions = (Note 1). 14, Symbol = TckL2ioV. 14, Characteristic = CLKO \uf0af to Port Out Valid. 14, Characteristic = CLKO \uf0af to Port Out Valid. 14, Min = -. 14, Typ\u2020 = -. 14, Max = 0.5 T CY + 20. 14, Units = ns. 14, Conditions = (Note 1). 15, Symbol = TioV2ckH. 15, Characteristic = Port In Valid before CLKO \uf0ad. 15, Characteristic = Port In Valid before CLKO \uf0ad. 15, Min = 0.25 T CY + 25. 15, Typ\u2020 = -. 15, Max = -. 15, Units = ns. 15, Conditions = (Note 1). 16, Symbol = TckH2ioI. 16, Characteristic = Port In Hold after CLKO \uf0ad. 16, Characteristic = Port In Hold after CLKO \uf0ad. 16, Min = 0. 16, Typ\u2020 = -. 16, Max = -. 16, Units = ns. 16, Conditions = (Note 1). 17, Symbol = TosH2ioV. 17, Characteristic = OSC1 \uf0ad",
    "TABLE 26-7: CLKO AND I/O TIMING REQUIREMENTS\n(Q1 cycle) to Port Out Valid. 17, Characteristic = OSC1 \uf0ad (Q1 cycle) to Port Out Valid. 17, Min = -. 17, Typ\u2020 = 50. 17, Max = 150. 17, Units = ns. 17, Conditions = . 18 18A, Symbol = TosH2ioI. 18 18A, Characteristic = OSC1 \uf0ad (Q2 cycle) to Port Input Invalid (I/O in hold time). 18 18A, Characteristic = PIC18FXX31. 18 18A, Min = 100. 18 18A, Typ\u2020 = -. 18 18A, Max = -. 18 18A, Units = ns. 18 18A, Conditions = . 18 18A, Symbol = TosH2ioI. 18 18A, Characteristic = OSC1 \uf0ad (Q2 cycle) to Port Input Invalid (I/O in hold time). 18 18A, Characteristic = PIC18LFXX31. 18 18A, Min = 200. 18 18A, Typ\u2020 = -. 18 18A, Max = -. 18 18A, Units = ns. 18 18A, Conditions = .",
    "TABLE 26-7: CLKO AND I/O TIMING REQUIREMENTS\n19, Symbol = TioV2osH. 19, Characteristic = Port Input Valid to OSC1 \uf0ad\uf020 (I/O in setup time). 19, Characteristic = Port Input Valid to OSC1 \uf0ad\uf020 (I/O in setup time). 19, Min = 0. 19, Typ\u2020 = -. 19, Max = -. 19, Units = ns. 19, Conditions = . 20 20A, Symbol = TioR. 20 20A, Characteristic = Port Output Rise Time. 20 20A, Characteristic = PIC18FXX31. 20 20A, Min = -. 20 20A, Typ\u2020 = 10. 20 20A, Max = 25. 20 20A, Units = ns. 20 20A, Conditions = . 20 20A, Symbol = TioR. 20 20A, Characteristic = Port Output Rise Time. 20 20A, Characteristic = PIC18LFXX31. 20 20A, Min = -. 20 20A, Typ\u2020 = -. 20 20A, Max = 60. 20 20A, Units = ns. 20 20A, Conditions = . 21, Symbol = TioF. 21, Characteristic = Port Output Fall Time.",
    "TABLE 26-7: CLKO AND I/O TIMING REQUIREMENTS\n21, Characteristic = PIC18FXX31. 21, Min = -. 21, Typ\u2020 = 10. 21, Max = 25. 21, Units = ns. 21, Conditions = . 21A, Symbol = TioF. 21A, Characteristic = Port Output Fall Time. 21A, Characteristic = PIC18LFXX31. 21A, Min = -. 21A, Typ\u2020 = -. 21A, Max = 60. 21A, Units = ns. 21A, Conditions = . 22\u2020, Symbol = TINP. 22\u2020, Characteristic = INTx Pin High or Low Time. 22\u2020, Characteristic = INTx Pin High or Low Time. 22\u2020, Min = T CY. 22\u2020, Typ\u2020 = -. 22\u2020, Max = -. 22\u2020, Units = ns. 22\u2020, Conditions = . 23\u2020, Symbol = TRBP. 23\u2020, Characteristic = RB<7:4> Change INTx High or Low Time. 23\u2020, Characteristic = RB<7:4> Change INTx High or Low Time. 23\u2020, Min = T CY. 23\u2020, Typ\u2020 = -.",
    "TABLE 26-7: CLKO AND I/O TIMING REQUIREMENTS\n23\u2020, Max = -. 23\u2020, Units = ns. 23\u2020, Conditions = \n\u2020 These parameters are asynchronous events not related to any internal clock edges.\nNote 1: Measurements are taken in RC mode, where CLKO output is 4 x TOSC.",
    "RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER AND POWER-UP TIMER TIMING\nFIGURE 26-8:\nBROWN-OUT RESET TIMING",
    "TABLE 26-8: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\n30, Symbol = TMCL. 30, Characteristic = MCLR Pulse Width (low). 30, Min = 2. 30, Typ = -. 30, Max = -. 30, Units = \uf06d s. 30, Conditions = . 31, Symbol = TWDT. 31, Characteristic = Watchdog Timer Time-out Period (no postscaler). 31, Min = -. 31, Typ = 4.00. 31, Max = -. 31, Units = ms. 31, Conditions = . 32, Symbol = T OST. 32, Characteristic = Oscillation Start-up Timer Period. 32, Min = 1024 T OSC. 32, Typ = -. 32, Max = 1024 T OSC. 32, Units = -. 32, Conditions = T OSC = OSC1 period. 33, Symbol = TPWRT. 33, Characteristic = Power-up Timer Period. 33, Min = -. 33, Typ = 65.5. 33, Max = -. 33, Units = ms. 33, Conditions = .",
    "TABLE 26-8: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\n34, Symbol = T IOZ. 34, Characteristic = I/O High-impedance from MCLR Low or Watchdog Timer Reset. 34, Min = -. 34, Typ = 2. 34, Max = -. 34, Units = \uf06d s. 34, Conditions = . 35, Symbol = TBOR. 35, Characteristic = Brown-out Reset Pulse Width. 35, Min = 200. 35, Typ = -. 35, Max = -. 35, Units = \uf06d s. 35, Conditions = VDD \uf0a3 BVDD (see D005). 36, Symbol = TIRVST. 36, Characteristic = Time for Internal Reference Voltage to become Stable. 36, Min = -. 36, Typ = 20. 36, Max = 50. 36, Units = \uf06d s. 36, Conditions = . 37, Symbol = TLVD. 37, Characteristic = Low-Voltage Detect Pulse Width. 37, Min = 200. 37, Typ = -. 37, Max = -. 37, Units = \uf06d s. 37, Conditions = VDD \uf0a3 VLVD. 38,",
    "TABLE 26-8: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS\nSymbol = T CSD. 38, Characteristic = CPU Start-up Time. 38, Min = -. 38, Typ = 10. 38, Max = -. 38, Units = \uf06d s. 38, Conditions = . 39, Symbol = TIOBST. 39, Characteristic = Time for INTOSC to Stabilize. 39, Min = -. 39, Typ = 1. 39, Max = -. 39, Units = ms. 39, Conditions = ",
    "TABLE 26-9: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n40, Symbol = Tt0H. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = No prescaler. 40, Min = 0.5 T CY + 20. 40, Max = -. 40, Units = ns. 40, Conditions = VDD = 2V. 40, Symbol = Tt0H. 40, Characteristic = . 40, Characteristic = . 40, Characteristic = With prescaler. 40, Min = 10. 40, Max = -. 40, Units = ns. 40, Conditions = VDD = 2V. 41, Symbol = Tt0L. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = No prescaler. 41, Min = 0.5 T CY + 20. 41, Max = -. 41, Units = ns. 41, Conditions = . 41, Symbol = Tt0L. 41, Characteristic = . 41, Characteristic = . 41, Characteristic = With prescaler. 41, Min = 10. 41, Max = -. 41, Units = ns. 41,",
    "TABLE 26-9: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nConditions = . 42, Symbol = Tt0P. 42, Characteristic = T0CKI Period. 42, Characteristic = T0CKI Period. 42, Characteristic = No prescaler. 42, Min = T CY + 10. 42, Max = -. 42, Units = ns. 42, Conditions = . 42, Symbol = Tt0P. 42, Characteristic = . 42, Characteristic = . 42, Characteristic = With prescaler. 42, Min = Greater of: 20 ns or T CY + 40 N. 42, Max = -. 42, Units = ns. 42, Conditions = N = prescale value (1, 2, 4,..., 256). 45, Symbol = Tt1H. 45, Characteristic = T1CKI High Time. 45, Characteristic = Synchronous, no prescaler. 45, Characteristic = Synchronous, no prescaler. 45, Min = 0.5 T CY + 20. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T1CKI High Time. 45, Characteristic =",
    "TABLE 26-9: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nSynchronous, with prescaler. 45, Characteristic = PIC18FXX31. 45, Min = 10. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T1CKI High Time. 45, Characteristic = Synchronous, with prescaler. 45, Characteristic = PIC18LFXX31. 45, Min = 25. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T1CKI High Time. 45, Characteristic = Asynchronous. 45, Characteristic = PIC18FXX31. 45, Min = 30. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T1CKI High Time. 45, Characteristic = Asynchronous. 45, Characteristic = PIC18LFXX31. 45, Min = 50. 45, Max = -. 45, Units = ns. 45, Conditions = . 46, Symbol = Tt1L. 46, Characteristic =",
    "TABLE 26-9: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nT1CKI Low Time. 46, Characteristic = Synchronous, no prescaler. 46, Characteristic = Synchronous, no prescaler. 46, Min = 0.5 T CY + 5. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI Low Time. 46, Characteristic = Synchronous, with prescaler. 46, Characteristic = PIC18FXX31. 46, Min = 10. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI Low Time. 46, Characteristic = Synchronous, with prescaler. 46, Characteristic = PIC18LFXX31. 46, Min = 25. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI Low Time. 46, Characteristic = Asynchronous. 46, Characteristic = PIC18FXX31. 46, Min = 30. 46, Max = -.",
    "TABLE 26-9: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI Low Time. 46, Characteristic = Asynchronous. 46, Characteristic = PIC18LFXX31. 46, Min = 50. 46, Max = -. 46, Units = ns. 46, Conditions = . 47, Symbol = Tt1P. 47, Characteristic = T1CKI Input Period. 47, Characteristic = Synchronous. 47, Characteristic = Synchronous. 47, Min = Greater of: 20 ns or T CY + 40 N. 47, Max = -. 47, Units = ns. 47, Conditions = N = prescale value (1, 2, 4, 8). 47, Symbol = Tt1P. 47, Characteristic = T1CKI Input Period. 47, Characteristic = Asynchronous. 47, Characteristic = Asynchronous. 47, Min = 60. 47, Max = -. 47, Units = ns. 47, Conditions = . , Symbol = Ft1. , Characteristic = T1CKI Oscillator Input Frequency Range. , Characteristic = T1CKI",
    "TABLE 26-9: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nOscillator Input Frequency Range. , Characteristic = T1CKI Oscillator Input Frequency Range. , Min = DC. , Max = 50. , Units = kHz. , Conditions = . 48, Symbol = Tcke2tmrI Delay from External T1CKI Clock Edge to Timer Increment. 48, Characteristic = Tcke2tmrI Delay from External T1CKI Clock Edge to Timer Increment. 48, Characteristic = Tcke2tmrI Delay from External T1CKI Clock Edge to Timer Increment. 48, Characteristic = Tcke2tmrI Delay from External T1CKI Clock Edge to Timer Increment. 48, Min = 2 T OSC. 48, Max = 7 T OSC. 48, Units = -. 48, Conditions = ",
    "TABLE 26-10: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\n50, Symbol = TccL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = No prescaler. 50, Characteristic = No prescaler. 50, Min = 0.5 T CY + 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Symbol = TccL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = With prescaler. 50, Characteristic = PIC18FXX31. 50, Min = 10. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Symbol = TccL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = With prescaler. 50, Characteristic = PIC18LFXX31. 50, Min = 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPxInput High Time. 51, Characteristic = No prescaler. 51, Characteristic = No prescaler. 51, Min = 0.5 T CY + 20. 51, Max =",
    "TABLE 26-10: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\n-. 51, Units = ns. 51, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPxInput High Time. 51, Characteristic = With prescaler. 51, Characteristic = PIC18FXX31. 51, Min = 10. 51, Max = -. 51, Units = ns. 51, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPxInput High Time. 51, Characteristic = With prescaler. 51, Characteristic = PIC18LFXX31. 51, Min = 20. 51, Max = -. 51, Units = ns. 51, Conditions = . 52, Symbol = TccP. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Min = 3 T CY + 40 N. 52, Max = -. 52, Units = ns. 52, Conditions = N = prescale value (1, 4 or 16). 53, Symbol = TccR. 53, Characteristic = CCPx Output Fall Time. 53, Characteristic = CCPx Output",
    "TABLE 26-10: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\nFall Time. 53, Characteristic = PIC18FXX31. 53, Min = -. 53, Max = 25. 53, Units = ns. 53, Conditions = . 53, Symbol = TccR. 53, Characteristic = . 53, Characteristic = . 53, Characteristic = PIC18LFXX31. 53, Min = -. 53, Max = 45. 53, Units = ns. 53, Conditions = . 54, Symbol = TccF. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = PIC18FXX31. 54, Min = -. 54, Max = 25. 54, Units = ns. 54, Conditions = . 54, Symbol = TccF. 54, Characteristic = . 54, Characteristic = . 54, Characteristic = PIC18LFXX31. 54, Min = -. 54, Max = 45. 54, Units = ns. 54, Conditions = ",
    "PIC18F2331/2431/4331/4431\n)\nFIGURE 26-11: EXAMPLE SPI MASTER MODE TIMING (CKE = 0\n\nTABLE 26-11: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0 )",
    "PIC18F2331/2431/4331/4431\n73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 20. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = Tb2b. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = . 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 40. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time.",
    "PIC18F2331/2431/4331/4431\n75, Characteristic = PIC18FXX31. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18LFXX31. 75, Min = -. 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time. 78, Characteristic = PIC18FXX31. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time. 78, Characteristic = PIC18LFXX31. 78, Min = -. 78, Max = 45. 78, Units = ns. 78, Conditions = . 79, Symbol =",
    "PIC18F2331/2431/4331/4431\nTscF. 79, Characteristic = SCK Output Fall Time. 79, Characteristic = SCK Output Fall Time. 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18FXX31. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18LFXX31. 80, Min = -. 80, Max = 100. 80, Units = ns. 80, Conditions = \n)\nFIGURE 26-12: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\nTABLE 26-12: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1\n)",
    "PIC18F2331/2431/4331/4431\n73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 20. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = Tb2b. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = . 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 40. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time.",
    "PIC18F2331/2431/4331/4431\n75, Characteristic = PIC18FXX31. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18LFXX31. 75, Min = -. 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time. 78, Characteristic = PIC18FXX31. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time. 78, Characteristic = PIC18LFXX31. 78, Min = -. 78, Max = 45. 78, Units = ns. 78, Conditions = . 79, Symbol =",
    "PIC18F2331/2431/4331/4431\nTscF. 79, Characteristic = SCK Output Fall Time. 79, Characteristic = SCK Output Fall Time. 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18FXX31. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18LFXX31. 80, Min = -. 80, Max = 100. 80, Units = ns. 80, Conditions = . 81, Symbol = TdoV2scH, TdoV2scL. 81, Characteristic = SDO Data Output Setup to SCK Edge. 81, Characteristic = SDO Data Output Setup to SCK Edge. 81, Min = T CY. 81, Max = -. 81, Units = ns. 81, Conditions = ",
    "EXAMPLE SPI SLAVE MODE TIMING (CKE = 0\n)",
    "TABLE 26-13: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE, CKE = 0\n)",
    "TABLE 26-13: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE, CKE = 0\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = TscH. 71, Characteristic = SCK Input High Time. 71, Characteristic = Continuous. 71, Min = 1.25 T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = TscH. 71A, Characteristic = SCK Input High Time. 71A, Characteristic = Single byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK Input Low Time. 72, Characteristic = Continuous. 72, Min = 1.25 T CY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol = TscL. 72A,",
    "TABLE 26-13: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE, CKE = 0\nCharacteristic = SCK Input Low Time. 72A, Characteristic = Single byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 20. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic",
    "TABLE 26-13: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE, CKE = 0\n= Hold Time of SDI Data Input to SCK Edge. 74, Min = 40. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18FXX31. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18LFXX31. 75, Min = -. 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol = TssH2doZ. 77, Characteristic = SS \uf0ad to SDO Output High-Impedance. 77, Characteristic = SS \uf0ad to SDO Output High-Impedance. 77, Min = 10. 77, Max =",
    "TABLE 26-13: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE, CKE = 0\n50. 77, Units = ns. 77, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18FXX31. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18LFXX31. 80, Min = -. 80, Max = 100. 80, Units = ns. 80, Conditions = . 83, Symbol = TscH2ssH, TscL2ssH. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Min = 1.5 T CY + 40. 83, Max = -. 83, Units = ns. 83, Conditions = \nNote 1: Requires the use of Parameter 73A.\n2: Only if Parameter 71A and 72A are used.",
    "PIC18F2331/2431/4331/4431\n)",
    "TABLE 26-14: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n)",
    "TABLE 26-14: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = TscH. 71, Characteristic = SCK Input High Time. 71, Characteristic = Continuous. 71, Min = 1.25 T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = TscH. 71A, Characteristic = SCK Input High Time. 71A, Characteristic = Single byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK Input Low Time. 72, Characteristic = Continuous. 72, Min = 1.25 T CY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol = TscL. 72A, Characteristic =",
    "TABLE 26-14: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\nSCK Input Low Time. 72A, Characteristic = Single byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 40. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18FXX31. 75, Min = -. 75, Max =",
    "TABLE 26-14: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18LFXX31. 75, Min = -. 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol = TssH2doZ. 77, Characteristic = SS \uf0ad to SDO Output High-Impedance. 77, Characteristic = SS \uf0ad to SDO Output High-Impedance. 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18FXX31. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = .",
    "TABLE 26-14: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18LFXX31. 80, Min = -. 80, Max = 100. 80, Units = ns. 80, Conditions = . 82, Symbol = TssL2doV. 82, Characteristic = SDO Data Output Valid after SS \uf0af Edge. 82, Characteristic = PIC18FXX31. 82, Min = -. 82, Max = 50. 82, Units = ns. 82, Conditions = . 82, Symbol = TssL2doV. 82, Characteristic = SDO Data Output Valid after SS \uf0af Edge. 82, Characteristic = PIC18LFXX31. 82, Min = -. 82, Max = 100. 82, Units = ns. 82, Conditions = . 83, Symbol = TscH2ssH, TscL2ssH. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Min = 1.5 T CY + 40. 83, Max = -. 83, Units = ns. 83, Conditions = ",
    "TABLE 26-14: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\nNote 1: Requires the use of Parameter 73A.\n2: Only if Parameter 71A and 72A are used.",
    "TABLE 26-15: I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\n90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 4700. 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for repeated Start condition. , Symbol = . , Characteristic = . , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = . 91, Symbol = THD: STA. 91, Characteristic = Start Condition. 91, Characteristic = 100 kHz mode. 91, Min = 4000. 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first. , Symbol = . , Characteristic = Hold Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = clock pulse is generated. 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition. 92, Characteristic = 100 kHz mode. 92, Min = 4000. 92, Max = -. 92, Units = ns. 92, Conditions = . , Symbol = . , Characteristic",
    "TABLE 26-15: I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\n= Setup Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = . 93, Symbol = THD: STO. 93, Characteristic = Stop Condition. 93, Characteristic = 100 kHz mode. 93, Min = 4700. 93, Max = -. 93, Units = ns. 93, Conditions = . , Symbol = . , Characteristic = Hold Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = ",
    "TABLE 26-16: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 100 kHz mode. 100, Min = 4.0. 100, Max = -. 100, Units = \uf06d s. 100, Conditions = PIC18FXX31 must operate at a minimum of 1.5 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 400 kHz mode. 100, Min = 0.6. 100, Max = -. 100, Units = \uf06d s. 100, Conditions = PIC18FXX31 must operate at a minimum of 10 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = SSP module. 100, Min = 1.5 T CY. 100, Max = -. 100, Units = . 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 100 kHz mode. 101, Min = 4.7. 101, Max = -. 101, Units = \uf06d s. 101, Conditions = PIC18FXX31 must operate at a minimum of 1.5 MHz. 101, Symbol = TLOW.",
    "TABLE 26-16: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n101, Characteristic = Clock Low Time. 101, Characteristic = 400 kHz mode. 101, Min = 1.3. 101, Max = -. 101, Units = \uf06d s. 101, Conditions = PIC18FXX31 must operate at a minimum of 10 MHz. 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = SSP Module. 101, Min = 1.5 T CY. 101, Max = -. 101, Units = . 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic =",
    "TABLE 26-16: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n100 kHz mode. 103, Min = -. 103, Max = 300. 103, Units = ns. 103, Conditions = . 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 4.7. 90, Max = -. 90, Units = \uf06d s. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 0.6. 90, Max = -. 90, Units = \uf06d s. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode. 91, Min =",
    "TABLE 26-16: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n4.0. 91, Max = -. 91, Units = \uf06d s. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 0.6. 91, Max = -. 91, Units = \uf06d s. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = \uf06d s. 106, Conditions = . 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -. 107, Units = ns. 107, Conditions",
    "TABLE 26-16: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n= (Note 2). 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 4.7. 92, Max = -. 92, Units = \uf06d s. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 0.6. 92, Max = -. 92, Units = \uf06d s. 92, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid From Clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500. 109, Units = ns. 109, Conditions = (Note 1). 109, Symbol = T AA. 109, Characteristic = Output Valid From Clock. 109, Characteristic = 400 kHz mode.",
    "TABLE 26-16: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n109, Min = -. 109, Max = -. 109, Units = ns. 109, Conditions = (Note 1). 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = \uf06d s. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = \uf06d s. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB Bus Capacitive Loading. D102, Characteristic = CB Bus Capacitive Loading. D102, Characteristic = CB Bus Capacitive Loading. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = ",
    "TABLE 26-16: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\nNote 1: As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of Start or Stop conditions.\n2: A Fast mode I 2 C bus device can be used in a Standard mode I 2 C bus system, but the requirement, TSU:DAT \uf0b3 250 ns, must then be met. This will automatically be the case if the device does not stretch the LOW period of the SCL signal. If such a device does stretch the LOW period of the SCL signal, it must output the next data bit to the SDA line,. TR max. + TSU:DAT = 1000 + 250 = 1250 ns (according to the Standard mode I 2 C bus specification), before the SCL line\nis released.",
    "TABLE 26-17: SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 100 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 400 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 100 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 400 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise",
    "TABLE 26-17: SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nTime. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 100 kHz mode. 103, Min = -. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 90, Symbol = T",
    "TABLE 26-17: SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nSU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG +",
    "TABLE 26-17: SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = ms. 106, Conditions = . 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -. 107, Units = ns. 107, Conditions = . 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic =",
    "TABLE 26-17: SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nStop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500. 109, Units = ns. 109, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 400 kHz mode. 109, Min = -. 109, Max = 1000. 109, Units = ns. 109, Conditions = . 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110,",
    "TABLE 26-17: SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nUnits = ms. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = Bus Capacitive Loading. D102, Characteristic = Bus Capacitive Loading. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = ",
    "TABLE 26-18: EUSART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n120, Symbol = TckH2dtV. 120, Characteristic = SYNC XMIT (MASTER & SLAVE) Clock High to Data Out Valid. 120, Characteristic = PIC18FXX31. 120, Min = -. 120, Max = 40. 120, Units = ns. 120, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18LFXX31. , Min = -. , Max = 100. , Units = ns. , Conditions = . 121, Symbol = Tckrf. 121, Characteristic = Clock Out Rise Time and Fall Time. 121, Characteristic = PIC18FXX31. 121, Min = -. 121, Max = 20. 121, Units = ns. 121, Conditions = . , Symbol = . , Characteristic = (Master mode). , Characteristic = PIC18LFXX31. , Min = -. , Max = 50. , Units = ns. , Conditions = . 122, Symbol = Tdtrf. 122, Characteristic = Data Out Rise Time and Fall Time. 122, Characteristic = PIC18FXX31. 122, Min = -. 122, Max = 20. 122, Units = ns. 122, Conditions",
    "TABLE 26-18: EUSART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n= . , Symbol = . , Characteristic = . , Characteristic = PIC18LFXX31. , Min = -. , Max = 50. , Units = ns. , Conditions = ",
    "TABLE 26-19: EUSART SYNCHRONOUS RECEIVE REQUIREMENTS\n125, Symbol = TdtV2ckl. 125, Characteristic = SYNC RCV (MASTER & SLAVE) Data Hold before CK \uf0af (DT hold time). 125, Min = 10. 125, Max = -. 125, Units = ns. 125, Conditions = . 126, Symbol = TckL2dtl. 126, Characteristic = Data Hold after CK \uf0af (DT hold time). 126, Min = 15. 126, Max = -. 126, Units = ns. 126, Conditions = ",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nDevice Supply, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = Device Supply. Device Supply, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Device Supply. Device Supply, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = Device Supply. Device Supply, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = Device Supply. Device Supply, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nindustrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = Device Supply. Device Supply, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = Device Supply. Device Supply, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Device Supply. , PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = AVDD. , PIC18LF2331/2431/4331/4431",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n(Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Analog VDD Supply. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = VDD - 0.3. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = VDD + 0.3. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nA \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . , PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = AVSS. , PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Analog VSS Supply. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nT A \uf0a3 +125\u00b0C for extended.Min = VSS - 0.3. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = VSS + 0.3. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated)",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nOperating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . , PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = I AD. , PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Module Current (during conversion). , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = - -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = 500",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n250. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = - -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = \uf06d A \uf06d A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD = 5V VDD = 2.5V. , PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = I",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nADO. , PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Module Current Off. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = -. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = 1.0. , Standard Operating Conditions (unless otherwise",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nstated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = \uf06d A. , Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . AC Timing Parameters, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = AC Timing Parameters. AC Timing Parameters, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = AC Timing Parameters. AC Timing Parameters, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated)",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nOperating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = AC Timing Parameters. AC Timing Parameters, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = AC Timing Parameters. AC Timing Parameters, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = AC Timing Parameters. AC Timing Parameters, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = AC Timing Parameters. AC Timing Parameters, Standard Operating Conditions",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n(unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = AC Timing Parameters. A10, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = FTHR. A10, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Throughput Rate. A10, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = - -. A10, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n(unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = - -. A10, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = 200 75. A10, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = ksps ksps. A10, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD = 5V, single channel VDD",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n< 3V, single channel. A11, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = T AD. A11, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = A/D Clock Period. A11, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = 385 1000. A11, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = - -. A11, Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = 20,000 20,000. A11, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = ns ns. A11, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD = 5V VDD = 3V. A12, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = TRC. A12,",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nPIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = A/D Internal RC Oscillator Period. A12, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = - - -. A12, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = 500 750 10000. A12, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nextended.Max = 1500 2250 20000. A12, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = ns ns ns. A12, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = PIC18F parts PIC18LF parts AVDD < 3.0V. A13, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = T CNV. A13, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Conversion Time",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n(1). A13, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = 12. A13, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = 12. A13, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = 12. A13, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n+85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = T AD. A13, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . A14, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = T ACQ. A14, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Acquisition Time (2). A14, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = 2",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n(2). A14, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = -. A14, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = -. A14, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = T AD. A14, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n+85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . A16, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = TTC. A16, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Conversion Start from External. A16, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = 1/4 T CY. A16, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ =",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n-. A16, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = -. A16, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = . A16, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . Reference Inputs, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = Reference Inputs. Reference Inputs,",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nPIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Reference Inputs. Reference Inputs, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = Reference Inputs. Reference Inputs, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = Reference Inputs. Reference Inputs, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = Reference Inputs. Reference Inputs, Standard Operating",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nConditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = Reference Inputs. Reference Inputs, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Reference Inputs. A20, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = VREF. A20, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Reference Voltage for 10-Bit Resolution (V REF + - VREF-). A20, Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = 1.5 1.8. A20, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = - -. A20, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = AVDD - AVSS AVDD - AVSS. A20, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nindustrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V V. A20, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD \uf0b3\uf020 3V VDD < 3V. A21, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = VREFH. A21, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Reference Voltage High (AV DD or VREF+). A21, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n+125\u00b0C for extended.Min = 1.5V. A21, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = -. A21, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = AVDD. A21, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. A21, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated)",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nOperating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD \uf0b3\uf020 3V. A22, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = VREFL. A22, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Reference Voltage Low (AV SS or VREF-). A22, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = AVSS. A22, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nindustrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = -. A22, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = VREFH - 1.5V. A22, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. A22, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . A23, PIC18LF2331/2431/4331/4431",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n(Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = I REF. A23, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Reference Current. A23, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = - -. A23, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = 150 \uf06d A 75 \uf06d A. A23, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = - -. A23, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = . A23, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD = 5V VDD = 2.5V. Analog Input Characteristics, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = Analog Input Characteristics. Analog Input Characteristics, PIC18LF2331/2431/4331/4431",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n(Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Analog Input Characteristics. Analog Input Characteristics, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = Analog Input Characteristics. Analog Input Characteristics, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = Analog Input Characteristics. Analog Input Characteristics, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = Analog Input Characteristics. Analog Input Characteristics, Standard Operating Conditions (unless otherwise stated)",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nOperating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = Analog Input Characteristics. Analog Input Characteristics, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = Analog Input Characteristics. A26, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = VAIN. A26, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Input Voltage (3). A26, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\notherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = AVSS - 0.3. A26, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = -. A26, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = AVDD + 0.3. A26, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = V. A26, Standard Operating",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nConditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . A30, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = ZAIN. A30, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Recommended Impedance of Analog Voltage Source. A30, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = -. A30, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nConditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = -. A30, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = 2.5. A30, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = k \uf057. A30, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . A31,",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nPIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = ZCHIN. A31, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Analog Channel Input Impedance. A31, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = -. A31, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = -. A31, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nindustrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = 10.0. A31, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = k \uf057. A31, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD = 3.0V. DC Performance, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = DC Performance. DC Performance, PIC18LF2331/2431/4331/4431",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n(Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = DC Performance. DC Performance, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = DC Performance. DC Performance, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = DC Performance. DC Performance, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = DC Performance. DC Performance, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n+85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = DC Performance. DC Performance, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = DC Performance. A41, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = NR. A41, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Resolution. A41, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nfor industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = . A41, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = 10 bits. A41, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = . A41, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = -. A41, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\notherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = . A42, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = EI L. A42, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Integral Nonlinearity. A42, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = -. A42, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n+125\u00b0C for extended.Typ = -. A42, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = < \uf0b1 1. A42, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = LSb. A42, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD \uf0b3 3.0V VREFH \uf0b3 3.0V. A43, PIC18LF2331/2431/4331/4431",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n(Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = EI L. A43, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Differential Nonlinearity. A43, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = -. A43, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = -. A43, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = < \uf0b1 1. A43, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = LSb. A43, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD \uf0b3 3.0V VREFH \uf0b3 3.0V. A45, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = EOFF. A45, PIC18LF2331/2431/4331/4431",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n(Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Offset Error. A45, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = -. A45, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = \uf0b1 0.5. A45, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = < \uf0b1 1.5. A45, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nT A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = LSb. A45, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD \uf0b3 3.0V VREFH \uf0b3 3.0V. A46, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = EGA. A46, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Gain Error. A46, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\notherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = -. A46, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = \uf0b1 0.5. A46, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = < \uf0b1 1.5. A46, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = LSb. A46, Standard Operating Conditions (unless otherwise",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nstated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD \uf0b3 3.0V VREFH \uf0b3 3.0V. A47, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Symbol = -. A47, PIC18LF2331/2431/4331/4431 (Industrial).PIC18F2331/2431/4331/4431 (Industrial).Characteristic = Monotonicity (4). A47, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Min = . A47, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\n+85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ = guaranteed. A47, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max = . A47, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units = -. A47, Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions = VDD \uf0b3 3.0V",
    "TABLE 26-20: A/D CONVERTER CHARACTERISTICS\nVREFH \uf0b3 3.0V\nNote 1: Conversion time does not include acquisition time. See Section 21.0 '10-Bit High-Speed Analog-to-Digital Converter (A/D) Module' for a full discussion of acquisition time requirements.\n2: In Sequential modes, TACQ should be 12 TAD or greater.\n3: For VDD < 2.7V and temperature below 0\u00b0C, VAIN should be limited to range < VDD/2.\n4: The A/D conversion result never decreases with an increase in the input voltage and has no missing codes.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "Legend:\nXX...X\nCustomer-specific information\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week '01')\nNNN\nAlphanumeric traceability code\nPb-free JEDEC designator for Matte Tin (Sn)\n*\nThis package is Pb-free. The Pb-free JEDEC designator (     )\ncan be found on the outer packaging for this package.\nNote :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.\n3\ne\n3\ne",
    "27.2 Package Details\nThe following sections give the technical details of the packages.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g49. /g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g44/g49/g38/g43/g40/g54./g48/g44/g49 = /##40He56442409eb2e77ad61dd1c271fabe6c/##52H929f5141f4575eca8d5e4ef21356227f. /g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86, /g44/g49/g38/g43/g40/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/##52H929f5141f4575eca8d5e4ef21356227f. /g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /##40He56442409eb2e77ad61dd1c271fabe6c/##52H929f5141f4575eca8d5e4ef21356227f.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g51/g76/g87/g70/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g72. /g51/g76/g87/g70/g75, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g37/g54/g38. /g51/g76/g87/g70/g75, /g44/g49/g38/g43/g40/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g37/g54/g38. /g51/g76/g87/g70/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g44/g49/g38/g43/g40/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g37/g54/g38. /g55",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g82/g83/;#23#23#23/g87/g82/;#23#23#23/g54/g72/g68/g87/g76/g81/g74/;#23#23#23/g51/g79/g68/g81/g72, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g36. /g55",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g82/g83/;#23#23#23/g87/g82/;#23#23#23/g54/g72/g68/g87/g76/g81/g74/;#23#23#23/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g177. /g55",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g82/g83/;#23#23#23/g87/g82/;#23#23#23/g54/g72/g68/g87/g76/g81/g74/;#23#23#23/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g177. /g55",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g82/g83/;#23#23#23/g87/g82/;#23#23#23/g54/g72/g68/g87/g76/g81/g74/;#23#23#23/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g36/##40He56442409eb2e77ad61dd1c271fabe6c.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g44/g49/g38/g43/g40/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/##49H7d5c40f4f2638829db6b707b7e9400a3.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g37/g68/g86/g72/;#23#23#23/g87/g82/;#23#23#23/g54/g72/g68/g87/g76/g81/g74/;#23#23#23/g51/g79/g68/g81/g72,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g36/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g68/g86/g72/;#23#23#23/g87/g82/;#23#23#23/g54/g72/g68/g87/g76/g81/g74/;#23#23#23/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3. /g37/g68/g86/g72/;#23#23#23/g87/g82/;#23#23#23/g54/g72/g68/g87/g76/g81/g74/;#23#23#23/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g177.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g68/g86/g72/;#23#23#23/g87/g82/;#23#23#23/g54/g72/g68/g87/g76/g81/g74/;#23#23#23/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /g177.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g54/g75/g82/g88/g79/g71/g72/g85/;#23#23#23/g87/g82/;#23#23#23/g54/g75/g82/g88/g79/g71/g72/g85/;#23#23#23/g58/g76/g71/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g40.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g54/g75/g82/g88/g79/g71/g72/g85/;#23#23#23/g87/g82/;#23#23#23/g54/g75/g82/g88/g79/g71/g72/g85/;#23#23#23/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/##55H86fa5259cb141e4f33f834c08eacfe53/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g54/g75/g82/g88/g79/g71/g72/g85/;#23#23#23/g87/g82/;#23#23#23/g54/g75/g82/g88/g79/g71/g72/g85/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g44/g49/g38/g43/g40/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g54/g75/g82/g88/g79/g71/g72/g85/;#23#23#23/g87/g82/;#23#23#23/g54/g75/g82/g88/g79/g71/g72/g85/;#23#23#23/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##43Hd27e308598cf1f8bcf9e336036f3f448/##43Hd27e308598cf1f8bcf9e336036f3f448/##49H7d5c40f4f2638829db6b707b7e9400a3. /g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g40/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g49/g50/g48",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n= /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/##52H929f5141f4575eca8d5e4ef21356227f/##49H7d5c40f4f2638829db6b707b7e9400a3. /g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g44/g49/g38/g43/g40/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/##55H86fa5259cb141e4f33f834c08eacfe53/##49H7d5c40f4f2638829db6b707b7e9400a3. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g39. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/##46H7a539460a8268e5915c0973dbb05dce1/##49H7d5c40f4f2638829db6b707b7e9400a3.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##43Hd27e308598cf1f8bcf9e336036f3f448/##4CH2eb0c8ba15de4cce8fa3c169622f8e93/##49H7d5c40f4f2638829db6b707b7e9400a3. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g55/g76/g83/;#23#23#23/g87/g82/;#23#23#23/g54/g72/g68/g87/g76/g81/g74/;#23#23#23/g51/g79/g68/g81/g72, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g47.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g55/g76/g83/;#23#23#23/g87/g82/;#23#23#23/g54/g72/g68/g87/g76/g81/g74/;#23#23#23/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g55/g76/g83/;#23#23#23/g87/g82/;#23#23#23/g54/g72/g68/g87/g76/g81/g74/;#23#23#23/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g55/g76/g83/;#23#23#23/g87/g82/;#23#23#23/g54/g72/g68/g87/g76/g81/g74/;#23#23#23/g51/g79/g68/g81/g72, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g47/g72/g68/g71/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g70. /g47/g72/g68/g71/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g44/g49/g38/g43/g40/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##52H929f5141f4575eca8d5e4ef21356227f. /g47/g72/g68/g71/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g47/g72/g68/g71/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3. /g56/g83/g83/g72/g85/;#23#23#23/g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g69/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g56/g83/g83/g72/g85/;#23#23#23/g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g44/g49/g38/g43/g40/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g83/g83/g72/g85/;#23#23#23/g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g56/g83/g83/g72/g85/;#23#23#23/g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g47/g82/g90/g72/g85/;#23#23#23/g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g69. /g47/g82/g90/g72/g85/;#23#23#23/g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##46H7a539460a8268e5915c0973dbb05dce1.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g47/g82/g90/g72/g85/;#23#23#23/g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##52H929f5141f4575eca8d5e4ef21356227f. /g47/g82/g90/g72/g85/;#23#23#23/g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/##40He56442409eb2e77ad61dd1c271fabe6c. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g53/g82/g90/;#23#23#23/g54/g83/g68/g70/g76/g81/g74/;#23#23#23/;#23#23#23/g134,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g72/g37. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g53/g82/g90/;#23#23#23/g54/g83/g68/g70/g76/g81/g74/;#23#23#23/;#23#23#23/g134,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g44/g49/g38/g43/g40/g54./g48/g44/g49 = /g177. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g53/g82/g90/;#23#23#23/g54/g83/g68/g70/g76/g81/g74/;#23#23#23/;#23#23#23/g134, /g44/g49/g38/g43/g40/g54./g49/g50/g48 = /g177.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g53/g82/g90/;#23#23#23/g54/g83/g68/g70/g76/g81/g74/;#23#23#23/;#23#23#23/g134, /g44/g49/g38/g43/g40/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##46H7a539460a8268e5915c0973dbb05dce1/##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /g51/g76/g81/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g89/g76/g86",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g88/g68/g79/;#23#23#23/g76/g81/g71/g72/g91/;#23#23#23/g73/g72/g68/g87/g88/g85/g72/;#23#23#23/g80/g68/g92/;#23#23#23/g89/g68/g85/g92 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23/g69/g88/g87/;#23#23#23/g80/g88/g86/g87/;#23#23#23/g69/g72/;#23#23#23/g79/g82/g70/g68/g87/g72/g71/;#23#23#23/g90/g76/g87/g75/g76/g81/;#23#23#23/g87/g75/g72/;#23#23#23/g75/g68/g87/g70/g75/g72/g71/;#23#23#23/g68/g85/g72/g68/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g134/;#23#23#23/g54/g76/g74/g81/g76/g73/g76/g70/g68/g81/g87/;#23#23#23/g38/g75/g68/g85/g68/g70/g87/g72/g85/g76/g86/g87/g76/g70/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g86/;#23#23#23/g39/;#23#23#23/g68/g81/g71/;#23#23#23/g40/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g71/g82/;#23#23#23/g81/g82/g87/;#23#23#23/g76/g81/g70/g79/g88/g71/g72/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g80/g82/g79/g71/;#23#23#23/g73/g79/g68/g86/g75/;#23#23#23/g82/g85/;#23#23#23/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g48/g82/g79/g71/;#23#23#23/g73/g79/g68/g86/g75/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g82/g85/;#23#23#23/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/;#23#23#23/g86/g75/g68/g79/g79/;#23#23#23/g81/g82/g87/;#23#23#23/g72/g91/g70/g72/g72/g71/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23/;#23#23#23/g83/g72/g85/;#23#23#23/g86/g76/g71/g72/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g76/g81/g74/;#23#23#23/g68/g81/g71/;#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g76/g81/g74/;#23#23#23/g83/g72/g85/;#23#23#23/g36/g54/g48/g40/;#23#23#23/g60/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##49H7d5c40f4f2638829db6b707b7e9400a3/g48/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g54/g38/##58Hb981034091b194e41ef5193e7127dfd3",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g68/g86/g76/g70/;#23#23#23/g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g55/g75/g72/g82/g85/g72/g87/g76/g70/g68/g79/g79/g92/;#23#23#23/g72/g91/g68/g70/g87/;#23#23#23/g89/g68/g79/g88/g72/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g86/g75/g82/g90/g81/;#23#23#23/g90/g76/g87/g75/g82/g88/g87/;#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g72/g86/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g76/g70/g85/g82/g70/g75/g76/g83 /g55 /g72/g70/g75/g81/g82/g79/g82/g74/g92 /g39/g85/g68/g90/g76/g81/g74 /g38/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##46H7a539460a8268e5915c0973dbb05dce1 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4FHabe68123f3cb4e14e0d59c97044fedf7 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /g37",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g49. /g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##40He56442409eb2e77ad61dd1c271fabe6c/##52H929f5141f4575eca8d5e4ef21356227f. /g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/##52H929f5141f4575eca8d5e4ef21356227f. /g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/##52H929f5141f4575eca8d5e4ef21356227f. /g51/g76/g87/g70/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g72. /g51/g76/g87/g70/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g54/g38. /g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23 /g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g36. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g177.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/##49H7d5c40f4f2638829db6b707b7e9400a3.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g36/##40He56442409eb2e77ad61dd1c271fabe6c. /g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g177. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23/;#23#23#23/g134,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g36/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23/;#23#23#23/g134,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23/;#23#23#23/g134, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23/;#23#23#23/g134, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g40. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38. /g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g40/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g37/g54/g38. /g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g39. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##55H86fa5259cb141e4f33f834c08eacfe53/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##55H86fa5259cb141e4f33f834c08eacfe53/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##55H86fa5259cb141e4f33f834c08eacfe53/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g75/g68/g80/g73/g72/g85/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23/g82/g83/g87/g76/g82/g81/g68/g79/;#23#23#23#23#23#23#23#23#23#23#23#23, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g75.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g75/g68/g80/g73/g72/g85/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23/g82/g83/g87/g76/g82/g81/g68/g79/;#23#23#23#23#23#23#23#23#23#23#23#23, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/##49H7d5c40f4f2638829db6b707b7e9400a3. /g38/g75/g68/g80/g73/g72/g85/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23/g82/g83/g87/g76/g82/g81/g68/g79/;#23#23#23#23#23#23#23#23#23#23#23#23,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g38/g75/g68/g80/g73/g72/g85/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23/g82/g83/g87/g76/g82/g81/g68/g79/;#23#23#23#23#23#23#23#23#23#23#23#23, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4FHabe68123f3cb4e14e0d59c97044fedf7/##49H7d5c40f4f2638829db6b707b7e9400a3. /g41/g82/g82/g87/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g47. /g41/g82/g82/g87/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g41/g82/g82/g87/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g41/g82/g82/g87/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/##4FHabe68123f3cb4e14e0d59c97044fedf7. /g41/g82/g82/g87/g83/g85/g76/g81/g87, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g47/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g41/g82/g82/g87/g83/g85/g76/g81/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g53/g40/g41. /g41/g82/g82/g87/g83/g85/g76/g81/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g53/g40/g41. /g41/g82/g82/g87/g83/g85/g76/g81/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g53/g40/g41.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g41/g82/g82/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g55 /g82/g83, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g73. /g41/g82/g82/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g55",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g82/g83, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /g131. /g41/g82/g82/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g55 /g82/g83, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g41/g82/g82/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g55 /g82/g83, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /##52H929f5141f4575eca8d5e4ef21356227f/g131. /g47/g72/g68/g71/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g70. /g47/g72/g68/g71/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##52H929f5141f4575eca8d5e4ef21356227f. /g47/g72/g68/g71/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g47/g72/g68/g71/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/##43Hd27e308598cf1f8bcf9e336036f3f448. /g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g69. /g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g55 /g82/g83,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g68. /g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g55 /g82/g83,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##49H7d5c40f4f2638829db6b707b7e9400a3/g131. /g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g55 /g82/g83, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n= /g177. /g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g55 /g82/g83, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##49H7d5c40f4f2638829db6b707b7e9400a3/g131. /g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g37/g82/g87/g87/g82/g80,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g69. /g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g37/g82/g87/g87/g82/g80,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##49H7d5c40f4f2638829db6b707b7e9400a3/g131. /g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g37/g82/g87/g87/g82/g80,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g37/g82/g87/g87/g82/g80, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3/g131",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /g51/g76/g81/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g89/g76/g86",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g88/g68/g79/;#23#23#23/g76/g81/g71/g72/g91/;#23#23#23/g73/g72/g68/g87/g88/g85/g72/;#23#23#23/g80/g68/g92/;#23#23#23/g89/g68/g85/g92 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23/g69/g88/g87/;#23#23#23/g80/g88/g86/g87/;#23#23#23/g69/g72/;#23#23#23/g79/g82/g70/g68/g87/g72/g71/;#23#23#23/g90/g76/g87/g75/g76/g81/;#23#23#23/g87/g75/g72/;#23#23#23/g75/g68/g87/g70/g75/g72/g71/;#23#23#23/g68/g85/g72/g68/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g134/;#23#23#23/g54/g76/g74/g81/g76/g73/g76/g70/g68/g81/g87/;#23#23#23/g38/g75/g68/g85/g68/g70/g87/g72/g85/g76/g86/g87/g76/g70/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g86/;#23#23#23/g39/;#23#23#23/g68/g81/g71/;#23#23#23/g40/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g71/g82/;#23#23#23/g81/g82/g87/;#23#23#23/g76/g81/g70/g79/g88/g71/g72/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g80/g82/g79/g71/;#23#23#23/g73/g79/g68/g86/g75/;#23#23#23/g82/g85/;#23#23#23/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g48/g82/g79/g71/;#23#23#23/g73/g79/g68/g86/g75/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g82/g85/;#23#23#23/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/;#23#23#23/g86/g75/g68/g79/g79/;#23#23#23/g81/g82/g87/;#23#23#23/g72/g91/g70/g72/g72/g71/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23/g80/g80/;#23#23#23/g83/g72/g85/;#23#23#23/g86/g76/g71/g72/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g76/g81/g74/;#23#23#23/g68/g81/g71/;#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g76/g81/g74/;#23#23#23/g83/g72/g85/;#23#23#23/g36/g54/g48/g40/;#23#23#23/g60/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##49H7d5c40f4f2638829db6b707b7e9400a3/g48/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g54/g38/##58Hb981034091b194e41ef5193e7127dfd3",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g68/g86/g76/g70/;#23#23#23/g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g55/g75/g72/g82/g85/g72/g87/g76/g70/g68/g79/g79/g92/;#23#23#23/g72/g91/g68/g70/g87/;#23#23#23/g89/g68/g79/g88/g72/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g86/g75/g82/g90/g81/;#23#23#23/g90/g76/g87/g75/g82/g88/g87/;#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g72/g86/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/g53/g40/g41/##58Hb981034091b194e41ef5193e7127dfd3",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g53/g72/g73/g72/g85/g72/g81/g70/g72/;#23#23#23/g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g88/g86/g88/g68/g79/g79/g92/;#23#23#23/g90/g76/g87/g75/g82/g88/g87/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g72/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g73/g82/g85/;#23#23#23/g76/g81/g73/g82/g85/g80/g68/g87/g76/g82/g81/;#23#23#23/g83/g88/g85/g83/g82/g86/g72/g86/;#23#23#23/g82/g81/g79/g92",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g76/g70/g85/g82/g70/g75/g76/g83 /g55 /g72/g70/g75/g81/g82/g79/g82/g74/g92 /g39/g85/g68/g90/g76/g81/g74 /g38/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3 /##40He56442409eb2e77ad61dd1c271fabe6c /g37",
    "PIC18F2331/2431/4331/4431\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g49. /g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##40He56442409eb2e77ad61dd1c271fabe6c/##52H929f5141f4575eca8d5e4ef21356227f. /g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/##52H929f5141f4575eca8d5e4ef21356227f. /g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/##52H929f5141f4575eca8d5e4ef21356227f. /g51/g76/g87/g70/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g72. /g51/g76/g87/g70/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g54/g38. /g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##4CH2eb0c8ba15de4cce8fa3c169622f8e93/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23 /g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g36. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##55H86fa5259cb141e4f33f834c08eacfe53/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g36/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g36/##43Hd27e308598cf1f8bcf9e336036f3f448.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g53/g40/g41. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g53/g40/g41.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g53/g40/g41. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g40. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##4CH2eb0c8ba15de4cce8fa3c169622f8e93/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##4CH2eb0c8ba15de4cce8fa3c169622f8e93/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g40/##40He56442409eb2e77ad61dd1c271fabe6c.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##4CH2eb0c8ba15de4cce8fa3c169622f8e93/##49H7d5c40f4f2638829db6b707b7e9400a3. /g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /##43Hd27e308598cf1f8bcf9e336036f3f448",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g39. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##4CH2eb0c8ba15de4cce8fa3c169622f8e93/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g47/g72/g81/g74/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g39/##40He56442409eb2e77ad61dd1c271fabe6c.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##4CH2eb0c8ba15de4cce8fa3c169622f8e93/##49H7d5c40f4f2638829db6b707b7e9400a3. /g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /##43Hd27e308598cf1f8bcf9e336036f3f448",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g58/g76/g71/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g69. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/##43Hd27e308598cf1f8bcf9e336036f3f448.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/##49H7d5c40f4f2638829db6b707b7e9400a3. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g47. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3/##49H7d5c40f4f2638829db6b707b7e9400a3.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##4FHabe68123f3cb4e14e0d59c97044fedf7/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g87/g82/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g40/g91",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g46.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g87/g82/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g40/g91 /g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g87/g82/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g40/g91 /g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g87/g82/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g40/g91 /g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g177",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /g51/g76/g81/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g89/g76/g86",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g88/g68/g79/;#23#23#23/g76/g81/g71/g72/g91/;#23#23#23/g73/g72/g68/g87/g88/g85/g72/;#23#23#23/g80/g68/g92/;#23#23#23/g89/g68/g85/g92 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23/g69/g88/g87/;#23#23#23/g80/g88/g86/g87/;#23#23#23/g69/g72/;#23#23#23/g79/g82/g70/g68/g87/g72/g71/;#23#23#23/g90/g76/g87/g75/g76/g81/;#23#23#23/g87/g75/g72/;#23#23#23/g75/g68/g87/g70/g75/g72/g71/;#23#23#23/g68/g85/g72/g68/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g76/g86/;#23#23#23/g86/g68/g90/;#23#23#23/g86/g76/g81/g74/g88/g79/g68/g87/g72/g71/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g76/g81/g74/;#23#23#23/g68/g81/g71/;#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g76/g81/g74/;#23#23#23/g83/g72/g85/;#23#23#23/g36/g54/g48/g40/;#23#23#23/g60/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##49H7d5c40f4f2638829db6b707b7e9400a3/g48/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g54/g38/##58Hb981034091b194e41ef5193e7127dfd3",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g68/g86/g76/g70/;#23#23#23/g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g55/g75/g72/g82/g85/g72/g87/g76/g70/g68/g79/g79/g92/;#23#23#23/g72/g91/g68/g70/g87/;#23#23#23/g89/g68/g79/g88/g72/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g86/g75/g82/g90/g81/;#23#23#23/g90/g76/g87/g75/g82/g88/g87/;#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g72/g86/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/g53/g40/g41/##58Hb981034091b194e41ef5193e7127dfd3",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g53/g72/g73/g72/g85/g72/g81/g70/g72/;#23#23#23/g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g88/g86/g88/g68/g79/g79/g92/;#23#23#23/g90/g76/g87/g75/g82/g88/g87/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g72/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g73/g82/g85/;#23#23#23/g76/g81/g73/g82/g85/g80/g68/g87/g76/g82/g81/;#23#23#23/g83/g88/g85/g83/g82/g86/g72/g86/;#23#23#23/g82/g81/g79/g92",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/g48/g76/g70/g85/g82/g70/g75/g76/g83 /g55 /g72/g70/g75/g81/g82/g79/g82/g74/g92 /g39/g85/g68/g90/g76/g81/g74",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##49H7d5c40f4f2638829db6b707b7e9400a3/g37\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g134/;#23#23#23/g54/g76/g74/g81/g76/g73/g76/g70/g68/g81/g87/;#23#23#23/g38/g75/g68/g85/g68/g70/g87/g72/g85/g76/g86/g87/g76/g70/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g86/;#23#23#23/g39/;#23#23#23/g68/g81/g71/;#23#23#23/g40/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g71/g82/;#23#23#23/g81/g82/g87/;#23#23#23/g76/g81/g70/g79/g88/g71/g72/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g80/g82/g79/g71/;#23#23#23/g73/g79/g68/g86/g75/;#23#23#23/g82/g85/;#23#23#23/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g48/g82/g79/g71/;#23#23#23/g73/g79/g68/g86/g75/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g82/g85/;#23#23#23/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/;#23#23#23/g86/g75/g68/g79/g79/;#23#23#23/g81/g82/g87/;#23#23#23/g72/g91/g70/g72/g72/g71/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23/;#23#23#23/g83/g72/g85/;#23#23#23/g86/g76/g71/g72/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g76/g81/g74/;#23#23#23/g68/g81/g71/;#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g76/g81/g74/;#23#23#23/g83/g72/g85/;#23#23#23/g36/g54/g48/g40/;#23#23#23/g60/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##49H7d5c40f4f2638829db6b707b7e9400a3/g48/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g54/g38/##58Hb981034091b194e41ef5193e7127dfd3",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g68/g86/g76/g70/;#23#23#23/g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g55/g75/g72/g82/g85/g72/g87/g76/g70/g68/g79/g79/g92/;#23#23#23/g72/g91/g68/g70/g87/;#23#23#23/g89/g68/g79/g88/g72/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g86/g75/g82/g90/g81/;#23#23#23/g90/g76/g87/g75/g82/g88/g87/;#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g72/g86/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g76/g70/g85/g82/g70/g75/g76/g83 /g55 /g72/g70/g75/g81/g82/g79/g82/g74/g92 /g39/g85/g68/g90/g76/g81/g74",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##4CH2eb0c8ba15de4cce8fa3c169622f8e93/g37",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g47/g72/g68/g71/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g49.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g47/g72/g68/g71/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##46H7a539460a8268e5915c0973dbb05dce1/##46H7a539460a8268e5915c0973dbb05dce1.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g47/g72/g68/g71/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /##46H7a539460a8268e5915c0973dbb05dce1/##46H7a539460a8268e5915c0973dbb05dce1.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g47/g72/g68/g71/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /##46H7a539460a8268e5915c0973dbb05dce1/##46H7a539460a8268e5915c0973dbb05dce1. /g47/g72/g68/g71/;#23#23#23/g51/g76/g87/g70/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g72. /g47/g72/g68/g71/;#23#23#23/g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g37/g54/g38. /g47/g72/g68/g71/;#23#23#23/g51/g76/g87/g70/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g47/g72/g68/g71/;#23#23#23/g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g36. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /g177.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g36/##40He56442409eb2e77ad61dd1c271fabe6c. /g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##55H86fa5259cb141e4f33f834c08eacfe53/##49H7d5c40f4f2638829db6b707b7e9400a3.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23/;#23#23#23,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g36/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23/;#23#23#23,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23/;#23#23#23, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23/;#23#23#23, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3. /g41/g82/g82/g87/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g47. /g41/g82/g82/g87/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##46H7a539460a8268e5915c0973dbb05dce1/##49H7d5c40f4f2638829db6b707b7e9400a3. /g41/g82/g82/g87/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g41/g82/g82/g87/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##4FHabe68123f3cb4e14e0d59c97044fedf7/##49H7d5c40f4f2638829db6b707b7e9400a3. /g41/g82/g82/g87/g83/g85/g76/g81/g87, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g47/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g41/g82/g82/g87/g83/g85/g76/g81/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g53/g40/g41. /g41/g82/g82/g87/g83/g85/g76/g81/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g53/g40/g41.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g41/g82/g82/g87/g83/g85/g76/g81/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g53/g40/g41. /g41/g82/g82/g87/;#23#23#23/g36/g81/g74/g79/g72, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g73.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g41/g82/g82/g87/;#23#23#23/g36/g81/g74/g79/g72, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /g131. /g41/g82/g82/g87/;#23#23#23/g36/g81/g74/g79/g72,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3/g131. /g41/g82/g82/g87/;#23#23#23/g36/g81/g74/g79/g72,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /##4FHabe68123f3cb4e14e0d59c97044fedf7/g131. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g40. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g39. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38. /g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g40/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g47/g72/g81/g74/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g39/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23/g37/g54/g38. /g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/g72/g71/;#23#23#23/g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23/g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g47/g72/g68/g71/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g70. /g47/g72/g68/g71/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##55H86fa5259cb141e4f33f834c08eacfe53.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g47/g72/g68/g71/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177. /g47/g72/g68/g71/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g69. /g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/##4FHabe68123f3cb4e14e0d59c97044fedf7.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g47/g72/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##46H7a539460a8268e5915c0973dbb05dce1/##49H7d5c40f4f2638829db6b707b7e9400a3. /g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g55 /g82/g83,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g68. /g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g55 /g82/g83,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /g131.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g55 /g82/g83, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/g131.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g55 /g82/g83, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/g131.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g37/g82/g87/g87/g82/g80, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g69.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g37/g82/g87/g87/g82/g80, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /g131. /g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g37/g82/g87/g87/g82/g80, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/g131. /g48/g82/g79/g71/;#23#23#23/g39/g85/g68/g73/g87/;#23#23#23/g36/g81/g74/g79/g72/;#23#23#23/g37/g82/g87/g87/g82/g80,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/g131",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /g51/g76/g81/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g89/g76/g86",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g88/g68/g79/;#23#23#23/g76/g81/g71/g72/g91/;#23#23#23/g73/g72/g68/g87/g88/g85/g72/;#23#23#23/g80/g68/g92/;#23#23#23/g89/g68/g85/g92 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23/g69/g88/g87/;#23#23#23/g80/g88/g86/g87/;#23#23#23/g69/g72/;#23#23#23/g79/g82/g70/g68/g87/g72/g71/;#23#23#23/g90/g76/g87/g75/g76/g81/;#23#23#23/g87/g75/g72/;#23#23#23/g75/g68/g87/g70/g75/g72/g71/;#23#23#23/g68/g85/g72/g68/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g75/g68/g80/g73/g72/g85/g86/;#23#23#23/g68/g87/;#23#23#23/g70/g82/g85/g81/g72/g85/g86/;#23#23#23/g68/g85/g72/;#23#23#23/g82/g83/g87/g76/g82/g81/g68/g79/##5BH40500acfd45bb67052e9c43dd051a0f4/;#23#23#23/g86/g76/g93/g72/;#23#23#23/g80/g68/g92/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g89/g68/g85/g92\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g86/;#23#23#23/g39/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g68/g81/g71/;#23#23#23/g40/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g71/g82/;#23#23#23/g81/g82/g87/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g76/g81/g70/g79/g88/g71/g72/;#23#23#23/g80/g82/g79/g71/;#23#23#23/g73/g79/g68/g86/g75/;#23#23#23/g82/g85/;#23#23#23/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g48/g82/g79/g71/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g73/g79/g68/g86/g75/;#23#23#23/g82/g85/;#23#23#23/g83/g85/g82/g87/g85/g88/g86/g76/g82/g81/g86/;#23#23#23/g86/g75/g68/g79/g79/;#23#23#23/g81/g82/g87/;#23#23#23/g72/g91/g70/g72/g72/g71/;#23#23#23/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##40He56442409eb2e77ad61dd1c271fabe6c/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23/g80/g80/;#23#23#23/g83/g72/g85/;#23#23#23/g86/g76/g71/g72/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g76/g81/g74/;#23#23#23/g68/g81/g71/;#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g76/g81/g74/;#23#23#23/g83/g72/g85/;#23#23#23/g36/g54/g48/g40/;#23#23#23/g60/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##49H7d5c40f4f2638829db6b707b7e9400a3/g48/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g54/g38/##58Hb981034091b194e41ef5193e7127dfd3",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g68/g86/g76/g70/;#23#23#23/g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g55/g75/g72/g82/g85/g72/g87/g76/g70/g68/g79/g79/g92/;#23#23#23/g72/g91/g68/g70/g87/;#23#23#23/g89/g68/g79/g88/g72/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g86/g75/g82/g90/g81/;#23#23#23/g90/g76/g87/g75/g82/g88/g87/;#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g72/g86/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/g53/g40/g41/##58Hb981034091b194e41ef5193e7127dfd3",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g53/g72/g73/g72/g85/g72/g81/g70/g72/;#23#23#23/g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g88/g86/g88/g68/g79/g79/g92/;#23#23#23/g90/g76/g87/g75/g82/g88/g87/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g72/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g73/g82/g85/;#23#23#23/g76/g81/g73/g82/g85/g80/g68/g87/g76/g82/g81/;#23#23#23/g83/g88/g85/g83/g82/g86/g72/g86/;#23#23#23/g82/g81/g79/g92",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g76/g70/g85/g82/g70/g75/g76/g83 /g55 /g72/g70/g75/g81/g82/g79/g82/g74/g92 /g39/g85/g68/g90/g76/g81/g74 /g38/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4FHabe68123f3cb4e14e0d59c97044fedf7 /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/g37",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g49. /g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##46H7a539460a8268e5915c0973dbb05dce1/##46H7a539460a8268e5915c0973dbb05dce1. /g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##46H7a539460a8268e5915c0973dbb05dce1/##46H7a539460a8268e5915c0973dbb05dce1. /g49/g88/g80/g69/g72/g85/;#23#23#23/g82/g73/;#23#23#23/g51/g76/g81/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##46H7a539460a8268e5915c0973dbb05dce1/##46H7a539460a8268e5915c0973dbb05dce1. /g51/g76/g87/g70/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g72. /g51/g76/g87/g70/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g54/g38. /g51/g76/g87/g70/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##4CH2eb0c8ba15de4cce8fa3c169622f8e93/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23 /g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g36. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##55H86fa5259cb141e4f33f834c08eacfe53/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g43/g72/g76/g74/g75/g87, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g36/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c. /g54/g87/g68/g81/g71/g82/g73/g73/;#23#23#23, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##49H7d5c40f4f2638829db6b707b7e9400a3.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g36/##43Hd27e308598cf1f8bcf9e336036f3f448.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g53/g40/g41. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g53/g40/g41.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g55/g75/g76/g70/g78/g81/g72/g86/g86, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23 /g53/g40/g41. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g40. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g40/##40He56442409eb2e77ad61dd1c271fabe6c.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##4CH2eb0c8ba15de4cce8fa3c169622f8e93 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##46H7a539460a8268e5915c0973dbb05dce1/##49H7d5c40f4f2638829db6b707b7e9400a3. /g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g39. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g37/g54/g38. /g50/g89/g72/g85/g68/g79/g79/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23 /g37/g54/g38.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g47/g72/g81/g74/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g39/##40He56442409eb2e77ad61dd1c271fabe6c.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##4CH2eb0c8ba15de4cce8fa3c169622f8e93 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##46H7a539460a8268e5915c0973dbb05dce1/##49H7d5c40f4f2638829db6b707b7e9400a3. /g40/g91/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /##4CH2eb0c8ba15de4cce8fa3c169622f8e93/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##52H929f5141f4575eca8d5e4ef21356227f/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g58/g76/g71/g87/g75, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g69. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g58/g76/g71/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/##49H7d5c40f4f2638829db6b707b7e9400a3.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g58/g76/g71/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/##52H929f5141f4575eca8d5e4ef21356227f. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g47. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g47/g72/g81/g74/g87/g75,",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23/g47/g72/g81/g74/g87/g75, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##49H7d5c40f4f2638829db6b707b7e9400a3/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23. /g38/g82/g81/g87/g68/g70/g87/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g87/g82/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g40/g91",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71, /g56/g81/g76/g87/g86./g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23/g47/g76/g80/g76/g87/g86 = /g46.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g87/g82/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g40/g91 /g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g44/g49 =",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g87/g82/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g40/g91 /g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g49/g50/g48 = /g177.",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/g82/g81/g87/g68/g70/g87/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g87/g82/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/g40/g91 /g83/g82/g86/g72/g71/;#23#23#23/g51/g68/g71, /g48/g44/g47/g47/g44/g48/g40/g55/g40/g53/g54./g48/g36/g59 = /g177",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /g51/g76/g81/;#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g89/g76/g86",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g88/g68/g79/;#23#23#23/g76/g81/g71/g72/g91/;#23#23#23/g73/g72/g68/g87/g88/g85/g72/;#23#23#23/g80/g68/g92/;#23#23#23/g89/g68/g85/g92 /;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23/g69/g88/g87/;#23#23#23/g80/g88/g86/g87/;#23#23#23/g69/g72/;#23#23#23/g79/g82/g70/g68/g87/g72/g71/;#23#23#23/g90/g76/g87/g75/g76/g81/;#23#23#23/g87/g75/g72/;#23#23#23/g75/g68/g87/g70/g75/g72/g71/;#23#23#23/g68/g85/g72/g68/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##40He56442409eb2e77ad61dd1c271fabe6c/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23 /g51/g68/g70/g78/g68/g74/g72/;#23#23#23/g76/g86/;#23#23#23/g86/g68/g90/;#23#23#23/g86/g76/g81/g74/g88/g79/g68/g87/g72/g71/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/##43Hd27e308598cf1f8bcf9e336036f3f448/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g39/g76/g80/g72/g81/g86/g76/g82/g81/g76/g81/g74/;#23#23#23/g68/g81/g71/;#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g76/g81/g74/;#23#23#23/g83/g72/g85/;#23#23#23/g36/g54/g48/g40/;#23#23#23/g60/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##49H7d5c40f4f2638829db6b707b7e9400a3/g48/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g54/g38/##58Hb981034091b194e41ef5193e7127dfd3",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g37/g68/g86/g76/g70/;#23#23#23/g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g55/g75/g72/g82/g85/g72/g87/g76/g70/g68/g79/g79/g92/;#23#23#23/g72/g91/g68/g70/g87/;#23#23#23/g89/g68/g79/g88/g72/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g86/g75/g82/g90/g81/;#23#23#23/g90/g76/g87/g75/g82/g88/g87/;#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g72/g86/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/g53/g40/g41/##58Hb981034091b194e41ef5193e7127dfd3",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g53/g72/g73/g72/g85/g72/g81/g70/g72/;#23#23#23/g39/g76/g80/g72/g81/g86/g76/g82/g81/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g88/g86/g88/g68/g79/g79/g92/;#23#23#23/g90/g76/g87/g75/g82/g88/g87/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23/g87/g82/g79/g72/g85/g68/g81/g70/g72/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23/g73/g82/g85/;#23#23#23/g76/g81/g73/g82/g85/g80/g68/g87/g76/g82/g81/;#23#23#23/g83/g88/g85/g83/g82/g86/g72/g86/;#23#23#23/g82/g81/g79/g92",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23\n/g48/g76/g70/g85/g82/g70/g75/g76/g83 /g55 /g72/g70/g75/g81/g82/g79/g82/g74/g92 /g39/g85/g68/g90/g76/g81/g74",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n/g38/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##46H7a539460a8268e5915c0973dbb05dce1/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;",
    "/g49/g82/g87/g72/g86/##58Hb981034091b194e41ef5193e7127dfd3\n#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23/##43Hd27e308598cf1f8bcf9e336036f3f448/g37",
    "Revision A (June 2003)\nOriginal  data  sheet  for  PIC18F2331/2431/4331/4431 devices.",
    "Revision B (December 2003)\nThe Electrical Specifications in Section 26.0 'Electrical  Characteristics' have  been  updated  and  there have been minor corrections to the data sheet text.",
    "Revision C (June 2007)\nThe data sheet has been updated with all known Data Sheet Errata items and there have been minor corrections  made  to  the  data  sheet  text.  Also,  the packaging diagrams have been updated in Section 27.0 'Packaging Information' .\nSection 2.0  'Guidelines  for  Getting  Started  with PIC18F  Microcontrollers' has  been  updated  with more detailed explanations. Changes have been made to the port summary  tables  in Section 11.0  'I/O Ports' . Section 26.0  'Electrical Characteristics' has  been  updated  to  include  extended  temperature data.  Packaging  diagrams  have  been  replaced  with new diagrams in Section 27.0 'Packaging Information' . There have  been  minor  text edits throughout the document.",
    "APPENDIX B: DEVICE DIFFERENCES\nThe differences between the devices listed in this data sheet are shown in Table B-1.",
    "TABLE B-1: DEVICE DIFFERENCES\nProgram Memory (Bytes), PIC18F2331 = 4096. Program Memory (Bytes), PIC18F2431 = 8192. Program Memory (Bytes), PIC18F4331 = 4096. Program Memory (Bytes), PIC18F4431 = 8192. Program Memory (Instructions), PIC18F2331 = 2048. Program Memory (Instructions), PIC18F2431 = 4096. Program Memory (Instructions), PIC18F4331 = 2048. Program Memory (Instructions), PIC18F4431 = 4096. Interrupt Sources, PIC18F2331 = 22. Interrupt Sources, PIC18F2431 = 22. Interrupt Sources, PIC18F4331 = 34. Interrupt Sources, PIC18F4431 = 34. I/O Ports, PIC18F2331 = Ports A, B, C, D, E. I/O Ports, PIC18F2431 = Ports A, B, C, D, E. I/O Ports, PIC18F4331 = Ports A, B, C, D, E. I/O Ports, PIC18F4431 = Ports",
    "TABLE B-1: DEVICE DIFFERENCES\nA, B, C, D, E. Capture/Compare/PWM Modules, PIC18F2331 = 2. Capture/Compare/PWM Modules, PIC18F2431 = 2. Capture/Compare/PWM Modules, PIC18F4331 = 2. Capture/Compare/PWM Modules, PIC18F4431 = 2. Enhanced Capture/Compare/ PWM Modules, PIC18F2331 = 1. Enhanced Capture/Compare/ PWM Modules, PIC18F2431 = 1. Enhanced Capture/Compare/ PWM Modules, PIC18F4331 = 1. Enhanced Capture/Compare/ PWM Modules, PIC18F4431 = 1. 10-Bit Analog-to-Digital Module, PIC18F2331 = 5 Input Channels. 10-Bit Analog-to-Digital Module, PIC18F2431 = 5 Input Channels. 10-Bit Analog-to-Digital Module, PIC18F4331 = 9 Input Channels. 10-Bit Analog-to-Digital Module, PIC18F4431 = 9 Input Channels. Packages, PIC18F2331 = 28-Pin SPDIP 28-Pin SOIC",
    "TABLE B-1: DEVICE DIFFERENCES\n28-Pin QFN. Packages, PIC18F2431 = 28-Pin SPDIP 28-Pin SOIC 28-Pin QFN. Packages, PIC18F4331 = 40-Pin PDIP 44-Pin TQFP 44-Pin QFN. Packages, PIC18F4431 = 40-Pin PDIP 44-Pin TQFP 44-Pin QFN",
    "APPENDIX C: CONVERSION CONSIDERATIONS\nThis appendix discusses the considerations for converting  from  previous  versions  of  a  device  to  the ones listed in this data sheet. Typically, these changes are due to the differences in the process technology used. An example of this type of conversion is from a PIC16C74A to a PIC16C74B.\nNot Applicable\nAPPENDIX D:\nMIGRATION FROM BASELINE TO ENHANCED DEVICES\nThis section discusses how to migrate from a baseline device (i.e., PIC16C5X) to an enhanced MCU device (i.e., PIC18FXXX).\nThe  following  are  the  list  of  modifications  over  the PIC16C5X microcontroller family:\nNot Currently Available",
    "PIC18F2331/2431/4331/4431\nAPPENDIX E:",
    "MIGRATION FROM MID-RANGE TO ENHANCED DEVICES\nAPPENDIX F:",
    "MIGRATION FROM HIGH-END TO ENHANCED DEVICES\nA detailed  discussion of the  differences between  the mid-range  MCU  devices  (i.e.,  PIC16CXXX)  and  the enhanced  devices  (i.e.,  PIC18FXXX)  is  provided  in AN716,  'Migrating  Designs  from  PIC16C74A/74B  to PIC18F442.'  The  changes  discussed,  while  devicespecific,  are  generally  applicable  to  all  mid-range  to enhanced device migrations.\nThis Application Note  is available on  Microchip's web site: www.Microchip.com.\nA  detailed  discussion  of  the  migration  pathway  and differences between the high-end MCU devices (i.e., PIC17CXXX) and the enhanced devices (i.e., PIC18FXXX)  is  provided  in  AN726,  'PIC17CXXX  to PIC18FXXX Migration.'\nThis Application Note  is available on  Microchip's web site: www.Microchip.com.",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "A\nA/D...................................................................................., 1 = 239. Acquisition Requirements ......................................... ................................................, 1 = 249. Associated Registers, 1 = 255. Calculating the Minimum Required, 1 = . Acquisition Time ..............................................., 1 =",
    "A\n250. Configuring................................................................, 1 = 247. Configuring Analog Port Pins...................................., 1 = 252. Conversions.............................................................., 1 = 253. Converter Characteristics ........................................., 1 = 361. Operation in Power-Managed",
    "A\nModes......................., 1 = 252. Result Buffer, 1 = ............................................................. 249. Selecting and Configuring Automatic, 1 = . Acquisition Time ..............................................., 1 = 251. Selecting the Conversion Clock................................, 1 = 251. Special Event Trigger (CCP)....................................., 1 = 147. Voltage References",
    "A\n.................................................., 1 = 251. Absolute Maximum Ratings .............................................., 1 = 329. (Timing) Characteristics, 1 = 344. AC .............................................. Load Conditions for Device, 1 = . Timing Specifications........................................, 1 = 345. Parameter Symbology, 1 =",
    "A\n.............................................. 344. Temperature and Voltage Specifications.................., 1 = 345. Timing Conditions ....................................................., 1 = 345. ACK Pulse................................................................., 1 = 212, 214 289.",
    "A\nADDLW............................................................................., 1 = 289. ADDWF............................................................................., 1 = ADDWFC.......................................................................... 290. Analog-to-Digital Converter.",
    "A\nSee A/D., 1 = . ANDLW............................................................................., 1 = 290. ANDWF............................................................................., 1 = 291. Application Notes, 1 = . AN578 (Use of the SSP Module in the I 2 C Multi-Master Environment) ........................., 1 = 205. Assembler MPASM, 1 = 326.",
    "A\nAssembler................................................... Auto-Wake-up on Sync Break Character.........................., 1 = 231. B, 1 = . BC....................................................................................., 1 = 291.",
    "A\nBCF..................................................................................., 1 = 292. BF Bit, 1 = ................................................................................ 206.",
    "A\nA/D............................................................................, 1 = 246. Analog Input Model..................................................., 1 = 250. Capture Mode Operation, 1 = .......................................... 146. Center Connected Load............................................, 1 = 194. Compare Mode Operation",
    "A\n........................................, 1 = 147. Dead-Time Control Unit for One, 1 = . PWM Output Pair.............................................., 1 = 191. EUSART Receive, 1 = ..................................................... 229. EUSART Transmit, 1 = .................................................... 227. External Clock Input,",
    "A\nEC............................................., 1 = 31. External Components for Timer1 LP Oscillator........., 1 = 133. External Power-on Reset Circuit (Slow VDD Power-up).........................................., 1 = 49. Fail-Safe Clock Monitor............................................., 1 = . Generic I/O Port........................................................, 1 = 277",
    "A\n113. Input Capture for IC1, 1 = 153. ................................................ Input Capture for IC2 and IC3..................................., 1 = 154. Interrupt Logic............................................................., 1 = 98. Low-Voltage Detect with External Input...................., 1 = 258. Motion Feedback Module.........................................., 1",
    "A\n= 152\nOn-Chip Reset Circuit................................................., 1 = 47. PIC18F2331/2431, 1 = ...................................................... 14. PIC18F4331/4431 ......................................................, 1 = 15. PLL, 1 =",
    "A\n............................................................................. 30. Power Control PWM Module, 1 = .................................... 174. PWM (Standard)......................................................., 1 = 149. PWM I/O",
    "A\nPin............................................................., 1 = 198. PWM Module, One Output Pair, Complementary Mode...................................... PWM Module, One Output Pair,, 1 = 175. Independent Mode ........................................... Base......................................................., 1 = 175. PWM Time, 1 = 177. QEI",
    "A\n..........................................................................., 1 = 161. RC Oscillator, 1 = .............................................................. 31. RCIO Oscillator..........................................................., 1 = 31. Reads from Flash Program Memory .........................., 1",
    "A\n= 89. Recommended Minimum Connections......................., 1 = 25. SSP (I 2 C Mode)........................................................, 1 = 212. SSP (SPI Mode), 1 = ....................................................... 209. System Clock.............................................................., 1 = 35. Table Read Operation, 1 =",
    "A\n................................................ 85. Table Write Operation ................................................, 1 = 86. Table Writes to Flash Program Memory....................., 1 = 91. Timer0 in 16-Bit Mode, 1 = .............................................. 128. Timer0 in 8-Bit Mode................................................, 1 =",
    "A\n128. Timer1 ......................................................................, 1 = 132 132. Timer1 (16-Bit Read/Write Mode)............................., 1 = ...................................................................... 137. Timer2 Timer5, 1 =",
    "A\n...................................................................... 140. Velocity Measurement.............................................. Timer ......................................................., 1 = 167. Watchdog, 1 = 274.",
    "A\nBN..................................................................................... BNC.................................................................................., 1 = 292. , 1 = 293.",
    "A\nBNN.................................................................................., 1 = 293. BNOV ............................................................................... BNZ, 1 = 294 294. BOR. See Brown-out Reset., 1 = 297.",
    "A\nBOV.................................................................................. BRA .................................................................................., 1 = 295. Brown-out Reset (BOR)..............................................",
    "A\nBSF..................................................................................., 1 = 49, 263 295. BTFSC.............................................................................., 1 = 296.",
    "A\nBTFSS.............................................................................., 1 = 296. BTG .................................................................................., 1 = 297.",
    "A\nBZ....................................................................................., 1 = . , 1 = 298. C, 1 = . MPLAB, 1 = C18.............................................................. 326 298. Capture (CCP Module) Associated Registers................................................ CCP Pin, 1 =",
    "A\n..................................................... 146 148. Configuration ............................................. CCPR1H:CCPR1L Registers, 1 = 146. Prescaler, 1 = ................................... 146. .................................................................., 1 = 146. Software Interrupt",
    "A\n....................................................., 1 = 146. Timer1 Mode Selection............................................., 1 = 146. Capture/Compare/PWM (CCP), 1 = . ........................................ Capture Mode. See Capture. CCP1........................................................................, 1 = 145. , 1",
    "A\n= 145. CCPR1H Register, 1 = ............................................ 145. CCPR1L Register............................................., 1 = 145",
    "PIC18F2331/2431/4331/4431\nCCP2, 1 = ........................................................................ 145. CCPR2H Register............................................., 1 = 145. CCPR2L Register ............................................., 1 = 145. Compare Mode. See Compare. Timer",
    "PIC18F2331/2431/4331/4431\nResources......................................................., 1 = 145. CKE Bit.............................................................................., 1 = 206. CKP Bit.............................................................................., 1 = 207. Clock",
    "PIC18F2331/2431/4331/4431\nSources....................................................................., 1 = 34. Effects of Power-Managed Modes.............................., 1 = 37. Selection Using OSCCON Register............................, 1 = 34. Clocking Scheme/Instruction Cycle....................................., 1 = 65.",
    "PIC18F2331/2431/4331/4431\nCLRF................................................................................. CLRWDT..........................................................................., 1 = 299 299. Code Examples, 1 = . Changing Between Capture Prescalers...................., 1 = 146. Computed GOTO Using an Offset Value...................., 1 = 64. Data EEPROM Read",
    "PIC18F2331/2431/4331/4431\n.................................................., 1 = 81. Data EEPROM Refresh Routine................................., 1 = 82. Data EEPROM Write .................................................., 1 = 81. Erasing a Flash Program Memory Row......................, 1 = 90. Fast Register",
    "PIC18F2331/2431/4331/4431\nStack....................................................., 1 = 64. How to Clear RAM (Bank 1) Using Indirect Addressing ............................................., 1 = 75. Implementing a Real-Time Clock Using a Timer1 Interrupt Service ..................................., 1 = 135. Initializing PORTA..................................................... Initializing, 1 = 113",
    "PIC18F2331/2431/4331/4431\nPORTB..................................................... 116. Initializing PORTC....................................................., 1 = 119. Initializing PORTD....................................................., 1 = 122. Initializing PORTE....................................................., 1 = 124.",
    "PIC18F2331/2431/4331/4431\nReading a Flash Program Memory Word, 1 = ................... 89. Saving STATUS, WREG and BSR RAM.............................................., 1 = 112. Registers in Writing to Flash Program Memory ........................, 1 = 93-94. 16 x 16 Signed Multiply Routine, 1 = ................................. 96. 16 x 16 Unsigned Multiply Routine 8 x 8 Signed Multiply Routine ....................................., 1 =",
    "PIC18F2331/2431/4331/4431\n............................. 96. 8 x 8 Unsigned Multiply Routine, 1 = 95. , 1 = ................................. 95. Code Protection ........................................................, 1 = 263, 279. Associated Registers, 1 = ................................................ 279. Data",
    "PIC18F2331/2431/4331/4431\nEEPROM.........................................................., 1 = 282. Program Memory, 1 = ...................................................... 280. COMF................................................................................ Compare (CCP",
    "PIC18F2331/2431/4331/4431\nModule)...................................................., 1 = 300 147. Associated Registers, 1 = 148. ................................................ CCP Pin Configuration.............................................., 1 = 147. CCPR1 Register CCPR2 Register, 1 = ....................................................... 147.",
    "PIC18F2331/2431/4331/4431\n....................................................... Interrupt, 1 = 147 147. Software Mode, 1 = ............................................ Special Event Trigger................................................ Timer1 Mode Selection, 1 = 147 147. Configuration Bits.............................................................., 1 =",
    "PIC18F2331/2431/4331/4431\n............................................. 263. Configuration Register Protection, 1 = ..................................... 282. Conversion Considerations............................................... CPFSEQ ..........................................................................., 1 = 376. , 1 = 300 301.",
    "PIC18F2331/2431/4331/4431\nCPFSGT............................................................................ CPFSLT, 1 = 301. ............................................................................ Crystal Oscillator/Ceramic Resonators, 1 = ............................... 29 387. Customer Change Notification Service, 1 =",
    "PIC18F2331/2431/4331/4431\n............................. 387. Customer Notification Service........................................... Support............................................................., 1 = . Customer, 1 = 387",
    "D\nData Addressing Modes, 206 = ..................................................... 75. Direct, 206 = .......................................................................... 75. Indirect........................................................................, 206 = 75. Inherent and",
    "D\nLiteral....................................................., 206 = 75. Data EEPROM Memory......................................................, 206 = 79. Associated Registers.................................................., 206 = 83. EEADR Register........................................................., 206 = 79. EECON1 and EECON2",
    "D\nRegisters.............................., 206 = 79. Operation During Code-Protect .................................., 206 = 82. Protection Against Spurious Write.............................., 206 = 81. Reading, 206 = ...................................................................... 81. Using",
    "D\n.........................................................................., 206 = 82. Write Verify ................................................................., 206 = 81. Writing, 206 = ........................................................................ 81. Data Memory, 206 =",
    "D\n...................................................................... 67. Access Bank..............................................................., 206 = 68. Bank Select Register (BSR) ......................................., 206 = 68. General Purpose Register (GPR) File ........................, 206 = 68. Map for PIC18F2331/2431/4331/4431, 206 =",
    "D\n....................... 67. Special Function Registers (SFRs)............................., 206 = 69. DAW ................................................................................. DC Characteristics............................................................, 206 = 302 339. Power-Down and Supply Current, 206 = .............................",
    "D\n332. Supply Voltage ........................................................., 206 = 331. DCFSNZ..........................................................................., 206 = 303. DECF................................................................................, 206 = 302. DECFSZ",
    "D\n..........................................................................., 206 = 303. Development Support......................................................., 206 = 325. Device Differences............................................................, 206 = 375. Device",
    "D\nOverview................................................................., 206 = 11. Features (table), 206 = .......................................................... 13. New Core Features....................................................., 206 = 11. Other Special Features..............................................., 206 = 12. Device",
    "D\nReset Timers, 206 = . Oscillator Start-up Timer PLL Lock Time-out......................................................, 206 = (OST).................................. 50 50. Power-up Timer (PWRT)............................................, 206 = 50. Time-out Sequence ...................................................., 206 = 50. Direct Addressing, 206 =",
    "D\n............................................................... 76. E, 206 = . Electrical Characteristics .................................................., 206 = 329. Enhanced Universal Synchronous Asynchronous Receiver Transmitter (EUSART) .............................., 206 = 217. Equations, 206 = . A/D Acquisition Time ................................................, 206 = 249. Conversion Time for Multi-Channel Modes",
    "D\n.............., 206 = 254. Minimum A/D Holding Capacitor Charging Time......, 206 = 249. PWM Period for Free-Running Mode ......................., 206 = 185. PWM Period for Up/Down Count Mode...................., 206 = 185. PWM Resolution......................................................., 206 = 185. 16 x 16 Signed Multiplication Algorithm......................, 206 = 96. 16 x 16 Unsigned Multiplication Algorithm.................. Errata",
    "D\n...................................................................................., 206 = 96 9",
    "PIC18F2331/2431/4331/4431\nEUSART\nAssociated Registers, Receive........................., Mode................................................. 226 = 230. Associated Registers, Transmit, Mode................................................. 226 = ........................ 228. Auto-Wake-up on Sync Break ..........................,",
    "PIC18F2331/2431/4331/4431\nMode................................................. 226 = 231. Receiver............................................................, Mode................................................. 226 = 229. Receiving a Break Character............................,",
    "PIC18F2331/2431/4331/4431\nMode................................................. 226 = 232. Setting Up 9-Bit Mode with Address Detect......, Mode................................................. 226 = 229. Transmitter........................................................, Mode................................................. 226 = 226. 12-Bit Break Character",
    "PIC18F2331/2431/4331/4431\nSequence...................., Mode................................................. 226 = 232. Baud Rate Generator (BRG)....................................., Mode................................................. 226 = 221. Associated Registers, Mode................................................. 226 =",
    "PIC18F2331/2431/4331/4431\n........................................ 222. Auto-Baud Rate Detect....................................., Mode................................................. 226 = 225. Baud Rate Error, Calculating ............................, Mode................................................. 226 = 222. Baud Rates, Asynchronous Modes,",
    "PIC18F2331/2431/4331/4431\nMode................................................. 226 = .................. 222. High Baud Rate Select (BRGH Bit), Mode................................................. 226 = .................. 221. Power-Managed Mode Operation....................., Mode................................................. 226 = 221.",
    "PIC18F2331/2431/4331/4431\nSampling..........................................................., Mode................................................. 226 = 221. Serial Port Enable (SPEN Bit)..................................., Mode................................................. 226 = 217. Synchronous Master",
    "PIC18F2331/2431/4331/4431\nMode......................................., Mode................................................. 226 = 233. Associated Registers, Receive........................., Mode................................................. 226 = 236. Associated Registers, Transmit, Mode................................................. 226 =",
    "PIC18F2331/2431/4331/4431\n........................ 234. Reception.........................................................., Mode................................................. 226 = 235. Transmission ....................................................,",
    "PIC18F2331/2431/4331/4431\nMode................................................. 226 = 233. Synchronous Slave Mode......................................... Associated Registers,, Mode................................................. 226 = 237 238. Associated Registers, Transmit, Mode................................................. 226 = ........................",
    "PIC18F2331/2431/4331/4431\n237. Reception.........................................................., Mode................................................. 226 = 238. Transmission, Mode................................................. 226 = 237. Clock Input............................................................,",
    "PIC18F2331/2431/4331/4431\nMode................................................. 226 = ..................................................... External, Mode................................................. 226 = 31. F, Mode................................................. 226 = . Fail-Safe Clock",
    "PIC18F2331/2431/4331/4431\nMonitor............................................., Mode................................................. 226 = 263, 277. Exiting ......................................................................., Mode................................................. 226 = 277. Interrupts in Power-Managed",
    "PIC18F2331/2431/4331/4431\nModes........................, Mode................................................. 226 = 278. POR or Wake From Sleep ........................................, Mode................................................. 226 = 278. WDT During Oscillator Failure, Mode................................................. 226 =",
    "PIC18F2331/2431/4331/4431\n.................................. 277. Fail-Safe Clock Monitor Fast, Mode................................................. 226 = (FSCM)....................................... 263. Register Stack............................................................. Flash Program Memory,",
    "PIC18F2331/2431/4331/4431\nMode................................................. 226 = 64 ...................................................... 85. Associated Registers, Mode................................................. 226 = .................................................. 94. Control Registers,",
    "PIC18F2331/2431/4331/4431\nMode................................................. 226 = ........................................................ 86. EECON1 and EECON2, Mode................................................. 226 = ...................................... 86. Erase Sequence",
    "PIC18F2331/2431/4331/4431\n........................................................., Mode................................................. 226 = 90. Erasing........................................................................, Mode................................................. 226 = 90. Operation",
    "PIC18F2331/2431/4331/4431\nDuring Code-Protect, Mode................................................. 226 = .................................. 94. Reading......................................................................., Mode................................................. 226 = 89. TABLAT",
    "PIC18F2331/2431/4331/4431\nRegister........................................................, Mode................................................. 226 = 88. Table Pointer..............................................................., Mode................................................. 226 = 88. Boundaries Based on",
    "PIC18F2331/2431/4331/4431\nOperation......................... ..........................................., Mode................................................. 226 = 88 88. Table Pointer Boundaries Table Reads and Table Writes, Mode................................................. 226 = 85. ...................................,",
    "PIC18F2331/2431/4331/4431\nMode................................................. 226 = . Unexpected Termination of Write Operation..............., Mode................................................. 226 = 94. Write Sequence, Mode................................................. 226 = ..........................................................",
    "PIC18F2331/2431/4331/4431\n92. Write Verify, Mode................................................. 226 = ................................................................. 94. Writing......................................................................... FSCM. See Fail-Safe Clock Monitor.,",
    "PIC18F2331/2431/4331/4431\nMode................................................. 226 = 91. G, Mode................................................. 226 = . Getting Started.................................................................... GOTO",
    "PIC18F2331/2431/4331/4431\n..............................................................................., Mode................................................. 226 = 25 304",
    "H\nHardware Multiplier............................................................., 1 = 95. Introduction................................................................., 1 = 95. Operation...................................................................., 1 = 95. Performance",
    "H\nComparison..........................................., 1 = 95",
    "I\nI/O Ports, 1 = ........................................................................... 113. ID Locations.............................................................., 1 = 263, 282. INCF ................................................................................., 1 = 304.",
    "I\nINCFSZ............................................................................., 1 = 305. In-Circuit Debugger..........................................................., 1 = 282. In-Circuit Serial Programming (ICSP)......................., 1 = 263, 282. Independent PWM Mode.................................................., 1 = 193. Duty",
    "I\nCycle Assignment, 1 = ............................................ 193. Indirect Addressing............................................................., 1 = 76. INFSNZ............................................................................., 1 = 305. Initialization Conditions for All Registers......................., 1 = 54-59. Instruction",
    "I\nFlow/Pipelining.................................................., 1 = 65. Instruction Set, 1 = . ADDLW....................................................................., 1 = 289. ADDWF, 1 = .................................................................... 289.",
    "I\nADDWFC.................................................................., 1 = 290. ANDLW....................................................................., 1 = 290. ANDWF, 1 = .................................................................... 291.",
    "I\nBC............................................................................., 1 = 291. BCF, 1 = .......................................................................... 292. BN............................................................................., 1 = 292.",
    "I\nBNC.........................................................................., 1 = 293. BNN.........................................................................., 1 = 293. BNOV, 1 = ....................................................................... 294. BNZ, 1 =",
    "I\n.......................................................................... 294. BOV.........................................................................., 1 = 297. BRA.........................................................................., 1 = 295.",
    "I\nBSF..........................................................................., 1 = 295. BTFSC......................................................................, 1 = 296. BTFSS......................................................................, 1 = 296.",
    "I\nBTG.........................................................................., 1 = 297. BZ............................................................................., 1 = 298. CALL........................................................................., 1 = 298.",
    "I\nCLRF........................................................................, 1 = 299. CLRWDT.................................................................., 1 = 299. COMF......................................................................., 1 = 300.",
    "I\nCPFSEQ..................................................................., 1 = 300. CPFSGT..................................................................., 1 = 301. CPFSLT...................................................................., 1 = 301.",
    "I\nDAW........................................................................., 1 = 302. DCFSNZ..................................................................., 1 = 303. DECF........................................................................, 1 = 302.",
    "I\nDECFSZ..................................................................., 1 = 303. General Format, 1 = ........................................................ 285. GOTO......................................................................., 1 = 304.",
    "I\nINCF........................................................................., 1 = 304. INCFSZ....................................................................., 1 = 305. INFSNZ....................................................................., 1 = 305.",
    "I\nIORLW......................................................................, 1 = 306. IORWF......................................................................, 1 = 306. LFSR, 1 = ........................................................................ 307.",
    "I\nMOVF......................................................................., 1 = 307. MOVFF....................................................................., 1 = 308. MOVLB....................................................................., 1 = 308",
    "PIC18F2331/2431/4331/4431\nMOVLW, 1 = .................................................................... 309. MOVWF...................................................................., 1 = 309. MULLW....................................................................., 1 = 310.",
    "PIC18F2331/2431/4331/4431\nMULWF....................................................................., 1 = 310. NEGF........................................................................, 1 = 311. NOP.........................................................................., 1 = 311. POP, 1 =",
    "PIC18F2331/2431/4331/4431\n312. .......................................................................... PUSH........................................................................, 1 = 312. RCALL, 1 = ...................................................................... 313. Read-Modify-Write Operations, 1 =",
    "PIC18F2331/2431/4331/4431\n................................. 283. RESET......................................................................, 1 = 313. RETFIE, 1 = ..................................................................... 314. RETLW",
    "PIC18F2331/2431/4331/4431\n....................................................................., 1 = 314. RETURN..................................................................., 1 = 315. RLCF........................................................................., 1 = 315.",
    "PIC18F2331/2431/4331/4431\nRLNCF......................................................................, 1 = 316. RRCF........................................................................, 1 = 316. RRNCF, 1 = ..................................................................... 317.",
    "PIC18F2331/2431/4331/4431\nSETF........................................................................., 1 = 317. SLEEP, 1 = ...................................................................... 318. SUBFWB..................................................................., 1 = 318.",
    "PIC18F2331/2431/4331/4431\nSUBLW....................................................................., 1 = 319. SUBWF....................................................................., 1 = 319. SUBWFB..................................................................., 1 = 320 283.",
    "PIC18F2331/2431/4331/4431\nSummary..................................................................., 1 = 286. Summary Table........................................................., 1 = 320. SWAPF..................................................................... TBLRD, 1 =",
    "PIC18F2331/2431/4331/4431\n...................................................................... 321. TBLWT......................................................................, 1 = 322. TSTFSZ, 1 = .................................................................... 323.",
    "PIC18F2331/2431/4331/4431\nXORLW....................................................................., 1 = 323. XORWF....................................................................., 1 = 324. INTCON Register, 1 = . RBIF Bit....................................................................., 1 = 116. INTCON",
    "PIC18F2331/2431/4331/4431\nRegisters .............................................................. 2 2, 1 = 99. INTIO Modes..............................................................., 1 = 32. INTRC Output Frequency, 1 = 32. OSCTUNE Register ...................................................., 1 =",
    "PIC18F2331/2431/4331/4431\n............................................ Oscillator, 1 = 32. Internal RC, 1 = . Use with WDT..........................................................., 1 = 274. Internet Address................................................................, 1 = 387. Interrupt",
    "PIC18F2331/2431/4331/4431\nSources..............................................................., 1 = 263. Capture Complete (CCP).......................................... Interrupt-on-Change (RB7:RB4), 1 = 146 116. INTx Pin ...................................................................., 1 = 112. PORTB, Interrupt-on-Change, 1 =",
    "PIC18F2331/2431/4331/4431\n................................... 112. TMR0 ........................................................................, 1 = 112. TMR1 Overflow ........................................................., 1 = 131. TMR2 to PR2 Match (PWM) ............................., 1 = 136, 149 97.",
    "PIC18F2331/2431/4331/4431\nInterrupts............................................................................. During, 1 = 112. Context Saving, Interrupts, Enable Bits, 1 = .............................................. Interrupts, Flag Bits, 1 = . CCP1 Flag (CCP1IF Bit), 1 = ........................................... 146. CCP1IF Flag (CCP1IF",
    "PIC18F2331/2431/4331/4431\nBit)........................................, 1 = 147. CCP2IF Flag (CCP2IF Bit)........................................, 1 = 147. Interrupt-on-Change (RB7:RB4) Flag (RBIF Bit) .........................................................., 1 = 116. INTOSC, INTRC. See Internal Oscillator Block. IORLW",
    "PIC18F2331/2431/4331/4431\n.............................................................................., 1 = 306. IORWF.............................................................................., 1 = 306. IPR Registers....................................................................,",
    "PIC18F2331/2431/4331/4431\n1 = 108\nI 2 C Mode, 1 = . Operation.................................................................. I 2 C, 1 = 212. Mode (SSP) Addressing................................................................, 1 = 213. Associated Registers................................................, 1 = 216. Master",
    "PIC18F2331/2431/4331/4431\nMode............................................................., 1 = 216. Mode Selection........................................................., 1 = 212. Multi-Master Mode...................................................., 1 = 216.",
    "PIC18F2331/2431/4331/4431\nOperation.................................................................., 1 = 212. Reception, 1 = ................................................................. 214. Slave Mode..............................................................., 1 = 212. SCL and SDA Pins",
    "PIC18F2331/2431/4331/4431\n............................................................, 1 = ........................................... 212. Transmission, 1 = 215. L, 1 = . LFSR................................................................................., 1 = 307. Low-Voltage Detect, 1 =",
    "PIC18F2331/2431/4331/4431\n.......................................................... 257. Applications .............................................................., 1 = 261. Associated Registers................................................, 1 = 261.",
    "PIC18F2331/2431/4331/4431\nCharacteristics.........................................................., 1 = 342. Current Consumption................................................, 1 = 259. Effects of a Reset ....................................................., 1 = 261.",
    "PIC18F2331/2431/4331/4431\nOperation.................................................................., 1 = 259. Operation During Sleep ............................................ ........................................................................, 1 = 261. Setup, 1 = 259. Start-up",
    "PIC18F2331/2431/4331/4431\nTime............................................................, 1 = 260. LVD. See Low-Voltage Detect., 1 = . M, 1 = . Master Clear (MCLR).........................................................., 1 = 49. Memory Organization, 1 = ......................................................... 61. Data",
    "PIC18F2331/2431/4331/4431\nMemory.............................................................. Program Memory........................................................, 1 = 67 61. Memory Programming Requirements..............................., 1 = 341. MFM, 1 = . Input Capture, 1 = . Edge Capture Mode, 1 = ......................................... 156. Entering and Timing, 1 =",
    "PIC18F2331/2431/4331/4431\n......................................... 159. IC Interrupts......................................................, 1 = 159. Pulse-Width Measurement Mode....................., 1 = 157. Special Event Trigger, 1 = (CAP1 Only).................. 160. State Change...................................................., 1 = 158. Time Base Reset",
    "PIC18F2331/2431/4331/4431\nSummary.............................. Timer5 Reset...................................................., 1 = 160 159. Capture (IC) Submode....................................., 1 = 153. Input, 1 = . Input Capture Mode Period Measurement, 1 = ............................... Noise",
    "PIC18F2331/2431/4331/4431\nFilters.............................................................., 1 = Mode 157. , 1 = 169. Microchip Internet Web Site.............................................. Migration From Baseline to Enhanced, 1 = 387 376. Devices................ Migration From High-End to Enhanced Devices..............., 1 = 377. Migration From Mid-Range to Enhanced, 1 = Devices............ 377. Motion Feedback Module",
    "PIC18F2331/2431/4331/4431\n(MFM)......................................, 1 = 151. Associated Registers................................................, 1 = 171. Summary of Features, 1 = ............................................... 151. MOVF ..............................................................................., 1 =",
    "PIC18F2331/2431/4331/4431\n307. MOVFF............................................................................., 1 = 308. MOVLB............................................................................., 1 = 308.",
    "PIC18F2331/2431/4331/4431\nMOVLW............................................................................, 1 = 309. MOVWF............................................................................, 1 = 309. MPLAB ASM30 Assembler, Linker, Librarian..................., 1 = 326. MPLAB Integrated Development Environment Software",
    "PIC18F2331/2431/4331/4431\n.............................................., 1 = 325 328. MPLAB PM3 Device Programmer .................................... MPLAB REAL ICE In-Circuit Emulator System, 1 = ................ 327",
    "PIC18F2331/2431/4331/4431\nMPLINK Object Linker/MPLIB Object MULLW............................................................................., 1 = Librarian ................ 326. MULWF............................................................................., 1 = 310 310. N, 1 = .",
    "PIC18F2331/2431/4331/4431\nNEGF................................................................................, 1 = 311. NOP.................................................................................., 1 = 311. O, 1 = . Opcode Field Descriptions................................................, 1 = 284. Oscillator",
    "PIC18F2331/2431/4331/4431\nConfiguration......................................................., 1 = 29. EC..............................................................................., 1 = 29. ECIO..........................................................................., 1 = 29.",
    "PIC18F2331/2431/4331/4431\nHS..............................................................................., 1 = 29. HSPLL........................................................................., 1 = 29. Internal Oscillator Block, 1 = .............................................. 32. INTIO1, 1 =",
    "PIC18F2331/2431/4331/4431\n........................................................................ 29 ......................................................................... INTIO2, 1 = 29. LP................................................................................, 1 = 29.",
    "PIC18F2331/2431/4331/4431\nRC..............................................................................., 1 = 29. RCIO..........................................................................., 1 = 29. XT, 1 = 29.",
    "PIC18F2331/2431/4331/4431\n............................................................................... Oscillator Selection, 1 = ........................................................... 263. Oscillator Start-up Timer (OST), 1 = .................................. 37, 263. Oscillator",
    "PIC18F2331/2431/4331/4431\nSwitching............................................................., 1 = 34. Oscillator Transitions, 1 = .......................................................... 37. Oscillator, Timer1.............................................................., 1 = 131. P, 1 = . P (Stop)",
    "PIC18F2331/2431/4331/4431\nBit........................................................................, 1 = 206. Packaging Information, 1 = ...................................................... 363. Details......................................................................., 1 = 365. Marking, 1 =",
    "PIC18F2331/2431/4331/4431\n..................................................................... 363. PIE Registers, 1 = .................................................................... 105. Pin Diagrams, 1 = ........................................................................ 4. Pin Functions, 1 = .",
    "PIC18F2331/2431/4331/4431\nMCLR/VPP..................................................................., 1 = 16. MCLR/VPP/RE3..........................................................., 1 = 19. OSC1/CLKI/RA7 ..................................................., 1 = 16, 19. OSC2/CLKO/RA6, 1 =",
    "PIC18F2331/2431/4331/4431\n................................................. 16, 19. RA0/AN0..............................................................., 1 = 16, 20. RA1/AN1..............................................................., 1 = 16, 20.",
    "PIC18F2331/2431/4331/4431\nRA2/AN2/VREF-/CAP1/INDX................................., 1 = 16, 20. RA3/AN3/VREF+/CAP2/QEA................................., 1 = 16, 20. RA4/AN4/CAP3/QEB............................................, 1 = 16, 20. RA5/AN5/LVDIN, 1 = .........................................................",
    "PIC18F2331/2431/4331/4431\n20. RB0/PWM0..........................................................., 1 = 17, 21. RB1/PWM1..........................................................., 1 = 17, 21. RB2/PWM2..........................................................., 1 = 17, 21.",
    "PIC18F2331/2431/4331/4431\nRB3/PWM3..........................................................., 1 = 17, 21. RB4/KBIO/PWM5........................................................, 1 = 17. RB4/KBI0/PWM5, 1 = ........................................................ 21.",
    "PIC18F2331/2431/4331/4431\nRB5/KBI1/PWM4/PGM........................................., 1 = 17, 21. RB6/KBI2/PGC, 1 = 17, 21. ..................................................... RB7/KBI3/PGD, 1 = 17, 21. ..................................................... RC0/T1OSO/T1CKI, 1 = 18, 22.",
    "PIC18F2331/2431/4331/4431\n.............................................. RC1/T1OSI/CCP2/FLTA......................................., 1 = 18, 22. RC2/CCP1.................................................................., 1 = 18. RC2/CCP1/FLTB, 1 =",
    "PIC18F2331/2431/4331/4431\n........................................................ 22. RC3/T0CKI/T5CKI/INT0........................................, 1 = 18, 22. , 1 = 18, 22. RC4/INT1/SDI/SDA............................................... RC5/INT2/SCK/SCL.............................................., 1",
    "PIC18F2331/2431/4331/4431\n= 18, 22. , 1 = 18, 22. RC6/TX/CK/SS ..................................................... RC7/RX/DT/SDO.................................................., 1 = 18, 22. RD0/T0CKI/T5CKI, 1 = ...................................................... 23.",
    "PIC18F2331/2431/4331/4431\nRD1/SDO...................................................................., 1 = 23",
    "PIC18F2331/2431/4331/4431\nRD2/SDI/SDA............................................................., 1 = 23. RD3/SCK/SCL............................................................, 1 = 23. RD4/FLTA..................................................................., 1 = 23.",
    "PIC18F2331/2431/4331/4431\nRD5/PWM4................................................................., 1 = 23. RD6/PWM6................................................................., 1 = 23. RD7/PWM7................................................................., 1 = 23.",
    "PIC18F2331/2431/4331/4431\nRE0/AN6....................................................................., 1 = 24. RE1/AN7....................................................................., 1 = 24. RE2/AN8....................................................................., 1 = 24. VDD",
    "PIC18F2331/2431/4331/4431\n......................................................................., 1 = 18, 24. VSS ......................................................................., 1 = 24, 18. Pinout I/O Descriptions, 1 = . PIC18F2331/2431 ......................................................, 1 = 16.",
    "PIC18F2331/2431/4331/4431\nPIC18F4331/4431 ......................................................, 1 = 19. PIR Registers...................................................................., 1 = 102. PLL, 1 = . HSPLL Mode.............................................................., 1 = 30. Multiplier",
    "PIC18F2331/2431/4331/4431\n....................................................................., 1 = 30. POP.................................................................................. See Power-on Reset., 1 = 312. POR. PORTA, 1 = . Associated Registers................................................, 1 = 115. LATA Register",
    "PIC18F2331/2431/4331/4431\n.........................................................., 1 = 113. PORTA Register......................................................., 1 = 113. TRISA Register........................................................., 1 = 113. PORTB, 1 = . Associated",
    "PIC18F2331/2431/4331/4431\nRegisters................................................, 1 = 118. LATB Register .........................................................., 1 = 116. PORTB Register......................................................., 1 = 116. RB7:RB4 Interrupt-on-Change Flag (RBIF Bit), 1 = ........ 116. TRISB",
    "PIC18F2331/2431/4331/4431\nRegister........................................................., 1 = 116. PORTC, 1 = . Associated Registers................................................, 1 = 121. LATC Register.........................................................., 1 = 119. PORTC",
    "PIC18F2331/2431/4331/4431\nRegister......................................................., 1 = 119. TRISC Register ........................................................, 1 = 119. PORTD, 1 = . Associated Registers................................................, 1 = 123. LATD",
    "PIC18F2331/2431/4331/4431\nRegister.........................................................., 1 = 122. PORTD Register......................................................., 1 = 122. TRISD Register ........................................................, 1 = 122. PORTE, 1 = . Associated",
    "PIC18F2331/2431/4331/4431\nRegisters................................................, 1 = 125. LATE Register .........................................................., 1 = 124. PORTE Register......................................................., 1 = 124. TRISE Register.........................................................",
    "PIC18F2331/2431/4331/4431\nPostscaler, WDT, 1 = 124. Assignment (PSA Bit) ..............................................., 1 = 129. Rate Select (T0PS2:T0PS0 Bits).............................., 1 = 129. Power-Managed Modes......................................................, 1 = 39. Clock Sources",
    "PIC18F2331/2431/4331/4431\n............................................................, 1 = 39. Clock Transitions and Status Indicators, 1 = ..................... 40. Entering ......................................................................, 1 = 39. Exiting Idle and Sleep Modes....................................., 1 = 45. By",
    "PIC18F2331/2431/4331/4431\nInterrupt........................................................., 1 = 45. By Reset............................................................., 1 = 45. By WDT Time-out..............................................., 1 = 45. Without an Oscillator Start-up Delay, 1 = .................. 46. Idle",
    "PIC18F2331/2431/4331/4431\nModes.................................................................., 1 = 43. PRI_IDLE ..........................................................., 1 = 44 45. RC_IDLE ............................................................",
    "PIC18F2331/2431/4331/4431\nSEC_IDLE.........................................................., 1 = 44. Multiple Sleep Commands.........................................., 1 = 40",
    "PIC18F2331/2431/4331/4431\nRun Modes.................................................................., 1 = 40. PRI_RUN............................................................, 1 = 40. RC_RUN............................................................., 1 = 41.",
    "PIC18F2331/2431/4331/4431\nSEC_RUN..........................................................., 1 = 40. Selecting ....................................................................., 1 = 39. Sleep Mode................................................................., 1 = 43. Summary (table), 1 =",
    "PIC18F2331/2431/4331/4431\n......................................................... 39. Power-on Reset (POR)..............................................., 1 = 49, 263. Power-up Delays................................................................., 1 = 37 37,. Power-up Timer",
    "PIC18F2331/2431/4331/4431\n(PWRT)............................................., 1 = 263. Prescaler, Timer0.............................................................., 1 = 129. Assignment (PSA Bit), 1 = ............................................... 129. Rate Select (T0PS2:T0PS0, 1 = Bits) .............................. 129. Prescaler,",
    "PIC18F2331/2431/4331/4431\nTimer2.............................................................., 1 = 150. PRI_IDLE Mode.................................................................., 1 = 44. PRI_RUN Mode .................................................................., 1 = 40. Program Counter (PC), 1 =",
    "PIC18F2331/2431/4331/4431\n........................................................ 62. Program Memory, 1 = . Instructions.................................................................., 1 = 66. Two-Word, 1 = ........................................................... 66. Interrupt Vector, 1 =",
    "PIC18F2331/2431/4331/4431\n........................................................... 61. Map and Stack, 1 = . PIC18F2331/4331..............................................., 1 = 61. PIC18F2431/4431..............................................., 1 = 61. Reset Vector, 1 =",
    "PIC18F2331/2431/4331/4431\n............................................................... 61. Program Verification.........................................................., 1 = 279. Pulse-Width Modulation. See PWM (CCP Module). PUSH................................................................................, 1 = 312. PUSH and POP Instructions, 1 =",
    "PIC18F2331/2431/4331/4431\n............................................... 64. PWM, 1 = . Associated Registers, 1 = ................................................ 203. Complementary Operation........................................, 1 = 190. Control Registers ......................................................, 1 = 176. Dead-Time Generators, 1 =",
    "PIC18F2331/2431/4331/4431\n............................................. 191. Duty Cycle................................................................., 1 = 187. Center-Aligned.................................................., 1 = 189. Comparison......................................................., 1 = 187. Edge-Aligned",
    "PIC18F2331/2431/4331/4431\n...................................................., 1 = 188 ................................................. Register Buffers, 1 = 188. Registers..........................................................., 1 = 187. Fault Inputs",
    "PIC18F2331/2431/4331/4431\nFunctionality.............................................................., 1 = ............................................................... 199 176. Modes, 1 = . Continuous Up/Down Count, 1 = ............................. 180. Free-Running...................................................., 1 = 180. Single-Shot",
    "PIC18F2331/2431/4331/4431\n......................................................., 1 = 180. Output and Polarity Control......................................., 1 = 198. Output Override ........................................................, 1 = 194. Single-Pulse Operation, 1 = ............................................. 194. Special Event",
    "PIC18F2331/2431/4331/4431\nTrigger................................................, 1 = 202. Time Base................................................................., 1 = 176. Interrupts..........................................................., 1 = 181. Continuous Up/Down, 1 = . Count Mode......................................, 1",
    "PIC18F2331/2431/4331/4431\n= 182. Double Update Mode................................, 1 = 184. Free-Running Mode.................................. Mode ....................................., 1 = 181. Single-Shot, 1 = 182. Postscaler .........................................................",
    "PIC18F2331/2431/4331/4431\nPrescaler..........................................................., 1 = 181 180. Update Lockout........................................................., 1 = 202",
    "PIC18F2331/2431/4331/4431\nPWM (CCP Module), 1 = . Associated Registers................................................, 1 = 150. CCPR1H:CCPR1L Registers...................................., 1 = 149. Duty Cycle, 1 = ................................................................ 149. Example Frequencies/Resolutions, 1 = ........................... 150. Period, 1 =",
    "PIC18F2331/2431/4331/4431\n....................................................................... 149. PR2 Register, Writing ..............................................., 1 = 149. Setup for PWM Operation........................................., 1 = 150. TMR2 to PR2 Match ........................................., 1 = 136, 149. PWM",
    "PIC18F2331/2431/4331/4431\nPeriod......................................................................, 1 = 185. Q, 1 = . Q Clock............................................................................., 1 = 150. QEI, 1 = . and IC Shared Interrupts, 1 = .......................................... 170. Configuration",
    "PIC18F2331/2431/4331/4431\n............................................................, 1 = 162. Direction of Rotation, 1 = ................................................. 163. Interrupts, 1 = .................................................................. 164.",
    "PIC18F2331/2431/4331/4431\nOperation.................................................................., 1 = 163. Operation in Sleep Mode.........................................., 1 = 170. 3x Input, 1 = Capture............................................... 170. Sampling Modes......................................................., 1 = 163. Velocity",
    "PIC18F2331/2431/4331/4431\nMeasurement.............................................., 1 = 167. Quadrature Encoder Interface (QEI)................................., 1 = 161. R, 1 = . R/W Bit......................................................, 1 = 206, 213, 214, 215. RAM. See Data Memory., 1 = . RC",
    "PIC18F2331/2431/4331/4431\nOscillator......................................................................., 1 = 31. RCIO Oscillator Mode................................................., 1 = 31. RC_IDLE Mode..................................................................., 1 = 45. RC_RUN, 1 =",
    "PIC18F2331/2431/4331/4431\nMode................................................................... 41. RCALL.............................................................................., 1 = 313. RCSTA Register, 1 = . SPEN Bit..................................................................., 1 = 217. Reader",
    "PIC18F2331/2431/4331/4431\nResponse............................................................., 1 = 388. ADCHS (A/D Channel Select), 1 = .................................. 244. ADCON0 (A/D Control 0).........................................., 1 = 240. ADCON1 (A/D Control 1).........................................., 1 = 241. ADCON2 (A/D Control",
    "PIC18F2331/2431/4331/4431\n2).........................................., 1 = 242. ADCON3 (A/D Control 3).........................................., 1 = 243. ANSEL0 (Analog Select 0), 1 = ....................................... 245. ANSEL1 (Analog Select 1), 1 = ....................................... 245. BAUDCON (Baud Rate",
    "PIC18F2331/2431/4331/4431\nControl)..............................., 1 = 220. CAPxCON (Input Capture x Control)........................, 1 = 155. CCPxCON (CCPx Control)......................................., 1 = 145. CONFIG1H (Configuration 1 High)..........................., 1 = 264. CONFIG2H (Configuration 2 High)..........................., 1 = 266. CONFIG2L (Configuration 2 Low), 1 =",
    "PIC18F2331/2431/4331/4431\n............................ 265. CONFIG3H (Configuration 3 High)..........................., 1 = 268. CONFIG3L (Configuration 3 Low), 1 = ............................ 267. CONFIG4L (Configuration 4 Low), 1 = ............................ 269. CONFIG5H (Configuration 5 High)..........................., 1 = 270. CONFIG5L (Configuration 5 Low), 1 = ............................",
    "PIC18F2331/2431/4331/4431\n270. CONFIG6H (Configuration 6 High)..........................., 1 = 271. CONFIG6L (Configuration 6 Low), 1 = ............................ 271 272. CONFIG7H (Configuration 7 High)........................... CONFIG7L (Configuration 7 Low), 1 = ............................ 272. DEVID1 (Device ID 1)..............................................., 1 = 273",
    "PIC18F2331/2431/4331/4431\nDEVID2 (Device ID 2)..............................................., 1 = 273. DFLTCON (Digital Filter Control), 1 = .............................. 169. DTCON (Dead-Time Control), 1 = ................................... 192. EECON1 (Data EEPROM Control 1), 1 = .......................... 87. EECON1 (EEPROM Control 1)..................................., 1 =",
    "PIC18F2331/2431/4331/4431\n80. FLTCONFIG (Fault Configuration)............................, 1 = 201. INTCON (Interrupt Control)........................................., 1 = 99. INTCON2 (Interrupt Control 2).................................., 1 = 100. INTCON3 (Interrupt Control 3).................................., 1 = 101. IPR1 (Peripheral Interrupt Priority 1)........................., 1 = 108. IPR2 (Peripheral Interrupt Priority",
    "PIC18F2331/2431/4331/4431\n2)........................., 1 = 109. IPR3 (Peripheral Interrupt Priority 3)........................., 1 = 110. LVDCON (Low-Voltage Detect Control)...................., 1 = 257. OSCCON (Oscillator Control), 1 = ..................................... 36. OSCTUNE (Oscillator Tuning)...................................., 1 = 33. OVDCOND (Output Override Control), 1 =",
    "PIC18F2331/2431/4331/4431\n...................... 196. OVDCONS (Output State), 1 = ........................................ 196. PIE1 (Peripheral Interrupt Enable 1)........................., 1 = 105. PIE2 (Peripheral Interrupt Enable 2)........................., 1 = 106. PIE3 (Peripheral Interrupt Enable 3)........................., 1 = 107. PIR1 (Peripheral Interrupt Request (Flag) 1)............, 1 = 102. PIR2 (Peripheral Interrupt Request (Flag)",
    "PIC18F2331/2431/4331/4431\n2)............, 1 = 103. PIR3 (Peripheral Interrupt Request (Flag), 1 = 3)............ 104. PTCON0 (PWM Timer Control 0), 1 = ............................. 178. PTCON1 (PWM Timer Control, 1 = 1) ............................. 178. PWMCON0 (PWM Control 0), 1 = ................................... 179 ................................... 180. PWMCON1 (PWM Control, 1 = 1)",
    "PIC18F2331/2431/4331/4431\n162. QEICON (QEI Control).............................................. RCON (Reset, 1 = Control)........................................ 48, 111. RCSTA (Receive Status and Control)......................., 1 = 219. SSPCON (SSP Control)............................................, 1 = 207. SSPSTAT (SSP",
    "PIC18F2331/2431/4331/4431\nStatus)............................................, 1 = 206. STATUS......................................................................, 1 = 74. STKPTR (Stack Pointer)............................................., 1 = 63.",
    "PIC18F2331/2431/4331/4431\nSummary..............................................................., 1 = 70-73. TRISE, 1 = ....................................................................... 124. TXSTA (Transmit Status and Control), 1 = ...................... 218. T0CON (Timer0 Control)..........................................., 1 = 127.",
    "PIC18F2331/2431/4331/4431\nT1CON (Timer1 Control)..........................................., 1 = 131. T2CON (Timer2 Control)..........................................., 1 = 136. T5CON (Timer5 Control)..........................................., 1 = 139 ........................ WDTCON (Watchdog Timer Control), 1 = 275.",
    "PIC18F2331/2431/4331/4431\nRESET.............................................................................., 1 = 313. Reset...................................................................................",
    "PIC18F2331/2431/4331/4431\nResets..............................................................................., 1 = 47 263. RETFIE, 1 = ............................................................................. 314. RETLW",
    "PIC18F2331/2431/4331/4431\n............................................................................., 1 = 314. RETURN..........................................................................., 1 = 315. Return Address Stack, 1 = 62. ......................................................... Return Stack Pointer (STKPTR), 1 =",
    "PIC18F2331/2431/4331/4431\n......................................... 62. Revision History, 1 = ................................................................ 375. RLCF................................................................................., 1 = 315.",
    "PIC18F2331/2431/4331/4431\nRLNCF.............................................................................., 1 = 316. RRCF................................................................................, 1 = 316. , 1 = 317. RRNCF, 1 =",
    "PIC18F2331/2431/4331/4431\n.............................................................................",
    "S\nS (Start) Bit ......................................................................., 1 = 206. SCK..................................................................................., 1 = 205.",
    "S\nSCL..................................................................................., 1 = 212. SDI...................................................................................., 1 = 205.",
    "S\nSDO.................................................................................., 1 = 205. SEC_IDLE Mode................................................................., 1 = 44. SEC_RUN Mode................................................................., 1 = 40. Serial Clock (SCK)",
    "S\nPin......................................................, 1 = 205. Serial Data In (SDI) Pin....................................................., 1 = 205",
    "S\nSerial Data Out (SDO) Pin................................................, 1 = 205. SETF ................................................................................, 1 = 317. Single-Supply ICSP Programming...................................., 1 = 282. Slave Select (SS) Pin",
    "S\n......................................................., 1 = 205. SLEEP.............................................................................., 1 = 318. Sleep, 1 = . OSC1 and OSC2 Pin States......................................., 1 = 37. Software Simulator (MPLAB SIM) ...................................., 1 = 327. Special Event Trigger. See",
    "S\nCompare (CCP Module). Special Features of the CPU............................................ Special Function Registers, 1 = 263. Map............................................................................., 1 = 69. SPI Mode (SSP) ..............................................................., 1 = 205 211. Associated",
    "S\nRegisters................................................ Serial Clock .............................................................., 1 = 205. Serial Data In............................................................, 1 = 205. Serial Data Out........................................................., 1 = 205. Slave",
    "S\nSelect.............................................................., 1 = 205. SS....................................................................................., 1 = . SSP, 1 = 205. TMR2 Output for Clock Shift............................., 1 = 136, 137. SSPEN Bit",
    "S\n........................................................................, 1 = 207. SSPM<3:0> Bits ..............................................................., 1 = 208. SSPOV Bit ........................................................................, 1 = 207. Stack Full/Underflow",
    "S\nResets..............................................., 1 = 64. Status Bits, Significance and Initialization for RCON Register..........................................................., 1 = 53 318. SUBLW............................................................................., 1 = 319.",
    "S\nSUBWF............................................................................., 1 = 319. SUBWFB .........................................................................., 1 = 320. SWAPF............................................................................., 1 = 320. Synchronous",
    "S\nSerial Port. See SSP., 1 = . T, 1 = . TABLAT Register................................................................, 1 = 88. Table Pointer Operations (table)........................................., 1 = 88. TBLPTR Register................................................................, 1 = 88.",
    "S\nTBLRD.............................................................................., 1 = 321. TBLWT ............................................................................., 1 = 322. Time-out in Various Situations (table)................................., 1 = 50. Timer0",
    "S\n.............................................................................., 1 = 127. Associated Registers................................................, 1 = 129 129. Clock Source Edge Select (T0SE Bit) Clock Source Select (T0CS Bit) ..............................., 1 = ...................... 129. Interrupt",
    "S\n...................................................................., 1 = 129. Operation.................................................................., 1 = 129. Prescaler .................................................................., 1 = 129. Switching Assignment",
    "S\n......................................, 1 = . Prescaler. See Prescaler, Timer0. Writes, 1 = 129. 16-Bit Mode Timer Reads and, 1 = ....................... , 1 = 129. Timer1 .............................................................................., 1 = 131. Associated Registers................................................, 1 = 135. Interrupt",
    "S\n...................................................................., 1 = 134. Operation.................................................................., 1 = 132 133. Oscillator..........................................................., 1 = 131,. Layout",
    "S\nConsiderations......................................, 1 = 133. Overflow Interrupt ..................................................... Trigger, 1 = 131. Resetting, Using a Special Event Output (CCP)...................................................., 1 = 134. Special Event Trigger (CCP) TMR1H Register......................................................., 1 =",
    "S\n.................................... 147 131. TMR1L Register, 1 = 131. ....................................................... Use as a Real-Time, 1 = 134. Clock (RTC)............................. 16-Bit Read/Write Mode..........................................., 1 = 134",
    "PIC18F2331/2431/4331/4431\nAssociated Registers, 136 = 137. Interrupt....................................................................., 136 = 137. Operation, 136 = .................................................................. 136. Postscaler. See Postscaler, Timer2. Prescaler. See Prescaler, Timer2. PR2",
    "PIC18F2331/2431/4331/4431\nRegister............................................................., 136 = . , 136 = 136. SSP Clock Shift................................................., 136 = 136, 137. TMR2 Register.........................................................., 136 = 136. TMR2 to PR2 Match Interrupt ..........................., 136 = 136, 149.",
    "PIC18F2331/2431/4331/4431\nTimer5..............................................................................., 136 = 139 ................................................. Associated Registers, 136 = 143. Interrupt..................................................................... Noise",
    "PIC18F2331/2431/4331/4431\nFilter................................................................, 136 = 142 142. Operation, 136 = .................................................................. 140. Continuous Count and Single-Shot..................., 136 = 141. Sleep Mode......................................................., 136 = 142.",
    "PIC18F2331/2431/4331/4431\nPrescaler..................................................................., 136 = . Special Event Trigger, 136 = 141. Output ..............................................................., 136 = 142. Reset Input........................................................, 136 = 142. 16-Bit Read/Write and Write Modes, 136 =",
    "PIC18F2331/2431/4331/4431\n......................... 141. 16-Bit Read-Modify-Write.........................................., 136 = 141. Timing Diagrams, 136 = .............................. Automatic Baud Rate Calculation Auto-Wake-up Bit (WUE) During, 136 = 225. Normal Operation.............................................., 136 = 231 231. Auto-Wake-up Bit (WUE) During Sleep Brown-out Reset",
    "PIC18F2331/2431/4331/4431\n(BOR)............................................, 136 = .................... 349. Capture/Compare/PWM (All CCP Modules)............., 136 = 352. CAPx Interrupts and IC1 Special, 136 = Event Trigger........ 159. CLKO and I/O ..........................................................., 136 = 348. Clock, Instruction Cycle",
    "PIC18F2331/2431/4331/4431\n.............................................., 136 = 65. Dead-Time Insertion for Complementary Duty Cycle Update Times in Continuous, 136 = PWM........191. Up/Down Count Mode......................................., 136 = . , 136 = 188. Duty Cycle Update Times in Continuous Up/Down Count Mode with Double Updates ................................................, 136 = . , 136 = 189. Edge Capture",
    "PIC18F2331/2431/4331/4431\nMode.................................................., 136 = 156. Edge-Aligned PWM................................................... EUSART Asynchronous, 136 = 188 230. Reception .........................., 136 = 227. EUSART Asynchronous Transmission, 136 = ...................... (Back to",
    "PIC18F2331/2431/4331/4431\nBack)..................................................., 136 = 227. EUSART Synchronous Receive (Master/Slave) EUSART Synchronous Reception, 136 = ....... 360. (Master Mode, SREN)....................................... EUSART Synchronous Transmission, 136 = . , 136 = 235. EUSART Synchronous Transmission, 136 = ....................... 233. (Through",
    "PIC18F2331/2431/4331/4431\nTXEN)................................................, 136 = 234. EUSART SynchronousTransmission, 136 = . (Master/Slave)..................................................., 136 = 360. Example SPI Master Mode (CKE = 0), 136 = ...................... 353. Example SPI Master Mode (CKE = 1), 136 = ...................... 354. Example SPI Slave Mode (CKE = 0), 136 =",
    "PIC18F2331/2431/4331/4431\n........................ 355. Example SPI Slave Mode (CKE = 1), 136 = ........................ 356. External Clock (All Modes Except, 136 = PLL) .................... 346. Fail-Safe Clock Monitor............................................., 136 = 278. Input Capture on State Change, Hall Effect Sensor Mode...................................................., 136 = 158. I 2 C Bus",
    "PIC18F2331/2431/4331/4431\nData............................................................., 136 = 357. I 2 C Bus Start/Stop Bits.............................................. I 2 C Reception (7-Bit Address)..................................., 136 = 357 214. I 2 C Transmission (7-Bit Address), 136 = 215. , 136 = .............................",
    "PIC18F2331/2431/4331/4431\nLow-Voltage Detect .................................................., 1 = 260. Low-Voltage Detect Characteristics.......................... Filter................................................................, 1 = 342. Noise, 1 = 170. Pulse-Width Measurement Mode, 1 = ............................. 157. PWM",
    "PIC18F2331/2431/4331/4431\nOutput............................................................., 1 = 149. PWM Output Override (Example 1).........................., 1 = 197. PWM Output Override (Example 2).........................., 1 = 197. PWM Override Bits in Complementary Mode........... PWM Period Buffer Updates in, 1 = 195. Continuous Up/Down Count Mode................... PWM Period Buffer Updates in, 1 = 186. Free-Running",
    "PIC18F2331/2431/4331/4431\nMode.......................................... PWM Time Base Interrupt, Continuous Up/Down Count Mode ......................................, 1 = 186 183. PWM Time Base Interrupt, Continuous Up/Down Count Mode with Double Updates................................................, 1 = 184. PWM Time Base Interrupt, Free-Running Mode, 1 = ...... 181. PWM Time Base Interrupt, Single-Shot Mode.........., 1 = 182. QEI Inputs When Sampled by Filter, 1 =",
    "PIC18F2331/2431/4331/4431\n......................... 165. QEI Reset on Period Match......................................, 1 = 165. QEI Reset with the Index Input................................., 1 = 166. Reset, Watchdog Timer (WDT), Oscillator Start-up Timer (OST), Power-up Timer (PWRT) .................................................., 1 = 349. Send Break Character",
    "PIC18F2331/2431/4331/4431\nSequence............................., 1 = 232 52. Slow Rise Time (MCLR Tied to VDD, VDD Rise > TPWRT)............................................., 1 = 210. SPI Mode (Master Mode).......................................... SPI Mode (Slave Mode with CKE =, 1 = 0)...................... 210. SPI Mode (Slave Mode with CKE = 1)......................, 1 = 211. Start of Center-Aligned",
    "PIC18F2331/2431/4331/4431\nPWM..................................., 1 = 189. Time-out Sequence on POR w/PLL Enabled (MCLR Tied to VDD) ..........................................., 1 = 53. Time-out Sequence on Power-up (MCLR Not Tied to VDD): Case 1, 1 = ....................... 51. Time-out Sequence on Power-up (MCLR Not Tied to VDD): Case 2 ....................... Time-out Sequence on Power-up, 1 = 52. (MCLR Tied to VDD, VDD Rise",
    "PIC18F2331/2431/4331/4431\nTPWRT)..............., 1 = 51. Timer0 and Timer1 External Clock ........................... Transition for Entry to Idle Mode................................., 1 = 351 44. Transition for Entry to SEC_RUN Mode....................., 1 = 41. Transition for Entry to Sleep Mode............................., 1 = 43. Transition for Two-Speed Start-up, 1 = . Transition for Wake From Idle to Run Mode..............., 1 = 44. Transition for Wake From Sleep",
    "PIC18F2331/2431/4331/4431\n(HSPLL).................., 1 = 43. Transition From RC_RUN Mode to PRI_RUN Mode.................................................., 1 = 42. Transition From SEC_RUN Mode to PRI_RUN Mode (HSPLL)..................................., 1 = 41. Transition to RC_RUN Mode...................................... Velocity",
    "PIC18F2331/2431/4331/4431\nMeasurement.............................................., 1 = 42. Diagrams and Specifications, 1 = 168. ................................ Capture/Compare/PWM Requirements, 1 = 346. (All CCP Modules)............................................ CLKO and I/O Requirements...................................., 1 = 352 348 360. EUSART Synchronous Receive Requirements........ EUSART Synchronous Transmission Requirements",
    "PIC18F2331/2431/4331/4431\n..................................................., 1 = . Example SPI Mode Requirements (Master Mode, CKE = 0)................................... Example SPI Mode Requirements, 1 = 360. , 1 = 353. (Master Mode, CKE = 1)..................................., 1 = 354",
    "PIC18F2331/2431/4331/4431\nExample SPI Mode Requirements (Slave Mode, CKE = 0)....................................., 1 = 355. Example SPI Slave Mode Requirements (CKE = 1).........................................................., 1 = 356. External Clock Requirements, 1 = ................................... 346. Internal RC Accuracy................................................, 1 = 347. I 2 C Bus Data Requirements (Slave Mode)",
    "PIC18F2331/2431/4331/4431\n..............., 1 = 358. I 2 C Bus Start/Stop Bits Requirements (Slave Mode) ...................................................., 1 = 357. PLL Clock.................................................................., 1 = 347. Reset, Watchdog Timer, Oscillator Start-up Timer, Power-up Timer and Brown-out Reset Requirements........................................., 1 = 350. SSP I 2 C",
    "PIC18F2331/2431/4331/4431\nBus Data Requirements, 1 = ............................. 359. Timer0 and Timer1 External Clock Requirements ..................................................., 1 = 351. Top-of-Stack Access..........................................................., 1 = 62. TSTFSZ, 1 =",
    "PIC18F2331/2431/4331/4431\n............................................................................ 323. Two-Speed Start-up.................................................., 1 = 263, 276. Two-Word Instructions Example Cases..........................................................., 1 = 66. TXSTA Register BRGH Bit",
    "PIC18F2331/2431/4331/4431\n.................................................................., 1 = 221. T0CON Register, 1 = . PSA Bit......................................................................, 1 = 129. T0CS Bit...................................................................., 1 = 129.",
    "PIC18F2331/2431/4331/4431\nT0PS2:T0PS0 Bits...................................................., 1 = 129. T0SE Bit...................................................................., 1 = 129",
    "U\nUA Bit, 1 = ............................................................................... 206. W, 1 = . Watchdog Timer (WDT)............................................, 1 = 263, 274. Associated Registers................................................, 1 = 275. Control",
    "U\nRegister........................................................, 1 = 274. During Oscillator Failure ..........................................., 1 = 277. Programming Considerations..................................., 1 = 274. WWWAddress ................................................................., 1 = 387. WWW, On-Line Support",
    "U\n......................................................., 1 = 9. X, 1 = . XORLW, 1 = ............................................................................ 323. XORWF............................................................................, 1 = 324",
    "PIC18F2331/2431/4331/4431\nNOTES:",
    "CUSTOMER SUPPORT\nMicrochip provides online support via our WWW site at www.microchip.com. This web site is used as a means to make  files and  information  easily available to customers. Accessible by using your favorite Internet browser, the web site contains the following information:\n\u00b7 Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\n\u00b7 General Technical Support - Frequently Asked Questions (FAQ), technical support requests, online discussion groups, Microchip consultant program member listing\n\u00b7 Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "CUSTOMER CHANGE NOTIFICATION SERVICE\nMicrochip's  customer  notification  service  helps  keep customers current on Microchip products. Subscribers will receive  e-mail  notification  whenever  there  are changes,  updates,  revisions  or  errata  related  to  a specified product family or development tool of interest.\nTo register, access the Microchip web site at www.microchip.com. Under 'Support', click on 'Customer Change Notification' and follow the registration instructions.\nUsers  of  Microchip  products  can  receive  assistance through several channels:\n\u00b7 Distributor or Representative\n\u00b7 Local Sales Office\n\u00b7 Field Application Engineer (FAE)\n\u00b7 Technical Support\n\u00b7 Development Systems Information Line\nCustomers should contact their distributor, representative  or  field  application  engineer  (FAE)  for support. Local sales offices are also available to help customers.  A  listing  of  sales  offices  and  locations  is included in the back of this document.\nTechnical support is available through the web site at: http://support.microchip.com",
    "READER RESPONSE\nIt  is  our  intention  to  provide  you  with  the  best  documentation  possible to ensure  successful  use of your  Microchip product.  If  you  wish  to  provide  your  comments  on  organization,  clarity,  subject  matter,  and  ways  in  which  our documentation  can  better  serve  you,  please  FAX  your  comments  to  the  Technical  Publications  Manager  at (480) 792-4150.\nPlease list the following information, and use this outline to provide us with your comments about this document.\nTO: Technical Publications Manager\nRE: Reader Response\nTotal Pages Sent ________\nFrom: Name\nCompany\nAddress\nCity / State / ZIP / Country\nTelephone: (_______) _________ - _________\nApplication (optional):\nWould you like a reply?       Y         N\nDevice:  PIC18F2331/2431/4331/4431\nLiterature Number:  DS39616D\nQuestions:\nFAX: (______) _________ - _________\n1. What are the best features of this document?\n2. How does this document meet your hardware and software development needs?",
    "READER RESPONSE\n3. Do you find the organization of this document easy to follow? If not, why?\n4. What additions to the document do you think would enhance the structure and subject?\n5. What deletions from the document could be made without affecting the overall usefulness?\n6. Is there any incorrect or misleading information (what and where)?\n7. How would you improve this document?",
    "PRODUCT IDENTIFICATION SYSTEM\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.",
    "PRODUCT IDENTIFICATION SYSTEM\nDevice, X Temperature Range = PIC18F2331/2431/4331/4431 (1) , PIC18F2331/2431/4331/4431T (1,2) ; VDD range 4.2V to 5.5V PIC18LF2331/2431/4331/4431 (1) , PIC18LF2331/2431/4331/44310T (1,2) ; VDD range 2.0V to 5.5V. Device, /XX Package = PIC18F2331/2431/4331/4431 (1) , PIC18F2331/2431/4331/4431T (1,2) ; VDD range 4.2V to 5.5V PIC18LF2331/2431/4331/4431 (1) , PIC18LF2331/2431/4331/44310T (1,2) ; VDD range 2.0V to 5.5V. Device, XXX Pattern = PIC18F2331/2431/4331/4431 (1) ,",
    "PRODUCT IDENTIFICATION SYSTEM\nPIC18F2331/2431/4331/4431T (1,2) ; VDD range 4.2V to 5.5V PIC18LF2331/2431/4331/4431 (1) , PIC18LF2331/2431/4331/44310T (1,2) ; VDD range 2.0V to 5.5V. Temperature Range, X Temperature Range = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Temperature Range, /XX Package = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Temperature Range, XXX Pattern = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Package, X Temperature Range = PT = TQFP (Thin Quad Flatpack) SO = SOIC SP = Skinny Plastic DIP P = PDIP. Package, /XX Package = PT = TQFP (Thin Quad Flatpack) SO = SOIC SP = Skinny Plastic DIP P = PDIP. Package, XXX Pattern = PT = TQFP",
    "PRODUCT IDENTIFICATION SYSTEM\n(Thin Quad Flatpack) SO = SOIC SP = Skinny Plastic DIP P = PDIP. Pattern, X Temperature Range = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, /XX Package = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, XXX Pattern = QTP, SQTP, Code or Special Requirements (blank otherwise)",
    "Examples:\na) PIC18LF4431-I/P 301 = Industrial temp., PDIP  package,  Extended  VDD  limits, QTP pattern #301.\nb) PIC18LF2331-I/SO  =  Industrial  temp., SOIC package, Extended VDD limits.\nc) PIC18F4331-I/P = Industrial temp., PDIP package, normal VDD limits.\nNote\n1: F = Standard Voltage Range LF= Wide Voltage Range\n- 2: T = in Tape and Reel - SOIC and TQFP Packages only.",
    "AMERICAS\nCorporate Office 2355 West Chandler Blvd. Chandler, AZ 85224-6199 Tel: 480-792-7200 Fax: 480-792-7277 Technical Support:\nhttp://support.microchip.com\nWeb Address:\nwww.microchip.com\nAtlanta Duluth, GA Tel: 678-957-9614 Fax: 678-957-1455",
    "Boston\nWestborough, MA Tel: 774-760-0087 Fax: 774-760-0088",
    "Chicago\nItasca, IL\nTel: 630-285-0071\nFax: 630-285-0075\nCleveland Independence, OH Tel: 216-447-0464 Fax: 216-447-0643\nDallas Addison, TX Tel: 972-818-7423 Fax: 972-818-2924\nDetroit Farmington Hills, MI Tel: 248-538-2250 Fax: 248-538-2260\nKokomo Kokomo, IN Tel: 765-864-8360 Fax: 765-864-8387",
    "Los Angeles\nMission Viejo, CA Tel: 949-462-9523 Fax: 949-462-9608\nSanta Clara Santa Clara, CA Tel: 408-961-6444 Fax: 408-961-6445\nToronto Mississauga, Ontario, Canada Tel: 905-673-0699 Fax: 905-673-6509",
    "ASIA/PACIFIC\nAsia Pacific Office Suites 3707-14, 37th Floor Tower 6, The Gateway Harbour City, Kowloon Hong Kong Tel: 852-2401-1200 Fax: 852-2401-3431\nAustralia - Sydney Tel: 61-2-9868-6733 Fax: 61-2-9868-6755\nChina - Beijing Tel: 86-10-8528-2100 Fax: 86-10-8528-2104\nChina - Chengdu Tel: 86-28-8665-5511 Fax: 86-28-8665-7889",
    "China - Chongqing\nTel: 86-23-8980-9588 Fax: 86-23-8980-9500\nChina - Hong Kong SAR Tel: 852-2401-1200 Fax: 852-2401-3431\nChina - Nanjing Tel: 86-25-8473-2460 Fax: 86-25-8473-2470\nChina - Qingdao Tel: 86-532-8502-7355 Fax: 86-532-8502-7205\nChina - Shanghai Tel: 86-21-5407-5533 Fax: 86-21-5407-5066\nChina - Shenyang Tel: 86-24-2334-2829 Fax: 86-24-2334-2393\nChina - Shenzhen Tel: 86-755-8203-2660 Fax: 86-755-8203-1760\nChina - Wuhan Tel: 86-27-5980-5300 Fax: 86-27-5980-5118\nChina - Xian Tel: 86-29-8833-7252 Fax: 86-29-8833-7256",
    "China - Chongqing\nChina - Xiamen Tel: 86-592-2388138 Fax: 86-592-2388130\nChina - Zhuhai Tel: 86-756-3210040 Fax: 86-756-3210049\nIndia - Bangalore Tel: 91-80-3090-4444 Fax: 91-80-3090-4123\nIndia - New Delhi Tel: 91-11-4160-8631 Fax: 91-11-4160-8632\nIndia - Pune Tel: 91-20-2566-1512 Fax: 91-20-2566-1513\nJapan - Yokohama Tel: 81-45-471- 6166 Fax: 81-45-471-6122",
    "Korea - Daegu\nTel: 82-53-744-4301\nFax: 82-53-744-4302\nKorea - Seoul Tel: 82-2-554-7200 Fax: 82-2-558-5932 or 82-2-558-5934\nMalaysia - Kuala Lumpur Tel: 60-3-6201-9857 Fax: 60-3-6201-9859\nMalaysia - Penang Tel: 60-4-227-8870 Fax: 60-4-227-4068\nPhilippines - Manila Tel: 63-2-634-9065 Fax: 63-2-634-9069",
    "Singapore\nTel: 65-6334-8870 Fax: 65-6334-8850\nTaiwan - Hsin Chu Tel: 886-3-6578-300 Fax: 886-3-6578-370\nTaiwan - Kaohsiung\nTel: 886-7-213-7830\nFax: 886-7-330-9305\nTaiwan - Taipei Tel: 886-2-2500-6610 Fax: 886-2-2508-0102",
    "Thailand - Bangkok\nTel: 66-2-694-1351 Fax: 66-2-694-1350",
    "EUROPE\nAustria - Wels Tel: 43-7242-2244-39 Fax: 43-7242-2244-393 Denmark - Copenhagen Tel: 45-4450-2828\nFax: 45-4485-2829\nFrance - Paris Tel: 33-1-69-53-63-20 Fax: 33-1-69-30-90-79\nGermany - Munich Tel: 49-89-627-144-0 Fax: 49-89-627-144-44",
    "Italy - Milan\nTel: 39-0331-742611 Fax: 39-0331-466781",
    "Netherlands - Drunen\nTel: 31-416-690399 Fax: 31-416-690340\nSpain - Madrid Tel: 34-91-708-08-90 Fax: 34-91-708-08-91\nUK - Wokingham Tel: 44-118-921-5869 Fax: 44-118-921-5820",
    "Mouser Electronics\nAuthorized Distributor\nClick to View Pricing, Inventory, Delivery & Lifecycle Information:",
    "Microchip:\nPIC18F4431-E/P\u00a0 PIC18F4331-I/P\u00a0 PIC18F4431-I/P\u00a0 PIC18F4331-E/P\u00a0 PIC18F2431T-I/SO\u00a0 PIC18F4331-E/PT PIC18F4431-E/PT\u00a0 PIC18LF2431-I/SO\u00a0 PIC18LF2331-I/SO\u00a0 PIC18LF2331-I/SP\u00a0 PIC18LF2431-I/SP\u00a0 PIC18F2331-I/MM PIC18LF4431-I/P\u00a0 PIC18LF4331-I/P\u00a0 PIC18LF4431-I/PT\u00a0 PIC18LF4331-I/PT\u00a0 PIC18LF4431-I/ML\u00a0 PIC18F2431-I/SO PIC18F2431-I/SP\u00a0 PIC18F2331-I/SO\u00a0 PIC18F2331-I/SP\u00a0 PIC18F4431-I/PT\u00a0 PIC18F4331-I/PT\u00a0 PIC18F2331-E/MM PIC18F2331-E/SO\u00a0 PIC18F2331-E/SP\u00a0 PIC18F2431-E/SO",
    "Microchip:\nPIC18F4431-I/ML\u00a0 PIC18F4331-I/ML\u00a0 PIC18F4431T-I/PT PIC18F2431-E/MM\u00a0 PIC18F2431-I/MM\u00a0 PIC18LF2331-I/MM\u00a0 PIC18LF2331T-I/MM\u00a0 PIC18LF2431-I/MM"
]
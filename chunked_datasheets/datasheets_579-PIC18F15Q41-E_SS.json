[
    "14/20-Pin, Low-Power, High-Performance Microcontroller with XLP Technology\nPIC18F04/05/14/15Q41",
    "Introduction\nThe PIC18-Q41 microcontroller family is available in 14/20-pin devices for sensor and real-time control applications. This analog-focused family features a 12-bit ADC with Computation (ADCC) automating Capacitive Voltage Divider (CVD) techniques for advanced capacitive touch sensing, averaging, filtering, oversampling and threshold comparison, two 8-bit DAC modules and an Operational Amplifier. The family showcases a 16-bit PWM module that provides dual independent outputs on the same time base. Additional features include vectored interrupt controller with fixed latency for handling interrupts, system bus arbiter, Direct Memory Access (DMA) capabilities, UART with support for asynchronous, DMX, DALI and LIN protocols, SPI, I 2 C, and a programmable 32-bit CRC with Memory Scan. This family also includes memory features such as Memory Access Partition (MAP) to support users in data protection and bootloader applications, as well as Device Information Area (DIA) that stores factory calibration values to help improve temperature sensor accuracy.",
    "PIC18-Q41 Family Types\nTable 1. Devices Included in This Data Sheet",
    "PIC18-Q41 Family Types\nPIC18F04Q41, Program Memory Flash (bytes) = 16k. PIC18F04Q41, Data SRAM (bytes) = 1024. PIC18F04Q41, Data EEPROM (bytes) = 512. PIC18F04Q41, Memory Access Partition/ Device Information Area = Y/Y. PIC18F04Q41, I/O Pins/ Peripheral Pin Select = 12/Y. PIC18F04Q41, 8-Bit Timer with HLT/ 16-Bit Timers = 2/3. PIC18F04Q41, 16-Bit Dual PWM/ CCP Complementary = 3/1. PIC18F04Q41, Waveform Generator = 1. PIC18F04Q41, Signal Measurement Timer = 1. PIC18F04Q41, Numerically Controlled Oscillator = 1. PIC18F04Q41, Configurable Logic Cell = 4. PIC18F04Q41, 12-Bit ADCC (channels) 8-Bit DAC = 11. PIC18F04Q41, Operational Amplifier = 2 1.",
    "PIC18-Q41 Family Types\nPIC18F04Q41, Comparator/ Zero-Cross Detect = 2/1. PIC18F04Q41, High/Low- Voltage Detect = 1. PIC18F04Q41, 2 = 2/1. PIC18F04Q41, SPI/I C UART/ = 2/1. PIC18F04Q41, UART with Protocol Support Memory Access (DMA) = 4. PIC18F04Q41, Direct Windowed Watchdog Timer = Y. PIC18F04Q41, 32-Bit CRC with Scanner Vectored Interrupts Y Y = Y. PIC18F04Q41, Peripheral Module Disable Temperature Indicator = Y. PIC18F05Q41, Program Memory Flash (bytes) = 32k. PIC18F05Q41, Data SRAM (bytes) = 2048. PIC18F05Q41, Data EEPROM (bytes) = 512. PIC18F05Q41, Memory Access Partition/ Device Information Area = Y/Y. PIC18F05Q41, I/O Pins/ Peripheral Pin Select = 12/Y.",
    "PIC18-Q41 Family Types\nPIC18F05Q41, 8-Bit Timer with HLT/ 16-Bit Timers = 2/3. PIC18F05Q41, 16-Bit Dual PWM/ CCP Complementary = 3/1. PIC18F05Q41, Waveform Generator = 1. PIC18F05Q41, Signal Measurement Timer = 1. PIC18F05Q41, Numerically Controlled Oscillator = 1. PIC18F05Q41, Configurable Logic Cell = 4. PIC18F05Q41, 12-Bit ADCC (channels) 8-Bit DAC = 11. PIC18F05Q41, Operational Amplifier = 2 1. PIC18F05Q41, Comparator/ Zero-Cross Detect = 2/1. PIC18F05Q41, High/Low- Voltage Detect = 1. PIC18F05Q41, 2 = 2/1. PIC18F05Q41, SPI/I C UART/ = 2/1. PIC18F05Q41, UART with Protocol Support Memory Access (DMA) = 4 4.",
    "PIC18-Q41 Family Types\nPIC18F05Q41, Direct Windowed Watchdog Timer = Y Y. PIC18F05Q41, 32-Bit CRC with Scanner Vectored Interrupts Y Y = Y Y. PIC18F05Q41, Peripheral Module Disable Temperature Indicator = Y. PIC18F14Q41, Program Memory Flash (bytes) = 16k. PIC18F14Q41, Data SRAM (bytes) = 1024. PIC18F14Q41, Data EEPROM (bytes) = 512. PIC18F14Q41, Memory Access Partition/ Device Information Area = Y/Y. PIC18F14Q41, I/O Pins/ Peripheral Pin Select = 18/Y. PIC18F14Q41, 8-Bit Timer with HLT/ 16-Bit Timers = 2/3. PIC18F14Q41, 16-Bit Dual PWM/ CCP Complementary = 3/1. PIC18F14Q41, Waveform Generator = 1. PIC18F14Q41, Signal Measurement Timer = 1. PIC18F14Q41, Numerically Controlled Oscillator = 1. PIC18F14Q41,",
    "PIC18-Q41 Family Types\nConfigurable Logic Cell = 4. PIC18F14Q41, 12-Bit ADCC (channels) 8-Bit DAC = 17. PIC18F14Q41, Operational Amplifier = 2 1. PIC18F14Q41, Comparator/ Zero-Cross Detect = 2/1. PIC18F14Q41, High/Low- Voltage Detect = 1. PIC18F14Q41, 2 = 2/1. PIC18F14Q41, SPI/I C UART/ = 2/1. PIC18F14Q41, UART with Protocol Support Memory Access (DMA) = Y. PIC18F14Q41, Direct Windowed Watchdog Timer = Y. PIC18F14Q41, 32-Bit CRC with Scanner Vectored Interrupts Y Y = Y Y. PIC18F14Q41, Peripheral Module Disable Temperature Indicator = Y. PIC18F15Q41, Program Memory Flash (bytes) = 32k. PIC18F15Q41, Data SRAM (bytes) = 2048. PIC18F15Q41, Data EEPROM (bytes) = 512. PIC18F15Q41,",
    "PIC18-Q41 Family Types\nMemory Access Partition/ Device Information Area = Y/Y. PIC18F15Q41, I/O Pins/ Peripheral Pin Select = 18/Y. PIC18F15Q41, 8-Bit Timer with HLT/ 16-Bit Timers = 2/3. PIC18F15Q41, 16-Bit Dual PWM/ CCP Complementary = 3/1. PIC18F15Q41, Waveform Generator = 1. PIC18F15Q41, Signal Measurement Timer = 1. PIC18F15Q41, Numerically Controlled Oscillator = 1. PIC18F15Q41, Configurable Logic Cell = 4. PIC18F15Q41, 12-Bit ADCC (channels) 8-Bit DAC = 17. PIC18F15Q41, Operational Amplifier = 2 1. PIC18F15Q41, Comparator/ Zero-Cross Detect = 2/1. PIC18F15Q41, High/Low- Voltage Detect = 1. PIC18F15Q41, 2 = 2/1. PIC18F15Q41, SPI/I C UART/ = 2/1.",
    "PIC18-Q41 Family Types\nPIC18F15Q41, UART with Protocol Support Memory Access (DMA) = 4 Y. PIC18F15Q41, Direct Windowed Watchdog Timer = Y. PIC18F15Q41, 32-Bit CRC with Scanner Vectored Interrupts Y Y = Y Y. PIC18F15Q41, Peripheral Module Disable Temperature Indicator = Y\nTable 2. Devices Not Included in This Data Sheet",
    "PIC18-Q41 Family Types\nPIC18F06Q41, Program Memory Flash (bytes) = 64k. PIC18F06Q41, Data SRAM (bytes) = 4096. PIC18F06Q41, Data EEPROM (bytes) Memory Access Partition/ Device Information Area 512 = Y/Y. PIC18F06Q41, I/O Pins/ Peripheral Pin Select = 12/Y. PIC18F06Q41, 8-Bit Timer with HLT/ 16-Bit Timers = 2/3. PIC18F06Q41, 16-Bit Dual PWM/ CCP = 3/1. PIC18F06Q41, Complimentary Waveform Generator Signal Measurement Timer = 1. PIC18F06Q41, Numerically Controlled Oscillator = 1. PIC18F06Q41, Configurable Logic Cell = 4. PIC18F06Q41, 12-Bit ADCC (channels) 8-Bit DAC Operational Amplifier = 2 1. PIC18F06Q41, Comparator/ Zero-Cross Detect High-Low Voltage Detect = 2/1 1 1.",
    "PIC18-Q41 Family Types\nPIC18F06Q41, SPI/I 2 C UART/ = 2/1. PIC18F06Q41, UART with Protocol Support Direct Memory Access (DMA) = 2/1 4 Y. PIC18F06Q41, Windowed Watchdog Timer 32-Bit CRC with Scanner = Y. PIC18F06Q41, Vectored Interrupts = Y. PIC18F06Q41, Peripheral Module Disable Temperature Indicator = Y. PIC18F16Q41, Program Memory Flash (bytes) = 64k. PIC18F16Q41, Data SRAM (bytes) = 4096. PIC18F16Q41, Data EEPROM (bytes) Memory Access Partition/ Device Information Area 512 = 512 Y/Y. PIC18F16Q41, I/O Pins/ Peripheral Pin Select = 18/Y. PIC18F16Q41, 8-Bit Timer with HLT/ 16-Bit Timers = 2/3. PIC18F16Q41, 16-Bit Dual PWM/ CCP = 3/1. PIC18F16Q41, Complimentary Waveform Generator Signal Measurement Timer",
    "PIC18-Q41 Family Types\n= 1. PIC18F16Q41, Numerically Controlled Oscillator = 1. PIC18F16Q41, Configurable Logic Cell = 4. PIC18F16Q41, 12-Bit ADCC (channels) 8-Bit DAC Operational Amplifier = 2 1. PIC18F16Q41, Comparator/ Zero-Cross Detect High-Low Voltage Detect = 2/1. PIC18F16Q41, SPI/I 2 C UART/ = 2/1. PIC18F16Q41, UART with Protocol Support Direct Memory Access (DMA) = 2/1 4 Y. PIC18F16Q41, Windowed Watchdog Timer 32-Bit CRC with Scanner = Y. PIC18F16Q41, Vectored Interrupts = Y. PIC18F16Q41, Peripheral Module Disable Temperature Indicator = Y",
    "Features\n\u00b7 C Compiler Optimized RISC Architecture\n\u00b7 Operating Speed:\n-DC - 64 MHz clock input\n-62.5 ns minimum instruction cycle\n\u00b7 Four Direct Memory Access (DMA) Controllers:\n-Data transfers to SFR/GPR spaces from either Program Flash Memory, Data EEPROM, or SFR/GPR spaces\n-User-programmable source and destination sizes\n-Hardware and software triggered data transfers\n\u00b7 Vectored Interrupt Capability:\n-Selectable high/low priority\n-Fixed interrupt latency of three instruction cycles\n-Programmable vector table base address\n-Backward compatible with previous interrupt capabilities\n\u00b7 128-Level Deep Hardware Stack\n\u00b7 Low-Current Power-on Reset (POR)\n\u00b7 Configurable Power-up Timer (PWRT)\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Low-Power BOR (LPBOR) Option\n\u00b7 Windowed Watchdog Timer (WWDT):\n-Watchdog Reset on too long or too short interval between watchdog clear events\n-Variable prescaler selection\n-Variable window size selection",
    "Memory\n\u00b7 Up to 64 KB of Program Flash Memory\n\u00b7 Up to 4 KB of Data SRAM Memory\n\u00b7 512 Bytes Data EEPROM\n\u00b7 Memory Access Partition: The Program Flash Memory Can Be Partitioned into:\n-Application Block\n-Boot Block\n-Storage Area Flash (SAF) Block\n\u00b7 Programmable Code Protection and Write Protection\n\u00b7 Device Information Area (DIA) Stores:\n-Temperature indicator factory calibrated data\n-Fixed Voltage Reference measurement data\n-Microchip Unique Identifier\n\u00b7 Device Characteristics Information (DCI) Area Stores:\n-Program/erase row sizes\n-Pin count details\n-EEPROM size\n\u00b7 Direct, Indirect and Relative Addressing Modes",
    "Operating Characteristics\n\u00b7 Operating Voltage Range:\n-1.8V to 5.5V\n\u00b7 Temperature Range:\n-Industrial: -40\u00b0C to 85\u00b0C\n-Extended: -40\u00b0C to 125\u00b0C",
    "Power-Saving Functionality\n\u00b7 Doze: CPU and Peripherals Running at Different Cycle Rates (Typically CPU Is Lower)\n\u00b7 Idle: CPU Halted While Peripherals Operate\n\u00b7 Sleep: Lowest Power Consumption\n\u00b7 Peripheral Module Disable (PMD):\n-Ability to selectively disable hardware module to minimize active power consumption of unused peripherals\n\u00b7 Low Power Mode Features:\n-Sleep: < 1 \u00b5A typical @ 3V\n-Operating Current:\n\u00b7 48 \u00b5A @ 32 kHz, 3V, typical",
    "Digital Peripherals\n\u00b7 Three 16-Bit Pulse-Width Modulators (PWM):\n-Dual outputs for each PWM module\n-Integrated 16-bit timer/counter\n-Double-buffered user registers for duty cycles\n-Right/Left/Center/Variable Aligned modes of operation\n-Multiple clock and Reset signal selections\n\u00b7 Three 16-Bit Timers (TMR0/1/3)\n\u00b7 Two 8-Bit Timers (TMR2/4) with Hardware Limit Timer (HLT)\n\u00b7 Four Configurable Logic Cell (CLC):\n-Integrated combinational and sequential logic\n\u00b7 One Complementary Waveform Generator (CWG):\n-Rising and falling edge dead-band control\n-Full-bridge, half-bridge, 1-channel drive",
    "Digital Peripherals\n-Multiple signal sources\n-Programmable dead band\n-Fault-shutdown input\n\u00b7 One Capture/Compare/PWM (CCP) Module:\n-16-bit resolution for Capture/Compare modes\n-10-bit resolution for PWM mode\n\u00b7 One Numerically Controlled Oscillator (NCO):\n-Generates true linear frequency control and increased frequency resolution\n-Input clock up to 64 MHz\n\u00b7 Signal Measurement Timer (SMT):\n-24-bit timer/counter with prescaler\n-Several modes of operation like Time-of-Flight, Period and Duty Cycle Measurement, etc.\n\u00b7 Data Signal Modulator (DSM):\n-Multiplex two carrier clocks, with glitch prevention feature\n-Multiple sources for each carrier\n\u00b7 Programmable CRC with Memory Scan:\n-Reliable data/program memory monitoring for Fail-Safe operation (e.g., Class B)\n-Calculate 32-bit CRC over any portion of Program Flash Memory\n\u00b7 Three UART Modules:\n-One module (UART1) supports LIN host and client, DMX mode, DALI gear, and device protocols\n-Asynchronous UART, RS-232, RS-485 compatible\n-Automatic and user timed BREAK period generation",
    "Digital Peripherals\n-Automatic checksums\n-Programmable Stop bits (1, 1.5 and 2 Stop bits)\n-Wake-up on BREAK reception\n-DMA compatible\n\u00b7 Two SPI Modules:\n-Configurable length bytes\n-Arbitrary length data packets\n-Transmit-without-receive and receive-without-transmit options\n-Transfer byte counter\n-Separate transmit and receive buffers with 2-byte FIFO and DMA capabilities\n\u00b7 One I 2 C Module, SMBus, PMBus \u2122 Compatible:\n-Supports Standard mode (100 kHz), Fast mode (400 kHz) and Fast mode Plus (1 MHz) modes of operation\n-7-bit and 10-bit Addressing modes with Address Masking modes\n-Dedicated address, transmit and receive buffers, and DMA capabilities\n-Bus collision detection with arbitration\n-Bus time-out detection and handling\n-I 2 C, SMBus 2.0 and SMBus 3.0, and 1.8V input level selections\n-Separate transmit and receive buffers with 2-byte FIFO and DMA capabilities\n-Multi-Host mode, including self-addressing",
    "Digital Peripherals\n\u00b7 Device I/O Port Features:\n-12 I/O pins (PIC18F04/05/06Q41)\n-18 I/O pins (PIC18F14/15/16Q41)\n-Individually programmable I/O direction, open-drain, slew rate and weak pull-up control\n-Interrupt-on-change on most pins\n-Three programmable external interrupt pins\n\u00b7 Peripheral Pin Select (PPS):\n-Enables pin mapping of digital I/O",
    "Analog Peripherals\n\u00b7 Analog-to-Digital Converter with Computation (ADCC):\n-Up to 17 external channels\n-Up to 140 KSPS\n-Automated math functions on input signals:\n\u00b7 Averaging, filter calculations, oversampling and threshold comparison\n-Operates in Sleep\n-Four internal analog channels\n-Hardware Capacitive Voltage Divider (CVD) support:\n\u00b7 Adjustable Sample-and-Hold capacitor array\n\u00b7 Guard ring digital output drive\n\u00b7 Automates touch sampling and reduces software size and CPU usage when touch or proximity sensing is required\n\u00b7 Two 8-Bit Digital-to-Analog Converters (DAC):\n-Buffered output available on two I/O pins\n-Internal connections to ADC and Comparators\n\u00b7 Two Comparators (CMP):\n-Four external inputs\n-Configurable output polarity\n-External output via Peripheral Pin Select\n\u00b7 One Operational Amplifier:\n-5.5 MHz gain bandwidth\n-Programmable gain\n-Internal gain resistor ladder\n\u00b7 Zero-Cross Detect (ZCD):\n-Detect when the AC signal on pin crosses ground\n\u00b7 Voltage Reference:\n-Fixed Voltage Reference with 1.024V, 2.048V and 4.096V output levels",
    "Analog Peripherals\n-Internal connections to ADC, Comparator and DAC",
    "Clocking Structure\n\u00b7 High-Precision Internal Oscillator Block (HFINTOSC):\n-Selectable frequencies up to 64 MHz\n-\u00b11% at calibration\n-Active Clock Tuning of HFINTOSC for better accuracy\n\u00b7 32 kHz Low-Power Internal Oscillator (LFINTOSC)\n\u00b7 External 32 kHz Crystal Oscillator (SOSC)\n\u00b7 External High-Frequency Oscillator Block:\n-Three Crystal/Resonator modes\n-Digital Clock Input mode\n-4x PLL with external sources\n\u00b7 Fail-Safe Clock Monitor:\n-Allows for operational recovery if external clock stops\n\u00b7 Oscillator Start-up Timer (OST):\n-Ensures stability of crystal oscillator sources",
    "Programming/Debug Features\n\u00b7 In-Circuit Serial Programming \u2122 (ICSP \u2122 ) via Two Pins\n\u00b7 In-Circuit Debug (ICD) with Three Breakpoints via Two Pins\n\u00b7 Debug Integrated On-Chip",
    "PIC18-Q41 Block Diagram\n\u6174\n\u6120\n\u656d\n\u6f72\n\u2852\n\u414d\n\u6573\n\u6574\n\u5072\n\u6973\n\u696f\n\u6e20\n\u4261\n\u6420\n\u6170\n\u6572\n\u6e63\n\u5374\n\u6172\n\u6c61\n\u5369\n\u6e67\n\u656d\n\u6820\n\u6f72\n\u5072\n\u6c65\n\u6772\n\u616d\n\u696e\n\u506f\n\u6572\n\u696c\n\u6c61\n\u6f72\n\u696d\n\u6572\n\u6174\n\u6120\n\u7570\n\u696d\n\u6572\n\u5375\n\u706c\n\u7570\n\u6f6e\n\u6c6f\n\u6f6e\n\u6974\n\u6f72\n\u656d\n\u7065\n\u6174\n\u7572\n\u6520\n\u4272\n\u496e\n\u6169\n\u6963\n\u6573\n\u6574\n\u504d\n\u5361\n\u6520\n\u6f75\n\u5050\n\u6f64\n\u6c65\n\u4558\n\u4558\n\u4f53\n\u534f\n\u3478\n\u504c\n\u4163\n\u6520\n\u6c6f\n\u5343\n\u756e\n\u696e\n\u6974\n\u696d\n\u6572\n\u4357\n\u5057\n\u534d\n\u4f50\n\u534d\n\u4c43\n\u4144\n\u4152\n\u4c56\n\u434d\n\u4143\n\u5350",
    "Table of Contents\nIntroduction........................................................................................................................................................................... 1, 1 =",
    "Table of Contents\nIntroduction........................................................................................................................................................................... 1. PIC18-Q41 Family",
    "Table of Contents\nTypes.......................................................................................................................................................1, 1 = PIC18-Q41 Family",
    "Table of Contents\nTypes.......................................................................................................................................................1.",
    "Table of Contents\nFeatures................................................................................................................................................................................. 2, 1 =",
    "Table of Contents\nFeatures................................................................................................................................................................................. 2. 1., 1 =",
    "Table of Contents\nPackages.......................................................................................................................................................................10. 2., 1 = Pin",
    "Table of Contents\nDiagrams................................................................................................................................................................11. 3., 1 = Pin Allocation",
    "Table of Contents\nTables................................................................................................................................................... 13. 4., 1 = Guidelines for Getting Started with PIC18-Q41 Microcontrollers......................................................................... 17. 5., 1 = Register and Bit",
    "Table of Contents\nNaming Conventions......................................................................................................................22. 6., 1 = Register",
    "Table of Contents\nLegend........................................................................................................................................................... 24. 7., 1 = PIC18",
    "Table of Contents\nCPU.....................................................................................................................................................................25. 8., 1 = Device",
    "Table of Contents\nConfiguration.................................................................................................................................................. 43. 9., 1 = Memory",
    "Table of Contents\nOrganization.................................................................................................................................................57. 10., 1 = NVM - Nonvolatile Memory",
    "Table of Contents\nModule......................................................................................................................... 87. 11., 1 = VIC - Vectored Interrupt Controller Module...........................................................................................................113. 12., 1 = OSC -",
    "Table of Contents\nOscillator Module (With Fail-Safe Clock Monitor)....................................................................................... 175. 13., 1 = CRC - Cyclic Redundancy Check Module with Memory Scanner......................................................................... 203. 14., 1 =",
    "Table of Contents\nResets......................................................................................................................................................................... 222. 15., 1 = WWDT - Windowed Watchdog",
    "Table of Contents\nTimer..................................................................................................................... 236. 16., 1 = DMA - Direct Memory",
    "Table of Contents\nAccess.................................................................................................................................. 246. 17., 1 = Power-Saving",
    "Table of Contents\nModes................................................................................................................................................ 283. 18., 1 = PMD - Peripheral Module",
    "Table of Contents\nDisable........................................................................................................................... 292. 19., 1 = I/O",
    "Table of Contents\nPorts..................................................................................................................................................................... 300. 20., 1 = IOC -",
    "Table of Contents\nInterrupt-on-Change....................................................................................................................................... 315. 21., 1 = PPS - Peripheral Pin Select",
    "Table of Contents\nModule.........................................................................................................................321. 22., 1 = CLC - Configurable Logic",
    "Table of Contents\nCell................................................................................................................................... 331. 23., 1 = CLKREF - Reference Clock Output",
    "Table of Contents\nModule............................................................................................................. 351. 24., 1 = TMR0 - Timer0",
    "Table of Contents\nModule............................................................................................................................................. 356. 25., 1 = TMR1 - Timer1 Module with Gate",
    "Table of Contents\nControl............................................................................................................. 364. 26., 1 = TMR2 - Timer2",
    "Table of Contents\nModule............................................................................................................................................. 381",
    "Table of Contents\n27.\u00a0 SMT - Signal Measurement Timer........................................................................................................................... 402",
    "Table of Contents\n28., 1 = CCP - Capture/Compare/PWM Module.................................................................................................................. 426. 29. Capture,, 1 = Compare, and PWMTimers Selection.................................................................................................... 439.",
    "Table of Contents\n30. PWM-, 1 = Pulse-Width Modulator with Compare...................................................................................................... 442. 31., 1 = CWG - Complementary Waveform Generator Module........................................................................................ 469. 32., 1 = NCO - Numerically Controlled Oscillator",
    "Table of Contents\nModule................................................................................................. 497. 33., 1 = DSM - Data Signal Modulator Module.................................................................................................................... 506. 34., 1 = UART - Universal Asynchronous Receiver Transmitter with Protocol",
    "Table of Contents\nSupport................................................. 517. 35., 1 = SPI - Serial Peripheral Interface Module.................................................................................................................568. 36. I 2 C -, 1 = Inter-Integrated Circuit",
    "Table of Contents\nModule...................................................................................................................... 602. 37., 1 = HLVD - High/Low-Voltage",
    "Table of Contents\nDetect.............................................................................................................................696. 38. FVR - Fixed, 1 = Voltage",
    "Table of Contents\nReference................................................................................................................................. 704. 39., 1 = Temperature Indicator",
    "Table of Contents\nModule............................................................................................................................... 709. 40. ADCC, 1 = - Analog-to-Digital Converter with Computation Module......................................................................... 715. 41., 1 = DAC - Digital-to-Analog Converter",
    "Table of Contents\nModule............................................................................................................ 760. 42., 1 = OPA - Operational Amplifier....................................................................................................................................",
    "Table of Contents\n768. 43., 1 = CMP - Comparator Module...................................................................................................................................... 780. 44., 1 = ZCD - Zero-Cross Detection",
    "Table of Contents\nModule....................................................................................................................... 791. 45., 1 = Instruction Set",
    "Table of Contents\nSummary......................................................................................................................................... 799. 46., 1 = ICSP \u2122 - In-Circuit Serial Programming \u2122",
    "Table of Contents\n.................................................................................................................. 875. 47., 1 = Register",
    "Table of Contents\nSummary.....................................................................................................................................................878. 48. Electrical, 1 =",
    "Table of Contents\nSpecifications............................................................................................................................................ 890. 49. DC and, 1 = AC Characteristics Graphs and",
    "Table of Contents\nTables...................................................................................................... 916. 50., 1 = Packaging",
    "Table of Contents\nInformation............................................................................................................................................. 940. 51., 1 = Appendix A: Revision",
    "Table of Contents\nHistory...................................................................................................................................962. Microchip, 1 =",
    "Table of Contents\nInformation..................................................................................................................................................... 963",
    "1. Packages\n\nTable 1-1. Packages",
    "1. Packages\nPIC18F04Q41, 14-Pin TSSOP = \u25cf. PIC18F04Q41, 14-Pin SOIC = \u25cf. PIC18F04Q41, 20-Pin PDIP = . PIC18F04Q41, 20-Pin SOIC = . PIC18F04Q41, 20-Pin SSOP = . PIC18F04Q41, 20-Pin VQFN = . PIC18F05Q41, 14-Pin TSSOP = \u25cf. PIC18F05Q41, 14-Pin SOIC = \u25cf. PIC18F05Q41, 20-Pin PDIP = . PIC18F05Q41, 20-Pin SOIC = . PIC18F05Q41, 20-Pin SSOP = . PIC18F05Q41, 20-Pin VQFN = . PIC18F06Q41, 14-Pin TSSOP = \u25cf. PIC18F06Q41, 14-Pin SOIC = \u25cf. PIC18F06Q41, 20-Pin PDIP = . PIC18F06Q41, 20-Pin SOIC = .",
    "1. Packages\nPIC18F06Q41, 20-Pin SSOP = . PIC18F06Q41, 20-Pin VQFN = . PIC18F14Q41, 14-Pin TSSOP = . PIC18F14Q41, 14-Pin SOIC = . PIC18F14Q41, 20-Pin PDIP = \u25cf. PIC18F14Q41, 20-Pin SOIC = \u25cf. PIC18F14Q41, 20-Pin SSOP = \u25cf. PIC18F14Q41, 20-Pin VQFN = \u25cf. PIC18F15Q41, 14-Pin TSSOP = . PIC18F15Q41, 14-Pin SOIC = . PIC18F15Q41, 20-Pin PDIP = \u25cf. PIC18F15Q41, 20-Pin SOIC = \u25cf. PIC18F15Q41, 20-Pin SSOP = \u25cf. PIC18F15Q41, 20-Pin VQFN = \u25cf. PIC18F16Q41, 14-Pin TSSOP = . PIC18F16Q41, 14-Pin SOIC = . PIC18F16Q41, 20-Pin PDIP =",
    "1. Packages\n\u25cf. PIC18F16Q41, 20-Pin SOIC = \u25cf. PIC18F16Q41, 20-Pin SSOP = \u25cf. PIC18F16Q41, 20-Pin VQFN = \u25cf",
    "2. Pin Diagrams\nFigure 2-1.\n14-Pin SOIC\n14-Pin TSSOP\nFigure 2-2.\n20-Pin PDIP\n20-Pin SOIC\n20-Pin SSOP\nFigure 2-3. 20-Pin VQFN\n\u4d43\n\u4d43\n\u5050\n\u5050\n\u5243\n\u5243\n\u5243\n\u5243\n\u5243\n\u4444\n\u3230\n\u5353\n\u5241\n\u3139\n\u5241\n\u4154\n\u5350\n\u5241\n\u5241\n\u5241\n\u5243\n\u5243\n\u5243\n\u5243\n\u5243\n\u5241\n\u5241\n\u5242\n\u4444\n\u3130\n\u3138\n\u3137\n\u3136\n\u3135\n\u3134\n\u3133\n\u3132\n\u3131\n\u3134\n\u3133\n\u3132\n\u3131\n\u3130\n\u5242\n\u5242\n\u5242\n\u5243\n\u5243\n\u5243\n\u5241\n\u5241\n\u5243\n\u5241\n\u5241\n\u5241\n\u5353\n\u5350\n\u4154\n\u5350\n\u5350\n\u4d43\n\u5050\n\u5243\n\u5243\n\u5243\n\u5243\n\u5241\n\u5241\n\u3230\n\u5243\n\u5241\n\u3139\n\u5242\n\u3138\n\u4444\n\u5242\n\u3137\n\u5353\n\u5242\n\u5350\n\u4154\n\u5241\n\u3130\n\u3136\n\u5242\n\u3132\n\u3133\n\u3134\n\u3135\n\u3131\n\u5243\n\u5243\n\u5241\n\u5241\n\u5243\n\u5350\nNote: It is recommended that the exposed bottom pad be connected to VSS; however, it must not be the only V SS connection to the device.",
    "Pin Allocation Tables\n14-Pin Allocation Table\n3.\nTable 3-1.",
    "Pin Allocation Tables\nInterrupts -, ICDDAT ICSPDAT = -. Interrupts -, ICDCLK ICSPCLK = INT0 (1). Interrupts -, - = -. Interrupts -, MCLR V PP = INT1 (1). Interrupts -, CLKOUT SOSCO OSC2 = INT2 (1). Interrupts -, CLKIN SOSCI OSC1 = -. Interrupts -, - = -. Interrupts -, - = -. Interrupts -, - = -. Interrupts -, - = -. Interrupts -, - - = -. Interrupts -, V = -. Interrupts -, DD V SS = -. IOCA0, ICDDAT ICSPDAT = IOCA1. IOCA0, ICDCLK ICSPCLK = IOCA2. IOCA0, - = IOCA3. IOCA0, MCLR V PP = IOCA4. IOCA0, CLKOUT SOSCO OSC2 = IOCA5. IOCA0, CLKIN SOSCI OSC1 = IOCC0. IOCA0, - = IOCC1. IOCA0, - =",
    "Pin Allocation Tables\nIOCC2. IOCA0, - = IOCC3. IOCA0, - = IOCC4. IOCA0, - - = IOCC5. IOCA0, V = - -. IOCA0, DD V SS = IOC. -, ICDDAT ICSPDAT = MDSRC (1). -, ICDCLK ICSPCLK = -. -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 = -. -, CLKIN SOSCI OSC1 = -. -, - = -. -, - = MDCARL (1). -, - = -. -, - = -. -, - - = MDCARH (1). -, V = - -. -, DD V SS = DSM. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = -. -, - = -. -, MCLR V PP = RX3 (1). -, CLKOUT SOSCO OSC2 = CTS3 (1). -, CLKIN SOSCI OSC1",
    "Pin Allocation Tables\n= -. -, - = RX2 (1). -, - = CTS2 (1). -, - = -. -, - = CTS1 (1). -, - - = RX1 (1). -, V = - -. -, DD V SS = UART. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = -. -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 = -. -, CLKIN SOSCI OSC1 = SCL1 (3,4). -, - = SDA1 (3,4). -, - = -. -, - = -. -, - = -. -, - - = . -, V = - -. -, DD V SS = I 2 C. SS2 (1), ICDDAT ICSPDAT = -. SS2 (1), ICDCLK ICSPCLK = -. SS2 (1), - = -. SS2 (1), MCLR V PP = -. SS2",
    "Pin Allocation Tables\n(1), CLKOUT SOSCO OSC2 = -. SS2 (1), CLKIN SOSCI OSC1 = SCK1 (1). SS2 (1), - = SDI1 (1). SS2 (1), - = -. SS2 (1), - = SS1 (1). SS2 (1), - = SCK2 (1). SS2 (1), - - = SDI2 (1). SS2 (1), V = - -. SS2 (1), DD V SS = SPI. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = -. -, - = -. -, MCLR V PP = CLCIN3 (1). -, CLKOUT SOSCO OSC2 = -. -, CLKIN SOSCI OSC1 = -. -, - = CLCIN2 (1). -, - = -. -, - = CLCIN0 (1). -, - = CLCIN1 (1). -, - - = -. -, V = -",
    "Pin Allocation Tables\n-. -, DD V SS = CLC. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = CWGIN (1). -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 = -. -, CLKIN SOSCI OSC1 = -. -, - = -. -, - = -. -, - = -. -, - = -. -, - - = -. -, V = - -. -, DD V SS = CWG. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = -. -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 = PWM1ERS (1). -, CLKIN SOSCI OSC1 = -. -, - = PWM2ERS (1). -, - = PWM3ERS (1). -, - = PWMIN2 (1). -, - = -. -, - - = CCP1IN",
    "Pin Allocation Tables\n(1) PWMIN1 (1). -, V = - -. -, DD V SS = 16-Bit PWM/CCP. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = T0CKI (1). -, - = -. -, MCLR V PP = T1G (1). -, CLKOUT SOSCO OSC2 = T1CKI (1) T2IN (1) SMT1WIN (1). -, CLKIN SOSCI OSC1 = SMT1SIG (1). -, - = T4IN (1). -, - = -. -, - = -. -, - = T3G (1). -, - - = T3CKI (1). -, V = - -. -, DD V SS = Timers/SMT. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = ZCDIN. -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 = -.",
    "Pin Allocation Tables\n-, CLKIN SOSCI OSC1 = -. -, - = -. -, - = -. -, - = -. -, - = -. -, - - = -. -, V = - -. -, DD V SS = ZCD. C1IN0+, ICDDAT ICSPDAT = C1IN0- C2IN0-. C1IN0+, ICDCLK ICSPCLK = -. C1IN0+, - = -. C1IN0+, MCLR V PP = -. C1IN0+, CLKOUT SOSCO OSC2 = -. C1IN0+, CLKIN SOSCI OSC1 = C2IN0+. C1IN0+, - = C1IN1- C2IN1-. C1IN0+, - = C1IN2- C2IN2-. C1IN0+, - = C1IN3- C2IN3-. C1IN0+, - = -. C1IN0+, - - = -. C1IN0+, V = - -. C1IN0+, DD V SS = Comparator. Operational Amplifier OPA1IN3+",
    "Pin Allocation Tables\nOPA1IN3-, ICDDAT ICSPDAT = -. Operational Amplifier OPA1IN3+ OPA1IN3-, ICDCLK ICSPCLK = OPA1IN2+ OPA1IN2-. Operational Amplifier OPA1IN3+ OPA1IN3-, - = -. Operational Amplifier OPA1IN3+ OPA1IN3-, MCLR V PP = -. Operational Amplifier OPA1IN3+ OPA1IN3-, CLKOUT SOSCO OSC2 = -. Operational Amplifier OPA1IN3+ OPA1IN3-, CLKIN SOSCI OSC1 = OPA1IN0+. Operational Amplifier OPA1IN3+ OPA1IN3-, - = OPA1IN0-. Operational Amplifier OPA1IN3+ OPA1IN3-, - = OPA1OUT. Operational Amplifier OPA1IN3+ OPA1IN3-, - = OPA1IN1+ OPA1IN1-. Operational Amplifier OPA1IN3+ OPA1IN3-, - = -. Operational Amplifier OPA1IN3+ OPA1IN3-, - - = -. Operational Amplifier OPA1IN3+ OPA1IN3-, V =",
    "Pin Allocation Tables\n-. Operational Amplifier OPA1IN3+ OPA1IN3-, DD V SS = -. DAC1OUT1, ICDDAT ICSPDAT = VREF+ (ADC) VREF+ (DAC1) VREF+ (DAC2). DAC1OUT1, ICDCLK ICSPCLK = VREF- (ADC) VREF- (DAC1) VREF- (DAC2) DAC1OUT2. DAC1OUT1, - = -. DAC1OUT1, MCLR V PP = -. DAC1OUT1, CLKOUT SOSCO OSC2 = -. DAC1OUT1, CLKIN SOSCI OSC1 = -. DAC1OUT1, - = -. DAC1OUT1, - = -. DAC1OUT1, - = -. DAC1OUT1, - = -. DAC1OUT1, - - = -. DAC1OUT1, V = - -. DAC1OUT1, DD V SS = Reference. A/D ANA0, ICDDAT ICSPDAT = ANA1. A/D",
    "Pin Allocation Tables\nANA0, ICDCLK ICSPCLK = ANA2. A/D ANA0, - = -. A/D ANA0, MCLR V PP = ANA4. A/D ANA0, CLKOUT SOSCO OSC2 = ANA5. A/D ANA0, CLKIN SOSCI OSC1 = ANC0. A/D ANA0, - = ANC1. A/D ANA0, - = ANC2 ADACT (1). A/D ANA0, - = ANC3. A/D ANA0, - = ANC4. A/D ANA0, - - = ANC5. A/D ANA0, V = - -. A/D ANA0, DD V SS = . 14-Pin SOIC/TSSOP 13, ICDDAT ICSPDAT = 12. 14-Pin SOIC/TSSOP 13, ICDCLK ICSPCLK = 11. 14-Pin SOIC/TSSOP 13, - = 4. 14-Pin SOIC/TSSOP 13, MCLR V PP = 3. 14-Pin SOIC/TSSOP 13, CLKOUT SOSCO OSC2 =",
    "Pin Allocation Tables\n2. 14-Pin SOIC/TSSOP 13, CLKIN SOSCI OSC1 = 10. 14-Pin SOIC/TSSOP 13, - = 9. 14-Pin SOIC/TSSOP 13, - = 8. 14-Pin SOIC/TSSOP 13, - = 7. 14-Pin SOIC/TSSOP 13, - = RC4 6. 14-Pin SOIC/TSSOP 13, - - = 5. 14-Pin SOIC/TSSOP 13, V = 1. 14-Pin SOIC/TSSOP 13, DD V SS = 14. I/O rota e hisp g 90 RA0, ICDDAT ICSPDAT = RA1. I/O rota e hisp g 90 RA0, ICDCLK ICSPCLK = RA2. I/O rota e hisp g 90 RA0, - = RA3. I/O rota e hisp g 90 RA0, MCLR V PP = RA4. I/O rota e hisp g 90 RA0, CLKOUT SOSCO OSC2 = RA5. I/O rota e hisp g 90 RA0, CLKIN",
    "Pin Allocation Tables\nSOSCI OSC1 = RC0. I/O rota e hisp g 90 RA0, - = RC1. I/O rota e hisp g 90 RA0, - = RC2. I/O rota e hisp g 90 RA0, - = . I/O rota e hisp g 90 RA0, - = RC3. I/O rota e hisp g 90 RA0, - - = RC5. I/O rota e hisp g 90 RA0, V = V DD. I/O rota e hisp g 90 RA0, DD V SS = V SS",
    "Pin Allocation Tables\nInterrupts, - = -. IOC, - = -. DSM, - = DSM1. UART, - = DTR1 RTS1 TX1 DTR2 RTS2 TX2 DTR3 RTS3 TX3. I 2 C, - = SDA1 SCL1. SPI, - = SS1 SCK1 SD01 SS2 SCK2 SDO2. CLC, - = CLC1OUT CLC2OUT CLC3OUT CLC4OUT. CWG, - = CWG1A CWG1B CWG1C CWG1D. 16-Bit PWM/CCP, - = PWM11 PWM12 PWM21 PWM22 PWM31 PWM32 CCP1. Timers/SMT, - = TMR0. ZCD, - = -. Comparator, - = C1OUT C2OUT. Operational Amplifier, - = -. Reference, - = -. A/D, - = ADCGRDA ADCGRDB. 14-Pin SOIC/TSSOP, - = -. I/O rota e hisp g 90, -",
    "Pin Allocation Tables\n= OUT (2)\n90\ng\nrota e hisp\nNotes:\nThis is a PPS re-mappable input signal. The input function may be moved from the default location shown to one of several other PORTx pins.\n1.\nAll digital output signals shown in these rows are PPS re-mappable. These signals may be mapped to output onto one of several PORTx pin options.\n2.\nThis is a bidirectional signal. For normal module operation, the firmware may map this signal to the same pin in both the PPS input and PPS output registers.\n3.\nThese pins are configured for I 2 C logic levels; The SCLx/SDAx signals may be assigned to any of these pins. PPS assignments to the other pins (e.g., RB1) will operate, but input logic levels will be standard TTL/ST as selected by the INLVL register, instead of the I 2 C specific or SMBus input buffer thresholds.\n4.\nA 0.1 \u03bcF bypass capacitor to V SS  is required on the V DD  pin.\n5.\nDS40002242F - 14\n20-Pin Allocation Table\nTable 3-2.",
    "Pin Allocation Tables\n-, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = -. -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 CLKIN SOSCI = -. -, OSC1 - = -. -,  = - -. -, - - = -. -, - = INT0 (1). -, - = INT1 (1). -, - = INT2 (1). -, - = -. -, - = -. -, - = -. -,  = -. -, - - = -. -, - V DD = - -. -, V SS = Interrupts. IOCA0, ICDDAT ICSPDAT = IOCA1. IOCA0, ICDCLK ICSPCLK = IOCA2. IOCA0, - = IOCA3. IOCA0, MCLR V PP = IOCA4. IOCA0, CLKOUT SOSCO OSC2 CLKIN SOSCI = IOCA5. IOCA0, OSC1 - = IOCB4. IOCA0,",
    "Pin Allocation Tables\n= IOCB5. IOCA0, - - = IOCB6 IOCB7. IOCA0, - = IOCC0. IOCA0, - = IOCC1. IOCA0, - = IOCC2. IOCA0, - = IOCC3. IOCA0, - = IOCC4. IOCA0, - = IOCC5. IOCA0,  = IOCC6. IOCA0, - - = IOCC7. IOCA0, - V DD = - -. IOCA0, V SS = IOC. -, ICDDAT ICSPDAT = MDSRC (1). -, ICDCLK ICSPCLK = -. -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 CLKIN SOSCI = -. -, OSC1 - = -. -,  = - -. -, - - = -. -, - = -. -, - = -. -, - = MDCARL (1). -, - = . -, - = - -. -, - = MDCARH (1). -,",
    "Pin Allocation Tables\n= -. -, - - = -. -, - V DD = - -. -, V SS = DSM. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = -. -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 CLKIN SOSCI = -. -, OSC1 - = - RX1 (1). -,  = -. -, - - = CTS1 (1). -, - = -. -, - = RX2 (1). -, - = CTS2 (1). -, - = RX3 (1). -, - = -. -, - = CTS3 (1). -,",
    "Pin Allocation Tables\n= -. -, - - = -. -, - V DD = - -. -, V SS = UART. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = -. -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 CLKIN SOSCI = -. -, OSC1 - = SDA1 (3,4) -. -,  = SCL1 (3,4). -, - - = -. -, - = -. -, - = -. -, - = -. -, - = -. -, - = -. -, - = -. -,",
    "Pin Allocation Tables\n= -. -, - - = - -. -, - V DD = -. -, V SS = I 2 C. -, ICDDAT ICSPDAT = SS2 (1). -, ICDCLK ICSPCLK = -. -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 CLKIN SOSCI = -. -, OSC1 - = SDI1 (1) (1). -,  = SDI2 SCK1 (1). -, - - = SCK2 (1). -, - = -. -, - = -. -, - = -. -, - = . -, - = -. -, - = - -. -,",
    "Pin Allocation Tables\n= SS1 (1). -, - - = -. -, - V DD = - -. -, V SS = SPI. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = CLCIN0 (1). -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 CLKIN SOSCI = -. -, OSC1 - = CLCIN2 (1) (1). -,  = CLCIN3 -. -, - - = -. -, - = -. -, - = -. -, - = -. -, - = CLCIN1 (1). -, - = -. -, - = -. -,",
    "Pin Allocation Tables\n= -. -, - - = -. -, - V DD = - -. -, V SS = CLC. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = CWGIN (1). -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 CLKIN SOSCI = -. -, OSC1 - = - -. -,  = -. -, - - = -. -, - = -. -, - = -. -, - = -. -, - = -. -, - = . -, - = - -. -,  = -. -, - - = -. -, - V DD = - -. -, V SS = CWG. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = -. -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 CLKIN SOSCI = PWM1ERS (1). -, OSC1 - = - -. -,",
    "Pin Allocation Tables\n= -. -, - - = -. -, - = -. -, - = PWM2ERS (1). -, - = PWM3ERS (1). -, - = PWMIN2 (1). -, - = - (1). -, - = CCP1IN PWMIN1 (1). -,  = -. -, - - = -. -, - V DD = - -. -, V SS = 16-Bit PWM/CCP. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = -. -, - = -. -, MCLR V PP = T1G (1) SMT1SIG (1). -, CLKOUT SOSCO OSC2 CLKIN SOSCI = T2IN (1) SMT1WIN (1). -, OSC1 - = -. -,",
    "Pin Allocation Tables\n= - -. -, - - = -. -, - = -. -, - = T4IN (1). -, - = -. -, - = -. -, - = T3G (1). -, - = T3CKI (1) T0CKI (1). -,  = T1CKI (1). -, - - = -. -, - V DD = - -. -, V SS = Timers/SMT. -, ICDDAT ICSPDAT = -. -, ICDCLK ICSPCLK = ZCDIN. -, - = -. -, MCLR V PP = -. -, CLKOUT SOSCO OSC2 CLKIN SOSCI = -. -, OSC1 - = -. -,  = -. -, - - = - -. -, - = -. -, - = -. -, - = -. -, - = -. -, - = -. -, - = -. -,",
    "Pin Allocation Tables\n= -. -, - - = -. -, - V DD = - -. -, V SS = ZCD. C1IN0+, ICDDAT ICSPDAT = C1IN0- C2IN0-. C1IN0+, ICDCLK ICSPCLK = -. C1IN0+, - = -. C1IN0+, MCLR V PP = -. C1IN0+, CLKOUT SOSCO OSC2 CLKIN SOSCI = -. C1IN0+, OSC1 - = -. C1IN0+,  = -. C1IN0+, - - = - -. C1IN0+, - = C2IN0+. C1IN0+, - = C1IN1- C2IN1-. C1IN0+, - = C1IN2- C2IN2-. C1IN0+, - = C1IN3-. C1IN0+, - = C2IN3-. C1IN0+, - = -. C1IN0+,",
    "Pin Allocation Tables\n= - -. C1IN0+, - - = -. C1IN0+, - V DD = - -. C1IN0+, V SS = Comparator. OPA1IN3+ OPA1IN3-, ICDDAT ICSPDAT = -. OPA1IN3+ OPA1IN3-, ICDCLK ICSPCLK = OPA1IN2+ OPA1IN2-. OPA1IN3+ OPA1IN3-, - = -. OPA1IN3+ OPA1IN3-, MCLR V PP = -. OPA1IN3+ OPA1IN3-, CLKOUT SOSCO OSC2 CLKIN SOSCI = -. OPA1IN3+ OPA1IN3-, OSC1 - = OPA1IN0-. OPA1IN3+ OPA1IN3-,",
    "Pin Allocation Tables\n= OPA1IN0+. OPA1IN3+ OPA1IN3-, - - = - -. OPA1IN3+ OPA1IN3-, - = -. OPA1IN3+ OPA1IN3-, - = -. OPA1IN3+ OPA1IN3-, - = OPA1OUT. OPA1IN3+ OPA1IN3-, - = OPA1IN1+ OPA1IN1-. OPA1IN3+ OPA1IN3-, - = -. OPA1IN3+ OPA1IN3-, - = -. OPA1IN3+ OPA1IN3-,",
    "Pin Allocation Tables\n= -. OPA1IN3+ OPA1IN3-, - - = -. OPA1IN3+ OPA1IN3-, - V DD = - -. OPA1IN3+ OPA1IN3-, V SS = Operational Amplifier. DAC1OUT1, ICDDAT ICSPDAT = VREF+ (ADC) VREF+ (DAC1) VREF+ (DAC2). DAC1OUT1, ICDCLK ICSPCLK = VREF- (ADC) VREF- (DAC1) VREF- (DAC2) DAC1OUT2. DAC1OUT1, - = -. DAC1OUT1, MCLR V PP = -. DAC1OUT1, CLKOUT SOSCO OSC2 CLKIN SOSCI = -. DAC1OUT1, OSC1 - = -. DAC1OUT1,",
    "Pin Allocation Tables\n= -. DAC1OUT1, - - = - -. DAC1OUT1, - = -. DAC1OUT1, - = -. DAC1OUT1, - = -. DAC1OUT1, - = . DAC1OUT1, - = - -. DAC1OUT1, - = . DAC1OUT1,  = - -. DAC1OUT1, - - = -. DAC1OUT1, - V DD = - -. DAC1OUT1, V SS = Reference. ANA0, ICDDAT ICSPDAT = ANA1. ANA0, ICDCLK ICSPCLK = ANA2. ANA0, - = -. ANA0, MCLR V PP = ANA4. ANA0, CLKOUT SOSCO OSC2 CLKIN SOSCI = ANA5. ANA0, OSC1 - = ANB4. ANA0,",
    "Pin Allocation Tables\n= ANB5. ANA0, - - = ANB6 ANB7. ANA0, - = ANC0. ANA0, - = ANC1. ANA0, - = ANC2 ADACT (1). ANA0, - = ANC3. ANA0, - = ANC4. ANA0, - = ANC5. ANA0,  = ANC6. ANA0, - - = ANC7. ANA0, - V DD = - -. ANA0, V SS = A/D. 19 16, ICDDAT ICSPDAT = 15. 19 16, ICDCLK ICSPCLK = 14. 19 16, - = 1. 19 16, MCLR V PP = 20. 19 16, CLKOUT SOSCO OSC2 CLKIN SOSCI = 19. 19 16, OSC1 - = 10. 19 16,  = 9 8. 19 16, - - = 7. 19 16, - = 13. 19 16, - = 12. 19 16, - = 14 11. 19 16, - = 7. 19 16, - = 4. 19 16, - = 3. 19 16,",
    "Pin Allocation Tables\n= 2. 19 16, - - = 5 6. 19 16, - V DD = 18 17. 19 16, V SS = 20-Pin PDIP/SOIC/SSOP 20-Pin VQFN. I/O rota e hisp g 90 RA0, ICDDAT ICSPDAT = RA1 18. I/O rota e hisp g 90 RA0, ICDCLK ICSPCLK = RA2 17. I/O rota e hisp g 90 RA0, - = 4. I/O rota e hisp g 90 RA0, MCLR V PP = RA3 3. I/O rota e hisp g 90 RA0, CLKOUT SOSCO OSC2 CLKIN SOSCI = RA5 2. I/O rota e hisp g 90 RA0, OSC1 - = RB4 13. I/O rota e hisp g 90 RA0,",
    "Pin Allocation Tables\n= RB5 12 11. I/O rota e hisp g 90 RA0, - - = RB6 RB7 10 16. I/O rota e hisp g 90 RA0, - = RC0 15. I/O rota e hisp g 90 RA0, - = RC1. I/O rota e hisp g 90 RA0, - = . I/O rota e hisp g 90 RA0, - = . I/O rota e hisp g 90 RA0, - = 6. I/O rota e hisp g 90 RA0, - = . I/O rota e hisp g 90 RA0,  = 5. I/O rota e hisp g 90 RA0, - - = 8 9 1. I/O rota e hisp g 90 RA0, - V DD = RC7 V DD V SS 20. I/O rota e hisp g 90 RA0, V SS = RA4 RC2 RC3 RC4 RC5 RC6\nDS40002242F - 15",
    "Pin Allocation Tables\nInterrupts, - = -. IOC, - = -. DSM, - = DSM1. UART, - = DTR1 RTS1 TX1 DTR2 RTS2 TX2 DTR3 RTS3 TX3. I 2 C, - = SDA1 SCL1. SPI, - = SS1 SCK1 SD01 SS2 SCK2 SDO2. CLC, - = CLC1OUT CLC2OUT CLC3OUT CLC4OUT. CWG, - = CWG1A CWG1B CWG1C CWG1D. 16-Bit PWM/CCP, - = PWM11 PWM12 PWM21 PWM22 PWM31 PWM32 CCP1. Timers/SMT, - = TMR0. ZCD, - = -. Comparator, - = C1OUT C2OUT. Operational Amplifier, - = -. Reference, - = -. A/D, - = ADCGRDA ADCGRDB. 20-Pin VQFN, - = -. 20-Pin PDIP/SOIC/SSOP, -",
    "Pin Allocation Tables\n= -. I/O rota e hisp g 90, - = OUT (2)\n90\ng\nrota e hisp\nNotes:\nThis is a PPS re-mappable input signal. The input function may be moved from the default location shown to one of several other PORTx pins.\n1.\nAll digital output signals shown in these rows are PPS re-mappable. These signals may be mapped to output onto one of several PORTx pin options.\n2.\nThis is a bidirectional signal. For normal module operation, the firmware may map this signal to the same pin in both the PPS input and PPS output registers.\n3.\nThese pins are configured for I 2 C logic levels; The SCLx/SDAx signals may be assigned to any of these pins. PPS assignments to the other pins (e.g., RB1) will operate, but input logic levels will be standard TTL/ST as selected by the INLVL register, instead of the I 2 C specific or SMBus input buffer thresholds.\n4.\nA 0.1 \u03bcF bypass capacitor to V SS  is required on the V DD  pin.\n5.",
    "Pin Allocation Tables\nDS40002242F - 16",
    "4.1 Basic Connection Requirements\nGetting started with the PIC18-Q41 family of 8-bit microcontrollers requires attention to a minimal set of device pin connections before proceeding with development.\nThe following pins must always be connected:\n\u00b7 All V DD and VSS pins (see the Power Supply Pins section)\n\u00b7 MCLR pin (see the Master Clear (MCLR) Pin section)\nThese pins must also be connected if they are being used in the end application:\n\u00b7 ICSPCLK/ICSPDAT pins used for In-Circuit Serial Programming  (ICSP ) and debugging purposes \u2122 \u2122 (see the In-Circuit Serial Programming (ICSP) Pins section)\n\u00b7 OSCI and OSCO pins when an external oscillator source is used (see the External Oscillator Pins section)\nAdditionally, the following pins may be required:\n- \u00b7 VREF +/VREF- pins are used when external voltage reference for analog modules is implemented\nThe minimum mandatory connections are shown in the figure below.\nFigure 4-1. Recommended Minimum Connections",
    "4.2.1 Decoupling Capacitors\nConsider the following criteria when using decoupling capacitors:\n\u00b7 Value and type of capacitor: A 0.1 \u03bcF (100 nF), 10-20V capacitor is recommended. The capacitor needs to be a low-ESR device, with a resonance frequency in the range of 200 MHz and higher. Ceramic capacitors are recommended.\n\u00b7 Placement on the printed circuit board: The decoupling capacitors need to be placed as close to the pins as possible. It is recommended to place the capacitors on the same side of the board as the device. If space is constricted, the capacitor can be placed on another layer on the PCB using a via; however, ensure that the trace length from the pin to the capacitor is no greater than 0.25 inch (6 mm).",
    "4.2.1 Decoupling Capacitors\n\u00b7 Handling high-frequency noise: If the board is experiencing high-frequency noise (upward of tens of MHz), add a second ceramic type capacitor in parallel to the above described decoupling capacitor. The value of the second capacitor can be in the range of 0.01 \u03bcF to 0.001 \u03bcF. Place this second capacitor next to each primary decoupling capacitor. In high-speed circuit designs, consider implementing a decade pair of capacitances as close to the power and ground pins as possible (e.g., 0.1 \u03bcF in parallel with 0.001 \u03bcF).\n\u00b7 Maximizing performance: On the board layout from the power supply circuit, run the power and return traces to the decoupling capacitors first and then to the device pins. This ensures that the decoupling capacitors are first in the power chain. Equally important is to keep the trace length between the capacitor and the power pins to a minimum, thereby reducing PCB trace inductance.",
    "4.2.2 Tank Capacitors\nOn boards with power traces running longer than six inches in length, it is suggested to use a tank capacitor for integrated circuits, including microcontrollers, to supply a local power source. The value of the tank capacitor will be determined based on the trace resistance that connects the\npower supply source to the device and the maximum current drawn by the device in the application. In other words, select the tank capacitor that meets the acceptable voltage sag at the device. Typical values range from 4.7 \u03bcF to 47 \u03bcF.",
    "4.3 Master Clear (MCLR) Pin\nThe MCLR pin provides two specific device functions: Device Reset and Device Programming and Debugging. If programming and debugging are not required in the end application, a direct connection to VDD may be all that is required. The addition of other components, to help increase the application's resistance to spurious Resets from voltage sags, may be beneficial. A typical configuration is shown in Figure 4-1. Other circuit designs may be implemented, depending on the application's requirements.\nDuring programming and debugging, the resistance and capacitance that can be added to the pin must be considered. Device programmers and debuggers drive the MCLR pin. Consequently, specific voltage levels (V IH and VIL ) and fast signal transitions must not be adversely affected. Therefore, specific values of R1 and C1 will need to be adjusted based on the application and PCB requirements. For example, it is recommended that the capacitor, C1, be isolated from the MCLR pin during programming and debugging operations by using a jumper (Figure 4-2). The jumper is replaced for normal run-time operations.",
    "4.3 Master Clear (MCLR) Pin\nAny components associated with the MCLR pin need to be placed within 0.25 inch (6 mm) of the pin.\nFigure 4-2. Example of MCLR Pin Connections",
    "Notes:\n\uf0a3\uf020 \uf057 \uf057 1. R1 \u2264 10 k\u03a9 is recommended. A suggested starting value is 10 k\u03a9. Ensure that the MCLR pin VIH and VIL specifications are met.\n\uf0a3\uf020 \uf057 2. R2 \u2264 470\u03a9 will limit any current flowing into MCLR from the extended capacitor, C1, in the event of MCLR pin breakdown, due to Electrostatic Discharge (ESD) or Electrical Overstress (EOS). Ensure that the MCLR pin VIH and VIL specifications are met.",
    "4.4 In-Circuit Serial Programming \u2122 (ICSP \u2122 ) Pins\nThe ICSPCLK and ICSPDAT pins are used for ICSP and debugging purposes. It is recommended to keep the trace length between the ICSP connector and the ICSP pins on the device as short as possible. If the ICSP connector is expected to experience an ESD event, a series resistor is recommended, with the value in the range of a few tens of ohms, not to exceed 100\u03a9.\nPull-up resistors, series diodes and capacitors on the ICSPCLK and ICSPDAT pins are not recommended as they can interfere with the programmer/debugger communications to the device. If such discrete components are an application requirement, they need to be removed from the circuit during programming and debugging. Alternatively, refer to the AC/DC characteristics and timing requirements information in the respective device Flash programming specification for information on capacitive loading limits as well as pin input voltage high (V IH ) and input low (V IL ) requirements.",
    "4.4 In-Circuit Serial Programming \u2122 (ICSP \u2122 ) Pins\nFor device emulation, ensure that the 'Communication Channel Select' pins (i.e., ICSPCLK/ICSPDAT) programmed into the device match the physical connections for the ICSP to the Microchip debugger/emulator tool.",
    "4.5 External Oscillator Pins\nMany microcontrollers have options for at least two oscillators: A high-frequency primary oscillator and a low-frequency secondary oscillator.\nThe oscillator circuit needs to be placed on the same side of the board as the device. Place the oscillator circuit close to the respective oscillator pins with no more than 0.5 inch (12 mm) between the circuit components and the pins. The load capacitors have to be placed next to the oscillator itself, on the same side of the board.\nUse a grounded copper pour around the oscillator circuit to isolate it from surrounding circuits. The grounded copper pour needs to be routed directly to the MCU ground. Do not run any signal traces or power traces inside the ground pour. Also, if using a two-sided board, avoid any traces on the other side of the board where the crystal is placed.",
    "4.5 External Oscillator Pins\nLayout suggestions are shown in the following figure. In-line packages may be handled with a single-sided layout that completely encompasses the oscillator pins. With fine-pitch packages, it is not always possible to completely surround the pins and components. A suitable solution is to tie the broken guard sections to a mirrored ground layer. In all cases, the guard trace(s) must be returned to ground.\nFigure 4-3. Suggested Placement of the Oscillator Circuit\nIn planning the application's routing and I/O assignments, ensure that adjacent PORT pins and other signals in close proximity to the oscillator are benign (i.e., free of high frequencies, short rise and fall times, and other similar noise).\nFor additional information and design guidance on oscillator circuits, refer to these Microchip application notes, available at the corporate website (www.microchip.com):",
    "4.5 External Oscillator Pins\n\u00b7 AN826, 'Crystal Oscillator Basics and Crystal Selection for rfPIC \u2122 and PICmicro  Devices' \u00ae\n\u00b7 AN849, 'Basic PICmicro  Oscillator Design' \u00ae\n\u00b7 AN943, 'Practical PICmicro  Oscillator Analysis and Design' \u00ae\n\u00b7 AN949, 'Making Your Oscillator Work'",
    "4.6 Unused I/Os\nUnused I/O pins need to be configured as outputs and driven to a Logic Low state. Alternatively, connect a 1 k\u03a9 to 10 k\u03a9 resistor to V SS on unused pins to drive the output to logic low.",
    "5.1 Register Names\nWhen there are multiple instances of the same peripheral in a device, the Peripheral Control registers will be depicted as the concatenation of a peripheral identifier, peripheral instance, and control identifier. The Control registers section will show just one instance of all the register names with an 'x' in the place of the peripheral instance number. This naming convention may also be applied to peripherals when there is only one instance of that peripheral in the device to maintain compatibility with other devices in the family that contain more than one.",
    "5.2 Bit Names\nThere are two variants for bit names:\n\u00b7 Short name: Bit function abbreviation\n\u00b7 Long name: Peripheral abbreviation + short name",
    "5.2.1 Short Bit Names\nShort bit names are an abbreviation for the bit function. For example, some peripherals are enabled with the EN bit. The bit names shown in the registers are the short name variant.\nShort bit names are useful when accessing bits in C programs. The general format for accessing bits by the short name is RegisterNamebits.ShortName. For example, the enable bit, ON, in the ADCON0 register can be set in C programs with the instruction ADCON0bits.ON = 1 .\nShort names are not useful in assembly programs because the same name may be used by different peripherals in different bit positions. When it occurs, during the include file generation, the short bit name instances are appended with an underscore plus the name of the register where the bit resides, to avoid naming contentions.",
    "5.2.2 Long Bit Names\nLong bit names are constructed by adding a peripheral abbreviation prefix to the short name. The prefix is unique to the peripheral, thereby making every long bit name unique. The long bit name for the ADC enable bit is the ADC prefix, AD, appended with the enable bit short name, ON, resulting in the unique bit name ADON.\nLong bit names are useful in both C and assembly programs. For example, in C the ADCON0 enable bit can be set with the ADON = 1 instruction. In assembly, this bit can be set with the BSF ADCON0,ADON instruction.",
    "5.2.3 Bit Fields\nBit fields are two or more adjacent bits in the same register. Bit fields adhere only to the short bit naming convention. For example, the three Least Significant bits of the ADCON2 register contain the ADC Operating Mode Selection bit. The short name for this field is MD and the long name is ADMD. Bit field access is only possible in C programs. The following example demonstrates a C program instruction for setting the ADC to operate in Accumulate mode:\nADCON2bits.MD = 0b001;\nIndividual bits in a bit field can also be accessed with long and short bit names. Each bit is the field name appended with the number of the bit position within the field. For example, the Most Significant MODE bit has the short bit name MD2 and the long bit name is ADMD2. The following two examples demonstrate assembly program sequences for setting the ADC to operate in Accumulate mode:\nMOVLW  1<<MD0 IORWF  ADCON2,F\nBCF    ADCON2,ADMD2\nBCF    ADCON2,ADMD1\nBSF    ADCON2,ADMD0",
    "5.3.1 Status, Interrupt and Mirror Bits\nStatus, Interrupt enables, Interrupt flags and Mirror bits are contained in registers that span more than one peripheral. In these cases, the bit name shown is unique so there is no prefix or short name variant.",
    "Table 6-1. Register Legend\nR, Definition = Readable bit. W, Definition = Writable bit. HS, Definition = Hardware settable bit. HC, Definition = Hardware clearable bit. S, Definition = Set only bit. C, Definition = Clear only bit. U, Definition = Unimplemented bit, read as ' 0 '. ' 1 ', Definition = Bit value is set. ' 0 ', Definition = Bit value is cleared. x, Definition = Bit value is unknown. u, Definition = Bit value is unchanged. q, Definition = Bit value depends on condition. m, Definition = Bit value is predefined",
    "7. PIC18 CPU\nThis family of devices contains a PIC18 8-bit CPU core based on the modified Harvard architecture. The PIC18 CPU supports:\n\u00b7 System arbitration which decides memory access allocation depending on user priorities\n\u00b7 Vectored interrupt capability with automatic two-level deep context saving\n\u00b7 127-level deep hardware stack with overflow and underflow Reset capabilities\n\u00b7 Support Direct, Indirect, and Relative Addressing modes\n\u00b7 8x8 hardware multiplier\nFigure 7-1. Family Block Diagram\n\u696e\n\u696e\n\u2f64\n\u6320\n\u6c6f\n\u6963\n\u436f\n\u7472\n\u204d\n\u6c74\n\u6970\n\u6c79\n\u436f\n\u7472\n\u6c20\n\u6967\n\u6c73\n\u4954\n\u4f50",
    "7.1 System Arbitration\nThe system arbiter resolves memory access between the system level selections (i.e., Main, Interrupt Service Routine) and peripheral selection (e.g., DMA and Scanner) based on user-assigned priorities. A block diagram of the system arbiter can be found below. Each of the system level and peripheral selections has its own priority selection registers. Memory access priority is resolved using the number written to the corresponding Priority registers, ' 0 ' being the highest priority selection and the maximum value being the lowest priority. All system level and peripheral level selections default\n\u204d\n\u4461\n\u204c\n\u7461\n\u6368\n\u6464\n\u7373\n\u204c\n\u6174\n\u6368\n\u6374\n\u696f\n\u496e\n\u2042\n\u7374\n\u434c\n\u2043\n\u4465\n\u636f\n\u204c\n\u7463\n\u4355\n\u496e\n\u496e\n\u7374\n\u7374\n\u6374\n\u696f\n\u6374\n\u696f\n\u6c20\n\u7665\n\u636b\n\u7461\n\u7463\n\u434c\n\u4348\n\u434c\n\u7461\n\u204d\n\u7465\n\u696e\n\u4253\n\u6464\n\u7373\n\u4465\n\u636f\n\u696e\n\u2f64\n\u6320\n\u7373\n\u204c\n\u7463\n\u5230\n\u5231\n\u5232\n\u4461\n\u2041\n\u7461\n\u7373\n\u4461\n\u204d\n\u7461\n\u6c6f\n\u6963\n\u4461\n\u204c\n\u7461\n\u6368\n\u524f\n\u6363\n\u7373\n\u524f\n\u4461\n\u2042\nto the lowest priority configuration. If the same value is in two or more Priority registers, priority is given to the higher-listed selection according to the following table.",
    "7.1 System Arbitration\nImportant: When the PRLOCKED bit is set, the Non Volatile Memory (NVM) module has a fixed priority of ' 0 ' that cannot be changed. If an interrupt is desired when an NVM read/write operation is in progress, then the ISR priority level must be set to ' 0 '. The NVM module priority is ignored when PRLOCKED bit is cleared.\nTable 7-1. Default Priorities\n\nSystem Level, Selection = ISR. System Level, Priority Register Reset Value = 7. , Selection = MAIN. , Priority Register Reset Value = 7. Peripheral, Selection = DMA1. Peripheral, Priority Register Reset Value = 7. , Selection = DMA2. , Priority Register Reset Value = 7. , Selection = DMA3. , Priority Register Reset Value = 7. , Selection = DMA4. , Priority Register Reset Value = 7. , Selection = SCANNER. , Priority Register Reset Value = 7\nFigure 7-2. System Arbiter Block Diagram\n\u6e64\n\u6765\n\u4c65\n\u6174\n\u5072\n\u6772\n\u616d\n\u6c61\n\u6820\n\u656d\n\u7279\n\u5346\n\u6174\n\u6120\n\u4550\n\u6174\n\u5052\n\u6174",
    "7.1.1 Priority Lock\nThe system arbiter grants memory access to the peripheral selections (DMAx, Scanner) as long as the PRLOCKED bit is set. Priority selections are locked by setting the PRLOCKED bit. Setting and clearing this bit requires a special sequence as an extra precaution against inadvertent changes. The following code examples demonstrate the Priority Lock and Priority Unlock sequences.\n```\nExample 7-1. Priority Lock Sequence\n```\n```\nINTCON0bits.GIE = 0;         // Disable Interrupts; PRLOCK = 0x55; PRLOCK = 0xAA; PRLOCKbits.PRLOCKED = 1;     // Grant memory access to peripherals; INTCON0bits.GIE = 1;         // Enable Interrupts;\n```",
    "Example 7-2. Priority Unlock Sequence\n```\nINTCON0bits.GIE = 0;         // Disable Interrupts; PRLOCK = 0x55; PRLOCK = 0xAA; PRLOCKbits.PRLOCKED = 0;     // Allow changing priority settings; INTCON0bits.GIE = 1;         // Enable Interrupts;\n```",
    "7.2 Memory Access Scheme\nThe user can assign priorities to both system level and peripheral selections based on which the system arbiter grants memory access. Consider the following priority scenarios between ISR, MAIN and peripherals.",
    "7.2.1 ISR Priority > Main Priority > Peripheral Priority\nWhen the peripheral priority (e.g., DMA, Scanner) is lower than ISR and MAIN priority, and the peripheral requires:\n1. Access to the Program Flash Memory, then the peripheral waits for an instruction cycle in which the CPU does not need to access the PFM (such as a branch instruction) and uses that cycle to do its own Program Flash Memory access, unless a PFM Read/Write operation is in progress.\n2. Access to the SFR/GPR, then the peripheral waits for an instruction cycle in which the CPU does not need to access the SFR/GPR (such as MOVLW CALL NOP , , ) and uses that cycle to do its own SFR/GPR access.\n3. Access to the Data EEPROM, then the peripheral has access to Data EEPROM unless a Data EEPROM Read/Write operation is being performed.\nThis results in the lowest throughput for the peripheral to access the memory and does so without any impact on execution times.",
    "7.2.2 Peripheral Priority > ISR Priority > Main Priority\nWhen the peripheral priority (DMA, Scanner) is higher than ISR and MAIN priority, the CPU operation is stalled when the peripheral requests memory. The CPU is held in its current state until the peripheral completes its operation. This results in the highest throughput for the peripheral to access the memory but has the cost of stalling other execution while it occurs.",
    "7.2.3 ISR Priority > Peripheral Priority > Main Priority\nIn this case, interrupt routines and peripheral operation (DMAx, Scanner) will stall the Main loop. Interrupt will preempt peripheral operation, which results in lowest interrupt latency.",
    "7.2.4 Peripheral 1 Priority > ISR Priority > Main Priority > Peripheral 2 Priority\nIn this case, the Peripheral 1 will stall the execution of the CPU. However, Peripheral 2 can access the memory in cycles unused by Peripheral 1, ISR and the Main Routine.",
    "7.3 8x8 Hardware Multiplier\nThis device includes an 8x8 hardware multiplier as part of the ALU within the CPU. The multiplier performs an unsigned operation and yields a 16-bit result that is stored in the product register, PROD. The multiplier's operation does not affect any flags in the STATUS register.\nMaking multiplication a hardware operation allows it to be completed in a single instruction cycle. This has the advantages of higher computational throughput and reduced code size for multiplication algorithms and allows the device to be used in many applications previously reserved for digital signal processors. A comparison of various hardware and software multiply operations, along with the savings in memory and execution time, is shown in Table 7-2.\n\nTable 7-2. Performance Comparison for Various Multiply Operations",
    "7.3 8x8 Hardware Multiplier\n8x8 unsigned, Multiply Method = Without hardware multiply. 8x8 unsigned, Program Memory.(Words) = 13. 8x8 unsigned, Cycles (Max). = 69. 8x8 unsigned, Time.@64 MHz = 4.3 \u03bcs. 8x8 unsigned, Time.@40 MHz = 6.9 \u03bcs. 8x8 unsigned, Time.@10 MHz = 27.6 \u03bcs. 8x8 unsigned, Time.@4MHz = 69 \u03bcs. 8x8 unsigned, Multiply Method = Hardware multiply. 8x8 unsigned, Program Memory.(Words) = 1. 8x8 unsigned, Cycles (Max). = 1. 8x8 unsigned, Time.@64 MHz = 62.5 ns. 8x8 unsigned, Time.@40 MHz = 100 ns. 8x8 unsigned, Time.@10 MHz = 400 ns. 8x8 unsigned, Time.@4MHz = 1 \u03bcs. 8x8 signed, Multiply Method = Without hardware multiply. 8x8 signed, Program Memory.(Words) = 33. 8x8 signed, Cycles",
    "7.3 8x8 Hardware Multiplier\n(Max). = 91. 8x8 signed, Time.@64 MHz = 5.7 \u03bcs. 8x8 signed, Time.@40 MHz = 9.1 \u03bcs. 8x8 signed, Time.@10 MHz = 36.4 \u03bcs. 8x8 signed, Time.@4MHz = 91 \u03bcs. 8x8 signed, Multiply Method = Hardware multiply. 8x8 signed, Program Memory.(Words) = 6. 8x8 signed, Cycles (Max). = 6. 8x8 signed, Time.@64 MHz = 375 ns. 8x8 signed, Time.@40 MHz = 600 ns. 8x8 signed, Time.@10 MHz = 2.4 \u03bcs. 8x8 signed, Time.@4MHz = 6 \u03bcs. 16x16 unsigned, Multiply Method = Without hardware multiply. 16x16 unsigned, Program Memory.(Words) = 21. 16x16 unsigned, Cycles (Max). = 242. 16x16 unsigned, Time.@64 MHz = 15.1 \u03bcs. 16x16 unsigned, Time.@40 MHz =",
    "7.3 8x8 Hardware Multiplier\n24.2 \u03bcs. 16x16 unsigned, Time.@10 MHz = 96.8 \u03bcs. 16x16 unsigned, Time.@4MHz = 242 \u03bcs. 16x16 unsigned, Multiply Method = Hardware multiply. 16x16 unsigned, Program Memory.(Words) = 28. 16x16 unsigned, Cycles (Max). = 28. 16x16 unsigned, Time.@64 MHz = 1.8 \u03bcs. 16x16 unsigned, Time.@40 MHz = 2.8 \u03bcs. 16x16 unsigned, Time.@10 MHz = 11.2 \u03bcs. 16x16 unsigned, Time.@4MHz = 28 \u03bcs. 16x16 signed, Multiply Method = Without hardware multiply. 16x16 signed, Program Memory.(Words) = 52. 16x16 signed, Cycles (Max). = 254. 16x16 signed, Time.@64 MHz = 15.9 \u03bcs. 16x16 signed, Time.@40 MHz = 25.4 \u03bcs. 16x16 signed, Time.@10 MHz = 102.6 \u03bcs. 16x16 signed,",
    "7.3 8x8 Hardware Multiplier\nTime.@4MHz = 254 \u03bcs. 16x16 signed, Multiply Method = Hardware multiply. 16x16 signed, Program Memory.(Words) = 35. 16x16 signed, Cycles (Max). = 40. 16x16 signed, Time.@64 MHz = 2.5 \u03bcs. 16x16 signed, Time.@40 MHz = 4.0 \u03bcs. 16x16 signed, Time.@10 MHz = 16.0 \u03bcs. 16x16 signed, Time.@4MHz = 40 \u03bcs",
    "7.3.1 Operation\nExample 7-3 shows the instruction sequence for an 8x8 unsigned multiplication. Only one instruction is required when one of the arguments is already loaded in the WREG register. Example 7-4 shows the sequence to do an 8x8 signed multiplication. To account for the sign bits of the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "7.3.2 16x16 Unsigned Multiplication Algorithm\nExample 7-6 shows the sequence to do a 16x16 unsigned multiplication. Example 7-5 shows the algorithm that is used. The 32-bit result is stored in four registers.\n```\nExample 7-5. 16x16 Unsigned Multiply Algorithm RES3:RES0 = ARG1H:ARG1L \u00b7 ARG2H:ARG2L = ARG1H \u00b7 ARG2H \u00b7 2 16 + ARG1H \u00b7 ARG2L \u00b7 2 8 + ARG1L \u00b7 ARG2H \u00b7 2 8 + ARG1L \u00b7 ARG2L\n```",
    "Example 7-6. 16x16 Unsigned Multiply Routine\nMOVF MULWF MOVFF MOVFF, 1 = ARG1L, ARG2L PRODH, PRODL,. MOVF MULWF MOVFF MOVFF, 2 = W RES1. MOVF MULWF MOVFF MOVFF, 3 = ; ;. MOVF MULWF MOVFF MOVFF, 4 = ARG1L * ARG2L \u2192 PRODH:PRODL. ; MOVF MULWF MOVFF, 1 = ARG1H, ARG2H PRODH,. ; MOVF MULWF MOVFF, 2 = RES0 W RES3. ; MOVF MULWF MOVFF, 3 = ; ; ; ;. ; MOVF MULWF MOVFF, 4 = ARG1H * ARG2H \u2192 PRODH:PRODL. MOVFF ; MOVF MULWF MOVF ADDWF MOVF, 1 = PRODL, ARG1L, ARG2H PRODL, RES1, PRODH,.",
    "Example 7-6. 16x16 Unsigned Multiply Routine\nMOVFF ; MOVF MULWF MOVF ADDWF MOVF, 2 = RES2 W. MOVFF ; MOVF MULWF MOVF ADDWF MOVF, 3 = ; ;. MOVFF ; MOVF MULWF MOVF ADDWF MOVF, 4 = ARG1L. ADDWFC CLRF ADDWFC, 1 = RES2,. ADDWFC CLRF ADDWFC, 2 = W F. ADDWFC CLRF ADDWFC, 3 = ; ;. ADDWFC CLRF ADDWFC, 4 = Add cross products. , 1 = WREG RES3,. , 2 = W F. , 3 = ; ; ;. , 4 = . ; MOVF MULWF, 1 = ARG1H, ARG2L. ; MOVF MULWF, 2 = F W W. ; MOVF MULWF, 3 = ; ; ; ; ;. ; MOVF MULWF, 4 = ARG1H. MOVF ADDWF MOVF",
    "Example 7-6. 16x16 Unsigned Multiply Routine\nADDWFC CLRF, 1 = PRODL, RES1, PRODH, RES2, WREG. MOVF ADDWF MOVF ADDWFC CLRF, 2 = F W F. MOVF ADDWF MOVF ADDWFC CLRF, 3 = ; ; ;. MOVF ADDWF MOVF ADDWFC CLRF, 4 = . ADDWFC, 1 = . ADDWFC, 2 = F. ADDWFC, 3 = . ADDWFC, 4 = . , 1 = RES3,. , 2 = . , 3 = . , 4 = Add cross products. , 1 = . , 2 = . , 3 = ;. , 4 = ",
    "7.3.3 16x16 Signed Multiplication Algorithm\nExample 7-8 shows the sequence to do a 16x16 signed multiply. Example 7-7 shows the algorithm used. The 32-bit result is stored in four registers. To account for the sign bits of the arguments, the MSb for each argument pair is tested and the appropriate subtractions are done.\nExample 7-7. 16x16 Signed Multiply Algorithm RES3:RES0 = ARG1H:ARG1L \u00b7 ARG2H:ARG2L = ARG1H \u00b7 ARG2H \u00b7 2 16 + ARG1H \u00b7 ARG2L \u00b7 2 8 + ARG1L \u00b7 ARG2H \u00b7 2 8 + ARG1L \u00b7 ARG2L + -1\u00b7ARG2H < 7 > \u00b7 ARG1H:ARG1L \u00b7 2 16 + -1\u00b7ARG1H < 7 > \u00b7 ARG2H:ARG2L \u00b7 2 16",
    "Example 7-8. 16x16 Signed Multiply Routine\nMOVF MULW MOVF MOVFF, 1 = ARG1L, ARG2L PRODH, PRODL,. MOVF MULW MOVF MOVFF, 2 = W RES1 RES0. MOVF MULW MOVF MOVFF, 3 = ; ; ;. MOVF MULW MOVF MOVFF, 4 = ARG1L. MOVF MULW MOVF MOVFF, 5 = * ARG2L \u2192 PRODH:PRODL. MOVF MULWF MOVFF, 1 = ARG1H, ARG2H PRODH,. MOVF MULWF MOVFF, 2 = W RES3. MOVF MULWF MOVFF, 3 = ; ;. MOVF MULWF MOVFF, 4 = ARG1H. MOVF MULWF MOVFF, 5 = * ARG2H \u2192 PRODH:PRODL. MOVF MULWF MOVF ADDWF MOVF CLRF MOVF, 1 =",
    "Example 7-8. 16x16 Signed Multiply Routine\nARG1L, ARG2H PRODL, RES1,. MOVF MULWF MOVF ADDWF MOVF CLRF MOVF, 2 = W W F. MOVF MULWF MOVF ADDWF MOVF CLRF MOVF, 3 = ; ; ;. MOVF MULWF MOVF ADDWF MOVF CLRF MOVF, 4 = ARG1L Add. MOVF MULWF MOVF ADDWF MOVF CLRF MOVF, 5 = * ARG2H \u2192 PRODH:PRODL cross products. ADDWFC ADDWFC, 1 = PRODH, RES2, WREG RES3,. ADDWFC ADDWFC, 2 = W F. ADDWFC ADDWFC, 3 = ; ; ; ;. ADDWFC ADDWFC, 4 = . ADDWFC ADDWFC, 5 = . , 1 = ARG1H,. , 2 = W. , 3 = ;. , 4 = . , 5 = ARG2L \u2192. MULWF,",
    "Example 7-8. 16x16 Signed Multiply Routine\n1 = ARG2L. MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 = ARG1H. MULWF, 5 = * PRODH:PRODL\n\u2e20\n\u2e20\n\u2e20\n\u4253\n\u504f\n\u5254\n\u2c20\n\u4249\n\u5453\n\u466f\n\u7263\n\u6564\n\u204e\n\u4f50\n\u4665\n\u466c\n\u4e4f\n\u2e20\n\u496e\n\u7374\n\u7275\n\u6374\n\u696f\n\u6e20\n\u4020\n\u6164\n\u6472\n\u6573\n\u7320\n\u5375\n\u4665",
    "7.4.1 Instruction Flow/Pipelining\nAn 'Instruction Cycle' consists of four cycles of the oscillator clock. The instruction fetch and execute are pipelined in such a manner that a fetch takes one instruction cycle, while the decode and execute take another instruction cycle. However, due to the pipelining, each instruction effectively executes in one cycle. If an instruction causes the Program Counter (PC) to change (e.g., GOTO ), then two cycles are required to complete the instruction (Figure 7-3).\nA fetch cycle begins with the Program Counter (PC) incrementing followed by the execution cycle. In the execution cycle, the fetched instruction is latched onto the Instruction Register (IR). This instruction is then decoded and executed during the next few oscillator clock cycles. Data memory is read (operand read) and written (destination write) during the execution cycle as well.\nFigure 7-3. Instruction Pipeline Flow\n\u2e20\n\u3130\n\u3238\nNote: There are some instructions that take multiple cycles to execute. Refer to the 'Instruction Set Summary' chapter for details.",
    "7.4.2 Instructions in Program Memory\nThe program memory is addressed in bytes. Instructions are stored as either two bytes, four bytes, or six bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSb = 0 ). To maintain alignment with instruction boundaries, the PC increments in steps of two and the LSb will always read ' 0 '. See the 'Program\n\u4d4f\n\u4252\n\u5657\n\u504f\n\u5375\n\u5254\n\u4359\n\u2e20\n\u4d4f\n\u564c\n\u3535\n\u4665\n\u4665\n\u4359\n\u4665\n\u4359\n\u4359\n\u4359\n\u4359\nCounter' section in the 'Memory Organization' chapter for more details. The instructions in the Program Memory figure below shows how instruction words are stored in the program memory.",
    "7.4.2 Instructions in Program Memory\nThe CALL and GOTO instructions have the absolute program memory address embedded into the instruction. Since instructions are always stored on word boundaries, the data contained in the instruction is a word address. The word address is written to the corresponding bits of the Program Counter register, which accesses the desired byte address in program memory. Instruction #2 in the example shows how the instruction GOTO 0006h is encoded in the program memory. Program branch instructions, which encode a relative address offset, operate in the same manner. The offset value stored in a branch instruction represents the number of single-word instructions by which the PC will be offset.\nInstruction 1:, Program Memory Byte Locations = MOVLW. Instruction 1:, Program Memory Byte Locations = 055h. Instruction 2:, Program Memory Byte Locations = GOTO. Instruction 2:, Program Memory Byte Locations = 0006h. Instruction 3:, Program Memory Byte Locations = MOVFF. Instruction 3:, Program Memory Byte Locations = 123h, 456h. Instruction 4:, Program Memory Byte Locations = MOVFFL. Instruction 4:, Program Memory Byte Locations = 123h, 456h\n\nFigure 7-4. Instructions in Program Memory",
    "7.4.2 Instructions in Program Memory\nLSB = 1, 1 = LSB = 0. LSB = 1, 2 = Word Address. , 1 = . , 2 = 000000h. , 1 = . , 2 = 000002h. , 1 = . , 2 = 000004h. , 1 = . , 2 = 000006h. 0Fh, 1 = 55h. 0Fh, 2 = 000008h. EFh, 1 = 03h. EFh, 2 = 00000Ah. F0h, 1 = 00h. F0h, 2 = 00000Ch. C1h, 1 = 23h. C1h, 2 = 00000Eh. F4h, 1 = 56h. F4h, 2 = 000010h. 00h, 1 = 60h. 00h, 2 = 000012h. F4h, 1 = 8Ch. F4h, 2 = 000014h. F4h, 1 = 56h. F4h, 2 = 000016h. , 1 = . , 2 = 000018h. , 1 = . , 2 = 00001Ah",
    "7.4.3 Multi-Word Instructions\nThe standard PIC18 instruction set has six two-word instructions: CALL MOVFF GOTO LFSR MOVSF , , , , and MOVSS and two three-word instructions: MOVFFL and MOVSFL . In all cases, the second and the third word of the instruction always has 1111 as its four Most Significant bits; the other 12 bits are literal data, usually a data memory address.\nThe use of 1111 in the four MSbs of an instruction specifies a special form of NOP . If the instruction is executed in proper sequence, immediately after the first word, the data in the second word is accessed and used by the instruction sequence. If the first word is skipped for some reason and the second word is executed by itself, a NOP is executed instead. This is necessary for cases when the two-word instruction is preceded by a conditional instruction that changes the PC.\nTable 7-3 and Table 7-4 show more details of how two-word instructions work. Table 7-5 and Table 7-6 show more details of how three-word instructions work.\nextended instruction set.",
    "7.4.3 Multi-Word Instructions\nImportant: See the 'PIC18 Instruction Execution and the Extended Instruction Set' section for information on two-word instructions in the\nTable 7-3. Two-Word Instructions (Case 1)\n\n0110 0110 0000 0000, Source Code = TSTFSZ REG1. 0110 0110 0000 0000, Comment = ; is RAM location 0?. 1100 0001 0101 0011, Source Code = MOVFF REG1,REG2. 1100 0001 0101 0011, Comment = ; No, skip this word\n1111 0100 0101 0110, Source Code = . 1111 0100 0101 0110, Comment = ; Execute this word as NOP. 0010 0100 0000 0000, Source Code = ADDWF REG3. 0010 0100 0000 0000, Comment = ; continue code",
    "Table 7-4. Two-Word Instructions (Case 2)\n0110 0110 0000 0000, Source Code = TSTFSZ REG1. 0110 0110 0000 0000, Comment = ; is RAM location 0?. 1100 0001 0101 0011, Source Code = MOVFF REG1,REG2. 1100 0001 0101 0011, Comment = ; Yes, execute this word. 1111 0100 0101 0110, Source Code = . 1111 0100 0101 0110, Comment = ; 2nd word of instruction. 0010 0100 0000 0000, Source Code = ADDWF REG3. 0010 0100 0000 0000, Comment = ; continue code\nTable 7-5. Three-Word Instructions (Case 1)",
    "Table 7-4. Two-Word Instructions (Case 2)\n0110 0110 0000 0000, Source Code = TSTFSZ REG1. 0110 0110 0000 0000, Comment = ; is RAM location 0?. 0000 0000 0110 0000, Source Code = MOVFFL REG1,REG2. 0000 0000 0110 0000, Comment = ; Yes, skip this word. 1111 0100 1000 1100, Source Code = . 1111 0100 1000 1100, Comment = ; Execute this word as NOP. 1111 0100 0101 0110, Source Code = . 1111 0100 0101 0110, Comment = ; Execute this word as NOP. 0010 0100 0000 0000, Source Code = ADDWF REG3. 0010 0100 0000 0000, Comment = ; continue code",
    "Table 7-6. Three-Word Instructions (Case 2)\n0110 0110 0000 0000, Source Code = TSTFSZ REG1. 0110 0110 0000 0000, Comment = ; is RAM location 0?. 0000 0000 0110 0000, Source Code = MOVFFL REG1,REG2. 0000 0000 0110 0000, Comment = ; No, execute this word. 1111 0100 1000 1100, Source Code = . 1111 0100 1000 1100, Comment = ; 2nd word of instruction. 1111 0100 0101 0110, Source Code = . 1111 0100 0101 0110, Comment = ; 3rd word of instruction. 0010 0100 0000 0000, Source Code = ADDWF REG3. 0010 0100 0000 0000, Comment = ; continue code",
    "7.5 STATUS Register\nThe STATUS register contains the arithmetic status of the ALU. As with any other SFR, it can be the operand for any instruction. If the STATUS register is the destination for an instruction that affects the Z, DC, C, OV or N bits, the results of the instruction are not written; instead, the STATUS register is updated according to the instruction performed. Therefore, the result of an instruction with the STATUS register as its destination may be different than intended. As an example, CLRF STATUS will set the Z bit and leave the remaining Status bits unchanged (' 000u u1uu ').\nIt is recommended that only BCF BSF SWAPF MOVFF , , , and MOVWF instructions are used to alter the STATUS register, because these instructions do not affect the Z, C, DC, OV or N bits in the STATUS register. For other instructions that do not affect Status bits, see the instruction set summaries.\nImportant: The C and DC bits operate as the Borrow and Digit Borrow bits, respectively, in subtraction.",
    "7.6 Call Shadow Register\nWhen CALL instruction is used, the WREG, BSR and STATUS are automatically saved in hardware and can be accessed using the WREG_CSHAD, BSR_CSHAD and STATUS_CSHAD registers.\nImportant: The contents of these registers need to be handled correctly to avoid erroneous code execution.",
    "7.7.1 ISRPR\nName:\nISRPR\nAddress:\n0x0BF\nInterrupt Service Routine Priority Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = PR[2:0]. , 7 = PR[2:0]. , 8 = PR[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 2:0 - PR[2:0] Interrupt Service Routine Priority Selection\n111, Description = System Arbiter Priority Level: 7 (Lowest Priority). 110, Description = System Arbiter Priority Level: 6. 101, Description = System Arbiter Priority Level: 5. 100, Description = System Arbiter Priority Level: 4. 011, Description = System Arbiter Priority Level: 3. 010, Description = System Arbiter Priority Level: 2. 001, Description = System Arbiter Priority Level: 1. 000, Description = System Arbiter Priority Level: 0 (Highest Priority)",
    "7.7.2 MAINPR\nName:\nMAINPR\nAddress:\n0x0BE\nMain Routine Priority Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nPR[2:0]\nAccess Reset\nR/W 1\nR/W\nR/W\n1\n1",
    "Bits 2:0 - PR[2:0] Main Routine Priority Selection\n111, Description = System Arbiter Priority Level: 7 (Lowest Priority). 110, Description = System Arbiter Priority Level: 6. 101, Description = System Arbiter Priority Level: 5. 100, Description = System Arbiter Priority Level: 4. 011, Description = System Arbiter Priority Level: 3. 010, Description = System Arbiter Priority Level: 2. 001, Description = System Arbiter Priority Level: 1. 000, Description = System Arbiter Priority Level: 0 (Highest Priority)",
    "7.7.3 DMAxPR\nName:\nDMAxPR\nAddress:\n0x0B6,0x0B7,0x0B8,0x0B9\nDMAx Priority Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nPR[2:0]\nAccess Reset\nR/W 1\nR/W\nR/W\n1\n1",
    "Bits 2:0 - PR[2:0] DMAx Priority Selection\n111, Description = System Arbiter Priority Level: 7 (Lowest Priority). 110, Description = System Arbiter Priority Level: 6. 101, Description = System Arbiter Priority Level: 5. 100, Description = System Arbiter Priority Level: 4. 011, Description = System Arbiter Priority Level: 3. 010, Description = System Arbiter Priority Level: 2. 001, Description = System Arbiter Priority Level: 1. 000, Description = System Arbiter Priority Level: 0 (Highest Priority)",
    "7.7.4 SCANPR\nName: Address:\nSCANPR\n0x0B5\nScanner Priority Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = PR[2:0]. , 7 = PR[2:0]. , 8 = PR[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 2:0 - PR[2:0] Scanner Priority Selection\n111, Description = System Arbiter Priority Level: 7 (Lowest Priority). 110, Description = System Arbiter Priority Level: 6. 101, Description = System Arbiter Priority Level: 5. 100, Description = System Arbiter Priority Level: 4. 011, Description = System Arbiter Priority Level: 3. 010, Description = System Arbiter Priority Level: 2. 001, Description = System Arbiter Priority Level: 1. 000, Description = System Arbiter Priority Level: 0 (Highest Priority)",
    "7.7.5 PRLOCK\nName: Address:\nPRLOCK\n0x0B4\nPriority Lock Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nPRLOCKED\nAccess Reset\nR/W\n0",
    "Bit 0 - PRLOCKED PR Register Lock\n1, Description = Priority registers are locked and cannot be written; Peripherals have access to the memory. 0, Description = Priority registers can be modified by write operations; Peripherals do not have access to the memory",
    "Important:\n1. The PRLOCKED bit can only be set or cleared after the unlock sequence.\n2. If the Configuration Bit PR1WAY = 1 , the PRLOCKED bit cannot be cleared after it has been set. A device Reset will clear the bit and allow one more set.",
    "7.7.6 PROD\nName:\nPROD\nAddress:\n0x4F3\nTimer Register Product Register Pair",
    "7.7.6 PROD\nAccess, 15.PROD[15:8] = R/W. Access, 14.PROD[15:8] = R/W. Access, 13.PROD[15:8] = R/W. Access, 12.PROD[15:8] = R/W. Access, 11.PROD[15:8] = R/W. Access, 10.PROD[15:8] = R/W. Access, 9.PROD[15:8] = R/W. Access, 8.PROD[15:8] = R/W. Reset, 15.PROD[15:8] = 0. Reset, 14.PROD[15:8] = 0. Reset, 13.PROD[15:8] = 0. Reset, 12.PROD[15:8] = 0. Reset, 11.PROD[15:8] = 0. Reset, 10.PROD[15:8] = 0. Reset, 9.PROD[15:8] = 0. Reset, 8.PROD[15:8] = 0. Bit,",
    "7.7.6 PROD\n15.PROD[15:8] = 7. Bit, 14.PROD[15:8] = 6. Bit, 13.PROD[15:8] = 5. Bit, 12.PROD[15:8] = 4. Bit, 11.PROD[15:8] = 3. Bit, 10.PROD[15:8] = 2. Bit, 9.PROD[15:8] = 1. Bit, 8.PROD[15:8] = 0. , 15.PROD[15:8] = PROD[7:0]. , 14.PROD[15:8] = PROD[7:0]. , 13.PROD[15:8] = PROD[7:0]. , 12.PROD[15:8] = PROD[7:0]. , 11.PROD[15:8] = PROD[7:0]. , 10.PROD[15:8] = PROD[7:0]. , 9.PROD[15:8] = PROD[7:0]. ,",
    "7.7.6 PROD\n8.PROD[15:8] = PROD[7:0]. Access, 15.PROD[15:8] = R/W. Access, 14.PROD[15:8] = R/W. Access, 13.PROD[15:8] = R/W. Access, 12.PROD[15:8] = R/W. Access, 11.PROD[15:8] = R/W. Access, 10.PROD[15:8] = R/W. Access, 9.PROD[15:8] = R/W. Access, 8.PROD[15:8] = R/W. Reset, 15.PROD[15:8] = x. Reset, 14.PROD[15:8] = x. Reset, 13.PROD[15:8] = x. Reset, 12.PROD[15:8] = x. Reset, 11.PROD[15:8] = x. Reset, 10.PROD[15:8] = x. Reset, 9.PROD[15:8] = x. Reset,",
    "7.7.6 PROD\n8.PROD[15:8] = x",
    "Bits 15:0 - PROD[15:0] PROD Most Significant\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 PRODH: Accesses the high byte PROD[15:8]\n\u00b7 PRODL: Accesses the low byte PROD[7:0]",
    "7.7.7 STATUS\nName:\nSTATUS\nAddress:\n0x4D8\nSTATUS Register",
    "Bit 6 - TO Time-Out\nReset States: POR/BOR = 1\nAll Other Resets = q\n1, Description = Set at power-up or by execution of the CLRWDT or SLEEP instruction. 0, Description = A WDT time-out occurred",
    "Bit 5 - PD Power-Down\nReset States: POR/BOR = 1\n1, Description = Set at power-up or by execution of the CLRWDT instruction. 0, Description = Cleared by execution of the SLEEP instruction\nAll Other Resets = q",
    "Bit 4 - N Negative\nUsed for signed arithmetic (two's complement); indicates if the result is negative (ALU MSb = 1 ).\nReset States: POR/BOR = 0\n1, Description = The result is negative. 0, Description = The result is positive\nAll Other Resets = u",
    "Bit 3 - OV Overflow\nUsed for signed arithmetic (two's complement); indicates an overflow of the 7-bit magnitude, which causes the sign bit (bit 7) to change state.\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Overflow occurred for current signed arithmetic operation. 0, Description = No overflow occurred",
    "Bit 2 - Z Zero\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = The result of an arithmetic or logic operation is zero. 0, Description = The result of an arithmetic or logic operation is not zero",
    "Bit 1 - DC  Digit Carry / Borrow\nADDWF ADDLW SUBLW SUBWF , , , instructions (1)",
    "Reset States: POR/BOR = 0\n1, Description = A carry-out from the 4th low-order bit of the result occurred. 0, Description = No carry-out from the 4th low-order bit of the result\nAll Other Resets = u",
    "Bit 0 - C  Carry / Borrow\nADDWF ADDLW SUBLW SUBWF , , , instructions (1,2)\nReset States: POR/BOR = 0\n1, Description = A carry-out from the Most Significant bit of the result occurred. 0, Description = No carry-out from the Most Significant bit of the result occurred\nAll Other Resets = u",
    "Notes:\n1. For Borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand.\n2. For Rotate ( RRCF RLCF , ) instructions, this bit is loaded with either the high or low-order bit of the Source register.",
    "7.8 Register Summary - System Arbiter Control\n0x00 ... 0xB3, Name = Reserved. 0x00 ... 0xB3, Bit Pos. = . 0x00 ... 0xB3, 7 = . 0x00 ... 0xB3, 6 = . 0x00 ... 0xB3, 5 = . 0x00 ... 0xB3, 4 = . 0x00 ... 0xB3, 3 = . 0x00 ... 0xB3, 2 = . 0x00 ... 0xB3, 1 = . 0x00 ... 0xB3, 0 = . 0xB4, Name = PRLOCK. 0xB4, Bit Pos. = 7:0. 0xB4, 7 = . 0xB4, 6 = . 0xB4, 5 = . 0xB4, 4 = . 0xB4, 3 = . 0xB4, 2 = . 0xB4, 1 = . 0xB4, 0 = PRLOCKED. 0xB5, Name = SCANPR.",
    "7.8 Register Summary - System Arbiter Control\n0xB5, Bit Pos. = 7:0. 0xB5, 7 = . 0xB5, 6 = . 0xB5, 5 = . 0xB5, 4 = . 0xB5, 3 = . 0xB5, 2 = . 0xB5, 1 = PR[2:0]. 0xB5, 0 = . 0xB6, Name = DMA1PR. 0xB6, Bit Pos. = 7:0. 0xB6, 7 = . 0xB6, 6 = . 0xB6, 5 = . 0xB6, 4 = . 0xB6, 3 = . 0xB6, 2 = . 0xB6, 1 = PR[2:0]. 0xB6, 0 = . 0xB7, Name = DMA2PR. 0xB7, Bit Pos. = 7:0. 0xB7, 7 = . 0xB7, 6 = . 0xB7, 5 = . 0xB7, 4 = . 0xB7, 3 =",
    "7.8 Register Summary - System Arbiter Control\n. 0xB7, 2 = . 0xB7, 1 = PR[2:0]. 0xB7, 0 = . 0xB8, Name = DMA3PR. 0xB8, Bit Pos. = 7:0. 0xB8, 7 = . 0xB8, 6 = . 0xB8, 5 = . 0xB8, 4 = . 0xB8, 3 = . 0xB8, 2 = . 0xB8, 1 = PR[2:0]. 0xB8, 0 = . 0xB9, Name = DMA4PR. 0xB9, Bit Pos. = 7:0. 0xB9, 7 = . 0xB9, 6 = . 0xB9, 5 = . 0xB9, 4 = . 0xB9, 3 = . 0xB9, 2 = . 0xB9, 1 = PR[2:0]. 0xB9, 0 = . 0xBA ... 0xBD, Name = Reserved. 0xBA ...",
    "7.8 Register Summary - System Arbiter Control\n0xBD, Bit Pos. = . 0xBA ... 0xBD, 7 = . 0xBA ... 0xBD, 6 = . 0xBA ... 0xBD, 5 = . 0xBA ... 0xBD, 4 = . 0xBA ... 0xBD, 3 = . 0xBA ... 0xBD, 2 = . 0xBA ... 0xBD, 1 = . 0xBA ... 0xBD, 0 = . 0xBE, Name = MAINPR. 0xBE, Bit Pos. = 7:0. 0xBE, 7 = . 0xBE, 6 = . 0xBE, 5 = . 0xBE, 4 = . 0xBE, 3 = . 0xBE, 2 = . 0xBE, 1 = PR[2:0]. 0xBE, 0 = . 0xBF, Name = ISRPR. 0xBF, Bit Pos. = 7:0. 0xBF, 7 = . 0xBF, 6 = .",
    "7.8 Register Summary - System Arbiter Control\n0xBF, 5 = . 0xBF, 4 = . 0xBF, 3 = . 0xBF, 2 = . 0xBF, 1 = PR[2:0]. 0xBF, 0 = . 0xC0 ... 0x0372, Name = Reserved. 0xC0 ... 0x0372, Bit Pos. = . 0xC0 ... 0x0372, 7 = . 0xC0 ... 0x0372, 6 = . 0xC0 ... 0x0372, 5 = . 0xC0 ... 0x0372, 4 = . 0xC0 ... 0x0372, 3 = . 0xC0 ... 0x0372, 2 = . 0xC0 ... 0x0372, 1 = . 0xC0 ... 0x0372, 0 = . 0x0373, Name = STATUS_CSHAD. 0x0373, Bit Pos. = 7:0.",
    "7.8 Register Summary - System Arbiter Control\n0x0373, 7 = . 0x0373, 6 = TO. 0x0373, 5 = PD. 0x0373, 4 = N. 0x0373, 3 = OV. 0x0373, 2 = Z. 0x0373, 1 = DC. 0x0373, 0 = C. 0x0374, Name = WREG_CSHAD. 0x0374, Bit Pos. = 7:0. 0x0374, 7 = . 0x0374, 6 = . 0x0374, 5 = . 0x0374, 4 = WREG[7:0]. 0x0374, 3 = WREG[7:0]. 0x0374, 2 = . 0x0374, 1 = . 0x0374, 0 = . 0x0375, Name = BSR_CSHAD. 0x0375, Bit Pos. = 7:0. 0x0375, 7 = . 0x0375, 6 = .",
    "7.8 Register Summary - System Arbiter Control\n0x0375, 5 = . 0x0375, 4 = . 0x0375, 3 = . 0x0375, 2 = BSR[5:0]. 0x0375, 1 = . 0x0375, 0 = . 0x0376, Name = Reserved. 0x0376, Bit Pos. = . 0x0376, 7 = . 0x0376, 6 = . 0x0376, 5 = . 0x0376, 4 = . 0x0376, 3 = . 0x0376, 2 = . 0x0376, 1 = . 0x0376, 0 = . 0x0377, Name = STATUS_SHAD. 0x0377, Bit Pos. = 7:0. 0x0377, 7 = . 0x0377, 6 = TO. 0x0377, 5 = PD. 0x0377, 4 = N. 0x0377, 3 = OV. 0x0377, 2 = Z.",
    "7.8 Register Summary - System Arbiter Control\n0x0377, 1 = DC. 0x0377, 0 = C. 0x0378, Name = WREG_SHAD. 0x0378, Bit Pos. = 7:0. 0x0378, 7 = . 0x0378, 6 = . 0x0378, 5 = . 0x0378, 4 = WREG[7:0]. 0x0378, 3 = WREG[7:0]. 0x0378, 2 = . 0x0378, 1 = . 0x0378, 0 = . 0x0379, Name = BSR_SHAD. 0x0379, Bit Pos. = 7:0. 0x0379, 7 = . 0x0379, 6 = . 0x0379, 5 = . 0x0379, 4 = . 0x0379, 3 = BSR[5:0]. 0x0379, 2 = . 0x0379, 1 = . 0x0379, 0 = .",
    "7.8 Register Summary - System Arbiter Control\n0x037A, Name = PCLAT_SHAD. 0x037A, Bit Pos. = 7:0. 0x037A, 7 = . 0x037A, 6 = . 0x037A, 5 = . 0x037A, 4 = PCLATH[7:0]. 0x037A, 3 = . 0x037A, 2 = . 0x037A, 1 = . 0x037A, 0 = . 0x037A, Name = . 0x037A, Bit Pos. = 15:8. 0x037A, 7 = . 0x037A, 6 = . 0x037A, 5 = . 0x037A, 4 = . 0x037A, 3 = PCLATU[4:0]. 0x037A, 2 = . 0x037A, 1 = . 0x037A, 0 = . 0x037C, Name = FSR0_SHAD. 0x037C, Bit Pos. = 7:0.",
    "7.8 Register Summary - System Arbiter Control\n0x037C, 7 = . 0x037C, 6 = . 0x037C, 5 = . 0x037C, 4 = FSRL[7:0]. 0x037C, 3 = . 0x037C, 2 = . 0x037C, 1 = . 0x037C, 0 = . 0x037C, Name = . 0x037C, Bit Pos. = 15:8. 0x037C, 7 = . 0x037C, 6 = . 0x037C, 5 = . 0x037C, 4 = . 0x037C, 3 = FSRH[5:0]. 0x037C, 2 = . 0x037C, 1 = . 0x037C, 0 = . 0x037E, Name = FSR1_SHAD. 0x037E, Bit Pos. = 7:0. 0x037E, 7 = . 0x037E, 6 = . 0x037E, 5 = .",
    "7.8 Register Summary - System Arbiter Control\n0x037E, 4 = FSRL[7:0]. 0x037E, 3 = . 0x037E, 2 = . 0x037E, 1 = . 0x037E, 0 = . 0x037E, Name = . 0x037E, Bit Pos. = 15:8. 0x037E, 7 = . 0x037E, 6 = . 0x037E, 5 = . 0x037E, 4 = . 0x037E, 3 = FSRH[5:0]. 0x037E, 2 = . 0x037E, 1 = . 0x037E, 0 = . 0x0380, Name = FSR2_SHAD. 0x0380, Bit Pos. = 7:0. 0x0380, 7 = . 0x0380, 6 = . 0x0380, 5 = . 0x0380, 4 = FSRL[7:0]. 0x0380, 3 = .",
    "7.8 Register Summary - System Arbiter Control\n0x0380, 2 = . 0x0380, 1 = . 0x0380, 0 = . 0x0380, Name = . 0x0380, Bit Pos. = 15:8. 0x0380, 7 = . 0x0380, 6 = . 0x0380, 5 = . 0x0380, 4 = . 0x0380, 3 = FSRH[5:0]. 0x0380, 2 = . 0x0380, 1 = . 0x0380, 0 = . 0x0382, Name = PROD_SHAD. 0x0382, Bit Pos. = 7:0. 0x0382, 7 = . 0x0382, 6 = . 0x0382, 5 = . 0x0382, 4 = PROD[7:0]. 0x0382, 3 = . 0x0382, 2 = . 0x0382, 1 = . 0x0382, 0 = . 0x0382,",
    "7.8 Register Summary - System Arbiter Control\nName = . 0x0382, Bit Pos. = 15:8. 0x0382, 7 = . 0x0382, 6 = . 0x0382, 5 = . 0x0382, 4 = PROD[15:8]. 0x0382, 3 = . 0x0382, 2 = . 0x0382, 1 = . 0x0382, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x0384 0x04D7, Name = . 0x0384 0x04D7, Bit Pos. = . 0x0384 0x04D7, 7 = . 0x0384 0x04D7, 6 = . 0x0384",
    "7.8 Register Summary - System Arbiter Control\n0x04D7, 5 = . 0x0384 0x04D7, 4 = . 0x0384 0x04D7, 3 = . 0x0384 0x04D7, 2 = . 0x0384 0x04D7, 1 = . 0x0384 0x04D7, 0 = . 0x04D8, Name = STATUS. 0x04D8, Bit Pos. = 7:0. 0x04D8, 7 = . 0x04D8, 6 = TO. 0x04D8, 5 = PD. 0x04D8, 4 = N. 0x04D8, 3 = OV. 0x04D8, 2 = Z. 0x04D8, 1 = DC. 0x04D8, 0 = C. 0x04D9 ... 0x04F2, Name = Reserved. 0x04D9 ... 0x04F2, Bit Pos. = .",
    "7.8 Register Summary - System Arbiter Control\n0x04D9 ... 0x04F2, 7 = . 0x04D9 ... 0x04F2, 6 = . 0x04D9 ... 0x04F2, 5 = . 0x04D9 ... 0x04F2, 4 = . 0x04D9 ... 0x04F2, 3 = . 0x04D9 ... 0x04F2, 2 = . 0x04D9 ... 0x04F2, 1 = . 0x04D9 ... 0x04F2, 0 = . 0x04F3, Name = PROD. 0x04F3, Bit Pos. = 7:0 15:8. 0x04F3, 7 = . 0x04F3, 6 = . 0x04F3, 5 = . 0x04F3, 4 = PROD[7:0] PROD[15:8]. 0x04F3, 3",
    "7.8 Register Summary - System Arbiter Control\n= . 0x04F3, 2 = . 0x04F3, 1 = . 0x04F3, 0 = ",
    "8.1 Configuration Settings\nThe Configuration settings allow the user to set up the device with several choices of oscillators, Resets and memory protection options. These are implemented at 0x300000 - 0x300009.\nImportant: The DEBUG Configuration bit is managed automatically by device development tools including debuggers and programmers. For normal device operation, this bit needs to be maintained as a ' 1 '.",
    "8.2 Code Protection\nCode protection allows the device to be protected from unauthorized access. Internal access to the program memory is unaffected by any code protection setting. A single code-protect bit controls the access for both program memory and data EEPROM memory.\nThe entire program memory and Data EEPROM space is protected from external reads and writes by the CP bit. When CP = 0 , external reads and writes are inhibited and a read will return all ' 0 's. The CPU can continue to read the memory, regardless of the protection bit settings. Self-writing the program memory is dependent upon the write protection setting.",
    "8.3 User ID\n32 words in the memory space (0x200000 - 0x20003F) are designated as ID locations where the user can store checksum or other code identification numbers. These locations are readable and writable during normal execution. See the 'User ID, Device ID, Configuration Settings Access, DIA and DCI' section in the \"NVM - Nonvolatile Memory Module\" chapter for more information on accessing these memory locations. For more information on checksum calculation, see the 'PIC18-Q41 Family Programming Specification' (DS40002143).",
    "8.4 Device ID and Revision ID\nThe 16-bit device ID word is located at 0x3FFFFE and the 16-bit revision ID is located at 0x3FFFFC. These locations are read-only and cannot be erased or modified.\nDevelopment tools, such as device programmers and debuggers, may be used to read the Device ID, Revision ID and Configuration bits. Refer to the 'NVM - Nonvolatile Memory Module' chapter for more information on accessing these locations.",
    "8.5.1 CONFIG1\nName: Address:\nCONFIG1 0x300000\nConfiguration Byte 1\nAccess, 7. = . Access, 6.RSTOSC[2:0] = R/W. Access, 5.RSTOSC[2:0] = R/W. Access, 4.RSTOSC[2:0] = R/W. Access, 3. = . Access, 2.FEXTOSC[2:0] = R/W. Access, 1.FEXTOSC[2:0] = R/W. Access, 0.FEXTOSC[2:0] = R/W. Reset, 7. = . Reset, 6.RSTOSC[2:0] = 1. Reset, 5.RSTOSC[2:0] = 1. Reset, 4.RSTOSC[2:0] = 1. Reset, 3. = . Reset, 2.FEXTOSC[2:0] = 1. Reset, 1.FEXTOSC[2:0] = 1. Reset, 0.FEXTOSC[2:0] = 1",
    "Bits 6:4 - RSTOSC[2:0] Power-Up Default Value for COSC\nThis value is the Reset default value for COSC and selects the oscillator first used by user software. Refer to COSC operation.\n111, Description = EXTOSC operating per FEXTOSC bits. 110, Description = HFINTOSC with HFFRQ = 4 MHz and CDIV = 4:1. Resets COSC/NOSC to b'110' .. 101, Description = LFINTOSC. 100, Description = SOSC. 011, Description = Reserved. 010, Description = EXTOSC with 4x PLL, with EXTOSC operating per FEXTOSC bits. 001, Description = Reserved. 000, Description = HFINTOSC with HFFRQ = 64 MHz and CDIV = 1:1. Resets COSC/NOSC to b'110' .",
    "Bits 2:0 - FEXTOSC[2:0] External Oscillator Mode Selection\n111, Description = ECH (external clock) above 8 MHz. 110, Description = ECM (external clock) for 500 kHz to 8 MHz. 101, Description = ECL (external clock) below 500 kHz. 100, Description = Oscillator not enabled. 011, Description = Reserved (do not use). 010, Description = HS (crystal oscillator) above 4 MHz. 001, Description = XT (crystal oscillator) above 500 kHz, below 4 MHz. 000, Description = LP (crystal oscillator) optimized for 32.768 kHz",
    "8.5.2 CONFIG2\nName: Address:\nCONFIG2\n0x300001",
    "Configuration Byte 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 0. , 1 = FCMENS. , 2 = FCMENP. , 3 = FCMEN. , 4 = . , 5 = CSWEN. , 6 = PR1WAY. , 7 = CLKOUTEN. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = . Access, 7 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = . Reset, 5 = 1. Reset, 6 = . Reset, 7 = 1",
    "Bit 7 - FCMENS Fail-Safe Clock Monitor Enable - Secondary XTAL Enable\n1, Description = Fail-Safe Clock Monitor enabled; the timer will flag the FSCMS bit and OSFIF interrupt on SOSC failure. 0, Description = Fail-Safe Clock Monitor disabled",
    "Bit 6 - FCMENP Fail-Safe Clock Monitor Enable - Primary XTAL Enable\n1, Description = Fail-Safe Clock Monitor enabled; the timer will flag the FSCMP bit and OSFIF interrupt on EXTOSC failure. 0, Description = Fail-Safe Clock Monitor disabled",
    "Bit 5 - FCMEN Fail-Safe Clock Monitor Enable\n1, Description = Fail-Safe Clock Monitor enabled. 0, Description = Fail-Safe Clock Monitor disabled",
    "Bit 3 - CSWEN Clock Switch Enable\n1, Description = Writing to NOSC and NDIV is allowed. 0, Description = The NOSC and NDIV bits cannot be changed by user software",
    "Bit 1 - PR1WAY PRLOCKED One-Way Set Enable\n1, Description = The PRLOCKED bit can be cleared and set only once; Priority registers remain locked after one clear/set cycle. 0, Description = The PRLOCKED bit can be set and cleared repeatedly (subject to the unlock sequence)",
    "Bit 0 - CLKOUTEN Clock Out Enable\nIf FEXTOSC = HS, XT, LP, then this bit is ignored. Otherwise:\n1, Description = CLKOUT function is disabled; I/O function on OSC2. 0, Description = CLKOUT function is enabled; F OSC /4 clock appears at OSC2",
    "8.5.3 CONFIG3\nName: Address:\nCONFIG3 0x300002",
    "Configuration Byte 3\nBit, 1 = 7 6. Bit, 2 = 7 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BOREN[1:0]. , 2 = BOREN[1:0]. , 3 = LPBOREN. , 4 = IVT1WAY. , 5 = MVECEN. , 6 = PWRTS[1:0]. , 7 = PWRTS[1:0]. , 8 = MCLRE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:6 - BOREN[1:0] Brown-out Reset Enable\nWhen enabled, Brown-out Reset Voltage (VBOR) is set by the BORV bit.\n11, Description = Brown-out Reset enabled, the SBOREN bit is ignored. 10, Description = Brown-out Reset enabled while running, disabled in Sleep; SBOREN is ignored. 01, Description = Brown-out Reset enabled according to SBOREN. 00, Description = Brown-out Reset disabled",
    "Bit 5 - LPBOREN Low-Power BOR Enable\n1, Description = Low-Power Brown-out Reset is disabled. 0, Description = Low-Power Brown-out Reset is enabled",
    "Bit 4 - IVT1WAY IVTLOCK One-Way Set Enable\n1, Description = The IVTLOCK bit can be cleared and set only once; IVT registers remain locked after one clear/set cycle. 0, Description = The IVTLOCK bit can be set and cleared repeatedly (subject to the unlock sequence)",
    "Bit 3 - MVECEN Multivector Enable\n1, Description = Multivector is enabled; vector table used for interrupts. 0, Description = Legacy interrupt behavior",
    "Bits 2:1 - PWRTS[1:0] Power-up Timer Selection\n11, Description = PWRT is disabled. 10, Description = PWRT is set at 64 ms. 01, Description = PWRT is set at 16 ms. 00, Description = PWRT is set at 1 ms",
    "Bit 0 - MCLRE  Master Clear (MCLR) Enable\nx, Condition = If LVP = 1. x, Description = RA3 pin function is MCLR. 1, Condition = If LVP = 0. 1, Description = RA3 pin function is MCLR. 0, Condition = If LVP = 0. 0, Description = RA3 pin function is a port-defined function",
    "8.5.4 CONFIG4\nName: Address:\nCONFIG4 0x300003",
    "Configuration Byte 4\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = XINST. , 2 = . , 3 = LVP. , 4 = STVREN. , 5 = PPS1WAY. , 6 = ZCD BORV[1:0]. , 7 = ZCD BORV[1:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = 1. Reset, 2 = . Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1 1. Reset, 7 = 1",
    "Bit 7 - XINST Extended Instruction Set Enable\n1, Description = Extended Instruction Set and Indexed Addressing mode disabled (Legacy mode). 0, Description = Extended Instruction Set and Indexed Addressing mode enabled",
    "Bit 5 - LVP Low-Voltage Programming Enable\nThe LVP bit cannot be written (to zero) while operating from the LVP programming interface. The purpose of this rule is to prevent the user from dropping out of LVP mode while programming from LVP mode, or accidentally eliminating LVP mode from the Configuration state.\n1, Description = Low-Voltage Programming enabled. MCLR/V PP pin function is MCLR. The MCLRE Configuration bit is ignored.. 0, Description = HV on MCLR/V PP must be used for programming",
    "Bit 4 - STVREN Stack Overflow/Underflow Reset Enable\n1, Description = Stack Overflow or Underflow will cause a Reset. 0, Description = Stack Overflow or Underflow will not cause a Reset",
    "Bit 3 - PPS1WAY PPSLOCKED One-Way Set Enable\n1, Description = The PPSLOCKED bit can only be set once after an unlocking sequence is executed; once PPSLOCK is set, all future changes to PPS registers are prevented. 0, Description = The PPSLOCKED bit can be set and cleared as needed (unlocking sequence is required)",
    "Bit 2 - ZCD ZCD Disable\n1, Description = ZCD disabled, ZCD can be enabled by setting the ZCDSEN bit of ZCDCON. 0, Description = ZCD always enabled, PMDx[ZCDMD] bit is ignored",
    "Bits 1:0 - BORV[1:0]  Brown-out Reset Voltage Selection\n11, Description = Brown-out Reset Voltage (V BOR ) set to 1.90V. 10, Description = Brown-out Reset Voltage (V BOR ) set to 2.45V. 01, Description = Brown-out Reset Voltage (V BOR ) set to 2.7V. 00, Description = Brown-out Reset Voltage (V BOR ) set to 2.85V",
    "8.5.5 CONFIG5\nName:\nCONFIG5\nAddress:\n0x300004",
    "Configuration Byte 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = WDTE[1:0]. , 3 = WDTE[1:0]. , 4 = WDTCPS[4:0]. , 5 = WDTCPS[4:0]. , 6 = WDTCPS[4:0]. , 7 = WDTCPS[4:0]. , 8 = WDTCPS[4:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 6:5 - WDTE[1:0] WDT Operating Mode\n11, Description = WDT enabled regardless of Sleep; the SEN bit in WDTCON0 is ignored. 10, Description = WDT enabled while Sleep = 0 , suspended when Sleep = 1 ; the SEN bit in WDTCON0 is ignored. 01, Description = WDT enabled/disabled by the SEN bit in WDTCON0. 00, Description = WDT disabled, the SEN bit in WDTCON0 is ignored",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\n11111, WDTCON0[WDTPS] at POR.Value = 01011. 11111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:65536. 11111, WDTCON0[WDTPS] at POR.Divider Ratio = 2 16. 11111, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 2s. 11111, Control of WDTPS?.Control of WDTPS? = Yes. 11110 to 10011, WDTCON0[WDTPS] at POR.Value = 11110 to 10011. 11110 to 10011, WDTCON0[WDTPS] at POR.Divider Ratio = 1:32. 11110 to 10011, WDTCON0[WDTPS] at POR.Divider Ratio = 2 5. 11110 to 10011, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 1 ms. 11110 to 10011, Control of",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\nWDTPS?.Control of WDTPS? = No. 10010, WDTCON0[WDTPS] at POR.Value = 10010. 10010, WDTCON0[WDTPS] at POR.Divider Ratio = 1:8388608. 10010, WDTCON0[WDTPS] at POR.Divider Ratio = 2 23. 10010, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 256s. 10010, Control of WDTPS?.Control of WDTPS? = No. 10001, WDTCON0[WDTPS] at POR.Value = 10001. 10001, WDTCON0[WDTPS] at POR.Divider Ratio = 1:4194304. 10001, WDTCON0[WDTPS] at POR.Divider Ratio = 2 22. 10001, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 128s. 10001, Control of",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\nWDTPS?.Control of WDTPS? = No. 10000, WDTCON0[WDTPS] at POR.Value = 10000. 10000, WDTCON0[WDTPS] at POR.Divider Ratio = 1:2097152. 10000, WDTCON0[WDTPS] at POR.Divider Ratio = 2 21. 10000, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 64s. 10000, Control of WDTPS?.Control of WDTPS? = No. 01111, WDTCON0[WDTPS] at POR.Value = 01111. 01111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:1048576. 01111, WDTCON0[WDTPS] at POR.Divider Ratio = 2 20. 01111, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 32s. 01111,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\nControl of WDTPS?.Control of WDTPS? = No. 01110, WDTCON0[WDTPS] at POR.Value = 01110. 01110, WDTCON0[WDTPS] at POR.Divider Ratio = 1:524288. 01110, WDTCON0[WDTPS] at POR.Divider Ratio = 2 19. 01110, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 16s. 01110, Control of WDTPS?.Control of WDTPS? = No. 01101, WDTCON0[WDTPS] at POR.Value = 01101. 01101, WDTCON0[WDTPS] at POR.Divider Ratio = 1:262144. 01101, WDTCON0[WDTPS] at POR.Divider Ratio = 2 18. 01101, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) =",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\n8s. 01101, Control of WDTPS?.Control of WDTPS? = No. 01100, WDTCON0[WDTPS] at POR.Value = 01100. 01100, WDTCON0[WDTPS] at POR.Divider Ratio = 1:131072. 01100, WDTCON0[WDTPS] at POR.Divider Ratio = 2 17. 01100, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 4s. 01100, Control of WDTPS?.Control of WDTPS? = No. 01011, WDTCON0[WDTPS] at POR.Value = 01011. 01011, WDTCON0[WDTPS] at POR.Divider Ratio = 1:65536. 01011, WDTCON0[WDTPS] at POR.Divider Ratio = 2 16. 01011, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz)",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\n= 2s. 01011, Control of WDTPS?.Control of WDTPS? = No. 01010, WDTCON0[WDTPS] at POR.Value = 01010. 01010, WDTCON0[WDTPS] at POR.Divider Ratio = 1:32768. 01010, WDTCON0[WDTPS] at POR.Divider Ratio = 2 15. 01010, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 1s. 01010, Control of WDTPS?.Control of WDTPS? = No. 01001, WDTCON0[WDTPS] at POR.Value = 01001. 01001, WDTCON0[WDTPS] at POR.Divider Ratio = 1:16384. 01001, WDTCON0[WDTPS] at POR.Divider Ratio = 2 14. 01001, WDTCON0[WDTPS] at POR.Typical Time-Out (F",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\nIN = 31 kHz) = 512 ms. 01001, Control of WDTPS?.Control of WDTPS? = No. 01000, WDTCON0[WDTPS] at POR.Value = 01000. 01000, WDTCON0[WDTPS] at POR.Divider Ratio = 1:8192. 01000, WDTCON0[WDTPS] at POR.Divider Ratio = 2 13. 01000, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 256 ms. 01000, Control of WDTPS?.Control of WDTPS? = No. 00111, WDTCON0[WDTPS] at POR.Value = 00111. 00111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:4096. 00111, WDTCON0[WDTPS] at POR.Divider Ratio = 2 12. 00111, WDTCON0[WDTPS] at POR.Typical Time-Out",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\n(F IN = 31 kHz) = 128 ms. 00111, Control of WDTPS?.Control of WDTPS? = No. 00110, WDTCON0[WDTPS] at POR.Value = 00110. 00110, WDTCON0[WDTPS] at POR.Divider Ratio = 1:2048. 00110, WDTCON0[WDTPS] at POR.Divider Ratio = 2 11. 00110, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 64 ms. 00110, Control of WDTPS?.Control of WDTPS? = No. 00101, WDTCON0[WDTPS] at POR.Value = 00101. 00101, WDTCON0[WDTPS] at POR.Divider Ratio = 1:1024. 00101, WDTCON0[WDTPS] at POR.Divider Ratio = 2 10. 00101, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) =",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\n32 ms. 00101, Control of WDTPS?.Control of WDTPS? = No. 00100, WDTCON0[WDTPS] at POR.Value = 00100. 00100, WDTCON0[WDTPS] at POR.Divider Ratio = 1:512. 00100, WDTCON0[WDTPS] at POR.Divider Ratio = 2 9. 00100, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 16 ms. 00100, Control of WDTPS?.Control of WDTPS? = No. 00011, WDTCON0[WDTPS] at POR.Value = 00011. 00011, WDTCON0[WDTPS] at POR.Divider Ratio = 1:256. 00011, WDTCON0[WDTPS] at POR.Divider Ratio = 2 8. 00011, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 8 ms. 00011, Control of",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\nWDTPS?.Control of WDTPS? = No. 00010, WDTCON0[WDTPS] at POR.Value = 00010. 00010, WDTCON0[WDTPS] at POR.Divider Ratio = 1:128. 00010, WDTCON0[WDTPS] at POR.Divider Ratio = 2 7. 00010, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 4 ms. 00010, Control of WDTPS?.Control of WDTPS? = No. 00001, WDTCON0[WDTPS] at POR.Value = 00001. 00001, WDTCON0[WDTPS] at POR.Divider Ratio = 1:64. 00001, WDTCON0[WDTPS] at POR.Divider Ratio = 2 6. 00001, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 2 ms. 00001, Control of WDTPS?.Control of",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\nWDTPS? = No. 00000, WDTCON0[WDTPS] at POR.Value = 00000. 00000, WDTCON0[WDTPS] at POR.Divider Ratio = 1:32. 00000, WDTCON0[WDTPS] at POR.Divider Ratio = 2 5. 00000, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 1 ms. 00000, Control of WDTPS?.Control of WDTPS? = No",
    "8.5.6 CONFIG6\nName:\nCONFIG6\nAddress:\n0x300005\nConfiguration Byte 6\nAccess, 7. = . Access, 6. = . Access, 5.WDTCCS[2:0] = R/W. Access, 4.WDTCCS[2:0] = R/W. Access, 3.WDTCCS[2:0] = R/W. Access, 2.WDTCWS[2:0] = R/W. Access, 1.WDTCWS[2:0] = R/W. Access, 0.WDTCWS[2:0] = R/W. Reset, 7. = . Reset, 6. = . Reset, 5.WDTCCS[2:0] = 1. Reset, 4.WDTCCS[2:0] = 1. Reset, 3.WDTCCS[2:0] = 1. Reset, 2.WDTCWS[2:0] = 1. Reset, 1.WDTCWS[2:0] = 1. Reset, 0.WDTCWS[2:0] = 1",
    "Bits 5:3 - WDTCCS[2:0] WDT Input Clock Selector\nx, Condition = WDTE = 00. x, Description = These bits have no effect. 111, Condition = WDTE \u2260 00. 111, Description = Software control. 110 to 011, Condition = WDTE \u2260 00. 110 to 011, Description = Reserved. 010, Condition = WDTE \u2260 00. 010, Description = WDT reference clock is the SOSC. 001, Condition = WDTE \u2260 00. 001, Description = WDT reference clock is the 31.25 kHz MFINTOSC. 000, Condition = WDTE \u2260 00. 000, Description = WDT reference clock is the 31.0 kHz LFINTOSC",
    "Bits 2:0 - WDTCWS[2:0] WDT Window Select (1)\n111, WDTCON1[WINDOW] at POR.Value = 111. 111, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = n/a. 111, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 100. 111, Software Control of WINDOW.Software Control of WINDOW = Yes. 110, WDTCON1[WINDOW] at POR.Value = 110. 110, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = n/a. 110, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 100. 110, Software Control of WINDOW.Software Control of WINDOW = No. 101, WDTCON1[WINDOW] at POR.Value = 101. 101, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 25. 101, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 75. 101, Software Control of WINDOW.Software Control of WINDOW = No. 100, WDTCON1[WINDOW] at POR.Value = 100. 100,",
    "Bits 2:0 - WDTCWS[2:0] WDT Window Select (1)\nWDTCON1[WINDOW] at POR.Window Delay Percent of Time = 37.5. 100, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 62.5. 100, Software Control of WINDOW.Software Control of WINDOW = No. 011, WDTCON1[WINDOW] at POR.Value = 011. 011, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 50. 011, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 50. 011, Software Control of WINDOW.Software Control of WINDOW = No. 010, WDTCON1[WINDOW] at POR.Value = 010. 010, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 62.5. 010, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 37.5. 010, Software Control of WINDOW.Software Control of WINDOW = No. 001, WDTCON1[WINDOW] at POR.Value = 001. 001, WDTCON1[WINDOW]",
    "Bits 2:0 - WDTCWS[2:0] WDT Window Select (1)\nat POR.Window Delay Percent of Time = 75. 001, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 25. 001, Software Control of WINDOW.Software Control of WINDOW = No. 000, WDTCON1[WINDOW] at POR.Value = 000. 000, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 87.5. 000, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 12.5. 000, Software Control of WINDOW.Software Control of WINDOW = No",
    "Note:\n- 1. For any setting other than WDTCWS = 111 , user firmware has to arm the WDT by reading the WDTCON0 register before executing the CLRWDT instruction.",
    "8.5.7 CONFIG7\nName: Address:\nCONFIG7 0x300006\nConfiguration Byte 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = DEBUG. , 4 = SAFEN. , 5 = BBEN. , 6 = BBSIZE[2:0]. , 7 = BBSIZE[2:0]. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1 1. Reset, 7 = 1",
    "Bit 5 - DEBUG Debugger Enable\n1, Description = Background debugger disabled. 0, Description = Background debugger enabled",
    "Bit 4 - SAFEN  Storage Area Flash (SAF) Enable (1)\n1, Description = SAF is disabled. 0, Description = SAF is enabled",
    "Bit 3 - BBEN  Boot Block Enable (1)\n1, Description = Boot Block is disabled. 0, Description = Boot Block is enabled",
    "Bits 2:0 - BBSIZE[2:0]  Boot Block Size Selection (2)\n\nTable 8-1. Boot Block Size",
    "Bits 2:0 - BBSIZE[2:0]  Boot Block Size Selection (2)\n1, BBSIZE. = xxx. 1, End Address of.Boot Block = -. 1, Boot Block Size (words).PIC18Fx4Q41 = . 1, Boot Block Size (words).PIC18Fx5Q41 = -. 1, Boot Block Size (words).PIC18Fx6Q41 = . 0, BBSIZE. = 111. 0, End Address of.Boot Block = 00 03FFh. 0, Boot Block Size (words).PIC18Fx4Q41 = . 0, Boot Block Size (words).PIC18Fx5Q41 = 512. 0, Boot Block Size (words).PIC18Fx6Q41 = . 0, BBSIZE. = 110. 0, End Address of.Boot Block = 00 07FFh. 0, Boot Block Size (words).PIC18Fx4Q41 = . 0, Boot Block Size (words).PIC18Fx5Q41 = 1024. 0, Boot Block Size (words).PIC18Fx6Q41 = . 0,",
    "Bits 2:0 - BBSIZE[2:0]  Boot Block Size Selection (2)\nBBSIZE. = 101. 0, End Address of.Boot Block = 00 0FFFh. 0, Boot Block Size (words).PIC18Fx4Q41 = . 0, Boot Block Size (words).PIC18Fx5Q41 = 2048. 0, Boot Block Size (words).PIC18Fx6Q41 = . 0, BBSIZE. = 100. 0, End Address of.Boot Block = 00 1FFFh. 0, Boot Block Size (words).PIC18Fx4Q41 = . 0, Boot Block Size (words).PIC18Fx5Q41 = 4096. 0, Boot Block Size (words).PIC18Fx6Q41 = . 0, BBSIZE. = 011. 0, End Address of.Boot Block = 00 3FFFh. 0, Boot Block Size (words).PIC18Fx4Q41 = -. 0, Boot Block Size (words).PIC18Fx5Q41 = 8192. 0, Boot Block Size",
    "Bits 2:0 - BBSIZE[2:0]  Boot Block Size Selection (2)\n(words).PIC18Fx6Q41 = 8192. 0, BBSIZE. = 010. 0, End Address of.Boot Block = 00 7FFFh. 0, Boot Block Size (words).PIC18Fx4Q41 = -. 0, Boot Block Size (words).PIC18Fx5Q41 = . 0, Boot Block Size (words).PIC18Fx6Q41 = 16384. 0, BBSIZE. = 001. 0, End Address of.Boot Block = 00 FFFFh. 0, Boot Block Size (words).PIC18Fx4Q41 = . 0, Boot Block Size (words).PIC18Fx5Q41 = -. 0, Boot Block Size (words).PIC18Fx6Q41 = . 0, BBSIZE. = 000. 0, End Address of.Boot Block = 01 FFFFh. 0, Boot Block Size (words).PIC18Fx4Q41 = . 0, Boot Block Size (words).PIC18Fx5Q41 = -.",
    "Bits 2:0 - BBSIZE[2:0]  Boot Block Size Selection (2)\n0, Boot Block Size (words).PIC18Fx6Q41 = ",
    "Notes:\n1. Once protection is enabled through ICSP \u2122 or a self-write, it can only be reset through a Bulk Erase.\n2. BBSIZE[2:0] bits can only be changed when BBEN = 1 . Once BBEN = 0 , BBSIZE[2:0] can only be changed through a Bulk Erase.",
    "8.5.8 CONFIG8\nName: Address:\nCONFIG8\n0x300007",
    "Configuration Byte 8\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WRTAPP. , 2 = . , 3 = . , 4 = . , 5 = WRTSAF. , 6 = WRTD. , 7 = WRTC. , 8 = WRTB. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - WRTAPP  Application Block Write Protection (1)\n1, Description = Application Block is not write-protected. 0, Description = Application Block is write-protected",
    "Bit 3 - WRTSAF  Storage Area Flash (SAF) Write Protection (1,2)\n1, Description = SAF is not write-protected. 0, Description = SAF is write-protected",
    "Bit 2 - WRTD  Data EEPROM Write Protection (1)\n1, Description = Data EEPROM is not write-protected. 0, Description = Data EEPROM is write-protected",
    "Bit 1 - WRTC  Configuration Register Write Protection (1)\n1, Description = Configuration registers are not write-protected. 0, Description = Configuration registers are write-protected",
    "Bit 0 - WRTB  Boot Block Write Protection (1,3)\n1, Description = Boot Block is not write-protected. 0, Description = Boot Block is write-protected",
    "Notes:\n1. Once protection is enabled through ICSP \u2122 or a self-write, it can only be reset through a Bulk Erase.\n2. Applicable only if SAFEN = 0 .\n3. Applicable only if BBEN = 0 .",
    "8.5.9 CONFIG9\nName: Address:\nCONFIG9\n0x300008\nConfiguration Byte 9\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nCP\nAccess Reset\nR/W 1",
    "Bit 0 - CP  User Program Flash Memory and Data EEPROM Code Protection\n1, Description = User Program Flash Memory and Data EEPROM code protection are disabled. 0, Description = User Program Flash Memory and Data EEPROM code protection are enabled",
    "8.6 Register Summary - Configuration Settings\n0x00 ... 0x2FFFFF, Name = Reserved. 0x00 ... 0x2FFFFF, Bit Pos. = . 0x00 ... 0x2FFFFF, 7 = . 0x00 ... 0x2FFFFF, 6 = . 0x00 ... 0x2FFFFF, 5 = . 0x00 ... 0x2FFFFF, 4 = . 0x00 ... 0x2FFFFF, 3 = . 0x00 ... 0x2FFFFF, 2 = . 0x00 ... 0x2FFFFF, 1 = . 0x00 ... 0x2FFFFF, 0 = . 0x300000, Name = CONFIG1. 0x300000, Bit Pos. = 7:0. 0x300000, 7 = . 0x300000, 6 = RSTOSC[2:0]. 0x300000, 5 = RSTOSC[2:0]. 0x300000, 4 = .",
    "8.6 Register Summary - Configuration Settings\n0x300000, 3 = . 0x300000, 2 = FEXTOSC[2:0]. 0x300000, 1 = FEXTOSC[2:0]. 0x300000, 0 = FEXTOSC[2:0]. 0x300001, Name = CONFIG2. 0x300001, Bit Pos. = 7:0. 0x300001, 7 = FCMENS. 0x300001, 6 = FCMENP. 0x300001, 5 = FCMEN. 0x300001, 4 = . 0x300001, 3 = CSWEN. 0x300001, 2 = . 0x300001, 1 = PR1WAY. 0x300001, 0 = CLKOUTEN. 0x300002, Name = CONFIG3. 0x300002, Bit Pos. = 7:0. 0x300002, 7 = BOREN[1:0]. 0x300002, 6 = BOREN[1:0].",
    "8.6 Register Summary - Configuration Settings\n0x300002, 5 = LPBOREN. 0x300002, 4 = IVT1WAY. 0x300002, 3 = MVECEN. 0x300002, 2 = PWRTS[1:0]. 0x300002, 1 = PWRTS[1:0]. 0x300002, 0 = MCLRE. 0x300003, Name = CONFIG4. 0x300003, Bit Pos. = 7:0. 0x300003, 7 = XINST. 0x300003, 6 = . 0x300003, 5 = LVP. 0x300003, 4 = STVREN. 0x300003, 3 = PPS1WAY. 0x300003, 2 = ZCD. 0x300003, 1 = BORV[1:0]. 0x300003, 0 = BORV[1:0]. 0x300004, Name = CONFIG5.",
    "8.6 Register Summary - Configuration Settings\n0x300004, Bit Pos. = 7:0. 0x300004, 7 = WDTE[1:0]. 0x300004, 6 = WDTE[1:0]. 0x300004, 5 = WDTE[1:0]. 0x300004, 4 = WDTCPS[4:0]. 0x300004, 3 = WDTCPS[4:0]. 0x300004, 2 = WDTCPS[4:0]. 0x300004, 1 = WDTCPS[4:0]. 0x300004, 0 = WDTCPS[4:0]. 0x300005, Name = CONFIG6. 0x300005, Bit Pos. = 7:0. 0x300005, 7 = . 0x300005, 6 = . 0x300005, 5 = WDTCCS[2:0]. 0x300005, 4 =",
    "8.6 Register Summary - Configuration Settings\nWDTCCS[2:0]. 0x300005, 3 = WDTCCS[2:0]. 0x300005, 2 = WDTCWS[2:0]. 0x300005, 1 = WDTCWS[2:0]. 0x300005, 0 = WDTCWS[2:0]. 0x300006, Name = CONFIG7. 0x300006, Bit Pos. = 7:0. 0x300006, 7 = . 0x300006, 6 = . 0x300006, 5 = DEBUG. 0x300006, 4 = SAFEN. 0x300006, 3 = BBEN. 0x300006, 2 = BBSIZE[2:0]. 0x300006, 1 = BBSIZE[2:0]. 0x300006, 0 = BBSIZE[2:0]. 0x300007, Name = CONFIG8. 0x300007,",
    "8.6 Register Summary - Configuration Settings\nBit Pos. = 7:0. 0x300007, 7 = WRTAPP. 0x300007, 6 = . 0x300007, 5 = . 0x300007, 4 = . 0x300007, 3 = WRTSAF. 0x300007, 2 = WRTD. 0x300007, 1 = WRTC. 0x300007, 0 = WRTB. 0x300008, Name = CONFIG9. 0x300008, Bit Pos. = 7:0. 0x300008, 7 = . 0x300008, 6 = . 0x300008, 5 = . 0x300008, 4 = . 0x300008, 3 = . 0x300008, 2 = . 0x300008, 1 = . 0x300008, 0 = CP",
    "8.7.1 Device ID\nName: Address:\nDEVICEID 0x3FFFFE",
    "Device ID Register\nAccess, 15.DEV[15:8] = R. Access, 14.DEV[15:8] = R. Access, 13.DEV[15:8] = R. Access, 12.DEV[15:8] = R. Access, 11.DEV[15:8] = R. Access, 10.DEV[15:8] = R. Access, 9.DEV[15:8] = R. Access, 8.DEV[15:8] = R. Reset, 15.DEV[15:8] = q. Reset, 14.DEV[15:8] = q. Reset, 13.DEV[15:8] = q. Reset, 12.DEV[15:8] = q. Reset, 11.DEV[15:8] = q. Reset, 10.DEV[15:8] = q. Reset, 9.DEV[15:8] = q. Reset, 8.DEV[15:8] = q. Bit, 15.DEV[15:8] = 7. Bit, 14.DEV[15:8] = 6. Bit, 13.DEV[15:8] = 5. Bit,",
    "Device ID Register\n12.DEV[15:8] = 4. Bit, 11.DEV[15:8] = 3. Bit, 10.DEV[15:8] = 2. Bit, 9.DEV[15:8] = 1. Bit, 8.DEV[15:8] = 0. , 15.DEV[15:8] = DEV[7:0]. , 14.DEV[15:8] = DEV[7:0]. , 13.DEV[15:8] = DEV[7:0]. , 12.DEV[15:8] = DEV[7:0]. , 11.DEV[15:8] = DEV[7:0]. , 10.DEV[15:8] = DEV[7:0]. , 9.DEV[15:8] = DEV[7:0]. , 8.DEV[15:8] = DEV[7:0]. Access, 15.DEV[15:8] = R. Access, 14.DEV[15:8] = R. Access, 13.DEV[15:8] = R. Access, 12.DEV[15:8] = R. Access,",
    "Device ID Register\n11.DEV[15:8] = R. Access, 10.DEV[15:8] = R. Access, 9.DEV[15:8] = R. Access, 8.DEV[15:8] = R. Reset, 15.DEV[15:8] = q. Reset, 14.DEV[15:8] = q. Reset, 13.DEV[15:8] = q. Reset, 12.DEV[15:8] = q. Reset, 11.DEV[15:8] = q. Reset, 10.DEV[15:8] = q. Reset, 9.DEV[15:8] = q. Reset, 8.DEV[15:8] = q",
    "Bits 15:0 - DEV[15:0] Device ID\nPIC18F04Q41, Device ID = 7540h. PIC18F05Q41, Device ID = 7500h. PIC18F06Q41, Device ID = 7580h. PIC18F14Q41, Device ID = 7520h. PIC18F15Q41, Device ID = 74E0h. PIC18F16Q41, Device ID = 7560h",
    "8.7.2 Revision ID\nName:\nREVISIONID\nAddress:\n0x3FFFFC\nRevision ID Register",
    "8.7.2 Revision ID\nAccess, 15.1010[3:0] = R. Access, 14.1010[3:0] = R. Access, 13.1010[3:0] = R. Access, 12.1010[3:0] = R. Access, 11.MJRREV[5:2] = R. Access, 10.MJRREV[5:2] = R. Access, 9.MJRREV[5:2] = R. Access, 8.MJRREV[5:2] = R. Reset, 15.1010[3:0] = 1. Reset, 14.1010[3:0] = 0. Reset, 13.1010[3:0] = 1. Reset, 12.1010[3:0] = 0. Reset, 11.MJRREV[5:2] = q. Reset, 10.MJRREV[5:2] = q. Reset, 9.MJRREV[5:2] = q. Reset, 8.MJRREV[5:2] = q. Bit,",
    "8.7.2 Revision ID\n15.1010[3:0] = 7. Bit, 14.1010[3:0] = 6. Bit, 13.1010[3:0] = 5. Bit, 12.1010[3:0] = 4. Bit, 11.MJRREV[5:2] = 3. Bit, 10.MJRREV[5:2] = 2. Bit, 9.MJRREV[5:2] = 1. Bit, 8.MJRREV[5:2] = 0. , 15.1010[3:0] = MJRREV[1:0]. , 14.1010[3:0] = MJRREV[1:0]. , 13.1010[3:0] = MNRREV[5:0]. , 12.1010[3:0] = MNRREV[5:0]. , 11.MJRREV[5:2] = MNRREV[5:0]. , 10.MJRREV[5:2] = MNRREV[5:0]. ,",
    "8.7.2 Revision ID\n9.MJRREV[5:2] = MNRREV[5:0]. , 8.MJRREV[5:2] = MNRREV[5:0]. Access, 15.1010[3:0] = R. Access, 14.1010[3:0] = R. Access, 13.1010[3:0] = R. Access, 12.1010[3:0] = R. Access, 11.MJRREV[5:2] = R. Access, 10.MJRREV[5:2] = R. Access, 9.MJRREV[5:2] = R. Access, 8.MJRREV[5:2] = R. Reset, 15.1010[3:0] = q. Reset, 14.1010[3:0] = q. Reset, 13.1010[3:0] = q. Reset, 12.1010[3:0] = q. Reset, 11.MJRREV[5:2] = q. Reset, 10.MJRREV[5:2] =",
    "8.7.2 Revision ID\nq. Reset, 9.MJRREV[5:2] = q. Reset, 8.MJRREV[5:2] = q",
    "Bits 15:12 - 1010[3:0]  Read as 'b1010\nThese bits are fixed with value 'b1010 for all devices in this family.",
    "Bits 11:6 - MJRREV[5:0] Major Revision ID\nRevision A = 'b00 0000\nThese bits are used to identify a major revision (A0, B0, C0, etc.).\nRevision B = 'b00 0001",
    "Bits 5:0 - MNRREV[5:0] Minor Revision ID\nRevision A0 = 'b00 0000\nThese bits are used to identify a minor revision.\nRevision B0 = 'b00 0000\nRevision B1 = 'b00 0001\nTip: For example, the REVISIONID register value for revision B1 will be 0xA041 .",
    "8.8 Register Summary - DEVID/REVID\n0x00 ... 0x3FFFFB, Name = Reserved. 0x00 ... 0x3FFFFB, Bit Pos. = . 0x00 ... 0x3FFFFB, 7 = . 0x00 ... 0x3FFFFB, 6 = . 0x00 ... 0x3FFFFB, 5 = . 0x00 ... 0x3FFFFB, 4 = . 0x00 ... 0x3FFFFB, 3 = . 0x00 ... 0x3FFFFB, 2 = . 0x00 ... 0x3FFFFB, 1 = . 0x00 ... 0x3FFFFB, 0 = . 0x3FFFFC, Name = REVISIONID. 0x3FFFFC, Bit Pos. = 7:0. 0x3FFFFC, 7 = MJRREV[1:0]. 0x3FFFFC, 6 = . 0x3FFFFC, 5 = . 0x3FFFFC, 4 =",
    "8.8 Register Summary - DEVID/REVID\nMNRREV[5:0]. 0x3FFFFC, 3 = MNRREV[5:0]. 0x3FFFFC, 2 = MNRREV[5:0]. 0x3FFFFC, 1 = . 0x3FFFFC, 0 = . 0x3FFFFC, Name = REVISIONID. 0x3FFFFC, Bit Pos. = 15:8. 0x3FFFFC, 7 = 1010[3:0]. 0x3FFFFC, 6 = 1010[3:0]. 0x3FFFFC, 5 = . 0x3FFFFC, 4 = . 0x3FFFFC, 3 = MJRREV[5:2]. 0x3FFFFC, 2 = MJRREV[5:2]. 0x3FFFFC, 1 = . 0x3FFFFC, 0 = . 0x3FFFFE, Name = DEVICEID. 0x3FFFFE, Bit Pos. = 7:0. 0x3FFFFE, 7 =",
    "8.8 Register Summary - DEVID/REVID\nDEV[7:0]. 0x3FFFFE, 6 = DEV[7:0]. 0x3FFFFE, 5 = DEV[7:0]. 0x3FFFFE, 4 = DEV[7:0]. 0x3FFFFE, 3 = DEV[7:0]. 0x3FFFFE, 2 = DEV[7:0]. 0x3FFFFE, 1 = DEV[7:0]. 0x3FFFFE, 0 = DEV[7:0]. 0x3FFFFE, Name = DEVICEID. 0x3FFFFE, Bit Pos. = 15:8. 0x3FFFFE, 7 = DEV[15:8]. 0x3FFFFE, 6 = DEV[15:8]. 0x3FFFFE, 5 = DEV[15:8]. 0x3FFFFE, 4 = DEV[15:8]. 0x3FFFFE, 3 = DEV[15:8]. 0x3FFFFE, 2 = DEV[15:8]. 0x3FFFFE, 1 = DEV[15:8].",
    "8.8 Register Summary - DEVID/REVID\n0x3FFFFE, 0 = DEV[15:8]",
    "9. Memory Organization\nThere are three types of memory in PIC18 microcontroller devices:\n\u00b7 Program Memory\n\u00b7 Data RAM\n\u00b7 Data EEPROM\nIn Harvard architecture devices, the data and program memories use separate buses that allow for concurrent access of the two memory spaces. The data EEPROM, for practical purposes, can be regarded as a peripheral device, since it is addressed and accessed through a set of control registers.\nAdditional detailed information on the operation of the Program Flash Memory and data EEPROM memory is provided in the 'NVM - Nonvolatile Memory Module' chapter.",
    "9.1 Program Memory Organization\nPIC18 microcontrollers implement a 21-bit Program Counter, which is capable of addressing a 2 Mbyte program memory space. Accessing a location between the upper boundary of the physically implemented memory and the 2 Mbyte address will return all ' 0 's (a NOP instruction).\nRefer to the following tables for device memory maps and code protection Configuration bits associated with the various sections of PFM.\nThe Reset vector address is at 000000h . The PIC18-Q41 devices feature a vectored interrupt controller with a dedicated interrupt vector table stored in the program memory. Refer to the 'VIC Vectored Interrupt Controller Module' chapter for more details.\n\nFigure 9-1. Program and Data Memory Map",
    "9.1 Program Memory Organization\n00 0000h to 00 3FFFh, 4/20/2017.PIC18Fx4Q41 = Program Flash Memory (8KW) (1). 00 0000h to 00 3FFFh, 4/20/2017.PIC18Fx5Q41 Device = Program Flash Memory (16 KW) (1). 00 0000h to 00 3FFFh, 4/20/2017.PIC18Fx6Q41 = Program Flash Memory (32 KW) (1). 00 4000h to 00 7FFFh, 4/20/2017.PIC18Fx4Q41 = Program Flash Memory (8KW) (1). 00 4000h to 00 7FFFh, 4/20/2017.PIC18Fx5Q41 Device = Program Flash Memory (16 KW) (1). 00 4000h to 00 7FFFh, 4/20/2017.PIC18Fx6Q41 = Program Flash Memory (32 KW) (1). 00 8000h to 00 FFFFh, 4/20/2017.PIC18Fx4Q41 = Program Flash Memory (8KW)",
    "9.1 Program Memory Organization\n(1). 00 8000h to 00 FFFFh, 4/20/2017.PIC18Fx5Q41 Device = Not Present (2). 00 8000h to 00 FFFFh, 4/20/2017.PIC18Fx6Q41 = Program Flash Memory (32 KW) (1). 01 0000h to 01 FFFFh, 4/20/2017.PIC18Fx4Q41 = Present (2). 01 0000h to 01 FFFFh, 4/20/2017.PIC18Fx5Q41 Device = Not Present (2). 01 0000h to 01 FFFFh, 4/20/2017.PIC18Fx6Q41 = Not Present (2). 02 0000h to 1F FFFFh, 4/20/2017.PIC18Fx4Q41 = Program Flash Memory (8KW) (1). 02 0000h to 1F FFFFh, 4/20/2017.PIC18Fx5Q41 Device = Not Present (2). 02 0000h to 1F FFFFh,",
    "9.1 Program Memory Organization\n4/20/2017.PIC18Fx6Q41 = Not Present (2). 20 0000h to 20 003Fh, 4/20/2017.PIC18Fx4Q41 = User IDs (32 Words) (3). 20 0000h to 20 003Fh, 4/20/2017.PIC18Fx5Q41 Device = User IDs (32 Words) (3). 20 0000h to 20 003Fh, 4/20/2017.PIC18Fx6Q41 = User IDs (32 Words) (3). 20 0040h to 2B FFFFh, 4/20/2017.PIC18Fx4Q41 = Reserved. 20 0040h to 2B FFFFh, 4/20/2017.PIC18Fx5Q41 Device = Reserved. 20 0040h to 2B FFFFh, 4/20/2017.PIC18Fx6Q41 = Reserved. 2C 0000h to 2C 00FFh, 4/20/2017.PIC18Fx4Q41 = Device Information Area (DIA) (3,5).",
    "9.1 Program Memory Organization\n2C 0000h to 2C 00FFh, 4/20/2017.PIC18Fx5Q41 Device = Device Information Area (DIA) (3,5). 2C 0000h to 2C 00FFh, 4/20/2017.PIC18Fx6Q41 = Device Information Area (DIA) (3,5). 2C 0100h to 2F FFFFh, 4/20/2017.PIC18Fx4Q41 = Reserved. 2C 0100h to 2F FFFFh, 4/20/2017.PIC18Fx5Q41 Device = Reserved. 2C 0100h to 2F FFFFh, 4/20/2017.PIC18Fx6Q41 = Reserved. 30 0000h to 30 0009h, 4/20/2017.PIC18Fx4Q41 = Configuration Bytes (3). 30 0000h to 30 0009h, 4/20/2017.PIC18Fx5Q41 Device = Configuration Bytes (3). 30 0000h to 30 0009h, 4/20/2017.PIC18Fx6Q41 = Configuration Bytes",
    "9.1 Program Memory Organization\n(3). 30 000Ah to 37 FFFFh, 4/20/2017.PIC18Fx4Q41 = Reserved. 30 000Ah to 37 FFFFh, 4/20/2017.PIC18Fx5Q41 Device = Reserved. 30 000Ah to 37 FFFFh, 4/20/2017.PIC18Fx6Q41 = Reserved. 38 0000h to 38 01FFh, 4/20/2017.PIC18Fx4Q41 = Data EEPROM (512 Bytes). 38 0000h to 38 01FFh, 4/20/2017.PIC18Fx5Q41 Device = Data EEPROM (512 Bytes). 38 0000h to 38 01FFh, 4/20/2017.PIC18Fx6Q41 = Data EEPROM (512 Bytes). 38 0200h to 3B FFFFh, 4/20/2017.PIC18Fx4Q41 = Reserved. 38 0200h to 3B FFFFh, 4/20/2017.PIC18Fx5Q41 Device = Reserved. 38 0200h to 3B FFFFh,",
    "9.1 Program Memory Organization\n4/20/2017.PIC18Fx6Q41 = Reserved. 3C 0000h to 3C 0009h, 4/20/2017.PIC18Fx4Q41 = Device Configuration Information (3,4,5). 3C 0000h to 3C 0009h, 4/20/2017.PIC18Fx5Q41 Device = Device Configuration Information (3,4,5). 3C 0000h to 3C 0009h, 4/20/2017.PIC18Fx6Q41 = Device Configuration Information (3,4,5). 3C 000Ah to 3F FFFBh, 4/20/2017.PIC18Fx4Q41 = Reserved. 3C 000Ah to 3F FFFBh, 4/20/2017.PIC18Fx5Q41 Device = Reserved. 3C 000Ah to 3F FFFBh, 4/20/2017.PIC18Fx6Q41 = Reserved. 3F FFFCh to 3F FFFDh, 4/20/2017.PIC18Fx4Q41 = Revision ID (1 Word) (3,4,5).",
    "9.1 Program Memory Organization\n3F FFFCh to 3F FFFDh, 4/20/2017.PIC18Fx5Q41 Device = Revision ID (1 Word) (3,4,5). 3F FFFCh to 3F FFFDh, 4/20/2017.PIC18Fx6Q41 = Revision ID (1 Word) (3,4,5). 3F FFFEh to 3F FFFFh, 4/20/2017.PIC18Fx4Q41 = Device ID (1 Word) (3,4,5). 3F FFFEh to 3F FFFFh, 4/20/2017.PIC18Fx5Q41 Device = Device ID (1 Word) (3,4,5). 3F FFFEh to 3F FFFFh, 4/20/2017.PIC18Fx6Q41 = Device ID (1 Word) (3,4,5)\nNote s:",
    "9.1 Program Memory Organization\n1 . Storage Area Flash is implemented as the last 128 Words of User Flash, if enabled.\n2 . The addresses do not roll over. The region is read as ' 0 '.\n3 . Not code-protected.\n4 . Hard-coded in silicon.\n5 . This region cannot be written by the user and it is not affected by a Bulk Erase.",
    "9.1.1 Memory Access Partition\nIn the PIC18-Q41 devices, the program memory can be further partitioned into the following subblocks:\n\u00b7 Application block\n\u00b7 Boot block\n\u00b7 Storage Area Flash (SAF) block\nRefer to the \"Program Flash Memory Partition\" table for more details.",
    "9.1.1.1 Application Block\nApplication block is where the user's firmware resides by default. Default settings of the Configuration bits (BBEN = 1 and SAFEN = 1 ) assign all memory in the program Flash memory area to the application block. The WRTAPP Configuration bit is used to write-protect the application block.",
    "9.1.1.2 Boot Block\nBoot block is an area in program memory that is ideal for storing bootloader code. Code placed in this area can be executed by the CPU. The boot block can be write-protected, independent of the main application block. The Boot Block is enabled by the BBEN Configuration bit and size is based on the value of the BBSIZE Configuration bits. The WRTB Configuration bit is used to write-protect the Boot Block.",
    "9.1.1.3 Storage Area Flash\nStorage Area Flash (SAF) is the area in program memory that can be used as data storage. SAF is enabled by the SAFEN Configuration bit. If enabled, the code placed in this area cannot be executed by the CPU. The SAF block is placed at the end of memory and spans 128 Words. The WRTSAF Configuration bit is used to write-protect the Storage Area Flash.\nImportant: If write-protected locations are written to, memory is not changed and the WRERR bit is set.\n\nTable 9-1. Program Flash Memory Partition",
    "9.1.1.3 Storage Area Flash\nProgram Flash Memory, Address = 00 0000h . . . . Last Boot Block Memory Address. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 1 = Application Block. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 0 = Application Block. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 1 = Boot Block. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 0 = Boot Block. Program Flash Memory, Address = Last Boot Block Memory Address (1) + 1 . . . . Last Program Memory Address (2) - 100h. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 1 = Application Block. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 0 = Application Block. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 1 = Application Block. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 0 = Application Block. Program Flash Memory, Address = Last Program Memory Address (2) - FEh (4) . . . . Last Program Memory Address",
    "9.1.1.3 Storage Area Flash\n(2). Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 1 = Application Block. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 0 = Storage Area Flash Block. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 1 = Application Block. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 0 = Storage Area Flash Block",
    "Notes:\n1. Last Boot Block address is based on BBSIZE bits. Refer to the 'Device Configuration' chapter for more details.\n2. For Last Program Memory address refer the table above.\n3. Refer to the 'Device Configuration' chapter for BBEN and SAFEN bit definitions.\n4. Storage Area Flash is implemented as the last 128 Words of user Flash memory.",
    "9.1.2 Program Counter\nThe Program Counter (PC) specifies the address of the instruction to fetch for execution. The PC is 21 bits wide and is contained in three separate 8-bit registers. The low byte, known as the PCL register, is both readable and writable. The high byte, or PCH register, contains the PC[15:8] bits; it is not directly readable or writable. Updates to the PCH register are performed through the PCLATH register. The upper byte is called PCU. This register contains the PC[20:16] bits; it is also not directly readable or writable. Updates to the PCU register are performed through the PCLATU register.\nThe contents of PCLATH and PCLATU are transferred to the Program Counter by any operation that writes PCL. Similarly, the upper two bytes of the Program Counter are transferred to PCLATH and PCLATU by an operation that reads PCL. This is useful for computed offsets to the PC (see the Computed GOTO section).",
    "9.1.2 Program Counter\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the Least Significant bit of PCL is fixed to a value of ' 0 '. The PC increments by two to address sequential instructions in the program memory.\nThe CALL RCALL GOTO , , and program branch instructions write to the Program Counter directly. For these instructions, the contents of PCLATH and PCLATU are not transferred to the Program Counter.",
    "9.1.3 Return Address Stack\nThe return address stack allows any combination of up to 127 program calls and interrupts to occur. The PC is pushed onto the stack when a CALL or RCALL instruction is executed or an interrupt is Acknowledged. The PC value is pulled off the stack on a RETURN RETLW , or a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN or CALL instructions.\nThe Stack Pointer is readable and writable and the address on the top of the stack is readable and writable through the Top-of-Stack (TOS) Special File registers. Data can also be pushed to or popped from the stack using these registers.\nA CALL type instruction causes a push onto the stack; the Stack Pointer is first incremented and the location pointed to by the Stack Pointer is written with the contents of the PC (already pointing to the instruction following the CALL ). A RETURN type instruction causes a pop from the stack; the contents of the location pointed to by the STKPTR are transferred to the PC and then the Stack Pointer is decremented.\nThe Stack Pointer is initialized to 0x00 after all Resets.",
    "9.1.3.1 Top-of-Stack Access\nOnly the top of the return address stack (TOS) is readable and writable. A set of three registers, TOSU:TOSH:TOSL, hold the contents of the stack location pointed to by the STKPTR register (see Figure 9-2). This allows users to implement a software stack if necessary. After a CALL, RCALL or interrupt, the software can read the pushed value by reading the TOSU:TOSH:TOSL registers. These values can be placed on a user defined software stack. At return time, the software can return these values to TOSU:TOSH:TOSL and do a return.\nThe user must disable the Global Interrupt Enable (GIE) bits while accessing the stack to prevent inadvertent stack corruption.",
    "9.1.3.2 Return Stack Pointer\nThe STKPTR register contains the Stack Pointer value. The Stack Overflow (STKOVF) Status bit and the Stack Underflow (STKUNF) Status bit can be accessed using the PCON0 register. The value of the Stack Pointer can be zero through 127. On Reset, the Stack Pointer value will be zero. The user may read and write the Stack Pointer value. After the PC is pushed onto the stack 128 times (without popping any values off the stack), the STKOVF bit is set. The STKOVF bit is cleared by software or by a POR. The action that takes place when the stack becomes full depends on the state of the Stack Overflow Reset Enable (STVREN) Configuration bit.\nIf STVREN is set (default), a Reset will be generated and a Stack Overflow will be indicated by the STKOVF bit. This includes CALL and CALLW instructions, as well as stacking the return address during an interrupt response. The STKOVF bit will remain set and the Stack Pointer will be set to zero.",
    "9.1.3.2 Return Stack Pointer\nIf STVREN is cleared, the STKOVF bit will be set on the 128 th  push, and the Stack Pointer will remain at 127, but no Reset will occur. Any additional pushes will overwrite the 127 th  push, but the STKPTR will remain unchanged.\nSetting STKOVF = 1 in software will change the bit but will not generate a Reset.\nThe STKUNF bit is set when a stack pop returns a value of ' 0 '. The STKUNF bit is cleared by software or by POR. The action that takes place when the stack becomes full depends on the state of the Stack Overflow Reset Enable (STVREN) Configuration bit.\nIf STVREN is set (default) and the stack has been popped enough times to unload the stack, the next pop will return a value of ' 0 ' to the PC, it will set the STKUNF bit, and a Reset will be generated. This condition can be generated by the RETURN RETLW , and RETFIE instructions.\nIf STVREN is cleared, the STKUNF bit will be set, but no Reset will occur.",
    "9.1.3.2 Return Stack Pointer\nImportant: Returning a value of ' 0 ' to the PC on an underflow has the effect of vectoring the program to the Reset vector, where the stack conditions can be verified and appropriate actions can be taken. This is not the same as a Reset, as the contents of the SFRs are not affected.",
    "9.1.3.3 PUSH and POP Instructions\nSince the Top-of-Stack is readable and writable, the ability to push values onto the stack and pull values off the stack without disturbing normal program execution is a desirable feature. The PIC18 instruction set includes two instructions, PUSH and POP , that permit the TOS to be manipulated\nunder software control. TOSU, TOSH and TOSL can be modified to place data or a return address on the stack.\nThe PUSH instruction places the current PC value onto the stack. This increments the Stack Pointer and loads the current PC value onto the stack.\nThe POP instruction discards the current TOS by decrementing the Stack Pointer. The previous value pushed onto the stack then becomes the TOS value.",
    "9.1.3.4 Fast Register Stack\nThere are three levels of fast stack registers available - one for CALL type instructions and two for interrupts. A fast register stack is provided for the STATUS, WREG and BSR registers, to provide a 'fast return' option for interrupts. It is loaded with the current value of the corresponding register when the processor vectors for an interrupt. All interrupt sources will push values into the stack registers. The values in the registers are then loaded back into their associated registers if the RETFIE FAST , instruction is used to return from the interrupt. Refer to the 'Call Shadow Register' section for interrupt call shadow registers.\nThe following example shows a source code example that uses the Fast Register Stack during a subroutine call and return.",
    "9.1.4 Look-up Tables in Program Memory\nThere may be programming situations that require the creation of data structures, or Look-up Tables, in program memory. For PIC18 devices, Look-up Tables can be implemented in two ways:\n\u00b7 Computed GOTO\n\u00b7 Table reads",
    "9.1.4.1 Computed GOTO\nA computed GOTO is accomplished by adding an offset to the Program Counter. An example is shown in the following code example.\nA Look-up Table can be formed with an ADDWF PCL instruction and a group of RETLW nn instructions. The W register is loaded with an offset into the table before executing a call to that table. The first instruction of the called routine is the ADDWF PCL instruction. The next instruction executed will be one of the RETLW nn instructions that returns the value ' nn ' to the calling function.\nThe offset value (in WREG) specifies the number of bytes that the Program Counter will advance and must be multiples of two (LSb = 0 ).\nIn this method, only one data byte may be stored in each instruction location and room on the return address stack is required.",
    "9.1.4.2 Program Flash Memory Access\nA more compact method of storing data in program memory allows two bytes of data to be stored in each instruction location.\nLook-up Table data may be stored two bytes per program word by using table reads and writes. The Table Pointer (TBLPTR) register specifies the byte address and the Table Latch (TABLAT) register contains the data that are read from or written to program memory. Data are transferred to or from program memory one byte at a time.\nTable read and table write operations are discussed further in the 'Table Read Operations' and 'Table Write Operations' sections in the 'NVM - Nonvolatile Memory Module' chapter.",
    "9.2 Device Information Area\nThe Device Information Area (DIA) is a dedicated region in the program memory space. The DIA contains the calibration data for the internal temperature indicator module, the Microchip Unique Identifier words, and the Fixed Voltage Reference voltage readings measured in mV.\nThe complete DIA table is shown below, followed by a description of each region and its functionality. The data are mapped from 2C0000h to 2C003Fh. These locations are read-only and cannot be erased or modified. The data are programmed into the device during manufacturing.\n\nTable 9-2. Device Information Area",
    "9.2 Device Information Area\n2C0000h-2C0011h, Name of Region = MUI0. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI1. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI2. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI3. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI4. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words).",
    "9.2 Device Information Area\n2C0000h-2C0011h, Name of Region = MUI5. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI6. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI7. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI8. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0012h-2C0013h, Name of Region = MUI9. 2C0012h-2C0013h, Standard Device Information = Reserved (1 Word). 2C0014h-2C0023h, Name of Region =",
    "9.2 Device Information Area\nEUI0. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI1. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI2. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI3. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI4. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI5.",
    "9.2 Device Information Area\n2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI6. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI7. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0024h-2C0025h, Name of Region = TSLR1 (1). 2C0024h-2C0025h, Standard Device Information = Gain = 0.1C \u00d7256 count (low range setting). 2C0026h-2C0027h, Name of Region = TSLR2 (1). 2C0026h-2C0027h, Standard Device Information = Temperature indicator ADC reading at 90\u00b0C (low range setting). 2C0028h-2C0029h, Name of Region = TSLR3",
    "9.2 Device Information Area\n(1). 2C0028h-2C0029h, Standard Device Information = Offset (low range setting). 2C002Ah-2C002Bh, Name of Region = TSHR1 (2). 2C002Ah-2C002Bh, Standard Device Information = Gain 0.1C \u00d7256 (high range setting)\n= 0.1C \u00d7 256\ncount",
    "9.2 Device Information Area\n2C002Ch-2C002Dh, Name of Region = TSHR2 (2). 2C002Ch-2C002Dh, Standard Device Information = Temperature indicator ADC reading at 90\u00b0C (high range setting). 2C002Eh-2C002Fh, Name of Region = TSHR3 (2). 2C002Eh-2C002Fh, Standard Device Information = Offset (high range setting). 2C0030h-2C0031h, Name of Region = FVRA1X. 2C0030h-2C0031h, Standard Device Information = ADC FVR1 Output voltage for 1x setting (in mV). 2C0032h-2C0033h, Name of Region = FVRA2X. 2C0032h-2C0033h, Standard Device Information = ADC FVR1 Output Voltage for 2x setting (in mV). 2C0034h-2C0035h, Name of Region = FVRA4X. 2C0034h-2C0035h, Standard Device Information = ADC",
    "9.2 Device Information Area\nFVR1 Output Voltage for 4x setting (in mV). 2C0036h-2C0037h, Name of Region = FVRC1X. 2C0036h-2C0037h, Standard Device Information = Comparator FVR2 output voltage for 1x setting (in mV). 2C0038h-2C0039h, Name of Region = FVRC2X. 2C0038h-2C0039h, Standard Device Information = Comparator FVR2 output voltage for 2x setting (in mV). 2C003Ah-2C003Bh, Name of Region = FVRC4X. 2C003Ah-2C003Bh, Standard Device Information = Comparator FVR2 output voltage for 4x setting (in mV). 2C003Ch-2C003Fh, Name of Region = . 2C003Ch-2C003Fh, Standard Device Information = Unassigned (2 Words)",
    "Notes:\n1. TSLR: Address 2C0024h-2C0029h store the measurements for the low range setting of the temperature sensor at VDD = 3V, V REF + = 2.048V from FVR1.\n2. TSHR: Address 2C002Ah-2C002Fh store the measurements for the high range setting of the temperature sensor at VDD = 3V, V REF + = 2.048V from FVR1.",
    "9.2.1 Microchip Unique Identifier (MUI)\nThis family of devices is individually encoded during final manufacturing with a Microchip Unique Identifier (MUI). The MUI cannot be user-erased. This feature allows for manufacturing traceability of Microchip Technology devices in applications where this is required. It may also be used by the application manufacturer for a number of functions that require unverified unique identification, such as:\n\u00b7 Tracking the device\n\u00b7 Unique serial number\nThe MUI is stored in read-only locations, located between 2C0000h to 2C0013h in the DIA space. The DIA table lists the addresses of the identifier words.\nImportant: For applications that require verified unique identification, contact the Microchip Technology sales office to create a Serialized Quick Turn Programming option.",
    "9.2.2 External Unique Identifier (EUI)\nThe EUI data are stored at locations 2C0014h-2C0023h in the program memory region. This region is an optional space for placing application specific information. The data are coded per customer requirements during manufacturing. The EUI cannot be erased by a Bulk Erase command.\nImportant: Data are stored in this address range on receiving a request from the customer. The customer may contact the local sales representative or Field Applications Engineer and provide them the unique identifier information that is required to be stored in this region.",
    "9.2.3 Standard Parameters for the Temperature Sensor\nThe purpose of the temperature indicator module is to provide a temperature-dependent voltage that can be measured by an analog module. The DIA table contains standard parameters for the temperature sensor for low and high range. The values are measured during test and are unique to each device. The calibration data can be used to plot the approximate sensor output voltage, VTSENSE\nvs. Temperature curve. The 'Temperature Indicator Module' chapter explains the operation of the Temperature Indicator module and defines terms such as the low range and high range settings of the sensor.",
    "9.2.4 Fixed Voltage Reference Data\nThe DIA stores measured FVR voltages for this device in mV for different buffer settings of 1x, 2x or 4x at program memory locations. For more information on the FVR, refer to the 'FVR - Fixed Voltage Reference' chapter.",
    "9.3 Device Configuration Information\nThe Device Configuration Information (DCI) is a dedicated region in the program memory mapped from 3C0000h to 3C0009h. The data stored in these location is read-only and cannot be erased. Refer to the table below for the complete DCI table address and description. The DCI holds information about the device, which is useful for programming and Bootloader applications.\nThe erase size is the minimum erasable unit in the PFM, expressed as rows. The total device Flash memory capacity is (Erase size * Number of user-erasable pages).\n\nTable 9-3. Device Configuration Information for PIC18FxxQ41 Devices",
    "9.3 Device Configuration Information\n3C0000h-3C0001h, Name. = ERSIZ. 3C0000h-3C0001h, Description. = Erase page size. 3C0000h-3C0001h, Value.PIC18F04/14Q41 = 128. 3C0000h-3C0001h, Value.PIC18F05/15Q41 = 128. 3C0000h-3C0001h, Value.PIC18F06/16Q41 = 128. 3C0000h-3C0001h, Units. = Words. 3C0002h-3C0003h, Name. = WLSIZ. 3C0002h-3C0003h, Description. = Number of write latches per row. 3C0002h-3C0003h, Value.PIC18F04/14Q41 = 0. 3C0002h-3C0003h, Value.PIC18F05/15Q41 = 0. 3C0002h-3C0003h,",
    "9.3 Device Configuration Information\nValue.PIC18F06/16Q41 = 0. 3C0002h-3C0003h, Units. = Words. 3C0004h-3C0005h, Name. = URSIZ. 3C0004h-3C0005h, Description. = Number of user- erasable pages. 3C0004h-3C0005h, Value.PIC18F04/14Q41 = 64. 3C0004h-3C0005h, Value.PIC18F05/15Q41 = 128. 3C0004h-3C0005h, Value.PIC18F06/16Q41 = 256. 3C0004h-3C0005h, Units. = Pages. 3C0006h-3C0007h, Name. = EESIZ. 3C0006h-3C0007h, Description. = Data EEPROM memory size. 3C0006h-3C0007h,",
    "9.3 Device Configuration Information\nValue.PIC18F04/14Q41 = 512. 3C0006h-3C0007h, Value.PIC18F05/15Q41 = 512. 3C0006h-3C0007h, Value.PIC18F06/16Q41 = 512. 3C0006h-3C0007h, Units. = Bytes. 3C0008h-3C0009h, Name. = PCNT. 3C0008h-3C0009h, Description. = Pin count. 3C0008h-3C0009h, Value.PIC18F04/14Q41 = 14/20. 3C0008h-3C0009h, Value.PIC18F05/15Q41 = 14/20. 3C0008h-3C0009h, Value.PIC18F06/16Q41 = 14/20. 3C0008h-3C0009h, Units. = Pins",
    "9.4 Data Memory Organization\nImportant: The operation of some aspects of data memory are changed when the PIC18 extended instruction set is enabled. See the PIC18 Instruction Execution and the Extended Instruction Set section for more information.\nThe data memory in PIC18 devices is implemented as static RAM. The memory space is divided into as many as 64 banks with 256 bytes each. The Data Memory Map table below shows the data memory organization for all devices in the device family.\nThe data memory contains Special Function Registers (SFRs) and General Purpose Registers (GPRs). The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratchpad operations in the user's application. Any read of an unimplemented location will read as ' 0 '.\nThe value in the Bank Select Register (BSR) determines which bank is being accessed. The instruction set and architecture allow operations across all banks. The entire data memory may be accessed by Direct, Indirect or Indexed Addressing modes. Addressing modes are discussed later in this subsection.",
    "9.4 Data Memory Organization\nTo ensure that commonly used registers (SFRs and select GPRs) can be accessed in a single cycle, PIC18 devices implement an Access Bank. This is a virtual 256-byte memory space that provides fast access to SFRs and the top half of GPR Bank 5 without using the Bank Select Register. The Access Bank section provides a detailed description of the Access RAM.\nFigure 9-3. Data Memory Map\n\u4261\n\u725b\n\u3a30\n\u2762\n\u3030\n\u2030\n\u4646\n\u2d30\n\u4253\n\u725b\n\u3a38\n\u746f\n\u3633\n\u2762\n\u3131\n\u2031\n\u3130\n\u3131\n\u3132\n\u3133\n\u3134\n\u3135\n\u3136\n\u3137\n\u3138\n\u3139\n\u3230\n\u3231\n\u3232\n\u3233\n\u3234\n\u3235\n\u3236\n\u3237\n\u3238\n\u3239\n\u3330\n\u3331\n\u3332\n\u3333\n\u3334\n\u3335\n\u3336\n\u3337\n\u3338\n\u2762\n\u3030\n\u2030\n\u2762\n\u3030\n\u2030\n\u3031\n\u2762\n\u3030\n\u2030\n\u3031\n\u2762\n\u3030\n\u2030\n\u3130\n\u2762\n\u3030\n\u2030\n\u3130\n\u2762\n\u3030\n\u2030\n\u3130\n\u2762\n\u3030\n\u2030\n\u3130\n\u2762\n\u3030\n\u2030\n\u3131\n\u2762\n\u3030\n\u2030\n\u3131\n\u2762\n\u3030\n\u2031\n\u2762\n\u3030\n\u2031\n\u2762\n\u3030\n\u2031\n\u3031\n\u2762\n\u3030\n\u2031\n\u3031\n\u2762\n\u3030\n\u2031\n\u3130\n\u2762\n\u3030\n\u2031\n\u3130\n\u2762\n\u3030\n\u2031\n\u3131\n\u2762\n\u3030\n\u2031\n\u3131\n\u2762\n\u3031\n\u2030\n\u3030\n\u2762\n\u3031\n\u2030\n\u3030\n\u2762\n\u3031\n\u2030\n\u2762\n\u3031\n\u2030\n\u2762\n\u3031\n\u2030\n\u3130\n\u2762\n\u3031\n\u2030\n\u3130\n\u2762\n\u3031\n\u2030\n\u3131\n\u2762\n\u3031\n\u2030\n\u3131\n\u2762\n\u3031\n\u2031\n\u3030\n\u2762\n\u3031\n\u2031\n\u3030\n\u2762\n\u3031\n\u2031\n\u2762\n\u3031\n\u2031\n\u2762\n\u3031\n\u2031\n\u3130\n\u2762\n\u3031\n\u2031\n\u3130\n\u2762\n\u3031\n\u2031\n\u3131\n\u2762",
    "9.4 Data Memory Organization\n\u3031\n\u2031\n\u3131\n\u2762\n\u3130\n\u2030\n\u3030\n\u2762\n\u3130\n\u2030\n\u3030\n\u2762\n\u3130\n\u2030\n\u3031\n\u2762\n\u3130\n\u2030\n\u3031\n\u2762\n\u3130\n\u2030\n\u2762\n\u3130\n\u2030\n\u2762\n\u3130\n\u2030\n\u3131\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u2d30\n\u5049\n\u4331\n\u5669\n\u4163\n\u2052\n\u414d\n\u2d30\n\u4661\n\u7420\n\u5346\n\u2d30\n\u4646\n\u5052\n\u7274\n\u2041\n\u2042\n\u556e\n\u7465\n\u4275\n\u6666\n\u7220\n\u5241\n\u5346",
    "9.4.1 Bank Select Register\nTo rapidly access the RAM space in PIC18 devices, the memory is split using the banking scheme. This divides the memory space into contiguous banks of 256 bytes each. Depending on the instruction, each location can be addressed directly by its full address or by an 8-bit low-order address and a bank pointer.\nMost instructions in the PIC18 instruction set make use of the bank pointer known as the Bank Select Register (BSR). This SFR holds the Most Significant bits of a location's address; the instruction itself includes the eight Least Significant bits. The BSR can be loaded directly by using the MOVLB instruction.\nThe value of the BSR indicates the bank in data memory being accessed; the eight bits in the instruction show the location in the bank and can be thought of as an offset from the bank's lower boundary. The relationship between the BSR's value and the bank division in data memory is shown in Figure 9-4.\nWhen writing the firmware in assembly, the user must ensure that the proper bank is selected before performing a data read or write. When using the C compiler to write the firmware, the BSR is tracked and maintained by the compiler.",
    "9.4.1 Bank Select Register\nWhile any bank can be selected, only those banks that are actually implemented can be read or written to. Writes to unimplemented banks are ignored, while reads from unimplemented banks will return ' 0 '. Refer to Figure 9-3 for a list of implemented banks.\nFigure 9-4. Use of the Bank Select Register (Direct Addressing)\nNote 1: The Access RAM bit of the instruction can be used to force an override of the selected bank (BSR value) to the registers of the Access Bank.",
    "9.4.2 Access Bank\nWhile the use of the BSR with an embedded 8-bit address allows users to address the entire range of data memory, it also means that the user must ensure that the correct bank is selected. Otherwise, data may be read from or written to the wrong location. Verifying and/or changing the BSR for each read or write to data memory can become inefficient.\nTo streamline access for the most commonly used data memory locations, the data memory is configured with a virtual Access Bank, which allows users to access a mapped block of memory\nwithout specifying a BSR. The Access Bank consists of the first 96 bytes of memory in Bank 5 ( 0500h-055Fh ) and the last 160 bytes of memory in Bank 4 ( 0460h-04FFh ). The upper half is known as the 'Access RAM' and is composed of GPRs. The lower half is where the device's SFRs are mapped. These two areas are mapped contiguously as the virtual Access Bank and can be addressed in a linear fashion by an 8-bit address (see the Data Memory Map section).",
    "9.4.2 Access Bank\nThe Access Bank is used by core PIC18 instructions that include the Access RAM bit (the 'a' parameter in the instruction). When 'a' is equal to ' 1 ', the instruction uses the BSR and the 8-bit address included in the opcode for the data memory address. When 'a' is ' 0 ', the instruction ignores the BSR and uses the Access Bank address map.\nUsing this 'forced' addressing allows the instruction to operate on a data address in a single cycle without updating the BSR first. Access RAM also allows for faster and more code efficient context saving and switching of variables.\nThe mapping of the Access Bank is slightly different when the extended instruction set is enabled (XINST Configuration bit = 1 ). This is discussed in more detail in the Mapping the Access Bank in Indexed Liberal Offset Mode section.",
    "9.5 Data Addressing Modes\nImportant: The execution of some instructions in the core PIC18 instruction set are changed when the PIC18 extended instruction set is enabled. See the Data Memory and the Extended Instruction Set section for more information.\nInformation in the data memory space can be addressed in several ways. For most instructions, the Addressing mode is fixed. Other instructions may use up to three modes, depending on which operands are used and whether or not the extended instruction set is enabled.\nThe Addressing modes are:\n\u00b7 Inherent\n\u00b7 Literal\n\u00b7 Direct\n\u00b7 Indirect\nAn additional Addressing mode, Indexed Literal Offset, is available when the extended instruction set is enabled (XINST Configuration bit = 1 ). Its operation is discussed in greater detail in the Indexed Addressing with Literal Offset section.",
    "9.5.1 Inherent and Literal Addressing\nMany PIC18 control instructions do not need any argument at all; they either perform an operation that globally affects the device or they operate implicitly on one register. This Addressing mode is known as Inherent Addressing. Examples include SLEEP RESET , and DAW .\nOther instructions work in a similar way but require an additional explicit argument in the opcode. This is known as Literal Addressing mode because they require some literal value as an argument. Examples include ADDLW and MOVLW , which, respectively, add or move a literal value to the W register. Other examples include CALL and GOTO , which include a program memory address.",
    "9.5.2 Direct Addressing\nDirect Addressing specifies all or part of the source and/or destination address of the operation within the opcode itself. The options are specified by the arguments accompanying the instruction.\nIn the core PIC18 instruction set, bit-oriented and byte-oriented instructions use some version of Direct Addressing by default. All of these instructions include some 8-bit literal address as their\nLeast Significant Byte. This address specifies either a register address in one of the banks of data RAM (see the Data Memory Organization section) or a location in the Access Bank (see the Access Bank section) as the data source for the instruction.\nThe Access RAM bit 'a' determines how the address is interpreted. When 'a' is ' 1 ', the contents of the BSR (see the Bank Select Register section) are used with the address to determine the complete 12-bit address of the register. When 'a' is ' 0 ', the address is interpreted as being a register in the Access Bank.",
    "9.5.2 Direct Addressing\nThe destination of the operation's results is determined by the destination bit 'd'. When 'd' is ' 1 ', the results are stored back in the source register, overwriting its original contents. When 'd' is ' 0 ', the results are stored in the W register. Instructions without the 'd' argument have a destination that is implicit in the instruction; their destination is either the target register being operated on or the W register.",
    "9.5.3 Indirect Addressing\nIndirect Addressing allows the user to access a location in data memory without giving a fixed address in the instruction. This is done by using File Select Registers (FSRs) as pointers to the locations which are to be read or written. Since the FSRs are themselves located in RAM as Special File Registers, they can also be directly manipulated under program control. This makes FSRs very useful in implementing data structures, such as tables and arrays in data memory.\nThe registers for Indirect Addressing are also implemented with Indirect File Operands (INDFs) that permit automatic manipulation of the pointer value with auto-incrementing, auto-decrementing or offsetting with another value. This allows for efficient code, using loops, such as the following example of clearing an entire RAM bank.",
    "9.5.3.1 FSR Registers and the INDF Operand\nAt the core of Indirect Addressing are three sets of registers: FSR0, FSR1 and FSR2. Each represent a pair of 8-bit registers, FSRnH and FSRnL. Each FSR pair holds the full address of the RAM location. The FSR value can address the entire range of the data memory in a linear fashion. The FSR register pairs, then, serve as pointers to data memory locations.\nIndirect Addressing is accomplished with a set of Indirect File Operands, INDF0 through INDF2. These can be thought of as 'virtual' registers; they are mapped in the SFR space but are not physically implemented. Reading or writing to a particular INDF register actually accesses its corresponding FSR register pair. A read from INDF1, for example, reads the data at the address indicated by FSR1H:FSR1L. Instructions that use the INDF registers as operands actually use the contents of their corresponding FSR as a pointer to the instruction's target. The INDF operand is just a convenient way of using the pointer.",
    "9.5.3.1 FSR Registers and the INDF Operand\nBecause Indirect Addressing uses a full address, the FSR value can target any location in any bank regardless of the BSR value. However, the Access RAM bit must be cleared to zero to ensure that the INDF register in Access space is the object of the operation instead of a register in one of the other banks. The assembler default value for the Access RAM bit is zero when targeting any of the indirect operands.",
    "9.5.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nIn addition to the INDF operand, each FSR register pair also has four additional indirect operands. Like INDF, these are 'virtual' registers that cannot be directly read or written. Accessing these registers actually accesses the location to which the associated FSR register pair points and also performs a specific action on the FSR value. They are:\n\u00b7 POSTDEC: Accesses the location to which the FSR points, then automatically decrements the FSR by 1 afterwards\n\u00b7 POSTINC: Accesses the location to which the FSR points, then automatically increments the FSR by 1 afterwards\n\u00b7 PREINC: Automatically increments the FSR by one, then uses the location to which the FSR points in the operation\n\u00b7 PLUSW: Adds the signed value of the W register (range of -127 to 128) to that of the FSR and uses the location to which the result points in the operation.",
    "9.5.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nIn this context, accessing an INDF register uses the value in the associated FSR register without changing it. Similarly, accessing a PLUSW register gives the FSR value an offset in the W register; however, neither W nor the FSR is actually changed in the operation. Accessing the other virtual registers changes the value of the FSR register.\nFigure 9-5. Indirect Addressing\nOperations on the FSRs with POSTDEC, POSTINC and PREINC affect the entire register pair; that is, rollovers of the FSRnL register from FFh to 00h carry over to the FSRnH register. On the other hand, results of these operations do not change the value of any flags in the STATUS register (e.g., Z, N, OV, etc.).",
    "9.5.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\n\uf0e3 The PLUSW register can be used to implement a form of Indexed Addressing in the data memory space. By manipulating the value in the W register, users can reach addresses that are fixed offsets from pointer addresses. In some applications, this can be used to implement some powerful program control structure, such as software stacks, inside of data memory.",
    "9.5.3.3 Operations by FSRs on FSRs\nIndirect Addressing operations that target other FSRs or virtual registers represent special cases. For example, using an FSR to point to one of the virtual registers will not result in successful operations. As a specific case, assume that FSR0H:FSR0L contains the address of INDF1. Attempts to read the value of the INDF1 using INDF0 as an operand will return 00h. Attempts to write to INDF1 using INDF0 as the operand will result in a NOP .\nOn the other hand, using the virtual registers to write to an FSR pair may not occur as planned. In these cases, the value will be written to the FSR pair but without any incrementing or decrementing. Thus, writing to either the INDF2 or POSTDEC2 register will write the same value to FSR2H:FSR2L.\nSince the FSRs are physical registers mapped in the SFR space, they can be manipulated through all direct operations. Users need to proceed cautiously when working on these registers, particularly if their code uses Indirect Addressing.",
    "9.5.3.3 Operations by FSRs on FSRs\nSimilarly, operations by Indirect Addressing are permitted on all other SFRs. Users need to exercise the appropriate caution that they do not inadvertently change settings that might affect the operation of the device.",
    "9.6 Data Memory and the Extended Instruction Set\nEnabling the PIC18 extended instruction set (XINST Configuration bit = 1 ) significantly changes certain aspects of data memory and its addressing. Specifically, the use of the Access Bank for many of the core PIC18 instructions is different; this is due to the introduction of a new Addressing mode for the data memory space.\nWhat does not change is just as important. The size of the data memory space is unchanged, as well as its linear addressing. The SFR map remains the same. Core PIC18 instructions can still operate in both Direct and Indirect Addressing mode; inherent and literal instructions do not change at all. Indirect addressing with FSR0 and FSR1 also remain unchanged.",
    "9.6.1 Indexed Addressing with Literal Offset\nEnabling the PIC18 extended instruction set changes the behavior of Indirect Addressing using the FSR2 register pair within Access RAM. Under the proper conditions, instructions that use the Access Bank - that is, most bit-oriented and byte-oriented instructions - can invoke a form of Indexed Addressing using an offset specified in the instruction. This special Addressing mode is known as Indexed Addressing with Literal Offset or Indexed Literal Offset mode.\nWhen using the extended instruction set, this Addressing mode requires the following:\n\u00b7 The use of the Access Bank is forced ('a' = 0 ) and\n\u00b7 The file address argument is less than or equal to 5Fh.\nUnder these conditions, the file address of the instruction is not interpreted as the lower byte of an address (used with the BSR in Direct Addressing) or as an 8-bit address in the Access Bank. Instead, the value is interpreted as an offset value to an Address Pointer, specified by FSR2. The offset and the contents of FSR2 are added to obtain the target address of the operation.",
    "9.6.2 Instructions Affected by Indexed Literal Offset Mode\nAny of the core PIC18 instructions that can use Direct Addressing are potentially affected by the Indexed Literal Offset Addressing mode. This includes all byte-oriented and bit-oriented instructions or almost one-half of the standard PIC18 instruction set. Instructions that only use Inherent or Literal Addressing modes are unaffected.\nAdditionally, byte-oriented and bit-oriented instructions are not affected if they do not use the Access Bank (Access RAM bit is ' 1 ') or include a file address of 60h or above. Instructions meeting these criteria will continue to execute as before. A comparison of the different possible Addressing modes when the extended instruction set is enabled is shown in the following figure.\nThose who desire to use byte-oriented or bit-oriented instructions in the Indexed Literal Offset mode need to note the changes to assembler syntax for this mode. This is described in more detail in the 'Extended Instruction Syntax' section.\nFigure 9-6. Comparing Addressing Options for Bit-Oriented and Byte-Oriented Instructions (Extended Instruction Set Enabled)\nEXAMPLE INSTRUCTION: ADDWF, f, d, a (Opcode: 0010 01da ffff ffff )",
    "9.6.2 Instructions Affected by Indexed Literal Offset Mode\nThe instruction executes in Direct Forced mode. 'f' is interpreted as a location in the Access RAM between 060h and 0FFh. This is the same as locations 460h to 4FFh (Bank4) of data memory. Locations below 60h are not available in this A ddressing mode. When 'a' = 0 and f \u2265 60h",
    "When 'a' = 0 and f \u2264 5 Fh\nThe instruction executes in Indexed Literal Offset mode. 'f' is interpreted as an offset to the address value in FSR2. The two are added together to obtain the address of the target register for the instruction. The address can be anywhere in the data memory space.\nNote that in this mode, the correct syntax is now:\nADDWF [k], d where 'k' is the same as 'f'.",
    "When 'a' = 1 (all values of f)\nThe instruction executes in Direct mode (also known as Direct Long mode). 'f' is interpreted as a location in one of the 63 banks of the data memory space. The bank is designated by the Bank Select Register (BSR) . The address can be in any implemented bank in the data memory space.",
    "9.6.3 Mapping the Access Bank in Indexed Literal Offset Mode\nThe use of Indexed Literal Offset Addressing mode effectively changes how the first 96 locations of Access RAM (00h to 5Fh) are mapped. Rather than containing just the contents of the top section of Bank 5, this mode maps the contents from a user defined 'window' that can be located anywhere in the data memory space. The value of FSR2 establishes the lower boundary of the addresses mapped into the window, while the upper boundary is defined by FSR2 plus 95 (5Fh). Addresses in the Access RAM above 5Fh are mapped as previously described (see the Access Bank section). An example of Access Bank remapping in this Addressing mode is shown in the following figure.",
    "EXAMPLE:\nADDWF, f, d, a FSR2H:FSR2L = 0x0A20\nLocations in the region from the FSR2 pointer (A20h) to the pointer plus 05Fh (A7Fh) are mapped to the Access RAM (000h-05Fh). Special File Registers at 460h through 4FFh are mapped to 60h through FFh, as usual. Bank 4 addresses below 5Fh can still be addressed by using the BSR.\nRemapping of the Access Bank applies only to operations using the Indexed Literal Offset mode. Operations that use the BSR (Access RAM bit is ' 1 ') will continue to use Direct Addressing as before.",
    "9.6.4 PIC18 Instruction Execution and the Extended Instruction Set\nEnabling the extended instruction set adds additional commands to the existing PIC18 instruction set. These instructions are executed as described in the 'Extended Instruction Set' section.",
    "9.7.1 PCL\nName:\nPCL 0x4F9\nAddress:\nLow byte of the Program Counter Register",
    "9.7.1 PCL\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PCL[7:0]. , 2 = PCL[7:0]. , 3 = PCL[7:0]. , 4 = PCL[7:0]. , 5 = PCL[7:0]. , 6 = PCL[7:0]. , 7 = PCL[7:0]. , 8 = PCL[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "9.7.1 PCL\nBits 7:0 - PCL[7:0] Provides direct read and write access to the Program Counter",
    "9.7.2 PCLAT\nName: Address:\nPCLAT 0x4FA\nProgram Counter Latches\nHolding register for bits [21:9] of the Program Counter (PC). Reads of the PCL register transfer the upper PC bits to the PCLAT register. Writes to PCL register transfer the PCLAT value to the PC.",
    "9.7.2 PCLAT\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12.PCLATU[4:0] = R/W. Access, 11.PCLATU[4:0] = R/W. Access, 10.PCLATU[4:0] = R/W. Access, 9.PCLATU[4:0] = R/W. Access, 8.PCLATU[4:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12.PCLATU[4:0] = 0. Reset, 11.PCLATU[4:0] = 0. Reset, 10.PCLATU[4:0] = 0. Reset, 9.PCLATU[4:0] = 0. Reset, 8.PCLATU[4:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12.PCLATU[4:0] = 4. Bit, 11.PCLATU[4:0] = 3. Bit,",
    "9.7.2 PCLAT\n10.PCLATU[4:0] = 2. Bit, 9.PCLATU[4:0] = 1. Bit, 8.PCLATU[4:0] = 0. , 15. = PCLATH[7:0]. , 14. = PCLATH[7:0]. , 13. = PCLATH[7:0]. , 12.PCLATU[4:0] = PCLATH[7:0]. , 11.PCLATU[4:0] = PCLATH[7:0]. , 10.PCLATU[4:0] = PCLATH[7:0]. , 9.PCLATU[4:0] = PCLATH[7:0]. , 8.PCLATU[4:0] = PCLATH[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12.PCLATU[4:0] = R/W. Access, 11.PCLATU[4:0] = R/W.",
    "9.7.2 PCLAT\nAccess, 10.PCLATU[4:0] = R/W. Access, 9.PCLATU[4:0] = R/W. Access, 8.PCLATU[4:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12.PCLATU[4:0] = 0. Reset, 11.PCLATU[4:0] = 0. Reset, 10.PCLATU[4:0] = 0. Reset, 9.PCLATU[4:0] = 0. Reset, 8.PCLATU[4:0] = 0\nBits 12:8 - PCLATU[4:0] Upper PC Latch Register Holding register for Program Counter [21:17]\nBits 7:0 - PCLATH[7:0] High PC Latch Register Holding register for Program Counter [16:8]",
    "9.7.3 TOS\nName: Address:\nTOS 0x4FD\nTop-of-Stack Register\nContents of the stack pointed to by the STKPTR register. This is the value that will be loaded into the Program Counter upon a RETURN or RETFIE instruction.",
    "9.7.3 TOS\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20.TOS[20:16] = R/W. Access, 19.TOS[20:16] = R/W. Access, 18.TOS[20:16] = R/W. Access, 17.TOS[20:16] = R/W. Access, 16.TOS[20:16] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20.TOS[20:16] = 0. Reset, 19.TOS[20:16] = 0. Reset, 18.TOS[20:16] = 0. Reset, 17.TOS[20:16] = 0. Reset, 16.TOS[20:16] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20.TOS[20:16] = 12. Bit, 19.TOS[20:16] = 11. Bit, 18.TOS[20:16] = 10.",
    "9.7.3 TOS\nBit, 17.TOS[20:16] = 9. Bit, 16.TOS[20:16] = 8. , 23. = TOS[15:8]. , 22. = TOS[15:8]. , 21. = TOS[15:8]. , 20.TOS[20:16] = TOS[15:8]. , 19.TOS[20:16] = TOS[15:8]. , 18.TOS[20:16] = TOS[15:8]. , 17.TOS[20:16] = TOS[15:8]. , 16.TOS[20:16] = TOS[15:8]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20.TOS[20:16] = R/W. Access, 19.TOS[20:16] = R/W. Access, 18.TOS[20:16] = R/W. Access, 17.TOS[20:16] =",
    "9.7.3 TOS\nR/W. Access, 16.TOS[20:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.TOS[20:16] = 0. Reset, 19.TOS[20:16] = 0. Reset, 18.TOS[20:16] = 0. Reset, 17.TOS[20:16] = 0. Reset, 16.TOS[20:16] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20.TOS[20:16] = 4. Bit, 19.TOS[20:16] = 3. Bit, 18.TOS[20:16] = 2. Bit, 17.TOS[20:16] = 1. Bit, 16.TOS[20:16] = 0. , 23. = TOS[7:0]. , 22. = TOS[7:0]. , 21. = TOS[7:0]. , 20.TOS[20:16] =",
    "9.7.3 TOS\nTOS[7:0]. , 19.TOS[20:16] = TOS[7:0]. , 18.TOS[20:16] = TOS[7:0]. , 17.TOS[20:16] = TOS[7:0]. , 16.TOS[20:16] = TOS[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20.TOS[20:16] = R/W. Access, 19.TOS[20:16] = R/W. Access, 18.TOS[20:16] = R/W. Access, 17.TOS[20:16] = R/W. Access, 16.TOS[20:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.TOS[20:16] = 0. Reset, 19.TOS[20:16] = 0. Reset,",
    "9.7.3 TOS\n18.TOS[20:16] = 0. Reset, 17.TOS[20:16] = 0. Reset, 16.TOS[20:16] = 0",
    "Bits 20:0 - TOS[20:0] Top-of-Stack\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 TOSU: Accesses the upper byte TOS[20:16]\n\u00b7 TOSH: Accesses the high byte TOS[15:8]\n\u00b7 TOSL: Accesses the low byte TOS[7:0]",
    "9.7.4 STKPTR\nName: Address:\nSTKPTR\n0x4FC\nStack Pointer Register\nBit, 1 = 6. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = STKPTR[6:0]. , 2 = STKPTR[6:0]. , 3 = STKPTR[6:0]. , 4 = STKPTR[6:0]. , 5 = STKPTR[6:0]. , 6 = STKPTR[6:0]. , 7 = STKPTR[6:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "9.7.4 STKPTR\nBits 6:0 - STKPTR[6:0] Stack Pointer Location",
    "9.7.5 WREG\nName:\nWREG\nAddress:\n0x4E8\nWorking Data Register",
    "9.7.5 WREG\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WREG[7:0]. , 2 = WREG[7:0]. , 3 = WREG[7:0]. , 4 = WREG[7:0]. , 5 = WREG[7:0]. , 6 = WREG[7:0]. , 7 = WREG[7:0]. , 8 = WREG[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 7:0 - WREG[7:0]\nDS40002242F - 78",
    "9.7.6 INDF\nName:\nINDFx 0x4EF,0x4E7,0x4DF\nAddress:\nIndirect Data Register\nThis is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the INDFx register.",
    "9.7.6 INDF\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INDF[7:0]. , 2 = INDF[7:0]. , 3 = INDF[7:0]. , 4 = INDF[7:0]. , 5 = INDF[7:0]. , 6 = INDF[7:0]. , 7 = INDF[7:0]. , 8 = INDF[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "9.7.6 INDF\nBits 7:0 - INDF[7:0] Indirect data pointed to by the FSRx register",
    "9.7.7 POSTDEC\nName:\nPOSTDECx 0x4ED,0x4E5,0x4DD\nAddress:\nIndirect Data Register with post decrement\nThis is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the POSTDECx register. FSRx is decrememted after the read or write operation.",
    "9.7.7 POSTDEC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POSTDEC[7:0]. , 2 = POSTDEC[7:0]. , 3 = POSTDEC[7:0]. , 4 = POSTDEC[7:0]. , 5 = POSTDEC[7:0]. , 6 = POSTDEC[7:0]. , 7 = POSTDEC[7:0]. , 8 = POSTDEC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "9.7.7 POSTDEC\n0. Reset, 8 = 0",
    "9.7.8 POSTINC\nName:\nPOSTINCx 0x4EE,0x4E6,0x4DE\nAddress:\nIndirect Data Register with post increment\nThis is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the POSTINCx register. FSRx is incremented after the read or write operation.",
    "9.7.8 POSTINC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POSTINC[7:0]. , 2 = POSTINC[7:0]. , 3 = POSTINC[7:0]. , 4 = POSTINC[7:0]. , 5 = POSTINC[7:0]. , 6 = POSTINC[7:0]. , 7 = POSTINC[7:0]. , 8 = POSTINC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "9.7.8 POSTINC\n0. Reset, 8 = 0",
    "9.7.9 PREINC\nName:\nPREINCx 0x4EC,0x4E4,0x4DC\nAddress:\nIndirect Data Register with pre-increment\nThis is a virtual register. The GPR/SFR register addressed by the FSRx register plus 1 is the target for all operations involving the PREINCx register. FSRx is incremented before the read or write operation.",
    "9.7.9 PREINC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PREINC[7:0]. , 2 = PREINC[7:0]. , 3 = PREINC[7:0]. , 4 = PREINC[7:0]. , 5 = PREINC[7:0]. , 6 = PREINC[7:0]. , 7 = PREINC[7:0]. , 8 = PREINC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "9.7.9 PREINC\n0. Reset, 8 = 0",
    "9.7.10 PLUSW\nName:\nPLUSWx 0x4EB,0x4E3,0x4DB\nAddress:\nIndirect Data Register with WREG offset\nThis is a virtual register. The GPR/SFR register addressed by the sum of the FSRx register plus the signed value of the W register is the target for all operations involving the PLUSWx register.",
    "9.7.10 PLUSW\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PLUSW[7:0]. , 2 = PLUSW[7:0]. , 3 = PLUSW[7:0]. , 4 = PLUSW[7:0]. , 5 = PLUSW[7:0]. , 6 = PLUSW[7:0]. , 7 = PLUSW[7:0]. , 8 = PLUSW[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "9.7.11 FSR\nName:\nFSRx 0x4E9,0x4E1,0x4D9\nAddress:\nIndirect Address Register\nThe FSR value is the address of the data to which the INDF register points.",
    "9.7.11 FSR\nAccess, 15. = . Access, 14. = . Access, 13.FSRH[5:0] = R/W. Access, 12.FSRH[5:0] = R/W. Access, 11.FSRH[5:0] = R/W. Access, 10.FSRH[5:0] = R/W. Access, 9.FSRH[5:0] = R/W. Access, 8.FSRH[5:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13.FSRH[5:0] = 0. Reset, 12.FSRH[5:0] = 0. Reset, 11.FSRH[5:0] = 0. Reset, 10.FSRH[5:0] = 0. Reset, 9.FSRH[5:0] = 0. Reset, 8.FSRH[5:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13.FSRH[5:0] = 5. Bit,",
    "9.7.11 FSR\n12.FSRH[5:0] = 4. Bit, 11.FSRH[5:0] = 3. Bit, 10.FSRH[5:0] = 2. Bit, 9.FSRH[5:0] = 1. Bit, 8.FSRH[5:0] = 0. , 15. = FSRL[7:0]. , 14. = FSRL[7:0]. , 13.FSRH[5:0] = FSRL[7:0]. , 12.FSRH[5:0] = FSRL[7:0]. , 11.FSRH[5:0] = FSRL[7:0]. , 10.FSRH[5:0] = FSRL[7:0]. , 9.FSRH[5:0] = FSRL[7:0]. , 8.FSRH[5:0] = FSRL[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access,",
    "9.7.11 FSR\n13.FSRH[5:0] = R/W. Access, 12.FSRH[5:0] = R/W. Access, 11.FSRH[5:0] = R/W. Access, 10.FSRH[5:0] = R/W. Access, 9.FSRH[5:0] = R/W. Access, 8.FSRH[5:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13.FSRH[5:0] = 0. Reset, 12.FSRH[5:0] = 0. Reset, 11.FSRH[5:0] = 0. Reset, 10.FSRH[5:0] = 0. Reset, 9.FSRH[5:0] = 0. Reset, 8.FSRH[5:0] = 0\nBits 13:8 - FSRH[5:0] Most Significant address of INDF data\nBits 7:0 - FSRL[7:0] Least Significant address of INDF data",
    "9.7.12 BSR\nName: Address:\nBSR\n0x4E0\nBank Select Register\nThe BSR indicates the data memory bank of the GPR address.\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = BSR[5:0]. , 3 = BSR[5:0]. , 4 = BSR[5:0]. , 5 = BSR[5:0]. , 6 = BSR[5:0]. , 7 = BSR[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "9.7.12 BSR\nBits 5:0 - BSR[5:0] Most Significant bits of the data memory address",
    "9.8 Register Summary - Memory Organization\n0x00 ... 0x04D8, Name = Reserved. 0x00 ... 0x04D8, Bit Pos. = . 0x00 ... 0x04D8, 7 = . 0x00 ... 0x04D8, 6 = . 0x00 ... 0x04D8, 5 = . 0x00 ... 0x04D8, 4 = . 0x00 ... 0x04D8, 3 = . 0x00 ... 0x04D8, 2 = . 0x00 ... 0x04D8, 1 = . 0x00 ... 0x04D8, 0 = . 0x04D9, Name = FSR2. 0x04D9, Bit Pos. = 7:0. 0x04D9, 7 = . 0x04D9, 6 = . 0x04D9, 5 = . 0x04D9, 4 = FSRL[7:0]. 0x04D9,",
    "9.8 Register Summary - Memory Organization\n3 = . 0x04D9, 2 = . 0x04D9, 1 = . 0x04D9, 0 = . 0x04D9, Name = FSR2. 0x04D9, Bit Pos. = 15:8. 0x04D9, 7 = . 0x04D9, 6 = . 0x04D9, 5 = . 0x04D9, 4 = . 0x04D9, 3 = FSRH[5:0]. 0x04D9, 2 = . 0x04D9, 1 = . 0x04D9, 0 = . 0x04DB, Name = PLUSW2. 0x04DB, Bit Pos. = 7:0. 0x04DB, 7 = . 0x04DB, 6 = . 0x04DB, 5 = . 0x04DB, 4 = PLUSW[7:0]. 0x04DB, 3 = . 0x04DB, 2 = . 0x04DB, 1 = .",
    "9.8 Register Summary - Memory Organization\n0x04DB, 0 = . 0x04DC, Name = PREINC2. 0x04DC, Bit Pos. = 7:0. 0x04DC, 7 = . 0x04DC, 6 = . 0x04DC, 5 = . 0x04DC, 4 = PREINC[7:0]. 0x04DC, 3 = . 0x04DC, 2 = . 0x04DC, 1 = . 0x04DC, 0 = . 0x04DD, Name = POSTDEC2. 0x04DD, Bit Pos. = 7:0. 0x04DD, 7 = . 0x04DD, 6 = . 0x04DD, 5 = . 0x04DD, 4 = POSTDEC[7:0]. 0x04DD, 3 = . 0x04DD, 2 = . 0x04DD, 1 = . 0x04DD, 0 = . 0x04DE, Name = POSTINC2. 0x04DE, Bit Pos.",
    "9.8 Register Summary - Memory Organization\n= 7:0. 0x04DE, 7 = . 0x04DE, 6 = . 0x04DE, 5 = . 0x04DE, 4 = POSTINC[7:0]. 0x04DE, 3 = . 0x04DE, 2 = . 0x04DE, 1 = . 0x04DE, 0 = . 0x04DF, Name = INDF2. 0x04DF, Bit Pos. = 7:0. 0x04DF, 7 = . 0x04DF, 6 = . 0x04DF, 5 = . 0x04DF, 4 = INDF[7:0]. 0x04DF, 3 = . 0x04DF, 2 = . 0x04DF, 1 = . 0x04DF, 0 = . 0x04E0, Name = BSR. 0x04E0, Bit Pos. = 7:0. 0x04E0, 7 = . 0x04E0, 6 = . 0x04E0, 5 =",
    "9.8 Register Summary - Memory Organization\n. 0x04E0, 4 = . 0x04E0, 3 = BSR[5:0]. 0x04E0, 2 = . 0x04E0, 1 = . 0x04E0, 0 = . 0x04E1, Name = FSR1. 0x04E1, Bit Pos. = 7:0. 0x04E1, 7 = . 0x04E1, 6 = . 0x04E1, 5 = . 0x04E1, 4 = FSRL[7:0]. 0x04E1, 3 = . 0x04E1, 2 = . 0x04E1, 1 = . 0x04E1, 0 = . 0x04E1, Name = FSR1. 0x04E1, Bit Pos. = 15:8. 0x04E1, 7 = . 0x04E1, 6 = . 0x04E1, 5 = . 0x04E1, 4 = .",
    "9.8 Register Summary - Memory Organization\n0x04E1, 3 = FSRH[5:0]. 0x04E1, 2 = . 0x04E1, 1 = . 0x04E1, 0 = . 0x04E3, Name = PLUSW1. 0x04E3, Bit Pos. = 7:0. 0x04E3, 7 = . 0x04E3, 6 = . 0x04E3, 5 = . 0x04E3, 4 = PLUSW[7:0]. 0x04E3, 3 = . 0x04E3, 2 = . 0x04E3, 1 = . 0x04E3, 0 = . 0x04E4, Name = PREINC1. 0x04E4, Bit Pos. = 7:0. 0x04E4, 7 = . 0x04E4, 6 = . 0x04E4, 5 = . 0x04E4, 4 = PREINC[7:0].",
    "9.8 Register Summary - Memory Organization\n0x04E4, 3 = . 0x04E4, 2 = . 0x04E4, 1 = . 0x04E4, 0 = . 0x04E5, Name = POSTDEC1. 0x04E5, Bit Pos. = 7:0. 0x04E5, 7 = . 0x04E5, 6 = . 0x04E5, 5 = . 0x04E5, 4 = POSTDEC[7:0]. 0x04E5, 3 = . 0x04E5, 2 = . 0x04E5, 1 = . 0x04E5, 0 = . 0x04E6, Name = POSTINC1. 0x04E6, Bit Pos. = 7:0. 0x04E6, 7 = . 0x04E6, 6 = . 0x04E6, 5 = . 0x04E6, 4 = POSTINC[7:0]. 0x04E6, 3 = .",
    "9.8 Register Summary - Memory Organization\n0x04E6, 2 = . 0x04E6, 1 = . 0x04E6, 0 = . 0x04E7, Name = INDF1. 0x04E7, Bit Pos. = 7:0. 0x04E7, 7 = . 0x04E7, 6 = . 0x04E7, 5 = . 0x04E7, 4 = INDF[7:0]. 0x04E7, 3 = . 0x04E7, 2 = . 0x04E7, 1 = . 0x04E7, 0 = . 0x04E8, Name = WREG. 0x04E8, Bit Pos. = 7:0. 0x04E8, 7 = . 0x04E8, 6 = . 0x04E8, 5 = . 0x04E8, 4 = WREG[7:0]. 0x04E8, 3 = . 0x04E8, 2 = . 0x04E8,",
    "9.8 Register Summary - Memory Organization\n1 = . 0x04E8, 0 = . 0x04E9, Name = FSR0. 0x04E9, Bit Pos. = 7:0. 0x04E9, 7 = . 0x04E9, 6 = . 0x04E9, 5 = . 0x04E9, 4 = FSRL[7:0]. 0x04E9, 3 = . 0x04E9, 2 = . 0x04E9, 1 = . 0x04E9, 0 = . 0x04E9, Name = FSR0. 0x04E9, Bit Pos. = 15:8. 0x04E9, 7 = . 0x04E9, 6 = . 0x04E9, 5 = . 0x04E9, 4 = . 0x04E9, 3 = FSRH[5:0]. 0x04E9, 2 = . 0x04E9, 1 = . 0x04E9, 0 = .",
    "9.8 Register Summary - Memory Organization\n0x04EB, Name = PLUSW0. 0x04EB, Bit Pos. = 7:0. 0x04EB, 7 = . 0x04EB, 6 = . 0x04EB, 5 = . 0x04EB, 4 = PLUSW[7:0]. 0x04EB, 3 = . 0x04EB, 2 = . 0x04EB, 1 = . 0x04EB, 0 = . 0x04EC, Name = PREINC0. 0x04EC, Bit Pos. = 7:0. 0x04EC, 7 = . 0x04EC, 6 = . 0x04EC, 5 = . 0x04EC, 4 = PREINC[7:0]. 0x04EC, 3 = . 0x04EC, 2 = . 0x04EC, 1 = . 0x04EC, 0 = . 0x04ED, Name = POSTDEC0. 0x04ED, Bit Pos. = 7:0. 0x04ED,",
    "9.8 Register Summary - Memory Organization\n7 = . 0x04ED, 6 = . 0x04ED, 5 = . 0x04ED, 4 = POSTDEC[7:0]. 0x04ED, 3 = . 0x04ED, 2 = . 0x04ED, 1 = . 0x04ED, 0 = . 0x04EE, Name = POSTINC0. 0x04EE, Bit Pos. = 7:0. 0x04EE, 7 = . 0x04EE, 6 = . 0x04EE, 5 = . 0x04EE, 4 = POSTINC[7:0]. 0x04EE, 3 = . 0x04EE, 2 = . 0x04EE, 1 = . 0x04EE, 0 = . 0x04EF, Name = INDF0. 0x04EF, Bit Pos. = 7:0. 0x04EF, 7 = . 0x04EF, 6 = . 0x04EF, 5 = . 0x04EF, 4 =",
    "9.8 Register Summary - Memory Organization\nINDF[7:0]. 0x04EF, 3 = . 0x04EF, 2 = . 0x04EF, 1 = . 0x04EF, 0 = . ... 0x04F8, Name = Reserved. ... 0x04F8, Bit Pos. = . ... 0x04F8, 7 = . ... 0x04F8, 6 = . ... 0x04F8, 5 = . ... 0x04F8, 4 = . ... 0x04F8, 3 = . ... 0x04F8, 2 = . ... 0x04F8, 1 = . ... 0x04F8, 0 = . 0x04F9, Name = PCL. 0x04F9, Bit Pos. = 7:0. 0x04F9, 7 = . 0x04F9, 6 = . 0x04F9, 5 = . 0x04F9, 4 =",
    "9.8 Register Summary - Memory Organization\nPCL[7:0]. 0x04F9, 3 = . 0x04F9, 2 = . 0x04F9, 1 = . 0x04F9, 0 = . 0x04FA, Name = . 0x04FA, Bit Pos. = 7:0. 0x04FA, 7 = . 0x04FA, 6 = . 0x04FA, 5 = . 0x04FA, 4 = PCLATH[7:0]. 0x04FA, 3 = . 0x04FA, 2 = . 0x04FA, 1 = . 0x04FA, 0 = . , Name = PCLAT. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = PCLATU[4:0]. , 2 = . , 1 = . , 0 = . 0x04FC, Name = STKPTR. 0x04FC, Bit Pos. = 7:0. 0x04FC, 7 = .",
    "9.8 Register Summary - Memory Organization\n0x04FC, 6 = . 0x04FC, 5 = . 0x04FC, 4 = STKPTR[6:0]. 0x04FC, 3 = . 0x04FC, 2 = . 0x04FC, 1 = . 0x04FC, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = TOS[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x04FD, Name = TOS. 0x04FD, Bit Pos. = 15:8. 0x04FD, 7 = . 0x04FD, 6 = . 0x04FD, 5 = . 0x04FD, 4 = TOS[15:8]. 0x04FD, 3 = . 0x04FD, 2 = . 0x04FD, 1 = . 0x04FD, 0 = . , Name = . , Bit",
    "9.8 Register Summary - Memory Organization\nPos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = TOS[20:16]. , 2 = . , 1 = . , 0 = ",
    "10. NVM - Nonvolatile Memory Module\nThe Nonvolatile Memory (NVM) module provides run-time read and write access to the Program Flash Memory (PFM), Data Flash Memory (DFM) and Configuration bits. PFM includes the program memory and user ID space. DFM is also referred to as EEPROM which is accessed one byte at a time and the erase before write is automatic.\nThe Table Pointer provides read-only access to the PFM, DFM and Configuration bits. The NVM controls provide both read and write access to PFM, DFM and Configuration bits.\nReads and writes to and from the DFM are limited to single byte operations, whereas those for PFM are 16-bit word or 128-word page operations. The page buffer memory occupies one full bank of RAM space located in the RAM bank following the last occupied GPR bank. Refer to the 'Memory Organization' chapter for more details about the buffer RAM.\nThe registers used for control, address and data are as follows:",
    "10. NVM - Nonvolatile Memory Module\n\u00b7 NVMCON0 - Operation start and active status\n\u00b7 NVMCON1 - Operation type and error status\n\u00b7 NVMLOCK - Write-only register to guard against accidental writes\n\u00b7 NVMADR - Read/write target address (multibyte register)\n\u00b7 NVMDAT - Read/write target data (multibyte register)\n\u00b7 TBLPTR - Table Pointer PFM target address for reads and buffer RAM address for writes (multibyte register)\n\u00b7 TABLAT - Table Pointer read/write target data (single byte register)\nThe write and erase times are controlled by an on-chip timer. The write and erase voltages are generated by an on-chip charge pump rated to function over the operating voltage range of the device.",
    "10. NVM - Nonvolatile Memory Module\nPFM and DFM can be protected in two ways: code protection and write protection. Code protection (Configuration bit CP) disables read and write access through an external device programmer. Write protection prevents user software writes to NVM areas tagged for protection by the WRTn Configuration bits. Code protection does not affect the self-write and erase functionality, whereas write protection does. Attempts to write a protected location will set the WRERR bit. Code protection and write protection can only be reset on a Bulk Erase performed by an external programmer.\nThe Bulk Erase command is used to completely erase different memory regions. The area to be erased is selected using a bit field combination. The Bulk Erase command can only be issued through an external programmer. There is no run time access for this command.\nIf the device is code-protected and a Bulk Erase command for the configuration memory is issued, all other memory regions are also erased. Refer to the appropriate Family Programming Specification for more details.",
    "10.1 Operations\nNVM write operations are controlled by selecting the desired action with the NVMCMD bits and then starting the operation by executing the unlock sequence. NVM read operations are started by setting the GO bit after setting the read operation. Available NVM operations are shown in the following table.",
    "Table 10-1. NVM Operations\n000, Unlock = No. 000, Operation = Read. 000, DFM = byte. 000, PFM = word. 000, Source/Destination = NVM to NVMDAT. 000, WRERR = No. 000, INT = No. 001, Unlock = No. 001, Operation = Read and Post Increment. 001, DFM = byte. 001, PFM = word. 001, Source/Destination = NVM to NVMDAT. 001, WRERR = No. 001, INT = No",
    "Table 10-1. NVM Operations\n010, ...........continued.Unlock = No. 010, Operation = Read Page. 010, DFM = -. 010, PFM = page. 010, Source/Destination = NVM to Buffer RAM. 010, WRERR = No. 010, INT = No. 011, ...........continued.Unlock = Yes. 011, Operation = Write. 011, DFM = byte. 011, PFM = word. 011, Source/Destination = NVMDAT to NVM. 011, WRERR = Yes. 011, INT = Yes. 100, ...........continued.Unlock = Yes. 100, Operation = Write and Post Increment. 100, DFM = byte. 100, PFM = word. 100, Source/Destination = NVMDAT to NVM. 100, WRERR = Yes. 100, INT = Yes. 101, ...........continued.Unlock = Yes. 101, Operation = Write",
    "Table 10-1. NVM Operations\nPage. 101, DFM = -. 101, PFM = page. 101, Source/Destination = Buffer RAM to NVM. 101, WRERR = Yes. 101, INT = Yes. 110, ...........continued.Unlock = Yes. 110, Operation = Erase Page. 110, DFM = -. 110, PFM = page. 110, Source/Destination = n/a. 110, WRERR = Yes. 110, INT = Yes. 111, ...........continued.Unlock = No. 111, Operation = Reserved (No Operation). 111, DFM = -. 111, PFM = -. 111, Source/Destination = -. 111, WRERR = No. 111, INT = No\nImportant: When the GO bit is set, writes operations are blocked on all NVM registers. The GO bit is cleared by hardware when the operation is complete. The GO bit cannot be cleared by software.",
    "10.2 Unlock Sequence\nAs an additional layer of protection against memory corruption, a specific code execution unlock sequence is required to initiate a write or erase operation. All interrupts need to be disabled before starting the unlock sequence to ensure proper execution.\n```\nExample 10-1. Unlock Sequence in C NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1;\n```",
    "10.3 Program Flash Memory (PFM)\nThe Program Flash Memory is readable, writable and erasable over the entire VDD range.\nA 128-word PFM page is the only size that can be erased by user software. A Bulk Erase operation cannot be issued from user code. A read from program memory is executed either one byte, one word or a 128-word page at a time. A write to program memory can be executed as either 1 or 128 words at a time.\nWriting or erasing program memory will cease instruction fetches until the operation is complete. The program memory cannot be accessed during the write or erase, so code cannot execute. An internal programming timer controls the write time of program memory writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing a program memory location that forms an invalid instruction results in a NOP .\nIt is important to understand the PFM memory structure for erase and programming operations. Program memory word size is 16 bits wide.",
    "10.3 Program Flash Memory (PFM)\nAfter a page has been erased, all or a portion of this page can be programmed. Data can be written directly into PFM one 16-bit word at a time using the NVMADR, NVMDAT and NVMCON1 controls or as a full page from the buffer RAM. The buffer RAM is directly accessible as any other SFR/GPR register and also may be loaded via sequential writes using the TABLAT and TBLPTR registers.\nImportant: To modify only a portion of a previously programmed page, the contents of the entire page must be read and saved in the buffer RAM prior to the page erase. The Read Page operation is the easiest way to do this. The page needs to be erased so that the new data can be written into the buffer RAM to reprogram the page of PFM. However, any unprogrammed locations can be written using the single word Write operation without first erasing the page.",
    "10.3.1 Page Erase\nThe erase size is always 128 words. Only through the use of an external programmer can larger areas of program memory be Bulk Erased. Word erase in the program memory is not supported.\nWhen initiating an erase sequence from user code, a page of 128 words of program memory is erased. The NVMADR[21:8] bits point to the page being erased. The NVMADR[7:0] bits are ignored. The NVMCON0 and NVMCON1 registers command the erase operation. The NVMCMD bits are set to select the erase operation. The GO bit is set to initiate the erase operation as the last step in the unlock sequence.\nThe NVM unlock sequence described in the Unlock Sequence section must be used; this guards against accidental writes. Instruction execution is halted during the erase cycle. The erase cycle is terminated by the internal programming timer.\nThe sequence of events for erasing a page of PFM is:",
    "10.3.1 Page Erase\n1. Set the NVMADR registers to an address within the intended page.\n2. Set the NVMCMD control bits to 'b110 (Page Erase).\n3. Disable all interrupts.\n4. Perform the unlock sequence as described in the Unlock Sequence section.\n5. Set the GO bit to start the PFM page erase.\n6. Monitor the GO bit or NVMIF interrupt flag to determine when the erase has completed.\n7. Interrupts can be enabled after the GO bit is clear.\n8. Set the NVMCMD control bits to 'b000 .\nIf the PFM address is write-protected, the GO bit will be cleared, the erase operation will not take place, and the WRERR bit will be set.\nWhile erasing the PFM page, the CPU operation is suspended and then resumes when the operation is complete. Upon erase completion, the GO bit is cleared in hardware, the NVMIF is set, and an interrupt will occur (if the NVMIE bit is set and interrupts are enabled).\nThe buffer RAM data are not affected by erase operations and the NVMCMD bits will remain unchanged throughout the erase opeation.",
    "Example 10-2. Erasing a Page of Program Flash Memory in C\n```",
    "Example 10-2. Erasing a Page of Program Flash Memory in C\n// Code sequence to erase one page of PFM // PFM target address is specified by PAGE_ADDR // Save interrupt enable bit value uint8_t GIEBitValue = INTCON0bits.GIE; // Load NVMADR with the base address of the memory page NVMADR = PAGE_ADDR; NVMCON1bits.CMD = 0x06; // Set the page erase command INTCON0bits.GIE = 0; // Disable interrupts //--------- Required Unlock Sequence --------NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; // Start page erase //---------------------------------------------while (NVMCON0bits.GO); // Wait for the erase operation to",
    "Example 10-2. Erasing a Page of Program Flash Memory in C\ncomplete // Verify erase operation success and call the recovery function if needed if (NVMCON1bits.WRERR){ ERASE_FAULT_RECOVERY(); } INTCON0bits.GIE = GIEBitValue; // Restore interrupt enable bit value NVMCON1bits.CMD = 0x00; // Disable writes to memory\n```",
    "Important:\n\u00b7 If a write or erase operation is terminated by an unexpected Reset, the WRERR bit will be set and the user can check to decide whether a rewrite of the location(s) is needed.\n\u00b7 If a write or erase operation is attempted on a write-protected area, the WRERR bit will be set.\n\u00b7 If a write or erase operation is attempted on an invalid address location, the WRERR bit is set (refer to the Program and Data Memory Map in the 'Memory Organization' chapter for more information on valid address locations).",
    "10.3.2 Page Read\nPFM can be read one word or 128-word page at a time. A page is read by setting the NVMADR registers to an address within the target page and setting the NVMCMD bits to 'b010 . The page content is then transferred from PFM to the buffer RAM by starting the read operation by setting the GO bit.\nThe sequence of events for reading a 128-word page of PFM is:\n1. Set the NVMADR registers to an address within the intended page.\n2. Set the NVMCMD control bits to 'b010 (Page Read).\n3. Set the GO bit to start the PFM page read.\n4. Monitor the GO bit or NVMIF interrupt flag to determine when the read has completed.",
    "10.3.3 Word Read\nA single 16-bit word is read by setting the NVMADR registers to the target address and setting the NVMCMD bits to 'b000 . The word is then transferred from PFM to the NVMDAT registers by starting the read operation by setting the GO bit.\nThe sequence of events for reading a word of PFM is:\n1. Set the NVMADR registers to the target address.\n2. Set the NVMCMD control bits to 'b000 (Word Read).\n3. Set the GO bit to start the PFM word read.\n4. Monitor the GO bit or NVMIF interrupt flag to determine when the read has completed.",
    "10.3.4 Page Write\nA page is written by first loading the buffer registers in the buffer RAM. All buffer registers are then written to PFM by setting the NVMADR to an address within the intended address range of the target PFM page, setting the NVMCMD bits to 'b101 , and then executing the unlock sequence and setting the GO bit.\nIf the PFM address in the NVMADR is write-protected, or if NVMADR points to an invalid location, the GO bit is cleared without any effect, and the WRERR bit is set.\nCPU operation is suspended during a page write cycle and resumes when the operation is complete. The page write operation completes in one extended instruction cycle. When complete, the GO bit is cleared by hardware and NVMIF is set. An interrupt will occur if NVMIE is also set. The buffer registers and NVMCMD bits are not changed throughout the write operation.\nThe internal programming timer controls the write time. The write/erase voltages are generated by an on-chip charge pump and rated to operate over the voltage range of the device.",
    "10.3.4 Page Write\nImportant: Individual bytes of program memory may be modified, provided that the modification does not attempt to change any NVM bit from a ' 0 ' to a ' 1 '. When modifying individual bytes with a page write operation, it is necessary to load all buffer registers with either 0xFF or the existing contents of memory before executing a page write operation. The fastest way to do this is by performing a page read operation.\nIn this device a PFM page is 128 words (256 bytes). This is the same size as one bank of general purpose RAM (GPR). This area of GPR space is dedicated as a buffer area for NVM page operations. The buffer areas for each device in the family are shown in the following table:\nTable 10-2. NVM Buffer Banks\n\nPIC18Fx6Q41, GPR Bank Number = 21. PIC18Fx5Q41, GPR Bank Number = 13. PIC18Fx4Q41, GPR Bank Number = 9\nThere are several ways to address the data in the GPR buffer space:",
    "10.3.4 Page Write\n\u00b7 Using the TBLRD and TBLWT instructions\n\u00b7 Using the indirect FSR registers\n\u00b7 Direct read and writes to specific GPR locations\nNeglecting the bank select bits, the 8 address bits of the GPR buffer space correspond to the 8 LSbs of each PFM page. In other words, there is a one-to-one correspondence between the NVMADRL register and the FSRxL register, where the x in FSRx is 0, 1 or 2.\nThe sequence of events for programming a page of PFM is:\n1. Set the NVMADR registers to an address within the intended page.\n2. Set the NVMCMD to 'b110 (Erase Page).",
    "10.3.4 Page Write\n3. Disable all interrupts.\n4. Perform the unlock sequence as described in the Unlock Sequence section.\n5. Set the GO bit to start the PFM page erase.\n6. Monitor the GO bit or NVMIF interrupt flag to determine when the erase has completed.\n7. Set NVMCMD to 'b101 (Page Write).\n8. Perform the unlock sequence.\n9. Set the GO bit to start the PFM page write.\n10. Monitor the GO bit or NVMIF interrupt flag to determine when the write has completed.\n11. Interrupts can be enabled after the GO bit is clear.\n12. Set the NVMCMD control bits to 'b000 .\n```",
    "10.3.4 Page Write\nExample 10-5. Writing a Page of Program Flash Memory in C // Code sequence to write a page of PFM // Input[] is the user data that needs to be written to PFM // PFM target address is specified by PAGE_ADDR #define PAGESIZE 128 // PFM page size // Save Interrupt Enable bit Value uint8_t GIEBitValue = INTCON0bits.GIE; // The BufferRAMStartAddr will be changed based on the device, refer // to the \"Memory Organization\" chapter for more details uint16_t bufferRAM __at (BufferRAMStartAddr); // Defining a pointer to the first location of the Buffer RAM uint16_t *bufferRamPtr = (uint16_t*) & bufferRAM; //Copy application buffer contents to the Buffer RAM for (uint8_t i = 0; i < PAGESIZE; i++) { *bufferRamPtr++ = Input[i]; } // Load NVMADR with the base address of the memory page NVMADR = PAGE_ADDR;",
    "10.3.4 Page Write\nNVMCON1bits.CMD = 0x06; // Set the page erase command INTCON0bits.GIE = 0; // Disable interrupts //--------- Required Unlock Sequence --------NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; // Start page erase //---------------------------------------------while (NVMCON0bits.GO); // Wait for the erase operation to complete // Verify erase operation success and call the recovery function if needed if (NVMCON1bits.WRERR){ ERASE_FAULT_RECOVERY(); } // NVMADR is already pointing to target page NVMCON1bits.CMD = 0x05; // Set the page write command //---------",
    "10.3.4 Page Write\nRequired Unlock Sequence --------NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; // Start page write //---------------------------------------------while (NVMCON0bits.GO); // Wait for the write operation to complete // Verify write operation success and call the recovery function if needed if (NVMCON1bits.WRERR){ WRITE_FAULT_RECOVERY(); } INTCON0bits.GIE = GIEBitValue; // Restore interrupt enable bit value NVMCON1bits.CMD = 0x00; // Disable writes to memory\n```",
    "10.3.5 Word Write\nPFM can be written one word at a time to a pre-erased memory location. Refer to the Word Modify section for more information on writing to a prewritten memory location.\nA single word is written by setting the NVMADR to the target address and loading NVMDAT with the desired word. The word is then transferred to PFM by setting the NVMCMD bits to 'b011 then executing the unlock sequence and setting the GO bit.\nThe sequence of events for programming single word to a pre-erased location of PFM is:\n1. Set the NVMADR registers to the target address.\n2. Load the NVMDAT with desired word.\n3. Set the NVMCMD control bits to 'b011 (Word Write).\n4. Disable all interrupts.\n5. Perform the unlock sequence as described in the Unlock Sequence section.\n6. Set the GO bit to start the PFM word write.\n7. Monitor the GO bit or NVMIF interrupt flag to determine when the write has completed.\n8. Interrupts can be enabled after the GO bit is clear.\n9. Set the NVMCMD control bits to 'b000 .",
    "Example 10-6. Writing a Word of Program Flash Memory in C\n```\n// Code sequence to program one word to a pre-erased location in PFM // PFM target address is specified by WORD_ADDR // Target data are specified by WordValue // Save interrupt enable bit value uint8_t GIEBitValue = INTCON0bits.GIE; // Load NVMADR with the target address of the word NVMADR = WORD_ADDR; NVMDAT = WordValue; // Load NVMDAT with the desired value NVMCON1bits.CMD = 0x03; // Set the word write command INTCON0bits.GIE = 0; // Disable interrupts //--------- Required Unlock Sequence --------NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; // Start word write",
    "Example 10-6. Writing a Word of Program Flash Memory in C\n//-----------------------------------------------while (NVMCON0bits.GO); // Wait for the write operation to complete // Verify word write operation success and call the recovery function if needed if (NVMCON1bits.WRERR){ WRITE_FAULT_RECOVERY(); } INTCON0bits.GIE = GIEBitValue; // Restore interrupt enable bit value NVMCON1bits.CMD = 0x00; // Disable writes to memory\n```",
    "10.3.6 Word Modify\nChanging a word in PFM requires erasing the word before it is rewritten. However, the PFM cannot be erased by less than a page at a time. Changing a single word requires reading the page, erasing the page, and then rewriting the page with the modified word. The NVM command set includes page operations to simplify this task.\nThe steps necessary to change one or more words in PFM space are as follows:\n1. Set the NVMADR registers to the target address.\n2. Set the NVMCMD to 'b010 (Page Read).\n3. Set the GO bit to start the PFM read into the GPR buffer.",
    "10.3.6 Word Modify\n4. Monitor the GO bit or NVMIF interrupt flag to determine when the read has completed.\n5. Make the desired changes to the GPR buffer data.\n6. Set NVMCMD to 'b110 (Page Erase).\n7. Disable all interrupts.\n8. Perform the unlock sequence as described in the Unlock Sequence section.\n9. Set the GO bit to start the PFM page erase.\n10. Monitor the GO bit or NVMIF interrupt flag to determine when the erase has completed.\n11. Set NVMCMD to 'b101 (Page Write).\n12. Perform the unlock sequence.\n13. Set the GO bit to start the PFM page write.\n14. Monitor the GO bit or NVMIF interrupt flag to determine when the write has completed.\n15. Interrupts can be enabled after the GO bit is clear.\n16. Set the NVMCMD control bits to 'b000 .\n```",
    "10.3.6 Word Modify\nExample 10-7. Modifying a Word in Program Flash Memory in C // Code sequence to modify one word in a programmed page of PFM // The variable with desired value is specified by ModifiedWord // PFM target address is specified by WORD_ADDR // PFM page size is specified by PAGESIZE // The Buffer RAM start address is specified by BufferRAMStartAddr. This value // will be changed based on the device, refer to the \"Memory Organization\" //chapter for more details. // Save Interrupt Enable bit Value uint8_t GIEBitValue = INTCON0bits.GIE; uint16_t bufferRAM __at (BufferRAMStartAddr); // Defining a pointer to the first location of the Buffer RAM uint16_t *bufferRamPtr = (uint16_t*) & bufferRAM; // Load NVMADR with the base address of the memory page NVMADR = WORD_ADDR; NVMCON1bits.CMD = 0x02; // Set the page read command INTCON0bits.GIE = 0; //",
    "10.3.6 Word Modify\nDisable interrupts NVMCON0bits.GO = 1; // Start page read while (NVMCON0bits.GO); // Wait for the read operation to complete // NVMADR is already pointing to target page NVMCON1bits.CMD = 0x06; // Set the page erase command //--------- Required Unlock Sequence --------NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; // Start page erase //---------------------------------------------while (NVMCON0bits.GO); // Wait for the erase operation to complete // Verify erase operation success and call the recovery function if needed if (NVMCON1bits.WRERR){ ERASE_FAULT_RECOVERY(); } //Modify Buffer RAM for the given",
    "10.3.6 Word Modify\nword to be written to PFM uint8_t offset = (uint8_t) ((WORD_ADDR & ((PAGESIZE * 2) - 1)) / 2); bufferRamPtr += offset; *bufferRamPtr = ModifiedWord; // NVMADR is already pointing to target page NVMCON1bits.CMD = 0x05; // Set the page write command //--------- Required Unlock Sequence --------NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; // Start page write //---------------------------------------------while (NVMCON0bits.GO); // Wait for the write operation to complete\n```",
    "10.3.7 Write Verify\nDepending on the application, good programming practice can dictate that the value written to the memory shall be verified against the original value. This can be used in applications where excessive writes can stress bits near the specification limit. Since program memory is stored as a full page, the stored program memory contents are compared with the intended data stored in the buffer RAM after the last write is complete.\nFigure 10-2. Program Flash Memory Write Verify Flowchart",
    "10.3.8 Unexpected Termination of Write Operation\nIf a write is terminated by an unplanned event, such as loss of power or an unexpected Reset, the memory location just programmed needs to be verified and reprogrammed, if needed. If the write operation is interrupted by a MCLR Reset or a WDT Time-out Reset during normal operation, the WRERR bit will be set. The user can then decide whether a rewrite of the location(s) is needed.",
    "10.3.9 User ID, Device ID, Configuration Settings Access, DIA and DCI\nThe NVMADR value determines which NVM address space is accessed. The User IDs and Configuration areas allow read and write access, whereas Device and Revision IDs are limited to read-only.\nReading and writing User ID space is identical to reading and writing PFM space as described in the preceding paragraphs.\nWriting to the Configuration bits is performed in the same manner as writing to the Data Flash Memory (DFM). Configuration settings are modified one byte at a time with the NVM Read and Write operations. When a Write operation is performed on a Configuration byte, an erase byte is performed automatically before the new byte is written. Any code protection settings that are not enabled will remain not enabled after the Write operation, unless the new values enable them. However, any code protection settings that are enabled cannot be disabled by a self-write of the configuration space. The user can modify the configuration space by following these steps:",
    "10.3.9 User ID, Device ID, Configuration Settings Access, DIA and DCI\n1. Read the target Configuration byte by setting the NVMADR with the target address.\n2. Retrieve the Configuration byte with the Read operation (NVMCMD = 'b000 ).\n3. Modify the Configuration byte in NVMDAT register.\n4. Write the NVMDAT register to the Configuration byte using the Write operation (NVMCMD = 'b011 ) and unlock sequence.",
    "10.3.10  Table Pointer Operations\nTo read and write program memory, there are two operations that allow the processor to move bytes between the program memory space and the data RAM:\n\u00b7 Table Read ( TBLRD* )\n\u00b7 Table Write ( TBLWT* )\nThe SFR registers associated with these operations include:\n\u00b7 TABLAT register\n\u00b7 TBLPTR registers\nThe program memory space is 16 bits wide, while the data RAM space is eight bits wide. The TBLPTR registers determine the address of one byte of the NVM memory. Table reads move one byte of data from NVM space to the TABLAT register, and table writes move the TABLAT data to the buffer RAM ready for a subsequent write to NVM space with the NVM controls.",
    "10.3.10.1 Table Pointer Register\nThe Table Pointer (TBLPTR) register addresses a byte within the program memory. The TBLPTR comprises three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL). These three registers join to form a 22-bit wide pointer (bits 0 through 21). The bits 0 through 20 allow the device to address up to 2 Mbytes of program memory space. Bit 21 allows access to the Device ID, the User ID, Configuration bits as well as the DIA and DCI.\nThe Table Pointer register, TBLPTR, is used by the TBLRD and TBLWT instructions. These instructions can increment and decrement TBLPTR, depending on specific appended characters shown in the following table. The increment and decrement operations on the TBLPTR affect only bits 0 through 20.",
    "10.3.10.1 Table Pointer Register\nTable 10-3. Table Pointer Operations with TBLRD and TBLWT Instructions\n\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write",
    "10.3.10.2 Table Latch Register\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch register receives one byte of NVM data resulting from a TBLRD* instruction and is the source of the 8-bit data sent to the holding register space as a result of a TBLWT* instruction.",
    "10.3.10.3 Table Read Operations\nThe table read operation retrieves one byte of data directly from program memory pointed to by the TBLPTR registers and places it into the TABLAT register. The following figure shows the operation of a table read.\nFigure 10-3. Table Read Operation\nInstruction: TBLRD*\nNote: 1  The Table Pointer register points to a byte in program memory. .",
    "10.3.10.4 Table Write Operations\nThe table write operation stores one byte of data from the TABLAT register into a buffer RAM register. The following figure shows the operation of a table write from the TABLAT register to the buffer RAM space. The procedure to write the contents of the buffer RAM into program memory is detailed in the Page Write section.",
    "Figure 10-4. Table Write Operation\nInstruction: TBLWT*\nNote 1: During table writes the Table Pointer does not point directly to program memory. TBLPTRL actually points to an address within the buffer registers. TBLPTRU:TBLPTRH points to program memory where the entire buffer space will eventually be written with the NVM commands.\nTable operations work with byte entities. Tables containing data, rather than program instructions, are not required to be word-aligned. Therefore, a table can start and end at any byte address. If a table write is being used to write executable code into program memory, program instructions will need to be word-aligned.",
    "10.3.10.5 Table Pointer Boundaries\nThe TBLPTR register is used in reads of the Program Flash Memory. Writes using the TBLPTR register go into a buffer RAM from which the data can eventually be transferred to Program Flash Memory using the NVMADR register and NVM commands.\nWhen a TBLRD instruction is executed, all 22 bits of the TBLPTR determine which byte is read from program memory directly into the TABLAT register.\nWhen a TBLWT instruction is executed, the byte in the TABLAT register is written not to Flash memory but to a buffer register in preparation for a program memory write. All the buffer registers form a write block of size 128 words/256 bytes. The LSbs of the TBLPTR register determine to which specific address within the buffer register block the write affects. The size of the write block determines the number of LSbs that are affected. The MSbs of the TBLPTR register have no effect during TBLWT operations.\nWhen a program memory page write is executed, the entire buffer register block is written to the Flash memory at the address determined by the MSbs of the NVMADR register. The LSbs are ignored during Flash memory writes.",
    "10.3.10.5 Table Pointer Boundaries\nThe following figure illustrates the relevant boundaries of the TBLPTR register based on NVM operations.\nFigure 10-5. Table Pointer Boundaries Based on Operation",
    "Note:\n- 1. Refer to the 'Memory Organization' chapter for more details about the size of the buffer registers block.",
    "10.3.10.6 Reading the Program Flash Memory\nThe TBLRD instruction retrieves data from program memory at the location to which the TBLPTR register points and places it into the TABLAT SFR register. Table reads from program memory are performed one byte at a time. The instruction set includes incrementing the TBLPTR register automatically for the next table read operation.\nThe CPU operation is suspended during the read and resumes operation immediately after. From the user point of view, the value in the TABLAT register is valid in the next instruction cycle.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. The following figure illustrates the interface between the internal program memory and the TABLAT register.\nFigure 10-6. Reads from Program Flash Memory\nFigure 10-7. Program Flash Memory Read Flowchart",
    "10.4 Data Flash Memory (DFM)\nThe Data Flash Memory is a nonvolatile memory array, also referred to as EEPROM. The DFM is mapped above program memory space. The DFM can be accessed using the Table Pointer or NVM Special Function Registers (SFRs). The DFM is readable and writable during normal operation over the entire V DD range.\nThe DFM can only be read and written one byte at a time. When interfacing to the data memory block, the NVMDATL register holds the 8-bit data for read/write and the NVMADR register holds the address of the DFM location being accessed.\nThe DFM is rated for high erase/write cycle endurance. A byte write automatically erases the location and writes the new data (erase-before-write). The write time is controlled by an internal programming timer; it will vary with voltage and temperature as well as from device-to-device. Refer to the data EEPROM memory parameters in the 'Electrical Specifications' chapter for the limits.",
    "10.4.1 Reading the DFM\nTo read a DFM location, the user must write the address to the NVMADR register, set the NVMCMD bits for a single read operation (NVMCMD = 'b000 ), and then set the GO control bit. The data are available on the very next instruction cycle. Therefore, the NVMDATL register can be read by the next instruction. NVMDATL will hold this value until another read operation or until it is written to by the user (during a write operation).\nNote: Only byte reads are supported for DFM. Reading DFM with the Read Page operation is not supported.\nThe sequence of events for reading a byte of DFM is:\n1. Set the NVMADR registers to an address within the intended page.\n2. Set the NVMCMD control bits to 'b000 (Byte Read).\n3. Set the GO bit to start the DFM byte read.\n4. Monitor the GO bit or NVMIF interrupt flag to determine when the read has completed.\nThis process is also shown in the following flowchart.\nFigure 10-8. DFM Read Flowchart",
    "10.4.2 Writing to DFM\nTo write a DFM location, the address must first be written to the NVMADR register, the data written to the NVMDATL register, and the Write operation command set in the NVMCMD bits. The sequence shown in Unlock Sequence must be followed to initiate the write cycle. Multibyte Page writes are not supported for the DFM.\nThe write will not begin if the NVM unlock sequence is not exactly followed for each byte. It is strongly recommended to disable interrupts during this code segment.\nWhen not actively writing to the DFM, the NVMCMD bits need to be kept clear at all times as an extra precaution against accidental writes. The NVMCMD bits are not cleared by hardware.\nAfter a write sequence has been initiated, NVMCON0, NVMCON1, NVMADR and NVMDAT cannot be modified.",
    "10.4.2 Writing to DFM\nEach DFM write operation includes an implicit erase cycle for that byte. CPU execution continues in parallel and at the completion of the write cycle, the GO bit is cleared in hardware and the NVM Interrupt Flag (NVMIF) bit is set. The user can either enable the interrupt or poll the bit. NVMIF must be cleared by software.\nThe sequence of events for programming one byte of DFM is:",
    "10.4.2 Writing to DFM\n1. Set NVMADR registers with the target byte address.\n2. Load NVMDATL register with desired byte.\n3. Set the NVMCMD control bits to 'b011 (Byte Write).\n4. Disable all interrupts.\n5. Perform the unlock sequence as described in the Unlock Sequence section.\n6. Set the GO bit to start the DFM byte write.\n7. Interrupts can be enabled after the GO bit is set. If it is not desired to have interrupts during DFM write, then enable interrupts after the next step when the GO bit is cleared.\n8. Monitor the GO bit or NVMIF interrupt flag to determine when the write has been completed.\n9. Set the NVMCMD control bits to 'b000 .",
    "10.4.3 Erasing the DFM\nThe DFM does not support the Page Erase operation. However, the DFM can be erased by writing 0xFF to all locations in the memory that need to be erased. The simple code example bellow shows\nhow to erase 'n' number of bytes in DFM. Refer to the 'Memory Organization' chapter for more details about the DFM size and valid address locations.",
    "Example 10-11. Erasing n Bytes of Data Flash Memory in C\n```\n// Code sequence to erase n bytes of DFM // DFM target start address is specified by PAGE_ADDR // Number of bytes to be eares is specified by n // Save interrupt enable bit value uint8_t GIEBitValue = INTCON0bits.GIE; // Load NVMADR with the target address of the byte NVMADR = DFM_ADDR; NVMDATL = 0xFF; // Load NVMDATL with 0xFF NVMCON1bits.CMD = 0x04; // Set the write and post increment command INTCON0bits.GIE = 0; // Disable interrupts for (uint8_t i = 0; i < n; i++}( NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; } // Verify byte erase operation success and call the recovery function if needed if (NVMCON1bits.WRERR){",
    "Example 10-11. Erasing n Bytes of Data Flash Memory in C\nERASE_FAULT_RECOVERY(); } INTCON0bits.GIE = GIEBitValue; // Restore interrupt enable bit value NVMCON1bits.CMD = 0; // Disable writes to memory\n```",
    "10.4.4 DFM Write Verify\nDepending on the application, good programming practice can dictate that the value written to the memory shall be verified against the original value. This can be used in applications where excessive writes can stress bits near the specification limit to ensure that the intended values are written correctly to the specified memory locations.",
    "10.4.5 Operation During Code-Protect and Write-Protect\nThe DFM can be code-protected using the CP Configuration bit. In-Circuit Serial Programming read and write operations are disabled when code protection is enabled. However, internal reads operate normally. Internal writes operate normally, provided that write protection is not enabled.\nIf the DFM is write-protected or if NVMADR points at an invalid address location, attempts to set the GO bit will fail and the WRERR bit will be set.",
    "10.4.6 Protection Against Spurious Writes\nA write sequence is valid only when both the following conditions are met. This prevents spurious writes that might lead to data corruption.\n1. All NVM read, write and erase operations are enabled with the NVMCMD control bits. It is suggested to have the NVMCMD bits cleared at all times except during memory writes. This prevents memory operations if any of the control bits are set accidentally.\n2. The NVM unlock sequence must be performed each time before all operations except the memory read operation.",
    "10.5.1 NVMCON0\nName:\nNVMCON0\nAddress:\n0x040\nNonvolatile Memory Control Register 0\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nGO\nAccess Reset\nR/S/HC\n0",
    "Bit 0 - GO Start Operation Control\nStart the operation specified by the NVMCMD bits\n1, Description = Start operation (must be set after UNLOCK sequence for all operations except READ). 0, Description = Operation is complete",
    "10.5.2 NVMCON1\nName:\nNVMCON1\nAddress:\n0x041\nNonvolatile Memory Control Register 1\nAccess, 7.WRERR = R/C/HS. Access, 6. = . Access, 5. = . Access, 4. = . Access, 3. = . Access, 2.NVMCMD[2:0] = R/W. Access, 1.NVMCMD[2:0] = R/W. Access, 0.NVMCMD[2:0] = R/W. Reset, 7.WRERR = 0. Reset, 6. = . Reset, 5. = . Reset, 4. = . Reset, 3. = . Reset, 2.NVMCMD[2:0] = 0. Reset, 1.NVMCMD[2:0] = 0. Reset, 0.NVMCMD[2:0] = 0",
    "Bit 7 - WRERR NVM Write Error\nReset States: POR = 0\nAll other Resets = u\n1, Description = A write operation was interrupted by a Reset, or a write or erase operation was attempted on a write-protected area, or a write or erase operation was attempted on an unimplemented area, or a write or erase operation was attempted while locked, or a page operation was directed to a DFM area. 0, Description = All write/erase operations have completed successfully",
    "Table 10-4. NVM Operations\n000, Unlock = No. 000, Operation = Read. 000, DFM = byte. 000, PFM = word. 000, Source/Destination = NVM to NVMDAT. 000, WRERR = No. 000, INT = No. 001, Unlock = No. 001, Operation = Read and Post Increment. 001, DFM = byte. 001, PFM = word. 001, Source/Destination = NVM to NVMDAT. 001, WRERR = No. 001, INT = No. 010, Unlock = No. 010, Operation = Read Page. 010, DFM = -. 010, PFM = page. 010, Source/Destination = NVM to Buffer RAM. 010, WRERR = No. 010, INT = No. 011, Unlock = Yes. 011, Operation = Write. 011, DFM = byte. 011, PFM = word. 011, Source/Destination = NVMDAT to NVM. 011, WRERR = Yes. 011, INT = Yes. 100, Unlock = Yes. 100, Operation",
    "Table 10-4. NVM Operations\n= Write and Post Increment. 100, DFM = byte. 100, PFM = word. 100, Source/Destination = NVMDAT to NVM. 100, WRERR = Yes. 100, INT = Yes. 101, Unlock = Yes. 101, Operation = Write Page. 101, DFM = -. 101, PFM = page. 101, Source/Destination = Buffer RAM to NVM. 101, WRERR = Yes. 101, INT = Yes. 110, Unlock = Yes. 110, Operation = Erase Page. 110, DFM = -. 110, PFM = page. 110, Source/Destination = n/a. 110, WRERR = Yes. 110, INT = Yes. 111, Unlock = No. 111, Operation = Reserved (No Operation). 111, DFM = -. 111, PFM = -. 111, Source/Destination = -. 111, WRERR = No. 111, INT = No",
    "10.5.3 NVMLOCK\nName:\nNVMLOCK\nAddress:\n0x042\nNonvolatile Memory Write Restriction Control Register\nNVM write and erase operations require writing 0x55 then 0xAA to this register immediately before the operation execution.",
    "10.5.3 NVMLOCK\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = NVMLOCK[7:0]. , 2 = NVMLOCK[7:0]. , 3 = NVMLOCK[7:0]. , 4 = NVMLOCK[7:0]. , 5 = NVMLOCK[7:0]. , 6 = NVMLOCK[7:0]. , 7 = NVMLOCK[7:0]. , 8 = NVMLOCK[7:0]. Access, 1 = WO. Access, 2 = WO. Access, 3 = WO. Access, 4 = WO. Access, 5 = WO. Access, 6 = WO. Access, 7 = WO. Access, 8 = WO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - NVMLOCK[7:0]\nReading this register always returns ' 0 '.",
    "10.5.4 NVMADR\nName: Address:\nNVMADR\n0x043",
    "Nonvolatile Memory Address Register\n, 23 = . , 22 = . , 21 = NVMADR[21:16]. , 20 = NVMADR[21:16]. , 19 = NVMADR[21:16]. , 18 = NVMADR[21:16]. , 17 = NVMADR[21:16]. , 16 = NVMADR[21:16]. Access, 23 = . Access, 22 = . Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 =",
    "Nonvolatile Memory Address Register\nNVMADR[15:8]. , 22 = NVMADR[15:8]. , 21 = NVMADR[15:8]. , 20 = NVMADR[15:8]. , 19 = NVMADR[15:8]. , 18 = NVMADR[15:8]. , 17 = NVMADR[15:8]. , 16 = NVMADR[15:8]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2.",
    "Nonvolatile Memory Address Register\nBit, 17 = 1. Bit, 16 = 0. , 23 = NVMADR[7:0]. , 22 = NVMADR[7:0]. , 21 = NVMADR[7:0]. , 20 = NVMADR[7:0]. , 19 = NVMADR[7:0]. , 18 = NVMADR[7:0]. , 17 = NVMADR[7:0]. , 16 = NVMADR[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0",
    "Bits 21:0 - NVMADR[21:0] NVM Address\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 NVMADRU: Accesses the upper byte NVMADR[21:16]\n\u00b7 NVMADRH: Accesses the high byte NVMADR[15:8]\n\u00b7 NVMADRL: Accesses the low byte NVMADR[7:0]",
    "10.5.5 NVMDAT\nName: Address:\nNVMDAT 0x046",
    "Nonvolatile Memory Data Register\nAccess, 15.NVMDAT[15:8] = R/W. Access, 14.NVMDAT[15:8] = R/W. Access, 13.NVMDAT[15:8] = R/W. Access, 12.NVMDAT[15:8] = R/W. Access, 11.NVMDAT[15:8] = R/W. Access, 10.NVMDAT[15:8] = R/W. Access, 9.NVMDAT[15:8] = R/W. Access, 8.NVMDAT[15:8] = R/W. Reset, 15.NVMDAT[15:8] = 0. Reset, 14.NVMDAT[15:8] = 0. Reset, 13.NVMDAT[15:8] = 0. Reset, 12.NVMDAT[15:8] = 0. Reset, 11.NVMDAT[15:8] = 0. Reset, 10.NVMDAT[15:8] = 0. Reset,",
    "Nonvolatile Memory Data Register\n9.NVMDAT[15:8] = 0. Reset, 8.NVMDAT[15:8] = 0. Bit, 15.NVMDAT[15:8] = 7. Bit, 14.NVMDAT[15:8] = 6. Bit, 13.NVMDAT[15:8] = 5. Bit, 12.NVMDAT[15:8] = 4. Bit, 11.NVMDAT[15:8] = 3. Bit, 10.NVMDAT[15:8] = 2. Bit, 9.NVMDAT[15:8] = 1. Bit, 8.NVMDAT[15:8] = 0. , 15.NVMDAT[15:8] = NVMDAT[7:0]. , 14.NVMDAT[15:8] = NVMDAT[7:0]. , 13.NVMDAT[15:8] = NVMDAT[7:0]. , 12.NVMDAT[15:8] =",
    "Nonvolatile Memory Data Register\nNVMDAT[7:0]. , 11.NVMDAT[15:8] = NVMDAT[7:0]. , 10.NVMDAT[15:8] = NVMDAT[7:0]. , 9.NVMDAT[15:8] = NVMDAT[7:0]. , 8.NVMDAT[15:8] = NVMDAT[7:0]. Access, 15.NVMDAT[15:8] = R/W. Access, 14.NVMDAT[15:8] = R/W. Access, 13.NVMDAT[15:8] = R/W. Access, 12.NVMDAT[15:8] = R/W. Access, 11.NVMDAT[15:8] = R/W. Access, 10.NVMDAT[15:8] = R/W. Access, 9.NVMDAT[15:8] = R/W. Access, 8.NVMDAT[15:8] = R/W. Reset,",
    "Nonvolatile Memory Data Register\n15.NVMDAT[15:8] = 0. Reset, 14.NVMDAT[15:8] = 0. Reset, 13.NVMDAT[15:8] = 0. Reset, 12.NVMDAT[15:8] = 0. Reset, 11.NVMDAT[15:8] = 0. Reset, 10.NVMDAT[15:8] = 0. Reset, 9.NVMDAT[15:8] = 0. Reset, 8.NVMDAT[15:8] = 0",
    "Bits 15:0 - NVMDAT[15:0] NVM Data\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 NVMDATH: Accesses the high byte NVMDAT[15:8]\n\u00b7 NVMDATL: Accesses the low byte NVMDAT[7:0]",
    "10.5.6 TBLPTR\nName: Address:\nTBLPTR 0x4F6",
    "Table Pointer Register\nAccess, 23. = . Access, 22. = . Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTR[20:16] = R/W. Access, 19.TBLPTR[20:16] = R/W. Access, 18.TBLPTR[20:16] = R/W. Access, 17.TBLPTR[20:16] = R/W. Access, 16.TBLPTR[20:16] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTR[20:16] = 0. Reset, 19.TBLPTR[20:16] = 0. Reset, 18.TBLPTR[20:16] = 0. Reset, 17.TBLPTR[20:16] = 0. Reset, 16.TBLPTR[20:16] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21.TBLPTR21 = 13. Bit, 20.TBLPTR[20:16] = 12. Bit,",
    "Table Pointer Register\n19.TBLPTR[20:16] = 11. Bit, 18.TBLPTR[20:16] = 10. Bit, 17.TBLPTR[20:16] = 9. Bit, 16.TBLPTR[20:16] = 8. , 23. = TBLPTR[15:8]. , 22. = TBLPTR[15:8]. , 21.TBLPTR21 = TBLPTR[15:8]. , 20.TBLPTR[20:16] = TBLPTR[15:8]. , 19.TBLPTR[20:16] = TBLPTR[15:8]. , 18.TBLPTR[20:16] = TBLPTR[15:8]. , 17.TBLPTR[20:16] = TBLPTR[15:8]. , 16.TBLPTR[20:16] = TBLPTR[15:8]. Access, 23. = R/W. Access, 22. = R/W. Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTR[20:16] =",
    "Table Pointer Register\nR/W. Access, 19.TBLPTR[20:16] = R/W. Access, 18.TBLPTR[20:16] = R/W. Access, 17.TBLPTR[20:16] = R/W. Access, 16.TBLPTR[20:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTR[20:16] = 0. Reset, 19.TBLPTR[20:16] = 0. Reset, 18.TBLPTR[20:16] = 0. Reset, 17.TBLPTR[20:16] = 0. Reset, 16.TBLPTR[20:16] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21.TBLPTR21 = 5. Bit, 20.TBLPTR[20:16] = 4. Bit, 19.TBLPTR[20:16] = 3. Bit, 18.TBLPTR[20:16] = 2. Bit,",
    "Table Pointer Register\n17.TBLPTR[20:16] = 1. Bit, 16.TBLPTR[20:16] = 0. , 23. = TBLPTR[7:0]. , 22. = TBLPTR[7:0]. , 21.TBLPTR21 = TBLPTR[7:0]. , 20.TBLPTR[20:16] = TBLPTR[7:0]. , 19.TBLPTR[20:16] = TBLPTR[7:0]. , 18.TBLPTR[20:16] = TBLPTR[7:0]. , 17.TBLPTR[20:16] = TBLPTR[7:0]. , 16.TBLPTR[20:16] = TBLPTR[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTR[20:16] = R/W. Access, 19.TBLPTR[20:16] = R/W. Access, 18.TBLPTR[20:16]",
    "Table Pointer Register\n= R/W. Access, 17.TBLPTR[20:16] = R/W. Access, 16.TBLPTR[20:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTR[20:16] = 0. Reset, 19.TBLPTR[20:16] = 0. Reset, 18.TBLPTR[20:16] = 0. Reset, 17.TBLPTR[20:16] = 0. Reset, 16.TBLPTR[20:16] = 0",
    "Bit 21 - TBLPTR21 NVM Most Significant Address bit\n1, Description = Access Configuration, User ID, Device ID, and Revision ID spaces. 0, Description = Access Program Flash Memory space",
    "Bits 20:0 - TBLPTR[20:0] NVM Address bits\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 TBLPTRU: Accesses the upper byte TBLPTR[21:16]\n\u00b7 TBLPTRH: Accesses the high byte TBLPTR[15:8]\n\u00b7 TBLPTRL: Accesses the low byte TBLPTR[7:0]",
    "10.5.7 TABLAT\nName: Address:\nTABLAT 0x4F5\nTable Latch Register",
    "10.5.7 TABLAT\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TABLAT[7:0]. , 2 = TABLAT[7:0]. , 3 = TABLAT[7:0]. , 4 = TABLAT[7:0]. , 5 = TABLAT[7:0]. , 6 = TABLAT[7:0]. , 7 = TABLAT[7:0]. , 8 = TABLAT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "10.5.7 TABLAT\nBits 7:0 - TABLAT[7:0] The value of the NVM memory byte returned from the address contained in TBLPTR after a TBLRD command or the data written to the latch by a TBLWT command.",
    "10.6 Register Summary - NVM\n0x00 ... 0x3F, Name = Reserved. 0x00 ... 0x3F, Bit Pos. = . 0x00 ... 0x3F, 7 = . 0x00 ... 0x3F, 6 = . 0x00 ... 0x3F, 5 = . 0x00 ... 0x3F, 4 3 = . 0x00 ... 0x3F, 2 = . 0x00 ... 0x3F, 1 = . 0x00 ... 0x3F, 0 = . 0x40, Name = NVMCON0. 0x40, Bit Pos. = 7:0. 0x40, 7 = . 0x40, 6 = . 0x40, 5 = . 0x40, 4 3 = . 0x40, 2 = . 0x40, 1 = . 0x40, 0 = GO. 0x41, Name = NVMCON1. 0x41, Bit Pos. = 7:0. 0x41, 7 = WRERR. 0x41, 6",
    "10.6 Register Summary - NVM\n= . 0x41, 5 = . 0x41, 4 3 = . 0x41, 2 = NVMCMD[2:0]. 0x41, 1 = NVMCMD[2:0]. 0x41, 0 = NVMCMD[2:0]. 0x42, Name = NVMLOCK. 0x42, Bit Pos. = 7:0. 0x42, 7 = . 0x42, 6 = . 0x42, 5 = . 0x42, 4 3 = NVMLOCK[7:0]. 0x42, 2 = . 0x42, 1 = . 0x42, 0 = . 0x43, Name = NVMADR. 0x43, Bit Pos. = 7:0. 0x43, 7 = . 0x43, 6 = . 0x43, 5 = . 0x43, 4 3 = NVMADR[7:0]. 0x43, 2 = . 0x43, 1 = . 0x43, 0 = . 0x43, Name = NVMADR. 0x43, Bit",
    "10.6 Register Summary - NVM\nPos. = 15:8. 0x43, 7 = . 0x43, 6 = . 0x43, 5 = . 0x43, 4 3 = NVMADR[15:8]. 0x43, 2 = . 0x43, 1 = . 0x43, 0 = . 0x43, Name = NVMADR. 0x43, Bit Pos. = 23:16. 0x43, 7 = . 0x43, 6 = . 0x43, 5 = . 0x43, 4 3 = NVMADR[21:16]. 0x43, 2 = NVMADR[21:16]. 0x43, 1 = NVMADR[21:16]. 0x43, 0 = NVMADR[21:16]. 0x46, Name = NVMDAT. 0x46, Bit Pos. = 7:0. 0x46, 7 = . 0x46, 6 = . 0x46, 5 = . 0x46, 4 3 = NVMDAT[7:0]. 0x46, 2 = .",
    "10.6 Register Summary - NVM\n0x46, 1 = . 0x46, 0 = . 0x46, Name = NVMDAT. 0x46, Bit Pos. = 15:8. 0x46, 7 = . 0x46, 6 = . 0x46, 5 = . 0x46, 4 3 = NVMDAT[15:8]. 0x46, 2 = . 0x46, 1 = . 0x46, 0 = . 0x48 ... 0x04F4, Name = Reserved. 0x48 ... 0x04F4, Bit Pos. = . 0x48 ... 0x04F4, 7 = . 0x48 ... 0x04F4, 6 = . 0x48 ... 0x04F4, 5 = . 0x48 ... 0x04F4, 4 3 = . 0x48 ... 0x04F4, 2 = . 0x48 ... 0x04F4, 1 = . 0x48 ... 0x04F4, 0 = .",
    "10.6 Register Summary - NVM\n0x04F5, Name = TABLAT. 0x04F5, Bit Pos. = 7:0. 0x04F5, 7 = . 0x04F5, 6 = . 0x04F5, 5 = . 0x04F5, 4 3 = TABLAT[7:0]. 0x04F5, 2 = . 0x04F5, 1 = . 0x04F5, 0 = . 0x04F6, Name = TBLPTR. 0x04F6, Bit Pos. = 7:0. 0x04F6, 7 = . 0x04F6, 6 = . 0x04F6, 5 = . 0x04F6, 4 3 = TBLPTR[7:0]. 0x04F6, 2 = . 0x04F6, 1 = . 0x04F6, 0 = . 0x04F6, Name = TBLPTR. 0x04F6, Bit Pos. = 15:8.",
    "10.6 Register Summary - NVM\n0x04F6, 7 = . 0x04F6, 6 = . 0x04F6, 5 = . 0x04F6, 4 3 = TBLPTR[15:8]. 0x04F6, 2 = . 0x04F6, 1 = . 0x04F6, 0 = . 0x04F6, Name = TBLPTR. 0x04F6, Bit Pos. = 23:16. 0x04F6, 7 = . 0x04F6, 6 = . 0x04F6, 5 = TBLPTR21. 0x04F6, 4 3 = . 0x04F6, 2 = TBLPTR[20:16]. 0x04F6, 1 = . 0x04F6, 0 = ",
    "11.1 Overview\nThe Vectored Interrupt Controller (VIC) module reduces the numerous peripheral interrupt request signals to a single interrupt request signal to the CPU. This module includes the following major features:\n\u00b7 Interrupt Vector Table (IVT) with a unique vector for each interrupt source\n\u00b7 Fixed and ensured interrupt latency\n\u00b7 Programmable base address for IVT with lock\n\u00b7 Two user-selectable priority levels: high-priority and low-priority\n\u00b7 Two levels of context saving\n\u00b7 Interrupt state Status bits to indicate the current execution status of the CPU\nThe VIC module assembles all of the interrupt request signals and resolves the interrupts based on both a fixed natural order priority (i.e., determined by the IVT) and a user-assigned priority (i.e., determined by the IPRx registers), thereby eliminating scanning of interrupt sources.",
    "11.2 Interrupt Control and Status Registers\nThe devices in this family implement the following registers for the interrupt controller:\n\u00b7 INTCON0, INTCON1 Control Registers\n\u00b7 PIRx - Peripheral Interrupt Status Registers\n\u00b7 PIEx - Peripheral Interrupt Enable Registers\n\u00b7 IPRx - Peripheral Interrupt Priority Registers\n\u00b7 IVTBASE Address Registers\n\u00b7 IVTLOCK Register\nGlobal interrupt control functions and external interrupts are controlled from the INTCON0 register. The INTCON1 register contains the status flags for the interrupt controller.\nThe PIRx registers contain all of the interrupt request flags. Each source of interrupt has a Status bit, which is set by the respective peripherals or an external signal and is either cleared via software or automatically cleared by hardware upon clearing of the interrupt condition, depending on the peripheral and bit.\nThe PIEx registers contain all of the interrupt enable bits. These control bits are used to individually enable interrupts from the peripherals or external signals.\nThe IPRx registers are used to set the interrupt priority level for each source of interrupt. Each user interrupt source can be assigned to either a high or low priority.",
    "11.2 Interrupt Control and Status Registers\nThe IVTBASE register is user-programmable and is used to determine the start address of the IVT and the IVTLOCK register is used to prevent any unintended writes to the IVTBASE register.\nThere are two other Configuration bits that control the way the interrupt controller can be configured: The MVECEN and the IVT1WAY bits.\nThe MVECEN bit determines whether the IVT is used to determine the interrupt priorities. The IVT1WAY bit determines the number of times the IVTLOCKED bit can be cleared and set after a device Reset. See the Interrupt Vector Table Address Calculation section for details.",
    "11.3 Interrupt Vector Table\nThe interrupt controller supports an IVT that contains the vector address location for each interrupt request source.\nThe IVT resides in program memory, starting at the address location determined by IVTBASE. The IVT contains one vector for each source of interrupt. Each interrupt vector location contains the starting address of the associated Interrupt Service Routine (ISR). The MVECEN Configuration bit controls the availability of the vector table.",
    "11.3.1 Interrupt Vector Table Base Address (IVTBASE)\nThe start address of the vector table is user-programmable through the IVTBASE. The user must ensure the start address is such that it can encompass the entire vector table inside the program memory.\nEach vector address is a 16-bit word (or two address locations on PIC18 devices). For 'n' interrupt sources, there are '2n' address locations necessary to hold the table, starting from IVTBASE as the first location. Thus, the starting address needs to be chosen such that the address range from IVTBASE to 'IVTBASE+2n-1' can be encompassed within the program Flash memory.\nFor example, if the highest vector number was 81, IVTBASE needs to be chosen such that 'IVTBASE+0xA1' is less than the last memory location in program Flash memory.\nA programmable vector table base address is useful in situations to switch between different sets of vector tables, depending on the application. It can also be used when the application program needs to update the existing vector table (vector address values).\nImportant: It is required that the user assign an even address to IVTBASE for correct operation.",
    "MVECEN = 0\nWhen MVECEN = 0 , the address location pointed to by IVTBASE has a GOTO instruction for a highpriority interrupt. Similarly, the corresponding low-priority vector also has a GOTO instruction, which is executed in case of a low-priority interrupt.",
    "MVECEN = 1\nWhen MVECEN = 1 , the value in the vector table of each interrupt points to the address location of the first instruction of the Interrupt Service Routine, hence: ISR Location = Interrupt Vector Table entry << 2.",
    "MVECEN = 0\nWhen the MVECEN Configuration bit is cleared, the address pointed to by IVTBASE is used as the high-priority interrupt vector address. The low-priority interrupt vector address is offset eight instruction words from the address in IVTBASE.\nFor PIC18 devices, IVTBASE defaults to 000008h, hence the high-priority interrupt vector address will be 000008h and the low-priority interrupt vector address will be 000018h.",
    "MVECEN = 1\nEach interrupt has a unique vector number associated with it, as defined in the IVT. This vector number is used for calculating the location of the interrupt vector for a particular interrupt source.\nInterrupt Vector Address = IVTBASE + (2*Vector Number). This calculated interrupt vector address value is stored in the IVTAD register when an interrupt is received.\nUser-assigned software priority, when assigned using the IPRx registers, does not affect address calculation and is only used to resolve concurrent interrupts.\nImportant: If for any reason the address of the ISR cannot be fetched from the vector table, it will cause the system to reset and clear the Memory Execution Violation flag in the Power Control register. This can occur due to any one of the following:\n\u00b7 The entry for the interrupt in the vector table lies outside the executable program memory area\n\u00b7 ISR pointed by the vector table lies outside the executable program memory area",
    "MVECEN = 1\nTable 11-1. IVT Calculations Summary\n\nMultivector Enable, MVECEN Configuration bit, IVT Address Calculation. = 0. Multivector Enable, MVECEN Configuration bit, Interrupt Priority INTCON0 Register, IPEN Bit.0 = IVTBASE. Multivector Enable, MVECEN Configuration bit, Interrupt Priority INTCON0 Register, IPEN Bit.1 = High-priority IVTBASE Low-priority IVTBASE + 8 words. Multivector Enable, MVECEN Configuration bit, IVT Address Calculation. = 1. Multivector Enable, MVECEN Configuration bit, Interrupt Priority INTCON0 Register, IPEN Bit.0 = IVTBASE + 2*(Vector Number). Multivector Enable, MVECEN Configuration bit, Interrupt Priority INTCON0 Register, IPEN Bit.1 = IVTBASE + 2*(Vector Number)",
    "11.3.4 Access Control for IVTBASE Registers\nThe interrupt controller has an IVTLOCKED bit, which can be set to avoid inadvertent changes to the contents of IVTBASE. Setting and clearing this bit requires a special sequence as an extra precaution against inadvertent changes.\nTo allow writes to IVTBASE, the interrupts must be disabled (GIEH = 0 ) and the IVTLOCKED bit must be cleared. The user must follow the sequence shown below to clear the IVTLOCKED bit.\n```\nExample 11-1. IVT Unlock Sequence ; Disable Interrupts: BCF INTCON0, GIE; ; Bank to IVTLOCK register BANKSEL IVTLOCK; MOVLW 55h; ; Required sequence, next 4 instructions MOVWF IVTLOCK; MOVLW AAh; MOVWF IVTLOCK; ; Clear IVTLOCKED bit to enable writes BCF IVTLOCK, IVTLOCKED; ; Enable Interrupts BSF INTCON0, GIE;\n```\nThe user must follow the following sequence to set the IVTLOCKED bit.",
    "11.3.4 Access Control for IVTBASE Registers\n```\nExample 11-2. IVT Lock Sequence ; Disable Interrupts: BCF INTCON0, GIE; ; Bank to IVTLOCK register BANKSEL IVTLOCK; MOVLW 55h; ; Required sequence, next 4 instructions MOVWF IVTLOCK; MOVLW AAh; MOVWF IVTLOCK; ; Set IVTLOCKED bit to enable writes\n```\nWhen the IVT1WAY Configuration bit is set, the IVTLOCKED bit can be cleared and set only once after a device Reset. The unlock operation will have no effect after the lock sequence is used to set the IVTLOCKED bit. Unlocking is inhibited until a system Reset occurs.",
    "11.4 Interrupt Priority\nThe final priority level for any pending source of interrupt is determined first by the user-assigned priority of that source in the IPRx register, then by the natural order priority within the IVT. The sections below detail the operation of interrupt priorities.",
    "11.4.1 User (Software) Priority\nUser-assigned interrupt priority is enabled by setting IPEN. Each peripheral interrupt source can be assigned a high- or low-priority level by the user. The user-assignable interrupt priority control bits for each interrupt are located in the IPRx registers, which are device-specific and can be found in the respective data sheet for each device.\nThe interrupts are serviced based on a predefined interrupt priority scheme detailed below.",
    "11.4.1 User (Software) Priority\n1. Interrupts set by the user as a high-priority interrupt have higher precedence of execution. High-priority interrupts will override a low-priority request when:\na. A low-priority interrupt has been requested or its request is already pending.\nb. A low- and high-priority interrupt are triggered concurrently (i.e., on the same instruction cycle). (1)\nc. A low-priority interrupt was requested and the corresponding Interrupt Service Routine is currently executing. In this case, the lower priority interrupt routine will be interrupted then complete executing after the high-priority interrupt has been serviced. (2)\n2. Interrupts set by the user as low priority have a lower priority of execution and are preempted by any high-priority interrupt.\n3. Interrupts defined with the same software priority cannot preempt or interrupt each other. Concurrent pending interrupts with the same user priority are resolved using the natural order priority (when vectored interrupts are enabled) or in the order the interrupt flag bits are polled in the ISR (when vectored interrupts are disabled).",
    "Important:\n1. When a high-priority interrupt preempts a concurrent low-priority interrupt, GIEL may be cleared in the high-priority Interrupt Service Routine. If GIEL is cleared, the low-priority interrupt will NOT be serviced, even if it was originally requested. The corresponding interrupt flag needs to be cleared in user code.\n2. When a high-priority interrupt is requested while a low-priority Interrupt Service Routine is executing, GIEL may be cleared in the high-priority Interrupt Service Routine. The pending low-priority interrupt will resume, even if GIEL is cleared.",
    "11.4.2 Natural Order (Hardware) Priority\nWhen vectored interrupts are enabled and more than one interrupt with the same user specified priority level is requested, the priority conflict is resolved by using a method called 'Natural Order Priority'. Natural order priority is a fixed priority scheme that is based on the IVT.\n\nTable 11-2. Interrupt Vector Priority Table",
    "11.4.2 Natural Order (Hardware) Priority\n0x0, Interrupt source = Software Interrupt. 0x0, Vector Number (cont.) = 0x2D. 0x0, Interrupt source (cont.) = CLC2. 0x1, Interrupt source = HLVD (High/Low-Voltage Detect). 0x1, Vector Number (cont.) = 0x2E. 0x1, Interrupt source (cont.) = PWM2PR. 0x2, Interrupt source = OSF (Oscillator Fail). 0x2, Vector Number (cont.) = 0x2F. 0x2, Interrupt source (cont.) = PWM2. 0x3, Interrupt source = CSW (Clock Switching). 0x3, Vector Number (cont.) = 0x30. 0x3, Interrupt source (cont.) = INT1. 0x4, Interrupt source = NVM. 0x4, Vector Number (cont.) = 0x31. 0x4, Interrupt source (cont.) = CWG1 (Complementary Waveform Generator).",
    "11.4.2 Natural Order (Hardware) Priority\n0x5, Interrupt source = CLC1 (Configurable Logic Cell). 0x5, Vector Number (cont.) = 0x32. 0x5, Interrupt source (cont.) = NCO1 (Numerically Controlled Oscillator). 0x6, Interrupt source = CRC (Cyclic Redundancy Check). 0x6, Vector Number (cont.) = 0x33. 0x6, Interrupt source (cont.) = DMA2SCNT. 0x7, Interrupt source = IOC (Interrupt-On-Change). 0x7, Vector Number (cont.) = 0x34. 0x7, Interrupt source (cont.) = DMA2DCNT. 0x8, Interrupt source = INT0. 0x8, Vector Number (cont.) = 0x35. 0x8, Interrupt source (cont.) = DMA2OR. 0x9, Interrupt source = ZCD (Zero-Cross Detection). 0x9, Vector Number (cont.) = 0x36. 0x9, Interrupt source",
    "11.4.2 Natural Order (Hardware) Priority\n(cont.) = DMA2A. 0xA, Interrupt source = AD (ADC Conversion Complete). 0xA, Vector Number (cont.) = 0x37. 0xA, Interrupt source (cont.) = -. 0xB, Interrupt source = ACT (Active Clock Tuning). 0xB, Vector Number (cont.) = 0x38. 0xB, Interrupt source (cont.) = I2C1RX. 0xC, Interrupt source = CM1 (Comparator). 0xC, Vector Number (cont.) = 0x39. 0xC, Interrupt source (cont.) = I2C1TX. 0xD, Interrupt source = SMT1 (Signal Measurement Timer). 0xD, Vector Number (cont.) = 0x3A. 0xD, Interrupt source (cont.) = I2C1. 0xE, Interrupt source = -. 0xE, Vector Number (cont.) = 0x3B. 0xE, Interrupt source (cont.) =",
    "11.4.2 Natural Order (Hardware) Priority\nI2C1E. 0xF, Interrupt source = SMT1PWA. 0xF, Vector Number (cont.) = 0x3C. 0xF, Interrupt source (cont.) = -. 0x10, Interrupt source = ADT. 0x10, Vector Number (cont.) = 0x3D. 0x10, Interrupt source (cont.) = CLC3. 0x11 - 0x13, Interrupt source = -. 0x11 - 0x13, Vector Number (cont.) = 0x3E. 0x11 - 0x13, Interrupt source (cont.) = PWM3PR. 0x14, Interrupt source = DMA1SCNT (Direct Memory Access). 0x14, Vector Number (cont.) = 0x3F. 0x14, Interrupt source (cont.) = PWM3. 0x15, Interrupt source = DMA1DCNT. 0x15, Vector Number (cont.) = 0x40. 0x15, Interrupt source (cont.) = U2RX.",
    "11.4.2 Natural Order (Hardware) Priority\n0x16, Interrupt source = DMA1OR. 0x16, Vector Number (cont.) = 0x41. 0x16, Interrupt source (cont.) = U2TX. 0x17, Interrupt source = DMA1A. 0x17, Vector Number (cont.) = 0x42. 0x17, Interrupt source (cont.) = U2E. 0x18, Interrupt source = SPI1RX (Serial Peripheral Interface). 0x18, Vector Number (cont.) = 0x43. 0x18, Interrupt source (cont.) = U2. 0x19, Interrupt source = SPI1TX. 0x19, Vector Number (cont.) = 0x44. 0x19, Interrupt source (cont.) = -. 0x1A, Interrupt source = SPI1. 0x1A, Vector Number (cont.) = 0x45. 0x1A, Interrupt source (cont.) = CLC4. 0x1B, Interrupt source = TMR2. 0x1B, Vector Number",
    "11.4.2 Natural Order (Hardware) Priority\n(cont.) = 0x46. 0x1B, Interrupt source (cont.) = -. 0x1C, Interrupt source = TMR1. 0x1C, Vector Number (cont.) = 0x47. 0x1C, Interrupt source (cont.) = SCAN. 0x1D, Interrupt source = TMR1G. 0x1D, Vector Number (cont.) = 0x48. 0x1D, Interrupt source (cont.) = U3RX. 0x1E, Interrupt source = CCP1 (Capture/Compare/PWM). 0x1E, Vector Number (cont.) = 0x49. 0x1E, Interrupt source (cont.) = U3TX. 0x1F, Interrupt source = TMR0. 0x1F, Vector Number (cont.) = 0x4A. 0x1F, Interrupt source (cont.) = U3E. 0x20, Interrupt source = U1RX. 0x20, Vector Number",
    "11.4.2 Natural Order (Hardware) Priority\n(cont.) = 0x4B. 0x20, Interrupt source (cont.) = U3. 0x21, Interrupt source = U1TX. 0x21, Vector Number (cont.) = 0x4C. 0x21, Interrupt source (cont.) = DMA3SCNT. 0x22, Interrupt source = U1E. 0x22, Vector Number (cont.) = 0x4D. 0x22, Interrupt source (cont.) = DMA3DCNT. 0x23, Interrupt source = U1. 0x23, Vector Number (cont.) = 0x4E. 0x23, Interrupt source (cont.) = DMA3OR. 0x24, Interrupt source = TMR3. 0x24, Vector Number (cont.) = 0x4F. 0x24, Interrupt source (cont.) = DMA3A. 0x25, Interrupt source = TMR3G. 0x25, Vector Number (cont.) = 0x50. 0x25, Interrupt source",
    "11.4.2 Natural Order (Hardware) Priority\n(cont.) = INT2. 0x26, Interrupt source = PWM1PR. 0x26, Vector Number (cont.) = 0x51. 0x26, Interrupt source (cont.) = -. 0x27, Interrupt source = PWM1. 0x27, Vector Number (cont.) = 0x52. 0x27, Interrupt source (cont.) = -. 0x28, Interrupt source = SPI2RX. 0x28, Vector Number (cont.) = 0x53. 0x28, Interrupt source (cont.) = TMR4. 0x29, Interrupt source = SPI2TX. 0x29, Vector Number (cont.) = 0x54. 0x29, Interrupt source (cont.) = DMA4SCNT. 0x2A, Interrupt source = SPI2. 0x2A, Vector Number (cont.) = 0x55. 0x2A, Interrupt source (cont.) = DMA4DCNT. 0x2B, Interrupt source = -.",
    "11.4.2 Natural Order (Hardware) Priority\n0x2B, Vector Number (cont.) = 0x56. 0x2B, Interrupt source (cont.) = DMA4OR. 0x2C, Interrupt source = CM2 (Comparator). 0x2C, Vector Number (cont.) = 0x57. 0x2C, Interrupt source (cont.) = DMA4A\nThe natural order priority scheme goes from high-to-low with increasing vector numbers, with 0 being the highest priority and decreasing from there.\nFor example, when two concurrently occurring interrupt sources that are both designated high priority, using the IPRx register will be resolved using the natural order priority (i.e., the interrupt with a lower corresponding vector number will preempt the interrupt with the higher vector number).\nThe ability for the user to assign every interrupt source to high- or low-priority levels means that the user program can give an interrupt with a low natural priority, a higher overall priority level.",
    "11.5 Interrupt Operation\nAll pending interrupts are indicated by their respective flag bit being equal to a ' 1 ' in the PIRx register. All pending interrupts are resolved using the priority scheme explained in the Interrupt Priority section.\nOnce the interrupt source to be serviced is resolved, the program execution vectors to the resolved interrupt vector addresses, as explained in Interrupt Vector Table section. The vector number is also stored in the WREG register. Most of the flag bits are required to be cleared by the application software, but in some cases, device hardware clears the interrupt automatically. Some flag bits are read-only in the PIRx registers. These flags are a summary of the source interrupts, and the corresponding interrupt flags of the source must be cleared.\nA valid interrupt can be either a high- or low-priority interrupt when in the main routine or a high-priority interrupt when in a low-priority Interrupt Service Routine. Depending on the order of interrupt requests received and their relative timing, the CPU will be in a state of execution indicated by the STAT bit.\nThe state machine shown in Figure 11-1 and the subsequent sections detail the execution of interrupts when received in different orders.",
    "11.5 Interrupt Operation\nImportant: The state of GIEH/L is not changed by the hardware when servicing an interrupt. The internal state machine is used to keep track of execution states. These bits can be manipulated in the user code, resulting in transferring execution to the main routine and ignoring existing interrupts.\nFigure 11-1. Vectored Interrupts State Transition Diagram",
    "11.5.1 Serving a High- or Low-Priority Interrupt While the Main Routine Code Is Executing\nWhen a high- or low-priority interrupt is requested while the main routine code is executing, the main routine execution is halted and the ISR is addressed. Upon a return from the ISR (by executing the RETFIE instruction), the main routine resumes execution.\nFigure 11-2. Interrupt Execution: High/Low-Priority Interrupt While Executing Main Routine\nRev. 10-000267A\n9/12/2016",
    "11.5.2 Serving a High-Priority Interrupt While a Low-Priority Interrupt Is Pending\nA high-priority interrupt request will always take precedence over any interrupt of a lower priority. The high-priority interrupt is acknowledged first, then the low-priority interrupt is acknowledged. Upon a return from the high-priority ISR (by executing the RETFIE instruction), the low-priority interrupt is serviced.\nIf any other high-priority interrupts are pending and enabled, they are serviced before servicing the pending low-priority interrupt. If no other high-priority interrupt requests are active, the low-priority interrupt is serviced.\nFigure 11-3. Interrupt Execution: High-Priority Interrupt with a Low-Priority Interrupt Pending\nRev. 10-000267C\n9/12/2016\nLow Priority Interrupt\nMain Code\nMain Code Execution Halted\nLow Interrupt received\nLow ISR\nHigh ISR\nHigh ISR\nMain routine\nMain routine\nLow ISR\nHigh Priority Interrupt\nHigh Interrupt received\nRETFIE Executed\nRETFIE Executed\nHigh Interrupt cleared\nLow Interrupt\ncleared",
    "11.5.3 Preempting Low-Priority Interrupts\nLow-priority interrupts can be preempted by high-priority interrupts. While in the low-priority ISR, if a high-priority interrupt arrives, the high-priority interrupt request is generated and the low-priority ISR is suspended, while the high-priority ISR is executed.\nAfter the high-priority ISR is complete and if any other high-priority interrupt requests are not active, the execution returns to the preempted low-priority ISR.\nFigure 11-4. Interrupt Execution: High-Priority Interrupt Preempting Low-Priority Interrupts\nRev. 10-000267B\n9/12/2016\nLow Priority Interrupt\nMain Code\nMain Code Execution Halted\nLow Interrupt received\nLow ISR\nLow ISR Execution Halted\nHigh ISR\nHigh ISR\nMain routine\nMain routine\nLow ISR\nLow ISR\nHigh Priority Interrupt\nHigh Interrupt\nreceived\nLow Interrupt pending, High Interrupt received\nRETFIE Executed\nRETFIE Executed\nHigh Interrupt\ncleared\nLow Interrupt cleared",
    "11.5.4 Simultaneous High- and Low-Priority Interrupts\nWhen both high- and low-priority interrupts are active in the same instruction cycle (i.e., simultaneous interrupt events), both the high- and low-priority requests are generated. The highpriority ISR is serviced first before servicing the low-priority interrupt.\nFigure 11-5. Interrupt Execution: Simultaneous High- and Low-Priority Interrupts\nRev. 10-000267D\n9/12/2016\nLow Priority Interrupt\nMain Code\nMain Code Execution Halted\nLow Interrupt received\nLow ISR\nHigh ISR\nHigh ISR\nMain routine\nMain routine\nLow ISR\nHigh Priority Interrupt\nHigh Interrupt received\nRETFIE Executed\nRETFIE Executed\nHigh Interrupt cleared\nLow Interrupt cleared",
    "11.6 Context Saving\nThe interrupt controller supports a two-level deep context saving system (main routine context and low ISR context). Refer to the state machine shown in Figure 11-6 for details.\nThe Program Counter (PC) is saved on the dedicated device PC stack. The CPU registers saved include STATUS, WREG, BSR, FSR0/1/2, PRODL/H and PCLATH/U.\nAfter WREG has been saved to the context registers, the resolved vector number of the interrupt source to be serviced is copied into WREG. Context save and restore operation is completed by the interrupt controller based on the current state of the interrupts and the order in which they were sent to the CPU.\nContext save/restore works the same way in both states of MVECEN. When IPEN = 0 , there is only one level of interrupt active. Hence, only the main context is saved when an interrupt is received.",
    "11.6.1 Accessing Shadow Registers\nThe interrupt controller automatically saves the context information in the shadow registers. Both the saved context values (i.e., main routine and low ISR) can be accessed using the same set of shadow registers. By clearing SHADLO, the CPU register values saved for main routine context can be accessed. Low ISR context is automatically restored to the CPU registers upon exiting the high ISR. Similarly, the main context is automatically restored to the CPU registers upon exiting the low ISR.\nThe shadow registers are readable and writable, so if the user desires to modify the context, then the corresponding shadow register needs to be modified and the value will be restored when exiting the ISR. Depending on the user's application, other registers may also need to be saved.\nFigure 11-6. Context Save State Machine Diagram",
    "11.7 Returning from Interrupt Service Routine (ISR)\nThe Return from Interrupt ( RETFIE ) instruction is used to mark the end of an ISR.\nWhen the RETFIE 1 instruction is executed, the PC is loaded with the saved PC value from the top of the PC stack. Saved context is also restored with the execution of this instruction. Thus, execution returns to the state of operation that existed before the interrupt occurred.\nWhen the RETFIE 0 instruction is executed, the saved context is not restored back to the registers.",
    "11.8 Interrupt Latency\nWhen MVECEN = 1 , there is a fixed latency of three instruction cycles between the completion of the instruction active when the interrupt occurred and the first instruction of the Interrupt Service Routine. Figure 11-7, Figure 11-8 and Figure 11-9 illustrate the sequence of events when a peripheral interrupt is asserted, when the last executed instruction is one-cycle, two-cycle and three-cycle, respectively.\nAfter the Interrupt Flag Status bit is set, the current instruction completes executing. In the first latency cycle, the contents of the PC, STATUS, WREG, BSR, FSR0/1/2, PRODL/H and PCLATH/U registers are context saved, and the IVTBASE + Vector number is calculated. In the second latency cycle, the PC is loaded with the calculated vector table address for the interrupt source, and the starting address of the ISR is fetched. In the third latency cycle, the PC is loaded with the ISR address. All the latency cycles are executed as NOP instructions.",
    "11.8 Interrupt Latency\nWhen MVECEN = 0 , the interrupt controller requires two clock cycles to vector to the ISR from the main routine. Note that, as this mode requires additional software to determine which interrupt source caused the interrupt, the actual latency between the trigger and the beginning of the specific ISR for each individual interrupt will be longer than two clock cycles and will vary, when not using vectored interrupts.\nFigure 11-7. Interrupt Timing Diagram: One-Cycle Instruction\nRev. 10-000 269A\n1/4/201 9\nSystem Clock\nProgram\nCounter\nX\nX+2\nX+2\n0x82\n0x218\n0x21A\n0x21C\nInst @ X ( 1 )\nFNOP\nFNOP\nFNOP\nInst @ 0x218\nInst @ 0x21A\nInstruction Register\nInterrupt\nX+2\nFNOP\nRETFIE\nX+4\nInst @ X+2\nX+6\nInst @ X+4\nVector Number\n1\nIVTBASE\n0x80\nProgram Memory 0x82\n0x86\nInterrupt Location = Interrupt vector table entry << 2 = 0x86 << 2 = 0x218\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nRoutine\nMAIN\nMAIN\nISR",
    "11.8 Interrupt Latency\nFNOP\nFNOP\nBCF\nNote :  1. Instruction @ X is a One-cycle Instruction.",
    "Figure 11-8. Interrupt Timing Diagram: Two-Cycle Instruction\nRev. 10-000 269B\n1/4/201 9\nSystem\nClock\nProgram\nCounter\nY\nY+2\nY+2\n0x82\n0x218\n0x21A\n0x21C\nInst @ Y (\n1\n)\nFNOP\nFNOP\nFNOP\nInst @ 0x218\nInst @ 0x21A\nInstruction Register\nInterrupt\nY+2\nFNOP\nRETFIE\nY+4\nInst @ Y+2\nY+6\nInst @ Y+4\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nY+2\n11\nInst @ Y\n(\n1\n)\nRoutine\nMAIN\nMAIN\nISR\nFNOP\nFNOP\nBCF\nIVTBASE\n0x80\nVector\nNumber\nProgram Memory 0x82\n1\n0x86\nInterrupt Location = Interrupt vector table entry << 2\n= 0x86 << 2 = 0x218\nNote :  1. Instruction @ Y is a Two-cycle Instruction.\nFigure 11-9. Interrupt Timing Diagram: Three-Cycle Instruction\nIVTBASE\n0x80\nVector\nNumber\nProgram Memory 0x82\n1\n0x86\nInterrupt Location = Interrupt vector table entry << 2 = 0x86 << 2 = 0x218",
    "Figure 11-8. Interrupt Timing Diagram: Two-Cycle Instruction\nNote :  1. Instruction @ Z is a Three-cycle Instruction.",
    "11.8.1 Aborting Interrupts\nIf the last instruction before the interrupt controller vectors to the ISR from the main routine clears the GIE, PIE, or PIR bit associated with the interrupt, the controller executes one forced NOP instruction cycle before it returns to the main routine.\nFigure 11-10 illustrates the sequence of events when a peripheral interrupt is asserted and then cleared on the last executed instruction cycle.\nIf the GIE, PIE or PIR bit associated with the interrupt is cleared prior to vectoring to the ISR, then the controller continues executing the main routine.\nFigure 11-10. Interrupt Timing Diagram: Aborting Interrupts\nRev. 10-000 269D\n1/4/201 9\nInstruction\nClock\nProgram\nCounter\nX\nX+2\nX+2\nInst @ X ( 1 )\nFNOP\nInstruction\nRegister\nInterrupt\nX+4\nInst @ X+2\nX+6\nInst @ X+4\nRoutine\nMAIN\nFNOP\n1\n2\n3\n4\n5\nMAIN\nNote :  1. Inst @ X clears the interrupt flag, Example BCF INTCON0, GIE.",
    "11.9 Interrupt Setup Procedure\n- 1. When using interrupt priority levels, set IPEN and then select the user-assigned priority level for the interrupt source by writing the control bits in the appropriate IPRx control register.\nImportant: At a device Reset, the IPRx registers are initialized such that all user interrupt sources are assigned to high priority.\n2. Clear the Interrupt Flag Status bit associated with the peripheral in the associated PIRx STATUS register.\n3. Enable the interrupt source by setting the interrupt enable control bit associated with the source in the appropriate PIEx register.\n4. If the vector table is used (MVECEN = 1 ), then set up the start address for the Interrupt Vector Table using IVTBASE. See the Interrupt Vector Table Contents section for more details.\n5. Once IVTBASE is written to, set the interrupt enable bits in INTCON0.\n6. An example of setting up interrupts and ISRs can be found below.",
    "11.10 External Interrupt Pins\nDevices may have several external interrupt sources that can be assigned to pins on different ports based on PPS settings. Refer to the 'PPS - Peripheral Pin Select Module' chapter for possible routing options for these external interrupts. The external interrupt sources are edge-triggered. If the corresponding INTxEDG bit in INTCON0 is set, the interrupt is triggered by a rising edge. If the bit is clear, the trigger is on the falling edge.\nWhen a valid edge appears on the INTx pin, the corresponding flag bit (INTxF in the PIRx registers) is set. This interrupt can be disabled by clearing the corresponding enable bit, INTxE. The flag bit INTxF must be cleared by software in the Interrupt Service Routine before re-enabling the interrupt.\nAll external interrupts can wake up the processor from Idle or Sleep modes if the INTxE bit was set prior to going into those modes. If GIE/GIEH bit is set, the processor will branch to the interrupt vector following wake-up. Interrupt priority is determined by the value contained in the respective INTxIP interrupt priority bits of the IPRx registers.",
    "11.11 Wake-Up from Sleep\nThe interrupt controller provides a wake-up request to the CPU whenever an interrupt event occurs, if the interrupt event is enabled. This occurs regardless of whether the part is in Run, Idle/Doze or Sleep modes. The status of GIE/GIEH and GIEL bits have no effect on the wake-up request. This wake-up request is asynchronous to all clocks.",
    "11.12 Interrupt Compatibility\nWhen the MVECEN bit is cleared, the IVT feature is disabled, and interrupts are compatible with previous high-performance 8-bit PIC18 microcontroller devices. In this mode, the IVT priority has no effect.\nWhen IPEN is also cleared, the interrupt priority feature is disabled and interrupts are compatible with PIC16 microcontroller midrange devices. All interrupts branch to address 0008h, since the interrupt priority is disabled.",
    "11.13.1  INTCON0\nName: Address:\nINTCON0\n0x4D6",
    "Interrupt Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GIE/GIEH. , 2 = GIEL. , 3 = IPEN. , 4 = . , 5 = . , 6 = INT2EDG. , 7 = INT1EDG. , 8 = INT0EDG. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - GIE/GIEH Global Interrupt Enable\n1, Condition Description = IPEN = 0. 1, Condition Description = Enables all masked interrupts. 0, Condition Description = IPEN = 0. 0, Condition Description = Disables all interrupts. 1, Condition Description = IPEN = 1. 1, Condition Description = Enables all unmasked high-priority interrupts: The bit also needs to be set for enabling low-priority interrupts. 0, Condition Description = IPEN = 1. 0, Condition Description = Disables all interrupts",
    "Bit 6 - GIEL Global Low-Priority Interrupt Enable\nn, Condition Description = IPEN = 0. n, Condition Description = Reserved, read as ' 0 '. 1, Condition Description = IPEN = 1. 1, Condition Description = Enables all unmasked low-priority interrupts, GIEH also needs to be set for low-priority interrupts. 0, Condition Description = IPEN = 1. 0, Condition Description = Disables all low-priority interrupts",
    "Bit 5 - IPEN Interrupt Priority Enable\n1, Description = Enable priority levels on interrupts. 0, Description = Disable priority levels on interrupts, all interrupts are treated as high-priority interrupts",
    "Bit 2 - INT2EDG External Interrupt 2 Edge Select\n1, Description = Interrupt on rising edge of the INT2 pin. 0, Description = Interrupt on falling edge of the INT2 pin",
    "Bit 1 - INT1EDG External Interrupt 1 Edge Select\n1, Description = Interrupt on rising edge of the INT1 pin. 0, Description = Interrupt on falling edge of the INT1 pin",
    "Bit 0 - INT0EDG External Interrupt 0 Edge Select\n1, Description = Interrupt on rising edge of the INT0 pin. 0, Description = Interrupt on falling edge of the INT0 pin",
    "11.13.2  INTCON1\nName:\nINTCON1\nAddress:\n0x4D7",
    "Interrupt Control Register 1\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nSTAT[1:0]\nAccess Reset\nR\nR\n0\n0",
    "Bits 7:6 - STAT[1:0] Interrupt State Status\n11, Description = High-priority ISR executing, high-priority interrupt was received while a low-priority ISR was executing. 10, Description = High-priority ISR executing, high-priority interrupt was received in main routine. 01, Description = Low-priority ISR executing, low-priority interrupt was received in main routine. 00, Description = Main routine executing",
    "11.13.3  IVTBASE\nName: Address:\nIVTBASE 0x45D\nInterrupt Vector Table Base Address Register",
    "11.13.3  IVTBASE\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20.IVTBASEU[4:0] = R/W. Access, 19.IVTBASEU[4:0] = R/W. Access, 18.IVTBASEU[4:0] = R/W. Access, 17.IVTBASEU[4:0] = R/W. Access, 16.IVTBASEU[4:0] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20.IVTBASEU[4:0] = 0. Reset, 19.IVTBASEU[4:0] = 0. Reset, 18.IVTBASEU[4:0] = 0. Reset, 17.IVTBASEU[4:0] = 0. Reset, 16.IVTBASEU[4:0] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20.IVTBASEU[4:0] = 12. Bit,",
    "11.13.3  IVTBASE\n19.IVTBASEU[4:0] = 11. Bit, 18.IVTBASEU[4:0] = 10. Bit, 17.IVTBASEU[4:0] = 9. Bit, 16.IVTBASEU[4:0] = 8. , 23. = IVTBASEH[7:0]. , 22. = IVTBASEH[7:0]. , 21. = IVTBASEH[7:0]. , 20.IVTBASEU[4:0] = IVTBASEH[7:0]. , 19.IVTBASEU[4:0] = IVTBASEH[7:0]. , 18.IVTBASEU[4:0] = IVTBASEH[7:0]. , 17.IVTBASEU[4:0] = IVTBASEH[7:0]. , 16.IVTBASEU[4:0] = IVTBASEH[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access,",
    "11.13.3  IVTBASE\n20.IVTBASEU[4:0] = R/W. Access, 19.IVTBASEU[4:0] = R/W. Access, 18.IVTBASEU[4:0] = R/W. Access, 17.IVTBASEU[4:0] = R/W. Access, 16.IVTBASEU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.IVTBASEU[4:0] = 0. Reset, 19.IVTBASEU[4:0] = 0. Reset, 18.IVTBASEU[4:0] = 0. Reset, 17.IVTBASEU[4:0] = 0. Reset, 16.IVTBASEU[4:0] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20.IVTBASEU[4:0] = 4. Bit, 19.IVTBASEU[4:0] = 3. Bit,",
    "11.13.3  IVTBASE\n18.IVTBASEU[4:0] = 2. Bit, 17.IVTBASEU[4:0] = 1. Bit, 16.IVTBASEU[4:0] = 0. , 23. = IVTBASEL[7:0]. , 22. = IVTBASEL[7:0]. , 21. = IVTBASEL[7:0]. , 20.IVTBASEU[4:0] = IVTBASEL[7:0]. , 19.IVTBASEU[4:0] = IVTBASEL[7:0]. , 18.IVTBASEU[4:0] = IVTBASEL[7:0]. , 17.IVTBASEU[4:0] = IVTBASEL[7:0]. , 16.IVTBASEU[4:0] = IVTBASEL[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20.IVTBASEU[4:0] = R/W.",
    "11.13.3  IVTBASE\nAccess, 19.IVTBASEU[4:0] = R/W. Access, 18.IVTBASEU[4:0] = R/W. Access, 17.IVTBASEU[4:0] = R/W. Access, 16.IVTBASEU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.IVTBASEU[4:0] = 0. Reset, 19.IVTBASEU[4:0] = 0. Reset, 18.IVTBASEU[4:0] = 0. Reset, 17.IVTBASEU[4:0] = 0. Reset, 16.IVTBASEU[4:0] = 0\nBits 20:16 - IVTBASEU[4:0] Interrupt Vector Table Base Address Most Significant 5 bits Bits 15:8 - IVTBASEH[7:0] Interrupt Vector Table Base Address Middle 8 bits Bits 7:0 - IVTBASEL[7:0] Interrupt Vector Table Base Address Least Significant 8 bits",
    "11.13.4  IVTAD\nName: Address:\nIVTAD\n0x45A",
    "Interrupt Vector Table Address\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20.IVTADU[4:0] = R. Access, 19.IVTADU[4:0] = R. Access, 18.IVTADU[4:0] = R. Access, 17.IVTADU[4:0] = R. Access, 16.IVTADU[4:0] = R. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20.IVTADU[4:0] = 0. Reset, 19.IVTADU[4:0] = 0. Reset, 18.IVTADU[4:0] = 0. Reset, 17.IVTADU[4:0] = 0. Reset, 16.IVTADU[4:0] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20.IVTADU[4:0] = 12. Bit, 19.IVTADU[4:0] = 11. Bit, 18.IVTADU[4:0] = 10.",
    "Interrupt Vector Table Address\nBit, 17.IVTADU[4:0] = 9. Bit, 16.IVTADU[4:0] = 8. , 23. = IVTADH[7:0]. , 22. = IVTADH[7:0]. , 21. = IVTADH[7:0]. , 20.IVTADU[4:0] = IVTADH[7:0]. , 19.IVTADU[4:0] = IVTADH[7:0]. , 18.IVTADU[4:0] = IVTADH[7:0]. , 17.IVTADU[4:0] = IVTADH[7:0]. , 16.IVTADU[4:0] = IVTADH[7:0]. Access, 23. = R. Access, 22. = R. Access, 21. = R. Access, 20.IVTADU[4:0] = R. Access, 19.IVTADU[4:0] = R. Access, 18.IVTADU[4:0] = R. Access, 17.IVTADU[4:0]",
    "Interrupt Vector Table Address\n= R. Access, 16.IVTADU[4:0] = R. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.IVTADU[4:0] = 0. Reset, 19.IVTADU[4:0] = 0. Reset, 18.IVTADU[4:0] = 0. Reset, 17.IVTADU[4:0] = 0. Reset, 16.IVTADU[4:0] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20.IVTADU[4:0] = 4. Bit, 19.IVTADU[4:0] = 3. Bit, 18.IVTADU[4:0] = 2. Bit, 17.IVTADU[4:0] = 1. Bit, 16.IVTADU[4:0] = 0. , 23. = IVTADL[7:0]. , 22. = IVTADL[7:0]. , 21. = IVTADL[7:0]. ,",
    "Interrupt Vector Table Address\n20.IVTADU[4:0] = IVTADL[7:0]. , 19.IVTADU[4:0] = IVTADL[7:0]. , 18.IVTADU[4:0] = IVTADL[7:0]. , 17.IVTADU[4:0] = IVTADL[7:0]. , 16.IVTADU[4:0] = IVTADL[7:0]. Access, 23. = R. Access, 22. = R. Access, 21. = R. Access, 20.IVTADU[4:0] = R. Access, 19.IVTADU[4:0] = R. Access, 18.IVTADU[4:0] = R. Access, 17.IVTADU[4:0] = R. Access, 16.IVTADU[4:0] = R. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.IVTADU[4:0] = 0. Reset, 19.IVTADU[4:0] = 0.",
    "Interrupt Vector Table Address\nReset, 18.IVTADU[4:0] = 0. Reset, 17.IVTADU[4:0] = 0. Reset, 16.IVTADU[4:0] = 0\nBits 20:16 - IVTADU[4:0] Interrupt Vector Table Address Most Significant 5 bits Bits 15:8 - IVTADH[7:0] Interrupt Vector Table Address Middle 8 bits Bits 7:0 - IVTADL[7:0] Interrupt Vector Table Address Least Significant 8 bits",
    "11.13.5  IVTLOCK\nName:\nIVTLOCK\nAddress:\n0x459\nInterrupt Vector Table Lock Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nIVTLOCKED\nAccess Reset\nR/W\n0",
    "Bit 0 - IVTLOCKED  IVT Registers Lock\n(1,2)\n1, Description = IVTBASE Registers are locked and cannot be written. 0, Description = IVTBASE Registers can be modified by write operations",
    "Notes:\n1. The IVTLOCKED bit can only be set or cleared after the unlock sequence in Example 11-1.\n2. If IVT1WAY = 1 , the IVTLOCKED bit cannot be cleared after it has been set.",
    "11.13.6  SHADCON\nName:\nSHADCON\nAddress:\n0x376\nShadow Control Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nSHADLO\nAccess Reset\nR/W\n0",
    "Bit 0 - SHADLO Interrupt Shadow Register Access Switch\n1, Description = Access Main Context for Interrupt Shadow registers. 0, Description = Access Low-Priority Interrupt Context for Interrupt Shadow registers",
    "11.13.7  PIE0\nName: Address:\nPIE0 0x4A8",
    "Peripheral Interrupt Enable Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCIE. , 2 = CRCIE. , 3 = CLC1IE. , 4 = NVMIE. , 5 = CSWIE. , 6 = OSFIE. , 7 = HLVDIE. , 8 = SWIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - IOCIE Interrupt-on-Change Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - CRCIE CRC Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - CLC1IE CLC1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - NVMIE NVM Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - CSWIE Clock Switch Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - OSFIE Oscillator Failure Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - HLVDIE High/Low-Voltage Detect Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - SWIE Software Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.8  PIE1\nName: Address:\nPIE1 0x4A9",
    "Peripheral Interrupt Enable Register 1\n, 7 = SMT1PWAIE. , 6 = SMT1PRAIE. , 5 = SMT1IE. , 4 = CM1IE. , 3 = ACTIE. , 2 = ADIE. , 1 = ZCDIE. , 0 = INT0IE. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - SMT1PWAIE SMT1 Pulse-Width Acquisition Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - SMT1PRAIE SMT1 Period Acquisition Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - SMT1IE SMT1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - CM1IE CMP1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - ACTIE Active Clock Tuning Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - ADIE ADC Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - ZCDIE ZCD Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - INT0IE External Interrupt 0 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.9  PIE2\nName: Address:\nPIE2 0x4AA",
    "Peripheral Interrupt Enable Register 2\n, 7 = DMA1AIE. , 6 = DMA1ORIE. , 5 = DMA1DCNTIE. , 4 = DMA1SCNTIE. , 3 = . , 2 = . , 1 = . , 0 = ADTIE. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = . Access, 2 = . Access, 1 = . Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = . Reset, 2 = . Reset, 1 = . Reset, 0 = 0",
    "Bit 7 - DMA1AIE DMA1 Abort Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - DMA1ORIE DMA1 Overrun Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - DMA1DCNTIE DMA1 Destination Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - DMA1SCNTIE DMA1 Source Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - ADTIE ADC Threshold Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.10 PIE3\nName: Address:\nPIE3 0x4AB",
    "Peripheral Interrupt Enable Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR0IE. , 2 = CCP1IE. , 3 = TMR1GIE. , 4 = TMR1IE. , 5 = TMR2IE. , 6 = SPI1IE. , 7 = SPI1TXIE. , 8 = SPI1RXIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - TMR0IE TMR0 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - CCP1IE CCP1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - TMR1GIE TMR1 Gate Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - TMR1IE TMR1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - TMR2IE TMR2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - SPI1IE SPI1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - SPI1TXIE SPI1 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - SPI1RXIE SPI1 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.11 PIE4\nName: Address:\nPIE4 0x4AC",
    "Peripheral Interrupt Enable Register 4\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM1IE. , 2 = PWM1PIE. , 3 = TMR3GIE. , 4 = TMR3IE. , 5 = U1IE. , 6 = U1EIE. , 7 = U1TXIE. , 8 = U1RXIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PWM1IE PWM1 Parameter Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - PWM1PIE PWM1 Period Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - TMR3GIE TMR3 Gate Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - TMR3IE TMR3 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - U1IE UART1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - U1EIE UART1 Framing Error Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - U1TXIE UART1 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - U1RXIE UART 1 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.12 PIE5\nName: Address:\nPIE5 0x4AD",
    "Peripheral Interrupt Enable Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM2IE. , 2 = PWM2PIE. , 3 = CLC2IE. , 4 = CM2IE. , 5 = . , 6 = SPI2IE. , 7 = SPI2TXIE. , 8 = SPI2RXIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PWM2IE PWM2 Parameter Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - PWM2PIE PWM2 Period Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - CLC2IE CLC2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - CM2IE CMP2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - SPI2IE SPI2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - SPI2TXIE SPI2 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - SPI2RXIE SPI2 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.13 PIE6\nName: Address:\nPIE6 0x4AE",
    "Peripheral Interrupt Enable Register 6\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA2AIE. , 2 = DMA2ORIE. , 3 = DMA2DCNTIE. , 4 = DMA2SCNTIE. , 5 = NCO1IE. , 6 = CWG1IE. , 7 = . , 8 = INT1IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - DMA2AIE DMA2 Abort Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - DMA2ORIE DMA2 Overrun Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - DMA2DCNTIE DMA2 Destination Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - DMA2SCNTIE DMA2 Source Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - NCO1IE NCO1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - CWG1IE CWG1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - INT1IE External Interrupt 1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.14 PIE7\nName: Address:\nPIE7 0x4AF",
    "Peripheral Interrupt Enable Register 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM3IE. , 2 = PWM3PIE. , 3 = CLC3IE. , 4 = . , 5 = I2C1EIE. , 6 = I2C1IE. , 7 = I2C1TXIE. , 8 = I2C1RXIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PWM3IE PWM3 Parameter Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - PWM3PIE PWM3 Period Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - CLC3IE CLC3 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - I2C1EIE I2C1 Error Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - I2C1IE I2C1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - I2C1TXIE I2C1 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - I2C1RXIE I2C1 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.15 PIE8\nName: Address:\nPIE8 0x4B0",
    "Peripheral Interrupt Enable Register 8\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = SCANIE. , 2 = . , 3 = CLC4IE. , 4 = . , 5 = U2IE. , 6 = U2EIE U2TXIE. , 7 = U2RXIE. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bit 7 - SCANIE Memory Scanner Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - CLC4IE CLC4 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - U2IE UART2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - U2EIE UART2 Framing Error Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - U2TXIE UART2 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - U2RXIE UART2 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.16 PIE9\nName: Address:\nPIE9 0x4B1",
    "Peripheral Interrupt Enable Register 9\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA3AIE. , 2 = DMA3ORIE. , 3 = DMA3DCNTIE. , 4 = DMA3SCNTIE. , 5 = U3IE. , 6 = U3EIE. , 7 = U3TXIE. , 8 = U3RXIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA3AIE DMA3 Abort Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - DMA3ORIE DMA3 Overrun Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - DMA3DCNTIE DMA3 Destination Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - DMA3SCNTIE DMA3 Source Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - U3IE UART3 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - U3EIE UART3 Framing Error Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - U3TXIE UART3 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - U3RXIE UART3 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.17 PIE10\nName:\nPIE10\nAddress:\n0x4B2",
    "Peripheral Interrupt Enable Register 10\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA4AIE. , 2 = DMA4ORIE. , 3 = DMA4DCNTIE. , 4 = DMA4SCNTIE. , 5 = TMR4IE. , 6 = . , 7 = . , 8 = INT2IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - DMA4AIE DMA4 Abort Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - DMA4ORIE DMA4 Overrun Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - DMA4DCNTIE DMA4 Destination Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - DMA4SCNTIE DMA4 Source Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - TMR4IE TMR4 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - INT2IE External Interrupt 2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.18 PIR0\nName: Address:\nPIR0 0x4B3",
    "Peripheral Interrupt Request Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCIF. , 2 = CRCIF. , 3 = CLC1IF. , 4 = NVMIF. , 5 = CSWIF. , 6 = OSFIF. , 7 = HLVDIF. , 8 = SWIF. Access, 1 = R. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - IOCIF  Interrupt-on-Change Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 6 - CRCIF CRC Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - CLC1IF CLC1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - NVMIF NVM Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - CSWIF  Clock Switch Interrupt Flag (3)\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - OSFIF Oscillator Failure Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 1 - HLVDIF High/Low-Voltage Detect Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 0 - SWIF Software Interrupt Flag\n1, Description = Interrupt will trigger (bit is set and cleared by user software). 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software must ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. IOCIF is a read-only bit. To clear the interrupt condition, all bits in the IOCxF registers must be cleared.\n3. The CSWIF interrupt will not wake the system from Sleep. The system will sleep until another interrupt causes the wake-up.",
    "11.13.19 PIR1\nName: Address:\nPIR1 0x4B4",
    "Peripheral Interrupt Request Register 1\n, 7 = SMT1PWAIF. , 6 = SMT1PRAIF. , 5 = SMT1IF. , 4 = CM1IF. , 3 = ACTIF. , 2 = ADIF. , 1 = ZCDIF. , 0 = INT0IF. Access, 7 = R/W/HS. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = R/W/HS. Access, 3 = R/W/HS. Access, 2 = R/W/HS. Access, 1 = R/W/HS. Access, 0 = R/W/HS. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - SMT1PWAIF SMT1 Pulse-Width Acquisition Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - SMT1PRAIF SMT1 Period Acquisition Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - SMT1IF SMT1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - CM1IF CMP1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - ACTIF Active Clock Tuning Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - ADIF ADC Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 1 - ZCDIF ZCD Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 0 - INT0IF  External Interrupt 0 Interrupt Flag (2)\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software must ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. The external interrupt GPIO pin is selected by the INTxPPS register.",
    "11.13.20 PIR2\nName:\nPIR2\nAddress:\n0x4B5",
    "Peripheral Interrupt Request Register 2\n, 7 = DMA1AIF. , 6 = DMA1ORIF. , 5 = DMA1DCNTIF. , 4 = DMA1SCNTIF. , 3 = . , 2 = . , 1 = . , 0 = ADTIF. Access, 7 = R/W/HS. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = R/W/HS. Access, 3 = . Access, 2 = . Access, 1 = . Access, 0 = R/W/HS. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = . Reset, 2 = . Reset, 1 = . Reset, 0 = 0",
    "Bit 7 - DMA1AIF DMA1 Abort Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - DMA1ORIF DMA1 Overrun Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - DMA1DCNTIF DMA1 Destination Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - DMA1SCNTIF DMA1 Source Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 0 - ADTIF ADC Threshold Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Note:\n- 1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software must ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.",
    "11.13.21 PIR3\nName: Address:\nPIR3 0x4B6",
    "Peripheral Interrupt Request Register 3\n, 7 = TMR0IF. , 6 = CCP1IF. , 5 = TMR1GIF. , 4 = TMR1IF. , 3 = TMR2IF. , 2 = SPI1IF. , 1 = SPI1TXIF. , 0 = SPI1RXIF. Access, 7 = R/W/HS. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = R/W/HS. Access, 3 = R/W/HS. Access, 2 = R. Access, 1 = R. Access, 0 = R. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - TMR0IF TMR0 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - CCP1IF CCP1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - TMR1GIF TMR1 Gate Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - TMR1IF TMR1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - TMR2IF TMR2 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - SPI1IF  SPI1 Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - SPI1TXIF  SPI1 Transmit Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - SPI1RXIF  SPI1 Receive Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software must ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. SPI1IF is a read-only bit. To clear the interrupt condition, all bits in the SPI1INTF register must be cleared.\n3. SPI1TXIF and SPI1RXIF are read-only bits and cannot be set/cleared by software.",
    "11.13.22 PIR4\nName: Address:\nPIR4 0x4B7",
    "Peripheral Interrupt Request Register 4\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM1IF. , 2 = PWM1PIF. , 3 = TMR3GIF. , 4 = TMR3IF. , 5 = U1IF. , 6 = U1EIF. , 7 = U1TXIF. , 8 = U1RXIF. Access, 1 = R. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PWM1IF  PWM1 Parameter Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 6 - PWM1PIF PWM1 Period Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - TMR3GIF TMR3 Gate Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - TMR3IF TMR3 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - U1IF  UART1 Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 2 - U1EIF  UART1 Framing Error Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - U1TXIF  UART1 Transmit Interrupt Flag (5)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - U1RXIF  UART 1 Receive Interrupt Flag (5)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software must ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. PWM1IF is a read-only bit. To clear the interrupt condition, all bits in the PWM1GIR register must be cleared.\n3. U1IF is a read-only bit. To clear the interrupt condition, all bits in the U1UIR register must be cleared.\n4. U1EIF is a read-only bit. To clear the interrupt condition, all bits in the U1ERR register must be cleared.\n5. U1TXIF and U1RXIF are read-only bits and cannot be set/cleared by software.",
    "11.13.23 PIR5\nName: Address:\nPIR5 0x4B8",
    "Peripheral Interrupt Request Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM2IF. , 2 = PWM2PIF. , 3 = CLC2IF. , 4 = CM2IF. , 5 = . , 6 = SPI2IF. , 7 = SPI2TXIF. , 8 = SPI2RXIF. Access, 1 = R. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = . Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PWM2IF  PWM2 Parameter Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 6 - PWM2PIF PWM2 Period Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - CLC2IF CLC2 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - CM2IF CMP2 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - SPI2IF  SPI2 Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - SPI2TXIF  SPI2 Transmit Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - SPI2RXIF  SPI2 Receive Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software must ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. PWM2IF is a read-only bit. To clear the interrupt condition, all bits in the PWM2GIR register must be cleared.\n3. SPI2IF is a read-only bit. To clear the interrupt condition, all bits in the SPI2INTF register must be cleared.\n4. SPI2TXIF and SPI2RXIF are read-only bits and cannot be set/cleared by software.",
    "11.13.24 PIR6\nName: Address:\nPIR6 0x4B9",
    "Peripheral Interrupt Request Register 6\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA2AIF. , 2 = DMA2ORIF. , 3 = DMA2DCNTIF. , 4 = DMA2SCNTIF. , 5 = NCO1IF. , 6 = CWG1IF. , 7 = . , 8 = INT1IF. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = . Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - DMA2AIF DMA2 Abort Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - DMA2ORIF DMA2 Overrun Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - DMA2DCNTIF DMA2 Destination Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - DMA2SCNTIF DMA2 Source Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - NCO1IF NCO1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - CWG1IF CWG1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 0 - INT1IF External Interrupt 1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Note:\n- 1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software must ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.",
    "11.13.25 PIR7\nName: Address:\nPIR7 0x4BA",
    "Peripheral Interrupt Request Register 7\n, 7 = PWM3IF. , 6 = PWM3PIF. , 5 = CLC3IF. , 4 = . , 3 = I2C1EIF. , 2 = I2C1IF. , 1 = I2C1TXIF. , 0 = I2C1RXIF. Access, 7 = R. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = . Access, 3 = R. Access, 2 = R. Access, 1 = R. Access, 0 = R. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = . Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - PWM3IF  PWM3 Parameter Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 6 - PWM3PIF PWM3 Period Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - CLC3IF CLC3 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - I2C1EIF  I2C1 Error Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 2 - I2C1IF  I2C1 Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - I2C1TXIF  I2C1 Transmit Interrupt Flag (5)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - I2C1RXIF  I2C1 Receive Interrupt Flag (5)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software must ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. PWM3IF is a read-only bit. To clear the interrupt condition, all bits in the PWM3GIR register must be cleared.\n3. I2C1EIF is a read-only bit. To clear the interrupt condition, all bits in the I2C1ERR register must be cleared.\n4. I2C1IF is a read-only bit. To clear the interrupt condition, all bits in the I2C1PIR register must be cleared.\n5. I2C1TXIF and I2C1RXIF are read-only bits. To clear the interrupt condition, the CLRBF bit in I2C1STAT1 must be set.",
    "11.13.26 PIR8\nName:\nPIR8 0x4BB\nAddress:",
    "Peripheral Interrupt Request Register 8\n, 7 = SCANIF. , 6 = . , 5 = CLC4IF. , 4 = . , 3 = U2IF. , 2 = U2EIF. , 1 = U2TXIF. , 0 = U2RXIF. Access, 7 = R/W/HS. Access, 6 = . Access, 5 = R/W/HS. Access, 4 = . Access, 3 = R. Access, 2 = R. Access, 1 = R. Access, 0 = R. Reset, 7 = 0. Reset, 6 = . Reset, 5 = 0. Reset, 4 = . Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - SCANIF Memory Scanner Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - CLC4IF CLC4 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - U2IF  UART2 Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 2 - U2EIF  UART2 Framing Error Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - U2TXIF  UART2 Transmit Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - U2RXIF  UART2 Receive Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software must ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. U2IF is a read-only bit. To clear the interrupt condition, all bits in the U2UIR register must be cleared.\n3. U2EIF is a read-only bit. To clear the interrupt condition, all bits in the U2ERR register must be cleared.\n4. U2TXIF and U2RXIF are read-only bits and cannot be set/cleared by software.",
    "11.13.27 PIR9\nName: Address:\nPIR9 0x4BC",
    "Peripheral Interrupt Request Register 9\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA3AIF. , 2 = DMA3ORIF. , 3 = DMA3DCNTIF. , 4 = DMA3SCNTIF. , 5 = U3IF. , 6 = U3EIF. , 7 = U3TXIF. , 8 = U3RXIF. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA3AIF DMA3 Abort Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - DMA3ORIF DMA3 Overrun Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - DMA3DCNTIF DMA3 Destination Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - DMA3SCNTIF DMA3 Source Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - U3IF  UART3 Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 2 - U3EIF  UART3 Framing Error Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - U3TXIF  UART3 Transmit Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - U3RXIF  UART3 Receive Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software must ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. U3IF is a read-only bit. To clear the interrupt condition, all bits in the U3UIR register must be cleared.\n3. U3EIF is a read-only bit. To clear the interrupt condition, all bits in the U3ERR register must be cleared.\n4. U3TXIF and U3RXIF are read-only bits and cannot be set/cleared by software.",
    "11.13.28 PIR10\nName:\nPIR10\nAddress:\n0x4BD",
    "Peripheral Interrupt Request Register 10\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA4AIF. , 2 = DMA4ORIF. , 3 = DMA4DCNTIF. , 4 = DMA4SCNTIF. , 5 = TMR4IF. , 6 = . , 7 = . , 8 = INT2IF. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = . Access, 7 = . Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - DMA4AIF DMA4 Abort Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - DMA4ORIF DMA4 Overrun Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - DMA4DCNTIF DMA4 Destination Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - DMA4SCNTIF DMA4 Source Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - TMR4IF TMR4 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 0 - INT2IF External Interrupt 2 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Note:\n- 1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit, or the global enable bit. User software must ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.",
    "11.13.29 IPR0\nName:\nIPR0\nAddress:\n0x367",
    "Peripheral Interrupt Request Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCIP. , 2 = CRCIP. , 3 = CLC1IP. , 4 = NVMIP. , 5 = CSWIP. , 6 = OSFIP. , 7 = HLVDIP. , 8 = SWIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 0. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - IOCIP Interrupt-on-Change Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - CRCIP CRC Interrupt Priority\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - CLC1IP CLC1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - NVMIP NVM Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - CSWIP Clock Switch Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - OSFIP Oscillator Failure Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - HLVDIP High/Low-Voltage Detect Priority Flag\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - SWIP Software Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.30 IPR1\nName:\nIPR1\nAddress:\n0x368\nPeripheral Interrupt Priority Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SMT1PWAIP. , 2 = SMT1PRAIP. , 3 = SMT1IP. , 4 = CM1IP. , 5 = ACTIP. , 6 = ADIP. , 7 = ZCDIP. , 8 = INT0IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - SMT1PWAIP SMT1 Pulse-Width Acquisition Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - SMT1PRAIP SMT1 Period Acquisition Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - SMT1IP SMT1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - CM1IP CMP1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - ACTIP Active Clock Tuning Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - ADIP ADC Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - ZCDIP ZCD Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - INT0IP External Interrupt 0 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.31 IPR2\nName:\nIPR2\nAddress:\n0x369",
    "Peripheral Interrupt Priority Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA1AIP. , 2 = DMA1ORIP. , 3 = DMA1DCNTIPDMA1SCNTIP. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = ADTIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 1",
    "Bit 7 - DMA1AIP DMA1 Abort Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - DMA1ORIP DMA1 Overrun Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - DMA1DCNTIP DMA1 Destination Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - DMA1SCNTIP DMA1 Source Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - ADTIP ADC Threshold Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.32 IPR3\nName: Address:\nIPR3 0x36A",
    "Peripheral Interrupt Priority Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR0IP. , 2 = CCP1IP. , 3 = TMR1GIP. , 4 = TMR1IP. , 5 = TMR2IP. , 6 = SPI1IP. , 7 = SPI1TXIP. , 8 = SPI1RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - TMR0IP TMR0 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - CCP1IP CCP1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - TMR1GIP TMR1 Gate Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - TMR1IP TMR1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - TMR2IP TMR2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - SPI1IP SPI1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - SPI1TXIP SPI1 Transmit Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - SPI1RXIP SPI1 Receive Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.33 IPR4\nName:\nIPR4\nAddress:\n0x36B",
    "Peripheral Interrupt Priority Register 4\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM1IP. , 2 = PWM1PIP. , 3 = TMR3GIP. , 4 = TMR3IP. , 5 = U1IP. , 6 = U1EIP. , 7 = U1TXIP. , 8 = U1RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - PWM1IP PWM1 Parameter Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - PWM1PIP PWM1 Period Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - TMR3GIP TMR3 Gate Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - TMR3IP TMR3 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - U1IP UART1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - U1EIP UART1 Framing Error Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - U1TXIP UART1 Transmit Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - U1RXIP UART 1 Receive Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.34 IPR5\nName: Address:\nIPR5 0x36C",
    "Peripheral Interrupt Priority Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM2IP. , 2 = PWM2PIP. , 3 = CLC2IP. , 4 = CMIP. , 5 = . , 6 = SPI2IP. , 7 = SPI2TXIP. , 8 = SPI2RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - PWM2IP PWM2 Parameter Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - PWM2PIP PWM2 Period Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - CLC2IP CLC2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - CMIP CMP2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - SPI2IP SPI2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - SPI2TXIP SPI2 Transmit Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - SPI2RXIP SPI2 Receive Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.35 IPR6\nName:\nIPR6 0x36D\nAddress:",
    "Peripheral Interrupt Priority Register 6\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA2AIP. , 2 = DMA2ORIP. , 3 = . , 4 = DMA2DCNTIPDMA2SCNTIP. , 5 = NCO1IP. , 6 = CWG1IP. , 7 = . , 8 = INT1IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = . Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = . Reset, 8 = 1",
    "Bit 7 - DMA2AIP DMA2 Abort Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - DMA2ORIP DMA2 Overrun Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - DMA2DCNTIP DMA2 Destination Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - DMA2SCNTIP DMA2 Source Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - NCO1IP NCO1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - CWG1IP CWG1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - INT1IP External Interrupt 1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.36 IPR7\nName: Address:\nIPR7 0x36E",
    "Peripheral Interrupt Priority Register 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM3IP. , 2 = PWM3PIP. , 3 = CLC3IP. , 4 = . , 5 = I2C1EIP. , 6 = I2C1IP. , 7 = I2C1TXIP. , 8 = I2C1RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = . Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - PWM3IP PWM3 Parameter Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - PWM3PIP PWM3 Period Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - CLC3IP CLC3 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - I2C1EIP I2C1 Error Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - I2C1IP I2C1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - I2C1TXIP I2C1 Transmit Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - I2C1RXIP I2C1 Receive Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.37 IPR8\nName:\nIPR8\nAddress:\n0x36F",
    "Peripheral Interrupt Priority Register 8\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SCANIP. , 2 = . , 3 = CLC4IP. , 4 = . , 5 = U2IP. , 6 = U2EIP. , 7 = U2TXIP. , 8 = U2RXIP. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = . Reset, 3 = 1. Reset, 4 = . Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - SCANIP Memory Scanner Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - CLC4IP CLC4 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - U2IP UART2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - U2EIP UART2 Framing Error Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - U2TXIP UART2 Transmit Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - U2RXIP UART2 Receive Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.38 IPR9\nName:\nIPR9\nAddress:\n0x370",
    "Peripheral Interrupt Priority Register 9\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA3AIP. , 2 = DMA3ORIP. , 3 = . , 4 = DMA3DCNTIPDMA3SCNTIP. , 5 = U3IP. , 6 = U3EIP. , 7 = U3TXIP. , 8 = U3RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - DMA3AIP DMA3 Abort Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - DMA3ORIP DMA3 Overrun Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - DMA3DCNTIP DMA3 Destination Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - DMA3SCNTIP DMA3 Source Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - U3IP UART3 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - U3EIP UART3 Framing Error Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - U3TXIP UART3 Transmit Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - U3RXIP UART3 Receive Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.39 IPR10\nName:\nIPR10\nAddress:\n0x371",
    "Peripheral Interrupt Priority Register 10\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA4AIP. , 2 = DMA4ORIP. , 3 = . , 4 = DMA4DCNTIPDMA4SCNTIP. , 5 = TMR4IP. , 6 = . , 7 = . , 8 = INT2IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = . Reset, 7 = . Reset, 8 = 1",
    "Bit 7 - DMA4AIP DMA4 Abort Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - DMA4ORIP DMA Overrun Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - DMA4DCNTIP DMA4 Destination Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - DMA4SCNTIP DMA4 Source Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - TMR4IP TMR4 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - INT2IP External Interrupt 2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.14 Register Summary - Interrupts\n0x00 ..., Name = Reserved. 0x00 ..., Bit Pos. = . 0x00 ..., 7 = . 0x00 ..., 6 = . 0x00 ..., 5 = . 0x00 ..., 4 = . 0x00 ..., 3 = . 0x00 ..., 2 = . 0x00 ..., 1 = . 0x00 ..., 0 = . 0x0366 0x0367, Name = IPR0. 0x0366 0x0367, Bit Pos. = 7:0. 0x0366 0x0367, 7 = IOCIP. 0x0366 0x0367, 6 = CRCIP. 0x0366 0x0367, 5 = CLC1IP. 0x0366 0x0367, 4 = NVMIP. 0x0366 0x0367, 3 = CSWIP. 0x0366 0x0367, 2 = OSFIP.",
    "11.14 Register Summary - Interrupts\n0x0366 0x0367, 1 = HLVDIP. 0x0366 0x0367, 0 = SWIP. 0x0368, Name = IPR1. 0x0368, Bit Pos. = 7:0. 0x0368, 7 = SMT1PWAIP. 0x0368, 6 = SMT1PRAIP. 0x0368, 5 = SMT1IP. 0x0368, 4 = CM1IP. 0x0368, 3 = ACTIP. 0x0368, 2 = ADIP. 0x0368, 1 = ZCDIP. 0x0368, 0 = INT0IP. 0x0369, Name = IPR2. 0x0369, Bit Pos. = 7:0. 0x0369, 7 = DMA1AIP. 0x0369, 6 = DMA1ORIP. 0x0369, 5 = DMA1DCNTIP. 0x0369, 4 = DMA1SCNTIP.",
    "11.14 Register Summary - Interrupts\n0x0369, 3 = . 0x0369, 2 = . 0x0369, 1 = . 0x0369, 0 = ADTIP. 0x036A, Name = IPR3. 0x036A, Bit Pos. = 7:0. 0x036A, 7 = TMR0IP. 0x036A, 6 = CCP1IP. 0x036A, 5 = TMR1GIP. 0x036A, 4 = TMR1IP. 0x036A, 3 = TMR2IP. 0x036A, 2 = SPI1IP. 0x036A, 1 = SPI1TXIP. 0x036A, 0 = SPI1RXIP. 0x036B, Name = IPR4. 0x036B, Bit Pos. = 7:0. 0x036B, 7 = PWM1IP. 0x036B, 6 = PWM1PIP. 0x036B, 5 =",
    "11.14 Register Summary - Interrupts\nTMR3GIP. 0x036B, 4 = TMR3IP. 0x036B, 3 = U1IP. 0x036B, 2 = U1EIP. 0x036B, 1 = U1TXIP. 0x036B, 0 = U1RXIP. 0x036C, Name = IPR5. 0x036C, Bit Pos. = 7:0. 0x036C, 7 = PWM2IP. 0x036C, 6 = PWM2PIP. 0x036C, 5 = CLC2IP. 0x036C, 4 = CMIP. 0x036C, 3 = . 0x036C, 2 = SPI2IP. 0x036C, 1 = SPI2TXIP. 0x036C, 0 = SPI2RXIP. 0x036D, Name = IPR6. 0x036D, Bit Pos. = 7:0. 0x036D, 7 = DMA2AIP.",
    "11.14 Register Summary - Interrupts\n0x036D, 6 = DMA2ORIP. 0x036D, 5 = DMA2DCNTIP. 0x036D, 4 = DMA2SCNTIP. 0x036D, 3 = NCO1IP. 0x036D, 2 = CWG1IP. 0x036D, 1 = . 0x036D, 0 = INT1IP. 0x036E, Name = IPR7. 0x036E, Bit Pos. = 7:0. 0x036E, 7 = PWM3IP. 0x036E, 6 = PWM3PIP. 0x036E, 5 = CLC3IP. 0x036E, 4 = . 0x036E, 3 = I2C1EIP. 0x036E, 2 = I2C1IP. 0x036E, 1 = I2C1TXIP. 0x036E, 0 = I2C1RXIP. 0x036F, Name = IPR8. 0x036F,",
    "11.14 Register Summary - Interrupts\nBit Pos. = 7:0. 0x036F, 7 = SCANIP. 0x036F, 6 = . 0x036F, 5 = CLC4IP. 0x036F, 4 = . 0x036F, 3 = U2IP. 0x036F, 2 = U2EIP. 0x036F, 1 = U2TXIP. 0x036F, 0 = U2RXIP. 0x0370, Name = IPR9. 0x0370, Bit Pos. = 7:0. 0x0370, 7 = DMA3AIP. 0x0370, 6 = DMA3ORIP. 0x0370, 5 = DMA3DCNTIP. 0x0370, 4 = DMA3SCNTIP. 0x0370, 3 = U3IP. 0x0370, 2 = U3EIP. 0x0370, 1 = U3TXIP. 0x0370, 0 = U3RXIP. 0x0371, Name =",
    "11.14 Register Summary - Interrupts\nIPR10. 0x0371, Bit Pos. = 7:0. 0x0371, 7 = DMA4AIP. 0x0371, 6 = DMA4ORIP. 0x0371, 5 = DMA4DCNTIP. 0x0371, 4 = DMA4SCNTIP. 0x0371, 3 = TMR4IP. 0x0371, 2 = . 0x0371, 1 = . 0x0371, 0 = INT2IP. 0x0372, Name = . 0x0372, Bit Pos. = . 0x0372, 7 = . 0x0372, 6 = . 0x0372, 5 = . 0x0372, 4 = . 0x0372, 3 = . 0x0372, 2 = . 0x0372, 1 = . 0x0372, 0 = . ... 0x0375, Name = Reserved. ... 0x0375, Bit Pos. = . ...",
    "11.14 Register Summary - Interrupts\n0x0375, 7 = . ... 0x0375, 6 = . ... 0x0375, 5 = . ... 0x0375, 4 = . ... 0x0375, 3 = . ... 0x0375, 2 = . ... 0x0375, 1 = . ... 0x0375, 0 = . 0x0376, Name = SHADCON. 0x0376, Bit Pos. = 7:0. 0x0376, 7 = . 0x0376, 6 = . 0x0376, 5 = . 0x0376, 4 = . 0x0376, 3 = . 0x0376, 2 = . 0x0376, 1 = . 0x0376, 0 = SHADLO. 0x0377 ..., Name = Reserved. 0x0377 ..., Bit Pos. = . 0x0377 ..., 7 = . 0x0377 ..., 6 = .",
    "11.14 Register Summary - Interrupts\n0x0377 ..., 5 = . 0x0377 ..., 4 = . 0x0377 ..., 3 = . 0x0377 ..., 2 = . 0x0377 ..., 1 = . 0x0377 ..., 0 = . 0x0458, Name = . 0x0458, Bit Pos. = . 0x0458, 7 = . 0x0458, 6 = . 0x0458, 5 = . 0x0458, 4 = . 0x0458, 3 = . 0x0458, 2 = . 0x0458, 1 = . 0x0458, 0 = . 0x0459, Name = IVTLOCK. 0x0459, Bit Pos. = 7:0. 0x0459, 7 = . 0x0459, 6 = . 0x0459, 5 = . 0x0459, 4 = . 0x0459, 3 = . 0x0459, 2 = .",
    "11.14 Register Summary - Interrupts\n0x0459, 1 = . 0x0459, 0 = IVTLOCKED. 0x045A, Name = IVTAD. 0x045A, Bit Pos. = 7:0 15:8 23:16. 0x045A, 7 = . 0x045A, 6 = . 0x045A, 5 = . 0x045A, 4 = IVTADH[7:0]. 0x045A, 3 = IVTADL[7:0]. 0x045A, 2 = IVTADU[4:0]. 0x045A, 1 = . 0x045A, 0 = . 0x045D, Name = IVTBASE. 0x045D, Bit Pos. = 7:0 15:8. 0x045D, 7 = . 0x045D, 6 = . 0x045D, 5 = . 0x045D, 4 = IVTBASEL[7:0]. 0x045D, 3 = . 0x045D, 2 = .",
    "11.14 Register Summary - Interrupts\n0x045D, 1 = . 0x045D, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = IVTBASEH[7:0]. , 3 = . , 2 = IVTBASEU[4:0]. , 1 = . , 0 = . 0x0460 ..., Name = Reserved. 0x0460 ..., Bit Pos. = . 0x0460 ..., 7 = . 0x0460 ..., 6 = . 0x0460 ..., 5 = . 0x0460 ..., 4 = . 0x0460 ..., 3 = . 0x0460 ..., 2 = . 0x0460 ..., 1 = . 0x0460 ..., 0 = . 0x04A8, Name = PIE0. 0x04A8, Bit Pos. = 7:0. 0x04A8, 7 = IOCIE.",
    "11.14 Register Summary - Interrupts\n0x04A8, 6 = CRCIE. 0x04A8, 5 = CLC1IE. 0x04A8, 4 = NVMIE. 0x04A8, 3 = CSWIE. 0x04A8, 2 = OSFIE. 0x04A8, 1 = HLVDIE. 0x04A8, 0 = SWIE. 0x04A9, Name = PIE1. 0x04A9, Bit Pos. = 7:0. 0x04A9, 7 = SMT1PWAIE. 0x04A9, 6 = SMT1PRAIE. 0x04A9, 5 = SMT1IE. 0x04A9, 4 = CM1IE. 0x04A9, 3 = ACTIE. 0x04A9, 2 = ADIE. 0x04A9, 1 = ZCDIE. 0x04A9, 0 = INT0IE. 0x04AA, Name = PIE2. 0x04AA, Bit",
    "11.14 Register Summary - Interrupts\nPos. = 7:0. 0x04AA, 7 = DMA1AIE. 0x04AA, 6 = DMA1ORIE. 0x04AA, 5 = DMA1DCNTIE. 0x04AA, 4 = DMA1SCNTIE. 0x04AA, 3 = . 0x04AA, 2 = . 0x04AA, 1 = . 0x04AA, 0 = ADTIE. 0x04AB, Name = PIE3. 0x04AB, Bit Pos. = 7:0. 0x04AB, 7 = TMR0IE. 0x04AB, 6 = CCP1IE. 0x04AB, 5 = TMR1GIE. 0x04AB, 4 = TMR1IE. 0x04AB, 3 = TMR2IE. 0x04AB, 2 = SPI1IE. 0x04AB, 1 = SPI1TXIE. 0x04AB, 0 = SPI1RXIE. 0x04AC, Name =",
    "11.14 Register Summary - Interrupts\nPIE4. 0x04AC, Bit Pos. = 7:0. 0x04AC, 7 = PWM1IE. 0x04AC, 6 = PWM1PIE. 0x04AC, 5 = TMR3GIE. 0x04AC, 4 = TMR3IE. 0x04AC, 3 = U1IE. 0x04AC, 2 = U1EIE. 0x04AC, 1 = U1TXIE. 0x04AC, 0 = U1RXIE. 0x04AD, Name = PIE5. 0x04AD, Bit Pos. = 7:0. 0x04AD, 7 = PWM2IE. 0x04AD, 6 = PWM2PIE. 0x04AD, 5 = CLC2IE. 0x04AD, 4 = CM2IE. 0x04AD, 3 = . 0x04AD, 2 = SPI2IE. 0x04AD, 1 = SPI2TXIE. 0x04AD, 0 =",
    "11.14 Register Summary - Interrupts\nSPI2RXIE. 0x04AE, Name = PIE6. 0x04AE, Bit Pos. = 7:0. 0x04AE, 7 = DMA2AIE. 0x04AE, 6 = DMA2ORIE. 0x04AE, 5 = DMA2DCNTIE. 0x04AE, 4 = DMA2SCNTIE. 0x04AE, 3 = NCO1IE. 0x04AE, 2 = CWG1IE. 0x04AE, 1 = . 0x04AE, 0 = INT1IE. 0x04AF 0x04B0, Name = PIE7 PIE8. 0x04AF 0x04B0, Bit Pos. = 7:0 7:0. 0x04AF 0x04B0, 7 = PWM3IE SCANIE. 0x04AF 0x04B0, 6 = PWM3PIE. 0x04AF 0x04B0, 5 = CLC3IE CLC4IE.",
    "11.14 Register Summary - Interrupts\n0x04AF 0x04B0, 4 = . 0x04AF 0x04B0, 3 = I2C1EIE U2IE. 0x04AF 0x04B0, 2 = I2C1IE U2EIE. 0x04AF 0x04B0, 1 = I2C1TXIE. 0x04AF 0x04B0, 0 = I2C1RXIE. , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = U2TXIE. , 0 = U2RXIE. 0x04B1, Name = PIE9. 0x04B1, Bit Pos. = 7:0. 0x04B1, 7 = DMA3AIE. 0x04B1, 6 = DMA3ORIE. 0x04B1, 5 = DMA3DCNTIE. 0x04B1, 4 = DMA3SCNTIE.",
    "11.14 Register Summary - Interrupts\n0x04B1, 3 = U3IE. 0x04B1, 2 = U3EIE. 0x04B1, 1 = U3TXIE. 0x04B1, 0 = U3RXIE. 0x04B2, Name = PIE10. 0x04B2, Bit Pos. = 7:0. 0x04B2, 7 = DMA4AIE. 0x04B2, 6 = DMA4ORIE. 0x04B2, 5 = DMA4DCNTIE. 0x04B2, 4 = DMA4SCNTIE. 0x04B2, 3 = TMR4IE. 0x04B2, 2 = . 0x04B2, 1 = . 0x04B2, 0 = INT2IE. 0x04B3, Name = PIR0. 0x04B3, Bit Pos. = 7:0. 0x04B3, 7 = IOCIF. 0x04B3, 6 = CRCIF.",
    "11.14 Register Summary - Interrupts\n0x04B3, 5 = CLC1IF. 0x04B3, 4 = NVMIF. 0x04B3, 3 = CSWIF. 0x04B3, 2 = OSFIF. 0x04B3, 1 = HLVDIF. 0x04B3, 0 = SWIF. 0x04B4, Name = PIR1. 0x04B4, Bit Pos. = 7:0. 0x04B4, 7 = SMT1PWAIF. 0x04B4, 6 = SMT1PRAIF. 0x04B4, 5 = SMT1IF. 0x04B4, 4 = CM1IF. 0x04B4, 3 = ACTIF. 0x04B4, 2 = ADIF. 0x04B4, 1 = ZCDIF. 0x04B4, 0 = INT0IF. 0x04B5, Name = PIR2. 0x04B5, Bit Pos. = 7:0.",
    "11.14 Register Summary - Interrupts\n0x04B5, 7 = DMA1AIF. 0x04B5, 6 = DMA1ORIF. 0x04B5, 5 = DMA1DCNTIF. 0x04B5, 4 = DMA1SCNTIF. 0x04B5, 3 = . 0x04B5, 2 = . 0x04B5, 1 = . 0x04B5, 0 = ADTIF. 0x04B6, Name = PIR3. 0x04B6, Bit Pos. = 7:0. 0x04B6, 7 = TMR0IF. 0x04B6, 6 = CCP1IF. 0x04B6, 5 = TMR1GIF. 0x04B6, 4 = TMR1IF. 0x04B6, 3 = TMR2IF. 0x04B6, 2 = SPI1IF. 0x04B6, 1 = SPI1TXIF. 0x04B6, 0 =",
    "11.14 Register Summary - Interrupts\nSPI1RXIF. 0x04B7, Name = PIR4. 0x04B7, Bit Pos. = 7:0. 0x04B7, 7 = PWM1IF. 0x04B7, 6 = PWM1PIF. 0x04B7, 5 = TMR3GIF. 0x04B7, 4 = TMR3IF. 0x04B7, 3 = U1IF. 0x04B7, 2 = U1EIF. 0x04B7, 1 = U1TXIF. 0x04B7, 0 = U1RXIF. 0x04B8 0x04B9, Name = PIR5. 0x04B8 0x04B9, Bit Pos. = 7:0 7:0. 0x04B8 0x04B9, 7 = PWM2IF. 0x04B8 0x04B9, 6 = PWM2PIF. 0x04B8",
    "11.14 Register Summary - Interrupts\n0x04B9, 5 = CLC2IF. 0x04B8 0x04B9, 4 = CM2IF. 0x04B8 0x04B9, 3 = . 0x04B8 0x04B9, 2 = SPI2IF. 0x04B8 0x04B9, 1 = SPI2TXIF. 0x04B8 0x04B9, 0 = SPI2RXIF. , Name = PIR6. , Bit Pos. = . , 7 = DMA2AIF. , 6 = DMA2ORIF. , 5 = DMA2DCNTIF. , 4 = DMA2SCNTIF. , 3 = NCO1IF. , 2 = CWG1IF. , 1 = . , 0 = INT1IF. 0x04BA, Name = PIR7. 0x04BA, Bit Pos. = 7:0. 0x04BA, 7 = PWM3IF. 0x04BA, 6 = PWM3PIF.",
    "11.14 Register Summary - Interrupts\n0x04BA, 5 = CLC3IF. 0x04BA, 4 = . 0x04BA, 3 = I2C1EIF. 0x04BA, 2 = I2C1IF. 0x04BA, 1 = I2C1TXIF. 0x04BA, 0 = I2C1RXIF. 0x04BB, Name = PIR8. 0x04BB, Bit Pos. = 7:0. 0x04BB, 7 = SCANIF. 0x04BB, 6 = . 0x04BB, 5 = CLC4IF. 0x04BB, 4 = . 0x04BB, 3 = U2IF. 0x04BB, 2 = U2EIF. 0x04BB, 1 = U2TXIF. 0x04BB, 0 = U2RXIF. 0x04BC, Name = PIR9. 0x04BC, Bit Pos. = . 0x04BC, 7 = DMA3AIF. 0x04BC, 6 =",
    "11.14 Register Summary - Interrupts\nDMA3ORIF. 0x04BC, 5 = DMA3DCNTIF. 0x04BC, 4 = DMA3SCNTIF. 0x04BC, 3 = U3IF. 0x04BC, 2 = U3EIF. 0x04BC, 1 = U3TXIF. 0x04BC, 0 = U3RXIF. 0x04BD, Name = PIR10. 0x04BD, Bit Pos. = 7:0 7:0. 0x04BD, 7 = DMA4AIF. 0x04BD, 6 = DMA4ORIF. 0x04BD, 5 = DMA4DCNTIF. 0x04BD, 4 = DMA4SCNTIF. 0x04BD, 3 = TMR4IF. 0x04BD, 2 = . 0x04BD, 1 = . 0x04BD, 0 = INT2IF. 0x04BE, Name = . 0x04BE, Bit",
    "11.14 Register Summary - Interrupts\nPos. = . 0x04BE, 7 = . 0x04BE, 6 = . 0x04BE, 5 = . 0x04BE, 4 = . 0x04BE, 3 = . 0x04BE, 2 = . 0x04BE, 1 = . 0x04BE, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x04D5 0x04D6, Name = INTCON0. 0x04D5 0x04D6, Bit Pos. = 7:0. 0x04D5 0x04D6, 7 = GIE/GIEH. 0x04D5 0x04D6, 6 = GIEL. 0x04D5 0x04D6, 5 =",
    "11.14 Register Summary - Interrupts\nIPEN. 0x04D5 0x04D6, 4 = . 0x04D5 0x04D6, 3 = . 0x04D5 0x04D6, 2 = INT2EDG. 0x04D5 0x04D6, 1 = INT1EDG. 0x04D5 0x04D6, 0 = INT0EDG. 0x04D7, Name = INTCON1. 0x04D7, Bit Pos. = 7:0. 0x04D7, 7 = STAT[1:0]. 0x04D7, 6 = . 0x04D7, 5 = . 0x04D7, 4 = . 0x04D7, 3 = . 0x04D7, 2 = . 0x04D7, 1 = . 0x04D7, 0 = ",
    "12. OSC - Oscillator Module (With Fail-Safe Clock Monitor)\nThe oscillator module contains multiple clock sources and selection features that allow it to be used in a wide range of applications while maximizing performance and minimizing power consumption.\nClock sources can be supplied either internally or externally. External sources include:\n\u00b7 External clock oscillators\n\u00b7 Quartz crystal resonators\n\u00b7 Ceramic resonators\n\u00b7 Secondary Oscillator (SOSC)\nInternal sources include:\n\u00b7 High-Frequency Internal Oscillator (HFINTOSC)\n\u00b7 Low-Frequency Internal Oscillator (LFINTOSC)\n\u00b7 Analog-to-Digital Converter RC Oscillator (ADCRC)\nSpecial features of the oscillator module include:",
    "12. OSC - Oscillator Module (With Fail-Safe Clock Monitor)\n\u00b7 Oscillator Start-up Timer (OST): Ensures stability of quartz crystal or ceramic resonators\n\u00b7 4x Phase-Locked Loop (PLL): Frequency multiplier for external clock sources\n\u00b7 HFINTOSC Frequency Adjustment: Provides the ability to adjust the HFINTOSC frequency\n\u00b7 Clock switching: Allows the system clock to switch between internal or external sources via software during run time\n\u00b7 Fail-Safe Clock Monitor (FSCM): Designed to detect a failure of the system clock (F OSC), primary external clock (EXTOSC) or secondary external clock (SOSC) sources. The FSCM automatically switches to an internal clock source upon detection of a F OSC failure.\nThe Reset Oscillator (RSTOSC) Configuration bits determine the type of oscillator that will be used when the device runs after a Reset, including when the device is first powered up (see the table below).\n\nTable 12-1. RSTOSC Selection Table",
    "12. OSC - Oscillator Module (With Fail-Safe Clock Monitor)\n111, SFR Reset Values.NOSC / COSC = 111. 111, SFR Reset Values.NDIV / CDIV = 0000 (1:1). 111, SFR Reset Values.OSCFRQ = 0010 (4 MHz). 111, Clock Source.Clock Source = EXTOSC per FEXTOSC. 110, SFR Reset Values.NOSC / COSC = 110. 110, SFR Reset Values.NDIV / CDIV = 0010 (4:1). 110, SFR Reset Values.OSCFRQ = 0010 (4 MHz). 110, Clock Source.Clock Source = HFINTOSC @1MHz. 101, SFR Reset Values.NOSC / COSC = 101. 101, SFR Reset Values.NDIV / CDIV = 0000 (1:1). 101, SFR Reset Values.OSCFRQ = 0010 (4 MHz). 101, Clock Source.Clock Source = LFINTOSC. 100, SFR Reset Values.NOSC / COSC = 100. 100, SFR Reset",
    "12. OSC - Oscillator Module (With Fail-Safe Clock Monitor)\nValues.NDIV / CDIV = 0000 (1:1). 100, SFR Reset Values.OSCFRQ = 0010 (4 MHz). 100, Clock Source.Clock Source = SOSC. 011, SFR Reset Values.NOSC / COSC = Reserved. 011, SFR Reset Values.NDIV / CDIV = Reserved. 011, SFR Reset Values.OSCFRQ = Reserved. 011, Clock Source.Clock Source = Reserved. 010, SFR Reset Values.NOSC / COSC = 010. 010, SFR Reset Values.NDIV / CDIV = 0000 (1:1). 010, SFR Reset Values.OSCFRQ = 0010 (4 MHz). 010, Clock Source.Clock Source = EXTOSC + 4x PLL (1). 001, SFR Reset Values.NOSC / COSC = Reserved. 001, SFR Reset Values.NDIV / CDIV = Reserved. 001, SFR Reset Values.OSCFRQ = Reserved. 001, Clock Source.Clock",
    "12. OSC - Oscillator Module (With Fail-Safe Clock Monitor)\nSource = Reserved. 000, SFR Reset Values.NOSC / COSC = 000. 000, SFR Reset Values.NDIV / CDIV = 0000 (1:1). 000, SFR Reset Values.OSCFRQ = 1000 (64 MHz). 000, Clock Source.Clock Source = HFINTOSC @64 MHz",
    "Note:\n- 1. EXTOSC must meet the PLL specifications (see the data sheet Electrical Specifications).\nIf an external clock source is selected by the RSTOSC bits, the External Oscillator Mode Select (FEXTOSC) Configuration bits must be used to select the External Clock mode. These modes include:\n\u00b7 ECL: External Clock Low-Power mode\n\u00b7 ECM: External Clock Medium-Power mode\n\u00b7 ECH: External Clock High-Power mode\n\u00b7 LP: 32 kHz Low-Gain Crystal mode\n\u00b7 XT: Medium-Gain Crystal or Ceramic Resonator mode\n\u00b7 HS: High-Gain Crystal or Ceramic Resonator mode\nThe ECH, ECM and ECL modes rely on an external logic-level signal as the device clock source.\nThe LP, XT and HS modes rely on an external quartz crystal or ceramic resonator as the device clock source. Each mode is optimized for a specific frequency range. The internal oscillator block produces both low-frequency and high-frequency clock signals, designated LFINTOSC and HFINTOSC, respectively. Multiple system operating frequencies may be derived from these clock sources.\nThe figure below illustrates a block diagram of the oscillator module.",
    "Note:\nFigure 12-1. Clock Source Block Diagram",
    "12.1 Clock Source Types\nClock sources can be classified as external or internal.\nExternal clock sources rely on external circuitry for the clock source to function. Examples of external clock sources include:\n\u00b7 Digital oscillator modules\n\u00b7 Quartz crystal resonators\n\u00b7 Ceramic resonators\nA 4x PLL is provided for use with external clock sources.\nInternal clock sources are contained within the oscillator module. The internal oscillator block features two internal oscillators that are used to generate internal system clock sources. The High-Frequency Internal Oscillator (HFINTOSC) can produce a wide range of frequencies which are determined via the HFINTOSC Frequency Selection (OSCFRQ) register. The Low-Frequency Internal Oscillator (LFINTOSC) generates a fixed nominal 31 kHz clock signal. The internal oscillator block also features an RC oscillator which is dedicated to the Analog-to-Digital Converter (ADC).",
    "12.1 Clock Source Types\nThe oscillator module allows the system clock source or system clock frequency to be changed through clock switching. Clock source selections are made via the New Oscillator Source Request (NOSC) bits. Once the clock source has been selected, the clock source base frequency can be divided (post-scaled) via the New Divider Selection Request (NDIV) bits.\nThe instruction clock (F OSC/4) can be routed to the OSC2/CLKOUT pin when the pin is not in use. The Clock Out Enable (CLKOUTEN) Configuration bit controls the functionality of the CLKOUT signal. When CLKOUTEN is clear (CLKOUTEN = 0 ), the CLKOUT signal is routed to the OSC2/CLKOUT pin. When CLKOUTEN is set (CLKOUTEN = 1 ), the OSC2/CLKOUT pin functions as an I/O pin.",
    "12.1.1 External Clock Sources\nAn external clock source can be used as the device system clock by performing one of the following actions:\n\u00b7 Program the RSTOSC and FEXTOSC Configuration bits to select an external clock source that will be used as the default system clock upon a device Reset.\n\u00b7 Write the NOSC and NDIV bits to switch the system clock source during run time.",
    "12.1.1.1 EC Mode\nThe External Clock (EC) mode allows an externally generated logic level signal to be the system clock source. When operating in EC mode, an external clock source is connected to the OSC1/CLKIN input pin. The OSC2/CLKOUT pin is available as a general purpose I/O pin or as the CLKOUT signal pin.\nEC mode provides three Power mode selections:\n\u00b7 ECH: High-Power mode\n\u00b7 ECM: Medium-Power mode\n\u00b7 ECL: Low-Power mode\nThe Oscillator Start-up Timer (OST) is disabled when EC mode is selected; therefore, there is no delay in operation after a Power-on Reset (POR) or wake-up from Sleep. Because the PIC  MCU \u00ae design is fully static, stopping the external clock input will have the effect of halting the device while leaving all data intact. Upon restarting the external clock, the device will resume operation as if no time had elapsed.\nThe figure below shows the pin connections for EC mode.",
    "Note:\n- 1. Output depends on the setting of the CLKOUTEN Configuration bit.",
    "12.1.1.2 LP, XT, HS Modes\nThe LP, XT and HS modes support the use of quartz crystals or ceramic resonators connected to the OSC1 and OSC2 pins, as shown in the figures below. These three modes select a low-, medium-, or high-gain setting of the internal inverter-amplifier to support various resonator types and speeds.\nThe LP Oscillator mode selects the lowest gain setting of the internal inverter-amplifier and consumes the least amount of current. LP mode is designed to drive 32.768 kHz tuning-fork-type crystals (watch crystals) but can operate up to 100 kHz.\nThe XT Oscillator mode selects the intermediate gain setting of the internal inverter-amplifier. Current consumption is at a medium level when compared to the other two modes. XT mode is best suited to drive crystal and ceramic resonators with a frequency range up to 4 MHz.\nThe HS Oscillator mode selects the highest gain setting of the internal inverter-amplifier and consumes the most current. This mode is best suited for crystal and ceramic resonators that require operating frequencies up to 20 MHz.",
    "12.1.1.2 LP, XT, HS Modes\nThe figures below show typical circuits for quartz crystal and ceramic resonators.",
    "Figure 12-3. Quartz Crystal Operation\nFilename:\nTitle:\nLast Edit:\nFirst Used:\nNotes:\nCeramic Resonator Operation.vsdx\n2/7/2019",
    "Notes:\n1. A series resistor (R ) may be required for quartz crystals with low drive level. S\n2. The value of RF varies with the Oscillator mode selected (typically between 2 M\u03a9 and 10 M\u03a9).\nFigure 12-4. Ceramic Resonator Operation\n1. A series resistor (R ) may be required for ceramic resonators with low drive level. S\n2. The value of RF varies with the Oscillator mode selected (typically between 2 M\u03a9 and 10 M\u03a9).\n3. An additional parallel feedback resistor (R ) may be required for proper ceramic resonator P operation.\nRev. Quartz Cry\n2/7/2019\nRev. Cerami\n2/7/",
    "12.1.1.3 Oscillator Start-Up Timer (OST)\nThe Oscillator Start-up Timer (OST) ensures that the oscillator circuit has started and is providing a stable system clock to the oscillator module. Quartz crystals or ceramic resonators do not start immediately and may take a few hundred cycles before the oscillator becomes stable. The oscillations must build up until sufficient amplitude is generated to properly toggle between logic states. The OST counts 1024 oscillation periods from the OSC1 input following a Power-on Reset (POR), Brown-out Reset (BOR), or wake-up from Sleep event to ensure that the oscillator has enough time to reach stable and accurate operation. Once the OST has completed its count, module hardware sets the External Oscillator Ready (EXTOR) bit, indicating that the oscillator is stable and ready to use.",
    "12.1.1.4 4x PLL\nThe oscillator module contains a 4x Phase-Locked Loop (PLL) circuit that can be used with the external clock sources to provide a system clock source. The input frequency for the PLL must fall within a specified range. See the 'PLL Specifications' table found in the 'Electrical Specifications' chapter for more information.\nFilename:\nTitle:\nThe PLL can be enabled for use through one of two methods: Quartz Crystal Operation.vsdx\nLast Edit:\nFirst Used:\n- 1. Program the RSTOSC Configuration bits to select the 'EXTOSC with 4x PLL' option. 2/8/2019\nNotes:\n- 2. Write the NOSC bits to select the 'EXTOSC with 4x PLL' option.",
    "12.1.1.5 Secondary Oscillator\nThe Secondary Oscillator (SOSC) is a separate external oscillator block that can be used as an alternate system clock source or as a Timer clock source. The SOSC is optimized for 32.768 kHz and can be used with either an external quartz crystal connected to the SOSCI and SOSCO pins or with an external clock source connected to the SOSCI pin, as shown in the figures below.\nFigure 12-5. SOSC 32.768 kHz Quartz Crystal Oscillator Operation\nRev. Quartz Cry\n2/8/2019\nNotes:\nThe SOSC can be enabled through one of two methods:\n\u00b7 Programming the RSTOSC Configuration bits to select the SOSC as the system clock.\n\u00b7 Programming the NOSC bits to select the SOSC during run time.",
    "12.1.1.5 Secondary Oscillator\nTwo Power modes are available for the secondary oscillator and are selected using the Secondary Oscillator Power Mode Select (SOSCPWR) bit. When SOSCPWR is clear (SOSCPWR = 0 ), the oscillator operates in Low-Power mode, which is ideal for crystal oscillators with low drive strength. When SOSCPWR is set (SOSCPWR = 1 ), the oscillator operates in High-Power mode, which is ideal for crystal oscillators with high drive strength or high Equivalent Series Resistance (ESR).\nImportant: The SOSC module must be disabled before changing Power modes. Changes to the Power mode during operation may result in undefined oscillator behavior.",
    "12.1.1.5.1 SOSC Start-Up Timing\nThe SOSC utilizes the Oscillator Start-up Timer (OST) to ensure that the 32.768 kHz crystal oscillator has started and is available for use. Since crystal oscillators do not start immediately and may take a few hundred cycles before achieving stable operation, the OST counts 1024 oscillation periods from the SOSCI input. Once the OST completes its count, module hardware sets the Secondary Oscillator Ready (SOR) bit, indicating that the SOSC is stable and ready to use.",
    "12.1.2 Internal Clock Sources\nThe internal oscillator block contains two independent oscillators that can produce two internal system clock sources:\n\u00b7 High-Frequency Internal Oscillator (HFINTOSC)\n\u00b7 Low-Frequency Internal Oscillator (LFINTOSC)\nInternal oscillator selection is performed one of two ways:\n1. Program the RSTOSC Configuration bits to select one of the INTOSC sources which will be used upon a device Reset.\n2. Write the New Oscillator Source Request (NOSC) bits to select an internal oscillator during run time.\nIn INTOSC mode, the OSC1/CLKIN and OSC2/CLKOUT pins are available for use as a general purpose I/Os, provided that no external oscillator is connected. The function of the OSC2/CLKOUT pin is determined by the CLKOUTEN Configuration bit. When CLKOUTEN is set (CLKOUTEN = 1 ), the pin functions as a general-purpose I/O. When CLKOUTEN is clear (CLKOUTEN = 0 ), the system instruction clock (F OSC/4) is available as an output signal on the pin.",
    "12.1.2.1 HFINTOSC\nThe High-Frequency Internal Oscillator (HFINTOSC) is a factory-calibrated, precision digitallycontrolled internal clock source that produces a wide range of stable clock frequencies. The HFINTOSC can be enabled through one of the following methods:\n\u00b7 Program the RSTOSC Configuration bits to select the HFINTOSC upon device Reset or power-up.\n\u00b7 Write to the New Oscillator Source Request (NOSC) bits to select the HFINTOSC during run time.\nThe HFINTOSC frequency is selected via the HFINTOSC Frequency Selection (FRQ) bits. Fine-tuning of the HFINTOSC is done via the HFINTOSC Frequency Tuning (TUN) bits. The HFINTOSC output frequency can be divided (post-scaled) via the New Divider Selection Request (NDIV) bits.",
    "12.1.2.1.1 HFINTOSC Frequency Tuning\nThe HFINTOSC frequency can be fine-tuned via the HFINTOSC Tuning (OSCTUNE) register. The OSCTUNE register is used by Active Clock Tuning hardware or user software to provide small adjustments to the HFINTOSC nominal frequency.\nThe OSCTUNE register contains the HFINTOSC Frequency Tuning (TUN) bits. The TUN bits default to a 6-bit, two's complement value of 0x00 , which indicates that the oscillator is operating at the selected frequency. When a value between 0x01 and 0x1F is written to the TUN bits, the HFINTOSC frequency is increased. When a value between 0x3F and 0x20 is written to the TUN bits, the HFINTOSC frequency is decreased.\nWhen the OSCTUNE register is modified, the oscillator will begin to shift to the new frequency. Code execution continues during this shift. There is no indication that the frequency shift occurred.\nImportant: OSCTUNE tuning does not affect the LFINTOSC frequency.",
    "12.1.2.2 MFINTOSC\nThe Medium-Frequency Internal Oscillator (MFINTOSC) generates two constant clock outputs (500 kHz and 31.25 kHz). The MFINTOSC clock signals are created from the HFINTOSC using dynamic divider logic, which provides constant MFINTOSC clock rates regardless of selected HFINTOSC frequency.\nThe MFINTOSC cannot be used as the system clock but can be used as a clock source for certain peripherals, such as a Timer.",
    "12.1.2.3 LFINTOSC\nThe Low-Frequency Internal Oscillator (LFINTOSC) is a factory-calibrated 31 kHz internal clock source.\nThe LFINTOSC can be used as a system clock source and may be used by certain peripheral modules as a clock source. Additionally, the LFINTOSC provides a time base for the following:\n\u00b7 Power-up Timer (PWRT)\n\u00b7 Watchdog Timer (WDT)/Windowed Watchdog Timer (WWDT)\n\u00b7 Fail-Safe Clock Monitor (FSCM)\nThe LFINTOSC is enabled through one of the following methods:\n- \u00b7 Program the RSTOSC Configuration bits to select LFINTOSC\n- \u00b7 Write the NOSC bits to select LFINTOSC during run time",
    "12.1.2.4 ADCRC\nThe Analog-to-Digital RC (ADCRC) oscillator is dedicated to the ADC module. ADCRC operates at a fixed frequency of approximately 600 kHz and is used as a conversion clock source. The ADCRC allows the ADC module to operate in Sleep mode, which can reduce system noise during the ADC conversion. The ADCRC is automatically enabled when it is selected as the clock source for the ADC module or when selected as the clock source of any peripheral that may use it. The ADCRC may also be manually enabled via the ADC Oscillator Enable (ADOEN) bit, thereby avoiding start-up delays when this source is used intermittently.",
    "12.1.3 Oscillator Status and Manual Enable\nThe Oscillator Status (OSCSTAT) register displays the Ready status for each of the following oscillators:\n\u00b7 External oscillator\n\u00b7 HFINTOSC\n\u00b7 MFINTOSC\n\u00b7 LFINTOSC\n\u00b7 SOSC\n\u00b7 ADCRC\nThe OSCSTAT register also displays the Ready status for the 4xPLL.\nThe HFINTOSC Oscillator Ready (HFOR) and MFINTOSC Oscillator Ready (MFOR) Status bits indicate whether the respective oscillators are ready for use. Both clock sources are available for use at any time but may require a finite amount of time before they have reached the specified accuracy levels. When the HFINTOSC or MFINTOSC are ready and achieved the specified accuracy, module hardware sets the HFOR/MFOR bits, respectively.",
    "12.1.3 Oscillator Status and Manual Enable\nWhen a new value is loaded into the OSCFRQ register, the HFOR and MFOR bits are cleared by hardware and will be set again once the respective oscillator is ready. During pending OSCFRQ changes, the MFINTOSC will stall at either a high or a low state until the HFINTOSC locks in the new frequency and resumes operation.\nThe Oscillator Enable (OSCEN) register can be used to manually enable the following oscillators:\n\u00b7 External oscillator\n\u00b7 HFINTOSC\n\u00b7 MFINTOSC\n\u00b7 LFINTOSC\n\u00b7 SOSC\n\u00b7 ADCRC\nImportant: OSCEN cannot be used to manually enable the 4xPLL.",
    "12.2 Clock Switching\nThe system clock source can be switched between external and internal clock sources via software using the New Oscillator Source Request (NOSC) and New Divider Selection Request (NDIV) bits. The following sources can be selected:\n- \u00b7 External Oscillator (EXTOSC)\n\u00b7 EXTOSC with 4x PLL\n\u00b7 High-Frequency Internal Oscillator (HFINTOSC)\n\u00b7 Low-Frequency Internal Oscillator (LFINTOSC)\n\u00b7 Secondary Oscillator (SOSC)\nThe Clock Switch Enable (CSWEN) Configuration bit can be used to enable or disable the clock switching capability. When CSWEN is set (CSWEN = 1 ), writes to NOSC and NDIV by user software will allow the system clock to switch between sources or frequencies. When CSWEN is clear (CSWEN = 0 ), writes to NOSC and NDIV are ignored, preventing the system clock from switching from one source to another.",
    "12.2.1 NOSC and NDIV Bits\nThe New Oscillator Source Request (NOSC) and New Divider Selection Request (NDIV) bits are used to select the system clock source and clock frequency divider that will be used by the CPU and peripherals (see the tables below).\nWhen new values are written into NOSC and/or NDIV, the current oscillator selection will continue to operate as the system clock while waiting for the new source to indicate that it is ready. Writes to NDIV without changing the clock source (e.g., changing the HFINTOSC frequency from 1 MHz to 2 MHz) are handled in the same manner as a clock switch.",
    "12.2.1 NOSC and NDIV Bits\nWhen the new oscillator selection is ready, the New Oscillator is Ready (NOSCR) bit and the Clock Switch Interrupt Flag (CSWIF) are set by module hardware. If the Clock Switch Interrupt Enable (CSWIE) bit is set (CSWIE = 1 ), an interrupt will be generated when CSWIF is set. Additionally, the Oscillator Ready (ORDY) bit can be polled to determine that the clock switch has completed and the new oscillator source has replaced the old source as the system clock.\nImportant: The CSWIF interrupt does not wake the device from Sleep.\nTable 12-2. NOSC/COSC Clock Source Selection Table\n\n111, Clock Source = EXTOSC (1). 110, Clock Source = HFINTOSC (2). 101, Clock Source = LFINTOSC. 100, Clock Source = SOSC. 011, Clock Source = Reserved. 010, Clock Source = EXTOSC + 4xPLL (3). 001, Clock Source = Reserved. 000, Clock Source = Reserved",
    "Notes:\n1. EXTOSC is configured via the FEXTOSC Configuration bits.\n2. HFINTOSC frequency is determined by the FRQ bits.\n3. EXTOSC must meet the PLL specifications (see the data sheet Electrical Specifications).",
    "Table 12-3. NDIV/CDIV Clock Divider Selection Table\n1111-1010, Clock Divider = Reserved. 1001, Clock Divider = 512. 1000, Clock Divider = 256\n0111, Clock Divider = 128. 0110, Clock Divider = 64. 0101, Clock Divider = 32. 0100, Clock Divider = 16. 0011, Clock Divider = 8. 0010, Clock Divider = 4. 0001, Clock Divider = 2. 0000, Clock Divider = 1",
    "12.2.2 COSC and CDIV Bits\nThe Current Oscillator Source Select (COSC) bits and the Current Divider Select (CDIV) bits indicate the current oscillator source and clock divider, respectively. When a new oscillator or divider is requested via the NOSC/NDIV bits, the COSC and CDIV bits remain unchanged until the clock switch actually occurs. When the switch actually occurs, hardware copies the NOSC and NDIV values into COSC and CDIV, the Oscillator Ready (ORDY) bit is set, and the NOSCR bit is cleared by hardware, indicating that the clock switch is complete.",
    "12.2.3 CSWHOLD\nWhen the system oscillator changes frequencies, peripherals using the system clock may be affected. For example, if the I 2 C module is actively using the system clock as its Serial Clock (SCL) time base, changing the system clock frequency will change the SCL frequency. The Clock Switch Hold (CSWHOLD) bit can be used to suspend a requested clock switch. In this example, software can request a new clock source, use the CSWHOLD bit to suspend the switch, wait for the I 2 C bus to become Idle, then reconfigure the SCL frequency based on the new clock source. Once the I 2 C has been reconfigured, software can use CSWHOLD to complete the clock switch without causing any issues with the I 2 C bus.",
    "12.2.3 CSWHOLD\nWhen CSWHOLD is set (CSWHOLD = 1 ), a write to NOSC and/or NDIV is accepted, but the clock switch is suspended and does not automatically complete. While the switch is suspended, code execution continues using the old (current) clock source. Module hardware will still enable the new oscillator selection and set the NOSCR bit. Once the NOSCR bit is set, software will either:\n\u00b7 clear CSWHOLD so that the clock switch can complete, or\n\u00b7 copy the Current Oscillator Source Select (COSC) value into NOSC to abandon the clock switch.\nWhen CSWHOLD is clear (CSWHOLD = 0 ), the clock switch will occur when the NOSCR bit is set. When NOSCR is set, the CSWIF is also set, and if CSWIE is set, the generated interrupt will be serviced using the new oscillator.",
    "12.2.4 PLL Input Switch\nSwitching between the PLL and any non-PLL source is handled in the same manner as any other clock source change.\nWhen the NOSC selects a source with a PLL, the system continues to operate using the current oscillator until the new oscillator is ready. When the new source is ready, the associated Status bit in the Oscillator Status (OSCSTAT) register is set, and once the PLL is locked and ready for use, the PLL is Ready (PLLR) bit is set. Once both the source and PLL are ready, the switch will complete.",
    "12.2.5 Clock Switch and Sleep\nIf the NOSC/NDIV bits are written with new values and the device is put to Sleep before the clock switch completes, the switch will not take place and the device will enter Sleep mode.\nWhen the device wakes up from Sleep and CSWHOLD is clear (CSWHOLD = 0 ), the clock switch will complete and the device will wake with the new clock active, setting CSWIF. Filename: Clock Switch (CSWHOLD = 0).vsdx Title:\nWhen the device wakes from Sleep and CSWHOLD is set (CSWHOLD = 1 ), the device will wake up with the old clock active, and the new clock source will be requested again. Last Edit: 3/5/2019 First Used: Notes:\nIf Doze mode is in effect, the clock switch occurs on the next clock cycle regardless of whether or not the CPU is active during that clock cycle.\nFigure 12-7. Clock Switch (CSWHOLD = 0 )",
    "Notes:\n1. CSWIF is asserted coincident with NOSCR; interrupt is serviced at OSC#2 speed.\n2. The assertion of NOSCR may not be seen by the user as it is only set for the duration of the switch.",
    "Note:\n- 1. CSWIF may be cleared before or after clearing CSWHOLD.\n- 1. CSWIF may be cleared before or after rewriting NOSC; CSWIF is not automatically cleared.",
    "12.3 Fail-Safe Clock Monitor (FSCM)\nThe Fail-Safe Clock Monitor (FSCM) allows the device to continue operating in the event of an oscillator failure. The FSCM also provides diagnostic data pertaining to potential primary and secondary oscillator failures. The FSCM serves three separate functions:\n\u00b7 Monitoring of FOSC using the FSCMFEV bit\n\u00b7 Monitoring of EXTOSC (primary external oscillator) using the FSCMPEV bit\n\u00b7 Monitoring of SOSC (secondary external oscillator) using the FSCMSEV bit\nThe primary external oscillator FSCM (FSCMP) is enabled by setting the Fail-Safe Clock Monitor for Primary Crystal Oscillator (FCMENP) Configuration bit. The secondary external oscillator FSCM (FSCMS) is enabled by setting the Fail-Safe Clock Monitor for Secondary Crystal Oscillator (FCMENS) Configuration bit. The F OSC FSCM is enabled by setting the Fail-Safe Clock Monitor Enable for FOSC (FCMEN) Configuration bit. The figure below shows the FSCM block diagram.",
    "Figure 12-10. FSCM Block Diagram\n\u5343\n\uf720\n\u3634\n\u5361",
    "12.3.1 Fail-Safe Detection\nEach FSCM detects a failed oscillator by comparing the external oscillator to the FSCM sample clock. The sample clock is generated by dividing the LFINTOSC by 64. The fail detector logic block contains a latch that is set upon each falling edge of the external clock. The latch is cleared on the rising edge of the sample clock. A failure is detected when a half-period of the sample clock elapses before the external clock goes low and the corresponding FSCM failure status bit will be set.",
    "12.3.2 Fail-Safe Operation - FOSC Fail-Safe Clock Monitor\nWhen the system clock (FOSC) fails, the Oscillator Fail Interrupt Flag (OSFIF) bit of the PIR registers, as well as the corresponding FSCM failure status (FSCMFEV) bit, will be set. If the Oscillator Fail Interrupt Enable (OSFIE) bit was set, an interrupt will be generated when OSFIF is high. If enabled, the F OSC Fail-Safe Clock Monitor will switch the system clock to HFINTOSC when a failure is detected by overwriting the NOSC/COSC bits. The frequency of HFINTOSC will depend on the previous state of the FRQ bits and the state of the NDIV/CDIV bits. Once a failure is detected, software can be used to take steps to mitigate the repercussions of the oscillator failure. The FSCM will switch the system clock to HFINTOSC, and the device will continue to operate from HFINTOSC until the external oscillator has been restarted. Once the external source is operational, it is up to the user to confirm that the clock",
    "12.3.2 Fail-Safe Operation - FOSC Fail-Safe Clock Monitor\nsource is stable and to switch the system clock back to the external oscillator using the NOSC/NDIV bits.",
    "12.3.3 Fail-Safe Operation - Primary and Secondary Fail-Safe Clock Monitors\nWhen the primary external clock (EXTOSC) or the secondary external clock (SOSC) fail, the Oscillator Fail Interrupt Flag (OSFIF) bit of the PIR registers will be set. Additionally, the corresponding FSCM failure status bit (FSCMPEV or FSCMSEV, respectively) will be set. If the Oscillator Fail Interrupt Enable (OSFIE) bit has been set, an interrupt will be generated when OSFIF is high. It is important to note that neither the primary or secondary Fail-Safe Clock Monitors will cause a clock switch to occur in the event of a failure, and it is up to the user to address the clock fail event.",
    "12.3.4 Fail-Safe Clock Monitor Fault Injection\nEach of the Fail-Safe Clock monitors on this device has its own respective Fault Injection bit. The Fault Injection bit is used to verify in the software that the FSCM functions work properly and that they will detect a clock failure during normal operation. If the FSCM Fault Injection bit is set, the FSCM sample clock input will be blocked, forcing a clock failure. Writing to the FOSC FSCM Fault Injection (FSCMFFI) bit will result in the system clock switching to HFINTOSC and the FSCMFEV bit as well as the Oscillator Fail Interrupt Flag (OSFIF) of the PIR registers being set. Writing to the primary and secondary external FSCM Fault Injection (FSCMPFI and FSCMSFI) bits will result in the respective FSCM Fault Status (FSCMPEV and FSCMSEV) bits being set but the system clock will not switch. Additionally, the Oscillator Fail Interrupt Flag (OSFIF) of the PIR registers will also be set.",
    "12.3.5 Fail-Safe Condition Clearing\nFor the FOSC FSCM, the Fail-Safe condition is cleared after either a device Reset, execution of a SLEEP instruction, or a change to the NOSC/NDIV bits. When switching to the external oscillator or PLL, the Oscillator Start-up Timer (OST) is restarted. While the OST is running, the device continues to operate from HFINTOSC. When the OST expires, the Fail-Safe condition is cleared after successfully switching to the external clock source.\nImportant: Software must clear the OSFIF bit before switching to the external oscillator. If the Fail-Safe condition still exists, the OSFIF bit will be set again by module hardware.",
    "12.3.6 Reset or Wake-Up from Sleep\nThe FSCM is designed to detect an oscillator failure after the OST has expired. The OST is used after waking up from Sleep or after any type of Reset, when in either LP, XT or HS mode. If the device is using the EC mode, the FSCM will be active as soon as the Reset or wake-up event has completed.",
    "12.4 Active Clock Tuning (ACT)\nMany applications, such as those using UART communication, require an oscillator with an accuracy of \u00b1 1% over the full temperature and voltage range. To meet this level of accuracy, the Active Clock Tuning (ACT) feature utilizes the SOSC frequency of 32.768 kHz to adjust the frequency of the HFINTOSC over voltage and temperature.\nImportant: Active Clock Tuning requires the use of a 32.768 kHz external oscillator connected to the SOSCI/SOSCO pins.\nActive Clock Tuning is enabled via the Active Clock Tuning Enable (ACTEN) bit. When ACTEN is set (ACTEN = 1 ), the ACT module uses the SOSC time base to measure the HFINTOSC frequency and uses the HFINTOSC Frequency Tuning (TUN) bits to adjust the HFINTOSC frequency. When ACTEN is clear (ACTEN = 0 ), the ACT feature is disabled, and user software can utilize the TUN bits to adjust the HFINTOSC frequency.",
    "12.4 Active Clock Tuning (ACT)\nImportant: When the ACT feature is enabled, the TUN bits are controlled directly through module hardware and become read-only bits to user software. Writes to the TUN bits when the ACT feature is enabled are ignored.\nThe figure below shows the Active Clock Tuning block diagram.",
    "12.4.1 ACT Lock Status\nThe Active Clock Tuning Lock Status (ACTLOCK) bit can be used to determine when the HFINTOSC has been tuned. When ACTLOCK is set (ACTLOCK = 1 ), the HFINTOSC frequency has been locked to within \u00b1 1% of the nominal frequency. When ACTLOCK is clear (ACTLOCK = 0 ), the following conditions may be true:\n\u00b7 The HFINTOSC frequency has not been locked to within \u00b1 1%\n\u00b7 A device Reset occurred\n\u00b7 The ACT feature is disabled\nImportant: The ACTLOCK bit is read-only. Writes to ACTLOCK are ignored.",
    "12.4.2 ACT Out-of-Range Status\nWhen Active Clock Tuning is enabled, module hardware uses the TUN bits to achieve high accuracy levels. If the module requires a TUN value outside of its range, the ACT Out-of-Range Status (ACTORS) bit is set by hardware (ACTORS = 1 ).\nThe ACTORS bit will be set when:\n\u00b7 The HFINTOSC is tuned to its lowest frequency as determined by the TUN bits and will require a value lower than the TUN bits can provide to achieve accuracy within \u00b1 1%.\n\u00b7 The HFINTOSC is tuned to its highest frequency as determined by the TUN bits and will require a value higher than the TUN bits can provide to achieve accuracy within \u00b1 1%.\nWhen an ACT out-of-range event occurs, the HFINTOSC will continue to use the last TUN value until the HFINTOSC frequency returns to the tunable range. Once the HFINTOSC returns to the tunable range, module hardware clears the ACTORS bit.\nImportant: The ACTORS bit is read-only. Writes to ACTORS are ignored.",
    "12.4.3 ACT Update Disable\nWhen Active Clock Tuning is enabled, the OSCTUNE register is continuously updated every ACT clock cycle. The ACT Update Disable (ACTUD) bit can be used to suspend updates to the OSCTUNE register. When ACTUD is set (ACTUD = 1 ), updates to OSCTUNE are suspended, although the module continues to operate. The last value written to OSCTUNE is used for tuning, and the ACTLOCK bit is continually updated for each ACT cycle. When ACTUD is clear (ACTUD = 0 ), the module updates OSCTUNE register every ACT cycle.",
    "12.4.4 ACT Interrupts\nWhen Active Clock Tuning is enabled (ACTEN = 1 ) and the ACTLOCK or ACTORS bit changes state (e.g., from a Locked to an Unlocked state), the ACT Interrupt Flag (ACTIF) of the PIR registers is set (ACTIF = 1 ). If the ACT Interrupt Enable (ACTIE) bit is set (ACTIE = 1 ), an interrupt will be generated when ACTIF becomes set. No interrupts are generated for each OSCTUNE update unless the update results in a change of Lock status or Out-of-Range status.",
    "12.5.1 ACTCON\nName: Address:\nACTCON\n0x0AC",
    "Active Clock Tuning Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ACTEN. , 2 = ACTUD. , 3 = . , 4 = . , 5 = ACTLOCK. , 6 = . , 7 = ACTORS. , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = R. Access, 6 = . Access, 7 = R. Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = . Reset, 7 = 0. Reset, 8 = ",
    "Bit 7 - ACTEN Active Clock Tuning Enable\n1, Description = ACT enabled: HFINTOSC tuning is controlled by the ACT. 0, Description = ACT disabled: HFINTOSC tuning is controlled by the OSCTUNE register via user software",
    "Bit 6 - ACTUD Active Clock Tuning Update Disable\n1, Condition = ACTEN = 1. 1, Description = Updates to the OSCTUNE register from ACT hardware are disabled. 0, Condition = ACTEN = 1. 0, Description = Updates to the OSCTUNE register from ACT hardware are allowed. x, Condition = ACTEN = 0. x, Description = Updates to the OSCTUNE register through user software are allowed",
    "Bit 3 - ACTLOCK Active Clock Tuning Lock Status\n1, Description = Locked: HFINTOSC is within \u00b1 1% of its nominal value. 0, Description = Not locked: HFINTOSC may or may not be within \u00b1 1% of its nominal value",
    "Bit 1 - ACTORS Active Clock Tuning Out-of-Range Status\n1, Description = Value required for tuning is outside of the OSCTUNE range. 0, Description = Value required for tuning is within the OSCTUNE range",
    "12.5.2 OSCCON1\nName:\nOSCCON1\nAddress:\n0x0AD\nOscillator Control Register 1",
    "12.5.2 OSCCON1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = NOSC[2:0]. , 3 = NOSC[2:0]. , 4 = NOSC[2:0]. , 5 = NDIV[3:0]. , 6 = NDIV[3:0]. , 7 = NDIV[3:0]. , 8 = NDIV[3:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = f. Reset, 3 = f. Reset, 4 = f. Reset, 5 = q. Reset, 6 = q. Reset, 7 = q. Reset, 8 = q",
    "Bits 6:4 - NOSC[2:0]  New Oscillator Source Request (1,2,3)\nRequests a new oscillator source per the NOSC/COSC Clock Source Selection Table.",
    "Bits 3:0 - NDIV[3:0] New Divider Selection Request\nRequests the new postscaler division ratio per the NDIV/CDIV Clock Divider Selection Table.",
    "Notes:\n1. The default value is determined by the RSTOSC Configuration bits. See the Reset Oscillator (RSTOSC) selection table for the RSTOSC selections.\n2. If NOSC is written with a reserved value, the operation is ignored and neither NOSC nor NDIV is written.\n3. When CSWEN = 0 , these bits are read-only and cannot be changed from the RSTOSC value.",
    "12.5.3 OSCCON2\nName:\nOSCCON2\nAddress:\n0x0AE\nOscillator Control Register 2\nAccess, 7. = . Access, 6.COSC[2:0] = R. Access, 5.COSC[2:0] = R. Access, 4.COSC[2:0] = R. Access, 3.CDIV[3:0] = R. Access, 2.CDIV[3:0] = R. Access, 1.CDIV[3:0] = R. Access, 0.CDIV[3:0] = R. Reset, 7. = . Reset, 6.COSC[2:0] = f. Reset, 5.COSC[2:0] = f. Reset, 4.COSC[2:0] = f. Reset, 3.CDIV[3:0] = f. Reset, 2.CDIV[3:0] = f. Reset, 1.CDIV[3:0] = f. Reset, 0.CDIV[3:0] = f",
    "Bits 6:4 - COSC[2:0]  Current Oscillator Source Select (read-only) (1)\nIndicates the current oscillator source per the NOSC/COSC Clock Source Selection Table.",
    "Bits 3:0 - CDIV[3:0] Current Divider Select (read-only)\nIndicates the current postscaler divider ratio per the NDIV/CDIV Clock Divider Table.",
    "Note:\n- 1. The RSTOSC value is the value present when user code execution begins. Refer to the RSTOSC Configuration bits or the RSTOSC selection table for the Reset Oscillator selections.",
    "12.5.4 OSCCON3\nName:\nOSCCON3\nAddress:\n0x0AF",
    "Oscillator Control Register 3\n, 7 = CSWHOLD. , 6 = SOSCPWR. , 5 = . , 4 = ORDY. , 3 = NOSCR. , 2 = . , 1 = . , 0 = . Access, 7 = R/W/HC. Access, 6 = R/W. Access, 5 = . Access, 4 = R. Access, 3 = R. Access, 2 = . Access, 1 = . Access, 0 = . Reset, 7 = 0. Reset, 6 = 1. Reset, 5 = . Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = . Reset, 1 = . Reset, 0 = ",
    "Bit 7 - CSWHOLD Clock Switch Hold Control\n1, Description = Clock switch (and interrupt) will hold when the oscillator selected by NOSC is ready. 0, Description = Clock switch will proceed when the oscillator selected by NOSC is ready",
    "Bit 6 - SOSCPWR Secondary Oscillator Power Mode Select\n1, Description = Secondary Oscillator operates in High-Power mode. 0, Description = Secondary Oscillator operates in Low-Power mode",
    "Bit 4 - ORDY Oscillator Ready (read-only)\n1, Description = OSCCON1 = OSCCON2; the current system clock is the clock specified by NOSC. 0, Description = A clock switch is in progress",
    "Bit 3 - NOSCR  New Oscillator is Ready (read-only) (1)\n1, Description = A clock switch is in progress and the oscillator selected by NOSC indicates a Ready condition. 0, Description = A clock switch is not in progress, or the NOSC-selected oscillator is not ready",
    "Note:\n- 1. If CSWHOLD = 0 , the user may not see this bit set (NOSCR = 1 ). When the oscillator becomes ready, there may be a delay of one instruction cycle before NOSCR is set. The clock switch occurs in the next instruction cycle and NOSCR is cleared.",
    "12.5.5 OSCTUNE\nName: Address:\nOSCTUNE\n0x0B0",
    "HFINTOSC Frequency Tuning Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = TUN[5:0]. , 3 = TUN[5:0]. , 4 = TUN[5:0]. , 5 = TUN[5:0]. , 6 = TUN[5:0]. , 7 = TUN[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - TUN[5:0] HFINTOSC Frequency Tuning\n01 1111, Condition = Maximum frequency. \u2022, Condition = \u2022. \u2022, Condition = \u2022. \u2022, Condition = \u2022. 00 0000, Condition = Center frequency. Oscillator is operating at the selected nominal frequency. (Default value). \u2022, Condition = \u2022. \u2022, Condition = \u2022. \u2022, Condition = \u2022. 10 0000, Condition = Minimum frequency",
    "12.5.6 OSCFRQ\nName:\nOSCFRQ\nAddress:\n0x0B1\nHFINTOSC Frequency Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = FRQ[3:0]. , 6 = FRQ[3:0]. , 7 = FRQ[3:0]. , 8 = FRQ[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - FRQ[3:0] HFINTOSC Frequency Selection\n1111-1001, Nominal Freq (MHz) = Reserved. 1000, Nominal Freq (MHz) = 64. 0111, Nominal Freq (MHz) = 48. 0110, Nominal Freq (MHz) = 32. 0101, Nominal Freq (MHz) = 16. 0100, Nominal Freq (MHz) = 12. 0011, Nominal Freq (MHz) = 8. 0010, Nominal Freq (MHz) = 4. 0001, Nominal Freq (MHz) = 2. 0000, Nominal Freq (MHz) = 1",
    "12.5.7 OSCSTAT\nName: Address:\nOSCSTAT\n0x0B2",
    "Oscillator Status Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EXTOR. , 2 = HFOR. , 3 = MFOR. , 4 = LFOR. , 5 = SOR. , 6 = ADOR. , 7 = SFOR. , 8 = PLLR. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EXTOR External Oscillator Ready\n1, Description = The External oscillator is ready for use. 0, Description = The External oscillator is not enabled, or it is not ready for use",
    "Bit 6 - HFOR HFINTOSC Ready\n1, Description = The HFINTOSC is ready for use. 0, Description = The HFINTOSC is not enabled, or it is not ready for use",
    "Bit 5 - MFOR MFINTOSC Ready\n1, Description = The MFINTOSC is ready for use. 0, Description = The MFINTOSC is not enabled, or it is not ready for use",
    "Bit 4 - LFOR LFINTOSC Ready\n1, Description = The LFINTOSC is ready for use. 0, Description = The LFINTOSC is not enabled, or it is not ready for use",
    "Bit 3 - SOR Secondary Oscillator (SOSC) Ready\n1, Description = The Secondary oscillator is ready for use. 0, Description = The Secondary oscillator is not enabled, or it is not ready for use",
    "Bit 2 - ADOR ADCRC Oscillator Ready\n1, Description = The ADCRC oscillator is ready for use. 0, Description = The ADCRC oscillator is not enabled, or it is not ready for use",
    "Bit 1 - SFOR SFINTOSC Ready\n1, Description = The SFINTOSC is ready for use. 0, Description = The SFINTOSC is not enabled, or it is not ready for use",
    "Bit 0 - PLLR PLL is Ready\n1, Description = The PLL is ready for use. 0, Description = The PLL is not enabled, the required input source is not ready, or the PLL is not locked",
    "12.5.8 OSCEN\nName:\nOSCEN\nAddress:\n0x0B3",
    "Oscillator Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EXTOEN. , 2 = HFOEN. , 3 = MFOEN. , 4 = LFOEN. , 5 = SOSCEN. , 6 = ADOEN. , 7 = . , 8 = PLLEN. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - EXTOEN External Oscillator Enable\n1, Description = EXTOSC is explicitly enabled, operating as specified by FEXTOSC. 0, Description = EXTOSC can be enabled by a peripheral request",
    "Bit 6 - HFOEN HFINTOSC Enable\n1, Description = HFINTOSC is explicitly enabled, operating as specified by OSCFRQ. 0, Description = HFINTOSC can be enabled by a peripheral request",
    "Bit 5 - MFOEN MFINTOSC Enable\n1, Description = MFINTOSC is explicitly enabled. 0, Description = MFINTOSC can be enabled by a peripheral request",
    "Bit 4 - LFOEN LFINTOSC Enable\n1, Description = LFINTOSC is explicitly enabled. 0, Description = LFINTOSC can be enabled by a peripheral request",
    "Bit 3 - SOSCEN Secondary Oscillator Enable\n1, Description = SOSC is explicitly enabled, operating as specified by SOSCPWR. 0, Description = SOSC can be enabled by a peripheral request",
    "Bit 2 - ADOEN ADCRC Oscillator Enable\n1, Description = ADCRC is explicitly enabled. 0, Description = ADCRC may be enabled by a peripheral request",
    "Bit 0 - PLLEN  PLL Enable (1)\n1, Description = EXTOSC multiplied by the 4x system PLL is used by a peripheral request. 0, Description = EXTOSC is used by a peripheral request",
    "Note:\n- 1. This bit only controls external clock source supplied to the peripherals and has no effect on the system clock.",
    "12.5.9 FSCMCON\nName:\nFSCMCON\nAddress:\n0x458",
    "Fail-Safe Clock Monitor Control and Status Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = FSCMSFI. , 3 = FSCMSEV. , 4 = FSCMPFI. , 5 = FSCMPEV. , 6 = FSCMFFI. , 7 = FSCMFEV. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - FSCMSFI  SOSC Fail-Safe Clock Monitor Fault Injection (1)\n1, Description = SOSC FSCM clock input is blocked; FSCM will time-out. 0, Description = SOSC FSCM clock input is enabled; FSCM functions as indicated",
    "Bit 4 - FSCMSEV  SOSC Fail-Safe Clock Monitor Status (2)\n1, Description = SOSC clock showed a failure. 0, Description = FSCM is detecting SOSC input clocks, or the bit was cleared by the user",
    "Bit 3 - FSCMPFI  Primary Oscillator Fail-Safe Clock Monitor Fault Injection (1)\n1, Description = Primary Oscillator FSCM clock input is blocked; FSCM will time-out. 0, Description = Primary Oscillator FSCM clock input is enabled; FSCM functions as indicated",
    "Bit 2 - FSCMPEV  Primary Oscillator Fail-Safe Clock Monitor Status (2)\n1, Description = Primary Oscillator clock showed a failure. 0, Description = FSCM is detecting primary oscillator input clocks, or the bit was cleared by the user",
    "Bit 1 - FSCMFFI  FOSC Fail-Safe Clock Monitor Fault Injection (1)\n1, Description = F OSC FSCM clock input is blocked; FSCM will time-out. 0, Description = F OSC FSCM clock input is enabled; FSCM functions as indicated",
    "Bit 0 - FSCMFEV  FOSC Fail-Safe Clock Monitor Status (2)\n1, Description = F OSC clock showed a failure. 0, Description = FSCM is detecting F OSC input clocks, or the bit was cleared by the user",
    "Notes:\n1. This bit is used to demonstrate that FSCM can detect clock failure; the bit must be cleared for normal operation.\n2. This bit will not be cleared by hardware upon clock recovery; the bit must be cleared by the user.",
    "12.6 Register Summary - Oscillator Module\n0x00 ... 0xAB, Name = Reserved. 0x00 ... 0xAB, Bit Pos. = . 0x00 ... 0xAB, 7 = . 0x00 ... 0xAB, 6 = . 0x00 ... 0xAB, 5 = . 0x00 ... 0xAB, 4 = . 0x00 ... 0xAB, 3 = . 0x00 ... 0xAB, 2 = . 0x00 ... 0xAB, 1 = . 0x00 ... 0xAB, 0 = . 0xAC, Name = ACTCON. 0xAC, Bit Pos. = 7:0. 0xAC, 7 = ACTEN. 0xAC, 6 = ACTUD. 0xAC, 5 = . 0xAC, 4 = . 0xAC, 3 = ACTLOCK. 0xAC, 2 = . 0xAC, 1 = ACTORS. 0xAC, 0 = . 0xAD, Name = OSCCON1. 0xAD, Bit Pos. = 7:0.",
    "12.6 Register Summary - Oscillator Module\n0xAD, 7 = . 0xAD, 6 = . 0xAD, 5 = NOSC[2:0]. 0xAD, 4 = . 0xAD, 3 = NDIV[3:0]. 0xAD, 2 = NDIV[3:0]. 0xAD, 1 = NDIV[3:0]. 0xAD, 0 = NDIV[3:0]. 0xAE, Name = OSCCON2. 0xAE, Bit Pos. = 7:0. 0xAE, 7 = . 0xAE, 6 = . 0xAE, 5 = COSC[2:0]. 0xAE, 4 = . 0xAE, 3 = CDIV[3:0]. 0xAE, 2 = CDIV[3:0]. 0xAE, 1 = CDIV[3:0]. 0xAE, 0 = CDIV[3:0]. 0xAF, Name = OSCCON3. 0xAF, Bit Pos. = 7:0. 0xAF, 7 = CSWHOLD.",
    "12.6 Register Summary - Oscillator Module\n0xAF, 6 = SOSCPWR. 0xAF, 5 = . 0xAF, 4 = ORDY. 0xAF, 3 = NOSCR. 0xAF, 2 = . 0xAF, 1 = . 0xAF, 0 = . 0xB0, Name = OSCTUNE. 0xB0, Bit Pos. = 7:0. 0xB0, 7 = . 0xB0, 6 = . 0xB0, 5 = . 0xB0, 4 = . 0xB0, 3 = TUN[5:0]. 0xB0, 2 = TUN[5:0]. 0xB0, 1 = TUN[5:0]. 0xB0, 0 = TUN[5:0]. 0xB1, Name = OSCFRQ. 0xB1, Bit Pos. = 7:0. 0xB1, 7 = . 0xB1, 6 = . 0xB1, 5 = . 0xB1, 4 = . 0xB1, 3 = FRQ[3:0].",
    "12.6 Register Summary - Oscillator Module\n0xB1, 2 = FRQ[3:0]. 0xB1, 1 = FRQ[3:0]. 0xB1, 0 = FRQ[3:0]. 0xB2, Name = OSCSTAT. 0xB2, Bit Pos. = 7:0. 0xB2, 7 = EXTOR. 0xB2, 6 = HFOR. 0xB2, 5 = MFOR. 0xB2, 4 = LFOR. 0xB2, 3 = SOR. 0xB2, 2 = ADOR. 0xB2, 1 = SFOR. 0xB2, 0 = PLLR. 0xB3, Name = OSCEN. 0xB3, Bit Pos. = 7:0. 0xB3, 7 = EXTOEN. 0xB3, 6 = HFOEN. 0xB3, 5 = MFOEN. 0xB3, 4 = LFOEN. 0xB3, 3 = SOSCEN. 0xB3, 2 = ADOEN. 0xB3,",
    "12.6 Register Summary - Oscillator Module\n1 = . 0xB3, 0 = PLLEN. 0xB4 ... 0x0457, Name = Reserved. 0xB4 ... 0x0457, Bit Pos. = . 0xB4 ... 0x0457, 7 = . 0xB4 ... 0x0457, 6 = . 0xB4 ... 0x0457, 5 = . 0xB4 ... 0x0457, 4 = . 0xB4 ... 0x0457, 3 = . 0xB4 ... 0x0457, 2 = . 0xB4 ... 0x0457, 1 = . 0xB4 ... 0x0457, 0 = . 0x0458, Name = FSCMCON. 0x0458, Bit Pos. = 7:0. 0x0458, 7 = . 0x0458, 6 = . 0x0458, 5 = FSCMSFI. 0x0458, 4 =",
    "12.6 Register Summary - Oscillator Module\nFSCMSEV. 0x0458, 3 = FSCMPFI. 0x0458, 2 = FSCMPEV. 0x0458, 1 = FSCMFFI. 0x0458, 0 = FSCMFEV",
    "13. CRC - Cyclic Redundancy Check Module with Memory Scanner\nThe Cyclic Redundancy Check (CRC) module provides a software-configurable hardwareimplemented CRC checksum generator. This module includes the following features:\n\u00b7 Any standard CRC up to 32 bits can be used\n\u00b7 Configurable polynomial\n\u00b7 Any seed value up to 32 bits can be used\n\u00b7 Standard and reversed bit order available\n\u00b7 Augmented zeros can be added automatically or by the user\n\u00b7 Memory scanner for core-independent CRC calculations on any program memory locations\n\u00b7 Software configurable data registers for communication CRCs",
    "13.1 Module Overview\nThe CRC module is coupled with a memory scanner that provides a means of performing CRC calculations in hardware, without CPU intervention. The memory scanner can automatically provide data from program Flash memory to the CRC module. The CRC module can also be operated by directly writing data to SFRs, without using a scanner.\nThe CRC module can be used to detect bit errors in the Flash memory using the built-in memory scanner or through user input RAM. The CRC module can accept up to a 32-bit polynomial with up to a 32-bit seed value. A CRC calculated check value (or checksum) will then be generated into the CRCOUT registers for user storage. The CRC module uses an XOR shift register implementation to perform the polynomial division required for the CRC calculation. This feature is useful for calculating CRC values of data being transmitted or received using communications peripherals such as the SPI, UART or I 2 C.",
    "13.2 Polynomial Implementation\nThe CRC polynomial equation is user configurable, allowing any polynomial equation to be used for the CRC checksum calculation. The polynomial and accumulator sizes are determined by the PLEN bits. For an n-bit accumulator, PLEN = n-1 and the corresponding polynomial is n+1 bits. This allows the accumulator to be any size up to 32 bits with a corresponding polynomial up to 33 bits. The MSb and LSb of the polynomial are always ' 1 ' which is forced by hardware. Therefore, the LSb of the CRCXOR Low Byte register is hardwired high and always reads as ' 1 '.\nAll polynomial bits between the MSb and LSb are specified by the CRCXOR registers.",
    "13.2 Polynomial Implementation\nFor example, when using the standard CRC32, the polynomial is defined as 0x4C11DB7 x 32 +x 26 +x 23 +x 22 +x 16 +x 12 +x 11 +x 10 +x +x +x +x +x +x+1 8 7 5 4 2 . In this polynomial, the X 32 and X 0  terms are the MSb and LSb controlled by hardware. The X 31  and X 1  terms are specified by setting the CRCXOR[31:0] bits with the corresponding polynomial value, which in this example is 0x04C11DB6 . Reading the CRCXOR registers will return 0x04C11DB7 because the LSb is always ' 1 '. Refer to the following example for more details.\nExample 13-1. CRC32 Example\nCRCXORT = 0x04 = 0b00000100\nCRCXORU = 0xC1 = 0b11000001\nCRCXORH = 0x1D = 0b00011101",
    "13.2 Polynomial Implementation\nStandard CRC32 Polynomial (33 bits): x 32 +x 26 +x 23 +x 22 +x 16 +x 12 +x 11 +x 10 +x +x +x +x +x +x+1 8 7 5 4 2 Standard 32-bit Polynomial Representation: 0x04C11DB7\nCRCXORL = 0xB7 = 0b1011011(1)\nData Sequence: 0x55, 0x66, 0x77, 0x88\nDLEN = 0b00111 // Number of bits written to CRCDATA registers (Data Length)\nPLEN = 0b11111 // MSb position of the polynomial (Polynomial Length)",
    "Data passed into the CRC:\n// SHIFTM = 0(Shift Mode: MSb first)\n0x55 0x66 0x77 0x88 = 01010101 01100110 01110111 10001000\n// SHIFTM = 1(Shift Mode: LSb first)\n0x55 0x66 0x77 0x88 = 10101010 01100110 11101110 00010001",
    "CRC Check Value ( ACCM = 1 , data are augmented with zeros)\n```\n// When SHIFTM = 0, CRC Result = 0xC60D8323 CRCOUTT = 0xC6 = 0b11000110 CRCOUTU = 0x0D = 0b00001101 CRCOUTH = 0x83 = 0b10000011 CRCOUTL = 0x23 = 0b00100011 // When SHIFTM = 1, CRC Result = 0x843529CC CRCOUTT = 0x84 = 0b10000100 CRCOUTU = 0x35 = 0b00110101 CRCOUTH = 0x29 = 0b00101001 CRCOUTL = 0xCC = 0b11001100\n```",
    "Note:\n- 1. Bit 0 is unimplemented. The LSb of any CRC polynomial is always ' 1 ' and will always be treated as a ' 1 ' by the CRC for calculating the CRC check value. This bit will be read in software as a ' 0 '.",
    "13.3 Data Sources\nData are supplied to the CRC module using the CRCDATA registers and can either be loaded manually or automatically by using the scanner module. The length of the data word being supplied to the CRC module is specified by the DLEN bits and can be configured for data words up to 32 bits in length. The DLEN field indicates how many bits in the CRCDATA registers are valid and any bits outside of the specified data word size will be ignored. Data are moved into the CRCSHIFT registers as an intermediate to calculate the check value located in the CRCOUT registers. The SHIFTM bit is used to determine the bit order of the data being shifted into the accumulator and the bit order of the result.",
    "Figure 13-1. CRC Process\nWhen the SHIFTM bit is not set, data will be shifted into the CRC, MSb first and the result will be big-endian. When the SHIFTM bit is set, data will be shifted into the accumulator in the reverse order (LSb first) and the result will be little-endian. The CRC module can be seeded with an initial value by setting the CRCOUT registers to the appropriate value before beginning the CRC process.",
    "13.3.1 CRC from User Data\nData can be supplied to the CRC module by writing to the CRCDATA registers. Once data have been loaded into the CRCDATA registers, it will then be latched onto the CRC Shift (CRCSHIFT) registers. If data are still being shifted from an earlier write to the CRCDATA registers and the user attempts to write more data, the most recently written data will be held in the CRCDATA registers until the previous shift has completed.",
    "13.3.2 CRC from Flash\nData can also be supplied to the CRC module using the memory scanner, as opposed to writing the data manually using the CRCDATA registers, allowing users to automate CRC calculations. An automated scan of Program Flash Memory or Data EEPROM can be performed by configuring the scanner accordingly, to copy data into the CRCDATA registers. The user can initialize the program memory scanner as defined in Scanner Module Overview and Configuring the Scanner.",
    "13.4 CRC Check Value\nThe CRC check value can be accessed using the CRCOUT registers after a CRC calculation has completed. The check value is dependent on the configuration of the ACCM and SHIFTM mode settings. When the ACCM bit is set, the CRC module will augment the data with a number of zeros equal to the length of the polynomial to align the final check value. When the ACCM bit is not set, the CRC will stop at the end of the data and no additional zeroes will be augmented to the final value. The user can manually augment a number of additional zeroes equal to the length of the polynomial by entering them into the CRCDATA register, which will yield the same check value as Augmented mode. Alternatively, the expected check value can be entered at this point to make the final result equal zero.\nWhen the CRC check value is computed with the SHIFTM (LSb first) and ACCM bits set, the final value in the CRCOUT registers will be reversed such that the LSb will be in the MSb position and vice versa (Figure 13-1).",
    "13.4 CRC Check Value\nWhen creating a check value to be appended to a data stream, then a reversal must be performed on the final value to achieve the correct checksum. The CRC can be used to do this reversal by following the steps below.\n1. Save CRCOUT value in user RAM space.\n2. Clear the CRCOUT registers.\n3. Clear the CRCXOR registers.\n4. Write the saved CRCOUT value to the CRCDATA input.\nIf the steps listed above were followed completely, the properly orientated check value will be in the CRCOUT registers.",
    "13.5 CRC Interrupt\nThe CRC module will generate an interrupt when the BUSY bit transitions from ' 1 ' to ' 0 '. The CRC Interrupt Flag (CRCIF) bit of the corresponding PIR register will be set every time the BUSY bit transitions, whether or not the CRC Interrupt Enable (CRCIE) has been set. The CRCIF bit must be cleared by software by the user. If the user has the CRCIE bit set, then the CPU will jump to the Interrupt Service Routine (ISR) every time that the CRCIF bit is set.",
    "13.6 Configuring the CRC Module\nThe following steps illustrate how to properly configure the CRC:",
    "13.6 Configuring the CRC Module\n1. Determine if the automatic program memory scan will be used with the scanner or if manual calculation will take place through the SFR interface and perform the actions specified in the CRC Data Sources section.\na. To configure the scanner module to be used with CRC, refer to the Configuring the Scanner section for more information.\n2. When applicable, seed a starting CRC value into the CRCOUT registers.\n3. Program the CRCXOR registers with the desired generator polynomial.\n4. Program the DLEN bits with the length of the data word (refer to Figure 13-1). This value determines how many times the shifter will shift into the accumulator for each data word.\n5. Program the PLEN bits with the length of the polynomial (refer to Figure 13-1).\n6. Determine whether shifting in trailing zeroes is desired and set the ACCM bit accordingly.\n7. Determine whether the MSb or LSb first shifting is desired and write the SHIFTM bit accordingly.\n8. Set the GO bit to begin the shifting process.\n9. If manual SFR entry is used, monitor the FULL bit.",
    "13.6 Configuring the CRC Module\na. When FULL = 0 , another word of data can be written to the CRCDATA registers. It is important to note that the Most Significant Byte (CRCDATAH) must be written first if the data have more than eight bits, as the shifter will begin upon the CRCDATAL register being written.\nb. If the scanner is used, it will automatically load words into the CRCDATA registers as needed, as long as the GO bit is set.\n10. If using the Flash memory scanner, monitor the SCANIF bit of the corresponding PIR register to determine when the scanner has finished pushing data into the CRCDATA registers.\na. After the scan is completed, monitor the SGO bit to determine that the CRC has been completed and the check value can be read from the CRCOUT registers.\nb. When both the interrupt flags are set (or both BUSY and SGO bits are cleared), the completed CRC calculation can be read from the CRCOUT registers.\n11. If manual entry is used, monitor the BUSY bit to determine when the CRCOUT registers hold the valid check value.",
    "13.6.1 Register Overlay\nThe CRCOUT, CRCSHIFT and CRCXOR registers are grouped together and share SFR space. Since these register groups are located within the same addresses, the SETUP bits must be configured accordingly to access any of these registers. Refer to the CRCCON2 register for more information about how the SETUP bits can be configured to access each of the available CRC registers.",
    "13.7 Scanner Module Overview\nThe scanner allows segments of the Program Flash Memory or Data EEPROM to be read out (scanned) to the CRC peripheral. The scanner module interacts with the CRC module and supplies it with data, one word at a time. Data are fetched from the address range defined by SCANLADR registers up to the SCANHADR registers. The scanner begins operation when the SGO bit is set and ends when either SGO is cleared by the user or when SCANLADR increments past SCANHADR. The SGO bit is also cleared when the EN bit in the CRCCON0 register is cleared.",
    "13.8 Scanning Modes\nThe interaction of the scanner with the system operation is controlled by the priority selection in the system arbiter (refer to the 'Memory Access Scheme' section for more details). When using the scanner module in conjunction with the CRC module, the system arbiter needs to be configured such that the scanner has a higher priority than the CPU to ensure that a memory access request is granted when it occurs. Additionally, BURSTMD and TRIGEN bits also determine the operation of the scanner.",
    "13.8.1 TRIGEN = 0 , BURSTMD = 0\nIn this case, the memory access request is granted to the scanner if no other higher priority source is requesting access. All sources with lower priority than the scanner will get the memory access cycles that are not utilized by the scanner.",
    "13.8.2 TRIGEN = 1 , BURSTMD = 0\nIn this case, the memory access request is generated when the CRC module is ready to accept. The memory access request is granted to the scanner if no other higher priority source is requesting access. All sources with lower priority than the scanner will get the memory access cycles that are not utilized by the scanner.",
    "13.8.3 TRIGEN = x , BURSTMD = 1\nIn this case, the memory access is always requested by the scanner. The memory access request is granted to the scanner if no other higher priority source is requesting access. The memory access cycles will not be granted to lower priority sources than the scanner until it completes operation, i.e. SGO = 0 .\nImportant: If TRIGEN = 1 and BURSTMD = 1 , the user needs to ensure that the trigger source is active for the scanner operation to complete.",
    "13.8.4 WWDT Interaction\nThe Windowed Watch Dog Timer (WWDT) operates in the background during scanner activity. It is possible that long scans, particularly in Burst mode, may exceed the WWDT time-out period and result in an undesired device Reset. This must be considered when performing memory scans with an application that also utilizes WWDT.",
    "13.9 Configuring the Scanner\nThe scanner module may be used in conjunction with the CRC module to perform a CRC calculation over a range of program memory or Data EEPROM addresses. To set up the scanner to work with the CRC, perform the following steps:",
    "13.9 Configuring the Scanner\n1. Set up the CRC module (see the Configuring the CRC Module section) and enable the scanner module by setting the EN bit in the SCANCON0 register.\n2. Choose which memory region the scanner module needs to operate on and set the MREG bit appropriately.\n3. If trigger is used for scanner operation, set the TRIGEN bit and select the trigger source using the SCANTRIG register. Select the trigger source using the SCANTRIG register and then set the TRIGEN bit.\n4. If Burst mode of operation is desired, set the BURSTMD bit.\n5. Set the SCANLADR and SCANHADR registers with the beginning and ending locations in memory that are to be scanned.\n6. Select the priority level for the scanner module (refer to the 'System Arbitration' and the 'Priority Lock' sections for more details).\nNote: The default priority levels of the system arbiter may need to be changed to ensure the scanner operates as intended and that a memory access request is granted when it occurs.\n7. Both EN and GO bits in the CRCCON0 register must be enabled to use the scanner. Setting the SGO bit will start the scanner operation.",
    "13.10 Scanner Interrupt\nThe scanner will trigger an interrupt when the SGO bit transitions from ' 1 ' to ' 0 '. The SCANIF interrupt flag of one of the PIR registers is set when the last memory location is reached and the data are entered into the CRCDATA registers. The SCANIF bit must be cleared by software. The SCAN interrupt enable is the SCANIE bit of the corresponding PIE register.",
    "13.11 Peripheral Module Disable\nBoth the CRC and scanner module can be disabled individually by setting the CRCMD and SCANMD bits of one of the PMD registers (see the 'PMD - Peripheral Module Disable' chapter for more details). The SCANMD bit can be used to enable or disable the scanner module only if the SCANE Configuration bit is set. If the SCANE bit is cleared, then the scanner module is not available for use and the SCANMD bit is ignored.",
    "13.12 Register Definitions: CRC and Scanner Control\nLong bit name prefixes for the CRC are shown in the table below. Refer to the ' Long Bit Names ' section in the ' Register and Bit Naming Conventions ' chapter for more information.\nTable 13-1. CRC Long Bit Name Prefixes\n\nCRC, Bit Name Prefix = CRC",
    "13.12.1  CRCCON0\nName: Address:\nCRCCON0\n0x356",
    "CRC Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 1. Bit, 7 = 0. , 1 = EN. , 2 = GO. , 3 = BUSY. , 4 = ACCM. , 5 = SETUP[1:0]. , 6 = SHIFTM. , 7 = FULL. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 7 - EN CRC Enable\n1, Description = CRC module is released from Reset. 0, Description = CRC is disabled and consumes no operating current",
    "Bit 6 - GO CRC Start\n1, Description = Start CRC serial shifter. 0, Description = CRC serial shifter turned off",
    "Bit 5 - BUSY CRC Busy\n1, Description = Shifting in progress or pending. 0, Description = All valid bits in shifter have been shifted into accumulator and EMPTY = 1",
    "Bit 4 - ACCM Accumulator Mode\n1, Description = Data are augmented with zeros. 0, Description = Data are not augmented with zeros",
    "Bits 4:3 - SETUP[1:0]\nRegister Overlay Setup\n11, Description = CRC Register Overlay Selection; Read / Write access to CRCOUT. 10, Description = CRC Register Overlay Selection; Read / Write access to CRCXOR. 01, Description = CRC Register Overlay Selection; Read / Write access to CRCSHIFT. 00, Description = CRC Register Overlay Selection; Read / Write access to CRCOUT",
    "Bit 1 - SHIFTM Shift Mode\n1, Description = Shift right (LSb first). 0, Description = Shift left (MSb first)",
    "Bit 0 - FULL Data Path Full Indicator\n1, Description = CRCDATAT/U/H/L registers are full. 0, Description = CRCDATAT/U/H/L registers have shifted their data into the shifter",
    "13.12.2  CRCCON1\nName: Address:\nCRCCON1\n0x357\nCRC Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = PLEN[4:0]. , 5 = PLEN[4:0]. , 6 = PLEN[4:0]. , 7 = PLEN[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\nBits 4:0 - PLEN[4:0] Polynomial Length Denotes the length of the polynomial (n-1)",
    "13.12.3  CRCCON2\nName: Address:\nCRCCON2\n0x358\nCRC Control Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = DLEN[4:0]. , 5 = DLEN[4:0]. , 6 = DLEN[4:0]. , 7 = DLEN[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\nBits 4:0 - DLEN[4:0] Data Length\nDenotes the length of the data word (n-1)",
    "13.12.4  CRCDATA\nName: Address:\nCRCDATA 0x34E\nCRC Data Registers",
    "13.12.4  CRCDATA\n, 31 = CRCDATAT[7:0]. , 30 = CRCDATAT[7:0]. , 29 = CRCDATAT[7:0]. , 28 = CRCDATAT[7:0]. , 27 = CRCDATAT[7:0]. , 26 = CRCDATAT[7:0]. , 25 = CRCDATAT[7:0]. , 24 = CRCDATAT[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit,",
    "13.12.4  CRCDATA\n26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = CRCDATAU[7:0]. , 30 = CRCDATAU[7:0]. , 29 = CRCDATAU[7:0]. , 28 = CRCDATAU[7:0]. , 27 = CRCDATAU[7:0]. , 26 = CRCDATAU[7:0]. , 25 = CRCDATAU[7:0]. , 24 = CRCDATAU[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 =",
    "13.12.4  CRCDATA\n13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = CRCDATAH[7:0]. , 30 = CRCDATAH[7:0]. , 29 = CRCDATAH[7:0]. , 28 = CRCDATAH[7:0]. , 27 = CRCDATAH[7:0]. , 26 = CRCDATAH[7:0]. , 25 = CRCDATAH[7:0]. , 24 = CRCDATAH[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0.",
    "13.12.4  CRCDATA\nBit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = CRCDATAL[7:0]. , 30 = CRCDATAL[7:0]. , 29 = CRCDATAL[7:0]. , 28 = CRCDATAL[7:0]. , 27 = CRCDATAL[7:0]. , 26 = CRCDATAL[7:0]. , 25 = CRCDATAL[7:0]. , 24 = CRCDATAL[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 =",
    "13.12.4  CRCDATA\n0. Reset, 24 = 0\nBits 31:24 - CRCDATAT[7:0] CRC Data Top Byte\nBits 23:16 - CRCDATAU[7:0] CRC Data Upper Byte Bits 15:8 - CRCDATAH[7:0] CRC Data High Byte Bits 7:0 - CRCDATAL[7:0] CRC Data Low Byte",
    "13.12.5  CRCOUT\nName: Address:\nCRCOUT\n0x352",
    "CRC Output Registers\n, 31 = CRCOUTT[7:0]. , 30 = CRCOUTT[7:0]. , 29 = CRCOUTT[7:0]. , 28 = CRCOUTT[7:0]. , 27 = CRCOUTT[7:0]. , 26 = CRCOUTT[7:0]. , 25 = CRCOUTT[7:0]. , 24 = CRCOUTT[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18.",
    "CRC Output Registers\nBit, 25 = 17. Bit, 24 = 16. , 31 = CRCOUTU[7:0]. , 30 = CRCOUTU[7:0]. , 29 = CRCOUTU[7:0]. , 28 = CRCOUTU[7:0]. , 27 = CRCOUTU[7:0]. , 26 = CRCOUTU[7:0]. , 25 = CRCOUTU[7:0]. , 24 = CRCOUTU[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12.",
    "CRC Output Registers\nBit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = CRCOUTH[7:0]. , 30 = CRCOUTH[7:0]. , 29 = CRCOUTH[7:0]. , 28 = CRCOUTH[7:0]. , 27 = CRCOUTH[7:0]. , 26 = CRCOUTH[7:0]. , 25 = CRCOUTH[7:0]. , 24 = CRCOUTH[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit,",
    "CRC Output Registers\n28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = CRCOUTL[7:0]. , 30 = CRCOUTL[7:0]. , 29 = CRCOUTL[7:0]. , 28 = CRCOUTL[7:0]. , 27 = CRCOUTL[7:0]. , 26 = CRCOUTL[7:0]. , 25 = CRCOUTL[7:0]. , 24 = CRCOUTL[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bits 31:24 - CRCOUTT[7:0] CRC Output Register Top Byte\nWriting to this register writes the Most Significant Byte of the CRC output register. Reading from this register reads the Most Significant Byte of the CRC output.\nBits 23:16 - CRCOUTU[7:0] CRC Output Register Upper Byte\nBits 15:8 - CRCOUTH[7:0] CRC Output Register High Byte",
    "Bits 7:0 - CRCOUTL[7:0] CRC Output Register Low Byte\nWriting to this register writes the Least Significant Byte of the CRC output register. Reading from this register reads the Least Significant Byte of the CRC output.",
    "13.12.6  CRCSHIFT\nName: Address:\nCRCSHIFT\n0x352\nCRC Shift Registers",
    "13.12.6  CRCSHIFT\n, 31 = CRCSHIFTT[7:0]. , 30 = CRCSHIFTT[7:0]. , 29 = CRCSHIFTT[7:0]. , 28 = CRCSHIFTT[7:0]. , 27 = CRCSHIFTT[7:0]. , 26 = CRCSHIFTT[7:0]. , 25 = CRCSHIFTT[7:0]. , 24 = CRCSHIFTT[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25",
    "13.12.6  CRCSHIFT\n= 17. Bit, 24 = 16. , 31 = CRCSHIFTU[7:0]. , 30 = CRCSHIFTU[7:0]. , 29 = CRCSHIFTU[7:0]. , 28 = CRCSHIFTU[7:0]. , 27 = CRCSHIFTU[7:0]. , 26 = CRCSHIFTU[7:0]. , 25 = CRCSHIFTU[7:0]. , 24 = CRCSHIFTU[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11.",
    "13.12.6  CRCSHIFT\nBit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = CRCSHIFTH[7:0]. , 30 = CRCSHIFTH[7:0]. , 29 = CRCSHIFTH[7:0]. , 28 = CRCSHIFTH[7:0]. , 27 = CRCSHIFTH[7:0]. , 26 = CRCSHIFTH[7:0]. , 25 = CRCSHIFTH[7:0]. , 24 = CRCSHIFTH[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28",
    "13.12.6  CRCSHIFT\n= 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = CRCSHIFTL[7:0]. , 30 = CRCSHIFTL[7:0]. , 29 = CRCSHIFTL[7:0]. , 28 = CRCSHIFTL[7:0]. , 27 = CRCSHIFTL[7:0]. , 26 = CRCSHIFTL[7:0]. , 25 = CRCSHIFTL[7:0]. , 24 = CRCSHIFTL[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bits 31:24 - CRCSHIFTT[7:0] CRC Shift Register Top Byte\nReading from this register reads the Most Significant Byte of the CRC Shifter.\nBits 23:16 - CRCSHIFTU[7:0] CRC Shift Register Upper Byte\nBits 15:8 - CRCSHIFTH[7:0] CRC Shift Register High Byte",
    "Bits 7:0 - CRCSHIFTL[7:0] CRC Shift Register Low Byte\nReading from this register reads the Least Significant Byte of the CRC Shifter.",
    "13.12.7  CRCXOR\nName: Address:\nCRCXOR\n0x352\nCRC XOR Registers",
    "13.12.7  CRCXOR\n, 31 = CRCXORT[7:0]. , 30 = CRCXORT[7:0]. , 29 = CRCXORT[7:0]. , 28 = CRCXORT[7:0]. , 27 = CRCXORT[7:0]. , 26 = CRCXORT[7:0]. , 25 = CRCXORT[7:0]. , 24 = CRCXORT[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19.",
    "13.12.7  CRCXOR\nBit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = CRCXORU[7:0]. , 30 = CRCXORU[7:0]. , 29 = CRCXORU[7:0]. , 28 = CRCXORU[7:0]. , 27 = CRCXORU[7:0]. , 26 = CRCXORU[7:0]. , 25 = CRCXORU[7:0]. , 24 = CRCXORU[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 =",
    "13.12.7  CRCXOR\n15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = CRCXORH[7:0]. , 30 = CRCXORH[7:0]. , 29 = CRCXORH[7:0]. , 28 = CRCXORH[7:0]. , 27 = CRCXORH[7:0]. , 26 = CRCXORH[7:0]. , 25 = CRCXORH[7:0]. , 24 = CRCXORH[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27",
    "13.12.7  CRCXOR\n= 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = CRCXORL[7:0]. , 30 = CRCXORL[7:0]. , 29 = CRCXORL[7:0]. , 28 = CRCXORL[7:0]. , 27 = CRCXORL[7:0]. , 26 = CRCXORL[7:0]. , 25 = CRCXORL[7:0]. , 24 = CRCXORL[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset,",
    "13.12.7  CRCXOR\n31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0\nBits 31:24 - CRCXORT[7:0] XOR of Polynomial Term XN Enable Top Byte Bits 23:16 - CRCXORU[7:0] XOR of Polynomial Term XN Enable Upper Byte Bits 15:8 - CRCXORH[7:0] XOR of Polynomial Term XN Enable High Byte Bits 7:0 - CRCXORL[7:0] XOR of Polynomial Term XN Enable Low Byte",
    "13.12.8  SCANCON0\nName: Address:\nSCANCON0\n0x360",
    "Scanner Access Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = TRIGEN. , 3 = SGO. , 4 = . , 5 = . , 6 = MREG. , 7 = BURSTMD. , 8 = BUSY. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W/HC. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN  Scanner Enable (1)\n1, Description = Scanner is enabled. 0, Description = Scanner is disabled",
    "Bit 6 - TRIGEN  Scanner Trigger Enable (2,5)\n1, Description = Scanner trigger is enabled. 0, Description = Scanner trigger is disabled",
    "Bit 5 - SGO  Scanner GO (3,4)\n1, Description = When the CRC is ready, the Memory region set by the MREG bit will be accessed and data are passed to the CRC peripheral. 0, Description = Scanner operations will not occur",
    "Bit 2 - MREG  Scanner Memory Region Select (2)\n1, Description = Scanner address points to Data EEPROM. 0, Description = Scanner address points to Program Flash Memory",
    "Bit 1 - BURSTMD  Scanner Burst Mode (5)\n1, Description = Memory access request to the CPU Arbiter is always true. 0, Description = Memory access request to the CPU Arbiter is dependent on the CRC request and trigger",
    "Bit 0 - BUSY Scanner Busy Indicator\n1, Description = Scanner cycle is in process. 0, Description = Scanner cycle is compete (or never started)",
    "Notes:\n1. Setting EN = 0 does not affect any other register content.\n2. Scanner trigger selection can be set using the SCANTRIG register.\n3. This bit can be cleared in software. It is cleared in hardware when LADR > HADR (and a data cycle is not occurring) or when CRCGO = 0 .\n4. The CRCEN and CRCGO bits must be set before setting the SGO bit.\n5. See Table 13-2.",
    "Table 13-2. Scanner Operating Modes\n0, BURSTMD = 0. 0, Scanner Operation = Memory access is requested when the CRC module is ready to accept data; the request is granted if no other higher priority source request is pending.. 1, BURSTMD = 0. 1, Scanner Operation = Memory access is requested when the CRC module is ready to accept data and trigger selection is true; the request is granted if no other higher priority source request is pending.. x, BURSTMD = 1. x, Scanner Operation = Memory access is always requested; the request is granted if no other higher priority source request is pending.\nNote: Refer to the 'System Arbitration' and the 'Memory Access Scheme' sections for more details about Priority selection and Memory Access Scheme.",
    "13.12.9  SCANLADR\nName: Address:\nSCANLADR 0x35A",
    "Scan Low Address Registers\n, 23 = . , 22 = . , 21 = SCANLADRU[5:0]. , 20 = SCANLADRU[5:0]. , 19 = SCANLADRU[5:0]. , 18 = SCANLADRU[5:0]. , 17 = SCANLADRU[5:0]. , 16 = SCANLADRU[5:0]. Access, 23 = . Access, 22 = . Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 = SCANLADRH[7:0]. , 22 =",
    "Scan Low Address Registers\nSCANLADRH[7:0]. , 21 = SCANLADRH[7:0]. , 20 = SCANLADRH[7:0]. , 19 = SCANLADRH[7:0]. , 18 = SCANLADRH[7:0]. , 17 = SCANLADRH[7:0]. , 16 = SCANLADRH[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2. Bit, 17 = 1. Bit, 16 = 0. , 23 =",
    "Scan Low Address Registers\nSCANLADRL[7:0]. , 22 = SCANLADRL[7:0]. , 21 = SCANLADRL[7:0]. , 20 = SCANLADRL[7:0]. , 19 = SCANLADRL[7:0]. , 18 = SCANLADRL[7:0]. , 17 = SCANLADRL[7:0]. , 16 = SCANLADRL[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0",
    "Bits 21:16 - SCANLADRU[5:0] Scan Start/Current Address upper byte\nUpper bits of the current address to be fetched from, value increments on each fetch of memory.",
    "Bits 15:8 - SCANLADRH[7:0] Scan Start/Current Address high byte\nHigh byte of the current address to be fetched from, value increments on each fetch of memory.",
    "Bits 7:0 - SCANLADRL[7:0] Scan Start/Current Address low byte\nLow byte of the current address to be fetched from, value increments on each fetch of memory.",
    "Notes:\n1. Registers SCANLADRU/H/L form a 22-bit value, but are not guarded for atomic or asynchronous access; registers may only be read or written while SGO = 0 .\n2. While SGO = 1 , writing to this register is ignored.",
    "13.12.10 SCANHADR\nName:\nSCANHADR\nAddress:\n0x35D\nScan High Address Registers",
    "13.12.10 SCANHADR\n, 23 = . , 22 = . , 21 = SCANHADRU[5:0]. , 20 = SCANHADRU[5:0]. , 19 = SCANHADRU[5:0]. , 18 = SCANHADRU[5:0]. , 17 = SCANHADRU[5:0]. , 16 = SCANHADRU[5:0]. Access, 23 = . Access, 22 = . Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 = SCANHADRH[7:0]. , 22 =",
    "13.12.10 SCANHADR\nSCANHADRH[7:0]. , 21 = SCANHADRH[7:0]. , 20 = SCANHADRH[7:0]. , 19 = SCANHADRH[7:0]. , 18 = SCANHADRH[7:0]. , 17 = SCANHADRH[7:0]. , 16 = SCANHADRH[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 1. Reset, 22 = 1. Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2. Bit, 17 = 1. Bit, 16 = 0. , 23 =",
    "13.12.10 SCANHADR\nSCANHADRL[7:0]. , 22 = SCANHADRL[7:0]. , 21 = SCANHADRL[7:0]. , 20 = SCANHADRL[7:0]. , 19 = SCANHADRL[7:0]. , 18 = SCANHADRL[7:0]. , 17 = SCANHADRL[7:0]. , 16 = SCANHADRL[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 1. Reset, 22 = 1. Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1",
    "Bits 21:16 - SCANHADRU[5:0] Scan End Address\nUpper bits of the address at the end of the designated scan",
    "Bits 15:8 - SCANHADRH[7:0] Scan End Address\nHigh byte of the address at the end of the designated scan",
    "Bits 7:0 - SCANHADRL[7:0] Scan End Address\nLow byte of the address at the end of the designated scan",
    "Notes:\n1. Registers SCANHADRU/H/L form a 22-bit value but are not guarded for atomic or asynchronous access; registers may only be read or written while SGO = 0 .\n2. While SGO = 1 , writing to this register is ignored.",
    "13.12.11 SCANTRIG\nName:\nSCANTRIG\nAddress:\n0x361\nSCAN Trigger Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = TSEL[3:0]. , 6 = TSEL[3:0]. , 7 = TSEL[3:0]. , 8 = TSEL[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 3:0 - TSEL[3:0] Scanner Data Trigger Input Selection",
    "13.12.11 SCANTRIG\nTable 13-3. Scanner Data Trigger Input Sources\n\n1111 - 1100, Trigger Input Sources = -. 1011, Trigger Input Sources = CLC4_OUT. 1010, Trigger Input Sources = CLC3_OUT. 1001, Trigger Input Sources = CLC2_OUT. 1000, Trigger Input Sources = CLC1_OUT. 0111, Trigger Input Sources = SMT1_OUT. 0110, Trigger Input Sources = TMR4_Postscaler_OUT. 0101, Trigger Input Sources = TMR3_OUT. 0100, Trigger Input Sources = TMR2_Postscaler_OUT. 0011, Trigger Input Sources = TMR1_OUT. 0010, Trigger Input Sources = TMR0_OUT. 0001, Trigger Input Sources = CLCKREF_OUT. 0000, Trigger Input Sources = LFINTOSC (1)",
    "Note:\n- 1. The number of implemented bits varies by device.",
    "13.13 Register Summary - CRC\n0x00 ... 0x034D, Name = Reserved. 0x00 ... 0x034D, Bit Pos. = . 0x00 ... 0x034D, 6 = . 0x00 ... 0x034D, 5 = . 0x00 ... 0x034D, 4 = . 0x00 ... 0x034D, 3 = . 0x00 ... 0x034D, 2 = . 0x00 ... 0x034D, 1 = . 0x00 ... 0x034D, 0 = . 0x034E, Name = CRCDATA. 0x034E, Bit Pos. = 7:0. 0x034E, 6 = . 0x034E, 5 = . 0x034E, 4 = CRCDATAL[7:0]. 0x034E, 3 = CRCDATAL[7:0]. 0x034E, 2 = . 0x034E, 1 = . 0x034E, 0 = .",
    "13.13 Register Summary - CRC\n0x034E, Name = CRCDATA. 0x034E, Bit Pos. = 15:8. 0x034E, 6 = . 0x034E, 5 = . 0x034E, 4 = CRCDATAH[7:0]. 0x034E, 3 = CRCDATAH[7:0]. 0x034E, 2 = . 0x034E, 1 = . 0x034E, 0 = . 0x034E, Name = CRCDATA. 0x034E, Bit Pos. = 23:16. 0x034E, 6 = . 0x034E, 5 = . 0x034E, 4 = CRCDATAU[7:0]. 0x034E, 3 = CRCDATAU[7:0]. 0x034E, 2 = . 0x034E, 1 = . 0x034E, 0 = . 0x034E, Name = CRCDATA. 0x034E, Bit Pos. = 31:24.",
    "13.13 Register Summary - CRC\n0x034E, 6 = . 0x034E, 5 = . 0x034E, 4 = CRCDATAT[7:0]. 0x034E, 3 = CRCDATAT[7:0]. 0x034E, 2 = . 0x034E, 1 = . 0x034E, 0 = . 0x0352, Name = CRCOUT. 0x0352, Bit Pos. = 7:0. 0x0352, 6 = . 0x0352, 5 = . 0x0352, 4 = CRCOUTL[7:0]. 0x0352, 3 = CRCOUTL[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = . 0x0352, Name = CRCOUT. 0x0352, Bit Pos. = 15:8. 0x0352, 6 = . 0x0352, 5 = . 0x0352, 4 =",
    "13.13 Register Summary - CRC\nCRCOUTH[7:0]. 0x0352, 3 = CRCOUTH[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = . 0x0352, Name = CRCOUT. 0x0352, Bit Pos. = 23:16. 0x0352, 6 = . 0x0352, 5 = . 0x0352, 4 = CRCOUTU[7:0]. 0x0352, 3 = CRCOUTU[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = . 0x0352, Name = CRCOUT. 0x0352, Bit Pos. = 31:24. 0x0352, 6 = . 0x0352, 5 = . 0x0352, 4 = CRCOUTT[7:0]. 0x0352, 3 = CRCOUTT[7:0]. 0x0352,",
    "13.13 Register Summary - CRC\n2 = . 0x0352, 1 = . 0x0352, 0 = . 0x0352, Name = CRCSHIFT. 0x0352, Bit Pos. = 7:0. 0x0352, 6 = . 0x0352, 5 = . 0x0352, 4 = CRCSHIFTL[7:0]. 0x0352, 3 = CRCSHIFTL[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = . 0x0352, Name = CRCSHIFT. 0x0352, Bit Pos. = 15:8. 0x0352, 6 = . 0x0352, 5 = . 0x0352, 4 = CRCSHIFTH[7:0]. 0x0352, 3 = CRCSHIFTH[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = .",
    "13.13 Register Summary - CRC\n0x0352, Name = CRCSHIFT. 0x0352, Bit Pos. = 23:16. 0x0352, 6 = . 0x0352, 5 = . 0x0352, 4 = CRCSHIFTU[7:0]. 0x0352, 3 = CRCSHIFTU[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = . 0x0352, Name = CRCSHIFT. 0x0352, Bit Pos. = 31:24. 0x0352, 6 = . 0x0352, 5 = . 0x0352, 4 = CRCSHIFTT[7:0]. 0x0352, 3 = CRCSHIFTT[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = . 0x0352, Name = . 0x0352, Bit Pos. = 7:0.",
    "13.13 Register Summary - CRC\n0x0352, 6 = . 0x0352, 5 = . 0x0352, 4 = CRCXORL[7:0]. 0x0352, 3 = CRCXORL[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = . 0x0352, Name = CRCXOR. 0x0352, Bit Pos. = 15:8. 0x0352, 6 = . 0x0352, 5 = . 0x0352, 4 = CRCXORH[7:0]. 0x0352, 3 = CRCXORH[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = . 0x0352, Name = . 0x0352, Bit Pos. = 23:16. 0x0352, 6 = . 0x0352, 5 = . 0x0352, 4 =",
    "13.13 Register Summary - CRC\nCRCXORU[7:0]. 0x0352, 3 = CRCXORU[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = . , Name = . , Bit Pos. = 31:24. , 6 = . , 5 = . , 4 = CRCXORT[7:0]. , 3 = CRCXORT[7:0]. , 2 = . , 1 = . , 0 = . 0x0356, Name = CRCCON0. 0x0356, Bit Pos. = 7:0. 0x0356, 6 = GO. 0x0356, 5 = BUSY. 0x0356, 4 = ACCM. 0x0356, 3 = SETUP[1:0]. 0x0356, 2 = . 0x0356, 1 = SHIFTM. 0x0356, 0 = FULL. 0x0357, Name = CRCCON1. 0x0357, Bit Pos. =",
    "13.13 Register Summary - CRC\n7:0. 0x0357, 6 = . 0x0357, 5 = . 0x0357, 4 = PLEN[4:0]. 0x0357, 3 = PLEN[4:0]. 0x0357, 2 = PLEN[4:0]. 0x0357, 1 = PLEN[4:0]. 0x0357, 0 = PLEN[4:0]. 0x0358, Name = CRCCON2. 0x0358, Bit Pos. = 7:0. 0x0358, 6 = . 0x0358, 5 = . 0x0358, 4 = DLEN[4:0]. 0x0358, 3 = DLEN[4:0]. 0x0358, 2 = DLEN[4:0]. 0x0358, 1 = DLEN[4:0]. 0x0358, 0 = DLEN[4:0]. 0x0359, Name = Reserved. 0x0359, Bit Pos.",
    "13.13 Register Summary - CRC\n= . 0x0359, 6 = . 0x0359, 5 = . 0x0359, 4 = . 0x0359, 3 = . 0x0359, 2 = . 0x0359, 1 = . 0x0359, 0 = . 0x035A, Name = . 0x035A, Bit Pos. = 7:0. 0x035A, 6 = . 0x035A, 5 = . 0x035A, 4 = SCANLADRL[7:0]. 0x035A, 3 = SCANLADRL[7:0]. 0x035A, 2 = SCANLADRL[7:0]. 0x035A, 1 = SCANLADRL[7:0]. 0x035A, 0 = SCANLADRL[7:0]. 0x035A, Name = SCANLADR. 0x035A, Bit Pos. = 15:8. 0x035A, 6 = . 0x035A, 5 = . 0x035A, 4 =",
    "13.13 Register Summary - CRC\nSCANLADRH[7:0]. 0x035A, 3 = SCANLADRH[7:0]. 0x035A, 2 = SCANLADRH[7:0]. 0x035A, 1 = SCANLADRH[7:0]. 0x035A, 0 = SCANLADRH[7:0]. 0x035A, Name = . 0x035A, Bit Pos. = 23:16. 0x035A, 6 = . 0x035A, 5 = . 0x035A, 4 = SCANLADRU[5:0]. 0x035A, 3 = SCANLADRU[5:0]. 0x035A, 2 = SCANLADRU[5:0]. 0x035A, 1 = SCANLADRU[5:0]. 0x035A, 0 = SCANLADRU[5:0]. 0x035D, Name = . 0x035D, Bit Pos. = 7:0. 0x035D, 6 = . 0x035D, 5 = .",
    "13.13 Register Summary - CRC\n0x035D, 4 = SCANHADRL[7:0]. 0x035D, 3 = SCANHADRL[7:0]. 0x035D, 2 = SCANHADRL[7:0]. 0x035D, 1 = SCANHADRL[7:0]. 0x035D, 0 = SCANHADRL[7:0]. 0x035D, Name = SCANHADR. 0x035D, Bit Pos. = 15:8. 0x035D, 6 = . 0x035D, 5 = . 0x035D, 4 = SCANHADRH[7:0]. 0x035D, 3 = SCANHADRH[7:0]. 0x035D, 2 = SCANHADRH[7:0]. 0x035D, 1 = SCANHADRH[7:0]. 0x035D, 0 = SCANHADRH[7:0]. 0x035D, Name = . 0x035D, Bit Pos. = 23:16. 0x035D, 6 = .",
    "13.13 Register Summary - CRC\n0x035D, 5 = . 0x035D, 4 = SCANHADRU[5:0]. 0x035D, 3 = SCANHADRU[5:0]. 0x035D, 2 = SCANHADRU[5:0]. 0x035D, 1 = SCANHADRU[5:0]. 0x035D, 0 = SCANHADRU[5:0]. 0x0360, Name = SCANCON0. 0x0360, Bit Pos. = 7:0. 0x0360, 6 = TRIGEN. 0x0360, 5 = SGO. 0x0360, 4 = . 0x0360, 3 = . 0x0360, 2 = . 0x0360, 1 = . 0x0360, 0 = . 0x0361, Name = SCANTRIG. 0x0361, Bit Pos. = 7:0. 0x0361, 6 = . 0x0361, 5 = . 0x0361, 4 = MREG BURSTMD BUSY",
    "13.13 Register Summary - CRC\nTSEL[3:0]. 0x0361, 3 = MREG BURSTMD BUSY TSEL[3:0]. 0x0361, 2 = MREG BURSTMD BUSY TSEL[3:0]. 0x0361, 1 = MREG BURSTMD BUSY TSEL[3:0]. 0x0361, 0 = MREG BURSTMD BUSY TSEL[3:0]",
    "14. Resets\nThere are multiple ways to reset the device:\n\u00b7 Power-on Reset (POR)\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Low-Power Brown-out Reset (LPBOR)\n\u00b7 MCLR Reset\n\u00b7 WDT Reset\n\u00b7 RESET instruction\n\u00b7 Stack Overflow\n\u00b7 Stack Underflow\n\u00b7 Programming mode exit\n\u00b7 Memory Execution Violation Reset\n\u00b7 Main LDO Voltage Regulator Reset\n\u00b7 Configuration Memory Reset\nA simplified block diagram of the On-Chip Reset Circuit is shown in the block diagram below.\nFigure 14-1. Simplified Block Diagram of On-Chip Reset Circuit",
    "Note:\n- 1. See the BOR Operating Modes table for BOR active conditions.",
    "14.1 Power-on Reset (POR)\nThe POR circuit holds the device in Reset until V DD has reached an acceptable level for minimum operation. Slow rising V DD, fast operating speeds or analog performance may require greater than\nminimum VDD. The PWRT, BOR or MCLR features can be used to extend the start-up period until all device operation conditions have been met. The POR bit will be set to ' 0 ' if a Power-on Reset has occurred.",
    "14.2 Brown-out Reset (BOR)\nThe BOR circuit holds the device in Reset when VDD reaches a selectable minimum level. Between the POR and BOR, complete voltage range coverage for execution protection can be implemented. The BOR bit will be set to ' 0 ' if a BOR has occurred.\nThe BOR module has four operating modes controlled by the BOREN Configuration bits. The four operating modes are:\n\u00b7 BOR is always on\n\u00b7 BOR is off when in Sleep\n\u00b7 BOR is controlled by software\n\u00b7 BOR is always off\nRefer to the BOR Operating Modes table for more information.\nA VDD noise rejection filter prevents the BOR from triggering on small events. If V DD falls below VBOR for a duration greater than parameter TBORDC, the device will reset. Refer to the 'Electrical Specifications' chapter for more details.",
    "14.2.1 BOR Is Always On\nWhen the BOREN Configuration bits are programmed to 'b11 , the BOR is always on. The device start-up will be delayed until the BOR is ready and V DD is higher than the BOR threshold.\nBOR protection is active during Sleep. The BOR does not delay wake-up from Sleep.",
    "14.2.2 BOR Is Off in Sleep\nWhen the BOREN Configuration bits are programmed to 'b10 , the BOR is on, except in Sleep. The device start-up will be delayed until the BOR is ready and V DD is higher than the BOR threshold.\nBOR protection is not active during Sleep. The device wake-up will be delayed until the BOR is ready.",
    "14.2.3 BOR Controlled by Software\nWhen the BOREN Configuration bits are programmed to 'b01 , the BOR is controlled by the SBOREN bit. The device start-up is not delayed by the BOR Ready condition or the V DD level.\nBOR protection begins as soon as the BOR circuit is ready. The status of the BOR circuit is reflected in the BORRDY bit.\nBOR protection selected by SBOREN bit is unchanged by Sleep.",
    "14.2.4 BOR Is Always Off\nWhen the BOREN Configuration bits are programmed to 'b00 , the BOR is off at all times. The device start-up is not delayed by the BOR Ready condition or the VDD level.",
    "14.2.4 BOR Is Always Off\nTable 14-1. Reset Condition for Special Registers\n\nPower-on Reset, Program Counter = 0. Power-on Reset, STATUS Register (1,2) = -110 0000. Power-on Reset, PCON0 Register = 0011 110x. Power-on Reset, PCON1 Register = ---- -111. Brown-out Reset, Program Counter = 0. Brown-out Reset, STATUS Register (1,2) = -110 0000. Brown-out Reset, PCON0 Register = 0011 11u0. Brown-out Reset, PCON1 Register = ---- -u1u. MCLR Reset during normal operation, Program Counter = 0. MCLR Reset during normal operation, STATUS Register (1,2) = -uuu uuuu. MCLR Reset during normal operation, PCON0 Register = uuuu 0uuu. MCLR Reset during normal operation, PCON1 Register = ---- -uuu\n...........continued",
    "14.2.4 BOR Is Always Off\nMCLR Reset during Sleep, Program Counter = 0. MCLR Reset during Sleep, STATUS Register (1,2) = -10u uuuu. MCLR Reset during Sleep, PCON0 Register = uuuu 0uuu. MCLR Reset during Sleep, PCON1 Register = ---- -uuu. WDT Time-out Reset, Program Counter = 0. WDT Time-out Reset, STATUS Register (1,2) = -0uu uuuu. WDT Time-out Reset, PCON0 Register = uuu0 uuuu. WDT Time-out Reset, PCON1 Register = ---- -uuu. WDT Wake-up from Sleep, Program Counter = PC + 2. WDT Wake-up from Sleep, STATUS Register (1,2) = -00u uuuu. WDT Wake-up from Sleep, PCON0 Register = uuuu uuuu. WDT Wake-up from Sleep, PCON1 Register = ---- -uuu. WWDT Window Violation Reset, Program Counter = 0.",
    "14.2.4 BOR Is Always Off\nWWDT Window Violation Reset, STATUS Register (1,2) = -uuu uuuu. WWDT Window Violation Reset, PCON0 Register = uu0u uuuu. WWDT Window Violation Reset, PCON1 Register = ---- -uuu. Interrupt Wake-up from Sleep, Program Counter = PC + 2 (3). Interrupt Wake-up from Sleep, STATUS Register (1,2) = -10u uuuu. Interrupt Wake-up from Sleep, PCON0 Register = uuuu uuuu. Interrupt Wake-up from Sleep, PCON1 Register = ---- -uuu. RESET Instruction Executed, Program Counter = 0. RESET Instruction Executed, STATUS Register (1,2) = -uuu uuuu. RESET Instruction Executed, PCON0 Register = uuuu u0uu. RESET Instruction Executed, PCON1 Register = ---- -uuu. Stack Overflow Reset (STVREN = 1 ), Program Counter = 0. Stack Overflow Reset (STVREN = 1 ), STATUS Register",
    "14.2.4 BOR Is Always Off\n(1,2) = -uuu uuuu. Stack Overflow Reset (STVREN = 1 ), PCON0 Register = 1uuu uuuu. Stack Overflow Reset (STVREN = 1 ), PCON1 Register = ---- -uuu. Stack Underflow Reset (STVREN = 1 ), Program Counter = 0. Stack Underflow Reset (STVREN = 1 ), STATUS Register (1,2) = -uuu uuuu. Stack Underflow Reset (STVREN = 1 ), PCON0 Register = u1uu uuuu. Stack Underflow Reset (STVREN = 1 ), PCON1 Register = ---- -uuu. Data Protection (Fuse Fault), Program Counter = 0. Data Protection (Fuse Fault), STATUS Register (1,2) = -uuu uuuu. Data Protection (Fuse Fault), PCON0 Register = uuuu uuuu. Data Protection (Fuse Fault), PCON1 Register = ---- -uu0. VREG or",
    "14.2.4 BOR Is Always Off\nULP Ready Fault, Program Counter = 0. VREG or ULP Ready Fault, STATUS Register (1,2) = -110 0000. VREG or ULP Ready Fault, PCON0 Register = 0011 110u. VREG or ULP Ready Fault, PCON1 Register = ---- -0u1. Memory Violation Reset, Program Counter = 0. Memory Violation Reset, STATUS Register (1,2) = -uuu uuuu. Memory Violation Reset, PCON0 Register = uuuu uuuu. Memory Violation Reset, PCON1 Register = ---- -u0u\nLegend: u = unchanged, x = unknown, - = unimplemented bit, reads as ' 0 '.",
    "Notes:\n1. If a Status bit is not implemented, that bit will be read as ' 0 '.\n2. Status bits Z, C, DC are reset by POR/BOR.\n3. When the wake-up is due to an interrupt and Global Interrupt Enable (GIE) bit is set, the return address is pushed on the stack and PC is loaded with the corresponding interrupt vector (depending on source, high or low priority) after execution of PC + 2.",
    "Table 14-2. BOR Operating Modes\n11 (1), SBOREN. = X. 11 (1), Device Mode. = X. 11 (1), BOR Mode. = Active. 11 (1), Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 11 (1), Instruction Execution upon:.Wake-Up from Sleep = Begins immediately. 10, SBOREN. = X. 10, Device Mode. = Awake. 10, BOR Mode. = Active. 10, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 10, Instruction Execution upon:.Wake-Up from Sleep = N/A. 10, SBOREN. = X. 10, Device Mode. = Sleep. 10, BOR Mode. = Hibernate. 10, Instruction Execution upon:.Release of POR = N/A. 10, Instruction Execution upon:.Wake-Up from Sleep = Wait for release of BOR (BORRDY = 1 ). 01, SBOREN. = 1. 01, Device Mode. = X. 01, BOR Mode. = Active.",
    "Table 14-2. BOR Operating Modes\n01, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 01, Instruction Execution upon:.Wake-Up from Sleep = Begins immediately. 01, SBOREN. = 0. 01, Device Mode. = X. 01, BOR Mode. = Hibernate. 01, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 01, Instruction Execution upon:.Wake-Up from Sleep = Begins immediately. 00, SBOREN. = X. 00, Device Mode. = X. 00, BOR Mode. = Disabled. 00, Instruction Execution upon:.Release of POR = Begins immediately. 00, Instruction Execution upon:.Wake-Up from Sleep = Begins immediately",
    "Note:\n- 1. In this specific case, 'Release of POR' and 'Wake-up from Sleep', there is no BOR ready delay in start-up. The BOR Ready flag (BORRDY = 1 ) will be set before the CPU is ready to execute instructions, because the BOR circuit is forced on by the BOREN bits.",
    "Figure 14-2. Brown-Out Situations\nRev. 30-000092A 4/12/2017\nTPWRT\n(1)\nVBOR\nVDD\nInternal Reset\nVBOR\nVDD\nInternal Reset\nTPWRT (1)\n< TPWRT\nTPWRT (1)\nVBOR\nVDD\nInternal Reset",
    "Note:\n1. TPWRT delay only if the Configuration bits enable the Power-up Timer.",
    "14.2.5 BOR and Bulk Erase\nBOR is forced ON during PFM Bulk Erase operations to make sure that the system code protection cannot be compromised by reducing VDD.\nDuring Bulk Erase, the BOR is enabled at the lowest BOR threshold level, even if it is configured to some other value. If V DD falls, the erase cycle will be aborted, but the device will not be reset.",
    "14.3 Low-Power Brown-out Reset (LPBOR)\nThe Low-Power Brown-out Reset (LPBOR) provides an additional BOR circuit for low-power operation. Refer to the figure below to see how the BOR interacts with other modules.\nThe LPBOR is used to monitor the external VDD pin. When too low of a voltage is detected, the device is held in Reset.",
    "14.3.1 Enabling LPBOR\nThe LPBOR is controlled by the LPBOREN Configuration bit. When the device is erased, the LPBOR module defaults to disabled.",
    "14.3.2 LPBOR Module Output\nThe output of the LPBOR module indicates whether or not a Reset is to be asserted. This signal is OR'd with the Reset signal of the BOR module to provide the generic BOR signal, which goes to the PCON0 register and to the power control block.",
    "14.4 MCLR Reset\nMCLR is an optional external input that can reset the device. The MCLR function is controlled by the MCLRE and LVP Configuration bits (see the table below). The RMCLR bit will be set to ' 0 ' if a MCLR has occurred.\nTable 14-3. MCLR Configuration\n\nx, LVP = 1. x, MCLR = Enabled. 1, LVP = 0. 1, MCLR = Enabled. 0, LVP = 0. 0, MCLR = Disabled",
    "14.4.1 MCLR Enabled\nWhen MCLR is enabled and the pin is held low, the device is held in Reset. The MCLR pin is connected to VDD through an internal weak pull-up.\nThe device has a noise filter in the MCLR Reset path. The filter will detect and ignore small pulses.\nImportant: An internal Reset event ( RESET instruction, BOR, WWDT, POR, STKOVF, STKUNF) does not drive the MCLR pin low.",
    "14.4.2 MCLR Disabled\nWhen MCLR is disabled, the MCLR pin becomes input-only and pin functions such as internal weak pull-ups are under software control.",
    "14.5 Windowed Watchdog Timer (WWDT) Reset\nThe Windowed Watchdog Timer generates a Reset if the firmware does not issue a CLRWDT instruction within the time-out period or window set. The TO and PD bits in the STATUS register and the RWDT bit are changed to indicate a WDT Reset. The WDTWV bit indicates if the WDT Reset has occurred due to a time-out or a window violation.",
    "14.6 RESET Instruction\nA RESET instruction will cause a device Reset. The RI bit will be set to ' 0 '. See Determining the Cause of a Reset for default conditions after a RESET instruction has occurred.",
    "14.7 Stack Overflow/Underflow Reset\nThe device can be reset when the Stack Overflows or Underflows. The STKOVF or STKUNF bits indicate the Reset condition. These Resets are enabled by setting the STVREN Configuration bit.",
    "14.8 Programming Mode Exit\nUpon exit of Programming mode, the device will operate as if a POR had just occurred.",
    "14.9 Power-up Timer (PWRT)\nThe Power-up Timer provides a selected time-out duration on POR or Brown-out Reset.\nThe device is held in Reset as long as PWRT is active. The PWRT delay allows additional time for V DD to rise to an acceptable level. The Power-up Timer is selected by setting the PWRTS Configuration bits accordingly.\nThe Power-up Timer starts after the release of the POR and BOR/LPBOR if enabled, as shown in Figure 14-4.",
    "14.10 Start-Up Sequence\nUpon the release of a POR or BOR, the following must occur before the device will begin executing:\n1. Power-up Timer runs to completion (if enabled).\n2. Oscillator Start-up Timer runs to completion (if required for selected oscillator source).\n3. MCLR must be released (if enabled).\nThe total time-out will vary based on the oscillator configuration and Power-up Timer configuration.\nThe Power-up Timer and Oscillator Start-up Timer run independently of MCLR Reset. If MCLR is kept low long enough, the Power-up Timer and Oscillator Start-up Timer will expire. Upon bringing MCLR high, the device will begin execution after 10 F OSC cycles (see the figure below). This is useful for testing purposes or to synchronize more than one device operating in parallel.",
    "Figure 14-4. Reset Start-Up Sequence\nTOST\nTMCLR\nTPWRT\nVDD\nInternal POR\nPower-up Timer\nMCLR\nInternal RESET\nOscillator Modes\nOscillator Start-up Timer\nOscillator\nF OSC\nInternal Oscillator\nOscillator\nF OSC\nExternal Clock (EC)\nCLKIN\nOSC F",
    "External Crystal\nRev. 30-000093A\n4/12/2017",
    "14.10.1  Memory Execution Violation\nA memory execution violation Reset occurs if executing an instruction being fetched from outside the valid execution area. The invalid execution areas are:\n1. Addresses outside implemented program memory.\n2. Storage Area Flash (SAF) inside program memory, if it is enabled.\nWhen a memory execution violation is generated, the device is reset and the MEMV bit is cleared to signal the cause of the Reset. The MEMV bit must be set in the user code after a memory execution violation Reset has occurred to detect further violation Resets.",
    "14.11 Determining the Cause of a Reset\nUpon any Reset, multiple bits in the STATUS, PCON0 and PCON1 registers are updated to indicate the cause of the Reset. The following table shows the Reset conditions of these registers.",
    "14.11 Determining the Cause of a Reset\nTable 14-4. Reset Condition for Special Registers\n\nPower-on Reset, Program Counter = 0. Power-on Reset, STATUS Register (1,2) = -110 0000. Power-on Reset, PCON0 Register = 0011 110x. Power-on Reset, PCON1 Register = ---- -111. Brown-out Reset, Program Counter = 0. Brown-out Reset, STATUS Register (1,2) = -110 0000. Brown-out Reset, PCON0 Register = 0011 11u0. Brown-out Reset, PCON1 Register = ---- -u1u. MCLR Reset during normal operation, Program Counter = 0. MCLR Reset during normal operation, STATUS Register (1,2) = -uuu uuuu. MCLR Reset during normal operation, PCON0 Register = uuuu 0uuu. MCLR Reset during normal operation, PCON1 Register = ---- -uuu",
    "...........continued\nMCLR Reset during Sleep, Program Counter = 0. MCLR Reset during Sleep, STATUS Register (1,2) = -10u uuuu. MCLR Reset during Sleep, PCON0 Register = uuuu 0uuu. MCLR Reset during Sleep, PCON1 Register = ---- -uuu. WDT Time-out Reset, Program Counter = 0. WDT Time-out Reset, STATUS Register (1,2) = -0uu uuuu. WDT Time-out Reset, PCON0 Register = uuu0 uuuu. WDT Time-out Reset, PCON1 Register = ---- -uuu. WDT Wake-up from Sleep, Program Counter = PC + 2. WDT Wake-up from Sleep, STATUS Register (1,2) = -00u uuuu. WDT Wake-up from Sleep, PCON0 Register = uuuu uuuu. WDT Wake-up from Sleep, PCON1 Register = ---- -uuu. WWDT Window Violation Reset, Program Counter =",
    "...........continued\n0. WWDT Window Violation Reset, STATUS Register (1,2) = -uuu uuuu. WWDT Window Violation Reset, PCON0 Register = uu0u uuuu. WWDT Window Violation Reset, PCON1 Register = ---- -uuu. Interrupt Wake-up from Sleep, Program Counter = PC + 2 (3). Interrupt Wake-up from Sleep, STATUS Register (1,2) = -10u uuuu. Interrupt Wake-up from Sleep, PCON0 Register = uuuu uuuu. Interrupt Wake-up from Sleep, PCON1 Register = ---- -uuu. RESET Instruction Executed, Program Counter = 0. RESET Instruction Executed, STATUS Register (1,2) = -uuu uuuu. RESET Instruction Executed, PCON0 Register = uuuu u0uu. RESET Instruction Executed, PCON1 Register = ---- -uuu. Stack Overflow Reset (STVREN = 1 ), Program Counter = 0. Stack Overflow Reset (STVREN = 1",
    "...........continued\n), STATUS Register (1,2) = -uuu uuuu. Stack Overflow Reset (STVREN = 1 ), PCON0 Register = 1uuu uuuu. Stack Overflow Reset (STVREN = 1 ), PCON1 Register = ---- -uuu. Stack Underflow Reset (STVREN = 1 ), Program Counter = 0. Stack Underflow Reset (STVREN = 1 ), STATUS Register (1,2) = -uuu uuuu. Stack Underflow Reset (STVREN = 1 ), PCON0 Register = u1uu uuuu. Stack Underflow Reset (STVREN = 1 ), PCON1 Register = ---- -uuu. Data Protection (Fuse Fault), Program Counter = 0. Data Protection (Fuse Fault), STATUS Register (1,2) = -uuu uuuu. Data Protection (Fuse Fault), PCON0 Register = uuuu uuuu. Data Protection (Fuse Fault), PCON1 Register = ----",
    "...........continued\n-uu0. VREG or ULP Ready Fault, Program Counter = 0. VREG or ULP Ready Fault, STATUS Register (1,2) = -110 0000. VREG or ULP Ready Fault, PCON0 Register = 0011 110u. VREG or ULP Ready Fault, PCON1 Register = ---- -0u1. Memory Violation Reset, Program Counter = 0. Memory Violation Reset, STATUS Register (1,2) = -uuu uuuu. Memory Violation Reset, PCON0 Register = uuuu uuuu. Memory Violation Reset, PCON1 Register = ---- -u0u\nLegend: u = unchanged, x = unknown, - = unimplemented bit, reads as ' 0 '.",
    "Notes:\n1. If a Status bit is not implemented, that bit will be read as ' 0 '.\n2. Status bits Z, C, DC are reset by POR/BOR.\n3. When the wake-up is due to an interrupt and Global Interrupt Enable (GIE) bit is set, the return address is pushed on the stack and PC is loaded with the corresponding interrupt vector (depending on source, high or low priority) after execution of PC + 2.",
    "14.12 Power Control (PCON0/PCON1) Registers\nThe Power Control (PCON0/PCON1) registers contain flag bits to differentiate between the following Reset events:\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Power-on Reset (POR)\n\u00b7 Reset Instruction Reset (RI)\n\u00b7 MCLR Reset (RMCLR)\n\u00b7 Watchdog Timer Reset (RWDT)\n\u00b7 Watchdog Window Violation (WDTWV)\n\u00b7 Stack Underflow Reset (STKUNF)\n\u00b7 Stack Overflow Reset (STKOVF)\n\u00b7 Configuration Memory Reset (RCM)\n\u00b7 Memory Violation Reset (MEMV)\n\u00b7 Main LDO Voltage Regulator Reset (RVREG)\nHardware will change the corresponding register bit or bits as a result of the Reset event. Bits for other Reset events remain unchanged. See Determining the Cause of a Reset for more details.\nSoftware will reset the bit to the Inactive state after restart (hardware will not reset the bit).\nSoftware may also set any PCON0 bit to the Active state so that user code may be tested, but no Reset action will be generated.",
    "14.13.1  BORCON\nName:\nBORCON\nAddress:\n0x049\nBrown-out Reset Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SBOREN. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 8 = BORRDY. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R. Reset, 1 = 1. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = q",
    "Bit 7 - SBOREN Software Brown-out Reset Enable\nReset States: POR/BOR = 1\nAll Other Resets = u\n-, Condition = If BOREN \u2260 01. -, Description = SBOREN is read/write but has no effect on the BOR. 1, Condition = If BOREN = 01. 1, Description = BOR Enabled. 0, Condition = If BOREN = 01. 0, Description = BOR Disabled",
    "Bit 0 - BORRDY Brown-out Reset Circuit Ready Status\nReset States: POR/BOR = q\nAll Other Resets = u\n1, Description = The Brown-out Reset Circuit is active and armed. 0, Description = The Brown-out Reset Circuit is disabled or is warming up",
    "14.13.2  PCON0\nName:\nPCON0\nAddress:\n0x4F0\nPower Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = STKOVF. , 2 = STKUNF. , 3 = WDTWV. , 4 = RWDT. , 5 = RMCLR. , 6 = RI. , 7 = POR. , 8 = BOR. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HC. Access, 4 = R/W/HC. Access, 5 = R/W/HC. Access, 6 = R/W/HC. Access, 7 = R/W/HC. Access, 8 = R/W/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 0. Reset, 8 = q",
    "Bit 7 - STKOVF Stack Overflow Flag\nReset States: POR/BOR = 0\nAll Other Resets = q\n1, Description = A Stack Overflow occurred (more CALL s than fit on the stack). 0, Description = A Stack Overflow has not occurred or set to ' 0 ' by firmware",
    "Bit 6 - STKUNF Stack Underflow Flag\nReset States: POR/BOR = 0\n1, Description = A Stack Underflow occurred (more RETURN s than CALL s). 0, Description = A Stack Underflow has not occurred or set to ' 0 ' by firmware\nAll Other Resets = q",
    "Bit 5 - WDTWV Watchdog Window Violation Flag\nReset States: POR/BOR = 1\nAll Other Resets = q\n1, Description = A WDT window violation has not occurred or set to ' 1 ' by firmware. 0, Description = A CLRWDT instruction was issued when the WDT Reset window was closed (set to ' 0 ' in hardware when a WDT window violation Reset occurs)",
    "Bit 4 - RWDT WDT Reset Flag\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = A WDT overflow/Time-out Reset has not occurred or set to ' 1 ' by firmware. 0, Description = A WDT overflow/Time-out Reset has occurred (set to ' 0 ' in hardware when a WDT Reset occurs)",
    "Bit 3 - RMCLR  MCLR Reset Flag\nReset States: POR/BOR = 1\nAll Other Resets = q\n1, Description = A MCLR Reset has not occurred or set to ' 1 ' by firmware. 0, Description = A MCLR Reset has occurred (set to ' 0 ' in hardware when a MCLR Reset occurs)",
    "Bit 2 - RI RESET Instruction Flag\nReset States: POR/BOR = 1 All Other Resets = q\n1, Description = A RESET instruction has not been executed or set to ' 1 ' by firmware. 0, Description = A RESET instruction has been executed (set to ' 0 ' in hardware upon executing a RESET instruction)",
    "Bit 1 - POR Power-on Reset Status\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = No V DD Power-on Reset occurred or set to ' 1 ' by firmware. 0, Description = A V DD Power-on Reset occurred (set to ' 0 ' in hardware when a Power-on Reset occurs)",
    "Bit 0 - BOR Brown-out Reset Status\nReset States: POR/BOR = q\nAll Other Resets = u\n1, Description = No V DD Brown-out Reset occurred or set to ' 1 ' by firmware. 0, Description = A V DD Brown-out Reset occurred (set to ' 0 ' in hardware when a Brown-out Reset occurs)",
    "14.13.3  PCON1\nName:\nPCON1\nAddress:\n0x4F1\nPower Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = RVREG. , 7 = MEMV. , 8 = RCM. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W/HC. Access, 7 = R/W/HC. Access, 8 = R/W/HC. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 0. Reset, 8 = q",
    "Bit 2 - RVREG Main LDO Voltage Regulator Reset Flag\nReset States: POR/BOR = 1\n1, Description = No LDO or ULP 'ready' Reset has occurred or set to ' 1 ' by firmware. 0, Description = LDO or ULP 'ready' Reset has occurred (VDDCORE reached its minimum spec)\nAll Other Resets = q",
    "Bit 1 - MEMV Memory Violation Reset Flag\nReset States: POR/BOR = 0\n1, Description = No memory violation Reset occurred or set to ' 1 ' by firmware. 0, Description = A memory violation Reset occurred (set to ' 0 ' in hardware when a Memory Violation occurs)\nAll Other Resets = u",
    "Bit 0 - RCM Configuration Memory Reset Flag\nReset States: POR/BOR = q\nAll Other Resets = u\n1, Description = A Reset occurred due to corruption of the configuration and/or calibration data latches. 0, Description = The configuration and calibration latches have not been corrupted",
    "14.14 Register Summary - BOR Control and Power Control\n0x00 ... 0x48, Name = Reserved. 0x00 ... 0x48, Bit Pos. = . 0x00 ... 0x48, 7 = . 0x00 ... 0x48, 6 = . 0x00 ... 0x48, 5 = . 0x00 ... 0x48, 4 = . 0x00 ... 0x48, 3 = . 0x00 ... 0x48, 2 = . 0x00 ... 0x48, 1 = . 0x00 ... 0x48, 0 = . 0x49, Name = BORCON. 0x49, Bit Pos. = 7:0. 0x49, 7 = SBOREN. 0x49, 6 = . 0x49, 5 = . 0x49, 4 = . 0x49, 3 = . 0x49, 2 = . 0x49, 1 = . 0x49, 0 = BORRDY. 0x4A ... 0x04EF, Name = Reserved. 0x4A ...",
    "14.14 Register Summary - BOR Control and Power Control\n0x04EF, Bit Pos. = . 0x4A ... 0x04EF, 7 = . 0x4A ... 0x04EF, 6 = . 0x4A ... 0x04EF, 5 = . 0x4A ... 0x04EF, 4 = . 0x4A ... 0x04EF, 3 = . 0x4A ... 0x04EF, 2 = . 0x4A ... 0x04EF, 1 = . 0x4A ... 0x04EF, 0 = . 0x04F0, Name = PCON0. 0x04F0, Bit Pos. = 7:0. 0x04F0, 7 = STKOVF. 0x04F0, 6 = STKUNF. 0x04F0, 5 = WDTWV. 0x04F0, 4 = RWDT. 0x04F0, 3 = RMCLR. 0x04F0, 2",
    "14.14 Register Summary - BOR Control and Power Control\n= RI. 0x04F0, 1 = POR. 0x04F0, 0 = BOR. 0x04F1, Name = PCON1. 0x04F1, Bit Pos. = 7:0. 0x04F1, 7 = . 0x04F1, 6 = . 0x04F1, 5 = . 0x04F1, 4 = . 0x04F1, 3 = . 0x04F1, 2 = RVREG. 0x04F1, 1 = MEMV. 0x04F1, 0 = RCM",
    "15. WWDT - Windowed Watchdog Timer\nA Watchdog Timer (WDT) is a system timer that generates a Reset if the firmware does not issue a CLRWDT instruction within the time-out period. A Watchdog Timer is typically used to recover the system from unexpected events. The Windowed Watchdog Timer (WWDT) differs from nonwindowed operation in that CLRWDT instructions are only accepted when they are performed within a specific window during the time-out period.\nThe WWDT has the following features:\n\u00b7 Selectable clock source\n\u00b7 Multiple operating modes\n-WWDT is always on\n-WWDT is off when in Sleep\n-WWDT is controlled by software\n-WWDT is always off\n\u00b7 Configurable time-out period from 1 ms to 256s (nominal)\n\u00b7 Configurable window size from 12.5% to 100% of the time-out period\n\u00b7 Multiple Reset conditions\nFigure 15-1. Windowed Watchdog Timer Block Diagram\n\u4454\n\u434c\n\u5257\n\u5369\n\u7a65\n\u5345\n\u5245\n\u4520\n\u3d20\n\u00b5\n\u3130\n\u536c",
    "15.1 Independent Clock Source\nThe WWDT can derive its time base from either the 31 KHz LFINTOSC or 31.25 kHz MFINTOSC internal oscillators, depending on the value of WDT Operating Mode (WDTE) Configuration bits. If WDTE = 'b1x , then the clock source will be enabled depending on the WDTCCS Configuration bits. If WDTE = 'b01 , the SEN bit will be set by software to enable WWDT and the clock source is enabled by the CS bits. Time intervals in this chapter are based on a minimum nominal interval of 1 ms. See the device Electrical Specifications for LFINTOSC and MFINTOSC tolerances.",
    "15.2 WWDT Operating Modes\nThe Windowed Watchdog Timer module has four operating modes that are controlled by the WDTE Configuration bit. The table below summarizes the different WWDT operating modes.\n\u4520\n\u4520\n\u3d20\n\u3d20\n\u7374\n\u00b5\n\u00b5\n\u4353\n\u5345\n\u5365\n\u3031\n\u3131\n\u3120\n\u5053\n\u3138\n\u7363\n\u5072\n\u4172\n\u7261\n\u6d70\n\u7365\n\u7665\n\u7266\n\u6368\n\u6d65\n\u5669\nTable 15-1. WWDT Operating Modes\n\n11, SEN = X. 11, Device Mode = X. 11, WWDT Mode = Active. 10, SEN = X. 10, Device Mode = Awake. 10, WWDT Mode = Active. 10, SEN = X. 10, Device Mode = Sleep. 10, WWDT Mode = Disabled. 01, SEN = 1. 01, Device Mode = X. 01, WWDT Mode = Active. 01, SEN = 0. 01, Device Mode = X. 01, WWDT Mode = Disabled. 00, SEN = X. 00, Device Mode = X. 00, WWDT Mode = Disabled",
    "15.2.1 WWDT Is Always On\nWhen the WDTE Configuration bits are set to 'b11 , the WWDT is always on. WWDT protection is active during Sleep.",
    "15.2.2 WWDT Is Off in Sleep\nWhen the WDTE Configuration bits are set to 'b10 , the WWDT is on, except in Sleep mode. WWDT protection is not active during Sleep.",
    "15.2.3 WWDT Controlled by Software\nWhen the WDTE Configuration bits are set to 'b01 , the WWDT is controlled by the SEN bit. WWDT protection is unchanged by Sleep. See Table 15-1 for more details.",
    "15.3 Time-Out Period\nWhen the WDTCPS Configuration bits are set to the default value of 'b11111 , the PS bits set the time-out period from 1 ms to 256 seconds (nominal). If any value other than the default value is assigned to the WDTCPS Configuration bits, then the timer period will be based on the WDTCPS Configuration bits. After a Reset, the default time-out period is 2s.",
    "15.4 Watchdog Window\nThe Windowed Watchdog Timer has an optional Windowed mode that is controlled by either the WDTCWS Configuration bits or the WINDOW bits. In the Windowed mode (WINDOW < 'b1111 ), the CLRWDT instruction must occur within the allowed window of the WDT period. Any CLRWDT instruction that occurs outside of this window will trigger a window violation and will cause a WWDT Reset, similar to a WWDT time-out. See Figure 15-2 for an example.\nWhen the WDTCWS Configuration bits are 'b111 , then the window size is controlled by the WINDOW bits, otherwise the window size is controlled by the WDTCWS bits. The five Most Significant bits of the WDTTMR register are used to determine whether the window is open, as defined by the window size. In the event of a window violation, a Reset will be generated and the WDTWV bit of the PCON0 register will be cleared. This bit is set by a POR and can be set by software.\nFigure 15-2. Window Period and Delay\n\u5265\n\u436c\n\u7720\n\u7720\n\u4465\n\u7720\n\u7720",
    "15.5 Clearing the Watchdog Timer\nThe Watchdog Timer is cleared when any of the following conditions occur:\n\u00b7 Any Reset\n\u00b7 A valid CLRWDT instruction is executed\n\u00b7 The device enters Sleep\n\u00b7 The devices exits Sleep by Interrupt\n\u00b7 The WWDT is disabled\n\u00b7 The Oscillator Start-up Timer (OST) is running\n\u00b7 Any write to the WDTCON0 or WDTCON1 registers",
    "15.5.1 CLRWDT Considerations (Windowed Mode)\nWhen in Windowed mode, the WWDT must be armed before a CLRWDT instruction will clear the timer. This is performed by reading the WDTCON0 register. Executing a CLRWDT instruction without performing such an arming action will trigger a window violation regardless of whether the window is open or not. See Table 15-2 for more information.",
    "15.6 Operation During Sleep\nWhen the device enters Sleep, the Watchdog Timer is cleared. If the WWDT is enabled during Sleep, the Watchdog Timer resumes counting. When the device exits Sleep, the Watchdog Timer is cleared again. The Watchdog Timer remains clear until the Oscillator Start-up Timer (OST) completes, if enabled. When a WWDT time-out occurs while the device is in Sleep, no Reset is generated. Instead, the device wakes up and resumes operation. The TO and PD bits in the STATUS register are changed to indicate the event. The RWDT bit in the PCON0 register indicates that a Watchdog Reset has occurred.",
    "Table 15-2. WWDT Clearing Conditions\nWDTE = 'b00, WWDT = . WDTE = 'b01 and SEN = 0, WWDT = . WDTE = 'b10 and enter Sleep, WWDT = Cleared. CLRWDT Command, WWDT = . Oscillator Fail Detected, WWDT = . Exit Sleep + System Clock = SOSC, EXTRC, INTOSC, EXTCLK, WWDT = . Exit Sleep + System Clock = XT, HS, LP, WWDT = Cleared until the end of OST. Change INTOSC divider (IRCF bits), WWDT = Unaffected",
    "15.7 Register Definitions: Windowed Watchdog Timer Control\nLong bit name prefixes for the Windowed Watchdog Timer peripherals are shown in the following table. Refer to the \" Long Bit Names \" section in the 'Register and Bit Naming Conventions' chapter for more information.",
    "Table 15-3. WWDT Long Bit Name Prefixes\nWDT, Bit Name Prefix = WDT",
    "15.7.1 WDTCON0\nName:\nWDTCON0\nAddress:\n0x078",
    "Watchdog Timer Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = PS[4:0]. , 6 = . , 7 = . , 8 = SEN. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = q. Reset, 4 = q. Reset, 5 = q. Reset, 6 = q. Reset, 7 = q. Reset, 8 = 0",
    "Bits 5:1 - PS[4:0]  Watchdog Timer Prescaler Select (2)\n11111 to 10011, Description = Reserved. Results in minimum interval (1 ms). 10010, Description = 1:8388608 (2 23 ) (Interval 256s nominal). 10001, Description = 1:4194304 (2 22 ) (Interval 128s nominal). 10000, Description = 1:2097152 (2 21 ) (Interval 64s nominal). 01111, Description = 1:1048576 (2 20 ) (Interval 32s nominal). 01110, Description = 1:524288 (2 19 ) (Interval 16s nominal). 01101, Description = 1:262144 (2 18 ) (Interval 8s nominal). 01100, Description = 1:131072 (2 17 ) (Interval 4s nominal). 01011, Description = 1:65536 (Interval 2s nominal) (Reset value). 01010, Description = 1:32768 (Interval 1s nominal). 01001, Description = 1:16384 (Interval 512 ms nominal).",
    "Bits 5:1 - PS[4:0]  Watchdog Timer Prescaler Select (2)\n01000, Description = 1:8192 (Interval 256 ms nominal). 00111, Description = 1:4096 (Interval 128 ms nominal). 00110, Description = 1:2048 (Interval 64 ms nominal). 00101, Description = 1:1024 (Interval 32 ms nominal). 00100, Description = 1:512 (Interval 16 ms nominal). 00011, Description = 1:256 (Interval 8 ms nominal). 00010, Description = 1:128 (Interval 4 ms nominal). 00001, Description = 1:64 (Interval 2 ms nominal). 00000, Description = 1:32 (Interval 1 ms nominal)",
    "Bit 0 - SEN Software Enable/Disable for Watchdog Timer\nx, Condition = If WDTE = 1x. x, Description = This bit is ignored. 1, Condition = If WDTE = 01. 1, Description = WDT is turned on. 0, Condition = If WDTE = 01. 0, Description = WDT is turned off. x, Condition = If WDTE = 00. x, Description = This bit is ignored",
    "Notes:\n1. When the WDTCPS Configuration bits = 'b11111 , the Reset value (q) of WDTPS is 'b01011 . Otherwise, the Reset value of WDTPS is equal to the WDTCPS in Configuration bits.\n2. When the WDTCPS in Configuration bits \u2260 'b11111 , these bits are read-only.",
    "15.7.2 WDTCON1\nName: Address:\nWDTCON1 0x079",
    "Watchdog Timer Control Register 1\nAccess, 7. = . Access, 6.CS[2:0] = R/W. Access, 5.CS[2:0] = R/W. Access, 4.CS[2:0] = R/W. Access, 3. = . Access, 2.WINDOW[2:0] = R/W. Access, 1.WINDOW[2:0] = R/W. Access, 0.WINDOW[2:0] = R/W. Reset, 7. = . Reset, 6.CS[2:0] = q. Reset, 5.CS[2:0] = q. Reset, 4.CS[2:0] = q. Reset, 3. = . Reset, 2.WINDOW[2:0] = q. Reset, 1.WINDOW[2:0] = q. Reset, 0.WINDOW[2:0] = q",
    "Bits 6:4 - CS[2:0]  Watchdog Timer Clock Select (1,3)\n111-100, Clock Source = Reserved. 011, Clock Source = EXTOSC. 010, Clock Source = SOSC. 001, Clock Source = MFINTOSC (31.25 kHz). 000, Clock Source = LFINTOSC (31 kHz)",
    "Bits 2:0 - WINDOW[2:0]  Watchdog Timer Window Select (2,4)\n111, Window Delay Percent of Time = N/A. 111, Window Opening Percent of Time = 100. 110, Window Delay Percent of Time = 12.5. 110, Window Opening Percent of Time = 87.5. 101, Window Delay Percent of Time = 25. 101, Window Opening Percent of Time = 75. 100, Window Delay Percent of Time = 37.5. 100, Window Opening Percent of Time = 62.5. 011, Window Delay Percent of Time = 50. 011, Window Opening Percent of Time = 50. 010, Window Delay Percent of Time = 62.5. 010, Window Opening Percent of Time = 37.5. 001, Window Delay Percent of Time = 75. 001, Window Opening Percent of Time = 25. 000, Window Delay Percent of Time = 87.5. 000, Window Opening Percent of Time = 12.5",
    "Notes:\n1. When the WDTCCS in Configuration bits = '0b111 , the Reset value of WDTCS is 'b000 .\n2. The Reset value (q) of WINDOW is determined by the value of WDTCWS in the Configuration bits.\n3. When the WDTCCS in Configuration bits \u2260 'b111 , these bits are read-only.\n4. When the WDTCWS in Configuration bits \u2260 'b111 , these bits are read-only.",
    "15.7.3 WDTPSH\nName: Address:\nWDTPSH 0x07B\nWWDT Prescaler Select Register (Read-Only)",
    "15.7.3 WDTPSH\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSCNTH[7:0]. , 2 = PSCNTH[7:0]. , 3 = PSCNTH[7:0]. , 4 = PSCNTH[7:0]. , 5 = PSCNTH[7:0]. , 6 = PSCNTH[7:0]. , 7 = PSCNTH[7:0]. , 8 = PSCNTH[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Note:\n- 1. The 18-bit WDT prescaler value, PSCNT[17:0] includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT[17:0] is intended for debug operations and will be read during normal operation.",
    "15.7.4 WDTPSL\nName: Address:\nWDTPSL 0x07A\nWWDT Prescaler Select Register (Read-Only)",
    "15.7.4 WDTPSL\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSCNTL[7:0]. , 2 = PSCNTL[7:0]. , 3 = PSCNTL[7:0]. , 4 = PSCNTL[7:0]. , 5 = PSCNTL[7:0]. , 6 = PSCNTL[7:0]. , 7 = PSCNTL[7:0]. , 8 = PSCNTL[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Note:\n- 1. The 18-bit WDT prescaler value, PSCNT[17:0] includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT[17:0] is intended for debug operations and will be read during normal operation.",
    "15.7.5 WDTTMR\nName:\nWDTTMR\nAddress:\n0x07C\nWDT Timer Register (Read-Only)",
    "15.7.5 WDTTMR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR[4:0]. , 2 = TMR[4:0]. , 3 = TMR[4:0]. , 4 = TMR[4:0]. , 5 = TMR[4:0]. , 6 = STATE. , 7 = PSCNT[17:16]. , 8 = PSCNT[17:16]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:3 - TMR[4:0] Watchdog Window Value\n111, WDT Window State.Closed = N/A. 111, WDT Window State.Open = 00000-11111. 111, Open Percent. = 100. 110, WDT Window State.Closed = 00000-00011. 110, WDT Window State.Open = 00100-11111. 110, Open Percent. = 87.5. 101, WDT Window State.Closed = 00000-00111. 101, WDT Window State.Open = 01000-11111. 101, Open Percent. = 75. 100, WDT Window State.Closed = 00000-01011. 100, WDT Window State.Open = 01100-11111. 100, Open Percent. = 62.5. 011, WDT Window State.Closed = 00000-01111. 011, WDT Window State.Open = 10000-11111. 011, Open Percent. = 50. 010, WDT Window State.Closed = 00000-10011. 010, WDT Window State.Open = 10100-11111. 010, Open Percent. =",
    "Bits 7:3 - TMR[4:0] Watchdog Window Value\n37.5. 001, WDT Window State.Closed = 00000-10111. 001, WDT Window State.Open = 11000-11111. 001, Open Percent. = 25. 000, WDT Window State.Closed = 00000-11011. 000, WDT Window State.Open = 11100-11111. 000, Open Percent. = 12.5",
    "Bit 2 - STATE WDT Armed Status\n1, Description = WDT is armed. 0, Description = WDT is not armed",
    "Note:\n- 1. The 18-bit WDT prescaler value, PSCNT[17:0] includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT[17:0] is intended for debug operations and will not be read during normal operation.",
    "15.8 Register Summary - WDT Control\n0x00 ... 0x77, Name = Reserved. 0x00 ... 0x77, Bit Pos. = . 0x00 ... 0x77, 7 = . 0x00 ... 0x77, 5 = . 0x00 ... 0x77, 4 = . 0x00 ... 0x77, 2 = . 0x00 ... 0x77, 1 = . 0x00 ... 0x77, 0 = . 0x78, Name = WDTCON0. 0x78, Bit Pos. = 7:0. 0x78, 7 = . 0x78, 5 = . 0x78, 4 = PS[4:0]. 0x78, 2 = . 0x78, 1 = . 0x78, 0 = . , Name = . , Bit Pos. = . , 7 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = SEN. 0x79, Name = WDTCON1.",
    "15.8 Register Summary - WDT Control\n0x79, Bit Pos. = 7:0. 0x79, 7 = . 0x79, 5 = CS[2:0]. 0x79, 4 = . 0x79, 2 = . 0x79, 1 = WINDOW[2:0]. 0x79, 0 = . 0x7A, Name = WDTPSL. 0x7A, Bit Pos. = 7:0. 0x7A, 7 = . 0x7A, 5 = . 0x7A, 4 = PSCNTL[7:0]. 0x7A, 2 = . 0x7A, 1 = . 0x7A, 0 = . 0x7B, Name = WDTPSH. 0x7B, Bit Pos. = 7:0. 0x7B, 7 = . 0x7B, 5 = . 0x7B, 4 = PSCNTH[7:0]. 0x7B, 2 = . 0x7B, 1 = . 0x7B, 0 = . 0x7C, Name =",
    "15.8 Register Summary - WDT Control\nWDTTMR. 0x7C, Bit Pos. = 7:0. 0x7C, 7 = . 0x7C, 5 = TMR[4:0]. 0x7C, 4 = . 0x7C, 2 = STATE. 0x7C, 1 = PSCNT[17:16]. 0x7C, 0 = ",
    "16. DMA - Direct Memory Access\nThe Direct Memory Access (DMA) module is designed to service data transfers between different memory regions directly, without intervention from the CPU. By eliminating the need for CPUintensive management of handling interrupts intended for data transfers, the CPU now can spend more time on other tasks.\nThe DMA modules can be independently programmed to transfer data between different memory locations, move different data sizes, and use a wide range of hardware triggers to initiate transfers. The DMA modules can even be programmed to work together, to carry out more complex data transfers without CPU overhead.\nKey features of the DMA module include:",
    "16. DMA - Direct Memory Access\n\u00b7 Support access to the following memory regions:\n-GPR and SFR space (R/W)\n-Program Flash memory (R only)\n-Data EEPROM memory (R only)\n\u00b7 Programmable priority between the DMA and CPU operations. Refer to the 'System Arbitration' section in the 'PIC18 CPU' chapter for details.\n\u00b7 Programmable Source and Destination Address modes:\n-Fixed address\n-Post-increment address\n-Post-decrement address\n\u00b7 Programmable source and destination sizes\n\u00b7 Source and Destination Pointer register, dynamically updated and reloadable\n\u00b7 Source and Destination Count register, dynamically updated and reloadable\n\u00b7 Programmable auto-stop based on source or destination counter\n\u00b7 Software triggered transfers\n\u00b7 Multiple user-selectable sources for hardware triggered transfers\n\u00b7 Multiple user-selectable sources for aborting DMA transfers",
    "16.1 DMA Registers\nThe operation of the DMA module is controlled by the following registers:\n\u00b7 DMA Instance Selection (DMASELECT) register\n\u00b7 Control (DMAnCON0, DMAnCON1) registers\n\u00b7 Data Buffer (DMAnBUF) register\n\u00b7 Source Start Address (DMAnSSA) register\n\u00b7 Source Pointer (DMAnSPTR) register\n\u00b7 Source Message Size (DMAnSSZ) register\n\u00b7 Source Count (DMAnSCNT) register\n\u00b7 Destination Start Address (DMAnDSA) register\n\u00b7 Destination Pointer (DMAnDPTR) register\n\u00b7 Destination Message Size (DMAnDSZ) register\n\u00b7 Destination Count (DMAnDCNT) register\n\u00b7 Start Interrupt Request Source (DMAnSIRQ) register\n- \u00b7 Abort Interrupt Request Source (DMAnAIRQ) register\nThe registers are detailed in Register Definitions: DMA.",
    "16.2 DMA Organization\nThe DMA module is designed to move data by using the existing instruction bus and data bus without the need for any dual-porting of memory or peripheral systems (Figure 16-1). The DMA accesses the required bus when granted by the system arbiter.\nFigure 16-1. DMA Functional Block Diagram\nRev. 10-000271A\nDepending on the priority of the DMA with respect to CPU execution (refer to the 'Memory Access Scheme' section in the 'PIC18 CPU' chapter for more information), the DMA Controller can move data through two methods:\n\u00b7 Stalling the CPU execution until it has completed its transfers (DMA has higher priority over the CPU in this mode of operation)\n\u00b7 Utilizing unused CPU cycles for DMA transfers (CPU has higher priority over the DMA in this mode of operation). Unused CPU cycles are referred to as bubbles, which are instruction cycles available for use by the DMA to perform read and write operations. In this way, the effective bandwidth for handling data is increased; at the same time, DMA operations can proceed without causing a processor stall.",
    "16.3 DMA Interface\nThe DMA module transfers data from the source to the destination one byte at a time, this smallest data movement is called a DMA data transaction. A DMA message refers to one or more DMA data transactions.\nEach DMA data transaction consists of two separate actions:\n\u00b7 Reading the source address memory and storing the value in the DMA Buffer register\n\u00b7 Writing the contents of the DMA Buffer register to the destination address memory\nImportant: DMA data movement is a two-cycle operation.\nThe XIP bit is a Status bit to indicate whether or not the data in the DMAnBUF register has been written to the destination address. If the bit is set, then data are waiting to be written to the destination. If clear, it means that either data have been written to the destination or that no source read has occurred.\nThe DMA has read access to PFM, Data EEPROM, and SFR/GPR space and has write access to SFR/GPR space. Based on these memory access capabilities, the DMA can support the following memory transactions:",
    "16.3 DMA Interface\nTable 16-1. DMA Memory Access\n\nProgram Flash Memory, Write Destination = GPR. Program Flash Memory, Write Destination = SFR. Data EE, Write Destination = GPR. Data EE, Write Destination = SFR. GPR, Write Destination = GPR. GPR, Write Destination = SFR. SFR, Write Destination = GPR. SFR, Write Destination = SFR\nImportant: Even though the DMA module has access to all memory and peripherals that are also available to the CPU, it is recommended that the DMA does not access any register that is part of the system arbitration. The DMA, as a system arbitration client must not be read or written by itself or by another DMA instantiation.\nThe following sections discuss the various control interfaces required for DMA data transfers.",
    "16.3.1 Special Function Registers with DMA Access only\nThe DMA can transfer data to any GPR or SFR location. For better user accessibility, some of the more commonly used SFR spaces have their mirror registers placed in a separate data memory location. These mirror registers can be only accessed by the DMA module through the DMA Source and Destination Address registers. The figure below shows the register map for these registers.\nThese registers are useful to multiple peripherals together like the Timers, PWMs and also other DMA modules using one of the DMA modules.",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n40FFh -, 1 = 40DFh - 40BFh. 40FFh -, 2 = - 409Fh - 407Fh ADPREH_M1. 40FFh -, 3 = 405Fh -. 40FFh -, 4 = 403Fh - 401Fh. 40FFh -, 5 = . 40FFh -, 6 = -. 40FEh -, 1 = 40DEh - 40BEh. 40FEh -, 2 = - 409Eh - 407Eh ADPREL_M1. 40FEh -, 3 = 405Eh - 403Eh - 401Eh. 40FEh -, 4 = -. 40FEh -, 5 = . 40FEh -, 6 = . 40FDh -, 1 = 40DDh - 40BDh. 40FDh -, 2 = - 409Dh - 407Dh ADRESH_M1. 40FDh -, 3 = 405Dh - 403Dh - 401Dh. 40FDh -, 4 = -. 40FDh -, 5 = . 40FDh -, 6 = . 40FCh -, 1 = 40DCh",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n- 40BCh. 40FCh -, 2 = - 409Ch - 407Ch ADRESL_M1. 40FCh -, 3 = 405Ch - 403Ch - 401Ch. 40FCh -, 4 = -. 40FCh -, 5 = . 40FCh -, 6 = . 40FBh -, 1 = 40DBh - 40BBh. 40FBh -, 2 = - 409Bh - 407Bh ADPCH_M1. 40FBh -, 3 = 405Bh - 403Bh - 401Bh. 40FBh -, 4 = PWM3S1P2H_M1. 40FBh -, 5 = . 40FBh -, 6 = . 40FAh -, 1 = 40DAh - 40BAh. 40FAh -, 2 = - 409Ah - 407Ah. 40FAh -, 3 = 405Ah - 403Ah - 401Ah. 40FAh -, 4 = PWM3S1P2L_M1. 40FAh -, 5 = . 40FAh -, 6 = . 40F9h -, 1 =",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n40D9h - 40B9h. 40F9h -, 2 = - 4099h - 4079h. 40F9h -, 3 = ADCLK_M1 ADACT_M1 4059h - 4039h - 4019h. 40F9h -, 4 = PWM3S1P1H_M2. 40F9h -, 5 = . 40F9h -, 6 = . 40F8h ADPREH_M2, 1 = 40D8h - 40B8h. 40F8h ADPREH_M2, 2 = - 4098h - 4078h. 40F8h ADPREH_M2, 3 = ADREF_M1 4058h - 4038h - 4018h. 40F8h ADPREH_M2, 4 = PWM3S1P1L_M2. 40F8h ADPREH_M2, 5 = . 40F8h ADPREH_M2, 6 = . 40F7h ADPREL_M2, 1 = 40D7h - 40B7h.",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n40F7h ADPREL_M2, 2 = 4097h - 4077h. 40F7h ADPREL_M2, 3 = ADCON3_M1 4057h - 4037h - 4017h. 40F7h ADPREL_M2, 4 = PWM2S1P2H_M1. 40F7h ADPREL_M2, 5 = . 40F7h ADPREL_M2, 6 = . 40F6h ADRESH_M2, 1 = 40D6h - 40B6h. 40F6h ADRESH_M2, 2 = - - 4096h - 4076h ADCON2_M1. 40F6h ADRESH_M2, 3 = 4056h - 4036h - 4016h. 40F6h ADRESH_M2, 4 = PWM2S1P2L_M1. 40F6h ADRESH_M2, 5 = . 40F6h ADRESH_M2, 6 = . 40F5h ADRESL_M2, 1 = 40D5h - 40B5h.",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n40F5h ADRESL_M2, 2 = - 4095h - 4075h. 40F5h ADRESL_M2, 3 = ADCON1_M1 4055h - 4035h - 4015h. 40F5h ADRESL_M2, 4 = PWM2S1P1H_M2. 40F5h ADRESL_M2, 5 = . 40F5h ADRESL_M2, 6 = . , 1 = 40D4h - 40B4h. , 2 = - 4094h - 4074h. , 3 = 4054h - 4034h - 4014h. , 4 = PWM2S1P1L_M2. , 5 = . , 6 = . 40F4h ADPCH_M2, 1 = . 40F4h ADPCH_M2, 2 = . 40F4h ADPCH_M2, 3 = ADCON0_M1. 40F4h ADPCH_M2, 4 = . 40F4h ADPCH_M2, 5 = . 40F4h",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\nADPCH_M2, 6 = . 40F3h ADCAP_M2 -, 1 = 40D3h - 40B3h. 40F3h ADCAP_M2 -, 2 = 4093h - 4073h. 40F3h ADCAP_M2 -, 3 = ADCAP_M1 4053h - 4033h - 4013h. 40F3h ADCAP_M2 -, 4 = PWM1S1P2H_M1. 40F3h ADCAP_M2 -, 5 = . 40F3h ADCAP_M2 -, 6 = . 40F2h ADACQH_M2 -, 1 = 40D2h - 40B2h. 40F2h ADACQH_M2 -, 2 = 4092h - 4072h. 40F2h ADACQH_M2 -, 3 = ADACQH_M1 4052h - 4032h -. 40F2h ADACQH_M2 -, 4 = PWM1S1P2L_M1. 40F2h",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\nADACQH_M2 -, 5 = . 40F2h ADACQH_M2 -, 6 = . 40F1h, 1 = . 40F1h, 2 = . 40F1h, 3 = 4012h ADACQL_M1 4051h - 4031h PWM3PRH_M1 4011h. 40F1h, 4 = PWM1S1P1H_M2. 40F1h, 5 = . 40F1h, 6 = . - 40F0h ADPREVH_M2, 1 = ADACQL_M2 40D1h - 40B1h. - 40F0h ADPREVH_M2, 2 = 4091h - 4071h 4090h - 4070h. - 40F0h ADPREVH_M2, 3 = ADPREVH_M1 4050h - 4030h PWM3PRL_M1 4010h. - 40F0h ADPREVH_M2, 4 = . - 40F0h ADPREVH_M2, 5 = .",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n- 40F0h ADPREVH_M2, 6 = . - 40EFh ADPREVL_M2 -, 1 = 40D0h - 40B0h. - 40EFh ADPREVL_M2 -, 2 = 408Fh - 406Fh ADPREVL_M1. - 40EFh ADPREVL_M2 -, 3 = 404Fh - 402Fh PWM3S1P2H_M2 400Fh. - 40EFh ADPREVL_M2 -, 4 = PWM1S1P1L_M2. - 40EFh ADPREVL_M2 -, 5 = . - 40EFh ADPREVL_M2 -, 6 = . 40EEh ADRPT_M2 -, 1 = 40CFh - 40AFh 40CEh - 40AEh. 40EEh ADRPT_M2 -, 2 = 408Eh - 406Eh. 40EEh ADRPT_M2 -, 3 = ADRPT_M1 404Eh - 402Eh PWM3S1P2L_M2",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n400Eh. 40EEh ADRPT_M2 -, 4 = - -. 40EEh ADRPT_M2 -, 5 = . 40EEh ADRPT_M2 -, 6 = . 40EDh ADCNT_M2 -, 1 = 40CDh - 40ADh. 40EDh ADCNT_M2 -, 2 = 408Dh - 406Dh ADCNT_M1. 40EDh ADCNT_M2 -, 3 = 404Dh - 402Dh PWM3S1P1H_M3 400Dh. 40EDh ADCNT_M2 -, 4 = -. 40EDh ADCNT_M2 -, 5 = . 40EDh ADCNT_M2 -, 6 = . 40ECh ADACCU_M2 -, 1 = 40CCh - 40ACh. 40ECh ADACCU_M2 -, 2 = 408Ch - 406Ch. 40ECh ADACCU_M2 -, 3 = ADACCU_M1 404Ch - 402Ch PWM3S1P1L_M3 400Ch ADACCH_M1 404Bh - 402Bh",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\nPWM2PRH_M1. 40ECh ADACCU_M2 -, 4 = - PWM3S1P1H_M1. 40ECh ADACCU_M2 -, 5 = . 40ECh ADACCU_M2 -, 6 = . 40CBh -, 1 = 40CBh - 40ABh 40CAh - 40AAh. 40CBh -, 2 = 408Bh - 406Bh 408Ah - 406Ah. 40CBh -, 3 = 400Bh. 40CBh -, 4 = PWM3S1P1L_M1. 40CBh -, 5 = . 40CBh -, 6 = . ADACCH_M2 40EAh ADACCL_M2 -, 1 = . ADACCH_M2 40EAh ADACCL_M2 -, 2 = . ADACCH_M2 40EAh ADACCL_M2 -, 3 = ADACCL_M1 404Ah - 402Ah PWM2PRL_M1. ADACCH_M2 40EAh ADACCL_M2 -, 4 = . ADACCH_M2",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n40EAh ADACCL_M2 -, 5 = . ADACCH_M2 40EAh ADACCL_M2 -, 6 = . 40E9h ADFLTRH_M2, 1 = 40C9h - 40A9h. 40E9h ADFLTRH_M2, 2 = . 40E9h ADFLTRH_M2, 3 = 400Ah 4049h - 4029h PWM2S1P2H_M2 4009h. 40E9h ADFLTRH_M2, 4 = PWM2S1P1H_M1. 40E9h ADFLTRH_M2, 5 = . 40E9h ADFLTRH_M2, 6 = . 40E8h ADFLTRL_M2, 1 = 40C8h - 40A8h. 40E8h ADFLTRL_M2, 2 = 4089h - 4069h ADFLTRH_M1 4088h - 4068h ADFLTRL_M1. 40E8h ADFLTRL_M2, 3 = 4048h -",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n4028h PWM2S1P2L_M2 4008h. 40E8h ADFLTRL_M2, 4 = PWM2S1P1L_M1. 40E8h ADFLTRL_M2, 5 = . 40E8h ADFLTRL_M2, 6 = . 40E7h ADSTPTH_M2, 1 = 40C7h - 40A7h. 40E7h ADSTPTH_M2, 2 = - - - 4087h - 4067h ADSTPTH_M1. 40E7h ADSTPTH_M2, 3 = 4047h - 4027h PWM2S1P1H_M3 4007h. 40E7h ADSTPTH_M2, 4 = PWM1S1P1H_M1. 40E7h ADSTPTH_M2, 5 = . 40E7h ADSTPTH_M2, 6 = . 40E6h ADSTPTL_M2, 1 = 40C6h - 40A6h. 40E6h ADSTPTL_M2, 2 = -",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n4086h - 4066h. 40E6h ADSTPTL_M2, 3 = ADSTPTL_M1 4046h - 4026h PWM2S1P1L_M3 4006h. 40E6h ADSTPTL_M2, 4 = PWM1S1P1L_M1. 40E6h ADSTPTL_M2, 5 = . 40E6h ADSTPTL_M2, 6 = . 40E5h ADERRH_M2, 1 = 40C5h - 40A5h. 40E5h ADERRH_M2, 2 = - 4085h - 4065h. 40E5h ADERRH_M2, 3 = ADERRH_M1 4045h T4PR_M1 4025h PWM1PRH_M1 4005h. 40E5h ADERRH_M2, 4 = -. 40E5h ADERRH_M2, 5 = . 40E5h ADERRH_M2, 6 = . 40E4h ADERRL_M2, 1 = 40C4h -",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n40A4h. 40E4h ADERRL_M2, 2 = - 4084h - 4064h. 40E4h ADERRL_M2, 3 = ADERRL_M1 4044h - 4024h PWM1PRL_M1 ADUTHH_M1. 40E4h ADERRL_M2, 4 = - -. 40E4h ADERRL_M2, 5 = . 40E4h ADERRL_M2, 6 = . 40E3h ADUTHH_M2, 1 = 40C3h - 40A3h. 40E3h ADUTHH_M2, 2 = 4083h - 4063h. 40E3h ADUTHH_M2, 3 = 4004h 4043h - 4023h PWM1S1P2H_M2 4003h. 40E3h ADUTHH_M2, 4 = -. 40E3h ADUTHH_M2, 5 = . 40E3h ADUTHH_M2, 6 = . 40E2h ADUTHL_M2, 1 =",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n40C2h - 40A2h 40C1h - 40A1h. 40E2h ADUTHL_M2, 2 = - - 4082h - 4062h. 40E2h ADUTHL_M2, 3 = ADUTHL_M1 4042h T2PR_M1 4022h PWM1S1P2L_M2 4002h. 40E2h ADUTHL_M2, 4 = . 40E2h ADUTHL_M2, 5 = . 40E2h ADUTHL_M2, 6 = . 40E1h ADLTHH_M2, 1 = . 40E1h ADLTHH_M2, 2 = 4081h - 4061h. 40E1h ADLTHH_M2, 3 = 4041h CCPR1H_M2 4021h PWM1S1P1H_M3. 40E1h ADLTHH_M2, 4 = CCPR1H_M1. 40E1h ADLTHH_M2, 5 = . 40E1h ADLTHH_M2, 6 = .",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n40E0h ADLTHL_M2, 1 = 40C0h - 40A0h. 40E0h ADLTHL_M2, 2 = -. 40E0h ADLTHL_M2, 3 = . 40E0h ADLTHL_M2, 4 = . 40E0h ADLTHL_M2, 5 = . 40E0h ADLTHL_M2, 6 = . 41FFh -, 1 = . 41FFh -, 2 = - 4080h - 4060h. 41FFh -, 3 = ADLTHH_M1 4001h ADLTHL_M1 4040h CCPR1L_M2 4020h PWM1S1P1L_M3 4000h. 41FFh -, 4 = CCPR1L_M1. 41FFh -, 5 = . 41FFh -, 6 = . 41DFh - 41BFh - 419Fh 41FEh - 41DEh - 41BEh - 419Eh 41FDh - - 419Dh 41FCh -, 1 = - - 41DDh - 41BDh -",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n41DCh - 41BCh 41DBh - 41BBh. 41DFh - 41BFh - 419Fh 41FEh - 41DEh - 41BEh - 419Eh 41FDh - - 419Dh 41FCh -, 2 = 417Fh 417Eh 417Dh. 41DFh - 41BFh - 419Fh 41FEh - 41DEh - 41BEh - 419Eh 41FDh - - 419Dh 41FCh -, 3 = 415Fh - 413Fh DMAnSSAH_DMA3 411Fh 415Eh - 413Eh DMAnSSAL_DMA3 411Eh 415Dh - 413Dh DMAnSSZH_DMA3 411Dh. 41DFh - 41BFh - 419Fh 41FEh - 41DEh - 41BEh - 419Eh 41FDh - - 419Dh 41FCh -, 4 = DMAnDSAL_DMA2 DMAnDSZH_DMA2 DMAnDSZL_DMA2 DMAnDPTRH_DMA2. 41DFh - 41BFh -",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n419Fh 41FEh - 41DEh - 41BEh - 419Eh 41FDh - - 419Dh 41FCh -, 5 = - - -. 41DFh - 41BFh - 419Fh 41FEh - 41DEh - 41BEh - 419Eh 41FDh - - 419Dh 41FCh -, 6 = DMAnDSAH_DMA2. 41FBh - 41FAh -, 1 = 41DAh - 41BAh. 41FBh - 41FAh -, 2 = - 419Ch - 417Ch - - 419Bh - 417Bh - - 419Ah - 417Ah -. 41FBh - 41FAh -, 3 = 415Ch - 413Ch DMAnSSZL_DMA3 411Ch 415Bh DMAnSIRQ_DMA4 413Bh DMAnSPTRU_DMA3 411Bh 415Ah DMAnAIRQ_DMA4 413Ah DMAnSPTRH_DMA3 411Ah. 41FBh - 41FAh -, 4 = DMAnDPTRL_DMA2. 41FBh -",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n41FAh -, 5 = . 41FBh - 41FAh -, 6 = . , 1 = 41D9h - 41B9h. , 2 = - 4199h - 4179h -. , 3 = 4159h DMAnCON1_DMA4 4139h DMAnSPTRL_DMA3. , 4 = DMAnDCNTH_DMA2. , 5 = . , 6 = . 41F9h TMR3H_M1, 1 = . 41F9h TMR3H_M1, 2 = . 41F9h TMR3H_M1, 3 = 4119h. 41F9h TMR3H_M1, 4 = . 41F9h TMR3H_M1, 5 = . 41F9h TMR3H_M1, 6 = . 41F8h TMR3L_M1, 1 = 41D8h - 41B8h. 41F8h TMR3L_M1, 2 = - 4198h - 4178h -. 41F8h",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\nTMR3L_M1, 3 = 4158h DMAnCON0_DMA4 4138h DMAnSCNTH_DMA3 4118h. 41F8h TMR3L_M1, 4 = . 41F8h TMR3L_M1, 5 = . 41F8h TMR3L_M1, 6 = . , 1 = 41D7h - 41B7h. , 2 = - 4197h - 4177h -. , 3 = 4157h DMAnSSAU_DMA4 4137h DMAnSCNTL_DMA3 4117h. , 4 = DMAnDCNTL_DMA2. , 5 = . , 6 = . 41F7h TMR1H_M1, 1 = 41D6h - 41B6h. 41F7h TMR1H_M1, 2 = - 4196h - 4176h -. 41F7h TMR1H_M1, 3 = . 41F7h TMR1H_M1, 4 =",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\nDMAnBUF_DMA2. 41F7h TMR1H_M1, 5 = . 41F7h TMR1H_M1, 6 = . 41F6h TMR1L_M1 41F5h -, 1 = 41D5h - 41B5h. 41F6h TMR1L_M1 41F5h -, 2 = - 4195h - 4175h - - 4194h - 4174h -. 41F6h TMR1L_M1 41F5h -, 3 = 4156h DMAnSSAH_DMA4 4136h DMAnDSAH_DMA3 4116h 4155h DMAnSSAL_DMA4 4135h DMAnDSAL_DMA3 4115h. 41F6h TMR1L_M1 41F5h -, 4 = DMAnSIRQ_DMA1 DMAnAIRQ_DMA1. 41F6h TMR1L_M1 41F5h -, 5 = . 41F6h",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\nTMR1L_M1 41F5h -, 6 = . 41F4h -, 1 = 41D4h - 41B4h. 41F4h -, 2 = - 4193h - 4173h -. 41F4h -, 3 = 4154h DMAnSSZH_DMA4 4134h DMAnDSZH_DMA3 4114h 4153h DMAnSSZL_DMA4 4133h DMAnDSZL_DMA3 4113h. 41F4h -, 4 = DMAnCON1_DMA1. 41F4h -, 5 = . 41F4h -, 6 = . 41F3h -, 1 = 41D3h - 41B3h. 41F3h -, 2 = . 41F3h -, 3 = . 41F3h -, 4 = DMAnCON0_DMA1. 41F3h -, 5 = . 41F3h -, 6 = . , 1 = 41D2h - 41B2h. , 2 = - 4192h -",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n4172h - 4152h. , 3 = DMAnSPTRU_DMA4 4132h DMAnDPTRH_DMA3 4112h. , 4 = . , 5 = . , 6 = . 41F2h - 41F1h -, 1 = 41D1h - 41B1h. 41F2h - 41F1h -, 2 = - 4191h - 4171h - 4151h - 4190h - 4170h - 4150h. 41F2h - 41F1h -, 3 = DMAnSPTRH_DMA4 4131h DMAnDPTRL_DMA3 4111h. 41F2h - 41F1h -, 4 = DMAnSSAU_DMA1 DMAnSSAH_DMA1. 41F2h - 41F1h -, 5 = . 41F2h - 41F1h -, 6 = . 41F0h - 41EFh -, 1 = 41D0h - 41B0h 41CFh - 41AFh. 41F0h - 41EFh",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n-, 2 = - 418Fh - 416Fh - 414Fh. 41F0h - 41EFh -, 3 = DMAnSPTRL_DMA4 4130h DMAnDCNTH_DMA3 4110h DMAnSCNTH_DMA4 412Fh DMAnDCNTL_DMA3 410Fh. 41F0h - 41EFh -, 4 = DMAnSSAL_DMA1 DMAnSSZH_DMA1. 41F0h - 41EFh -, 5 = . 41F0h - 41EFh -, 6 = . 41EEh -, 1 = 41CEh - 41AEh. 41EEh -, 2 = - 418Eh - 416Eh - 414Eh - 418Dh - 416Dh - 414Dh. 41EEh -, 3 = DMAnSCNTL_DMA4 412Eh DMAnBUF_DMA3 410Eh. 41EEh -, 4 = DMAnSSZL_DMA1. 41EEh -, 5 = . 41EEh -, 6 =",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n. 41EDh -, 1 = 41CDh - 41ADh. 41EDh -, 2 = - 418Ch - 416Ch - 414Ch. 41EDh -, 3 = DMAnDSAH_DMA4 412Dh DMAnSIRQ_DMA2 410Dh. 41EDh -, 4 = DMAnSPTRU_DMA1. 41EDh -, 5 = . 41EDh -, 6 = . 41ECh -, 1 = 41CCh - 41ACh 41CBh - 41ABh. 41ECh -, 2 = - 418Bh - 416Bh - 414Bh - 418Ah - 416Ah - 414Ah. 41ECh -, 3 = DMAnDSAL_DMA4 412Ch DMAnAIRQ_DMA2 410Ch DMAnDSZH_DMA4 412Bh DMAnCON1_DMA2 410Bh. 41ECh -, 4 = DMAnSPTRH_DMA1 DMAnSPTRL_DMA1. 41ECh -, 5 = . 41ECh -, 6 = . 41CBh - 41EAh -",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n41E9h -, 1 = 41CAh - 41AAh 41C9h - 41A9h. 41CBh - 41EAh - 41E9h -, 2 = - 4189h - 4169h - 4149h - 4188h - 4168h - 4148h. 41CBh - 41EAh - 41E9h -, 3 = DMAnDSZL_DMA4 412Ah DMAnCON0_DMA2 410Ah DMAnDPTRH_DMA4 4129h DMAnSSAU_DMA2 4109h. 41CBh - 41EAh - 41E9h -, 4 = DMAnSCNTH_DMA1. 41CBh - 41EAh - 41E9h -, 5 = . 41CBh - 41EAh - 41E9h -, 6 = . 41E8h -, 1 = 41C8h - 41A8h. 41E8h -, 2 = - 4187h - 4167h - 4147h. 41E8h -, 3 =",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\nDMAnDPTRL_DMA4 4128h DMAnSSAH_DMA2 4108h DMAnDCNTH_DMA4 4127h DMAnSSAL_DMA2 4107h. 41E8h -, 4 = DMAnSCNTL_DMA1 DMAnDSAH_DMA1. 41E8h -, 5 = . 41E8h -, 6 = . 41E7h -, 1 = 41C7h - 41A7h. 41E7h -, 2 = - 4186h - 4166h - 4146h. 41E7h -, 3 = . 41E7h -, 4 = DMAnDSAL_DMA1. 41E7h -, 5 = . 41E7h -, 6 = . 41E6h -, 1 = 41C6h - 41A6h. 41E6h -, 2 = - 4185h - 4165h - 4145h. 41E6h -, 3 = DMAnDCNTL_DMA4 4126h DMAnSSZH_DMA2",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n4106h. 41E6h -, 4 = . 41E6h -, 5 = . 41E6h -, 6 = . , 1 = 41C5h - 41A5h. , 2 = - 4184h - 4164h - 4144h. , 3 = DMAnBUF_DMA4 4125h DMAnSSZL_DMA2 4105h. , 4 = DMAnDSZH_DMA1. , 5 = . , 6 = . 41E5h -, 1 = . 41E5h -, 2 = . 41E5h -, 3 = DMAnSIRQ_DMA3 4124h DMAnSPTRU_DMA2 4104h. 41E5h -, 4 = DMAnDSZL_DMA1. 41E5h -, 5 = . 41E5h -, 6 = . 41E4h -, 1 = 41C4h - 41A4h 41C3h - 41A3h. 41E4h -, 2 = - 4183h - 4163h -",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n4143h. 41E4h -, 3 = . 41E4h -, 4 = DMAnDPTRH_DMA1. 41E4h -, 5 = . 41E4h -, 6 = . 41E3h -, 1 = . 41E3h -, 2 = - 4182h - 4162h - 4142h. 41E3h -, 3 = DMAnAIRQ_DMA3 4123h DMAnSPTRH_DMA2 4103h. 41E3h -, 4 = . 41E3h -, 5 = . 41E3h -, 6 = . 41E2h IOCCF_M1, 1 = 41C2h - 41A2h. 41E2h IOCCF_M1, 2 = . 41E2h IOCCF_M1, 3 = DMAnCON1_DMA3 4122h DMAnSPTRL_DMA2 4102h. 41E2h IOCCF_M1, 4 = DMAnDPTRL_DMA1. 41E2h IOCCF_M1,",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n5 = . 41E2h IOCCF_M1, 6 = . , 1 = . , 2 = - 4181h - 4161h - 4141h. , 3 = . , 4 = DMAnDCNTH_DMA1. , 5 = . , 6 = . 41E1h IOCBF_M1, 1 = 41C1h - 41A1h. 41E1h IOCBF_M1, 2 = . 41E1h IOCBF_M1, 3 = DMAnCON0_DMA3 4121h DMAnSCNTH_DMA2 4101h. 41E1h IOCBF_M1, 4 = DMAnDCNTL_DMA1. 41E1h IOCBF_M1, 5 = . 41E1h IOCBF_M1, 6 = . , 1 = . , 2 = - 4180h - 4160h. , 3 = . , 4 = . , 5 = . , 6 = . , 1 = . , 2 = . , 3 = . , 4 = DMAnBUF_DMA1. , 5 = . , 6 = . , 1",
    "Figure 16-2. Special Function Register Map (DMA Access Only)\n= 41C0h -. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . 41E0h IOCAF_M1, 1 = . 41E0h IOCAF_M1, 2 = . 41E0h IOCAF_M1, 3 = DMAnSSAU_DMA3 4120h DMAnSCNTL_DMA2 4100h. 41E0h IOCAF_M1, 4 = . 41E0h IOCAF_M1, 5 = . 41E0h IOCAF_M1, 6 = . , 1 = . , 2 = -. , 3 = . , 4 = . , 5 = . , 6 = . , 1 = . , 2 = 41A0h. , 3 = . , 4 = . , 5 = . , 6 = . , 1 = . , 2 = 4140h. , 3 = . , 4 = . , 5 = . , 6 = ",
    "16.3.2 DMA Addressing\nThe start addresses for the source read and destination write operations are set using the DMAnSSA and DMAnDSA registers, respectively.\nWhen the DMA message transfers are in progress, the DMAnSPTR and DMAnDPTR registers contain the current Address Pointers for each source read and destination write operation. These registers are modified after each transaction based on the Address mode selection bits.\nThe SMODE and DMODE bits determine the Address modes of operation by controlling how the DMAnSPTR and DMAnDPTR registers are updated after every DMA data transaction (Figure 16-3).\nEach address can be separately configured to:\n\u00b7 Remain unchanged\n\u00b7 Increment by 1\n\u00b7 Decrement by 1\nFigure 16-3. DMA Pointers Block Diagram\nThe DMA can initiate data transfers from the PFM, Data EEPROM or SFR/GPR space. The SMR bits are used to select the type of memory being pointed to by the Source Address Pointer. The SMR bits are required because the PFM and SFR/GPR spaces have overlapping addresses that do not allow the specified address to uniquely define the memory location to be accessed.",
    "Important:\n1. For proper memory read access to occur, the combination of address and space selection must be valid.\n2. The destination does not have space selection bits because it can only write to the SFR/GPR space.",
    "16.3.3 DMA Message Size/Counters\nA transaction is the transfer of one byte. A message consists of one or more transactions. A complete DMA process consists of one or more messages. The size registers determine how many transactions are in a message. The DMAnSSZ registers determine the source size and DMAnDSZ registers determine the destination size.\nWhen a DMA transfer is initiated, the size registers are copied to corresponding counter registers that control the duration of the message. The DMAnSCNT registers count the source transactions and the DMAnDCNT registers count the destination transactions. Both are simultaneously decremented by one after each transaction.\nA message is started by setting the DGO bit and terminates when the smaller of the two counters reaches zero.\nWhen either counter reaches zero, the DGO bit is cleared and the counter and pointer registers are immediately reloaded with the corresponding size and address data. If the other counter did not reach zero, then the next message will continue with the count and address corresponding to that register. Refer to Figure 16-4.",
    "16.3.3 DMA Message Size/Counters\nWhen the Source and Destination Size registers are not equal, then the ratio of the largest to the smallest size determines how many messages are in the DMA process. For example, when the destination size is six and the source size is two, then each message will consist of two transactions and the complete DMA process will consist of three messages. When the larger size is not an even integer of the smaller size, then the last message in the process will terminate early when the larger count reaches zero. In that case, the larger counter will reset and the smaller counter will have a remainder skewing any subsequent messages by that amount.\nTable 16-2 has a few examples of configuring DMA Message sizes.\nImportant: Reading the DMAnSCNT or DMAnDCNT registers will never return zero. When either register is decremented from ' 1 ', it is immediately reloaded from the corresponding size register.\n\nTable 16-2. Example Message Size",
    "16.3.3 DMA Message Size/Counters\nRead from single SFR location to RAM, Example = UART Receive Buffer. Read from single SFR location to RAM, SCNT = 1. Read from single SFR location to RAM, DCNT = N. Read from single SFR location to RAM, Comments = N equals the number of bytes desired in the destination buffer. N \u2265 1.. Write to single SFR location from RAM, Example = UART Transmit Buffer. Write to single SFR location from RAM, SCNT = N. Write to single SFR location from RAM, DCNT = 1. Write to single SFR location from RAM, Comments = N equals the number of bytes desired in the source buffer. N \u2265 1.. Read from multiple SFR location, Example = ADC Result registers. Read from multiple SFR location, SCNT = 2. Read from multiple SFR location, DCNT = 2*N. Read from multiple SFR location, Comments = N equals the number of ADC results to be stored in memory. N \u2265 1. Write to Multiple SFR registers, Example = PWMDuty Cycle registers. Write to Multiple SFR registers, SCNT = 2*N. Write to Multiple",
    "16.3.3 DMA Message Size/Counters\nSFR registers, DCNT = 2. Write to Multiple SFR registers, Comments = N equals the number of PWMduty cycle values to be loaded from a memory table. N \u2265 1\nFigure 16-4. DMA Counters Block Diagram",
    "16.3.4 DMA Message Transfers\nOnce the Enable bit is set to start DMA message transfers, the Source/Destination Pointer and Counter registers are initialized to the conditions shown in the table below.\nTable 16-3. DMA Initial Conditions\n\nDMAnSPTR, Value Loaded = DMAnSSA. DMAnSCNT, Value Loaded = DMAnSSZ\n...........continued, 1 = . ...........continued, 2 = . , 1 = DMAnDPTR. , 2 = DMAnDSA. , 1 = DMAnDCNT. , 2 = DMAnDSZ\nDuring the DMA operation after each transaction, Table 16-4 and Table 16-5 indicate how the Source/Destination Pointer and Counter registers are modified.\nThe following sections discuss how to initiate and terminate DMA transfers.",
    "16.3.4 DMA Message Transfers\nTable 16-4. DMA Source Pointer/Counter During Operation\n\nDMAnSCNT != 1, Modified Source Counter/Pointer Value = DMAnSCNT = DMAnSCNT -1 SMODE = 00 : DMAnSPTR = DMAnSPTR SMODE = 01 : DMAnSPTR = DMAnSPTR + 1. DMAnSCNT == 1, Modified Source Counter/Pointer Value = DMAnSCNT = DMAnSSZ DMAnSPTR = DMAnSSA\nTable 16-5. DMA Destination Pointer/Counter During Operation\n\nDMAnDCNT != 1, Modified Destination Counter/Pointer Value = DMAnDCNT = DMAnDCNT -1 DMODE = 00 : DMAnDPTR = DMAnDPTR DMODE = 01 : DMAnDPTR = DMAnDPTR + 1 DMODE = 10 : DMAnDPTR = DMAnDPTR - 1. DMAnDCNT == 1, Modified Destination Counter/Pointer Value = DMAnDCNT = DMAnDSZ DMAnDPTR = DMAnDSA",
    "16.3.4.1 Starting DMA Message Transfers\nThe DMA can initiate data transactions by either of the following two conditions:\n\u00b7 User software control\n\u00b7 Hardware trigger, SIRQ",
    "16.3.4.1.1 User Software Control\nSoftware starts or stops DMA transaction by setting/clearing the DGO bit. The DGO bit is also used to indicate whether a DMA hardware trigger has been received and a message is in progress.",
    "Important:\n1. Software start can only occur when the EN bit is set.\n2. If the CPU writes to the DGO bit while it is already set, there is no effect on the system, the DMA will continue to operate normally.",
    "16.3.4.1.2 Hardware Trigger, SIRQ\nA hardware trigger is an interrupt request from another module sent to the DMA with the purpose of starting a DMA message. The DMA start trigger source is user-selectable using the DMAnSIRQ register.\nThe SIRQEN bit is used to enable sampling of external interrupt triggers by which a DMA transfer can be started. When set, the DMA will sample the selected interrupt source and when cleared, the DMA will ignore the interrupt source. Clearing the SIRQEN bit does not stop a DMA transaction currently in progress, it only stops more hardware request signals from being received.",
    "16.3.4.2 Stopping DMA Message Transfers\nThe DMA controller can stop data transactions by any of the following conditions:\n\u00b7 Clearing the DGO bit\n\u00b7 Hardware abort trigger, AIRQ\n\u00b7 Source count reload\n\u00b7 Destination count reload\n\u00b7 Clearing the EN bit",
    "16.3.4.2.1 User Software Control\nIf the user clears the DGO bit, the message will be stopped and the DMA will remain in the current configuration.\nFor example, if the user clears the DGO bit after source data have been read but before it is written to the destination, then the data in the DMAnBUF register will not reach its destination.\nThis is also referred to as a soft-stop as the operation can resume, if desired, by setting the DGO bit again.",
    "16.3.4.2.2 Hardware Trigger, AIRQ\nThe AIRQEN bit is used to enable sampling of external interrupt triggers by which a DMA transaction can be aborted.\nOnce an abort interrupt request has been received, the DMA will perform a soft-stop by clearing the DGO bit, as well as clearing the SIRQEN bit so overruns do not occur. The AIRQEN bit is also cleared to prevent additional abort signals from triggering false aborts.\nIf desired, the DGO bit can be set again and the DMA will resume operation from where it left off after the soft stop had occurred, as none of the DMA state information is changed in the event of an abort.",
    "16.3.4.2.3 Source Count Reload\nA DMA message is considered to be complete when the Source Count register is decremented from ' 1 ' and then reloaded (i.e., once the last byte from either the source read or destination write has occurred). When the SSTP bit is set and the Source Count register is reloaded, then further message transfer is stopped.",
    "16.3.4.2.4 Destination Count Reload\nA DMA message is considered to be complete when the Destination Count register is decremented from 1 and then reloaded (i.e., once the last byte from either the source read or destination write has occurred). When the DSTP bit is set and the Destination Count register is reloaded then further message transfer is stopped.\nImportant: Reading the DMAnSCNT or DMAnDCNT registers will never return zero. When either register is decremented from ' 1 ', it is immediately reloaded from the corresponding size register.",
    "16.3.4.2.5 Clearing the EN Bit\nIf the user clears the EN bit, the message will be stopped and the DMA will return to its default configuration. This is also referred to as a hard stop, as the DMA cannot resume operation from where it was stopped.\nImportant: After the DMA message transfer is stopped, it requires an extra instruction cycle before the Stop condition takes effect. Thus, after the Stop condition has occurred, a source read or a destination write can occur depending on the source or destination bus availability.",
    "16.4 Disable DMA Message Transfer Upon Completion\nOnce the DMA message is complete, it may be desirable to disable the trigger source to prevent overrun or under run of data. This can be done by any of the following methods:\n\u2022 Clearing the SIRQEN bit\n\u2022 Setting the SSTP bit\n\u2022 Setting the DSTP bit",
    "16.4.1 Clearing the SIRQEN Bit\nClearing the SIRQEN bit stops the sampling of external start interrupt triggers, hence preventing further DMA message transfers.\nAn example is a communications peripheral with a level-triggered interrupt. The peripheral will continue to request data (because its buffer is empty) even though there is no more data to be moved. Disabling the SIRQEN bit prevents the DMA from processing these requests.",
    "16.4.2 Source/Destination Stop\nThe SSTP and DSTP bits determine whether or not to disable the hardware triggers (SIRQEN = 0 ), once a DMA message has completed.\nWhen the SSTP bit is set and the DMAnSCNT = 0 , then the SIRQEN bit will be cleared. Similarly, when the DSTP bit is set and the DMAnDCNT = 0 , the SIRQEN bit will be cleared.\nImportant: The SSTP and DSTP bits are independent functions and do not depend on each other. It is possible for a message to be stopped by either counter at message end or both counters at message end.",
    "16.5 Types of Hardware Triggers\nThe DMA has two different trigger inputs, the source trigger and the abort trigger. Each of these trigger sources is user configurable using the DMAnSIRQ and DMAnAIRQ registers.\nBased on the source selected for each trigger, there are two types of requests that can be sent to the DMA:\n\u00b7 Edge triggers\n\u00b7 Level triggers",
    "16.5.1 Edge Trigger Requests\nAn edge request occurs only once when a given module interrupt requirements are true. Examples of edge triggers are the ADC conversion complete and the interrupt-on-change interrupts.",
    "16.5.2 Level Trigger Requests\nA level request is asserted as long as the condition that causes the interrupt is true. Examples of level triggers are the UART receive and transmit interrupts.",
    "16.6 Types of Data Transfers\nBased on the memory access capabilities of the DMA (see Table 16-1), the following sections discuss the different types of data movement between the source and destination memory regions.\n- \u00b7 N:1 This type of transfer is common when sending predefined data packets (such as strings) through\na single interface point (such as communications modules transmit registers).\n- \u2022\nto SRAM for manipulation by the CPU or other peripherals.\nN:N This type of transfer is useful for moving information out of the program Flash or Data EEPROM\n\u00b7 1:1\nThis type of transfer is common when bridging two different modules data streams together (communications bridge).\n- \u00b7 1:N\nThis type of transfer is useful for moving information from a single data source into a memory buffer (communications receive registers).",
    "16.7 DMA Interrupts\nEach DMA has its own set of four interrupt flags, used to indicate a range of conditions during data transfers. The interrupt flag bits can be accessed using the corresponding PIR registers (refer to the 'VIC - Vectored Interrupt Controller Module' chapter).",
    "16.7.1 DMA Source Count Interrupt\nThe Source Count Interrupt Flag (DMAxSCNTIF) is set every time the DMAnSCNT register reaches zero and is reloaded to its starting value.",
    "16.7.2 DMA Destination Count Interrupt\nThe Destination Count Interrupt Flag (DMAxDCNTIF) is set every time the DMAnDCNT register reaches zero and is reloaded to its starting value.\nThe DMA source and destination count interrupts signal the CPU when the DMA messages are completed.",
    "16.7.3 Abort Interrupt\nThe Abort Interrupt Flag (DMAxAIF) is used to signal that the DMA has halted activity due to an abort signal from one of the abort sources. This is used to indicate that the transaction has been halted by a hardware event.",
    "16.7.4 Overrun Interrupt\nWhen the DMA receives a trigger to start a new message before the current message is completed, then the Overrun Interrupt Flag (DMAxORIF) bit is set.\nThis condition indicates that the DMA is being requested before its current transaction is finished. This implies that the active DMA may not be able to keep up with the demands from the peripheral module being serviced, which may result in data loss.\nThe DMAxORIF flag being set does not cause the current DMA transfer to terminate.\nThe overrun interrupt is only available for trigger sources that are edge-based and is not available for sources that are level-based. Therefore, a level-based interrupt source does not trigger a DMA overrun error due to the potential latency issues in the system.\nAn example of an interrupt that can use the overrun interrupt is a timer overflow (or period match) interrupt. This event only happens every time the timer rolls over and is not dependent on any other system conditions.",
    "16.7.4 Overrun Interrupt\nAn example of an interrupt that does not allow the overrun interrupt is the UART TX buffer. The UART will continue to assert the interrupt until the DMA is able to process the message. Due to latency issues, the DMA may not be able to service an empty buffer immediately, but the UART continues to assert its transmit interrupt until it is serviced. If overrun was allowed in this case, the overrun would occur almost immediately, as the module samples the interrupt sources every instruction cycle.",
    "16.8 DMA Setup and Operation\nThe following steps illustrate how to configure the DMA for data transfer:\n1. Select the desired DMA using the DMASELECT register.\n2. Program the appropriate source and destination addresses for the transaction into the DMAnSSA and DMAnDSA registers.\n3. Select the source memory region that is being addressed by the DMAnSSA register, using the SMR bits.\n4. Program the SMODE and DMODE bits to select the Addressing mode.\n5. Program the source size (DMAnSSZ) and destination size (DMAnDSZ) registers with the number of bytes to be transferred. It is recommended for proper operation that the size registers be a multiple of each other.\n6. If the user desires to disable data transfers once the message has completed, then the SSTP and DSTP bits need to be set (see the Source/Destination Stop section).\n7. If using hardware triggers for data transfer, set up the hardware trigger interrupt sources for the starting and aborting DMA transfers (DMAnSIRQ and DMAnAIRQ), and set the corresponding Interrupt Request Enable (SIRQEN and AIRQEN) bits.",
    "16.8 DMA Setup and Operation\n8. Select the priority level for the DMA (see the 'System Arbitration' section in the 'PIC18 CPU' chapter) and lock the priorities (see the 'Priority Lock' section in the 'PIC18 CPU' chapter).\n9. Enable the DMA by setting the EN bit.\n10. If using software control for data transfer, set the DGO bit, else this bit will be set by the hardware trigger.\nOnce the DMA is set up, Figure 16-5 describes the sequence of operation when the DMA uses hardware triggers and utilizes the unused CPU cycles (bubble) for DMA transfers.\nThe following sections describe with visual reference the sequence of events for different configurations of the DMA module.\nFigure 16-5. DMA Operation with Hardware Trigger",
    "16.8.1 Source Stop\nWhen the Source Stop bit is set (SSTP = 1 ) and the DMAnSCNT register reloads, the DMA clears the SIRQEN bit to stop receiving new start interrupt request signals and sets the DMAnSCNTIF flag. Refer to the figure below for more details.\nFigure 16-6. GPR-GPR Transactions with Hardware Triggers, SSTP = 1\n\u3130\n\u6374\n\u7275\n\u7374\n\u636b\n\u3131\n\u3132\n\u3133\n\u3134\n\u3135\n\u3136\n\u3137\n\u3138\n\u3139\n\u416e\n\u5353",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write\n\u7265\n\u7264\n\u7263\n\u536f\n\u5343\n\u4178\n\u4178\n\u4154\n\u5354\n\u4120\n\u5054\n\u416e\n\u416e\n\u416e\n\u5343\n\u416e\n\u5350\n\u7269\n\u454e\n\u5349\n\u454e\n\u416e\n\u5353\n\u5352\n\u4457\n\u5341\n\u416e\n\u535a\n\u416e\n\u5352\n\u4457\n\u5352\n\u4457\n\u5352\n\u4457",
    "16.8.2 Destination Stop\nWhen the Destination Stop bit is set (DSTP = 1 ) and the DMAxDCNT register reloads, the DMA clears the SIRQEN bit to stop receiving new start interrupt request signals and sets the DMAnDCNTIF flag.\nFigure 16-7. GPR-GPR Transactions with Hardware Triggers, DSTP = 1\n\u3130\n\u6374\n\u7275\n\u7374\n\u636b\n\u3131\n\u3132\n\u3133\n\u3134\n\u3135\n\u3136\n\u3137\n\u3138\n\u3139\n\u416e\n\u5353",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write",
    "16.8.3 Continuous Transfer\nWhen the Source or the Destination Stop bit is cleared (SSTP, DSTP = 0 ), the transactions continue unless stopped by the user. The DMAxSCNTIF and DMAxDCNTIF flags are set whenever the respective counter registers are reloaded.\n\u7265\n\u7264\n\u7263\n\u536f\n\u5343\n\u4178\n\u4178\n\u4154\n\u5354\n\u4120\n\u5054\n\u416e\n\u416e\n\u416e\n\u5343\n\u416e\n\u5350\n\u7269\n\u454e\n\u5349\n\u454e\n\u416e\n\u5353\n\u5352\n\u4457\n\u5341\n\u416e\n\u535a\n\u416e\n\u5352\n\u4457\n\u5352\n\u4457\n\u5352\n\u4457",
    "Figure 16-8. GPR-GPR Transactions with Hardware Triggers, SSTP, DSTP = 0\n\u3130\n\u3131\n\u3132\n\u3133\n\u3134\n\u3135\n\u3136\n\u3137\n\u3138\n\u3139\n\u6374\n\u7275\n\u7374\n\u636b\n\u416e\n\u5353",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write\n\u4178\n\u5343\n\u4178\n\u416e\n\u5054\n\u416e\n\u416e\n\u5343\n\u416e\n\u5350\n\u7265\n\u7264\n\u4154\n\u5354\n\u454e\n\u5349\n\u4120\n\u7263\n\u7269\n\u536f\n\u454e\n\u416e\n\u5353\n\u5352\n\u4457\n\u5352\n\u4457\n\u5341\n\u416e\n\u535a\n\u416e\n\u5352\n\u4457\n\u5352\n\u4457\n\u5352\n\u4457\n\u5352\n\u3230\n\u4457\n\u3231\n\u3232\n\u3233\n\u3234\n\u5352\n\u3235\n\u4457\n\u3236\n\u5352\n\u3237\n\u4457\n\u3238\n\u3239\n\u3330\n\u3331\n\u3332",
    "16.8.4 Transfer from SFR to GPR\nThe following visual reference describes the sequence of events when copying ADC results to a GPR location. The ADC interrupt flag can be chosen as the source hardware trigger, the source address can be set to point to the ADC Result registers (e.g., at 0x3EEF), and the destination address can be set to point to any chosen GPR location (e.g., at 0x100).\nFigure 16-9. SFR Space to GPR Space Transfer\n\u6374\n\u7374\n\u7275\n\u636b\n\u454e\n\u534d",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write",
    "16.8.5 Overrun Condition\nThe Overrun Interrupt flag is set if the DMA receives a trigger to start a new message before the current message is completed.\n\u7265\n\u7264\n\u7263\n\u536f\n\u5343\n\u4178\n\u4178\n\u4154\n\u5354\n\u4120\n\u5054\n\u416e\n\u416e\n\u416e\n\u5343\n\u416e\n\u5350\n\u7269\n\u454e\n\u5349\n\u416e\n\u5353\n\u416e\n\u5353\n\u3130\n\u4545\n\u5352\n\u4457\n\u5341\n\u416e\n\u535a\n\u416e\n\u5352\n\u4546\n\u4457\n\u7841\n\u444c\n\u5352\n\u4457\n\u5352\n\u4546\n\u4457\n\u444c",
    "Figure 16-10. Overrun Interrupt\nDMAnCON1bits.SMA = 01\nDMAnSSA\n0x100\nDMAnSSZ\n0x2",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write\nDMAnDSA\nDMAnDSZ\n0x200\n0x20",
    "16.8.6 Abort Trigger, Message Complete\nThe AIRQEN needs to be set in order for the DMA to sample abort interrupt sources. When an abort interrupt is received, the SIRQEN bit is cleared and the AIRQEN bit is cleared to avoid receiving further abort triggers.\nFigure 16-11. Abort at the End of Message\n\u6374\n\u7374\n\u7275\n\u636b\n\u454e\n\u416e\n\u5353",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write\n\u7265\n\u7264\n\u7263\n\u536f\n\u7264\n\u7265\n\u7274\n\u4162\n\u4178\n\u4178\n\u4149\n\u4178\n\u5343\n\u4154\n\u5354\n\u4120\n\u5054\n\u416e\n\u416e\n\u416e\n\u5343\n\u416e\n\u5350\n\u7269\n\u7269\n\u454e\n\u454e\n\u5349\n\u4149\n\u416e\n\u5353\n\u3130\n\u4545\n\u5352\n\u4457\n\u5341\n\u416e\n\u535a\n\u416e\n\u5352\n\u4546\n\u4457\n\u7841\n\u444c\n\u5352\n\u4457\n\u5352\n\u3130\n\u4546\n\u4457\n\u3130",
    "16.8.7 Abort Trigger, Message in Progress\nWhen an abort interrupt request is received in a DMA transaction, the DMA will perform a soft-stop by clearing the DGO bit (i.e., if the DMA was reading the source register, it will complete the read operation and then clear the DGO bit).\nThe SIRQEN bit is cleared to prevent any overrun and the AIRQEN bit is cleared to prevent any false aborts. When the DGO bit is set again, the DMA will resume operation from where it left off after the soft-stop.\nFigure 16-12. Abort During Message Transfer\n\u3130\n\u3130\n\u3131\n\u3132\n\u416e\n\u5353",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write\n\u7265\n\u7264\n\u7263\n\u536f\n\u7265\n\u7264\n\u7274\n\u4162\n\u4154\n\u4120\n\u5354\n\u416e\n\u5054\n\u416e\n\u416e\n\u416e\n\u5343\n\u416e\n\u5350\n\u7269\n\u7269\n\u4178\n\u4149\n\u6374\n\u7374\n\u7275\n\u636b\n\u454e\n\u454e\n\u454e\n\u5349\n\u4149\n\u416e\n\u5353\n\u5849\n\u4545\n\u5341\n\u416e\n\u535a\n\u416e\n\u5352\n\u3130\n\u7841\n\u4457\n\u5352\n\u4546\n\u4457\n\u444c",
    "16.9 Reset\nThe DMA registers are set to the default state on any Reset. The registers are also reset to the default state when the enable bit is cleared (EN = 0 ). User firmware needs to set up all the registers to resume DMA operation.",
    "16.10 Power-Saving Mode Operation\nThe DMA utilizes system clocks and it is treated as a peripheral when it comes to power-saving operations. Like other peripherals, the DMA also uses Peripheral Module Disable bits to further tailor its operation in low-power states.",
    "16.10.1  Sleep Mode\nWhen the device enters Sleep mode, the system clock to the module is shut down, therefore no DMA operation is supported in Sleep. Once the system clock is disabled, the requisite read and write clocks are also disabled, without which the DMA cannot perform any of its tasks.\nAny transfers that may be in progress are resumed on exiting from Sleep mode. Register contents are not affected by the device entering or leaving Sleep mode. It is recommended that DMA transactions be allowed to finish before entering Sleep mode.",
    "16.10.2  Idle Mode\nIn Idle mode, all of the system clocks (including the read and write clocks) are still operating, but the CPU is not using them to save power.\nTherefore, every instruction cycle is available to the system arbiter and if the bubble is granted to the DMA, it may be utilized to move data.",
    "16.10.3  Doze Mode\nSimilar to the Idle mode, the CPU does not utilize all of the available instruction cycles slots that are available to it to save power. It only executes instructions based on its Doze mode settings.\nTherefore, every instruction not used by the CPU is available for system arbitration and may be utilized by the DMA, if granted by the arbiter.",
    "16.10.4  Peripheral Module Disable\nThe Peripheral Module Disable (PMD) registers provide a method to disable DMA by gating all clock sources supplied to it. The respective DMAxMD bit needs to be set to disable the DMA.",
    "16.11 Example Setup Code\nThis code example illustrates using DMA1 to transfer 10 bytes of data from 0x1000 in Flash memory to the UART transmit buffer.",
    "16.12 Register Overlay\nAll DMA instances in this device share the same set of registers. Only one DMA instance is accessible at a time. The value in the DMASELECT register is one less than the selected DMA instance. For example, a DMASELECT value of ' 0 ' selects DMA1.",
    "16.13.1  DMASELECT\nName:\nDMASELECT\nAddress:\n0x0E8\nDMA Instance Selection Register\nSelects which DMA instance is accessed by the DMA registers\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = SLCT[2:0]. , 7 = SLCT[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 2:0 - SLCT[2:0] DMA Instance Selection\nn, Description = Shared DMA registers of instance n+1 are selected for read and write operations",
    "16.13.2  DMAnCON0\nName:\nDMAnCON0\nAddress:\n0x0FC\nDMA Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = SIRQEN. , 3 = DGO. , 4 = . , 5 = . , 6 = AIRQEN. , 7 = . , 8 = XIP. Access, 1 = R/W. Access, 2 = R/W/HC. Access, 3 = R/W/HS/HC. Access, 4 = . Access, 5 = . Access, 6 = R/W/HC. Access, 7 = . Access, 8 = R/HS/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - EN DMA Module Enable\n1, Description = Enables module. 0, Description = Disables module",
    "Bit 6 - SIRQEN Start of Transfer Interrupt Request Enable\n1, Description = Hardware triggers are allowed to start DMA transfers. 0, Description = Hardware triggers are not allowed to start the DMA transfers",
    "Bit 5 - DGO DMA Transaction\n1, Description = DMA transaction is in progress. 0, Description = DMA transaction is not in progress",
    "Bit 2 - AIRQEN Abort of Transfer Interrupt Request Enable\n1, Description = Hardware triggers are allowed to abort DMA transfers. 0, Description = Hardware triggers are not allowed to abort the DMA transfers",
    "Bit 0 - XIP Transfer in Progress Status\n1, Description = The DMA buffer register currently holds contents from a read operation and has not transferred data to the destination. 0, Description = The DMA buffer register is empty or has successfully transferred data to the destination address",
    "16.13.3  DMAnCON1\nName: Address:\nDMAnCON1 0x0FD",
    "DMA Control Register 1\nBit, 1 = 7 6. Bit, 2 = 7 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMODE[1:0]. , 2 = DMODE[1:0]. , 3 = DSTP. , 4 = SMR[1:0]. , 5 = SMR[1:0]. , 6 = SMODE[1:0]. , 7 = SMODE[1:0]. , 8 = SSTP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:6 - DMODE[1:0] Destination Address Mode Selection\n11, Description = Reserved, do not use. 10, Description = Destination Pointer (DMADPTR) is decremented after each transfer. 01, Description = Destination Pointer (DMADPTR) is incremented after each transfer. 00, Description = Destination Pointer (DMADPTR) remains unchanged after each transfer",
    "Bit 5 - DSTP Destination Counter Reload Stop\n1, Description = SIRQEN bit is cleared when destination counter reloads. 0, Description = SIRQEN bit is not cleared when destination counter reloads",
    "Bits 4:3 - SMR[1:0] Source Memory Region Selection\n1x, Description = Data EEPROM is selected as the DMA source memory. 01, Description = Program Flash Memory is selected as the DMA source memory. 00, Description = SFR/GPR data space is selected as the DMA source memory",
    "Bits 2:1 - SMODE[1:0] Source Address Mode Selection\n11, Description = Reserved, do not use. 10, Description = Source Pointer (DMASPTR) is decremented after each transfer. 01, Description = Source Pointer (DMASPTR) is incremented after each transfer. 00, Description = Source Pointer (DMASPTR) remains unchanged after each transfer",
    "Bit 0 - SSTP Source Counter Reload Stop\n1, Description = SIRQEN bit is cleared when source counter reloads. 0, Description = SIRQEN bit is not cleared when source counter reloads",
    "16.13.4  DMAnBUF\nName:\nDMAnBUF\nAddress:\n0x0E9",
    "DMA Data Buffer Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BUF[7:0]. , 2 = BUF[7:0]. , 3 = BUF[7:0]. , 4 = BUF[7:0]. , 5 = BUF[7:0]. , 6 = BUF[7:0]. , 7 = BUF[7:0]. , 8 = BUF[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Description\nThese bits reflect the content of the internal data buffer the DMA peripheral uses to hold the data being moved from the source to destination.",
    "16.13.5  DMAnSSA\nName: Address:\nDMAnSSA 0x0F9",
    "DMA Source Start Address Register\nAccess, 23. = . Access, 22. = . Access, 21.SSA[21:16] = R/W. Access, 20.SSA[21:16] = R/W. Access, 19.SSA[21:16] = R/W. Access, 18.SSA[21:16] = R/W. Access, 17.SSA[21:16] = R/W. Access, 16.SSA[21:16] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21.SSA[21:16] = 0. Reset, 20.SSA[21:16] = 0. Reset, 19.SSA[21:16] = 0. Reset, 18.SSA[21:16] = 0. Reset, 17.SSA[21:16] = 0. Reset, 16.SSA[21:16] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21.SSA[21:16] = 13. Bit, 20.SSA[21:16] = 12. Bit,",
    "DMA Source Start Address Register\n19.SSA[21:16] = 11. Bit, 18.SSA[21:16] = 10. Bit, 17.SSA[21:16] = 9. Bit, 16.SSA[21:16] = 8. , 23. = SSA[15:8]. , 22. = SSA[15:8]. , 21.SSA[21:16] = SSA[15:8]. , 20.SSA[21:16] = SSA[15:8]. , 19.SSA[21:16] = SSA[15:8]. , 18.SSA[21:16] = SSA[15:8]. , 17.SSA[21:16] = SSA[15:8]. , 16.SSA[21:16] = SSA[15:8]. Access, 23. = R/W. Access, 22. = R/W. Access, 21.SSA[21:16] = R/W. Access, 20.SSA[21:16] = R/W. Access,",
    "DMA Source Start Address Register\n19.SSA[21:16] = R/W. Access, 18.SSA[21:16] = R/W. Access, 17.SSA[21:16] = R/W. Access, 16.SSA[21:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.SSA[21:16] = 0. Reset, 20.SSA[21:16] = 0. Reset, 19.SSA[21:16] = 0. Reset, 18.SSA[21:16] = 0. Reset, 17.SSA[21:16] = 0. Reset, 16.SSA[21:16] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21.SSA[21:16] = 5. Bit, 20.SSA[21:16] = 4. Bit, 19.SSA[21:16] = 3. Bit, 18.SSA[21:16] = 2. Bit, 17.SSA[21:16] = 1. Bit,",
    "DMA Source Start Address Register\n16.SSA[21:16] = 0. , 23. = SSA[7:0]. , 22. = SSA[7:0]. , 21.SSA[21:16] = SSA[7:0]. , 20.SSA[21:16] = SSA[7:0]. , 19.SSA[21:16] = SSA[7:0]. , 18.SSA[21:16] = SSA[7:0]. , 17.SSA[21:16] = SSA[7:0]. , 16.SSA[21:16] = SSA[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21.SSA[21:16] = R/W. Access, 20.SSA[21:16] = R/W. Access, 19.SSA[21:16] = R/W. Access, 18.SSA[21:16] = R/W. Access, 17.SSA[21:16] = R/W. Access,",
    "DMA Source Start Address Register\n16.SSA[21:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.SSA[21:16] = 0. Reset, 20.SSA[21:16] = 0. Reset, 19.SSA[21:16] = 0. Reset, 18.SSA[21:16] = 0. Reset, 17.SSA[21:16] = 0. Reset, 16.SSA[21:16] = 0",
    "Bits 21:0 - SSA[21:0] Source Start Address\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnSSAU: Accesses the upper most byte [23:16].\n2. DMAnSSAH: Accesses the high byte [15:8].\n3. DMAnSSAL: Access the low byte [7:0].",
    "16.13.6  DMAnSSZ\nName: Address:\nDMAnSSZ\n0x0F7\nDMA Source Size Register",
    "16.13.6  DMAnSSZ\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11.SSZ[11:8] = R/W. Access, 10.SSZ[11:8] = R/W. Access, 9.SSZ[11:8] = R/W. Access, 8.SSZ[11:8] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11.SSZ[11:8] = 0. Reset, 10.SSZ[11:8] = 0. Reset, 9.SSZ[11:8] = 0. Reset, 8.SSZ[11:8] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11.SSZ[11:8] = 3. Bit, 10.SSZ[11:8] = 2. Bit, 9.SSZ[11:8] = 1. Bit,",
    "16.13.6  DMAnSSZ\n8.SSZ[11:8] = 0. , 15. = SSZ[7:0]. , 14. = SSZ[7:0]. , 13. = SSZ[7:0]. , 12. = SSZ[7:0]. , 11.SSZ[11:8] = SSZ[7:0]. , 10.SSZ[11:8] = SSZ[7:0]. , 9.SSZ[11:8] = SSZ[7:0]. , 8.SSZ[11:8] = SSZ[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11.SSZ[11:8] = R/W. Access, 10.SSZ[11:8] = R/W. Access, 9.SSZ[11:8] = R/W. Access, 8.SSZ[11:8] = R/W. Reset, 15. = 0. Reset, 14. =",
    "16.13.6  DMAnSSZ\n0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11.SSZ[11:8] = 0. Reset, 10.SSZ[11:8] = 0. Reset, 9.SSZ[11:8] = 0. Reset, 8.SSZ[11:8] = 0",
    "Bits 11:0 - SSZ[11:0] Source Message Size\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnSSZH: Accesses the high byte [15:8].\n2. DMAnSSZL: Access the low byte [7:0].",
    "16.13.7  DMAnSCNT\nName: Address:\nDMAnSCNT 0x0F2\nDMA Source Count Register",
    "16.13.7  DMAnSCNT\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11.SCNT[11:8] = R/W. Access, 10.SCNT[11:8] = R/W. Access, 9.SCNT[11:8] = R/W. Access, 8.SCNT[11:8] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11.SCNT[11:8] = 0. Reset, 10.SCNT[11:8] = 0. Reset, 9.SCNT[11:8] = 0. Reset, 8.SCNT[11:8] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11.SCNT[11:8] = 3. Bit, 10.SCNT[11:8] = 2. Bit, 9.SCNT[11:8] = 1. Bit,",
    "16.13.7  DMAnSCNT\n8.SCNT[11:8] = 0. , 15. = SCNT[7:0]. , 14. = SCNT[7:0]. , 13. = SCNT[7:0]. , 12. = SCNT[7:0]. , 11.SCNT[11:8] = SCNT[7:0]. , 10.SCNT[11:8] = SCNT[7:0]. , 9.SCNT[11:8] = SCNT[7:0]. , 8.SCNT[11:8] = SCNT[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11.SCNT[11:8] = R/W. Access, 10.SCNT[11:8] = R/W. Access, 9.SCNT[11:8] = R/W. Access, 8.SCNT[11:8] = R/W. Reset, 15. = 0. Reset, 14.",
    "16.13.7  DMAnSCNT\n= 0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11.SCNT[11:8] = 0. Reset, 10.SCNT[11:8] = 0. Reset, 9.SCNT[11:8] = 0. Reset, 8.SCNT[11:8] = 0",
    "Bits 11:0 - SCNT[11:0] Current Source Byte Count\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnSCNTH: Accesses the high byte [15:8].\n2. DMAnSCNTL: Access the low byte [7:0].",
    "16.13.8  DMAnSPTR\nName: Address:\nDMAnSPTR 0x0F4",
    "DMA Source Pointer Register\nAccess, 23. = . Access, 22. = . Access, 21.SPTR[21:16] = R. Access, 20.SPTR[21:16] = R. Access, 19.SPTR[21:16] = R. Access, 18.SPTR[21:16] = R. Access, 17.SPTR[21:16] = R. Access, 16.SPTR[21:16] = R. Reset, 23. = . Reset, 22. = . Reset, 21.SPTR[21:16] = 0. Reset, 20.SPTR[21:16] = 0. Reset, 19.SPTR[21:16] = 0. Reset, 18.SPTR[21:16] = 0. Reset, 17.SPTR[21:16] = 0. Reset, 16.SPTR[21:16] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21.SPTR[21:16] = 13. Bit, 20.SPTR[21:16] = 12. Bit, 19.SPTR[21:16] = 11. Bit,",
    "DMA Source Pointer Register\n18.SPTR[21:16] = 10. Bit, 17.SPTR[21:16] = 9. Bit, 16.SPTR[21:16] = 8. , 23. = SPTR[15:8]. , 22. = SPTR[15:8]. , 21.SPTR[21:16] = SPTR[15:8]. , 20.SPTR[21:16] = SPTR[15:8]. , 19.SPTR[21:16] = SPTR[15:8]. , 18.SPTR[21:16] = SPTR[15:8]. , 17.SPTR[21:16] = SPTR[15:8]. , 16.SPTR[21:16] = SPTR[15:8]. Access, 23. = R. Access, 22. = R. Access, 21.SPTR[21:16] = R. Access, 20.SPTR[21:16] = R. Access, 19.SPTR[21:16] = R. Access, 18.SPTR[21:16] = R. Access,",
    "DMA Source Pointer Register\n17.SPTR[21:16] = R. Access, 16.SPTR[21:16] = R. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.SPTR[21:16] = 0. Reset, 20.SPTR[21:16] = 0. Reset, 19.SPTR[21:16] = 0. Reset, 18.SPTR[21:16] = 0. Reset, 17.SPTR[21:16] = 0. Reset, 16.SPTR[21:16] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21.SPTR[21:16] = 5. Bit, 20.SPTR[21:16] = 4. Bit, 19.SPTR[21:16] = 3. Bit, 18.SPTR[21:16] = 2. Bit, 17.SPTR[21:16] = 1. Bit, 16.SPTR[21:16] = 0. , 23. = SPTR[7:0]. , 22. = SPTR[7:0]. ,",
    "DMA Source Pointer Register\n21.SPTR[21:16] = SPTR[7:0]. , 20.SPTR[21:16] = SPTR[7:0]. , 19.SPTR[21:16] = SPTR[7:0]. , 18.SPTR[21:16] = SPTR[7:0]. , 17.SPTR[21:16] = SPTR[7:0]. , 16.SPTR[21:16] = SPTR[7:0]. Access, 23. = R. Access, 22. = R. Access, 21.SPTR[21:16] = R. Access, 20.SPTR[21:16] = R. Access, 19.SPTR[21:16] = R. Access, 18.SPTR[21:16] = R. Access, 17.SPTR[21:16] = R. Access, 16.SPTR[21:16] = R. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.SPTR[21:16] = 0. Reset, 20.SPTR[21:16] =",
    "DMA Source Pointer Register\n0. Reset, 19.SPTR[21:16] = 0. Reset, 18.SPTR[21:16] = 0. Reset, 17.SPTR[21:16] = 0. Reset, 16.SPTR[21:16] = 0",
    "Bits 21:0 - SPTR[21:0] Current Source Address Pointer\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnSPTRU: Accesses the upper most byte [23:16].\n2. DMAnSPTRH: Accesses the high byte [15:8].\n3. DMAnSPTRL: Access the low byte [7:0].",
    "16.13.9  DMAnDSA\nName: Address:\nDMAnDSA 0x0F0",
    "DMA Destination Start Address Register\nAccess, 15.DSA[15:8] = R/W. Access, 14.DSA[15:8] = R/W. Access, 13.DSA[15:8] = R/W. Access, 12.DSA[15:8] = R/W. Access, 11.DSA[15:8] = R/W. Access, 10.DSA[15:8] = R/W. Access, 9.DSA[15:8] = R/W. Access, 8.DSA[15:8] = R/W. Reset, 15.DSA[15:8] = 0. Reset, 14.DSA[15:8] = 0. Reset, 13.DSA[15:8] = 0. Reset, 12.DSA[15:8] = 0. Reset, 11.DSA[15:8] = 0. Reset, 10.DSA[15:8] = 0. Reset, 9.DSA[15:8] = 0. Reset, 8.DSA[15:8] = 0. Bit,",
    "DMA Destination Start Address Register\n15.DSA[15:8] = 7. Bit, 14.DSA[15:8] = 6. Bit, 13.DSA[15:8] = 5. Bit, 12.DSA[15:8] = 4. Bit, 11.DSA[15:8] = 3. Bit, 10.DSA[15:8] = 2. Bit, 9.DSA[15:8] = 1. Bit, 8.DSA[15:8] = 0. , 15.DSA[15:8] = DSA[7:0]. , 14.DSA[15:8] = DSA[7:0]. , 13.DSA[15:8] = DSA[7:0]. , 12.DSA[15:8] = DSA[7:0]. , 11.DSA[15:8] = DSA[7:0]. , 10.DSA[15:8] = DSA[7:0]. , 9.DSA[15:8] = DSA[7:0]. ,",
    "DMA Destination Start Address Register\n8.DSA[15:8] = DSA[7:0]. Access, 15.DSA[15:8] = R/W. Access, 14.DSA[15:8] = R/W. Access, 13.DSA[15:8] = R/W. Access, 12.DSA[15:8] = R/W. Access, 11.DSA[15:8] = R/W. Access, 10.DSA[15:8] = R/W. Access, 9.DSA[15:8] = R/W. Access, 8.DSA[15:8] = R/W. Reset, 15.DSA[15:8] = 0. Reset, 14.DSA[15:8] = 0. Reset, 13.DSA[15:8] = 0. Reset, 12.DSA[15:8] = 0. Reset, 11.DSA[15:8] = 0. Reset, 10.DSA[15:8] = 0. Reset, 9.DSA[15:8] = 0. Reset,",
    "DMA Destination Start Address Register\n8.DSA[15:8] = 0",
    "Bits 15:0 - DSA[15:0] Destination Start Address\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnDSAH: Accesses the high byte [15:8].\n2. DMAnDSAL: Access the low byte [7:0].",
    "16.13.10 DMAnDSZ\nName: Address:\nDMAnDSZ 0x0EE\nDMA Destination Size Register",
    "16.13.10 DMAnDSZ\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11.DSZ[11:8] = R/W. Access, 10.DSZ[11:8] = R/W. Access, 9.DSZ[11:8] = R/W. Access, 8.DSZ[11:8] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11.DSZ[11:8] = 0. Reset, 10.DSZ[11:8] = 0. Reset, 9.DSZ[11:8] = 0. Reset, 8.DSZ[11:8] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11.DSZ[11:8] = 3. Bit, 10.DSZ[11:8] = 2. Bit, 9.DSZ[11:8] = 1. Bit,",
    "16.13.10 DMAnDSZ\n8.DSZ[11:8] = 0. , 15. = DSZ[7:0]. , 14. = DSZ[7:0]. , 13. = DSZ[7:0]. , 12. = DSZ[7:0]. , 11.DSZ[11:8] = DSZ[7:0]. , 10.DSZ[11:8] = DSZ[7:0]. , 9.DSZ[11:8] = DSZ[7:0]. , 8.DSZ[11:8] = DSZ[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11.DSZ[11:8] = R/W. Access, 10.DSZ[11:8] = R/W. Access, 9.DSZ[11:8] = R/W. Access, 8.DSZ[11:8] = R/W. Reset, 15. = 0. Reset, 14.",
    "16.13.10 DMAnDSZ\n= 0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11.DSZ[11:8] = 0. Reset, 10.DSZ[11:8] = 0. Reset, 9.DSZ[11:8] = 0. Reset, 8.DSZ[11:8] = 0",
    "Bits 11:0 - DSZ[11:0] Destination Message Size\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnDSZH: Accesses the high byte [15:8].\n2. DMAnDSZL: Access the low byte [7:0].",
    "16.13.11 DMAnDCNT\nName: Address:\nDMAnDCNT 0x0EA\nDMA Destination Count Register",
    "16.13.11 DMAnDCNT\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11.DCNT[11:8] = R/W. Access, 10.DCNT[11:8] = R/W. Access, 9.DCNT[11:8] = R/W. Access, 8.DCNT[11:8] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11.DCNT[11:8] = 0. Reset, 10.DCNT[11:8] = 0. Reset, 9.DCNT[11:8] = 0. Reset, 8.DCNT[11:8] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11.DCNT[11:8] = 3. Bit, 10.DCNT[11:8] = 2. Bit, 9.DCNT[11:8] = 1. Bit,",
    "16.13.11 DMAnDCNT\n8.DCNT[11:8] = 0. , 15. = DCNT[7:0]. , 14. = DCNT[7:0]. , 13. = DCNT[7:0]. , 12. = DCNT[7:0]. , 11.DCNT[11:8] = DCNT[7:0]. , 10.DCNT[11:8] = DCNT[7:0]. , 9.DCNT[11:8] = DCNT[7:0]. , 8.DCNT[11:8] = DCNT[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11.DCNT[11:8] = R/W. Access, 10.DCNT[11:8] = R/W. Access, 9.DCNT[11:8] = R/W. Access, 8.DCNT[11:8] = R/W. Reset, 15. = 0. Reset, 14.",
    "16.13.11 DMAnDCNT\n= 0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11.DCNT[11:8] = 0. Reset, 10.DCNT[11:8] = 0. Reset, 9.DCNT[11:8] = 0. Reset, 8.DCNT[11:8] = 0",
    "Bits 11:0 - DCNT[11:0] Current Destination Byte Count\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnDCNTH: Accesses the high byte [15:8].\n2. DMAnDCNTL: Access the low byte Destination Message Size bits [7:0].",
    "16.13.12 DMAnDPTR\nName: Address:\nDMAnDPTR 0x0EC",
    "DMA Destination Pointer Register\nAccess, 15.DPTR[15:8] = R. Access, 14.DPTR[15:8] = R. Access, 13.DPTR[15:8] = R. Access, 12.DPTR[15:8] = R. Access, 11.DPTR[15:8] = R. Access, 10.DPTR[15:8] = R. Access, 9.DPTR[15:8] = R. Access, 8.DPTR[15:8] = R. Reset, 15.DPTR[15:8] = 0. Reset, 14.DPTR[15:8] = 0. Reset, 13.DPTR[15:8] = 0. Reset, 12.DPTR[15:8] = 0. Reset, 11.DPTR[15:8] = 0. Reset, 10.DPTR[15:8] = 0. Reset, 9.DPTR[15:8] = 0. Reset, 8.DPTR[15:8] = 0. Bit,",
    "DMA Destination Pointer Register\n15.DPTR[15:8] = 7. Bit, 14.DPTR[15:8] = 6. Bit, 13.DPTR[15:8] = 5. Bit, 12.DPTR[15:8] = 4. Bit, 11.DPTR[15:8] = 3. Bit, 10.DPTR[15:8] = 2. Bit, 9.DPTR[15:8] = 1. Bit, 8.DPTR[15:8] = 0. , 15.DPTR[15:8] = DPTR[7:0]. , 14.DPTR[15:8] = DPTR[7:0]. , 13.DPTR[15:8] = DPTR[7:0]. , 12.DPTR[15:8] = DPTR[7:0]. , 11.DPTR[15:8] = DPTR[7:0]. , 10.DPTR[15:8] = DPTR[7:0]. ,",
    "DMA Destination Pointer Register\n9.DPTR[15:8] = DPTR[7:0]. , 8.DPTR[15:8] = DPTR[7:0]. Access, 15.DPTR[15:8] = R. Access, 14.DPTR[15:8] = R. Access, 13.DPTR[15:8] = R. Access, 12.DPTR[15:8] = R. Access, 11.DPTR[15:8] = R. Access, 10.DPTR[15:8] = R. Access, 9.DPTR[15:8] = R. Access, 8.DPTR[15:8] = R. Reset, 15.DPTR[15:8] = 0. Reset, 14.DPTR[15:8] = 0. Reset, 13.DPTR[15:8] = 0. Reset, 12.DPTR[15:8] = 0. Reset, 11.DPTR[15:8] = 0. Reset, 10.DPTR[15:8] = 0.",
    "DMA Destination Pointer Register\nReset, 9.DPTR[15:8] = 0. Reset, 8.DPTR[15:8] = 0\nBits 15:0 - DPTR[15:0] Current Destination Address Pointer\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnDPTRH: Accesses the high byte [15:8].\n2. DMAnDPTRL: Access the low byte [7:0].",
    "16.13.13 DMAnSIRQ\nName: Address:\nDMAnSIRQ 0x0FF\nDMA Start Interrupt Request Source Selection Register",
    "16.13.13 DMAnSIRQ\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SIRQ[7:0]. , 2 = SIRQ[7:0]. , 3 = SIRQ[7:0]. , 4 = SIRQ[7:0]. , 5 = SIRQ[7:0]. , 6 = SIRQ[7:0]. , 7 = SIRQ[7:0]. , 8 = SIRQ[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n\nTable 16-6. DMAxSIRQ and DMAxAIRQ Interrupt Sources",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x0, Interrupt source = -. 0x0, Vector Number (cont.) = 0x30. 0x0, Interrupt source (cont.) = INT1. 0x1, Interrupt source = HLVD (High/Low-Voltage Detect). 0x1, Vector Number (cont.) = 0x31. 0x1, Interrupt source (cont.) = -. 0x2, Interrupt source = OSF (Oscillator Fail). 0x2, Vector Number (cont.) = 0x32 CWG1 (Complementary Waveform. 0x2, Interrupt source (cont.) = Generator). 0x3, Interrupt source = CSW (Clock Switching). 0x3, Vector Number (cont.) = 0x33. 0x3, Interrupt source (cont.) = NCO1 (Numerically Controlled Oscillator). 0x4, Interrupt source = NVM. 0x4, Vector Number (cont.) = 0x34. 0x4, Interrupt source (cont.)",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n= DMA2SCNT. 0x5, Interrupt source = CLC1 (Configurable Logic Cell). 0x5, Vector Number (cont.) = 0x35. 0x5, Interrupt source (cont.) = DMA2DCNT. 0x6, Interrupt source = CRC (Cyclic Redundancy Check). 0x6, Vector Number (cont.) = 0x36. 0x6, Interrupt source (cont.) = DMA2OR. 0x7, Interrupt source = IOC (Interrupt-On-Change). 0x7, Vector Number (cont.) = 0x37. 0x7, Interrupt source (cont.) = DMA2A. 0x8, Interrupt source = INT0. 0x8, Vector Number (cont.) = 0x38. 0x8, Interrupt source (cont.) = I2C1RX. 0x9, Interrupt source = ZCD (Zero-Cross Detection). 0x9, Vector Number (cont.) = 0x39.",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x9, Interrupt source (cont.) = I2C1TX. 0xA, Interrupt source = AD (ADC Conversion Complete). 0xA, Vector Number (cont.) = 0x3A. 0xA, Interrupt source (cont.) = I2C1. 0xB, Interrupt source = ACT (Active Clock Tuning). 0xB, Vector Number (cont.) = 0x3B. 0xB, Interrupt source (cont.) = I2C1E. 0xC, Interrupt source = CM1 (Comparator). 0xC, Vector Number (cont.) = 0x3C. 0xC, Interrupt source (cont.) = -. 0xD, Interrupt source = SMT1 (Signal Measurement Timer). 0xD, Vector Number (cont.) = 0x3D. 0xD, Interrupt source (cont.) = CLC3. 0xE, Interrupt source = -. 0xE, Vector Number (cont.) = 0x3E.",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0xE, Interrupt source (cont.) = PWM3RINT. 0xF, Interrupt source = SMT1PWA. 0xF, Vector Number (cont.) = 0x3F. 0xF, Interrupt source (cont.) = PWM3GINT. 0x10, Interrupt source = ADT. 0x10, Vector Number (cont.) = 0x40. 0x10, Interrupt source (cont.) = U2RX. 0x11 - 0x13, Interrupt source = -. 0x11 - 0x13, Vector Number (cont.) = 0x41. 0x11 - 0x13, Interrupt source (cont.) = U2TX. 0x14, Interrupt source = DMA1SCNT (Direct Memory Access). 0x14, Vector Number (cont.) = 0x42. 0x14, Interrupt source (cont.) = U2E. 0x15, Interrupt source = DMA1DCNT. 0x15, Vector Number (cont.) =",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x43. 0x15, Interrupt source (cont.) = U2. 0x16, Interrupt source = DMA1OR. 0x16, Vector Number (cont.) = 0x44. 0x16, Interrupt source (cont.) = -. 0x17, Interrupt source = DMA1A. 0x17, Vector Number (cont.) = 0x45. 0x17, Interrupt source (cont.) = CLC4. 0x18, Interrupt source = SPI1RX (Serial Peripheral Interface). 0x18, Vector Number (cont.) = 0x46. 0x18, Interrupt source (cont.) = -. 0x19, Interrupt source = SPI1TX. 0x19, Vector Number (cont.) = 0x47. 0x19, Interrupt source (cont.) = SCAN. 0x1A, Interrupt source = SPI1. 0x1A, Vector Number (cont.) = 0x48. 0x1A, Interrupt source (cont.) =",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\nU3RX. 0x1B, Interrupt source = TMR2. 0x1B, Vector Number (cont.) = 0x49. 0x1B, Interrupt source (cont.) = U3TX. 0x1C, Interrupt source = TMR1. 0x1C, Vector Number (cont.) = 0x4A. 0x1C, Interrupt source (cont.) = U3E. 0x1D, Interrupt source = TMR1G. 0x1D, Vector Number (cont.) = 0x4B. 0x1D, Interrupt source (cont.) = U3. 0x1E, Interrupt source = CCP1 (Capture/Compare/PWM). 0x1E, Vector Number (cont.) = 0x4C. 0x1E, Interrupt source (cont.) = DMA3SCNT. 0x1F, Interrupt source = TMR0. 0x1F, Vector Number (cont.) =",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x4D. 0x1F, Interrupt source (cont.) = DMA3DCNT. 0x20, Interrupt source = U1RX. 0x20, Vector Number (cont.) = 0x4E. 0x20, Interrupt source (cont.) = DMA3OR. 0x21, Interrupt source = U1TX. 0x21, Vector Number (cont.) = 0x4F. 0x21, Interrupt source (cont.) = DMA3A. 0x22, Interrupt source = U1E. 0x22, Vector Number (cont.) = 0x50. 0x22, Interrupt source (cont.) = INT2. 0x23, Interrupt source = U1. 0x23, Vector Number (cont.) = 0x51. 0x23, Interrupt source (cont.) = -. 0x24, Interrupt source = TMR3. 0x24, Vector Number (cont.) = 0x52. 0x24, Interrupt source (cont.)",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n= -. 0x25, Interrupt source = TMR3G. 0x25, Vector Number (cont.) = 0x53. 0x25, Interrupt source (cont.) = TMR4. 0x26, Interrupt source = PWM1RINT. 0x26, Vector Number (cont.) = 0x54. 0x26, Interrupt source (cont.) = DMA4SCNT. 0x27, Interrupt source = PWM1GINT. 0x27, Vector Number (cont.) = 0x55. 0x27, Interrupt source (cont.) = DMA4DCNT",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x28, ...........continued.Interrupt source = SPI2RX. 0x28, ...........continued.Vector Number (cont.) = 0x56. 0x28, ...........continued.Interrupt source (cont.) = DMA4OR. 0x29, ...........continued.Interrupt source = SPI2TX. 0x29, ...........continued.Vector Number (cont.) = 0x57. 0x29, ...........continued.Interrupt source (cont.) = DMA4A. 0x2A, ...........continued.Interrupt source = SPI2. 0x2A, ...........continued.Vector Number (cont.) = 0x58. 0x2A,",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n...........continued.Interrupt source (cont.) = PWM1.S1P1 (PWM1 Parameter 1 of Slice 1). 0x2B, ...........continued.Interrupt source = -. 0x2B, ...........continued.Vector Number (cont.) = 0x59. 0x2B, ...........continued.Interrupt source (cont.) = PWM1.S1P2 (PWM1 Parameter 2 of Slice 1). 0x2C, ...........continued.Interrupt source = CM2 (Comparator). 0x2C, ...........continued.Vector Number (cont.) = 0x5A. 0x2C, ...........continued.Interrupt source (cont.) = PWM2S1P1.",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x2D, ...........continued.Interrupt source = CLC2. 0x2D, ...........continued.Vector Number (cont.) = 0x5B. 0x2D, ...........continued.Interrupt source (cont.) = PWM2S1P2. 0x2E, ...........continued.Interrupt source = PWM2RINT. 0x2E, ...........continued.Vector Number (cont.) = 0x5C. 0x2E, ...........continued.Interrupt source (cont.) = PWM3S1P1. 0x2F, ...........continued.Interrupt source = PWM2GINT. 0x2F, ...........continued.Vector Number",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n(cont.) = 0x5D. 0x2F, ...........continued.Interrupt source (cont.) = PWM3S1P2",
    "16.13.14 DMAnAIRQ\nName:\nDMAnAIRQ\nAddress:\n0x0FE\nDMA Abort Interrupt Request Source Selection Register",
    "16.13.14 DMAnAIRQ\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = AIRQ[7:0]. , 2 = AIRQ[7:0]. , 3 = AIRQ[7:0]. , 4 = AIRQ[7:0]. , 5 = AIRQ[7:0]. , 6 = AIRQ[7:0]. , 7 = AIRQ[7:0]. , 8 = AIRQ[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "16.13.14 DMAnAIRQ\nBits 7:0 - AIRQ[7:0] DMA Abort Interrupt Request Source Selection Refer to the DMA Interrupt Sources table.",
    "16.14 Register Summary - DMA\n0x00 ... 0xE7, Name = Reserved. 0x00 ... 0xE7, Bit Pos. = . 0x00 ... 0xE7, 7 = . 0x00 ... 0xE7, 6 = . 0x00 ... 0xE7, 5 = . 0x00 ... 0xE7, 4 = . 0x00 ... 0xE7, 2 = . 0x00 ... 0xE7, 1 = . 0x00 ... 0xE7, 0 = . 0xE8, Name = DMASELECT. 0xE8, Bit Pos. = 7:0. 0xE8, 7 = . 0xE8, 6 = . 0xE8, 5 = . 0xE8, 4 = . 0xE8, 2 = SLCT[2:0]. 0xE8, 1 = SLCT[2:0]. 0xE8, 0 = SLCT[2:0]. 0xE9, Name = DMAnBUF.",
    "16.14 Register Summary - DMA\n0xE9, Bit Pos. = 7:0. 0xE9, 7 = . 0xE9, 6 = . 0xE9, 5 = . 0xE9, 4 = BUF[7:0]. 0xE9, 2 = . 0xE9, 1 = . 0xE9, 0 = . 0xEA, Name = DMAnDCNT. 0xEA, Bit Pos. = 7:0. 0xEA, 7 = . 0xEA, 6 = . 0xEA, 5 = . 0xEA, 4 = DCNT[7:0]. 0xEA, 2 = . 0xEA, 1 = . 0xEA, 0 = . 0xEA, Name = DMAnDCNT. 0xEA, Bit Pos. = 15:8. 0xEA, 7 = . 0xEA, 6 = . 0xEA, 5 = . 0xEA, 4 = . 0xEA, 2 = DCNT[11:8]. 0xEA, 1 = DCNT[11:8]. 0xEA, 0 =",
    "16.14 Register Summary - DMA\nDCNT[11:8]. 0xEC, Name = DMAnDPTR. 0xEC, Bit Pos. = 7:0. 0xEC, 7 = . 0xEC, 6 = . 0xEC, 5 = . 0xEC, 4 = DPTR[7:0]. 0xEC, 2 = . 0xEC, 1 = . 0xEC, 0 = . 0xEC, Name = DMAnDPTR. 0xEC, Bit Pos. = 15:8. 0xEC, 7 = . 0xEC, 6 = . 0xEC, 5 = . 0xEC, 4 = DPTR[15:8]. 0xEC, 2 = . 0xEC, 1 = . 0xEC, 0 = . 0xEE, Name = DMAnDSZ. 0xEE, Bit Pos. = 7:0. 0xEE, 7 = . 0xEE, 6 = . 0xEE, 5 = . 0xEE, 4 = DSZ[7:0]. 0xEE, 2 = . 0xEE, 1 = . 0xEE, 0",
    "16.14 Register Summary - DMA\n= . 0xEE, Name = DMAnDSZ. 0xEE, Bit Pos. = 15:8. 0xEE, 7 = . 0xEE, 6 = . 0xEE, 5 = . 0xEE, 4 = . 0xEE, 2 = DSZ[11:8]. 0xEE, 1 = DSZ[11:8]. 0xEE, 0 = DSZ[11:8]. 0xF0, Name = DMAnDSA. 0xF0, Bit Pos. = 7:0. 0xF0, 7 = . 0xF0, 6 = . 0xF0, 5 = . 0xF0, 4 = DSA[7:0]. 0xF0, 2 = . 0xF0, 1 = . 0xF0, 0 = . 0xF0, Name = DMAnDSA. 0xF0, Bit Pos. = 15:8. 0xF0, 7 = . 0xF0, 6 = . 0xF0, 5 = . 0xF0, 4 =",
    "16.14 Register Summary - DMA\nDSA[15:8]. 0xF0, 2 = . 0xF0, 1 = . 0xF0, 0 = . 0xF2, Name = DMAnSCNT. 0xF2, Bit Pos. = 7:0. 0xF2, 7 = . 0xF2, 6 = . 0xF2, 5 = . 0xF2, 4 = SCNT[7:0]. 0xF2, 2 = . 0xF2, 1 = . 0xF2, 0 = . 0xF2, Name = DMAnSCNT. 0xF2, Bit Pos. = 15:8. 0xF2, 7 = . 0xF2, 6 = . 0xF2, 5 = . 0xF2, 4 = . 0xF2, 2 = SCNT[11:8]. 0xF2, 1 = SCNT[11:8]. 0xF2, 0 = SCNT[11:8]. 0xF4, Name = DMAnSPTR. 0xF4, Bit Pos. =",
    "16.14 Register Summary - DMA\n7:0. 0xF4, 7 = . 0xF4, 6 = . 0xF4, 5 = . 0xF4, 4 = SPTR[7:0]. 0xF4, 2 = . 0xF4, 1 = . 0xF4, 0 = . 0xF4, Name = DMAnSPTR. 0xF4, Bit Pos. = 15:8. 0xF4, 7 = . 0xF4, 6 = . 0xF4, 5 = . 0xF4, 4 = SPTR[15:8]. 0xF4, 2 = . 0xF4, 1 = . 0xF4, 0 = . 0xF4, Name = DMAnSPTR. 0xF4, Bit Pos. = 23:16. 0xF4, 7 = . 0xF4, 6 = . 0xF4, 5 = . 0xF4, 4 = SPTR[21:16]. 0xF4, 2 = SPTR[21:16]. 0xF4, 1 =",
    "16.14 Register Summary - DMA\nSPTR[21:16]. 0xF4, 0 = SPTR[21:16]. 0xF7, Name = DMAnSSZ. 0xF7, Bit Pos. = 7:0. 0xF7, 7 = . 0xF7, 6 = . 0xF7, 5 = . 0xF7, 4 = SSZ[7:0]. 0xF7, 2 = . 0xF7, 1 = . 0xF7, 0 = . 0xF7, Name = DMAnSSZ. 0xF7, Bit Pos. = 15:8. 0xF7, 7 = . 0xF7, 6 = . 0xF7, 5 = . 0xF7, 4 = . 0xF7, 2 = SSZ[11:8]. 0xF7, 1 = SSZ[11:8]. 0xF7, 0 = SSZ[11:8]. 0xF9, Name = DMAnSSA. 0xF9, Bit Pos. = 7:0. 0xF9, 7 = .",
    "16.14 Register Summary - DMA\n0xF9, 6 = . 0xF9, 5 = . 0xF9, 4 = SSA[7:0]. 0xF9, 2 = . 0xF9, 1 = . 0xF9, 0 = . 0xF9, Name = DMAnSSA. 0xF9, Bit Pos. = 15:8. 0xF9, 7 = . 0xF9, 6 = . 0xF9, 5 = . 0xF9, 4 = SSA[15:8]. 0xF9, 2 = . 0xF9, 1 = . 0xF9, 0 = . 0xF9, Name = DMAnSSA. 0xF9, Bit Pos. = 23:16. 0xF9, 7 = . 0xF9, 6 = . 0xF9, 5 = . 0xF9, 4 = SSA[21:16]. 0xF9, 2 = SSA[21:16]. 0xF9, 1 = SSA[21:16]. 0xF9, 0 =",
    "16.14 Register Summary - DMA\nSSA[21:16]. 0xFC, Name = DMAnCON0. 0xFC, Bit Pos. = 7:0. 0xFC, 7 = EN. 0xFC, 6 = SIRQEN. 0xFC, 5 = DGO. 0xFC, 4 = AIRQEN. 0xFC, 2 = AIRQEN. 0xFC, 1 = AIRQEN. 0xFC, 0 = XIP. 0xFD, Name = DMAnCON1. 0xFD, Bit Pos. = 7:0. 0xFD, 7 = DMODE[1:0]. 0xFD, 6 = . 0xFD, 5 = DSTP. 0xFD, 4 = SMR[1:0]. 0xFD, 2 = SMODE[1:0]. 0xFD, 1 = . 0xFD, 0 = SSTP. 0xFE, Name = DMAnAIRQ. 0xFE, Bit Pos. = 7:0. 0xFE, 7 = . 0xFE, 6 = . 0xFE,",
    "16.14 Register Summary - DMA\n5 = . 0xFE, 4 = AIRQ[7:0]. 0xFE, 2 = . 0xFE, 1 = . 0xFE, 0 = . 0xFF, Name = DMAnSIRQ. 0xFF, Bit Pos. = 7:0. 0xFF, 7 = . 0xFF, 6 = . 0xFF, 5 = . 0xFF, 4 = SIRQ[7:0]. 0xFF, 2 = . 0xFF, 1 = . 0xFF, 0 = ",
    "17. Power-Saving Modes\nThe purpose of the Power-Saving modes is to reduce power consumption. There are three PowerSaving modes:\n\u00b7 Doze mode\n\u00b7 Sleep mode\n\u00b7 Idle mode",
    "17.1 Doze Mode\nDoze mode allows for power saving by reducing CPU operation and Program Flash Memory (PFM) access, without affecting peripheral operation. Doze mode differs from Sleep mode because the band gap and system oscillators continue to operate, while only the CPU and PFM are affected. The reduced execution saves power by eliminating unnecessary operations within the CPU and memory.\nWhen the Doze Enable bit is set (DOZEN = 'b1 ) the CPU executes only one instruction cycle out of every N cycles as defined by the DOZE bits. For example, if DOZE = 001 , the instruction cycle ratio is 1:4. The CPU and memory execute for one instruction cycle and then lay Idle for three instruction cycles. During the unused cycles, the peripherals continue to operate at the system clock speed.",
    "17.1.1 Doze Operation\nThe Doze operation is illustrated in Figure 17-1. As with normal operation, the instruction is fetched for the next instruction cycle while the previous instruction is executed. The Q-clocks to the peripherals continue throughout the periods in which no instructions are fetched or executed. The following configuration settings apply for this example:\n\u00b7 Doze enabled (DOZEN = 1 )\n\u00b7 CPU instruction cycle to peripheral instruction cycle ratio of 1:4\n\u00b7 Recover-on-Interrupt enabled (ROI = 1 )",
    "Notes:\n1. Multicycle instructions are executed to completion before fetching 0x0004 .\n2. If the prefetched instruction clears GIE, the ISR will not occur, but DOZEN is still cleared, and the CPU will resume execution at full speed.",
    "17.1.2 Interrupts During Doze\nSystem behavior for interrupts that may occur during Doze mode are configured using the ROI and DOE bits. Refer to the example below for details about system behavior in all cases for a transition from Main to ISR back to Main.\n```\nExample 17-1. Doze Software Example // Mainline operation bool somethingToDo = FALSE; void main () { initializeSystem(); // DOZE = 64:1 (for example) // ROI = 1; GIE = 1; // enable interrupts while (1) { // If ADC completed, process data if (somethingToDo) { doSomething(); DOZEN = 1; // resume low-power } } } // Data interrupt handler void interrupt () { // DOZEN = 0 because ROI = 1 if (ADIF) { somethingToDo = TRUE; DOE = 0; // make main() go fast ADIF = 0;\n```",
    "17.2 Sleep Mode\nSleep mode provides the greatest power savings because both the CPU and selected peripherals cease to operate. However, some peripheral clocks continue to operate during Sleep. The peripherals that use those clocks also continue to operate. Sleep mode is entered by executing the SLEEP instruction, while the IDLEN bit is clear. Upon entering Sleep mode, the following conditions exist:\n1. The WDT will be cleared but keeps running if enabled for operation during Sleep.\n2. The PD bit of the STATUS register is cleared.\n3. The TO bit of the STATUS register is set.\n4. The CPU clock is disabled.\n5. LFINTOSC, HFINTOSC and ADCRC are unaffected. Peripherals using them may continue operation during Sleep.\n6. I/O ports maintain the status they had before Sleep was executed (driving high, low, or highimpedance).\n7. Resets other than WDT are not affected by Sleep mode.\nImportant: Refer to individual chapters for more details on peripheral operation during Sleep.\nTo minimize current consumption, consider the following conditions:",
    "17.2 Sleep Mode\n\u00b7 I/O pins must not be floating\n\u00b7 External circuitry sinking current from I/O pins\n\u00b7 Internal circuitry sourcing current to I/O pins\n\u00b7 Current draw from pins with internal weak pull-ups\n\u00b7 Peripherals using clock source unaffected by Sleep\nI/O pins that are high-impedance inputs need to be pulled to VDD or VSS externally to avoid switching currents caused by floating inputs. Examples of internal circuitry that might be consuming current include modules such as the DAC and FVR peripherals.",
    "17.2.1 Wake-Up from Sleep\nThe device can wake up from Sleep through one of the following events:\n1. External Reset input on MCLR pin, if enabled.\n2. BOR Reset, if enabled.\n3. Low-Power Brown-out Reset (LPBOR), if enabled.\n4. POR Reset.\n5. Windowed Watchdog Timer, if enabled.\n- 6. All interrupt sources except clock switch interrupt can wake up the part.\nImportant: The first five events will cause a device Reset. The last event in the list is considered a continuation of program execution. For more information about determining whether a device Reset or wake-up event occurred, refer to the 'Resets' chapter.",
    "17.2.1 Wake-Up from Sleep\nWhen the SLEEP instruction is being executed, the next instruction (PC + 2) is prefetched. For the device to wake up through an interrupt event, the corresponding Interrupt Enable bit must be enabled in the PIEx register. Wake-up will occur regardless of the state of the Global Interrupt Enable (GIE) bit. If the GIE bit is disabled, the device will continue execution at the instruction after the SLEEP instruction. If the GIE bit is enabled, the device executes the instruction after the SLEEP instruction and then call the Interrupt Service Routine (ISR).\nImportant: It is recommended to add a NOP as the immediate instruction after the SLEEP instruction.\nThe WDT is cleared when the device wakes up from Sleep, regardless of the source of wake-up. Upon a wake-from-Sleep event, the core will wait for a combination of three conditions before beginning execution. The conditions are:\n\u00b7 PFM Ready\n\u00b7 System Clock Ready\n\u00b7 BOR Ready (unless BOR is disabled)",
    "17.2.2 Wake-Up Using Interrupts\nWhen global interrupts are disabled (GIE cleared) and any interrupt source, with the exception of the clock switch interrupt, has both its interrupt enable bit and interrupt flag bit set, one of the following will occur:\n\u00b7 If the interrupt occurs before the execution of a SLEEP instruction:\n-The SLEEP instruction will execute as a NOP\n-WDT and WDT prescaler will not be cleared\n-The TO bit of the STATUS register will not be set\n-The PD bit of the STATUS register will not be cleared\n\u00b7 If the interrupt occurs during or after the execution of a SLEEP instruction:\n-The SLEEP instruction will be completely executed\n-Device will immediately wake up from Sleep\n-WDT and WDT prescaler will be cleared\n-The TO bit of the STATUS register will be set\n-The PD bit of the STATUS register will be cleared\nIn the event where flag bits were checked before executing a SLEEP instruction, it may be possible for flag bits to become set before the SLEEP instruction completes. To determine whether a SLEEP instruction executed, test the PD bit. If the PD bit is set, the SLEEP instruction was executed as a NOP .",
    "Figure 17-2. Wake-Up from Sleep through Interrupt\n\u4c4b\n\u4f55\n\u6e74\n\u7272\n\u7570\n\u6c61\n\u6e73\n\u7275\n\u696f\n\u6e20\n\u7275\n\u6e73\n\u696f\n\u6e20\n\u4320",
    "Notes:\n1. External clock - High, Medium, Low mode assumed.\n2. CLKOUT is shown here for timing reference.\n3. TOST = 1024 TOSC. This delay does not apply to EC and INTOSC Oscillator modes.\n4. GIE = 1 assumed. In this case after wake-up, the processor calls the ISR at 0x0004 . If GIE = 0 , execution will continue in-line.",
    "17.2.3 Low-Power Sleep Mode\nThis device family contains an internal Low Dropout (LDO) voltage regulator, which allows the device I/O pins to operate at voltages up to V DD while the internal device logic operates at a lower voltage. The LDO and its associated reference circuitry must remain active in Sleep but can operate in different Power modes. This allows the user to optimize the operating current in Sleep mode, depending on the application requirements.",
    "17.2.3.1 Sleep Current vs. Wake-Up Time\nThe Low-Power Sleep mode can be selected by setting the VREGPM bits as following:\n\u00b7 VREGPM = 'b00 ; the voltage regulator is in High-Power mode. In this mode, the voltage regulator and reference circuitry remain in the normal configuration while in Sleep. Hence, there is no delay needed for these circuits to stabilize after wake-up (fastest wake-up from Sleep).\n\u00b7 VREGPM = 'b01 ; the voltage regulator is in Low-Power mode. In this mode, when waking up from Sleep, an extra delay time is required for the voltage regulator and reference circuitry to return to the normal configuration and stabilize (faster wake-up from Sleep).\n\u00b7 VREGPM = 'b10 ; the voltage regulator is in Ultra Low-Power mode. In this mode, the voltage regulator and reference circuitry are in the lowest current consumption mode and all the auxiliary circuits remain shut down. Wake-up from Sleep in this mode needs the longest delay time for the voltage regulator and reference circuitry to stabilize (lowest current consumption).",
    "17.2.3.1 Sleep Current vs. Wake-Up Time\n\u00b7 VREGPM = 'b11 ; this mode is similar to the Ultra Low-Power mode (VREGPM = 'b10 ) and is recommended ONLY for extended temperature ranges at or above 70 \u2103 .",
    "17.2.3.2 Peripheral Usage in Sleep\nSome peripherals that can operate in High-Power Sleep mode (VREGPM = 'b00 ) will not operate as intended in the Low-Power Sleep modes (VREGPM = 'b01 and 'b11 ). The Low-Power Sleep modes are intended for use with the following peripherals:\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Windowed Watchdog Timer (WWDT)\n\u00b7 External interrupt pin/interrupt-on-change pins\n\u7275\n\u6e73\n\u6c6f\n\u6e20\n\u696f\n\u476c\n\u6261\n\u6c20\n\u6e74\n\u6572\n\u7275\n\u7074\n\u456e\n\u626c\n\u5043\n\u5043\n\u5043\n\u2920\n\u6c65\n\u2b20\n\u2b20\n\u6365\n\u7373\n\u2b20\n\u6379\n\u4320\n\u2b20\n\u2b20\n\u2b20\n\u2b20\n\u6e73\n\u6e73\n\u6e73\nIt is the responsibility of the end user to determine what is acceptable for their application when setting the VREGPM settings to ensure correct operation in Sleep.",
    "17.3 Idle Mode\nWhen the IDLEN bit is clear, the SLEEP instruction will put the device into full Sleep mode. When IDLEN is set, the SLEEP instruction will put the device into Idle mode. In Idle mode, the CPU and memory operations are halted, but the peripheral clocks continue to run. This mode is similar to Doze mode, except that in Idle both the CPU and program memory are shut off.",
    "Important:\n1. Peripherals using F OSC will continue to operate while in Idle (but not in Sleep). Peripherals using HFINTOSC:LFINTOSC will continue running in both Idle and Sleep.\n2. When the Clock Out Enable (CLKOUTEN) Configuration bit is cleared, the CLKOUT pin will continue operating while in Idle.",
    "17.3.1 Idle and Interrupts\nIdle mode ends when an interrupt occurs (even if global interrupts are disabled), but IDLEN is not changed. The device can re-enter Idle by executing the SLEEP instruction. If Recover-on-Interrupt is enabled (ROI = 1 ), the interrupt that brings the device out of Idle also restores full-speed CPU execution when Doze is also enabled.",
    "17.3.2 Idle and WWDT\nWhen in Idle, the WWDT Reset is blocked and will instead wake the device. The WWDT wake-up is not an interrupt, therefore ROI does not apply.\nImportant: The WWDT can bring the device out of Idle, in the same way it brings the device out of Sleep. The DOZEN bit is not affected.",
    "17.4 Peripheral Operation in Power-Saving Modes\nAll selected clock sources and the peripherals running from them are active in both Idle and Doze modes. Only in Sleep mode, both the FOSC and FOSC/4 clocks are unavailable. However, all other clock sources enabled specifically or through peripheral clock selection before the part enters Sleep, remain operating in Sleep.",
    "17.5.1 CPUDOZE\nName: Address:\nCPUDOZE\n0x4F2\nDoze and Idle Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IDLEN. , 2 = DOZEN. , 3 = ROI. , 4 = DOE. , 5 = . , 6 = DOZE[2:0]. , 7 = DOZE[2:0]. , 8 = DOZE[2:0]. Access, 1 = R/W. Access, 2 = R/W/HC/HS. Access, 3 = R/W. Access, 4 = R/W/HC/HS. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - IDLEN Idle Enable\n1, Description = A SLEEP instruction places device into Idle mode. 0, Description = A SLEEP instruction places the device into Sleep mode",
    "Bit 6 - DOZEN  Doze Enable (1)\n1, Description = Places devices into Doze setting. 0, Description = Places devices into Normal mode",
    "Bit 5 - ROI  Recover-on-Interrupt (1)\n1, Description = Entering the Interrupt Service Routine (ISR) makes DOZEN = 0. 0, Description = Entering the Interrupt Service Routine (ISR) does not change DOZEN",
    "Bit 4 - DOE  Doze-on-Exit (1)\n1, Description = Exiting the ISR makes DOZEN = 1. 0, Description = Exiting the ISR does not change DOZEN",
    "Bits 2:0 - DOZE[2:0] Ratio of CPU Instruction Cycles to Peripheral Instruction Cycles\n111, Description = 1:256. 110, Description = 1:128. 101, Description = 1:64. 100, Description = 1:32. 011, Description = 1:16. 010, Description = 1:8. 001, Description = 1:4. 000, Description = 1:2",
    "Note:\n- 1. When ROI = 1 or DOE = 1 .",
    "17.5.2 VREGCON\nName:\nVREGCON\nAddress:\n0x048",
    "Voltage Regulator Control Register\nAccess, 7. = . Access, 6 5.PMSYS[1:0] = R. Access, 4.PMSYS[1:0] = R. Access, 1.VREGPM[1:0] = R/W. Access, 0.VREGPM[1:0] = R/W. Access,  = . Reset, 7. = . Reset, 6 5.PMSYS[1:0] = q. Reset, 4.PMSYS[1:0] = q. Reset, 1.VREGPM[1:0] = 1. Reset, 0.VREGPM[1:0] = 0. Reset,  = ",
    "Bits 5:4 - PMSYS[1:0] System Power Mode Status\n11, Description = Regulator in Ultra Low-Power (ULP) mode for extended temperature range is active. 10, Description = Regulator in Ultra Low-Power (ULP) mode is active. 01, Description = Regulator in Low-Power (LP) mode is active. 00, Description = Regulator in High-Power (HP) mode is active",
    "Bits 1:0 - VREGPM[1:0] Voltage Regulator Power Mode Selection\n11, Description = Regulator in Ultra Low-Power (ULP) mode. Use ONLY for extended temperature range. 10, Description = Regulator in Ultra Low-Power (ULP) mode (lowest current consumption). 01, Description = Regulator in Low-Power (LP) mode (faster wake-up from Sleep). 00, Description = Regulator in High-Power (HP) mode (fastest wake-up from Sleep)",
    "17.6 Register Summary - Power-Savings Control\n0x00 ... 0x47, Name = Reserved. 0x00 ... 0x47, Bit Pos. = . 0x00 ... 0x47, 7 = . 0x00 ... 0x47, 6 = . 0x00 ... 0x47, 5 = . 0x00 ... 0x47, 4 = . 0x00 ... 0x47, 3 = . 0x00 ... 0x47, 2 = . 0x00 ... 0x47, 1 = . 0x00 ... 0x47, 0 = . 0x48, Name = VREGCON. 0x48, Bit Pos. = 7:0. 0x48, 7 = . 0x48, 6 = . 0x48, 5 = PMSYS[1:0]. 0x48, 4 = PMSYS[1:0]. 0x48, 3 = . 0x48, 2 = . 0x48, 1 = VREGPM[1:0]. 0x48, 0 = VREGPM[1:0].",
    "17.6 Register Summary - Power-Savings Control\n0x49 ... 0x04F1, Name = Reserved. 0x49 ... 0x04F1, Bit Pos. = . 0x49 ... 0x04F1, 7 = . 0x49 ... 0x04F1, 6 = . 0x49 ... 0x04F1, 5 = . 0x49 ... 0x04F1, 4 = . 0x49 ... 0x04F1, 3 = . 0x49 ... 0x04F1, 2 = . 0x49 ... 0x04F1, 1 = . 0x49 ... 0x04F1, 0 = . 0x04F2, Name = CPUDOZE. 0x04F2, Bit Pos. = 7:0. 0x04F2, 7 = IDLEN. 0x04F2, 6 = DOZEN. 0x04F2, 5 = ROI. 0x04F2, 4 = DOE. 0x04F2, 3",
    "17.6 Register Summary - Power-Savings Control\n= . 0x04F2, 2 = . 0x04F2, 1 = DOZE[2:0]. 0x04F2, 0 = ",
    "18.1 Overview\nThis module provides the ability to selectively enable or disable a peripheral. Disabling a peripheral places it in its lowest possible Power state. The user can selectively disable unused modules to reduce the overall power consumption.\nImportant: All modules are ON by default following any system Reset.",
    "18.2 Disabling a Module\nA peripheral can be disabled by setting the corresponding peripheral disable bit in the PMDx register. Disabling a module has the following effects:\n\u00b7 The module is held in Reset and does not function\n\u00b7 All the SFRs pertaining to that peripheral become 'unimplemented'\n-Writing is disabled\n-Reading returns 0x00\n\u00b7 Module outputs are disabled",
    "18.3 Enabling a Module\nClearing the corresponding module disable bit in the PMDx register, re-enables the module and the SFRs will reflect the Power-on Reset values.\nImportant: There will be no reads/writes to the module SFRs for at least two instruction cycles after it has been re-enabled.",
    "18.4.1 PMD0\nName:\nPMD0\nAddress:\n0x063",
    "PMD Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SYSCMD. , 2 = FVRMD. , 3 = HLVDMD. , 4 = CRCMD. , 5 = SCANMD. , 6 = . , 7 = CLKRMD. , 8 = IOCMD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SYSCMD  Disable Peripheral System Clock Network (1)\n1, Description = System clock network disabled (F OSC ). 0, Description = System clock network enabled",
    "Bit 6 - FVRMD Disable Fixed Voltage Reference\nDisable Fixed Voltage Reference\n1, Description = FVR module disabled. 0, Description = FVR module enabled",
    "Bit 5 - HLVDMD Disable High/Low-Voltage Detect\n1, Description = HLVD module disabled. 0, Description = HLVD module enabled",
    "Bit 4 - CRCMD Disable CRC Module\n1, Description = CRC module disabled. 0, Description = CRC module enabled",
    "Bit 3 - SCANMD Disable NVM Memory Scanner\n1, Description = NVM memory scanner module disabled. 0, Description = NVM memory scanner module enabled",
    "Bit 1 - CLKRMD Disable Clock Reference\n1, Description = Clock reference module disabled. 0, Description = Clock reference module enabled",
    "Bit 0 - IOCMD Disable Interrupt-on-Change\n1, Description = Interrupt-on-change module is disabled. 0, Description = Interrupt-on-change module is enabled",
    "Note:\n- 1. Clearing the SYSCMD bit disables the system clock (FOSC) to peripherals, however peripherals clocked by FOSC/4 are not affected.",
    "18.4.2 PMD1\nName: Address:\nPMD1\n0x064",
    "PMD Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = C1MD. , 2 = ZCDMD. , 3 = SMT1MD. , 4 = TMR4MD. , 5 = TMR3MD. , 6 = TMR2MD. , 7 = TMR1MD. , 8 = TMR0MD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - C1MD Disable Comparator 1\n1, Description = CM1 module disabled. 0, Description = CM1 module enabled",
    "Bit 6 - ZCDMD  Disable Zero-Cross Detect (1)\n1, Description = ZCD module disabled. 0, Description = ZCD module enabled",
    "Bit 5 - SMT1MD Disable SMT1 Module\n1, Description = SMT1 module disabled. 0, Description = SMT1 module enabled",
    "Bits 0, 1, 2, 3, 4 - TMRnMD Disable Timer TMRn\n1, Description = TMRn module disabled. 0, Description = TMRn module enabled",
    "Note:\n- 1. Subject to the value of ZCD Configuration bit.",
    "18.4.3 PMD2\nName: Address:\nPMD2\n0x065",
    "PMD Control Register 2\n, 7 = CCP1MD. , 6 = CWG1MD. , 5 = DSM1MD. , 4 = NCO1MD. , 3 = ACTMD. , 2 = DAC1MD. , 1 = ADCMD. , 0 = C2MD. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - CCP1MD Disable Capture Compare 1\n1, Description = CCP1 module disabled. 0, Description = CCP1 module enabled",
    "Bit 6 - CWG1MD Disable Complementary Waveform Generator 1\n1, Description = CWG1 module disabled. 0, Description = CWG1 module enabled",
    "Bit 5 - DSM1MD Disable Digital Signal Modulator\n1, Description = DSM module disabled. 0, Description = DSM module enabled",
    "Bit 4 - NCO1MD Disable Numerically Controlled Oscillator 1\n1, Description = NCO1 module disabled. 0, Description = NCO1 module enabled",
    "Bit 3 - ACTMD Disable Active Clock Tuning\n1, Description = Active Clock Tuning disabled. 0, Description = Active Clock Tuning enabled",
    "Bit 2 - DAC1MD Disable Digital-to-Analog Converter\n1, Description = DAC module disabled. 0, Description = DAC module enabled",
    "Bit 1 - ADCMD Disable Analog-to-Digital Converter\n1, Description = ADC module disabled. 0, Description = ADC module enabled",
    "Bit 0 - C2MD Disable Comparator 2\n1, Description = CM2 module disabled. 0, Description = CM2 module enabled",
    "18.4.4 PMD3\nName: Address:\nPMD3\n0x066",
    "PMD Control Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = U2MD. , 2 = U1MD. , 3 = SPI2MD. , 4 = SPI1MD. , 5 = I2C1MD. , 6 = PWM3MD. , 7 = PWM2MD. , 8 = PWM1MD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 6, 7 - UnMD Disable UART Un\n1, Description = UARTn module disabled. 0, Description = UARTn module enabled",
    "Bit 5 - SPI2MD Disable Serial Peripheral Interface 2\n1, Description = SPI2 module disabled. 0, Description = SPI2 module enabled",
    "Bit 4 - SPI1MD Disable Serial Peripheral Interface 1\n1, Description = SPI1 module disabled. 0, Description = SPI1 module enabled",
    "Bit 3 - I2C1MD  Disable I 2 C\n1, Description = I 2 C1 module disabled. 0, Description = I 2 C1 module enabled",
    "Bit 2 - PWM3MD Disable Pulse-Width Modulator 3\n1, Description = PWM3 module disabled. 0, Description = PWM3 module enabled",
    "Bit 1 - PWM2MD Disable Pulse-Width Modulator 2\n1, Description = PWM2 module disabled. 0, Description = PWM2 module enabled",
    "Bit 0 - PWM1MD Disable Pulse-Width Modulator 1\n1, Description = PWM1 module disabled. 0, Description = PWM1 module enabled",
    "18.4.5 PMD4\nName:\nPMD4\nAddress:\n0x067",
    "PMD Control Register 4\n, 7 = DMA3MD. , 6 = DMA2MD. , 5 = DMA1MD. , 4 = CLC4MD. , 3 = CLC3MD. , 2 = CLC2MD. , 1 = CLC1MD. , 0 = U3MD. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bits 5, 6, 7 - DMAnMD Disable DMAn\n1, Description = DMAn module disabled. 0, Description = DMAn module enabled",
    "Bits 1, 2, 3, 4 - CLCnMD Disable CLCn\n1, Description = CLCn module disabled. 0, Description = CLCn module enabled",
    "Bit 0 - UnMD Disable UART Un\n1, Description = UARTn module disabled. 0, Description = UARTn module enabled",
    "18.4.6 PMD5\nName:\nPMD5\nAddress:\n0x068",
    "PMD Control Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = OPA1MD. , 7 = DAC2MD. , 8 = DMA4MD. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 2 - OPA1MD Disable Operational Amplifier\n1, Description = OPA module disabled. 0, Description = OPA module enabled",
    "Bit 1 - DAC2MD Disable Digital-to-Analog Converter\n1, Description = DAC module disabled. 0, Description = DAC module enabled",
    "Bit 0 - DMAnMD Disable DMAn\n1, Description = DMAn module disabled. 0, Description = DMAn module enabled",
    "18.5 Register Summary - PMD\n0x00 ... 0x62, Name = Reserved. 0x00 ... 0x62, Bit Pos. = . 0x00 ... 0x62, 7 = . 0x00 ... 0x62, 6 = . 0x00 ... 0x62, 5 = . 0x00 ... 0x62, 4 = . 0x00 ... 0x62, 3 = . 0x00 ... 0x62, 2 = . 0x00 ... 0x62, 1 = . 0x00 ... 0x62, 0 = . 0x63, Name = PMD0. 0x63, Bit Pos. = 7:0. 0x63, 7 = SYSCMD. 0x63, 6 = FVRMD. 0x63, 5 = HLVDMD. 0x63, 4 = CRCMD. 0x63, 3 = SCANMD. 0x63, 2 = . 0x63, 1 = CLKRMD. 0x63,",
    "18.5 Register Summary - PMD\n0 = IOCMD. 0x64, Name = PMD1. 0x64, Bit Pos. = 7:0. 0x64, 7 = C1MD. 0x64, 6 = ZCDMD. 0x64, 5 = SMT1MD. 0x64, 4 = TMR4MD. 0x64, 3 = TMR3MD. 0x64, 2 = TMR2MD. 0x64, 1 = TMR1MD. 0x64, 0 = TMR0MD. 0x65, Name = PMD2. 0x65, Bit Pos. = 7:0. 0x65, 7 = CCP1MD. 0x65, 6 = CWG1MD. 0x65, 5 = DSM1MD. 0x65, 4 = NCO1MD. 0x65, 3 = ACTMD. 0x65, 2 = DAC1MD. 0x65, 1 = ADCMD. 0x65, 0 = C2MD. 0x66, Name = PMD3. 0x66, Bit Pos. = 7:0.",
    "18.5 Register Summary - PMD\n0x66, 7 = U2MD. 0x66, 6 = U1MD. 0x66, 5 = SPI2MD. 0x66, 4 = SPI1MD. 0x66, 3 = I2C1MD. 0x66, 2 = PWM3MD. 0x66, 1 = PWM2MD. 0x66, 0 = PWM1MD. 0x67, Name = PMD4. 0x67, Bit Pos. = 7:0. 0x67, 7 = DMA3MD. 0x67, 6 = DMA2MD. 0x67, 5 = DMA1MD. 0x67, 4 = CLC4MD. 0x67, 3 = CLC3MD. 0x67, 2 = CLC2MD. 0x67, 1 = CLC1MD. 0x67, 0 = U3MD. 0x68, Name = PMD5. 0x68, Bit Pos. = 7:0. 0x68, 7 = . 0x68, 6",
    "18.5 Register Summary - PMD\n= . 0x68, 5 = . 0x68, 4 = . 0x68, 3 = . 0x68, 2 = OPA1MD. 0x68, 1 = DAC2MD. 0x68, 0 = DMA4MD",
    "19.1 Overview\nTable 19-1. Port Availability per Device\n\n14-pin devices, PORTA = \u25cf (1). 14-pin devices, PORTB = . 14-pin devices, PORTC = \u25cf (3). 20-pin devices, PORTA = \u25cf (1). 20-pin devices, PORTB = \u25cf (2). 20-pin devices, PORTC = \u25cf. Notes:, PORTA = . Notes:, PORTB = . Notes:, PORTC = . 1. Pins RA0 - RA5 only., PORTA = . 1. Pins RA0 - RA5 only., PORTB = . 1. Pins RA0 - RA5 only., PORTC = . 2. Pins RB4 - RB7 only., PORTA = . 2. Pins RB4 - RB7 only., PORTB = . 2. Pins RB4 - RB7 only., PORTC = . 3. Pins RC0 - RC5 only., PORTA = . 3. Pins RC0 - RC5 only., PORTB = . 3. Pins RC0 - RC5 only., PORTC = \nEach port has eight registers to control the operation. These registers are:",
    "19.1 Overview\n\u00b7 PORTx registers (reads the levels on the pins of the device)\n\u00b7 LATx registers (output latch)\n\u00b7 TRISx registers (data direction)\n\u00b7 ANSELx registers (analog select)\n\u00b7 WPUx registers (weak pull-up)\n\u00b7 INLVLx (input level control)\n\u00b7 SLRCONx registers (slew rate control)\n\u00b7 ODCONx registers (open-drain control)\nIn this section, the generic names such as PORTx, LATx, TRISx, etc. can be associated with PORTA, PORTB, PORTC, etc., depending on availability per device.\nA simplified model of a generic I/O port, without the interfaces to other peripherals, is shown in the following figure:\nFigure 19-1. Generic I/O Port Operation\n\u2e20\n\u3130\n\u7374\n\u434b\n\u5353\n\u4444\n\u3131",
    "19.2 PORTx - Data Register\nPORTx is a bidirectional port and its corresponding data direction register is TRISx.\nReading the PORTx register reads the status of the pins, whereas writing to it will write to the PORT latch. All write operations are Read-Modify-Write operations. Therefore, a write to a port implies that the PORT pins are read, and this value is modified and then written to the PORT data latch (LATx). The PORT data latch LATx holds the output port data and contains the latest value of a LATx or PORTx write. The example below shows how to initialize PORTA.\n```\n; This code example illustrates initializing the PORTA register. ; The other ports are initialized in the same manner. BANKSEL    PORTA        ; CLRF       PORTA        ;Clear PORTA BANKSEL    LATA         ; CLRF       LATA         ;Clear Data Latch BANKSEL    ANSELA       ; CLRF       ANSELA       ;Enable digital drivers BANKSEL    TRISA        ; MOVLW      B'00111000'  ;Set RA[5:3] as inputs MOVWF      TRISA        ;and set others as outputs\n```\n\nExample 19-1. Initializing PORTA in Assembly",
    "19.2 PORTx - Data Register\n```\nExample 19-2. Initializing PORTA in C // This code example illustrates initializing the PORTA register. // The other ports are initialized in the same manner. PORTA  = 0x00; // Clear PORTA LATA   = 0x00; // Clear Data Latch ANSELA = 0x00; // Enable digital drivers TRISA  = 0x38; // Set RA[5:3] as inputs and set others as outputs\n```\nImportant: Most PORT pins share functions with device peripherals, both analog and digital. In general, when a peripheral is enabled on a PORT pin, that pin cannot be used as a general purpose output; however, the pin can still be read.",
    "19.3 LATx - Output Latch\nThe Data Latch (LATx registers) is useful for Read-Modify-Write operations on the value that the I/O pins are driving.\nA write operation to the LATx register has the same effect as a write to the corresponding PORTx register. A read of the LATx register reads the values held in the I/O PORT latches, while a read of the PORTx register reads the actual I/O pin value.\nImportant: As a general rule, output operations to a port must use the LAT register to avoid Read-Modify-Write issues. For example, a bit set or clear operation reads the port, modifies the bit, and writes the result back to the port. When two bit operations are executed in succession, output loading on the changed bit may delay the change at the output in which case the bit will be misread in the second bit operation and written to an unexpected level. The LAT registers are isolated from the port loading and therefore changes are not delayed.",
    "19.4 TRISx - Direction Control\nThe TRISx register controls the PORTx pin output drivers, even when the pins are being used as analog inputs. The user must ensure the bits in the TRISx register are set when using the pins as analog inputs. I/O pins configured as analog inputs always read ' 0 '.\nSetting a TRISx bit (TRISx = 1 ) will make the corresponding PORTx pin an input (i.e., disable the output driver). Clearing a TRISx bit (TRISx = 0 ) will make the corresponding PORTx pin an output (i.e., it enables output driver and puts the contents of the output latch on the selected pin).",
    "19.5 ANSELx - Analog Control\nPorts that support analog inputs have an associated ANSELx register. The ANSELx register is used to configure the Input mode of an I/O pin to analog. Setting an ANSELx bit high will disable the digital input buffer associated with that bit and cause the corresponding input value to always read ' 0 ', whether the value is read in PORTx register or selected by PPS as a peripheral input.\nDisabling the input buffer prevents analog signal levels on the pin between a logic high and low from causing excessive current in the logic input circuitry.\nThe state of the ANSELx bits has no effect on digital or analog output functions. A pin with TRIS clear and ANSEL set will still operate as a digital output, but the Input mode will be analog. This can cause unexpected behavior when executing Read-Modify-Write instructions on the PORTx register.\nImportant: The ANSELx bits default to the Analog mode after Reset. To use any pins as digital general purpose or peripheral inputs, the corresponding ANSEL bits must be changed to ' 0 ' by the user.",
    "19.6 WPUx - Weak Pull-Up Control\nThe WPUx register controls the individual weak pull-ups for each PORT pin. When a WPUx bit is set (WPUx = 1 ), the weak pull-up will be enabled for the corresponding pin. When a WPUx bit is cleared (WPUx = 0 ), the weak pull-up will be disabled for the corresponding pin.",
    "19.7 INLVLx - Input Threshold Control\nThe INLVLx register controls the input voltage threshold for each of the available PORTx input pins. A selection between the Schmitt Trigger CMOS and the TTL compatible thresholds is available. The input threshold is important in determining the value of a read of the PORTx register and also the level at which an interrupt-on-change occurs, if that feature is enabled. Refer to the I/O Ports table in the 'Electrical Specifications' chapter for more details on threshold levels.\nImportant: Changing the input threshold selection must be performed while all peripheral modules are disabled. Changing the threshold level during the time a module is active may inadvertently generate a transition associated with an input pin, regardless of the actual voltage level on that pin.",
    "19.8 SLRCONx - Slew Rate Control\nThe SLRCONx register controls the slew rate option for each PORT pin. Slew rate for each PORT pin can be controlled independently. When a SLRCONx bit is set (SLRCONx = 1 ), the corresponding PORT pin drive is slew rate limited. When a SLRCONx bit is cleared (SLRCONx = 0 ), the corresponding PORT pin drive slews at the maximum rate possible.",
    "19.9 ODCONx - Open-Drain Control\nThe ODCONx register controls the open-drain feature of the port. Open-drain operation is independently selected for each pin. When a ODCONx bit is set (ODCONx = 1 ), the corresponding port output becomes an open-drain driver capable of sinking current only. When a ODCONx bit is cleared (ODCONx = 0 ), the corresponding port output pin is the standard push-pull drive capable of sourcing and sinking current.\nImportant: It is necessary to set open-drain control when using the pin for I 2 C.",
    "19.10 Edge Selectable Interrupt-on-Change\nAn interrupt can be generated by detecting a signal at the PORT pin that has either a rising edge or a falling edge. Individual pins can be independently configured to generate an interrupt. Refer to the ' IOC - Interrupt-on-Change ' chapter for more details.",
    "19.11 I 2 C Pad Control\nFor this family of devices, the I 2 C specific pads are available on RB4, RB6, RC0 and RC1 pins. The I 2 C characteristics of each of these pins is controlled by the RxyI2C registers. These characteristics include enabling I 2 C specific slew rate (over standard GPIO slew rate), selecting internal pull-ups for I 2 C pins, and selecting appropriate input threshold as per SMBus specifications.\nImportant: Any peripheral using the I 2 C pins reads the I 2 C input levels when enabled via RxyI2C.",
    "19.12 I/O Priorities\nEach pin defaults to the data latch after Reset. Other functions are selected with the Peripheral Pin Select logic. Refer to the 'PPS - Peripheral Pin Select Module' chapter for more details.\nAnalog input functions, such as ADC and comparator inputs, are not shown in the Peripheral Pin Select lists. These inputs are active when the I/O pin is set for Analog mode using the ANSELx register. Digital output functions may continue to control the pin when it is in Analog mode.\nAnalog outputs, when enabled, take priority over digital outputs and force the digital output driver into a High-Impedance state.\nThe pin function priorities are as follows:\n1. Port functions determined by the Configuration bits.\n2. Analog outputs (input buffers must be disabled).\n3. Analog inputs.\n4. Port inputs and outputs from PPS.",
    "19.13 MCLR/VPP/RA3 Pin\nThe MCLR/VPP pin is an input-only pin. Its operation is controlled by the MCLRE Configuration bit. When selected as a PORT pin (MCLRE = 0 ), it functions as a digital input-only pin; as such, it does not have TRISx and LATx bits associated with its operation. Otherwise, it functions as the device's Master Clear input. In either configuration, the MCLR/V PP pin also functions as the programming voltage input pin during high-voltage programming.\nThe MCLR/VPP pin is a read-only bit and will read ' 1 ' when MCLRE = 1 (i.e., Master Clear enabled).\nImportant: On a Power-on Reset (POR), the MCLR/VPP pin is enabled as a digital input-only if Master Clear functionality is disabled.",
    "19.13 MCLR/VPP/RA3 Pin\nThe MCLR/VPP pin has an individually controlled internal weak pull-up. When set, the corresponding WPU bit enables the pull-up. When the MCLR/VPP pin is configured as MCLR (MCLRE = 1 and LVP = 0 ) or configured for Low-Voltage Programming (MCLRE = x and LVP = 1 ), the pull-up is always enabled, and the WPU bit has no effect.",
    "19.14.1  PORTx\nName:\nPORTx\nPORTx Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = Rx7. , 2 = Rx6. , 3 = Rx5. , 4 = Rx4. , 5 = Rx3. , 6 = Rx2. , 7 = Rx1. , 8 = Rx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - Rxn Port I/O Value\nReset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuu\n1, Description = PORT pin is \u2265 V IH. 0, Description = PORT pin is \u2264 V IL",
    "Important:\n\u00b7 Writes to PORTx are actually written to the corresponding LATx register. Reads from PORTx register return actual I/O pin values.\n\u00b7 The PORT bit associated with the MCLR pin is read-only and will read ' 1 ' when the MCLR function is enabled (LVP = 1 or (LVP = 0 and MCLRE = 1 ))\n\u00b7 Refer to the 'Pin Allocation Table' for details about MCLR pin and pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '\n\u00b7 Bits RB6 and RB7 read '1' while in Debug mode",
    "Output Latch Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATx7. , 2 = LATx6. , 3 = LATx5. , 4 = LATx4. , 5 = LATx3. , 6 = LATx2. , 7 = LATx1. , 8 = LATx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - LATxn Output Latch Value\nReset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuu",
    "Important:\n\u00b7 Writes to LATx are equivalent to writes to the corresponding PORTx register. Reads from LATx register return register values, not I/O pin values.\n\u00b7 Refer to the 'Pin Allocation Table' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISx7. , 2 = TRISx6. , 3 = TRISx5. , 4 = TRISx4. , 5 = TRISx3. , 6 = TRISx2. , 7 = TRISx1. , 8 = TRISx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - TRISxn Port I/O Tri-state Control\n1, Description = PORTx output driver is disabled. PORTx pin configured as an input (tri-stated).. 0, Description = PORTx output driver is enabled. PORTx pin configured as an output.",
    "Important:\n\u00b7 The TRIS bit associated with the MCLR pin is read-only and the value is ' 1 '\n\u00b7 Refer to the 'Pin Allocation Table' for details about MCLR pin and pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "Name: ANSELx\nAnalog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELx7. , 2 = ANSELx6. , 3 = ANSELx5. , 4 = ANSELx4. , 5 = ANSELx3. , 6 = ANSELx2. , 7 = ANSELx1. , 8 = ANSELx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELxn Analog Select on RX Pin\n1, Description = Analog input. Pin is assigned as analog input. Digital input buffer disabled.. 0, Description = Digital I/O. Pin is assigned to port or digital special function.",
    "Important:\n\u00b7 When setting a pin as an analog input, the corresponding TRIS bit must be set to Input mode to allow external control of the voltage on the pin\n\u00b7 Refer to the ' Pin Allocation Table ' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "Name: WPUx\nWeak Pull-Up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUx7. , 2 = WPUx6. , 3 = WPUx5. , 4 = WPUx4. , 5 = WPUx3. , 6 = WPUx2. , 7 = WPUx1. , 8 = WPUx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUxn Weak Pull-up PORTx Control\n1, Description = Weak pull-up enabled. 0, Description = Weak pull-up disabled",
    "Important:\n\u00b7 The weak pull-up device is automatically disabled if the pin is configured as an output, but this register remains unchanged\n\u00b7 If MCLRE = 1 , the weak pull-up on MCLR pin is always enabled and the corresponding WPU bit is not affected\n\u00b7 Refer to the 'Pin Allocation Table' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "Input Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLx7. , 2 = INLVLx6. , 3 = INLVLx5. , 4 = INLVLx4. , 5 = INLVLx3. , 6 = INLVLx2. , 7 = INLVLx1. , 8 = INLVLx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLxn Input Level Select on RX Pin\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "Important:\n\u00b7 Refer to the ' Pin Allocation Table ' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '\n\u00b7 Any peripheral using the I 2 C pins read the I 2 C ST inputs when enabled via RxyI2C",
    "Slew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRx7. , 2 = SLRx6. , 3 = SLRx5. , 4 = SLRx4. , 5 = SLRx3. , 6 = SLRx2. , 7 = SLRx1. , 8 = SLRx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - SLRxn Slew Rate Control on RX Pin\n1, Description = PORT pin slew rate is limited. 0, Description = PORT pin slews at maximum rate",
    "Important:\n\u00b7 Refer to the ' Pin Allocation Table ' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "Name: ODCONx\nOpen-Drain Control Register\n, 7 = ODCx7. , 6 = ODCx6. , 5 = ODCx5. , 4 = ODCx4. , 3 = ODCx3. , 2 = ODCx2. , 1 = ODCx1. , 0 = ODCx0. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ODCxn Open-Drain Configuration on Rx Pin\n1, Description = PORT pin operates as open-drain drive (sink current only). 0, Description = PORT pin operates as standard push-pull drive (source and sink current)",
    "Important:\n\u00b7 Refer to the ' Pin Allocation Table ' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "Name: RxyI2C\nI 2 C Pad Rxy Control Register",
    "Name: RxyI2C\nBit, 1 = 7 6. Bit, 2 = 7 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 2 1. Bit, 8 = 0. Bit, 9 = . Bit, 10 = . , 1 = SLEW[1:0]. , 2 = SLEW[1:0]. , 3 = PU[1:0]. , 4 = PU[1:0]. , 5 = PU[1:0]. , 6 = . , 7 = TH[1:0]. , 8 = TH[1:0]. , 9 = . , 10 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Access, 9 = . Access, 10 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 = .",
    "Name: RxyI2C\nReset, 7 = 0. Reset, 8 = 0. Reset, 9 = . Reset, 10 = ",
    "Bits 7:6 - SLEW[1:0]  I 2 C Specific Slew Rate Limiting Control\n11, Description = I 2 C Fast mode Plus (1 MHz) slew rate enabled. The SLRxy bit is ignored.. 10, Description = Reserved. 01, Description = I 2 C Fast mode (400 kHz) slew rate enabled. The SLRxy bit is ignored.. 00, Description = Standard GPIO Slew Rate; enabled/disabled via the SLRxy bit",
    "Bits 5:4 - PU[1:0]  I 2 C Pull-Up Selection\n11, Description.FME = 0x = Reserved. 11, Description.FME = 10 = 20x current of standard weak pull-up. 10, Description.FME = 0x = 10x current of standard weak pull-up. 10, Description.FME = 10 = 10x current of standard weak pull-up. 01, Description.FME = 0x = 2x current of standard weak pull-up. 01, Description.FME = 10 = 5x current of standard weak pull-up. 00, Description.FME = 0x = Standard GPIO weak pull-up, enabled via the WPUxy bit. 00, Description.FME = 10 = Standard GPIO weak pull-up, enabled via the WPUxy bit",
    "Bits 1:0 - TH[1:0]  I 2 C Input Threshold Selection\n11, Description = SMBus 3.0 (1.35V) input threshold. 10, Description = SMBus 2.0 (2.1V) input threshold. 01, Description = I 2 C-specific input thresholds. 00, Description = Standard GPIO Input pull-up, enabled via the INLVLxy registers",
    "Important:\n\u00b7 Refer to the ' Pin Allocation Table ' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "19.15 Register Summary - I/O Ports\n0x00 ..., Name = Reserved. 0x00 ..., Bit Pos. = . 0x00 ..., 7 = . 0x00 ..., 6 = . 0x00 ..., 5 = . 0x00 ..., 4 = . 0x00 ..., 3 = . 0x00 ..., 2 = . 0x00 ..., 1 = . 0x00 ..., 0 = . 0x0286, Name = RB6I2C. 0x0286, Bit Pos. = 7:0. 0x0286, 7 = SLEW[1:0]. 0x0286, 6 = . 0x0286, 5 = PU[1:0]. 0x0286, 4 = . 0x0286, 3 = . 0x0286, 2 = . 0x0286, 1 = TH[1:0]. 0x0286, 0 = . 0x0287, Name = RB4I2C. 0x0287, Bit",
    "19.15 Register Summary - I/O Ports\nPos. = 7:0. 0x0287, 7 = SLEW[1:0]. 0x0287, 6 = . 0x0287, 5 = PU[1:0]. 0x0287, 4 = . 0x0287, 3 = . 0x0287, 2 = . 0x0287, 1 = TH[1:0]. 0x0287, 0 = . 0x0288, Name = RC1I2C. 0x0288, Bit Pos. = 7:0. 0x0288, 7 = SLEW[1:0]. 0x0288, 6 = . 0x0288, 5 = PU[1:0]. 0x0288, 4 = . 0x0288, 3 = . 0x0288, 2 = . 0x0288, 1 = TH[1:0]. 0x0288, 0 = . 0x0289, Name = RC0I2C. 0x0289, Bit Pos. =",
    "19.15 Register Summary - I/O Ports\n7:0. 0x0289, 7 = SLEW[1:0]. 0x0289, 6 = . 0x0289, 5 = PU[1:0]. 0x0289, 4 = . 0x0289, 3 = . 0x0289, 2 = . 0x0289, 1 = TH[1:0]. 0x0289, 0 = . 0x028A, Name = . 0x028A, Bit Pos. = . 0x028A, 7 = . 0x028A, 6 = . 0x028A, 5 = . 0x028A, 4 = . 0x028A, 3 = . 0x028A, 2 = . 0x028A, 1 = . 0x028A, 0 = . ... 0x03FF 0x0400, Name = Reserved ANSELA. ... 0x03FF 0x0400, Bit Pos. = 7:0. ... 0x03FF 0x0400, 7 = .",
    "19.15 Register Summary - I/O Ports\n... 0x03FF 0x0400, 6 = . ... 0x03FF 0x0400, 5 = ANSELA5. ... 0x03FF 0x0400, 4 = ANSELA4. ... 0x03FF 0x0400, 3 = . ... 0x03FF 0x0400, 2 = ANSELA2. ... 0x03FF 0x0400, 1 = ANSELA1. ... 0x03FF 0x0400, 0 = ANSELA0. 0x0401, Name = WPUA. 0x0401, Bit Pos. = 7:0. 0x0401, 7 = . 0x0401, 6 = . 0x0401, 5 = WPUA5. 0x0401, 4 = WPUA4. 0x0401, 3 = WPUA3. 0x0401, 2 = WPUA2. 0x0401, 1 = WPUA1. 0x0401,",
    "19.15 Register Summary - I/O Ports\n0 = WPUA0. 0x0402, Name = ODCONA. 0x0402, Bit Pos. = 7:0. 0x0402, 7 = . 0x0402, 6 = . 0x0402, 5 = ODCA5. 0x0402, 4 = ODCA4. 0x0402, 3 = . 0x0402, 2 = ODCA2. 0x0402, 1 = ODCA1. 0x0402, 0 = ODCA0. 0x0403, Name = SLRCONA. 0x0403, Bit Pos. = 7:0. 0x0403, 7 = . 0x0403, 6 = . 0x0403, 5 = SLRA5. 0x0403, 4 = SLRA4. 0x0403, 3 = . 0x0403, 2 = SLRA2. 0x0403, 1 = SLRA1. 0x0403, 0 = SLRA0. 0x0404, Name",
    "19.15 Register Summary - I/O Ports\n= INLVLA. 0x0404, Bit Pos. = 7:0. 0x0404, 7 = . 0x0404, 6 = . 0x0404, 5 = INLVLA5. 0x0404, 4 = INLVLA4. 0x0404, 3 = INLVLA3. 0x0404, 2 = INLVLA2. 0x0404, 1 = INLVLA1. 0x0404, 0 = INLVLA0. 0x0405 ..., Name = Reserved. 0x0405 ..., Bit Pos. = . 0x0405 ..., 7 = . 0x0405 ..., 6 = . 0x0405 ..., 5 = . 0x0405 ..., 4 = . 0x0405 ..., 3 = . 0x0405 ..., 2 = . 0x0405 ..., 1 = . 0x0405 ..., 0 =",
    "19.15 Register Summary - I/O Ports\n. 0x0407, Name = ANSELB. 0x0407, Bit Pos. = . 0x0407, 7 = . 0x0407, 6 = . 0x0407, 5 = . 0x0407, 4 = . 0x0407, 3 = . 0x0407, 2 = . 0x0407, 1 = . 0x0407, 0 = . 0x0408, Name = . 0x0408, Bit Pos. = 7:0. 0x0408, 7 = ANSELB7. 0x0408, 6 = ANSELB6. 0x0408, 5 = ANSELB5. 0x0408, 4 = ANSELB4. 0x0408, 3 = . 0x0408, 2 = . 0x0408, 1 = . 0x0408, 0 = . 0x0409, Name = WPUB. 0x0409, Bit Pos. = 7:0. 0x0409, 7 =",
    "19.15 Register Summary - I/O Ports\nWPUB7. 0x0409, 6 = WPUB6. 0x0409, 5 = WPUB5. 0x0409, 4 = WPUB4. 0x0409, 3 = . 0x0409, 2 = . 0x0409, 1 = . 0x0409, 0 = . 0x040A, Name = ODCONB. 0x040A, Bit Pos. = 7:0. 0x040A, 7 = ODCB7. 0x040A, 6 = ODCB6. 0x040A, 5 = ODCB5. 0x040A, 4 = ODCB4. 0x040A, 3 = . 0x040A, 2 = . 0x040A, 1 = . 0x040A, 0 = . 0x040B, Name = SLRCONB. 0x040B, Bit Pos. = 7:0. 0x040B, 7 = SLRB7. 0x040B, 6 =",
    "19.15 Register Summary - I/O Ports\nSLRB6. 0x040B, 5 = SLRB5. 0x040B, 4 = SLRB4. 0x040B, 3 = . 0x040B, 2 = . 0x040B, 1 = . 0x040B, 0 = . 0x040C, Name = INLVLB. 0x040C, Bit Pos. = 7:0. 0x040C, 7 = INLVLB7. 0x040C, 6 = INLVLB6. 0x040C, 5 = INLVLB5. 0x040C, 4 = INLVLB4. 0x040C, 3 = . 0x040C, 2 = . 0x040C, 1 = . 0x040C, 0 = . 0x040D, Name = . 0x040D, Bit Pos. = . 0x040D, 7 = . 0x040D, 6 = . 0x040D, 5 = . 0x040D, 4 = .",
    "19.15 Register Summary - I/O Ports\n0x040D, 3 = . 0x040D, 2 = . 0x040D, 1 = . 0x040D, 0 = . ... 0x040F, Name = Reserved. ... 0x040F, Bit Pos. = . ... 0x040F, 7 = . ... 0x040F, 6 = . ... 0x040F, 5 = . ... 0x040F, 4 = . ... 0x040F, 3 = . ... 0x040F, 2 = . ... 0x040F, 1 = . ... 0x040F, 0 = . 0x0410, Name = ANSELC. 0x0410, Bit Pos. = 7:0. 0x0410, 7 = ANSELC7. 0x0410, 6 = ANSELC6. 0x0410, 5 = ANSELC5. 0x0410, 4 = ANSELC4. 0x0410, 3",
    "19.15 Register Summary - I/O Ports\n= ANSELC3. 0x0410, 2 = ANSELC2. 0x0410, 1 = ANSELC1. 0x0410, 0 = ANSELC0. 0x0411, Name = WPUC. 0x0411, Bit Pos. = 7:0. 0x0411, 7 = WPUC7. 0x0411, 6 = WPUC6. 0x0411, 5 = WPUC5. 0x0411, 4 = WPUC4. 0x0411, 3 = WPUC3. 0x0411, 2 = WPUC2. 0x0411, 1 = WPUC1. 0x0411, 0 = WPUC0. 0x0412, Name = ODCONC. 0x0412, Bit Pos. = 7:0. 0x0412, 7 = ODCC7. 0x0412, 6 = ODCC6. 0x0412, 5 = ODCC5.",
    "19.15 Register Summary - I/O Ports\n0x0412, 4 = ODCC4. 0x0412, 3 = ODCC3. 0x0412, 2 = ODCC2. 0x0412, 1 = ODCC1. 0x0412, 0 = ODCC0. 0x0413, Name = SLRCONC. 0x0413, Bit Pos. = 7:0. 0x0413, 7 = SLRC7. 0x0413, 6 = SLRC6. 0x0413, 5 = SLRC5. 0x0413, 4 = SLRC4. 0x0413, 3 = SLRC3. 0x0413, 2 = SLRC2. 0x0413, 1 = SLRC1. 0x0413, 0 = SLRC0. 0x0414, Name = INLVLC. 0x0414, Bit Pos. = 7:0. 0x0414, 7 = INLVLC7. 0x0414, 6 = INLVLC6.",
    "19.15 Register Summary - I/O Ports\n0x0414, 5 = INLVLC5. 0x0414, 4 = INLVLC4. 0x0414, 3 = INLVLC3. 0x0414, 2 = INLVLC2. 0x0414, 1 = INLVLC1. 0x0414, 0 = INLVLC0. 0x0415 ..., Name = Reserved. 0x0415 ..., Bit Pos. = . 0x0415 ..., 7 = . 0x0415 ..., 6 = . 0x0415 ..., 5 = . 0x0415 ..., 4 = . 0x0415 ..., 3 = . 0x0415 ..., 2 = . 0x0415 ..., 1 = . 0x0415 ..., 0 = . 0x04BE, Name = LATA. 0x04BE, Bit Pos. = 7:0. 0x04BE, 7 = .",
    "19.15 Register Summary - I/O Ports\n0x04BE, 6 = . 0x04BE, 5 = LATA5. 0x04BE, 4 = LATA4. 0x04BE, 3 = . 0x04BE, 2 = LATA2. 0x04BE, 1 = LATA1. 0x04BE, 0 = LATA0. 0x04BF, Name = LATB. 0x04BF, Bit Pos. = 7:0. 0x04BF, 7 = LATB7. 0x04BF, 6 = LATB6. 0x04BF, 5 = LATB5. 0x04BF, 4 = LATB4. 0x04BF, 3 = . 0x04BF, 2 = . 0x04BF, 1 = . 0x04BF, 0 = . 0x04C0, Name = LATC. 0x04C0, Bit Pos. = 7:0. 0x04C0, 7 = LATC7. 0x04C0, 6 =",
    "19.15 Register Summary - I/O Ports\nLATC6. 0x04C0, 5 = LATC5. 0x04C0, 4 = LATC4. 0x04C0, 3 = LATC3. 0x04C0, 2 = LATC2. 0x04C0, 1 = LATC1. 0x04C0, 0 = LATC0. 0x04C1 ..., Name = Reserved. 0x04C1 ..., Bit Pos. = . 0x04C1 ..., 7 = . 0x04C1 ..., 6 = . 0x04C1 ..., 5 = . 0x04C1 ..., 4 = . 0x04C1 ..., 3 = . 0x04C1 ..., 2 = . 0x04C1 ..., 1 = . 0x04C1 ..., 0 = . 0x04C5, Name = . 0x04C5, Bit Pos. = . 0x04C5,",
    "19.15 Register Summary - I/O Ports\n7 = . 0x04C5, 6 = . 0x04C5, 5 = . 0x04C5, 4 = . 0x04C5, 3 = . 0x04C5, 2 = . 0x04C5, 1 = . 0x04C5, 0 = . 0x04C6, Name = TRISA. 0x04C6, Bit Pos. = 7:0. 0x04C6, 7 = . 0x04C6, 6 = . 0x04C6, 5 = TRISA5. 0x04C6, 4 = TRISA4. 0x04C6, 3 = Reserved. 0x04C6, 2 = TRISA2. 0x04C6, 1 = TRISA1. 0x04C6, 0 = TRISA0. 0x04C7, Name = TRISB. 0x04C7, Bit Pos. = 7:0. 0x04C7, 7 = TRISB7. 0x04C7, 6",
    "19.15 Register Summary - I/O Ports\n= TRISB6. 0x04C7, 5 = TRISB5. 0x04C7, 4 = TRISB4. 0x04C7, 3 = . 0x04C7, 2 = . 0x04C7, 1 = . 0x04C7, 0 = . 0x04C8, Name = TRISC. 0x04C8, Bit Pos. = 7:0. 0x04C8, 7 = TRISC7. 0x04C8, 6 = TRISC6. 0x04C8, 5 = TRISC5. 0x04C8, 4 = TRISC4. 0x04C8, 3 = TRISC3. 0x04C8, 2 = TRISC2. 0x04C8, 1 = TRISC1. 0x04C8, 0 = TRISC0. 0x04C9, Name = Reserved. 0x04C9, Bit Pos. = . 0x04C9, 7 = . 0x04C9, 6 =",
    "19.15 Register Summary - I/O Ports\n. 0x04C9, 5 = . 0x04C9, 4 = . 0x04C9, 3 = . 0x04C9, 2 = . 0x04C9, 1 = . 0x04C9, 0 = . ... 0x04CD, Name = . ... 0x04CD, Bit Pos. = . ... 0x04CD, 7 = . ... 0x04CD, 6 = . ... 0x04CD, 5 = . ... 0x04CD, 4 = . ... 0x04CD, 3 = . ... 0x04CD, 2 = . ... 0x04CD, 1 = . ... 0x04CD, 0 = . 0x04CE, Name = PORTA. 0x04CE, Bit Pos. = 7:0. 0x04CE, 7 = . 0x04CE, 6 = . 0x04CE, 5 = RA5. 0x04CE, 4",
    "19.15 Register Summary - I/O Ports\n= RA4. 0x04CE, 3 = RA3. 0x04CE, 2 = RA2. 0x04CE, 1 = RA1. 0x04CE, 0 = RA0. 0x04CF, Name = PORTB. 0x04CF, Bit Pos. = 7:0. 0x04CF, 7 = RB7. 0x04CF, 6 = RB6. 0x04CF, 5 = RB5. 0x04CF, 4 = RB4. 0x04CF, 3 = . 0x04CF, 2 = . 0x04CF, 1 = . 0x04CF, 0 = . 0x04D0, Name = PORTC. 0x04D0, Bit Pos. = 7:0. 0x04D0, 7 = RC7. 0x04D0, 6 = RC6. 0x04D0, 5 = RC5. 0x04D0, 4 = RC4.",
    "19.15 Register Summary - I/O Ports\n0x04D0, 3 = RC3. 0x04D0, 2 = RC2. 0x04D0, 1 = RC1. 0x04D0, 0 = RC0",
    "20.1 Overview\nThe pins denoted in the table below can be configured to operate as interrupt-on-change (IOC) pins for this device. An interrupt can be generated by detecting a signal that has either a rising edge or a falling edge. Any individual PORT pin, or combination of PORT pins, can be configured to generate an interrupt.\nTable 20-1. IOC Pin Availability per Device\n\n14-pin devices, PORTA = \u25cf. 14-pin devices, PORTB = . 14-pin devices, PORTC = \u25cf. 20-pin devices, PORTA = \u25cf. 20-pin devices, PORTB = \u25cf. 20-pin devices, PORTC = \u25cf\nImportant: If MCLRE = 1 or LVP = 1 , the MCLR pin port functionality is disabled and IOC on that pin is not available.\nThe interrupt-on-change module has the following features:\n\u00b7 Interrupt-on-change enable (Host Switch)\n\u00b7 Individual pin configuration\n\u00b7 Rising and falling edge detection\n\u00b7 Individual pin interrupt flags\nThe following figure is a block diagram of the IOC module.\nFigure 20-1. Interrupt-on-Change Block Diagram (PORTA Example)\n\u7369\n\u506f\n\u7665\n\u6374\n\u4564\n\u4150\n\u726f\n\u7220\n\u7820",
    "20.2 Enabling the Module\nFor individual PORT pins to generate an interrupt, the IOC Interrupt Enable (IOCIE) bit of the Peripheral Interrupt Enable (PIEx) register must be set. If the IOC Interrupt Enable bit is disabled, the edge detection on the pin will still occur, but an interrupt will not be generated.",
    "20.3 Individual Pin Configuration\nA rising edge detector and a falling edge detector are present for each PORT pin. To enable a pin to detect a rising edge, the associated bit of the IOCxP register must be set. To enable a pin to detect a falling edge, the associated bit of the IOCxN register must be set. A PORT pin can be configured\n\u7665\n\u6374\n\u4564\n\u414e\n\u5365\n\u7365\n\u7820\n\u4146\n\u7269\n\u7272\n\u636f\n\u7265\nto detect rising and falling edges simultaneously by setting both associated bits of the IOCxP and IOCxN registers, respectively.",
    "20.4 Interrupt Flags\nThe bits located in the IOCxF registers are status flags that correspond to the interrupt-on-change pins of each port. If an expected edge is detected on an appropriately enabled pin, then the status flag for that pin will be set, and an interrupt will be generated if the IOCIE bit is set. The IOCIF bit located in the corresponding Peripheral Interrupt Request (PIRx) register, is all the IOCxF bits ORd together. The IOCIF bit is read-only. All of the IOCxF Status bits must be cleared to clear the IOCIF bit.",
    "20.5 Clearing Interrupt Flags\nThe individual status flags (IOCxF register bits) will be cleared by resetting them to zero. If another edge is detected during this clearing operation, the associated status flag will be set at the end of the sequence, regardless of the value actually being written.\nTo ensure that no detected edge is lost while clearing flags, only AND operations masking out known changed bits must be performed. The following sequence is an example of clearing an IOC interrupt flag using this method.",
    "20.6 Operation in Sleep\nAn interrupt-on-change event will wake the device from Sleep mode, if the IOCIE bit is set. If an edge is detected while in Sleep mode, the IOCxF register will be updated prior to the first instruction executed out of Sleep.",
    "Interrupt-on-Change Flag Register\n, 7 = IOCxF7. , 6 = IOCxF6. , 5 = IOCxF5. , 4 = IOCxF4. , 3 = IOCxF3. , 2 = IOCxF2. , 1 = IOCxF1. , 0 = IOCxF0. Access, 7 = R/W/HS. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = R/W/HS. Access, 3 = R/W/HS. Access, 2 = R/W/HS. Access, 1 = R/W/HS. Access, 0 = R/W/HS. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCxFn Interrupt-on-Change Flag\n1, Condition = IOCxP[n] = 1. 1, Description = A positive edge was detected on the Rx[n] pin. 1, Condition = IOCxN[n] = 1. 1, Description = A negative edge was detected on the Rx[n] pin. 0, Condition = IOCxP[n] = x and IOCxN[n] = x. 0, Description = No change was detected, or the user cleared the detected change",
    "Important:\n\u00b7 If MCLRE = 1 or LVP = 1 , the MCLR pin port functionality is disabled and IOC on that pin is not available\n\u00b7 Refer to the 'Pin Allocation Table' for details about pins with configurable IOC per port",
    "Interrupt-on-Change Negative Edge Register Example\n, 7 = IOCxN7. , 6 = IOCxN6. , 5 = IOCxN5. , 4 = IOCxN4. , 3 = IOCxN3. , 2 = IOCxN2. , 1 = IOCxN1. , 0 = IOCxN0. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCxNn Interrupt-on-Change Negative Edge Enable\n1, Description = Interrupt-on-change enabled on the IOCx pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Falling edge interrupt-on-change disabled for the associated pin",
    "Important:\n\u00b7 If MCLRE = 1 or LVP = 1 , the MCLR pin port functionality is disabled and IOC on that pin is not available\n\u00b7 Refer to the 'Pin Allocation Table' for details about pins with configurable IOC per port",
    "Interrupt-on-Change Positive Edge Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCxP7. , 2 = IOCxP6. , 3 = IOCxP5. , 4 = IOCxP4. , 5 = IOCxP3. , 6 = IOCxP2. , 7 = IOCxP1. , 8 = IOCxP0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCxPn Interrupt-on-Change Positive Edge Enable\n1, Description = Interrupt-on-change enabled on the IOCx pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Rising edge interrupt-on-change disabled for the associated pin.",
    "Important:\n\u00b7 If MCLRE = 1 or LVP = 1 , the MCLR pin port functionality is disabled and IOC on that pin is not available\n\u00b7 Refer to the 'Pin Allocation Table' for details about pins with configurable IOC per port",
    "20.8 Register Summary - Interrupt-on-Change Control\n0x00 ... 0x0404, Name = Reserved. 0x00 ... 0x0404, Bit Pos. = . 0x00 ... 0x0404, 7 = . 0x00 ... 0x0404, 6 = . 0x00 ... 0x0404, 5 = . 0x00 ... 0x0404, 4 = . 0x00 ... 0x0404, 3 = . 0x00 ... 0x0404, 2 = . 0x00 ... 0x0404, 1 = . 0x00 ... 0x0404, 0 = . 0x0405, Name = IOCAP. 0x0405, Bit Pos. = 7:0. 0x0405, 7 = . 0x0405, 6 = . 0x0405, 5 = IOCAP5. 0x0405, 4 = IOCAP4. 0x0405, 3 = IOCAP3. 0x0405, 2 =",
    "20.8 Register Summary - Interrupt-on-Change Control\nIOCAP2. 0x0405, 1 = IOCAP1. 0x0405, 0 = IOCAP0. 0x0406, Name = IOCAN. 0x0406, Bit Pos. = 7:0. 0x0406, 7 = . 0x0406, 6 = . 0x0406, 5 = IOCAN5. 0x0406, 4 = IOCAN4. 0x0406, 3 = IOCAN3. 0x0406, 2 = IOCAN2. 0x0406, 1 = IOCAN1. 0x0406, 0 = IOCAN0. 0x0407, Name = IOCAF. 0x0407, Bit Pos. = 7:0. 0x0407, 7 = . 0x0407, 6 = . 0x0407, 5 = IOCAF5. 0x0407, 4 = IOCAF4. 0x0407, 3 = IOCAF3. 0x0407, 2 = IOCAF2. 0x0407, 1 =",
    "20.8 Register Summary - Interrupt-on-Change Control\nIOCAF1. 0x0407, 0 = IOCAF0. 0x0408 ... 0x040C, Name = Reserved. 0x0408 ... 0x040C, Bit Pos. = . 0x0408 ... 0x040C, 7 = . 0x0408 ... 0x040C, 6 = . 0x0408 ... 0x040C, 5 = . 0x0408 ... 0x040C, 4 = . 0x0408 ... 0x040C, 3 = . 0x0408 ... 0x040C, 2 = . 0x0408 ... 0x040C, 1 = . 0x0408 ... 0x040C, 0 = . 0x040D, Name = IOCBP. 0x040D, Bit Pos. = 7:0. 0x040D, 7 = IOCBP7. 0x040D, 6 = IOCBP6.",
    "20.8 Register Summary - Interrupt-on-Change Control\n0x040D, 5 = IOCBP5. 0x040D, 4 = IOCBP4. 0x040D, 3 = . 0x040D, 2 = . 0x040D, 1 = . 0x040D, 0 = . 0x040E, Name = IOCBN. 0x040E, Bit Pos. = 7:0. 0x040E, 7 = IOCBN7. 0x040E, 6 = IOCBN6. 0x040E, 5 = IOCBN5. 0x040E, 4 = IOCBN4. 0x040E, 3 = . 0x040E, 2 = . 0x040E, 1 = . 0x040E, 0 = . 0x040F, Name = IOCBF. 0x040F, Bit Pos. = 7:0. 0x040F, 7 = IOCBF7. 0x040F, 6 = IOCBF6. 0x040F, 5 = IOCBF5. 0x040F, 4 =",
    "20.8 Register Summary - Interrupt-on-Change Control\nIOCBF4. 0x040F, 3 = . 0x040F, 2 = . 0x040F, 1 = . 0x040F, 0 = . 0x0410 ... 0x0414, Name = Reserved. 0x0410 ... 0x0414, Bit Pos. = . 0x0410 ... 0x0414, 7 = . 0x0410 ... 0x0414, 6 = . 0x0410 ... 0x0414, 5 = . 0x0410 ... 0x0414, 4 = . 0x0410 ... 0x0414, 3 = . 0x0410 ... 0x0414, 2 = . 0x0410 ... 0x0414, 1 = . 0x0410 ... 0x0414, 0 = . 0x0415, Name = IOCCP. 0x0415, Bit Pos. = 7:0.",
    "20.8 Register Summary - Interrupt-on-Change Control\n0x0415, 7 = IOCCP7. 0x0415, 6 = IOCCP6. 0x0415, 5 = IOCCP5. 0x0415, 4 = IOCCP4. 0x0415, 3 = IOCCP3. 0x0415, 2 = IOCCP2. 0x0415, 1 = IOCCP1. 0x0415, 0 = IOCCP0. 0x0416, Name = IOCCN. 0x0416, Bit Pos. = 7:0. 0x0416, 7 = IOCCN7. 0x0416, 6 = IOCCN6. 0x0416, 5 = IOCCN5. 0x0416, 4 = IOCCN4. 0x0416, 3 = IOCCN3. 0x0416, 2 = IOCCN2. 0x0416, 1 = IOCCN1. 0x0416, 0 = IOCCN0. 0x0417, Name = IOCCF.",
    "20.8 Register Summary - Interrupt-on-Change Control\n0x0417, Bit Pos. = 7:0. 0x0417, 7 = IOCCF7. 0x0417, 6 = IOCCF6. 0x0417, 5 = IOCCF5. 0x0417, 4 = IOCCF4. 0x0417, 3 = IOCCF3. 0x0417, 2 = IOCCF2. 0x0417, 1 = IOCCF1. 0x0417, 0 = IOCCF0",
    "21.1 Overview Filename:\nPPS Block Diagram.vsdx\nThe Peripheral Pin Select (PPS) module connects peripheral inputs and outputs to the device I/O pins. Only digital signals are included in the selections. Title: Last Edit: 3/26/2019 First Used:\nNotes:\nImportant: All analog inputs and outputs remain fixed to their assigned pins and cannot be changed through PPS.\nInput and output selections are independent as shown in the figure below.\nFigure 21-1. PPS Block Diagram",
    "21.2 PPS Inputs\nEach digital peripheral has a dedicated PPS Peripheral Input Selection (xxxPPS) register with which the input pin to the peripheral is selected. Devices that have 20 leads or less (8/14/16/20) allow PPS routing to any I/O pin, while devices with 28 leads or more allow PPS routing to I/Os contained within two ports (see the table below).\nImportant: The notation 'xxx' in the generic register name is a placeholder for the peripheral identifier. For example, xxx = T0CKI for the T0CKIPPS register.\nMultiple peripherals can operate from the same source simultaneously. Port reads always return the pin level regardless of peripheral PPS selection. If a pin also has analog functions associated, the ANSEL bit for that pin must be cleared to enable the digital input buffer.\n\nTable 21-1. PPS Input Selection Table",
    "21.2 PPS Inputs\nInterrupt 0, PPS Input Register.PPS Input Register = INT0PPS. Interrupt 0, Default Pin Selection at POR.Default Pin Selection at POR = RA2. Interrupt 0, 14-Pin Register Reset.at = 'b000. Interrupt 0, 14-Pin Register Reset.POR = 010. Interrupt 0, Devices Value Available. = A. Interrupt 0, Devices Value Available.Port = -. Interrupt 0, Devices Value Available. = C. Interrupt 0, Default Pin Selection at POR.Default Pin Selection at POR = RC0. Interrupt 0, 20-Pin Register Reset.at POR = 'b010. Interrupt 0, 20-Pin Register Reset. = 000. Interrupt 0, Devices Value Available Port. = A. Interrupt 0, Devices Value Available Port. = B. Interrupt 0, Devices Value Available Port. = C. Interrupt 1, PPS Input Register.PPS Input Register = INT1PPS. Interrupt 1, Default Pin Selection at POR.Default Pin Selection at POR = RA4. Interrupt 1, 14-Pin Register Reset.at = 'b000. Interrupt 1, 14-Pin Register Reset.POR = 100. Interrupt 1, Devices Value Available. = A.",
    "21.2 PPS Inputs\nInterrupt 1, Devices Value Available.Port = -. Interrupt 1, Devices Value Available. = C. Interrupt 1, Default Pin Selection at POR.Default Pin Selection at POR = RC1. Interrupt 1, 20-Pin Register Reset.at POR = 'b010. Interrupt 1, 20-Pin Register Reset. = 001. Interrupt 1, Devices Value Available Port. = A. Interrupt 1, Devices Value Available Port. = B. Interrupt 1, Devices Value Available Port. = C. Interrupt 2, PPS Input Register.PPS Input Register = INT2PPS. Interrupt 2, Default Pin Selection at POR.Default Pin Selection at POR = RA5. Interrupt 2, 14-Pin Register Reset.at = 'b000. Interrupt 2, 14-Pin Register Reset.POR = 101. Interrupt 2, Devices Value Available. = A. Interrupt 2, Devices Value Available.Port = -. Interrupt 2, Devices Value Available. = C. Interrupt 2, Default Pin Selection at POR.Default Pin Selection at POR = RC2 RC5. Interrupt 2, 20-Pin Register Reset.at POR = 'b010 'b010. Interrupt 2, 20-Pin Register Reset. = 010.",
    "21.2 PPS Inputs\nInterrupt 2, Devices Value Available Port. = A. Interrupt 2, Devices Value Available Port. = B. Interrupt 2, Devices Value Available Port. = C. Timer0 Clock Timer1 Clock, PPS Input Register.PPS Input Register = T0CKIPPS T1CKIPPS. Timer0 Clock Timer1 Clock, Default Pin Selection at POR.Default Pin Selection at POR = RA2 RA5. Timer0 Clock Timer1 Clock, 14-Pin Register Reset.at = 'b000 'b000. Timer0 Clock Timer1 Clock, 14-Pin Register Reset.POR = 010 101. Timer0 Clock Timer1 Clock, Devices Value Available. = A A. Timer0 Clock Timer1 Clock, Devices Value Available.Port = - -. Timer0 Clock Timer1 Clock, Devices Value Available. = C C. Timer0 Clock Timer1 Clock, Default Pin Selection at POR.Default Pin Selection at POR = RC6. Timer0 Clock Timer1 Clock, 20-Pin Register Reset.at POR = 'b010. Timer0 Clock Timer1 Clock, 20-Pin Register Reset. = 101 110. Timer0 Clock Timer1 Clock, Devices Value Available Port. = A A. Timer0",
    "21.2 PPS Inputs\nClock Timer1 Clock, Devices Value Available Port. = B B. Timer0 Clock Timer1 Clock, Devices Value Available Port. = C C. Timer1 Gate, PPS Input Register.PPS Input Register = T1GPPS. Timer1 Gate, Default Pin Selection at POR.Default Pin Selection at POR = . Timer1 Gate, 14-Pin Register Reset.at = . Timer1 Gate, 14-Pin Register Reset.POR = 100. Timer1 Gate, Devices Value Available. = A. Timer1 Gate, Devices Value Available.Port = . Timer1 Gate, Devices Value Available. = C. Timer1 Gate, Default Pin Selection at POR.Default Pin Selection at POR = RA4. Timer1 Gate, 20-Pin Register Reset.at POR = 'b000. Timer1 Gate, 20-Pin Register Reset. = 100. Timer1 Gate, Devices Value Available Port. = A. Timer1 Gate, Devices Value Available Port. = B. Timer1 Gate, Devices Value Available Port. = C. , PPS Input Register.PPS Input Register = T3CKIPPS. , Default Pin Selection at POR.Default Pin Selection at POR = RA4 RC5. , 14-Pin",
    "21.2 PPS Inputs\nRegister Reset.at = 'b000 'b010. , 14-Pin Register Reset.POR = 101. , Devices Value Available. = A. , Devices Value Available.Port = - -. , Devices Value Available. = C. , Default Pin Selection at POR.Default Pin Selection at POR = RC5. , 20-Pin Register Reset.at POR = 'b010. , 20-Pin Register Reset. = 101. , Devices Value Available Port. = A. , Devices Value Available Port. = B. , Devices Value Available Port. = C. Timer3 Clock Timer3 Gate, PPS Input Register.PPS Input Register = T3GPPS. Timer3 Clock Timer3 Gate, Default Pin Selection at POR.Default Pin Selection at POR = RC4. Timer3 Clock Timer3 Gate, 14-Pin Register Reset.at = 'b010. Timer3 Clock Timer3 Gate, 14-Pin Register Reset.POR = 100. Timer3 Clock Timer3 Gate, Devices Value Available. = A. Timer3 Clock Timer3 Gate, Devices Value Available.Port = -. Timer3 Clock Timer3 Gate, Devices Value Available. = C. Timer3 Clock Timer3 Gate,",
    "21.2 PPS Inputs\nDefault Pin Selection at POR.Default Pin Selection at POR = RC4. Timer3 Clock Timer3 Gate, 20-Pin Register Reset.at POR = 'b010. Timer3 Clock Timer3 Gate, 20-Pin Register Reset. = 100. Timer3 Clock Timer3 Gate, Devices Value Available Port. = A. Timer3 Clock Timer3 Gate, Devices Value Available Port. = B. Timer3 Clock Timer3 Gate, Devices Value Available Port. = C. Timer2 Input, PPS Input Register.PPS Input Register = T2INPPS. Timer2 Input, Default Pin Selection at POR.Default Pin Selection at POR = RA5. Timer2 Input, 14-Pin Register Reset.at = 'b000. Timer2 Input, 14-Pin Register Reset.POR = 101. Timer2 Input, Devices Value Available. = A. Timer2 Input, Devices Value Available.Port = -. Timer2 Input, Devices Value Available. = C. Timer2 Input, Default Pin Selection at POR.Default Pin Selection at POR = RA5. Timer2 Input, 20-Pin Register Reset.at POR = 'b000. Timer2 Input, 20-Pin Register Reset. = 101.",
    "21.2 PPS Inputs\nTimer2 Input, Devices Value Available Port. = A. Timer2 Input, Devices Value Available Port. = B. Timer2 Input, Devices Value Available Port. = C. Timer4 Input, PPS Input Register.PPS Input Register = T4INPPS. Timer4 Input, Default Pin Selection at POR.Default Pin Selection at POR = RC1. Timer4 Input, 14-Pin Register Reset.at = 'b010. Timer4 Input, 14-Pin Register Reset.POR = 001. Timer4 Input, Devices Value Available. = A. Timer4 Input, Devices Value Available.Port = -. Timer4 Input, Devices Value Available. = C. Timer4 Input, Default Pin Selection at POR.Default Pin Selection at POR = RC1. Timer4 Input, 20-Pin Register Reset.at POR = 'b010. Timer4 Input, 20-Pin Register Reset. = 001. Timer4 Input, Devices Value Available Port. = A. Timer4 Input, Devices Value Available Port. = B. Timer4 Input, Devices Value Available Port. = C. CCP1, PPS Input Register.PPS Input Register = CCP1PPS. CCP1, Default Pin",
    "21.2 PPS Inputs\nSelection at POR.Default Pin Selection at POR = RC5. CCP1, 14-Pin Register Reset.at = 'b010. CCP1, 14-Pin Register Reset.POR = 101. CCP1, Devices Value Available. = A. CCP1, Devices Value Available.Port = -. CCP1, Devices Value Available. = C. CCP1, Default Pin Selection at POR.Default Pin Selection at POR = RC5. CCP1, 20-Pin Register Reset.at POR = 'b010. CCP1, 20-Pin Register Reset. = 101. CCP1, Devices Value Available Port. = A. CCP1, Devices Value Available Port. = B. CCP1, Devices Value Available Port. = C. SMT1 Window, PPS Input Register.PPS Input Register = SMT1WINPPS. SMT1 Window, Default Pin Selection at POR.Default Pin Selection at POR = RA5. SMT1 Window, 14-Pin Register Reset.at = 'b000. SMT1 Window, 14-Pin Register Reset.POR = 101. SMT1 Window, Devices Value Available. = A.",
    "21.2 PPS Inputs\nSMT1 Window, Devices Value Available.Port = -. SMT1 Window, Devices Value Available. = C. SMT1 Window, Default Pin Selection at POR.Default Pin Selection at POR = RA5. SMT1 Window, 20-Pin Register Reset.at POR = 'b000. SMT1 Window, 20-Pin Register Reset. = 101. SMT1 Window, Devices Value Available Port. = A. SMT1 Window, Devices Value Available Port. = B. SMT1 Window, Devices Value Available Port. = C. SMT1 Signal, PPS Input Register.PPS Input Register = SMT1SIGPPS. SMT1 Signal, Default Pin Selection at POR.Default Pin Selection at POR = RC0. SMT1 Signal, 14-Pin Register Reset.at = 'b010. SMT1 Signal, 14-Pin Register Reset.POR = 000. SMT1 Signal, Devices Value Available. = A. SMT1 Signal, Devices Value Available.Port = -. SMT1 Signal, Devices Value Available. = C. SMT1 Signal, Default Pin Selection at POR.Default Pin Selection at POR = RA4.",
    "21.2 PPS Inputs\nSMT1 Signal, 20-Pin Register Reset.at POR = 'b000. SMT1 Signal, 20-Pin Register Reset. = 100. SMT1 Signal, Devices Value Available Port. = A. SMT1 Signal, Devices Value Available Port. = B. SMT1 Signal, Devices Value Available Port. = C. PWMInput 0, PPS Input Register.PPS Input Register = PWMIN0PPS. PWMInput 0, Default Pin Selection at POR.Default Pin Selection at POR = RC5. PWMInput 0, 14-Pin Register Reset.at = 'b010. PWMInput 0, 14-Pin Register Reset.POR = 101. PWMInput 0, Devices Value Available. = A. PWMInput 0, Devices Value Available.Port = -. PWMInput 0, Devices Value Available. = C. PWMInput 0, Default Pin Selection at POR.Default Pin Selection at POR = RC5. PWMInput 0, 20-Pin Register Reset.at POR = 'b010. PWMInput 0, 20-Pin Register Reset. = 101. PWMInput",
    "21.2 PPS Inputs\n0, Devices Value Available Port. = A. PWMInput 0, Devices Value Available Port. = B. PWMInput 0, Devices Value Available Port. = C. PWMInput 1, PPS Input Register.PPS Input Register = PWMIN1PPS. PWMInput 1, Default Pin Selection at POR.Default Pin Selection at POR = RC3. PWMInput 1, 14-Pin Register Reset.at = 'b010. PWMInput 1, 14-Pin Register Reset.POR = 011. PWMInput 1, Devices Value Available. = A. PWMInput 1, Devices Value Available.Port = -. PWMInput 1, Devices Value Available. = C. PWMInput 1, Default Pin Selection at POR.Default Pin Selection at POR = RC3. PWMInput 1, 20-Pin Register Reset.at POR = 'b010. PWMInput 1, 20-Pin Register Reset. = 011. PWMInput 1, Devices Value Available Port. = A. PWMInput 1, Devices Value Available Port. = B. PWMInput 1, Devices Value",
    "21.2 PPS Inputs\nAvailable Port. = C. PWM1 External Reset Source, PPS Input Register.PPS Input Register = PWM1ERSPPS. PWM1 External Reset Source, Default Pin Selection at POR.Default Pin Selection at POR = RA5. PWM1 External Reset Source, 14-Pin Register Reset.at = 'b000. PWM1 External Reset Source, 14-Pin Register Reset.POR = 101. PWM1 External Reset Source, Devices Value Available. = A. PWM1 External Reset Source, Devices Value Available.Port = -. PWM1 External Reset Source, Devices Value Available. = C. PWM1 External Reset Source, Default Pin Selection at POR.Default Pin Selection at POR = RA5. PWM1 External Reset Source, 20-Pin Register Reset.at POR = 'b000. PWM1 External Reset Source, 20-Pin Register Reset. = 101. PWM1 External Reset Source, Devices Value Available Port. = A. PWM1 External Reset Source, Devices Value Available Port. = B. PWM1 External Reset Source, Devices Value Available Port. = C.",
    "21.2 PPS Inputs\nPWM2 External Reset Source, PPS Input Register.PPS Input Register = PWM2ERSPPS. PWM2 External Reset Source, Default Pin Selection at POR.Default Pin Selection at POR = RC1. PWM2 External Reset Source, 14-Pin Register Reset.at = 'b010. PWM2 External Reset Source, 14-Pin Register Reset.POR = 001. PWM2 External Reset Source, Devices Value Available. = A. PWM2 External Reset Source, Devices Value Available.Port = -. PWM2 External Reset Source, Devices Value Available. = C. PWM2 External Reset Source, Default Pin Selection at POR.Default Pin Selection at POR = RC1. PWM2 External Reset Source, 20-Pin Register Reset.at POR = 'b010. PWM2 External Reset Source, 20-Pin Register Reset. = 001. PWM2 External Reset Source, Devices Value Available Port. = A. PWM2 External Reset Source, Devices Value Available Port. = B. PWM2 External Reset Source, Devices Value Available Port. = C. PWM3 External Reset",
    "21.2 PPS Inputs\nSource, PPS Input Register.PPS Input Register = PWM3ERSPPS. PWM3 External Reset Source, Default Pin Selection at POR.Default Pin Selection at POR = RC2. PWM3 External Reset Source, 14-Pin Register Reset.at = 'b010. PWM3 External Reset Source, 14-Pin Register Reset.POR = 010. PWM3 External Reset Source, Devices Value Available. = A. PWM3 External Reset Source, Devices Value Available.Port = -. PWM3 External Reset Source, Devices Value Available. = C. PWM3 External Reset Source, Default Pin Selection at POR.Default Pin Selection at POR = RC2. PWM3 External Reset Source, 20-Pin Register Reset.at POR = 'b010. PWM3 External Reset Source, 20-Pin Register Reset. = 010. PWM3 External Reset Source, Devices Value Available Port. = A. PWM3 External Reset Source, Devices Value Available Port. = B. PWM3 External Reset Source, Devices Value Available Port. = C. CWG1, PPS Input Register.PPS",
    "21.2 PPS Inputs\nInput Register = CWG1PPS. CWG1, Default Pin Selection at POR.Default Pin Selection at POR = RA2. CWG1, 14-Pin Register Reset.at = 'b000. CWG1, 14-Pin Register Reset.POR = 010. CWG1, Devices Value Available. = A. CWG1, Devices Value Available.Port = -. CWG1, Devices Value Available. = C. CWG1, Default Pin Selection at POR.Default Pin Selection at POR = RA2. CWG1, 20-Pin Register Reset.at POR = 'b000. CWG1, 20-Pin Register Reset. = 010. CWG1, Devices Value Available Port. = A. CWG1, Devices Value Available Port. = B. CWG1, Devices Value Available Port. = C. DSM1 Carrier Low, PPS Input Register.PPS Input Register = MD1CARLPPS. DSM1 Carrier Low, Default Pin Selection at POR.Default Pin Selection at POR = RC2. DSM1 Carrier Low, 14-Pin Register Reset.at = 'b010. DSM1 Carrier Low,",
    "21.2 PPS Inputs\n14-Pin Register Reset.POR = 010. DSM1 Carrier Low, Devices Value Available. = A. DSM1 Carrier Low, Devices Value Available.Port = -. DSM1 Carrier Low, Devices Value Available. = C. DSM1 Carrier Low, Default Pin Selection at POR.Default Pin Selection at POR = RC2. DSM1 Carrier Low, 20-Pin Register Reset.at POR = 'b010. DSM1 Carrier Low, 20-Pin Register Reset. = 010. DSM1 Carrier Low, Devices Value Available Port. = A. DSM1 Carrier Low, Devices Value Available Port. = B. DSM1 Carrier Low, Devices Value Available Port. = C. DSM1 Carrier High, PPS Input Register.PPS Input Register = MD1CARHPPS. DSM1 Carrier High, Default Pin Selection at POR.Default Pin Selection at POR = RC5. DSM1 Carrier High, 14-Pin Register Reset.at = 'b010. DSM1 Carrier High, 14-Pin Register Reset.POR = 101. DSM1 Carrier High, Devices Value Available. = A. DSM1 Carrier High, Devices Value",
    "21.2 PPS Inputs\nAvailable.Port = -. DSM1 Carrier High, Devices Value Available. = C. DSM1 Carrier High, Default Pin Selection at POR.Default Pin Selection at POR = RC5. DSM1 Carrier High, 20-Pin Register Reset.at POR = 'b010. DSM1 Carrier High, 20-Pin Register Reset. = 101. DSM1 Carrier High, Devices Value Available Port. = A. DSM1 Carrier High, Devices Value Available Port. = B. DSM1 Carrier High, Devices Value Available Port. = C. DSM1 Source, PPS Input Register.PPS Input Register = MD1SRCPPS. DSM1 Source, Default Pin Selection at POR.Default Pin Selection at POR = RA1. DSM1 Source, 14-Pin Register Reset.at = 'b000. DSM1 Source, 14-Pin Register Reset.POR = 001. DSM1 Source, Devices Value Available. = A. DSM1 Source, Devices Value Available.Port = -. DSM1 Source, Devices Value Available. = C. DSM1 Source, Default Pin Selection at POR.Default Pin Selection at POR = RA1.",
    "21.2 PPS Inputs\nDSM1 Source, 20-Pin Register Reset.at POR = 'b000. DSM1 Source, 20-Pin Register Reset. = 001. DSM1 Source, Devices Value Available Port. = A. DSM1 Source, Devices Value Available Port. = B. DSM1 Source, Devices Value Available Port. = C. CLCx Input 1, PPS Input Register.PPS Input Register = CLCIN0PPS. CLCx Input 1, Default Pin Selection at POR.Default Pin Selection at POR = RC3. CLCx Input 1, 14-Pin Register Reset.at = 'b010. CLCx Input 1, 14-Pin Register Reset.POR = 011. CLCx Input 1, Devices Value Available. = A. CLCx Input 1, Devices Value Available.Port = -. CLCx Input 1, Devices Value Available. = C. CLCx Input 1, Default Pin Selection at POR.Default Pin Selection at POR = RA2. CLCx Input 1, 20-Pin Register Reset.at POR = 'b000. CLCx Input 1, 20-Pin Register Reset. = 010. CLCx",
    "21.2 PPS Inputs\nInput 1, Devices Value Available Port. = A. CLCx Input 1, Devices Value Available Port. = B. CLCx Input 1, Devices Value Available Port. = C. CLCx Input 2, PPS Input Register.PPS Input Register = CLCIN1PPS. CLCx Input 2, Default Pin Selection at POR.Default Pin Selection at POR = RC4. CLCx Input 2, 14-Pin Register Reset.at = 'b010. CLCx Input 2, 14-Pin Register Reset.POR = 100. CLCx Input 2, Devices Value Available. = A. CLCx Input 2, Devices Value Available.Port = -. CLCx Input 2, Devices Value Available. = C. CLCx Input 2, Default Pin Selection at POR.Default Pin Selection at POR = RC3. CLCx Input 2, 20-Pin Register Reset.at POR = 'b010. CLCx Input 2, 20-Pin Register Reset. = 011. CLCx Input 2, Devices Value Available Port. = A. CLCx Input 2, Devices Value Available Port. = B. CLCx Input 2, Devices Value Available",
    "21.2 PPS Inputs\nPort. = C. CLCx Input 3, PPS Input Register.PPS Input Register = CLCIN2PPS. CLCx Input 3, Default Pin Selection at POR.Default Pin Selection at POR = RC1. CLCx Input 3, 14-Pin Register Reset.at = 'b010. CLCx Input 3, 14-Pin Register Reset.POR = 001. CLCx Input 3, Devices Value Available. = A. CLCx Input 3, Devices Value Available.Port = -. CLCx Input 3, Devices Value Available. = C. CLCx Input 3, Default Pin Selection at POR.Default Pin Selection at POR = RB4. CLCx Input 3, 20-Pin Register Reset.at POR = 'b001. CLCx Input 3, 20-Pin Register Reset. = 100. CLCx Input 3, Devices Value Available Port. = A. CLCx Input 3, Devices Value Available Port. = B. CLCx Input 3, Devices Value Available Port. = C. CLCx Input 4, PPS Input Register.PPS Input Register = CLCIN3PPS. CLCx Input 4, Default Pin Selection",
    "21.2 PPS Inputs\nat POR.Default Pin Selection at POR = RA4. CLCx Input 4, 14-Pin Register Reset.at = 'b000. CLCx Input 4, 14-Pin Register Reset.POR = 100. CLCx Input 4, Devices Value Available. = A. CLCx Input 4, Devices Value Available.Port = -. CLCx Input 4, Devices Value Available. = C. CLCx Input 4, Default Pin Selection at POR.Default Pin Selection at POR = RB5. CLCx Input 4, 20-Pin Register Reset.at POR = 'b001. CLCx Input 4, 20-Pin Register Reset. = 101. CLCx Input 4, Devices Value Available Port. = A. CLCx Input 4, Devices Value Available Port. = B. CLCx Input 4, Devices Value Available Port. = C. ADC Conversion Trigger, PPS Input Register.PPS Input Register = ADACTPPS. ADC Conversion Trigger, Default Pin Selection at POR.Default Pin Selection at POR = RC2. ADC Conversion Trigger, 14-Pin Register Reset.at = 'b010. ADC Conversion Trigger, 14-Pin",
    "21.2 PPS Inputs\nRegister Reset.POR = 010. ADC Conversion Trigger, Devices Value Available. = A. ADC Conversion Trigger, Devices Value Available.Port = -. ADC Conversion Trigger, Devices Value Available. = C. ADC Conversion Trigger, Default Pin Selection at POR.Default Pin Selection at POR = RC2. ADC Conversion Trigger, 20-Pin Register Reset.at POR = 'b010. ADC Conversion Trigger, 20-Pin Register Reset. = 010. ADC Conversion Trigger, Devices Value Available Port. = A. ADC Conversion Trigger, Devices Value Available Port. = B. ADC Conversion Trigger, Devices Value Available Port. = C. SPI1 Clock SPI1 Data, PPS Input Register.PPS Input Register = SPI1SCKPPS. SPI1 Clock SPI1 Data, Default Pin Selection at POR.Default Pin Selection at POR = RC0 RC1. SPI1 Clock SPI1 Data, 14-Pin Register Reset.at = 'b010 'b010. SPI1 Clock SPI1 Data, 14-Pin Register Reset.POR = 000. SPI1 Clock SPI1 Data, Devices Value Available. =",
    "21.2 PPS Inputs\nA. SPI1 Clock SPI1 Data, Devices Value Available.Port = -. SPI1 Clock SPI1 Data, Devices Value Available. = C. SPI1 Clock SPI1 Data, Default Pin Selection at POR.Default Pin Selection at POR = RB6. SPI1 Clock SPI1 Data, 20-Pin Register Reset.at POR = 'b001. SPI1 Clock SPI1 Data, 20-Pin Register Reset. = 110. SPI1 Clock SPI1 Data, Devices Value Available Port. = A. SPI1 Clock SPI1 Data, Devices Value Available Port. = B. SPI1 Clock SPI1 Data, Devices Value Available Port. = C. Client, PPS Input Register.PPS Input Register = SPI1SDIPPS. Client, Default Pin Selection at POR.Default Pin Selection at POR = RC3. Client, 14-Pin Register Reset.at = 'b010. Client, 14-Pin Register Reset.POR = 001. Client, Devices Value Available. = A. Client, Devices Value Available.Port = -. Client, Devices Value Available. = C. Client, Default Pin Selection at",
    "21.2 PPS Inputs\nPOR.Default Pin Selection at POR = RB4. Client, 20-Pin Register Reset.at POR = 'b001. Client, 20-Pin Register Reset. = 100. Client, Devices Value Available Port. = A. Client, Devices Value Available Port. = B. Client, Devices Value Available Port. = C. SPI1 Select, PPS Input Register.PPS Input Register = SPI1SSPPS. SPI1 Select, Default Pin Selection at POR.Default Pin Selection at POR = . SPI1 Select, 14-Pin Register Reset.at = . SPI1 Select, 14-Pin Register Reset.POR = 011. SPI1 Select, Devices Value Available. = A. SPI1 Select, Devices Value Available.Port = -. SPI1 Select, Devices Value Available. = C. SPI1 Select, Default Pin Selection at POR.Default Pin Selection at POR = RC6. SPI1 Select, 20-Pin Register Reset.at POR = 'b010. SPI1 Select, 20-Pin Register Reset. = 110. SPI1 Select, Devices Value Available Port. = A. SPI1 Select, Devices Value Available Port.",
    "21.2 PPS Inputs\n= B. SPI1 Select, Devices Value Available Port. = C. SPI2 Clock, PPS Input Register.PPS Input Register = SPI2SCKPPS. SPI2 Clock, Default Pin Selection at POR.Default Pin Selection at POR = RC4. SPI2 Clock, 14-Pin Register Reset.at = 'b010. SPI2 Clock, 14-Pin Register Reset.POR = 100. SPI2 Clock, Devices Value Available. = A. SPI2 Clock, Devices Value Available.Port = -. SPI2 Clock, Devices Value Available. = C. SPI2 Clock, Default Pin Selection at POR.Default Pin Selection at POR = RB7. SPI2 Clock, 20-Pin Register Reset.at POR = 'b001. SPI2 Clock, 20-Pin Register Reset. = 111. SPI2 Clock, Devices Value Available Port. = A. SPI2 Clock, Devices Value Available Port. = B. SPI2 Clock, Devices Value Available Port. = C. SPI2 Data, PPS Input Register.PPS Input Register = SPI2SDIPPS. SPI2 Data, Default Pin Selection",
    "21.2 PPS Inputs\nat POR.Default Pin Selection at POR = RC5. SPI2 Data, 14-Pin Register Reset.at = 'b010. SPI2 Data, 14-Pin Register Reset.POR = 101. SPI2 Data, Devices Value Available. = A. SPI2 Data, Devices Value Available.Port = -. SPI2 Data, Devices Value Available. = C. SPI2 Data, Default Pin Selection at POR.Default Pin Selection at POR = RB5. SPI2 Data, 20-Pin Register Reset.at POR = 'b001. SPI2 Data, 20-Pin Register Reset. = 101. SPI2 Data, Devices Value Available Port. = A. SPI2 Data, Devices Value Available Port. = B. SPI2 Data, Devices Value Available Port. = C. SPI2 Client Select, PPS Input Register.PPS Input Register = SPI2SSPPS. SPI2 Client Select, Default Pin Selection at POR.Default Pin Selection at POR = RA0. SPI2 Client Select, 14-Pin Register Reset.at = 'b000. SPI2 Client Select, 14-Pin Register Reset.POR =",
    "21.2 PPS Inputs\n000. SPI2 Client Select, Devices Value Available. = A. SPI2 Client Select, Devices Value Available.Port = -. SPI2 Client Select, Devices Value Available. = C. SPI2 Client Select, Default Pin Selection at POR.Default Pin Selection at POR = RA1. SPI2 Client Select, 20-Pin Register Reset.at POR = 'b000. SPI2 Client Select, 20-Pin Register Reset. = 001. SPI2 Client Select, Devices Value Available Port. = A. SPI2 Client Select, Devices Value Available Port. = B. SPI2 Client Select, Devices Value Available Port. = C. I2C1 Clock, PPS Input Register.PPS Input Register = I2C1SCLPPS (1). I2C1 Clock, Default Pin Selection at POR.Default Pin Selection at POR = RC0. I2C1 Clock, 14-Pin Register Reset.at = 'b010. I2C1 Clock, 14-Pin Register Reset.POR = 000. I2C1 Clock, Devices Value Available. = A. I2C1 Clock, Devices Value Available.Port = -.",
    "21.2 PPS Inputs\nI2C1 Clock, Devices Value Available. = C. I2C1 Clock, Default Pin Selection at POR.Default Pin Selection at POR = RB6. I2C1 Clock, 20-Pin Register Reset.at POR = 'b001. I2C1 Clock, 20-Pin Register Reset. = 110. I2C1 Clock, Devices Value Available Port. = A. I2C1 Clock, Devices Value Available Port. = B. I2C1 Clock, Devices Value Available Port. = C. I2C1 Data, PPS Input Register.PPS Input Register = I2C1SDAPPS (1). I2C1 Data, Default Pin Selection at POR.Default Pin Selection at POR = RC1. I2C1 Data, 14-Pin Register Reset.at = 'b010. I2C1 Data, 14-Pin Register Reset.POR = 001. I2C1 Data, Devices Value Available. = A. I2C1 Data, Devices Value Available.Port = -. I2C1 Data, Devices Value Available. = C. I2C1 Data, Default Pin Selection at POR.Default Pin Selection at",
    "21.2 PPS Inputs\nPOR = RB4. I2C1 Data, 20-Pin Register Reset.at POR = 'b001. I2C1 Data, 20-Pin Register Reset. = 100. I2C1 Data, Devices Value Available Port. = A. I2C1 Data, Devices Value Available Port. = B. I2C1 Data, Devices Value Available Port. = C. UART1 Receive, PPS Input Register.PPS Input Register = U1RXPPS. UART1 Receive, Default Pin Selection at POR.Default Pin Selection at POR = RC5. UART1 Receive, 14-Pin Register Reset.at = 'b010. UART1 Receive, 14-Pin Register Reset.POR = 101. UART1 Receive, Devices Value Available. = A. UART1 Receive, Devices Value Available.Port = -. UART1 Receive, Devices Value Available. = C. UART1 Receive, Default Pin Selection at POR.Default Pin Selection at POR = RB5. UART1 Receive, 20-Pin Register Reset.at POR = 'b001. UART1 Receive, 20-Pin Register Reset. = 101. UART1",
    "21.2 PPS Inputs\nReceive, Devices Value Available Port. = A. UART1 Receive, Devices Value Available Port. = B. UART1 Receive, Devices Value Available Port. = C. UART1 Clear to Send, PPS Input Register.PPS Input Register = U1CTSPPS. UART1 Clear to Send, Default Pin Selection at POR.Default Pin Selection at POR = RC4. UART1 Clear to Send, 14-Pin Register Reset.at = 'b010. UART1 Clear to Send, 14-Pin Register Reset.POR = 100. UART1 Clear to Send, Devices Value Available. = A. UART1 Clear to Send, Devices Value Available.Port = -. UART1 Clear to Send, Devices Value Available. = C. UART1 Clear to Send, Default Pin Selection at POR.Default Pin Selection at POR = RB7. UART1 Clear to Send, 20-Pin Register Reset.at POR = 'b001. UART1 Clear to Send, 20-Pin Register Reset. = 111. UART1 Clear to Send, Devices Value Available Port. = A. UART1 Clear to Send, Devices Value Available Port. = B.",
    "21.2 PPS Inputs\nUART1 Clear to Send, Devices Value Available Port. = C. UART2 Receive UART2 Clear to, PPS Input Register.PPS Input Register = U2RXPPS U2CTSPPS. UART2 Receive UART2 Clear to, Default Pin Selection at POR.Default Pin Selection at POR = RC1 RC2. UART2 Receive UART2 Clear to, 14-Pin Register Reset.at = 'b010 'b010. UART2 Receive UART2 Clear to, 14-Pin Register Reset.POR = 001. UART2 Receive UART2 Clear to, Devices Value Available. = A A. UART2 Receive UART2 Clear to, Devices Value Available.Port = - -. UART2 Receive UART2 Clear to, Devices Value Available. = C C. UART2 Receive UART2 Clear to, Default Pin Selection at POR.Default Pin Selection at POR = RC1 RC2. UART2 Receive UART2 Clear to, 20-Pin Register Reset.at POR = 'b010 'b010. UART2 Receive UART2 Clear to, 20-Pin Register Reset. = 001 010.",
    "21.2 PPS Inputs\nUART2 Receive UART2 Clear to, Devices Value Available Port. = A A. UART2 Receive UART2 Clear to, Devices Value Available Port. = B B. UART2 Receive UART2 Clear to, Devices Value Available Port. = C C. Send UART3 Receive, PPS Input Register.PPS Input Register = U3RXPPS. Send UART3 Receive, Default Pin Selection at POR.Default Pin Selection at POR = . Send UART3 Receive, 14-Pin Register Reset.at = . Send UART3 Receive, 14-Pin Register Reset.POR = 010. Send UART3 Receive, Devices Value Available. = A. Send UART3 Receive, Devices Value Available.Port = -. Send UART3 Receive, Devices Value Available. = C. Send UART3 Receive, Default Pin Selection at POR.Default Pin Selection at POR = RC3. Send UART3 Receive, 20-Pin Register Reset.at POR = 'b010. Send UART3 Receive, 20-Pin Register Reset. = 011. Send UART3 Receive, Devices Value Available Port. = A. Send UART3 Receive, Devices Value Available",
    "21.2 PPS Inputs\nPort. = B. Send UART3 Receive, Devices Value Available Port. = C. UART3 Clear to, PPS Input Register.PPS Input Register = . UART3 Clear to, Default Pin Selection at POR.Default Pin Selection at POR = RA4. UART3 Clear to, 14-Pin Register Reset.at = 'b000. UART3 Clear to, 14-Pin Register Reset.POR = 100. UART3 Clear to, Devices Value Available. = . UART3 Clear to, Devices Value Available.Port = . UART3 Clear to, Devices Value Available. = . UART3 Clear to, Default Pin Selection at POR.Default Pin Selection at POR = . UART3 Clear to, 20-Pin Register Reset.at POR = . UART3 Clear to, 20-Pin Register Reset. = . UART3 Clear to, Devices Value Available Port. = . UART3 Clear to, Devices Value Available Port. = . UART3 Clear to, Devices Value Available Port. = . Send, PPS Input Register.PPS Input Register = U3CTSPPS. Send, Default Pin Selection at POR.Default Pin Selection at POR =",
    "21.2 PPS Inputs\nRA5. Send, 14-Pin Register Reset.at = 'b000. Send, 14-Pin Register Reset.POR = 101. Send, Devices Value Available. = A. Send, Devices Value Available.Port = -. Send, Devices Value Available. = C. Send, Default Pin Selection at POR.Default Pin Selection at POR = RC5. Send, 20-Pin Register Reset.at POR = 'b010. Send, 20-Pin Register Reset. = 101. Send, Devices Value Available Port. = A. Send, Devices Value Available Port. = B. Send, Devices Value Available Port. = C",
    "Note:\n- 1. Bidirectional pin. The corresponding output must select the same pin.",
    "21.3 PPS Outputs\nEach digital peripheral has a dedicated Pin Rxy Output Source Selection (RxyPPS) register with which the pin output source is selected. With few exceptions, the port TRIS control associated with that pin retains control over the pin output driver. Peripherals that control the pin output driver as part of the peripheral operation will override the TRIS control as needed. The I 2 C module is an example of such a peripheral.\nImportant: The notation 'Rxy' is a placeholder for the pin identifier. The 'x' holds the place of the PORT letter and the 'y' holds the place of the bit number. For example, Rxy = RA0 for the RA0PPS register.\nThe table below shows the output codes for each peripheral, as well as the available Port selections.\n\nTable 21-2. PPS Output Selection Table",
    "21.3 PPS Outputs\n0x27, Output Source.ADGRDB = ADGRDA. 0x27, Available Output Ports 20-Pin Devices.A = A. 0x27, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x27, Available Output Ports 20-Pin Devices.C = C. 0x27, Available Output Ports 20-Pin Devices.A = A. 0x27, Available Output Ports 20-Pin Devices.B = B. 0x27, Available Output Ports 20-Pin Devices.C = C. 0x26, Output Source.ADGRDB = DSM1. 0x26, Available Output Ports 20-Pin Devices.A = A. 0x26, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x26, Available Output Ports 20-Pin Devices.C = C. 0x26, Available Output Ports 20-Pin Devices.A = A. 0x26, Available Output Ports 20-Pin Devices.B = B. 0x26, Available Output Ports 20-Pin Devices.C = C. 0x25, Output Source.ADGRDB = CLKR. 0x25, Available Output",
    "21.3 PPS Outputs\nPorts 20-Pin Devices.A = A. 0x25, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x25, Available Output Ports 20-Pin Devices.C = C. 0x25, Available Output Ports 20-Pin Devices.A = A. 0x25, Available Output Ports 20-Pin Devices.B = B. 0x25, Available Output Ports 20-Pin Devices.C = C. 0x24, Output Source.ADGRDB = NCO1. 0x24, Available Output Ports 20-Pin Devices.A = A. 0x24, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x24, Available Output Ports 20-Pin Devices.C = C. 0x24, Available Output Ports 20-Pin Devices.A = A. 0x24, Available Output Ports 20-Pin Devices.B = B. 0x24, Available Output Ports 20-Pin Devices.C = C. 0x23, Output Source.ADGRDB = TMR0. 0x23, Available Output Ports 20-Pin Devices.A = A. 0x23, Available Output Ports",
    "21.3 PPS Outputs\n20-Pin Devices.14-Pin Devices - = -. 0x23, Available Output Ports 20-Pin Devices.C = C. 0x23, Available Output Ports 20-Pin Devices.A = A. 0x23, Available Output Ports 20-Pin Devices.B = B. 0x23, Available Output Ports 20-Pin Devices.C = C. 0x22, Output Source.ADGRDB = I2C1 SDA (1). 0x22, Available Output Ports 20-Pin Devices.A = A. 0x22, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x22, Available Output Ports 20-Pin Devices.C = C. 0x22, Available Output Ports 20-Pin Devices.A = A. 0x22, Available Output Ports 20-Pin Devices.B = B. 0x22, Available Output Ports 20-Pin Devices.C = C. 0x21, Output Source.ADGRDB = I2C1 SCL (1). 0x21, Available Output Ports 20-Pin Devices.A = A. 0x21, Available Output Ports 20-Pin Devices.14-Pin",
    "21.3 PPS Outputs\nDevices - = -. 0x21, Available Output Ports 20-Pin Devices.C = C. 0x21, Available Output Ports 20-Pin Devices.A = A. 0x21, Available Output Ports 20-Pin Devices.B = B. 0x21, Available Output Ports 20-Pin Devices.C = C. 0x20, Output Source.ADGRDB = SPI2 SS. 0x20, Available Output Ports 20-Pin Devices.A = A. 0x20, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x20, Available Output Ports 20-Pin Devices.C = C. 0x20, Available Output Ports 20-Pin Devices.A = A. 0x20, Available Output Ports 20-Pin Devices.B = B. 0x20, Available Output Ports 20-Pin Devices.C = C. 0x1F, Output Source.ADGRDB = SPI2 SDO. 0x1F, Available Output Ports 20-Pin Devices.A = A. 0x1F, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x1F, Available Output Ports",
    "21.3 PPS Outputs\n20-Pin Devices.C = C. 0x1F, Available Output Ports 20-Pin Devices.A = A. 0x1F, Available Output Ports 20-Pin Devices.B = B. 0x1F, Available Output Ports 20-Pin Devices.C = C. 0x1E, Output Source.ADGRDB = SPI2 SCK. 0x1E, Available Output Ports 20-Pin Devices.A = A. 0x1E, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x1E, Available Output Ports 20-Pin Devices.C = C. 0x1E, Available Output Ports 20-Pin Devices.A = A. 0x1E, Available Output Ports 20-Pin Devices.B = B. 0x1E, Available Output Ports 20-Pin Devices.C = C. 0x1D, Output Source.ADGRDB = SPI1 SS. 0x1D, Available Output Ports 20-Pin Devices.A = A. 0x1D, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x1D, Available Output Ports 20-Pin",
    "21.3 PPS Outputs\nDevices.C = C. 0x1D, Available Output Ports 20-Pin Devices.A = A. 0x1D, Available Output Ports 20-Pin Devices.B = B. 0x1D, Available Output Ports 20-Pin Devices.C = C. 0x1C, Output Source.ADGRDB = SPI1 SDO. 0x1C, Available Output Ports 20-Pin Devices.A = A. 0x1C, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x1C, Available Output Ports 20-Pin Devices.C = C. 0x1C, Available Output Ports 20-Pin Devices.A = A. 0x1C, Available Output Ports 20-Pin Devices.B = B. 0x1C, Available Output Ports 20-Pin Devices.C = C. 0x1B, Output Source.ADGRDB = SPI1 SCK. 0x1B, Available Output Ports 20-Pin Devices.A = A. 0x1B, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x1B, Available Output Ports 20-Pin",
    "21.3 PPS Outputs\nDevices.C = C. 0x1B, Available Output Ports 20-Pin Devices.A = A. 0x1B, Available Output Ports 20-Pin Devices.B = B. 0x1B, Available Output Ports 20-Pin Devices.C = C. 0x1A, Output Source.ADGRDB = C2OUT. 0x1A, Available Output Ports 20-Pin Devices.A = A. 0x1A, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x1A, Available Output Ports 20-Pin Devices.C = C. 0x1A, Available Output Ports 20-Pin Devices.A = A. 0x1A, Available Output Ports 20-Pin Devices.B = B. 0x1A, Available Output Ports 20-Pin Devices.C = C. 0x19, Output Source.ADGRDB = C1OUT. 0x19, Available Output Ports 20-Pin Devices.A = A. 0x19, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x19, Available Output Ports 20-Pin Devices.C = C. 0x19, Available Output",
    "21.3 PPS Outputs\nPorts 20-Pin Devices.A = A. 0x19, Available Output Ports 20-Pin Devices.B = B. 0x19, Available Output Ports 20-Pin Devices.C = C. 0x18, Output Source.ADGRDB = UART3 RTS. 0x18, Available Output Ports 20-Pin Devices.A = A. 0x18, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x18, Available Output Ports 20-Pin Devices.C = C. 0x18, Available Output Ports 20-Pin Devices.A = A. 0x18, Available Output Ports 20-Pin Devices.B = B. 0x18, Available Output Ports 20-Pin Devices.C = C. 0x17, Output Source.ADGRDB = UART3 TXDE. 0x17, Available Output Ports 20-Pin Devices.A = A. 0x17, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x17, Available Output Ports 20-Pin Devices.C = C. 0x17, Available Output Ports 20-Pin Devices.A = A. 0x17, Available Output",
    "21.3 PPS Outputs\nPorts 20-Pin Devices.B = B. 0x17, Available Output Ports 20-Pin Devices.C = C. 0x16, Output Source.ADGRDB = UART3 TX. 0x16, Available Output Ports 20-Pin Devices.A = A. 0x16, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x16, Available Output Ports 20-Pin Devices.C = C. 0x16, Available Output Ports 20-Pin Devices.A = A. 0x16, Available Output Ports 20-Pin Devices.B = B. 0x16, Available Output Ports 20-Pin Devices.C = C. 0x15, Output Source.ADGRDB = UART2 RTS. 0x15, Available Output Ports 20-Pin Devices.A = A. 0x15, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x15, Available Output Ports 20-Pin Devices.C = C. 0x15, Available Output Ports 20-Pin Devices.A = A. 0x15, Available Output Ports 20-Pin Devices.B = B. 0x15, Available Output Ports",
    "21.3 PPS Outputs\n20-Pin Devices.C = C. 0x14, Output Source.ADGRDB = UART2 TXDE. 0x14, Available Output Ports 20-Pin Devices.A = A. 0x14, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x14, Available Output Ports 20-Pin Devices.C = C. 0x14, Available Output Ports 20-Pin Devices.A = A. 0x14, Available Output Ports 20-Pin Devices.B = B. 0x14, Available Output Ports 20-Pin Devices.C = C. 0x13, Output Source.ADGRDB = UART2 TX. 0x13, Available Output Ports 20-Pin Devices.A = A. 0x13, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x13, Available Output Ports 20-Pin Devices.C = C. 0x13, Available Output Ports 20-Pin Devices.A = A. 0x13, Available Output Ports 20-Pin Devices.B = B. 0x13, Available Output Ports 20-Pin Devices.C = C. 0x12, Output",
    "21.3 PPS Outputs\nSource.ADGRDB = UART1 RTS. 0x12, Available Output Ports 20-Pin Devices.A = A. 0x12, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x12, Available Output Ports 20-Pin Devices.C = C. 0x12, Available Output Ports 20-Pin Devices.A = A. 0x12, Available Output Ports 20-Pin Devices.B = B. 0x12, Available Output Ports 20-Pin Devices.C = C. 0x11, Output Source.ADGRDB = UART1 TXDE. 0x11, Available Output Ports 20-Pin Devices.A = A. 0x11, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x11, Available Output Ports 20-Pin Devices.C = C. 0x11, Available Output Ports 20-Pin Devices.A = A. 0x11, Available Output Ports 20-Pin Devices.B = B. 0x11, Available Output Ports 20-Pin Devices.C = C. 0x10, Output Source.ADGRDB = UART1 TX. 0x10, Available",
    "21.3 PPS Outputs\nOutput Ports 20-Pin Devices.A = A. 0x10, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x10, Available Output Ports 20-Pin Devices.C = C. 0x10, Available Output Ports 20-Pin Devices.A = A. 0x10, Available Output Ports 20-Pin Devices.B = B. 0x10, Available Output Ports 20-Pin Devices.C = C. 0x0F, Output Source.ADGRDB = PWM3S1P2_OUT. 0x0F, Available Output Ports 20-Pin Devices.A = A. 0x0F, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x0F, Available Output Ports 20-Pin Devices.C = C. 0x0F, Available Output Ports 20-Pin Devices.A = A. 0x0F, Available Output Ports 20-Pin Devices.B = B. 0x0F, Available Output Ports 20-Pin Devices.C = C. 0x0E, Output Source.ADGRDB = PWM3S1P1_OUT.",
    "21.3 PPS Outputs\n0x0E, Available Output Ports 20-Pin Devices.A = A. 0x0E, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x0E, Available Output Ports 20-Pin Devices.C = C. 0x0E, Available Output Ports 20-Pin Devices.A = A. 0x0E, Available Output Ports 20-Pin Devices.B = B. 0x0E, Available Output Ports 20-Pin Devices.C = C. 0x0D, Output Source.ADGRDB = PWM2S1P2_OUT. 0x0D, Available Output Ports 20-Pin Devices.A = A. 0x0D, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x0D, Available Output Ports 20-Pin Devices.C = C. 0x0D, Available Output Ports 20-Pin Devices.A = A. 0x0D, Available Output Ports 20-Pin Devices.B = B. 0x0D, Available Output Ports 20-Pin Devices.C = C. 0x0C, Output Source.ADGRDB =",
    "21.3 PPS Outputs\nPWM2S1P1_OUT. 0x0C, Available Output Ports 20-Pin Devices.A = A. 0x0C, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x0C, Available Output Ports 20-Pin Devices.C = C. 0x0C, Available Output Ports 20-Pin Devices.A = A. 0x0C, Available Output Ports 20-Pin Devices.B = B. 0x0C, Available Output Ports 20-Pin Devices.C = C. 0x0B, Output Source.ADGRDB = PWM1S1P2_OUT. 0x0B, Available Output Ports 20-Pin Devices.A = A. 0x0B, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x0B, Available Output Ports 20-Pin Devices.C = C. 0x0B, Available Output Ports 20-Pin Devices.A = A. 0x0B, Available Output Ports 20-Pin Devices.B = B. 0x0B, Available Output Ports 20-Pin Devices.C = C.",
    "21.3 PPS Outputs\n0x0A, Output Source.ADGRDB = PWM1S1P1_OUT. 0x0A, Available Output Ports 20-Pin Devices.A = A. 0x0A, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x0A, Available Output Ports 20-Pin Devices.C = C. 0x0A, Available Output Ports 20-Pin Devices.A = A. 0x0A, Available Output Ports 20-Pin Devices.B = B. 0x0A, Available Output Ports 20-Pin Devices.C = C. 0x09, Output Source.ADGRDB = CCP1. 0x09, Available Output Ports 20-Pin Devices.A = A. 0x09, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x09, Available Output Ports 20-Pin Devices.C = C. 0x09, Available Output Ports 20-Pin Devices.A = A. 0x09, Available Output Ports 20-Pin Devices.B = B. 0x09, Available Output Ports 20-Pin Devices.C =",
    "21.3 PPS Outputs\nC. 0x08, Output Source.ADGRDB = CWG1D. 0x08, Available Output Ports 20-Pin Devices.A = A. 0x08, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x08, Available Output Ports 20-Pin Devices.C = C. 0x08, Available Output Ports 20-Pin Devices.A = A. 0x08, Available Output Ports 20-Pin Devices.B = B. 0x08, Available Output Ports 20-Pin Devices.C = C. 0x07, Output Source.ADGRDB = CWG1C. 0x07, Available Output Ports 20-Pin Devices.A = A. 0x07, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x07, Available Output Ports 20-Pin Devices.C = C. 0x07, Available Output Ports 20-Pin Devices.A = A. 0x07, Available Output Ports 20-Pin Devices.B = B. 0x07, Available Output Ports 20-Pin Devices.C = C.",
    "21.3 PPS Outputs\n0x06, Output Source.ADGRDB = CWG1B. 0x06, Available Output Ports 20-Pin Devices.A = A. 0x06, Available Output Ports 20-Pin Devices.14-Pin Devices - = -. 0x06, Available Output Ports 20-Pin Devices.C = C. 0x06, Available Output Ports 20-Pin Devices.A = A. 0x06, Available Output Ports 20-Pin Devices.B = B. 0x06, Available Output Ports 20-Pin Devices.C = C",
    "21.3 PPS Outputs\n0x04, ...........continued.Output Source = CLC4OUT. 0x04, ...........continued.Available Output 14-Pin Devices = A. 0x04, ...........continued.Available Output 14-Pin Devices = -. 0x04, ...........continued.Available Output 14-Pin Devices = C. 0x04, ...........continued.Ports 20-Pin Devices = A. 0x04, ...........continued.Ports 20-Pin Devices = B. 0x04, ...........continued.Ports 20-Pin Devices = C. 0x03, ...........continued.Output Source = CLC3OUT. 0x03, ...........continued.Available Output 14-Pin Devices = A. 0x03,",
    "21.3 PPS Outputs\n...........continued.Available Output 14-Pin Devices = -. 0x03, ...........continued.Available Output 14-Pin Devices = C. 0x03, ...........continued.Ports 20-Pin Devices = A. 0x03, ...........continued.Ports 20-Pin Devices = B. 0x03, ...........continued.Ports 20-Pin Devices = C. 0x02, ...........continued.Output Source = CLC2OUT. 0x02, ...........continued.Available Output 14-Pin Devices = A. 0x02, ...........continued.Available Output 14-Pin Devices = -. 0x02, ...........continued.Available Output 14-Pin Devices = C. 0x02,",
    "21.3 PPS Outputs\n...........continued.Ports 20-Pin Devices = A. 0x02, ...........continued.Ports 20-Pin Devices = B. 0x02, ...........continued.Ports 20-Pin Devices = C. 0x01, ...........continued.Output Source = CLC1OUT. 0x01, ...........continued.Available Output 14-Pin Devices = A. 0x01, ...........continued.Available Output 14-Pin Devices = -. 0x01, ...........continued.Available Output 14-Pin Devices = C. 0x01, ...........continued.Ports 20-Pin Devices = A. 0x01, ...........continued.Ports 20-Pin Devices = B. 0x01, ...........continued.Ports 20-Pin Devices =",
    "21.3 PPS Outputs\nC. 0x00, ...........continued.Output Source = LATxy. 0x00, ...........continued.Available Output 14-Pin Devices = A. 0x00, ...........continued.Available Output 14-Pin Devices = -. 0x00, ...........continued.Available Output 14-Pin Devices = C. 0x00, ...........continued.Ports 20-Pin Devices = A. 0x00, ...........continued.Ports 20-Pin Devices = B. 0x00, ...........continued.Ports 20-Pin Devices = C",
    "Note:\n- 1. Bidirectional pin. The corresponding input must select the same pin.",
    "21.4 Bidirectional Pins\nPPS selections for peripherals with bidirectional signals on a single pin must be made so that the PPS input and PPS output select the same pin. The I 2 C Serial Clock (SCL) and Serial Data (SDA) are examples of such pins.\nImportant: The I 2 C default pins and a limited number of other alternate pins are I 2 C and SMBus compatible. SDA and SCL signals can be routed to any pin; however, pins without I 2 C compatibility will operate at standard TTL/ST logic levels as selected by the port's INLVL register.",
    "21.5 PPS Lock\nThe PPS module provides an extra layer of protection to prevent inadvertent changes to the PPS selection registers. The PPSLOCKED bit is used in combination with specific code execution blocks to lock/unlock the PPS selection registers.\nImportant: The PPSLOCKED bit is clear by default (PPSLOCKED = 0 ), which allows the PPS selection registers to be modified without an unlock sequence.\nPPS selection registers are locked when the PPSLOCKED bit is set (PPSLOCKED = 1 ). Setting the PPSLOCKED bit requires a specific lock sequence as shown in the examples below in both C and assembly languages.\nPPS selection registers are unlocked when the PPSLOCKED bit is clear (PPSLOCKED = 0 ). Clearing the PPSLOCKED bit requires a specific unlock sequence as shown in the examples below in both C and assembly languages.\nImportant: All interrupts must be disabled before starting the lock/unlock sequence to ensure proper execution.\n```\n; restore interrupts BSF      INTCON0,GIE\n```",
    "Example 21-2. PPS Lock Sequence (C language)\n```\nINTCON0bits.GIE = 0; //Suspend interrupts PPSLOCK = 0x55; //Required sequence PPSLOCK = 0xAA; //Required sequence PPSLOCKbits.PPSLOCKED = 1; //Set PPSLOCKED bit INTCON0bits.GIE = 1; //Restore interrupts\n```",
    "Example 21-3. PPS Unlock Sequence (assembly language)\n```\n; suspend interrupts BCF      INTCON0,GIE BANKSEL  PPSLOCK ; required sequence, next 5 instructions MOVLW    0x55 MOVWF    PPSLOCK MOVLW    0xAA MOVWF    PPSLOCK ; Clear PPSLOCKED bit BCF      PPSLOCK,PPSLOCKED ; restore interrupts BSF      INTCON0,GIE\n```",
    "Example 21-4. PPS Unlock Sequence (C language)\n```\nINTCON0bits.GIE = 0; //Suspend interrupts PPSLOCK = 0x55; //Required sequence PPSLOCK = 0xAA; //Required sequence PPSLOCKbits.PPSLOCKED = 0; //Clear PPSLOCKED bit INTCON0bits.GIE = 1; //Restore interrupts\n```",
    "21.5.1 PPS One-Way Lock\nThe PPS1WAY Configuration bit can also be used to prevent inadvertent modification to the PPS selection registers.\nWhen the PPS1WAY bit is set (PPS1WAY = 1 ), the PPSLOCKED bit can only be set one time after a device Reset. Once the PPSLOCKED bit has been set, it cannot be cleared again unless a device Reset is executed.\nWhen the PPS1WAY bit is clear (PPS1WAY = 0 ), the PPSLOCKED bit can be set or cleared as needed; however, the PPS lock/unlock sequences must be executed.",
    "21.6 Operation During Sleep\nPPS input and output selections are unaffected by Sleep.",
    "21.7 Effects of a Reset\nA device Power-on Reset (POR) or Brown-out Reset (BOR) returns all PPS input selection registers to their default values and clears all PPS output selection registers. All other Resets leave the selections unchanged. Default input selections are shown in the PPS input register details table. The PPSLOCKED bit is cleared in all Reset conditions.",
    "21.8.1 xxxPPS\nName:\nxxxPPS\nPeripheral Input Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = PORT[2:0]. , 4 = PORT[2:0]. , 5 = PORT[2:0]. , 6 = PIN[2:0]. , 7 = PIN[2:0]. , 8 = PIN[2:0]. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = m. Reset, 4 = m. Reset, 5 = m. Reset, 6 = m. Reset, 7 = m. Reset, 8 = m",
    "Bits 5:3 - PORT[2:0]  Peripheral Input PORT Selection (1)\nSee the PPS Input Selection Table for the list of available Ports and default pin locations.\n010, Selection = PORTC. 001, Selection = PORTB. 000, Selection = PORTA\nReset States: POR = mmm\nAll other Resets = uuu",
    "Bits 2:0 - PIN[2:0]  Peripheral Input PORT Pin Selection (2)\nReset States: POR = mmm\nAll other Resets = uuu\n111, Description = Peripheral input is from PORTx Pin 7 (Rx7). 110, Description = Peripheral input is from PORTx Pin 6 (Rx6). 101, Description = Peripheral input is from PORTx Pin 5 (Rx5). 100, Description = Peripheral input is from PORTx Pin 4 (Rx4). 011, Description = Peripheral input is from PORTx Pin 3 (Rx3). 010, Description = Peripheral input is from PORTx Pin 2 (Rx2). 001, Description = Peripheral input is from PORTx Pin 1 (Rx1). 000, Description = Peripheral input is from PORTx Pin 0 (Rx0)",
    "Notes:\n1. The Reset value 'm' is determined by device default locations for that input.\n2. Refer to the 'Pin Allocation Table' for details about available pins per port.",
    "21.8.2 RxyPPS\nName:\nRxyPPS\nPin Rxy Output Source Selection Register",
    "21.8.2 RxyPPS\nBit, 1 = 6. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = . Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = RxyPPS[6:0]. , 3 = RxyPPS[6:0]. , 4 = RxyPPS[6:0]. , 5 = RxyPPS[6:0]. , 6 = RxyPPS[6:0]. , 7 = RxyPPS[6:0]. , 8 = RxyPPS[6:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 6:0 - RxyPPS[6:0] Pin Rxy Output Source Selection\nSee the PPS Output Selection Table for the list of RxyPPS Output Source codes\nReset States: POR = 0000000\nAll other Resets = uuuuuuu",
    "21.8.3 PPSLOCK\nName:\nPPSLOCK\nPPS Lock Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nPPSLOCKED\nAccess Reset\nR/W\n0",
    "Bit 0 - PPSLOCKED PPS Locked\nReset States: POR = 0\nAll other Resets = 0\n1, Description = PPS is locked. PPS selections cannot be changed. Writes to any PPS register are ignored.. 0, Description = PPS is not locked. PPS selections can be changed but may require the PPS lock/unlock sequence.",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x00, Name = Reserved. 0x00, Bit Pos. = . 0x00, 7 = . 0x00, 6 = . 0x00, 4 = . 0x00, 3 = . 0x00, 1 = . 0x00, 0 = . ... 0x01FF, Name = . ... 0x01FF, Bit Pos. = . ... 0x01FF, 7 = . ... 0x01FF, 6 = . ... 0x01FF, 4 = . ... 0x01FF, 3 = . ... 0x01FF, 1 = . ... 0x01FF, 0 = . 0x0200, Name = PPSLOCK. 0x0200, Bit Pos. = 7:0. 0x0200, 7 = . 0x0200, 6 = . 0x0200, 4 = . 0x0200, 3 = . 0x0200, 1 = . 0x0200, 0 = PPSLOCKED. 0x0201, Name = RA0PPS. 0x0201,",
    "21.9 Register Summary - Peripheral Pin Select Module\nBit Pos. = 7:0. 0x0201, 7 = . 0x0201, 6 = . 0x0201, 4 = . 0x0201, 3 = RA0PPS[5:0]. 0x0201, 1 = . 0x0201, 0 = . 0x0202, Name = RA1PPS. 0x0202, Bit Pos. = 7:0. 0x0202, 7 = . 0x0202, 6 = . 0x0202, 4 = . 0x0202, 3 = RA1PPS[5:0]. 0x0202, 1 = . 0x0202, 0 = . 0x0203, Name = RA2PPS. 0x0203, Bit Pos. = 7:0. 0x0203, 7 = . 0x0203, 6 = . 0x0203, 4 = . 0x0203, 3 = RA2PPS[5:0]. 0x0203, 1 = . 0x0203,",
    "21.9 Register Summary - Peripheral Pin Select Module\n0 = . 0x0204, Name = Reserved. 0x0204, Bit Pos. = . 0x0204, 7 = . 0x0204, 6 = . 0x0204, 4 = . 0x0204, 3 = . 0x0204, 1 = . 0x0204, 0 = . 0x0205, Name = RA4PPS. 0x0205, Bit Pos. = 7:0. 0x0205, 7 = . 0x0205, 6 = . 0x0205, 4 = . 0x0205, 3 = RA4PPS[5:0]. 0x0205, 1 = . 0x0205, 0 = . 0x0206, Name = RA5PPS. 0x0206, Bit Pos. = 7:0. 0x0206, 7 = . 0x0206, 6 = . 0x0206, 4 = . 0x0206, 3 = RA5PPS[5:0]. 0x0206, 1",
    "21.9 Register Summary - Peripheral Pin Select Module\n= . 0x0206, 0 = . 0x0207, Name = Reserved. 0x0207, Bit Pos. = . 0x0207, 7 = . 0x0207, 6 = . 0x0207, 4 = . 0x0207, 3 = . 0x0207, 1 = . 0x0207, 0 = . ... 0x020C, Name = . ... 0x020C, Bit Pos. = . ... 0x020C, 7 = . ... 0x020C, 6 = . ... 0x020C, 4 = . ... 0x020C, 3 = . ... 0x020C, 1 = . ... 0x020C, 0 = . 0x020D, Name = RB4PPS. 0x020D, Bit Pos. = 7:0. 0x020D, 7 = . 0x020D, 6 = . 0x020D, 4 = . 0x020D,",
    "21.9 Register Summary - Peripheral Pin Select Module\n3 = RB4PPS[5:0]. 0x020D, 1 = . 0x020D, 0 = . 0x020E, Name = RB5PPS. 0x020E, Bit Pos. = 7:0. 0x020E, 7 = . 0x020E, 6 = . 0x020E, 4 = . 0x020E, 3 = RB5PPS[5:0]. 0x020E, 1 = . 0x020E, 0 = . 0x020F, Name = RB6PPS. 0x020F, Bit Pos. = 7:0. 0x020F, 7 = . 0x020F, 6 = . 0x020F, 4 = . 0x020F, 3 = RB6PPS[5:0]. 0x020F, 1 = . 0x020F, 0 = . 0x0210, Name = RB7PPS. 0x0210, Bit Pos. = 7:0. 0x0210, 7 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0210, 6 = . 0x0210, 4 = . 0x0210, 3 = RB7PPS[5:0]. 0x0210, 1 = . 0x0210, 0 = . 0x0211, Name = RC0PPS. 0x0211, Bit Pos. = 7:0. 0x0211, 7 = . 0x0211, 6 = . 0x0211, 4 = . 0x0211, 3 = RC0PPS[5:0]. 0x0211, 1 = . 0x0211, 0 = . 0x0212, Name = RC1PPS. 0x0212, Bit Pos. = 7:0. 0x0212, 7 = . 0x0212, 6 = . 0x0212, 4 = . 0x0212, 3 = RC1PPS[5:0]. 0x0212, 1 = . 0x0212, 0 = . 0x0213, Name = RC2PPS.",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0213, Bit Pos. = 7:0. 0x0213, 7 = . 0x0213, 6 = . 0x0213, 4 = . 0x0213, 3 = RC2PPS[5:0]. 0x0213, 1 = . 0x0213, 0 = . 0x0214, Name = RC3PPS. 0x0214, Bit Pos. = 7:0. 0x0214, 7 = . 0x0214, 6 = . 0x0214, 4 = . 0x0214, 3 = RC3PPS[5:0]. 0x0214, 1 = . 0x0214, 0 = . 0x0215, Name = RC4PPS. 0x0215, Bit Pos. = 7:0. 0x0215, 7 = . 0x0215, 6 = . 0x0215, 4 = . 0x0215, 3 = RC4PPS[5:0]. 0x0215, 1 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0215, 0 = . 0x0216, Name = RC5PPS. 0x0216, Bit Pos. = 7:0. 0x0216, 7 = . 0x0216, 6 = . 0x0216, 4 = . 0x0216, 3 = RC5PPS[5:0]. 0x0216, 1 = . 0x0216, 0 = . 0x0217, Name = RC6PPS. 0x0217, Bit Pos. = 7:0. 0x0217, 7 = . 0x0217, 6 = . 0x0217, 4 = . 0x0217, 3 = RC6PPS[5:0]. 0x0217, 1 = . 0x0217, 0 = . 0x0218, Name = RC7PPS. 0x0218, Bit Pos. = 7:0. 0x0218, 7 = . 0x0218, 6 = . 0x0218, 4 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0218, 3 = RC7PPS[5:0]. 0x0218, 1 = . 0x0218, 0 = . 0x0219, Name = . 0x0219, Bit Pos. = . 0x0219, 7 = . 0x0219, 6 = . 0x0219, 4 = . 0x0219, 3 = . 0x0219, 1 = . 0x0219, 0 = . ... 0x023D, Name = Reserved. ... 0x023D, Bit Pos. = . ... 0x023D, 7 = . ... 0x023D, 6 = . ... 0x023D, 4 = . ... 0x023D, 3 = . ... 0x023D, 1 = . ... 0x023D, 0 = . 0x023E, Name = INT0PPS. 0x023E, Bit Pos. = 7:0. 0x023E, 7 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x023E, 6 = . 0x023E, 4 = . 0x023E, 3 = PORT. 0x023E, 1 = PIN[2:0]. 0x023E, 0 = . 0x023F, Name = INT1PPS. 0x023F, Bit Pos. = 7:0. 0x023F, 7 = . 0x023F, 6 = . 0x023F, 4 = PORT[1:0]. 0x023F, 3 = . 0x023F, 1 = PIN[2:0]. 0x023F, 0 = . 0x0240, Name = INT2PPS. 0x0240, Bit Pos. = 7:0. 0x0240, 7 = . 0x0240, 6 = . 0x0240, 4 = PORT[2:0]. 0x0240, 3 = . 0x0240, 1 = PIN[2:0]. 0x0240, 0 = . 0x0241, Name =",
    "21.9 Register Summary - Peripheral Pin Select Module\nT0CKIPPS. 0x0241, Bit Pos. = 7:0. 0x0241, 7 = . 0x0241, 6 = . 0x0241, 4 = PORT[2:0]. 0x0241, 3 = . 0x0241, 1 = PIN[2:0]. 0x0241, 0 = . 0x0242, Name = T1CKIPPS. 0x0242, Bit Pos. = 7:0. 0x0242, 7 = . 0x0242, 6 = . 0x0242, 4 = PORT[2:0]. 0x0242, 3 = . 0x0242, 1 = PIN[2:0]. 0x0242, 0 = . 0x0243, Name = T1GPPS. 0x0243, Bit Pos. = 7:0. 0x0243, 7 = . 0x0243, 6 = . 0x0243, 4 = PORT[2:0].",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0243, 3 = . 0x0243, 1 = PIN[2:0]. 0x0243, 0 = . 0x0244, Name = T3CKIPPS. 0x0244, Bit Pos. = 7:0. 0x0244, 7 = . 0x0244, 6 = . 0x0244, 4 = PORT[2:0]. 0x0244, 3 = . 0x0244, 1 = PIN[2:0]. 0x0244, 0 = . 0x0245, Name = T3GPPS. 0x0245, Bit Pos. = 7:0. 0x0245, 7 = . 0x0245, 6 = . 0x0245, 4 = PORT[2:0]. 0x0245, 3 = . 0x0245, 1 = PIN[2:0]. 0x0245, 0 = . 0x0246, Name = . 0x0246, Bit Pos. = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0246, 7 = . 0x0246, 6 = . 0x0246, 4 = . 0x0246, 3 = . 0x0246, 1 = . 0x0246, 0 = . ... 0x0247, Name = Reserved. ... 0x0247, Bit Pos. = . ... 0x0247, 7 = . ... 0x0247, 6 = . ... 0x0247, 4 = . ... 0x0247, 3 = . ... 0x0247, 1 = . ... 0x0247, 0 = . 0x0248, Name = T2INPPS. 0x0248, Bit Pos. = 7:0. 0x0248, 7 = . 0x0248, 6 = . 0x0248, 4 = PORT[2:0]. 0x0248, 3 = . 0x0248, 1 = PIN[2:0]. 0x0248, 0",
    "21.9 Register Summary - Peripheral Pin Select Module\n= . 0x0249, Name = T4INPPS. 0x0249, Bit Pos. = 7:0. 0x0249, 7 = . 0x0249, 6 = . 0x0249, 4 = PORT[2:0]. 0x0249, 3 = . 0x0249, 1 = PIN[2:0]. 0x0249, 0 = . 0x024A ..., Name = Reserved. 0x024A ..., Bit Pos. = . 0x024A ..., 7 = . 0x024A ..., 6 = . 0x024A ..., 4 = . 0x024A ..., 3 = . 0x024A ..., 1 = . 0x024A ..., 0 = . 0x024E, Name = . 0x024E, Bit Pos. = . 0x024E, 7 = . 0x024E, 6 = . 0x024E, 4 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x024E, 3 = . 0x024E, 1 = . 0x024E, 0 = . 0x024F, Name = CCP1PPS. 0x024F, Bit Pos. = 7:0. 0x024F, 7 = . 0x024F, 6 = . 0x024F, 4 = PORT[2:0]. 0x024F, 3 = . 0x024F, 1 = PIN[2:0]. 0x024F, 0 = . 0x0250, Name = Reserved. 0x0250, Bit Pos. = . 0x0250, 7 = . 0x0250, 6 = . 0x0250, 4 = . 0x0250, 3 = . 0x0250, 1 = . 0x0250, 0 = . 0x0251, Name = PWM1ERSPPS. 0x0251, Bit Pos. = 7:0. 0x0251, 7 = . 0x0251, 6 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0251, 4 = PORT[1:0]. 0x0251, 3 = . 0x0251, 1 = PIN[2:0]. 0x0251, 0 = . 0x0252, Name = PWM2ERSPPS. 0x0252, Bit Pos. = 7:0. 0x0252, 7 = . 0x0252, 6 = . 0x0252, 4 = PORT[2:0]. 0x0252, 3 = . 0x0252, 1 = PIN[2:0]. 0x0252, 0 = . 0x0253, Name = PWM3ERSPPS. 0x0253, Bit Pos. = 7:0. 0x0253, 7 = . 0x0253, 6 = . 0x0253, 4 = PORT[1:0]. 0x0253, 3 = . 0x0253, 1 = PIN[2:0]. 0x0253, 0 = . 0x0254,",
    "21.9 Register Summary - Peripheral Pin Select Module\nName = . 0x0254, Bit Pos. = . 0x0254, 7 = . 0x0254, 6 = . 0x0254, 4 = . 0x0254, 3 = . 0x0254, 1 = . 0x0254, 0 = . ... 0x0256, Name = Reserved. ... 0x0256, Bit Pos. = . ... 0x0256, 7 = . ... 0x0256, 6 = . ... 0x0256, 4 = . ... 0x0256, 3 = . ... 0x0256, 1 = . ... 0x0256, 0 = . 0x0257, Name = PWMIN0PPS. 0x0257, Bit Pos. = 7:0. 0x0257, 7 = . 0x0257, 6 = . 0x0257, 4 = PORT[2:0]. 0x0257, 3 = . 0x0257,",
    "21.9 Register Summary - Peripheral Pin Select Module\n1 = PIN[2:0]. 0x0257, 0 = . 0x0258, Name = PWMIN1PPS. 0x0258, Bit Pos. = 7:0. 0x0258, 7 = . 0x0258, 6 = . 0x0258, 4 = PORT[2:0]. 0x0258, 3 = . 0x0258, 1 = PIN[2:0]. 0x0258, 0 = . 0x0259, Name = SMT1WINPPS. 0x0259, Bit Pos. = 7:0. 0x0259, 7 = . 0x0259, 6 = . 0x0259, 4 = PORT[2:0]. 0x0259, 3 = . 0x0259, 1 = PIN[2:0]. 0x0259, 0 = . 0x025A, Name = SMT1SIGPPS. 0x025A, Bit Pos. = 7:0. 0x025A, 7 =",
    "21.9 Register Summary - Peripheral Pin Select Module\n. 0x025A, 6 = . 0x025A, 4 = PORT[2:0]. 0x025A, 3 = . 0x025A, 1 = PIN[2:0]. 0x025A, 0 = . 0x025B, Name = CWG1PPS. 0x025B, Bit Pos. = 7:0. 0x025B, 7 = . 0x025B, 6 = . 0x025B, 4 = PORT[2:0]. 0x025B, 3 = . 0x025B, 1 = PIN[2:0]. 0x025B, 0 = . 0x025C, Name = . 0x025C, Bit Pos. = . 0x025C, 7 = . 0x025C, 6 = . 0x025C, 4 = . 0x025C, 3 = . 0x025C, 1 = . 0x025C, 0 = . ... 0x025D, Name = Reserved. ...",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x025D, Bit Pos. = . ... 0x025D, 7 = . ... 0x025D, 6 = . ... 0x025D, 4 = . ... 0x025D, 3 = . ... 0x025D, 1 = . ... 0x025D, 0 = ",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x025E, ...........continued.Name = MD1CARLPPS. 0x025E, ...........continued.Bit Pos. = 7:0. 0x025E, ...........continued.6 = . 0x025E, ...........continued.4 = PORT[2:0]. 0x025E, ...........continued.3 = . 0x025E, ...........continued.1 = PIN[2:0]. 0x025E, ...........continued.0 = . 0x025F, ...........continued.Name = MD1CARHPPS. 0x025F, ...........continued.Bit Pos. = 7:0. 0x025F,",
    "21.9 Register Summary - Peripheral Pin Select Module\n...........continued.6 = . 0x025F, ...........continued.4 = PORT[2:0]. 0x025F, ...........continued.3 = . 0x025F, ...........continued.1 = PIN[2:0]. 0x025F, ...........continued.0 = . 0x0260, ...........continued.Name = MD1SRCPPS. 0x0260, ...........continued.Bit Pos. = 7:0. 0x0260, ...........continued.6 = . 0x0260, ...........continued.4 = PORT[2:0]. 0x0260, ...........continued.3 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0260, ...........continued.1 = PIN[2:0]. 0x0260, ...........continued.0 = . 0x0261, ...........continued.Name = CLCIN0PPS. 0x0261, ...........continued.Bit Pos. = 7:0. 0x0261, ...........continued.6 = . 0x0261, ...........continued.4 = PORT[2:0]. 0x0261, ...........continued.3 = . 0x0261, ...........continued.1 = PIN[2:0]. 0x0261, ...........continued.0 = . 0x0262, ...........continued.Name",
    "21.9 Register Summary - Peripheral Pin Select Module\n= CLCIN1PPS. 0x0262, ...........continued.Bit Pos. = 7:0. 0x0262, ...........continued.6 = . 0x0262, ...........continued.4 = PORT[2:0]. 0x0262, ...........continued.3 = . 0x0262, ...........continued.1 = PIN[2:0]. 0x0262, ...........continued.0 = . 0x0263, ...........continued.Name = CLCIN2PPS. 0x0263, ...........continued.Bit Pos. = 7:0. 0x0263, ...........continued.6 = . 0x0263,",
    "21.9 Register Summary - Peripheral Pin Select Module\n...........continued.4 = PORT[2:0]. 0x0263, ...........continued.3 = . 0x0263, ...........continued.1 = PIN[2:0]. 0x0263, ...........continued.0 = . 0x0264, ...........continued.Name = CLCIN3PPS. 0x0264, ...........continued.Bit Pos. = 7:0. 0x0264, ...........continued.6 = . 0x0264, ...........continued.4 = PORT[2:0]. 0x0264, ...........continued.3 = . 0x0264, ...........continued.1 =",
    "21.9 Register Summary - Peripheral Pin Select Module\nPIN[2:0]. 0x0264, ...........continued.0 = . 0x0265 ... 0x0268, ...........continued.Name = Reserved. 0x0265 ... 0x0268, ...........continued.Bit Pos. = . 0x0265 ... 0x0268, ...........continued.6 = . 0x0265 ... 0x0268, ...........continued.4 = . 0x0265 ... 0x0268, ...........continued.3 = . 0x0265 ... 0x0268, ...........continued.1 = . 0x0265 ... 0x0268, ...........continued.0 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0269, ...........continued.Name = ADACTPPS. 0x0269, ...........continued.Bit Pos. = 7:0. 0x0269, ...........continued.6 = . 0x0269, ...........continued.4 = PORT[2:0]. 0x0269, ...........continued.3 = . 0x0269, ...........continued.1 = PIN[2:0]. 0x0269, ...........continued.0 = . 0x026A, ...........continued.Name = SPI1SCKPPS. 0x026A, ...........continued.Bit Pos. = 7:0. 0x026A,",
    "21.9 Register Summary - Peripheral Pin Select Module\n...........continued.6 = . 0x026A, ...........continued.4 = PORT[2:0]. 0x026A, ...........continued.3 = . 0x026A, ...........continued.1 = PIN[2:0]. 0x026A, ...........continued.0 = . 0x026B, ...........continued.Name = SPI1SDIPPS. 0x026B, ...........continued.Bit Pos. = 7:0. 0x026B, ...........continued.6 = . 0x026B, ...........continued.4 = PORT[2:0]. 0x026B, ...........continued.3 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x026B, ...........continued.1 = PIN[2:0]. 0x026B, ...........continued.0 = . 0x026C, ...........continued.Name = SPI1SSPPS. 0x026C, ...........continued.Bit Pos. = 7:0. 0x026C, ...........continued.6 = . 0x026C, ...........continued.4 = PORT[2:0]. 0x026C, ...........continued.3 = . 0x026C, ...........continued.1 = PIN[2:0]. 0x026C, ...........continued.0 = . 0x026D,",
    "21.9 Register Summary - Peripheral Pin Select Module\n...........continued.Name = SPI2SCKPPS. 0x026D, ...........continued.Bit Pos. = 7:0. 0x026D, ...........continued.6 = . 0x026D, ...........continued.4 = PORT[2:0]. 0x026D, ...........continued.3 = . 0x026D, ...........continued.1 = PIN[2:0]. 0x026D, ...........continued.0 = . 0x026E, ...........continued.Name = SPI2SDIPPS. 0x026E, ...........continued.Bit Pos. = 7:0. 0x026E,",
    "21.9 Register Summary - Peripheral Pin Select Module\n...........continued.6 = . 0x026E, ...........continued.4 = PORT[2:0]. 0x026E, ...........continued.3 = . 0x026E, ...........continued.1 = PIN[2:0]. 0x026E, ...........continued.0 = . 0x026F, ...........continued.Name = SPI2SSPPS. 0x026F, ...........continued.Bit Pos. = 7:0. 0x026F, ...........continued.6 = . 0x026F, ...........continued.4 = PORT[2:0]. 0x026F, ...........continued.3 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x026F, ...........continued.1 = PIN[2:0]. 0x026F, ...........continued.0 = . 0x0270, ...........continued.Name = I2C1SDAPPS. 0x0270, ...........continued.Bit Pos. = 7:0. 0x0270, ...........continued.6 = . 0x0270, ...........continued.4 = PORT[2:0]. 0x0270, ...........continued.3 = . 0x0270, ...........continued.1 = PIN[2:0]. 0x0270, ...........continued.0 = . 0x0271,",
    "21.9 Register Summary - Peripheral Pin Select Module\n...........continued.Name = I2C1SCLPPS. 0x0271, ...........continued.Bit Pos. = 7:0. 0x0271, ...........continued.6 = . 0x0271, ...........continued.4 = PORT[2:0]. 0x0271, ...........continued.3 = . 0x0271, ...........continued.1 = PIN[2:0]. 0x0271, ...........continued.0 = . 0x0272, ...........continued.Name = U1RXPPS. 0x0272, ...........continued.Bit Pos. = 7:0. 0x0272,",
    "21.9 Register Summary - Peripheral Pin Select Module\n...........continued.6 = . 0x0272, ...........continued.4 = PORT[1:0]. 0x0272, ...........continued.3 = . 0x0272, ...........continued.1 = PIN[2:0]. 0x0272, ...........continued.0 = . 0x0273, ...........continued.Name = U1CTSPPS. 0x0273, ...........continued.Bit Pos. = 7:0. 0x0273, ...........continued.6 = . 0x0273, ...........continued.4 = PORT[1:0]. 0x0273, ...........continued.3 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0273, ...........continued.1 = PIN[2:0]. 0x0273, ...........continued.0 = . 0x0274, ...........continued.Name = UxRXPPS. 0x0274, ...........continued.Bit Pos. = 7:0. 0x0274, ...........continued.6 = . 0x0274, ...........continued.4 = . 0x0274, ...........continued.3 = PORT. 0x0274, ...........continued.1 = PIN[2:0]. 0x0274, ...........continued.0 = . 0x0275, ...........continued.Name =",
    "21.9 Register Summary - Peripheral Pin Select Module\nUxCTSPPS. 0x0275, ...........continued.Bit Pos. = 7:0. 0x0275, ...........continued.6 = . 0x0275, ...........continued.4 = . 0x0275, ...........continued.3 = PORT. 0x0275, ...........continued.1 = PIN[2:0]. 0x0275, ...........continued.0 = . 0x0276, ...........continued.Name = U3RXPPS. 0x0276, ...........continued.Bit Pos. = 7:0. 0x0276, ...........continued.6 = . 0x0276,",
    "21.9 Register Summary - Peripheral Pin Select Module\n...........continued.4 = PORT[1:0]. 0x0276, ...........continued.3 = . 0x0276, ...........continued.1 = PIN[2:0]. 0x0276, ...........continued.0 = . 0x0277, ...........continued.Name = U3CTSPPS. 0x0277, ...........continued.Bit Pos. = 7:0. 0x0277, ...........continued.6 = . 0x0277, ...........continued.4 = PORT[1:0]. 0x0277, ...........continued.3 = . 0x0277, ...........continued.1 =",
    "21.9 Register Summary - Peripheral Pin Select Module\nPIN[2:0]. 0x0277, ...........continued.0 = ",
    "22. CLC - Configurable Logic Cell\nThe Configurable Logic Cell (CLC) module provides programmable logic that operates outside the speed limitations of software execution. The logic cell takes up to 256 input signals and, through the use of configurable gates, reduces those inputs to four logic lines that drive one of eight selectable single-output logic functions.\nInput sources are a combination of the following:\n\u00b7 I/O pins\n\u00b7 Internal clocks\n\u00b7 Peripherals\n\u00b7 Register bits\nThe output can be directed internally to peripherals and to an output pin.\nThe following figure is a simplified diagram showing signal flow through the CLC. Possible configurations include:\n\u00b7 Combinatorial Logic\n-AND\n-NAND\n-AND-OR\n-AND-OR-INVERT\n-OR-XOR\n-OR-XNOR\n\u00b7 Latches\n-SR\n-Clocked D with Set and Reset\n-Transparent D with Set and Reset",
    "Figure 22-1. CLC Simplified Block Diagram\n\u696e\n\u696e\n\u696e\n\u6378\n\u454e\n\u7272",
    "Notes:\n1. See Figure 22-2 for input data selection and gating.\n2. See Figure 22-3 for programmable logic functions.",
    "22.1 CLC Setup\nProgramming the CLC module is performed by configuring the four stages in the logic signal flow. The four stages are:\n\u00b7 Data selection\n\u00b7 Data gating\n\u00b7 Logic function selection\n\u00b7 Output polarity\nEach stage is set up at run time by writing to the corresponding CLC Special Function Registers. This has the added advantage of permitting logic reconfiguration on-the-fly during program execution.",
    "22.1.1 Data Selection\nData inputs are selected with CLCnSEL0 through CLCnSEL3 registers.\nImportant: Data selections are undefined at power-up.\nDepending on the number of bits implemented in the CLCnSELy registers, there can be as many as 256 sources available as inputs to the configurable logic. Four multiplexers are used to independently select these inputs to pass on to the next stage as indicated on the left side of the following diagram.\n\u696e\n\u696e\n\u696e\n\u6374\n\u6378\n\u6378\n\u6378\n\u6374\n\u4d4f\n\u6378\n\u504f\n\u7272\n\u5053\n\u7950\n\u5050\n\u7320\n\u7269\n\u7261\n\u5065\n\u7365\nData inputs in the figure are identified by a generic numbered input name.\nFigure 22-2. Input Data Selection and Gating\nNote: All controls are undefined at power up Note: All controls are undefined at power-up.\nThe CLC Input Selection table correlates the generic input name to the actual signal for each CLC module. The table column labeled 'DyS Value' indicates the MUX selection code for the selected data input. DyS is an abbreviation for the MUX select input codes, D1S through D4S, where 'y' is the gate number.",
    "22.1.2 Data Gating\nOutputs from the input multiplexers are directed to the desired logic function input through the data gating stage. Each data gate can direct any combination of the four selected inputs.\nThe gate stage is more than just signal direction. The gate can be configured to direct each input signal as inverted or noninverted data. Directed signals are ANDed together in each gate. The output of each gate can be inverted before going on to the logic function stage.\nThe gating is in essence a 1-to-4 input AND/NAND/OR/NOR gate. When every input is inverted and the output is inverted, the gate is an AND of all enabled data inputs. When the inputs and output are not inverted, the gate is an OR or all enabled inputs.\nTable 22-1 summarizes the basic logic that can be obtained in gate 1 by using the gate logic select bits. The table shows the logic of four input variables, but each gate can be configured to use less than four. If no inputs are selected, the output will be ' 0 ' or ' 1 ', depending on the gate output polarity bit.",
    "22.1.2 Data Gating\nTable 22-1. Data Gating Logic\n\n0x55, GyPOL = 1. 0x55, Gate Logic = AND. 0x55, GyPOL = 0. 0x55, Gate Logic = NAND. 0xAA, GyPOL = 1. 0xAA, Gate Logic = NOR. 0xAA, GyPOL = 0. 0xAA, Gate Logic = OR. 0x00, GyPOL = 0. 0x00, Gate Logic = Logic ' 0 '. 0x00, GyPOL = 1. 0x00, Gate Logic = Logic ' 1 '\nIt is possible (but not recommended) to select both the true and negated values of an input. When this is done, the gate output is ' 0 ', regardless of the other inputs, but may emit logic glitches (transient-induced pulses). If the output of the channel must be ' 0 ' or ' 1 ', the recommended method is to set all gate bits to ' 0 ' and use the gate polarity bit to set the desired level.\nData gating is configured with the logic gate select registers as follows:",
    "22.1.2 Data Gating\n\u00b7 Gate 1: CLCnGLS0\n\u00b7 Gate 2: CLCnGLS1\n\u00b7 Gate 3: CLCnGLS2\n\u00b7 Gate 4: CLCnGLS3\nNote: Register number suffixes are different than the gate numbers because other variations of this module have multiple gate selections in the same register.\nData gating is indicated in the right side of Figure 22-2. Only one gate is shown in detail. The remaining three gates are configured identically, except when the data enables correspond to the enables for that gate.",
    "22.1.3 Logic Function\nThere are eight available logic functions including:\n\u00b7 AND-OR\n\u00b7 OR-XOR\n\u00b7 AND\n\u00b7 SR Latch\n\u00b7 D Flip-Flop with Set and Reset\n\u00b7 D Flip-Flop with Reset\n\u00b7 J-K Flip-Flop with Reset\n\u00b7 Transparent Latch with Set and Reset\nLogic functions are shown in the following diagram. Each logic function has four inputs and one output. The four inputs are the four data gate outputs of the previous stage. The output is fed to the inversion stage and, from there, to other peripherals, an output pin, and back to the CLC itself.",
    "Figure 22-3. Programmable Logic Functions\nRev. 10-000122B 9/13/2016",
    "Figure 22-3. Programmable Logic Functions\nMODE<2:0> = 010 1-Input DFlip-Flop with S and R D Q S lcxg2 lcxg4 lcxq, OR-XOR.MODE<2:0> = 001 S-R Latch = MODE<2:0> = 011 S R Q lcxq lcxg1 lcxg2 lcxg3 lcxg4. MODE<2:0> = 100 R lcxg1 lcxg3, OR-XOR.MODE<2:0> = 001 S-R Latch = 2-Input DFlip-Flop with R MODE<2:0> = 101 D R Q lcxq lcxg1 lcxg2 lcxg3 lcxg4. J-K Flip-Flop with R MODE<2:0> = 110 J R Q K lcxg1 lcxg2 lcxg3 lcxg4 lcxq, OR-XOR.MODE<2:0> = 001 S-R Latch = 1-Input Transparent Latch with S and R MODE<2:0> = 111 D R Q S LE lcxq",
    "Figure 22-3. Programmable Logic Functions\nlcxg1 lcxg2 lcxg3 lcxg4",
    "22.1.4 Output Polarity\nThe last stage in the Configurable Logic Cell is the output polarity. Setting the POL bit inverts the output signal from the logic stage. Changing the polarity while the interrupts are enabled will cause an interrupt for the resulting output transition.",
    "22.2 CLC Interrupts\nAn interrupt will be generated upon a change in the output value of the CLCx when the appropriate interrupt enables are set. A rising edge detector and a falling edge detector are present in each CLC for this purpose.\nThe CLCxIF bit of the associated PIR register will be set when either edge detector is triggered and its associated enable bit is set. The INTP bit enables rising edge interrupts and the INTN bit enables falling edge interrupts.\nTo fully enable the interrupt, set the following bits:\n\u00b7 The CLCxIE bit of the respective PIE register\n\u00b7 The INTP bit (for a rising edge detection)\n\u00b7 The INTN bit (for a falling edge detection)\nIf priority interrupts are not used:\n1. Clear the IPEN bit of the INTCON register.\n2. Set the GIE bit of the INTCON register.\n3. Set the GIEL bit of the INTCON register.\nIf the CLC is a high-priority interrupt:\n1. Set the IPEN bit of the INTCON register.\n2. Set the CLCxIP bit of the respective IPR register.\n3. Set the GIEH bit of the INTCON register.",
    "22.2 CLC Interrupts\nIf the CLC is a low-priority interrupt:\n1. Set the IPEN bit of the INTCON register.\n2. Clear the CLCxIP bit of the respective IPR register.\n3. Set the GIEL bit of the INTCON register.\nThe CLCxIF bit of the respective PIR register must be cleared in software as part of the interrupt service. If another edge is detected while this flag is being cleared, the flag will still be set at the end of the sequence.",
    "22.3 Effects of a Reset\nThe CLCnCON register is cleared to ' 0 ' as the result of a Reset. All other selection and gating values remain unchanged.",
    "22.4 Output Mirror Copies\nMirror copies of all CLCxOUT bits are contained in the CLCDATA register. Reading this register reads the outputs of all CLCs simultaneously. This prevents any reading skew introduced by testing or reading the OUT bits in the individual CLCnCON registers.",
    "22.5 Operation During Sleep\nThe CLC module operates independently from the system clock and will continue to run during Sleep, provided that the input sources selected remain Active.\nThe HFINTOSC remains Active during Sleep when the CLC module is enabled and the HFINTOSC is selected as an input source, regardless of the system clock source selected.\nIn other words, if the HFINTOSC is simultaneously selected as both the system clock and as a CLC input source, when the CLC is enabled, the CPU will go Idle during Sleep, but the CLC will continue to operate, and the HFINTOSC will remain Active. This will have a direct effect on the Sleep mode current.",
    "22.6 CLC Setup Steps\nThese steps need to be followed when setting up the CLC:\n1. Disable the CLC by clearing the EN bit.\n2. Select the desired inputs using the CLCnSEL0 through CLCnSEL3 registers.\n3. Clear any ANSEL bits associated with CLC input pins.\n4. Set all TRIS bits associated with inputs. However, a CLC input will also operate if the pin is configured as an output, in which case the TRIS bits must be cleared.\n5. Enable the chosen inputs through the four gates using the CLCnGLS0 through CLCnGLS3 registers.\n6. Select the gate output polarities with the GyPOL bits.\n7. Select the desired logic function with the MODE bits.\n8. Select the desired polarity of the logic output with the POL bit (this step may be combined with the previous gate output polarity step).\n9. If driving a device pin, configure the associated pin PPS control register and also clear the TRIS bit corresponding to that output.\n10. Configure the interrupts (optional). See the CLC Interrupts section.\n11. Enable the CLC by setting the EN bit.",
    "22.7 Register Overlay\nAll CLCs in this device share the same set of registers. Only one CLC instance is accessible at a time. The value in the CLCSELECT register is one less than the selected CLC instance. For example, a CLCSELECT value of ' 0 ' selects CLC1.",
    "22.8.1 CLCSELECT\nName:\nCLCSELECT\nAddress:\n0x0D5\nCLC Instance Selection Register\nSelects which CLC instance is accessed by the CLC registers\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nSLCT[1:0]\nAccess\nR/W\nR/W\nReset\n0\n0",
    "Bits 1:0 - SLCT[1:0] CLC instance selection\nn, Description = Shared CLC registers of instance n+1 are selected for read and write operations",
    "22.8.2 CLCnCON\nName: Address:\nCLCnCON\n0x0D6",
    "Configurable Logic Cell Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = INTP. , 5 = INTN. , 6 = MODE[2:0]. , 7 = MODE[2:0]. , 8 = MODE[2:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = R. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CLC Enable\n1, Description = Configurable logic cell is enabled and mixing signals. 0, Description = Configurable logic cell is disabled and has logic zero output",
    "Bit 4 - INTP Configurable Logic Cell Positive Edge Going Interrupt Enable\n1, Description = CLCxIF will be set when a rising edge occurs on CLCxOUT. 0, Description = Rising edges on CLCxOUT have no effect on CLCxIF",
    "Bit 3 - INTN Configurable Logic Cell Negative Edge Going Interrupt Enable\n1, Description = CLCxIF will be set when a falling edge occurs on CLCxOUT. 0, Description = Falling edges on CLCxOUT have no effect on CLCxIF",
    "Bits 2:0 - MODE[2:0] Configurable Logic Cell Functional Mode Selection\n111, Description = Cell is 1-input transparent latch with Set and Reset. 110, Description = Cell is J-K flip-flop with Reset. 101, Description = Cell is 2-input D flip-flop with Reset. 100, Description = Cell is 1-input D flip-flop with Set and Reset. 011, Description = Cell is SR latch. 010, Description = Cell is 4-input AND. 001, Description = Cell is OR-XOR. 000, Description = Cell is AND-OR",
    "22.8.3 CLCnPOL\nName:\nCLCnPOL\nAddress:\n0x0D7",
    "Signal Polarity Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POL. , 2 = . , 3 = . , 4 = . , 5 = G4POL. , 6 = G3POL. , 7 = G2POL. , 8 = G1POL. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bit 7 - POL CLCxOUT Output Polarity Control\n1, Description = The output of the logic cell is inverted. 0, Description = The output of the logic cell is not inverted",
    "Bits 0, 1, 2, 3 - GyPOL Gate Output Polarity Control\nReset States: POR/BOR = xxxx\nAll Other Resets = uuuu\n1, Description = The gate output is inverted when applied to the logic cell. 0, Description = The output of the gate is not inverted",
    "22.8.4 CLCnSEL0\nName: Address:\nCLCnSEL0\n0x0D8",
    "Generic CLCn Data 1 Select Register\nBit, 1 = 6 5. Bit, 2 = . Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = D1S[6:0]. , 5 = . , 6 = . , 7 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "Table 22-2. CLC Input Selection\n[0] 0000 0000, Input Source = CLCIN0PPS. [0] 0000 0000, DyS (cont.) = [26] 0001 1010. [0] 0000 0000, Input Source (cont.) = PWM3S1P2_OUT. [1] 0000 0001, Input Source = CLCIN1PPS. [1] 0000 0001, DyS (cont.) = [27] 0001 1011. [1] 0000 0001, Input Source (cont.) = NCO1. [2] 0000 0010, Input Source = CLCIN2PPS. [2] 0000 0010, DyS (cont.) = [28] 0001 1100. [2] 0000 0010, Input Source (cont.) = CMP1_OUT. [3] 0000 0011, Input Source = CLCIN3PPS. [3] 0000 0011, DyS (cont.) = [29] 0001 1101. [3] 0000 0011, Input Source (cont.) =",
    "Table 22-2. CLC Input Selection\nCMP2_OUT. [4] 0000 0100, Input Source = F OSC. [4] 0000 0100, DyS (cont.) = [30] 0001 1110. [4] 0000 0100, Input Source (cont.) = ZCD. [5] 0000 0101, Input Source = HFINTOSC (1). [5] 0000 0101, DyS (cont.) = [31] 0001 1111. [5] 0000 0101, Input Source (cont.) = IOC. [6] 0000 0110, Input Source = LFINTOSC (1). [6] 0000 0110, DyS (cont.) = [32] 0010 0000. [6] 0000 0110, Input Source (cont.) = DSM1. [7] 0000 0111, Input Source = MFINTOSC (1). [7] 0000 0111, DyS (cont.) = [33] 0010 0001. [7] 0000 0111, Input Source (cont.) =",
    "Table 22-2. CLC Input Selection\nHLVD_OUT. [8] 0000 1000, Input Source = MFINTOSC (32 kHz) (1). [8] 0000 1000, DyS (cont.) = [34] 0010 0010. [8] 0000 1000, Input Source (cont.) = CLC1. [9] 0000 1001, Input Source = SFINTOSC (1 MHz) (1). [9] 0000 1001, DyS (cont.) = [35] 0010 0011. [9] 0000 1001, Input Source (cont.) = CLC2. [10] 0000 1010, Input Source = SOSC (1). [10] 0000 1010, DyS (cont.) = [36] 0010 0100. [10] 0000 1010, Input Source (cont.) = CLC3. [11] 0000 1011, Input Source = EXTOSC (1). [11] 0000 1011, DyS (cont.) = [37] 0010 0101. [11] 0000",
    "Table 22-2. CLC Input Selection\n1011, Input Source (cont.) = CLC4. [12] 0000 1100, Input Source = ADCRC (1). [12] 0000 1100, DyS (cont.) = [38] 0010 0110. [12] 0000 1100, Input Source (cont.) = U1TX. [13] 0000 1101, Input Source = CLKR. [13] 0000 1101, DyS (cont.) = [39] 0010 0111. [13] 0000 1101, Input Source (cont.) = U2TX. [14] 0000 1110, Input Source = TMR0. [14] 0000 1110, DyS (cont.) = [40] 0010 1000. [14] 0000 1110, Input Source (cont.) = U3TX. [15] 0000 1111, Input Source = TMR1. [15] 0000 1111, DyS (cont.) = [41] 0010 1001. [15] 0000 1111, Input Source",
    "Table 22-2. CLC Input Selection\n(cont.) = SPI1_SDO. [16] 0001 0000, Input Source = TMR2. [16] 0001 0000, DyS (cont.) = [42] 0010 1010. [16] 0001 0000, Input Source (cont.) = SPI1_SCK. [17] 0001 0001, Input Source = TMR3. [17] 0001 0001, DyS (cont.) = [43] 0010 1011. [17] 0001 0001, Input Source (cont.) = SPI1_SS. [18] 0001 0010, Input Source = TMR4. [18] 0001 0010, DyS (cont.) = [44] 0010 1100. [18] 0001 0010, Input Source (cont.) = SPI2_SDO. [19] 0001 0011, Input Source = SMT1. [19] 0001 0011, DyS (cont.) = [45] 0010 1101. [19] 0001 0011,",
    "Table 22-2. CLC Input Selection\nInput Source (cont.) = SPI2_SCK. [20] 0001 0100, Input Source = CCP1. [20] 0001 0100, DyS (cont.) = [46] 0010 1110. [20] 0001 0100, Input Source (cont.) = SPI2_SS. [21] 0001 0101, Input Source = PWM1S1P1_OUT. [21] 0001 0101, DyS (cont.) = [47] 0010 1111. [21] 0001 0101, Input Source (cont.) = I 2 C_SCL. [22] 0001 0110, Input Source = PWM1S1P2_OUT. [22] 0001 0110, DyS (cont.) = [48] 0011 0000. [22] 0001 0110, Input Source (cont.) = I 2 C_SDA. [23] 0001 0111, Input Source = PWM2S1P1_OUT. [23] 0001 0111, DyS",
    "Table 22-2. CLC Input Selection\n(cont.) = [49] 0011 0001. [23] 0001 0111, Input Source (cont.) = CWG1A. [24] 0001 1000, Input Source = PWM2S1P2_OUT. [24] 0001 1000, DyS (cont.) = [50] 0011 0010. [24] 0001 1000, Input Source (cont.) = CWG1B. [25] 0001 1001, Input Source = PWM3S1P1_OUT. [25] 0001 1001, DyS (cont.) = [51] 0011 0011. [25] 0001 1001, Input Source (cont.) = -. Note:, Input Source = Note:. Note:, DyS (cont.) = Note:. Note:, Input Source (cont.) = Note:\nReset States: POR/BOR = xxxxxxx All Other Resets = uuuuuuu",
    "22.8.5 CLCnSEL1\nName:\nCLCnSEL1\nAddress:\n0x0D9\nGeneric CLCn Data 1 Select Register\nBit, 1 = 6 5. Bit, 2 = 4. Bit, 3 = . Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = D2S[6:0]. , 2 = D2S[6:0]. , 3 = D2S[6:0]. , 4 = D2S[6:0]. , 5 = D2S[6:0]. , 6 = D2S[6:0]. , 7 = D2S[6:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "Bits 6:0 - D2S[6:0] CLCn Data2 Input Selection\nReset States: POR/BOR = xxxxxxx\nAll Other Resets = uuuuuuu\nn, Description = Refer to the CLC Input Selection table for input selections",
    "22.8.6 CLCnSEL2\nName:\nCLCnSEL2\nAddress:\n0x0DA\nGeneric CLCn Data 1 Select Register\nBit, 1 = 6 5. Bit, 2 = 4. Bit, 3 = . Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = D3S[6:0]. , 2 = D3S[6:0]. , 3 = D3S[6:0]. , 4 = D3S[6:0]. , 5 = D3S[6:0]. , 6 = D3S[6:0]. , 7 = D3S[6:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "Bits 6:0 - D3S[6:0] CLCn Data3 Input Selection\nReset States: POR/BOR = xxxxxxx\nAll Other Resets = uuuuuuu\nn, Description = Refer to the CLC Input Selection table for input selections",
    "22.8.7 CLCnSEL3\nName:\nCLCnSEL3\nAddress:\n0x0DB\nGeneric CLCn Data 4 Select Register\nBit, 1 = 6 5. Bit, 2 = 4. Bit, 3 = . Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = D4S[6:0]. , 5 = . , 6 = . , 7 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "Bits 6:0 - D4S[6:0] CLCn Data4 Input Selection\nReset States: POR/BOR = xxxxxxx\nAll Other Resets = uuuuuuu\nn, Description = Refer to the CLC Input Selection table for input selections",
    "22.8.8 CLCnGLS0\nName:\nCLCnGLS0\nAddress:\n0x0DC",
    "CLCn Gate1 Logic Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = G1D4T. , 2 = G1D4N. , 3 = G1D3T. , 4 = G1D3N. , 5 = G1D2T. , 6 = G1D2N. , 7 = G1D1T. , 8 = G1D1N. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 1, 3, 5, 7 - G1DyT dyT: Gate1 Data 'y' True (noninverted)\nReset States: POR/BOR = xxxx\nAll Other Resets = uuuu\n1, Description = dyT is gated into g1. 0, Description = dyT is not gated into g1",
    "Bits 0, 2, 4, 6 - G1DyN dyN: Gate1 Data 'y' Negated (inverted)\nReset States: POR/BOR = xxxx\nAll Other Resets = uuuu\n1, Description = dyN is gated into g1. 0, Description = dyN is not gated into g1",
    "22.8.9 CLCnGLS1\nName:\nCLCnGLS1\nAddress:\n0x0DD",
    "CLCn Gate2 Logic Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = G2D4T. , 2 = G2D4N. , 3 = G2D3T. , 4 = G2D3N. , 5 = G2D2T. , 6 = G2D2N. , 7 = G2D1T. , 8 = G2D1N. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 1, 3, 5, 7 - G2DyT dyT: Gate2 Data 'y' True (noninverted)\nReset States: POR/BOR = xxxx\nAll Other Resets = uuuu\n1, Description = dyT is gated into g2. 0, Description = dyT is not gated into g2",
    "Bits 0, 2, 4, 6 - G2DyN dyN: Gate2 Data 'y' Negated (inverted)\nReset States: POR/BOR = xxxx\nAll Other Resets = uuuu\n1, Description = dyN is gated into g2. 0, Description = dyN is not gated into g2",
    "22.8.10  CLCnGLS2\nName:\nCLCnGLS2\nAddress:\n0x0DE",
    "CLCn Gate3 Logic Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = G3D4T. , 2 = G3D4N. , 3 = G3D3T. , 4 = G3D3N. , 5 = G3D2T. , 6 = G3D2N. , 7 = G3D1T. , 8 = G3D1N. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 1, 3, 5, 7 - G3DyT dyT: Gate3 Data 'y' True (noninverted)\nReset States: POR/BOR = xxxx\nAll Other Resets = uuuu\n1, Description = dyT is gated into g3. 0, Description = dyT is not gated into g3",
    "Bits 0, 2, 4, 6 - G3DyN dyN: Gate3 Data 'y' Negated (inverted)\nReset States: POR/BOR = xxxx\nAll Other Resets = uuuu\n1, Description = dyN is gated into g3. 0, Description = dyN is not gated into g3",
    "22.8.11  CLCnGLS3\nName:\nCLCnGLS3\nAddress:\n0x0DF",
    "CLCn Gate4 Logic Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = G4D4T. , 2 = G4D4N. , 3 = G4D3T. , 4 = G4D3N. , 5 = G4D2T. , 6 = G4D2N. , 7 = G4D1T. , 8 = G4D1N. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 1, 3, 5, 7 - G4DyT dyT: Gate4 Data 'y' True (noninverted)\nReset States: POR/BOR = xxxx\nAll Other Resets = uuuu\n1, Description = dyT is gated into g4. 0, Description = dyT is not gated into g4",
    "Bits 0, 2, 4, 6 - G4DyN dyN: Gate4 Data 'y' Negated (inverted)\nReset States: POR/BOR = xxxx\nAll Other Resets = uuuu\n1, Description = dyN is gated into g4. 0, Description = dyN is not gated into g4",
    "22.8.12  CLCDATA\nName: Address:\nCLCDATA 0x0D4\nCLC Data Output Register\nMirror copy of CLC outputs\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CLC4OUT. , 6 = CLC3OUT. , 7 = CLC2OUT. , 8 = CLC1OUT. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 0, 1, 2, 3 - CLCxOUT Mirror copy of CLCx_out",
    "22.8.12  CLCDATA\n1, Description = CLCx_out is 1. 0, Description = CLCx_out is 0",
    "22.9 Register Summary - CLC Control\n0x00 ... 0xD3, Name = Reserved. 0x00 ... 0xD3, Bit Pos. = . 0x00 ... 0xD3, 7 = . 0x00 ... 0xD3, 6 = . 0x00 ... 0xD3, 5 = . 0x00 ... 0xD3, 4 = . 0x00 ... 0xD3, 3 = . 0x00 ... 0xD3, 2 = . 0x00 ... 0xD3, 1 = . 0x00 ... 0xD3, 0 = . 0xD4, Name = CLCDATA. 0xD4, Bit Pos. = 7:0. 0xD4, 7 = . 0xD4, 6 = . 0xD4, 5 = . 0xD4, 4 = . 0xD4, 3 = CLC4OUT. 0xD4, 2 = CLC3OUT. 0xD4, 1 = CLC2OUT. 0xD4, 0 =",
    "22.9 Register Summary - CLC Control\nCLC1OUT. 0xD5, Name = CLCSELECT. 0xD5, Bit Pos. = 7:0. 0xD5, 7 = . 0xD5, 6 = . 0xD5, 5 = . 0xD5, 4 = . 0xD5, 3 = . 0xD5, 2 = . 0xD5, 1 = SLCT[1:0]. 0xD5, 0 = SLCT[1:0]. 0xD6, Name = CLCnCON. 0xD6, Bit Pos. = 7:0. 0xD6, 7 = EN. 0xD6, 6 = . 0xD6, 5 = OUT. 0xD6, 4 = INTP. 0xD6, 3 = INTN. 0xD6, 2 = . 0xD6, 1 = MODE[2:0]. 0xD6, 0 = . 0xD7, Name = CLCnPOL. 0xD7, Bit Pos. = 7:0. 0xD7, 7 = POL.",
    "22.9 Register Summary - CLC Control\n0xD7, 6 = . 0xD7, 5 = . 0xD7, 4 = . 0xD7, 3 = G4POL. 0xD7, 2 = G3POL. 0xD7, 1 = G2POL. 0xD7, 0 = G1POL. 0xD8, Name = CLCnSEL0. 0xD8, Bit Pos. = 7:0. 0xD8, 7 = . 0xD8, 6 = . 0xD8, 5 = . 0xD8, 4 = . 0xD8, 3 = D1S[6:0]. 0xD8, 2 = . 0xD8, 1 = . 0xD8, 0 = . 0xD9, Name = CLCnSEL1. 0xD9, Bit Pos. = 7:0. 0xD9, 7 = . 0xD9, 6 = . 0xD9, 5 = . 0xD9, 4 = . 0xD9, 3 = D2S[6:0]. 0xD9,",
    "22.9 Register Summary - CLC Control\n2 = . 0xD9, 1 = . 0xD9, 0 = . 0xDA, Name = CLCnSEL2. 0xDA, Bit Pos. = 7:0. 0xDA, 7 = . 0xDA, 6 = . 0xDA, 5 = . 0xDA, 4 = . 0xDA, 3 = D3S[6:0]. 0xDA, 2 = . 0xDA, 1 = . 0xDA, 0 = . 0xDB, Name = CLCnSEL3. 0xDB, Bit Pos. = 7:0. 0xDB, 7 = . 0xDB, 6 = . 0xDB, 5 = . 0xDB, 4 = . 0xDB, 3 = D4S[6:0]. 0xDB, 2 = . 0xDB, 1 = . 0xDB, 0 = . 0xDC, Name = CLCnGLS0. 0xDC, Bit Pos. = 7:0. 0xDC, 7 = G1D4T. 0xDC, 6 = G1D4N.",
    "22.9 Register Summary - CLC Control\n0xDC, 5 = G1D3T. 0xDC, 4 = G1D3N. 0xDC, 3 = G1D2T. 0xDC, 2 = G1D2N. 0xDC, 1 = G1D1T. 0xDC, 0 = G1D1N. 0xDD, Name = CLCnGLS1. 0xDD, Bit Pos. = 7:0. 0xDD, 7 = G2D4T. 0xDD, 6 = G2D4N. 0xDD, 5 = G2D3T. 0xDD, 4 = G2D3N. 0xDD, 3 = G2D2T. 0xDD, 2 = G2D2N. 0xDD, 1 = G2D1T. 0xDD, 0 = G2D1N. 0xDE, Name = CLCnGLS2. 0xDE, Bit Pos. = 7:0. 0xDE, 7 = G3D4T. 0xDE, 6 = G3D4N. 0xDE, 5 =",
    "22.9 Register Summary - CLC Control\nG3D3T. 0xDE, 4 = G3D3N. 0xDE, 3 = G3D2T. 0xDE, 2 = G3D2N. 0xDE, 1 = G3D1T. 0xDE, 0 = G3D1N. 0xDF, Name = CLCnGLS3. 0xDF, Bit Pos. = 7:0. 0xDF, 7 = G4D4T. 0xDF, 6 = G4D4N. 0xDF, 5 = G4D3T. 0xDF, 4 = G4D3N. 0xDF, 3 = G4D2T. 0xDF, 2 = G4D2N. 0xDF, 1 = G4D1T. 0xDF, 0 = G4D1N",
    "23. CLKREF - Reference Clock Output Module\nThe reference clock output module provides the ability to send a clock signal to the clock reference output pin (CLKR). The reference clock output can be routed internally as an input signal for other peripherals, such as the timers and CLCs.\nThe reference clock output module has the following features:\n\u00b7 Selectable clock source using the CLKRCLK register\n\u00b7 Programmable clock divider\n\u00b7 Selectable duty cycle\nThe figure below shows the simplified block diagram of the clock reference module.\nFigure 23-1. Clock Reference Block Diagram\nRev. 10-000261B\n1/23/2019\nFigure 23-2. Clock Reference Timing\nRev. 10-000264B\n1/23/2019",
    "23.1 Clock Source\nThe clock source of the reference clock peripheral is selected with the CLK bits.",
    "23.1.1 Clock Synchronization\nThe CLKR output signal is ensured to be glitch-free when the EN bit is set to start the module and enable the CLKR output. When the reference clock output is disabled, the output signal will be disabled immediately.",
    "23.2 Programmable Clock Divider\nThe module takes the clock input and divides it based on the value of the DIV bits.\nThe following configurations are available:\n\u00b7 Base clock frequency value\n\u00b7 Base clock frequency divided by 2\n\u00b7 Base clock frequency divided by 4\n\u00b7 Base clock frequency divided by 8\n\u00b7 Base clock frequency divided by 16\n\u00b7 Base clock frequency divided by 32\n\u00b7 Base clock frequency divided by 64\n\u00b7 Base clock frequency divided by 128",
    "23.3 Selectable Duty Cycle\nThe DC bits are used to modify the duty cycle of the output clock. A duty cycle of 0%, 25%, 50%, or 75% can be selected for all clock rates when the DIV value is not 0b000 . When DIV = 0b000 , the duty cycle defaults to 50% for all values of DC except 0b00 , in which case the duty cycle is 0% (constant low output).\nImportant: The DC value at Reset is 10 . This makes the default duty cycle 50% and not 0%.\nImportant: Clock dividers and clock duty cycles can be changed while the module is enabled but doing so may cause glitches to occur on the output. To avoid possible glitches, clock dividers and clock duty cycles will be changed only when the EN bit is clear.",
    "23.4 Operation in Sleep Mode\nThe reference clock module continues to operate and provide a signal output in Sleep for all clock source selections except FOSC (CLK = 0 ).",
    "23.5 Register Definitions: Reference Clock\nLong bit name prefixes for the Reference Clock peripherals are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 23-1. CLKREF Long Bit Name Prefixes\n\nCLKR, Bit Name Prefix = CLKR",
    "23.5.1 CLKRCON\nName:\nCLKRCON\nAddress:\n0x039",
    "Reference Clock Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = . , 4 = DC[1:0]. , 5 = DC[1:0]. , 6 = DIV[2:0]. , 7 = DIV[2:0]. , 8 = DIV[2:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN Reference Clock Module Enable\n1, Description = Reference clock module enabled. 0, Description = Reference clock module is disabled",
    "Bits 4:3 - DC[1:0]  Reference Clock Duty Cycle (1)\n11, Description = Clock outputs duty cycle of 75%. 10, Description = Clock outputs duty cycle of 50%. 01, Description = Clock outputs duty cycle of 25%. 00, Description = Clock outputs duty cycle of 0%",
    "Bits 2:0 - DIV[2:0] Reference Clock Divider\n111, Description = Base clock value divided by 128. 110, Description = Base clock value divided by 64. 101, Description = Base clock value divided by 32. 100, Description = Base clock value divided by 16. 011, Description = Base clock value divided by 8. 010, Description = Base clock value divided by 4. 001, Description = Base clock value divided by 2. 000, Description = Base clock value",
    "Note:\n- 1. Bits are valid for DIV \u2265 001 . For DIV = 000 , duty cycle is fixed at 50%.",
    "23.5.2 CLKRCLK\nName:\nCLKRCLK\nAddress:\n0x03A\nClock Reference Clock Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CLK[3:0]. , 6 = CLK[3:0]. , 7 = CLK[3:0]. , 8 = CLK[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - CLK[3:0] CLKR Clock Selection\nTable 23-2. Clock Reference Module Clock Sources\n\n1111 - 1100, Clock Source = Reserved. 1011, Clock Source = CLC4_OUT. 1010, Clock Source = CLC3_OUT. 1001, Clock Source = CLC2_OUT. 1000, Clock Source = CLC1_OUT. 0111, Clock Source = NCO1_OUT. 0110, Clock Source = EXTOSC. 0101, Clock Source = SOSC. 0100, Clock Source = MFINTOSC (32 kHz). 0011, Clock Source = MFINTOSC (500 kHz). 0010, Clock Source = LFINTOSC. 0001, Clock Source = HFINTOSC. 0000, Clock Source = F OSC",
    "23.6 Register Summary - Reference CLK\n0x00 ... 0x38, Name = Reserved. 0x00 ... 0x38, Bit Pos. = . 0x00 ... 0x38, 7 = . 0x00 ... 0x38, 6 = . 0x00 ... 0x38, 5 = . 0x00 ... 0x38, 4 = . 0x00 ... 0x38, 3 = . 0x00 ... 0x38, 2 1 = . 0x00 ... 0x38, 0 = . 0x39, Name = CLKRCON. 0x39, Bit Pos. = 7:0. 0x39, 7 = EN. 0x39, 6 = . 0x39, 5 = . 0x39, 4 = DC[1:0]. 0x39, 3 = . 0x39, 2 1 = DIV[2:0]. 0x39, 0 = . 0x3A, Name = CLKRCLK. 0x3A, Bit Pos. = 7:0. 0x3A, 7 = .",
    "23.6 Register Summary - Reference CLK\n0x3A, 6 = . 0x3A, 5 = . 0x3A, 4 = . 0x3A, 3 = . 0x3A, 2 1 = CLK[3:0]. 0x3A, 0 = ",
    "24. TMR0 - Timer0 Module\nThe Timer0 module has the following features:\n\u00b7 8-bit timer with programmable period\n\u00b7 16-bit timer\n\u00b7 Selectable clock sources\n\u00b7 Synchronous and asynchronous operation\n\u00b7 Programmable prescaler (Independent of Watchdog Timer)\n\u00b7 Programmable postscaler\n\u00b7 Interrupt on match or overflow\n\u00b7 Output on I/O pin (via PPS) or to other peripherals\n\u00b7 Operation during Sleep\nFigure 24-1. Timer0 Block Diagram\nPIC18F04/05/14/15Q41 TMR0 - Timer0 Module",
    "24.1 Timer0 Operation\nTimer0 can operate as either an 8-bit or 16-bit timer. The mode is selected with the MD16 bit.",
    "24.1.1 8-Bit Mode\nIn this mode, Timer0 increments on the rising edge of the selected clock source. A prescaler on the clock input gives several prescale options (see the prescaler control bits, CKPS). In this mode, as shown in Figure 24-1, a buffered version of TMR0H is maintained.\nThis is compared with the value of TMR0L on each cycle of the selected clock source. When the two values match, the following events occur:\n\u00b7 TMR0L is reset\n\u00b7 The contents of TMR0H are copied to the TMR0H buffer for next comparison",
    "24.1.2 16-Bit Mode\nIn this mode, Timer0 increments on the rising edge of the selected clock source. A prescaler on the clock input gives several prescale options (see the prescaler control bits, CKPS). In this mode, TMR0H:TMR0L form the 16-bit timer value. As shown in Figure 24-1, reads and writes of the TMR0H register are buffered. The TMR0H register is updated with the contents of the high byte of Timer0 when the TMR0L register is read. Similarly, writing the TMR0L register causes a transfer of the TMR0H register value to the Timer0 high byte.\nThis buffering allows all 16 bits of Timer0 to be read and written at the same time. Timer0 rolls over to 0x0000 on incrementing past 0xFFFF . This makes the timer free-running. While actively operating in 16-bit mode, the Timer0 value can be read but not written.",
    "24.2 Clock Selection\nTimer0 has several options for clock source selections, the option to operate synchronously/ asynchronously and an available programmable prescaler. The CS bits are used to select the clock source for Timer0.",
    "24.2.1 Synchronous Mode\nWhen the ASYNC bit is clear, Timer0 clock is synchronized to the system clock (F OSC/4). When operating in Synchronous mode, Timer0 clock frequency cannot exceed FOSC/4. During Sleep mode, the system clock is not available and Timer0 cannot operate.",
    "24.2.2 Asynchronous Mode\nWhen the ASYNC bit is set, Timer0 increments with each rising edge of the input source (or output of the prescaler, if used). Asynchronous mode allows Timer0 to continue operation during Sleep mode provided the selected clock source operates during Sleep.",
    "24.2.3 Programmable Prescaler\nTimer0 has 16 programmable input prescaler options ranging from 1:1 to 1:32768. The prescaler values are selected using the CKPS bits. The prescaler counter is not directly readable or writable. The prescaler counter is cleared on the following events:\n\u00b7 A write to the TMR0L register\n\u00b7 A write to either the T0CON0 or T0CON1 registers\n\u00b7 Any device Reset",
    "24.2.4 Programmable Postscaler\nTimer0 has 16 programmable output postscaler options ranging from 1:1 to 1:16. The postscaler values are selected using the OUTPS bits. The postscaler divides the output of Timer0 by the selected ratio. The postscaler counter is not directly readable or writable. The postscaler counter is cleared on the following events:\n\u00b7 A write to the TMR0L register\n\u00b7 A write to either the T0CON0 or T0CON1 registers\n\u00b7 Any device Reset",
    "24.3.1 Timer0 Output\nTMR0_out toggles on every match between TMR0L and TMR0H in 8-bit mode or when TMR0H:TMR0L rolls over in 16-bit mode. If the output postscaler is used, the output is scaled by the ratio selected. The Timer0 output can be routed to an I/O pin via the RxyPPS output selection register or internally to a number of Core Independent Peripherals. The Timer0 output can be monitored through software via the OUT output bit.\nImportant: In 8-bit mode, when PR0 = 0 (either loaded with 0 or resets to 0 ), the TMR0 output remains high, and no interrupts are generated.",
    "24.3.2 Timer0 Interrupt\nThe Timer0 Interrupt Flag (TMR0IF) bit is set when the TMR0_out toggles. If the Timer0 interrupt is enabled (TMR0IE), the CPU will be interrupted when the TMR0IF bit is set. When the postscaler bits (T0OUTPS) are set to 1:1 operation (no division), the T0IF flag bit will be set with every TMR0 match or rollover. In general, the TMR0IF flag bit will be set every T0OUTPS +1 matches or rollovers.",
    "24.3.3 Timer0 Example\nTimer0 Configuration:\n\u00b7 Timer0 mode = 16-bit\n\u00b7 Clock Source = FOSC/4 (250 kHz)\n\u00b7 Synchronous operation\n\u00b7 Prescaler = 1:1\n\u00b7 Postscaler = 1:2 (T0OUTPS = 1 )\nIn this case, the TMR0_out toggles every two rollovers of TMR0H:TMR0L. i.e., (0xFFFF)*2*(1/250 kHz) = 524.28 ms",
    "24.4 Operation During Sleep\nWhen operating synchronously, Timer0 will halt when the device enters Sleep mode. When operating asynchronously and the selected clock source is active, Timer0 will continue to increment and wake the device from Sleep mode if the Timer0 interrupt is enabled.",
    "24.5.1 T0CON0\nName: Address:\nT0CON0 0x31A",
    "Timer0 Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = MD16. , 5 = OUTPS[3:0]. , 6 = OUTPS[3:0]. , 7 = OUTPS[3:0]. , 8 = OUTPS[3:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = R. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN TMR0 Enable\n1, Description = The module is enabled and operating. 0, Description = The module is disabled",
    "Bit 4 - MD16 16-Bit Timer Operation Select\n1, Description = TMR0 is a 16-bit timer. 0, Description = TMR0 is an 8-bit timer",
    "Bits 3:0 - OUTPS[3:0] TMR0 Output Postscaler (Divider) Select\n1111, Description = 1:16 Postscaler. 1110, Description = 1:15 Postscaler. 1101, Description = 1:14 Postscaler. 1100, Description = 1:13 Postscaler. 1011, Description = 1:12 Postscaler. 1010, Description = 1:11 Postscaler. 1001, Description = 1:10 Postscaler. 1000, Description = 1:9 Postscaler. 0111, Description = 1:8 Postscaler. 0110, Description = 1:7 Postscaler. 0101, Description = 1:6 Postscaler. 0100, Description = 1:5 Postscaler. 0011, Description = 1:4 Postscaler. 0010, Description = 1:3 Postscaler. 0001, Description = 1:2 Postscaler. 0000, Description = 1:1 Postscaler",
    "24.5.2 T0CON1\nName: Address:\nT0CON1 0x31B",
    "Timer0 Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CS[2:0]. , 2 = CS[2:0]. , 3 = CS[2:0]. , 4 = ASYNC. , 5 = CKPS[3:0]. , 6 = CKPS[3:0]. , 7 = CKPS[3:0]. , 8 = CKPS[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:5 - CS[2:0] Timer0 Clock Source Select\n111, Description = CLC1_OUT. 110, Description = SOSC. 101, Description = MFINTOSC (500 kHz). 100, Description = LFINTOSC. 011, Description = HFINTOSC. 010, Description = F OSC /4. 001, Description = Pin selected by T0CKIPPS (Inverted). 000, Description = Pin selected by T0CKIPPS (Noninverted)",
    "Bit 4 - ASYNC TMR0 Input Asynchronization Enable\n1, Description = The input to the TMR0 counter is not synchronized to system clocks. 0, Description = The input to the TMR0 counter is synchronized to Fosc/4",
    "Bits 3:0 - CKPS[3:0] Prescaler Rate Select\n1111, Description = 1:32768. 1110, Description = 1:16384. 1101, Description = 1:8192. 1100, Description = 1:4096. 1011, Description = 1:2048. 1010, Description = 1:1024. 1001, Description = 1:512. 1000, Description = 1:256. 0111, Description = 1:128. 0110, Description = 1:64. 0101, Description = 1:32. 0100, Description = 1:16. 0011, Description = 1:8. 0010, Description = 1:4. 0001, Description = 1:2. 0000, Description = 1:1",
    "24.5.3 TMR0H\nName: Address:\nTMR0H 0x319",
    "Timer0 Period/Count High Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR0H[7:0]. , 2 = TMR0H[7:0]. , 3 = TMR0H[7:0]. , 4 = TMR0H[7:0]. , 5 = TMR0H[7:0]. , 6 = TMR0H[7:0]. , 7 = TMR0H[7:0]. , 8 = TMR0H[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1.",
    "Timer0 Period/Count High Register\nReset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:0 - TMR0H[7:0] TMR0 Most Significant Counter\n0 to 255, Condition = MD16 = 0. 0 to 255, Description = 8-bit Timer0 Period Value. TMR0L continues counting from 0 when this value is reached.. 0 to 255, Condition = MD16 = 1. 0 to 255, Description = 16-bit Timer0 Most Significant Byte",
    "24.5.4 TMR0L\nName: Address:\nTMR0L\n0x318",
    "Timer0 Period/Count Low Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR0L[7:0]. , 2 = TMR0L[7:0]. , 3 = TMR0L[7:0]. , 4 = TMR0L[7:0]. , 5 = TMR0L[7:0]. , 6 = TMR0L[7:0]. , 7 = TMR0L[7:0]. , 8 = TMR0L[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0.",
    "Timer0 Period/Count Low Register\nReset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - TMR0L[7:0] TMR0 Least Significant Counter\n0 to 255, Condition = MD16 = 0. 0 to 255, Description = 8-bit Timer0 Counter bits. 0 to 255, Condition = MD16 = 1. 0 to 255, Description = 16-bit Timer0 Least Significant Byte",
    "24.6 Register Summary - Timer0\n0x00 ... 0x0317, Name = Reserved. 0x00 ... 0x0317, Bit Pos. = . 0x00 ... 0x0317, 7 = . 0x00 ... 0x0317, 6 = . 0x00 ... 0x0317, 5 = . 0x00 ... 0x0317, 4 = . 0x00 ... 0x0317, 3 = . 0x00 ... 0x0317, 2 = . 0x00 ... 0x0317, 0 = . 0x0318, Name = TMR0L. 0x0318, Bit Pos. = 7:0. 0x0318, 7 = TMR0L[7:0]. 0x0318, 6 = TMR0L[7:0]. 0x0318, 5 = TMR0L[7:0]. 0x0318, 4 = TMR0L[7:0].",
    "24.6 Register Summary - Timer0\n0x0318, 3 = TMR0L[7:0]. 0x0318, 2 = TMR0L[7:0]. 0x0318, 0 = TMR0L[7:0]. 0x0319, Name = TMR0H. 0x0319, Bit Pos. = 7:0. 0x0319, 7 = TMR0H[7:0]. 0x0319, 6 = TMR0H[7:0]. 0x0319, 5 = TMR0H[7:0]. 0x0319, 4 = TMR0H[7:0]. 0x0319, 3 = TMR0H[7:0]. 0x0319, 2 = TMR0H[7:0]. 0x0319, 0 = TMR0H[7:0]. 0x031A, Name = T0CON0. 0x031A, Bit Pos. = 7:0.",
    "24.6 Register Summary - Timer0\n0x031A, 7 = EN. 0x031A, 6 = . 0x031A, 5 = OUT. 0x031A, 4 = MD16. 0x031A, 3 = . 0x031A, 2 = OUTPS[3:0]. 0x031A, 0 = . 0x031B, Name = T0CON1. 0x031B, Bit Pos. = 7:0. 0x031B, 7 = . 0x031B, 6 = CS[2:0]. 0x031B, 5 = . 0x031B, 4 = ASYNC. 0x031B, 3 = . 0x031B, 2 = CKPS[3:0]. 0x031B, 0 = ",
    "25. TMR1 - Timer1 Module with Gate Control\nThe Timer1 module is a 16-bit timer/counter with the following features:\n\u00b7 16-bit timer/counter register pair (TMRxH:TMRxL)\n\u00b7 Programmable internal or external clock source\n\u00b7 2-bit prescaler\n\u00b7 Clock source for optional comparator synchronization\n\u00b7 Multiple Timer1 gate (count enable) sources\n\u00b7 Interrupt-on-overflow\n\u00b7 Wake-up on overflow (external clock, Asynchronous mode only)\n\u00b7 16-bit read/write operation\n\u00b7 Time base for the capture/compare function with the CCP modules\n\u00b7 Special event trigger (with CCP)\n\u00b7 Selectable gate source polarity\n\u00b7 Gate Toggle mode\n\u00b7 Gate Single Pulse mode\n\u00b7 Gate value status\n\u00b7 Gate event interrupt\nImportant: References to the module Timer1 apply to all the odd numbered timers on this device.",
    "Figure 25-1. Timer1 Block Diagram\n\u4154\n\u7847\n\u5050\n\u5053",
    "Notes:\n1. This signal comes from the pin selected by Timer1 PPS register.\n2. TMRx register increments on rising edge.\n3. Synchronize does not operate while in Sleep.\n4. See TxCLK for clock source selections.\n5. See TxGATE for gate source selections.\n6. Synchronized comparator output must not be used in conjunction with synchronized input clock.",
    "25.1 Timer1 Operation\nThe Timer1 module is a 16-bit incrementing counter accessed through the TMRx register. Writes to TMRx directly update the counter. When used with an internal clock source, the module is a timer that increments on every instruction cycle. When used with an external clock source, the module can be used as either a timer or counter and increments on every selected edge of the external source.\nTimer1 is enabled by configuring the ON and GE bits. Table 25-1 shows the possible Timer1 enable selections.\n\u5478\n\u7266\n\u7843\n\u4520\n\u7365\n\u4d52\n\u504f\n\u4754\n\u4f4e\n\u4d52\n\u4d52\n\u434b\n\u5050\n\u7843\n\u454e\n\u5050\n\u7843\n\u5359\n\u3030\n\u3131\n\u7365\n\u5075\n\u5369\n\u4163\n\u4747\n\u2e20\n\u4f4e\n\u726f\n\u5350\n\u7363\n\u5072\n\u636b\n\u7a65\n\u6368\n\u726f\n\u5379\n\u4745\n\u726e\n\u7363\n\u636b\n\u7272\n\u7273\n\u7261\n\u6d70\n\u7a65\n\u6368\n\u726f\n\u5379\n\u536c\n\u5641\n\u4d52\n\u7365\nTable 25-1. Timer1 Enable Selections\n\n1, GE = 1. 1, Timer1 Operation = Count enabled. 1, GE = 0. 1, Timer1 Operation = Always on. 0, GE = 1. 0, Timer1 Operation = Off. 0, GE = 0. 0, Timer1 Operation = Off",
    "25.2 Clock Source Selection\nThe CS bits select the clock source for Timer1. These bits allow the selection of several possible synchronous and asynchronous clock sources.",
    "25.2.1 Internal Clock Source\nWhen the internal clock source is selected, the TMRx register will increment on multiples of F OSC as determined by the Timer1 prescaler.\nWhen the FOSC internal clock source is selected, the TMRx register value will increment by four counts every instruction clock cycle. Due to this condition, a two LSB error in resolution will occur when reading the TMRx value. To utilize the full resolution of Timer1, an asynchronous input signal must be used to gate the Timer1 clock input.\nImportant: In Counter mode, a falling edge must be registered by the counter prior to the first incrementing rising edge after any one or more of the following conditions:\n\u00b7 Timer1 enabled after POR\n\u00b7 Write to TMRxH or TMRxL\n\u00b7 Timer1 is disabled\n\u00b7 Timer1 is disabled (ON = 0 ) when TxCKI is high, then Timer1 is enabled (ON = 1 ) when TxCKI is low. Refer to the figure below.\nFigure 25-2. Timer1 Incrementing Edge\n\u5278\n\u434b\n\u3d20\n\u5278\n\u434b\n\u3d20",
    "Notes:\n1. Arrows indicate counter increments.\n2. In Counter mode, a falling edge must be registered by the counter prior to the first incrementing rising edge of the clock.",
    "25.2.2 External Clock Source\nWhen the external clock source is selected, the TMRx module may work as a timer or a counter. When enabled to count, Timer1 is incremented on the rising edge of the external clock input of the TxCKIPPS pin. This external clock source can be synchronized to the system clock or it can run asynchronously.",
    "25.3 Timer1 Prescaler\nTimer1 has four prescaler options allowing 1, 2, 4 or 8 divisions of the clock input. The CKPS bits control the prescale counter. The prescale counter is not directly readable or writable; however, the prescaler counter is cleared upon a write to TMRx.",
    "25.4 Timer1 Operation in Asynchronous Counter Mode\nWhen the SYNC Control bit is set, the external clock input is not synchronized. The timer increments asynchronously to the internal phase clocks. If the external clock source is selected, then the timer will continue to run during Sleep and can generate an interrupt on overflow, which will wake up the processor. However, special precautions in software are needed to read/write the timer.\nImportant: When switching from synchronous to asynchronous operation, it is possible to skip an increment. When switching from asynchronous to synchronous operation, it is possible to produce an additional increment.",
    "25.4.1 Reading and Writing TMRx in Asynchronous Counter Mode\nReading TMRxH or TMRxL while the timer is running from an external asynchronous clock will ensure a valid read (taken care of in hardware). However, the user must keep in mind that reading the 16-bit timer in two 8-bit values itself poses certain problems, since there may be a carry-out of TMRxL to TMRxH between the reads.\nFor writes, it is recommended that the user simply stop the timer and write the desired values. A write contention may occur by writing to the timer registers, while the register is incrementing. This may produce an unpredictable value in the TMRxH:TMRxL register pair.",
    "25.5 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured to read and write all 16 bits of data to and from the 8-bit TMRxL and TMRxH registers, simultaneously. The 16-bit read and write operations are enabled by setting the RD16 bit. To accomplish this function, the TMRxH register value is mapped to a buffer register called the TMRxH buffer register. While in 16-bit mode, the TMRxH register is not directly readable or writable and all read and write operations take place through the use of this TMRxH buffer register.",
    "25.5 Timer1 16-Bit Read/Write Mode\nWhen a read from the TMRxL register is requested, the value of the TMRxH register is simultaneously loaded into the TMRxH buffer register. When a read from the TMRxH register is requested, the value is provided from the TMRxH buffer register instead. This provides the user with the ability to accurately read all 16 bits of the Timer1 value from a single instance in time (refer to Figure 25-3 for more details). In contrast, when not in 16-bit mode, the user must read each register separately and determine if the values have become invalid due to a rollover that may have occurred between the read operations.",
    "25.5 Timer1 16-Bit Read/Write Mode\nWhen a write request of the TMRxL register is requested, the TMRxH buffer register is simultaneously updated with the contents of the TMRxH register. The value of TMRxH must be preloaded into the TMRxH buffer register prior to the write request for the TMRxL register. This provides the user with the ability to write all 16 bits to the TMRx register at the same time. Any requests to write to TMRxH directly does not clear the Timer1 prescaler value. The prescaler value is only cleared through write requests to the TMRxL register.\nFigure 25-3. Timer1 16-Bit Read/Write Mode Block Diagram\n\u726f\n\u6e74\n\u726e\n\u616c\n\u6120\n\u4275",
    "25.6 Timer1 Gate\nTimer1 can be configured to count freely or the count can be enabled and disabled using Timer1 gate circuitry. This is also referred to as Timer1 gate enable. Timer1 gate can also be driven by multiple selectable sources.",
    "25.6.1 Timer1 Gate Enable\nThe Timer1 Gate Enable mode is enabled by setting the GE bit. The polarity of the Timer1 Gate Enable mode is configured using the GPOL bit.\nWhen Timer1 Gate Enable mode is enabled, Timer1 will increment on the rising edge of the Timer1 clock source. When Timer1 Gate signal is inactive, the timer will not increment and hold the current count. Enable mode is disabled, no incrementing will occur and Timer1 will hold the current count. See Figure 25-4 for timing details.\nTable 25-2. Timer1 Gate Enable Selections\n\n\u2191, GPOL = 1. \u2191, TxG = 1. \u2191, Timer1 Operation = Counts. \u2191, GPOL = 1. \u2191, TxG = 0. \u2191, Timer1 Operation = Holds Count. \u2191, GPOL = 0. \u2191, TxG = 1. \u2191, Timer1 Operation = Holds Count. \u2191, GPOL = 0. \u2191, TxG = 0. \u2191, Timer1 Operation = Counts\n\u7269\n\u6561\n\u6520\n\u6972\n\u7569\n\u5365\n\u6f6e\n\u4f76\n\u6572\n\u6c6f",
    "Figure 25-4. Timer1 Gate Enable Mode\n\u494e",
    "25.6.2 Timer1 Gate Source Selection\nThe gate source for Timer1 is selected using the GSS bits. The polarity selection for the gate source is controlled by the GPOL bit.\nAny of the above mentioned signals can be used to trigger the gate. The output of the CMPx can be synchronized to the Timer1 clock or left asynchronous. For more information, refer to the 'Comparator Output Synchronization' section in the 'CMP - Comparator Module' chapter.",
    "25.6.3 Timer1 Gate Toggle Mode\nWhen Timer1 Gate Toggle mode is enabled, it is possible to measure the full-cycle length of a Timer1 Gate signal, as opposed to the duration of a single-level pulse. The Timer1 gate source is routed through a flip-flop that changes state on every incrementing edge of the signal. See the figure below for timing details.\nTimer1 Gate Toggle mode is enabled by setting the GTM bit. When the GTM bit is cleared, the flip-flop is cleared and held clear. This is necessary to control which edge is measured.\nImportant: Enabling Toggle mode at the same time as changing the gate polarity may result in indeterminate operation.",
    "Figure 25-5. Timer1 Gate Toggle Mode\n\u494e",
    "25.6.4 Timer1 Gate Single Pulse Mode\nWhen Timer1 Gate Single Pulse mode is enabled, it is possible to capture a single pulse gate event. Timer1 Gate Single Pulse mode is first enabled by setting the GSPM bit. Next, the GGO/DONE must be set. The Timer1 will be fully enabled on the next incrementing edge. On the next trailing edge of the pulse, the GGO/DONE bit will automatically be cleared. No other gate events will be allowed to increment Timer1 until the GGO/DONE bit is once again set in software.\nFigure 25-6. Timer1 Gate Single Pulse Mode\n\u4d52\n\u7847\n\u7847\n\u504f\n\u4d45\n\u4d52\n\u7847\n\u7847\n\u7847\n\u5350\n\u7847\n\u5641\n\u7847\n\u7843\n\u4b49\n\u494e\n\u736f\n\u7920\n\u7265\n\u7269\n\u7847\n\u7369\n\u736f\n\u7265\n\u7920\n\u5365\n\u7847\n\u5641\n\u7920\n\u7264\n\u7265\n\u7847\n\u5641\n\u5365\n\u7920\n\u7264\n\u7265\n\u7920\n\u7265\n\u736f\n\u7265\nClearing the GSPM bit will also clear the GGO/DONE bit. See the figure below for timing details. Enabling the Toggle mode and the Single Pulse mode simultaneously will permit both sections to work together. This allows the cycle times on the Timer1 gate source to be measured. See the figure below for timing details.\nFigure 25-7. Timer1 Gate Single Pulse and Toggle Combined Mode\n\u4d52\n\u7847\n\u7847",
    "25.6.4 Timer1 Gate Single Pulse Mode\n\u504f\n\u4d45\n\u4d52\n\u7847\n\u7265\n\u7920\n\u736f\n\u7265\n\u7920\n\u736f\n\u7265\n\u5365\n\u7920\n\u7264\n\u7265\n\u7847\n\u5641",
    "25.6.5 Timer1 Gate Value Status\nWhen Timer1 gate value status is utilized, it is possible to read the most current level of the gate control value. The value is stored in the GVAL bit in the TxGCON register. The GVAL bit is valid even when the Timer1 gate is not enabled (GE bit is cleared).",
    "25.6.6 Timer1 Gate Event Interrupt\nWhen Timer1 gate event interrupt is enabled, it is possible to generate an interrupt upon the completion of a gate event. When the falling edge of GVAL occurs, the TMRxGIF flag bit in one of the PIR registers will be set. If the TMRxGIE bit in the corresponding PIE register is set, then an interrupt will be recognized.\nThe TMRxGIF flag bit operates even when the Timer1 gate is not enabled (the GE bit is cleared). For more information on selecting high- or low-priority status for the Timer1 gate event interrupt, see the 'VIC - Vectored Interrupt Controller Module' chapter.",
    "25.7 Timer1 Interrupt\nThe TMRx register increments to FFFFh and rolls over to 0000h. When TMRx rolls over, the Timer1 interrupt flag bit of the PIRx register is set. To enable the interrupt-on-rollover, the following bits must be set:\n- \u00b7 The ON bit of the TxCON register\n\u7847\n\u7847\n\u5350\n\u7847\n\u5641\n\u7847\n\u7847\n\u7843\n\u4b49\n\u494e\n\u7847\n\u7269\n\u7369\n\u736f\n\u5365\n\u7920\n\u7265\n\u7920\n\u7264\n\u7265\n\u7847\n\u5641\n\u00b7 The TMRxIE bits of the PIEx register\n\u00b7 Global interrupts must be enabled\nThe interrupt is cleared by clearing the TMRxIF bit as a task in the Interrupt Service Routine. For more information on selecting high- or low-priority status for the Timer1 overflow interrupt, see the 'VIC - Vectored Interrupt Controller Module' chapter.\nImportant: The TMRx register and the TMRxIF bit must be cleared before enabling interrupts.",
    "25.8 Timer1 Operation During Sleep\nTimer1 can only operate during Sleep when configured as an asynchronous counter. In this mode, many clock sources can be used to increment the counter. To set up the timer to wake the device:\n\u00b7 The ON bit must be set\n\u00b7 The TMRxIE bit of the PIEx register must be set\n\u00b7 Global interrupts must be enabled\n\u00b7 The SYNC bit must be set\n\u00b7 Configure the TxCLK register for using any clock source other than F OSC and FOSC/4\nThe device will wake up on an overflow and execute the next instruction. If global interrupts are enabled, the device will call the IRS. The secondary oscillator will continue to operate in Sleep regardless of the SYNC bit setting.",
    "25.9 CCP Capture/Compare Time Base\nThe CCP modules use TMRx as the time base when operating in Capture or Compare mode. In Capture mode, the value in TMRx is copied into the CCPRx register on a capture event. In Compare mode, an event is triggered when the value in the CCPRx register matches the value in TMRx. This event can be a Special Event Trigger.",
    "25.10 CCP Special Event Trigger\nWhen any of the CCPs are configured to trigger a special event, the trigger will clear the TMRx register. This special event does not cause a Timer1 interrupt. The CCP module may still be configured to generate a CCP interrupt. In this mode of operation, the CCPRx register becomes the period register for Timer1. Timer1 must be synchronized and FOSC/4 must be selected as the clock source to utilize the Special Event Trigger. Asynchronous operation of Timer1 can cause a Special Event Trigger to be missed. In the event that a write to TMRxH or TMRxL coincides with a Special Event Trigger from the CCP, the write will take precedence.",
    "25.11 Peripheral Module Disable\nWhen a peripheral is not used or inactive, the module can be disabled by setting the Module Disable bit in the PMD registers. This will reduce power consumption to an absolute minimum. Setting the PMD bits holds the module in Reset and disconnects the module's clock source. The Module Disable bits for Timer1 (TMR1MD) are in the PMDx register. See the 'PMD - Peripheral Module Disable' chapter for more information.",
    "25.12 Register Definitions: Timer1 Control\nLong bit name prefixes for the Timer registers are shown in the table below, where 'x' refers to the Timer instance number. Refer to the ' Long Bit Names ' section in the ' Register and Bit Naming Conventions ' chapter for more information.\nTable 25-3. Timer1 Register Long Bit Name Prefixes\n\nTimer1, Bit Name Prefix = T1. Timer3, Bit Name Prefix = T3",
    "25.12.1  TxCON\nName: Address:\nTxCON 0x314,0x325\nTimer Control Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 2 1. Bit, 5 = 0. , 1 = . , 2 = CKPS[1:0]. , 3 = CKPS[1:0]. , 4 = SYNC RD16. , 5 = ON. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W R/W. Access, 5 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0 0. Reset, 5 = 0",
    "Bits 5:4 - CKPS[1:0] Timer Input Clock Prescaler Select\nReset States: POR/BOR = 00\nAll Other Resets = uu\n11, Description = 1:8 Prescaler value. 10, Description = 1:4 Prescaler value. 01, Description = 1:2 Prescaler value. 00, Description = 1:1 Prescaler value",
    "Bit 2 - SYNC Timer External Clock Input Synchronization Control\nReset States: POR/BOR = 0\nx, Condition = CS = F OSC /4 or F OSC. x, Description = This bit is ignored. Timer uses the incoming clock as is.. 1, Condition = All other clock sources. 1, Description = Do not synchronize external clock input. 0, Condition = All other clock sources. 0, Description = Synchronize external clock input with system clock\nAll Other Resets = u",
    "Bit 1 - RD16 16-Bit Read/Write Mode Enable\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Enables register read/write of Timer in one 16-bit operation. 0, Description = Enables register read/write of Timer in two 8-bit operations",
    "Bit 0 - ON Timer On\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Enables Timer. 0, Description = Disables Timer",
    "25.12.2  TxGCON\nName:\nTxGCON 0x315,0x326\nAddress:",
    "Timer Gate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GE. , 2 = GPOL. , 3 = GTM. , 4 = GSPM. , 5 = GGO/DONE. , 6 = GVAL. , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R. Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = x. Reset, 7 = . Reset, 8 = ",
    "Bit 7 - GE Timer Gate Enable\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Condition = ON = 1. 1, Description = Timer counting is controlled by the Timer gate function. 0, Condition = ON = 1. 0, Description = Timer is always counting. X, Condition = ON = 0. X, Description = This bit is ignored",
    "Bit 6 - GPOL Timer Gate Polarity\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Timer gate is active-high (Timer counts when gate is high). 0, Description = Timer gate is active-low (Timer counts when gate is low)",
    "Bit 5 - GTM Timer Gate Toggle Mode\nTimer Gate flip-flop toggles on every rising edge when Toggle mode is enabled.\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Timer Gate Toggle mode is enabled. 0, Description = Timer Gate Toggle mode is disabled and Toggle flip-flop is cleared",
    "Bit 4 - GSPM Timer Gate Single Pulse Mode\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Timer Gate Single Pulse mode is enabled and is controlling Timer gate. 0, Description = Timer Gate Single Pulse mode is disabled",
    "Bit 3 - GGO/DONE Timer Gate Single Pulse Acquisition Status\nThis bit is automatically cleared when TxGSPM is cleared.\nReset States: POR/BOR = 0\n1, Description = Timer Gate Single Pulse Acquisition is ready, waiting for an edge. 0, Description = Timer Gate Single Pulse Acquisition has completed or has not been started\nAll Other Resets = u",
    "Bit 2 - GVAL Timer Gate Current State\nIndicates the current state of the timer gate that can be provided to TMRxH:TMRxL",
    "25.12.3  TxCLK\nName: Address:\nTxCLK 0x317,0x328\nTimer Clock Source Selection Register\nBits 4:0 - CS[4:0] Timer Clock Source Selection\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\n\nTable 25-4. Timer Clock Sources",
    "25.12.3  TxCLK\n11111 - 10001, Clock Source.Timer1 = . 11111 - 10001, Clock Source. = Reserved. 11111 - 10001, Clock Source.Timer3 = . 10000, Clock Source.Timer1 = . 10000, Clock Source. = CLC4_OUT. 10000, Clock Source.Timer3 = . 01111, Clock Source.Timer1 = . 01111, Clock Source. = CLC3_OUT. 01111, Clock Source.Timer3 = . 01110, Clock Source.Timer1 = . 01110, Clock Source. = CLC2_OUT. 01110, Clock Source.Timer3 = . 01101, Clock Source.Timer1 = . 01101, Clock Source. = CLC1_OUT. 01101, Clock Source.Timer3 = . 01100, Clock Source.Timer1 = TMR3_OUT. 01100, Clock Source. = . 01100, Clock Source.Timer3 = Reserved. 01011, Clock Source.Timer1 = Reserved. 01011, Clock Source. = . 01011, Clock Source.Timer3 =",
    "25.12.3  TxCLK\nTMR1_OUT. 01010, Clock Source.Timer1 = . 01010, Clock Source. = TMR0_OUT. 01010, Clock Source.Timer3 = . 01001, Clock Source.Timer1 = . 01001, Clock Source. = CLKREF_OUT. 01001, Clock Source.Timer3 = . 01000, Clock Source.Timer1 = . 01000, Clock Source. = EXTOSC. 01000, Clock Source.Timer3 = . 00111, Clock Source.Timer1 = . 00111, Clock Source. = SOSC. 00111, Clock Source.Timer3 = . 00110, Clock Source.Timer1 = . 00110, Clock Source. = MFINTOSC (32 kHz). 00110, Clock Source.Timer3 = . 00101, Clock Source.Timer1 = . 00101, Clock Source. = MFINTOSC (500 kHz). 00101, Clock Source.Timer3 = . 00100, Clock Source.Timer1 = . 00100, Clock Source. = LFINTOSC. 00100, Clock Source.Timer3 = .",
    "25.12.3  TxCLK\n00011, Clock Source.Timer1 = . 00011, Clock Source. = HFINTOSC. 00011, Clock Source.Timer3 = . 00010, Clock Source.Timer1 = . 00010, Clock Source. = F OSC. 00010, Clock Source.Timer3 = . 00001, Clock Source.Timer1 = . 00001, Clock Source. = F OSC /4. 00001, Clock Source.Timer3 = . 00000, Clock Source.Timer1 = Pin selected by T1CKIPPS. 00000, Clock Source. = . 00000, Clock Source.Timer3 = Pin selected by T3CKIPPS\nReset States: POR/BOR = 00000 All Other Resets = uuuuu",
    "25.12.4  TxGATE\nName: Address:\nTxGATE 0x316,0x327\nTimer Gate Source Selection Register\nBits 4:0 - GSS[4:0] Timer Gate Source Selection\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\n\nTable 25-5. Timer Gate Sources",
    "25.12.4  TxGATE\n11111 - 10110, Gate Source.Timer1 = . 11111 - 10110, Gate Source.Timer3 = Reserved. 10101, Gate Source.Timer1 = . 10101, Gate Source.Timer3 = CLC4_OUT. 10100, Gate Source.Timer1 = . 10100, Gate Source.Timer3 = CLC3_OUT. 10011, Gate Source.Timer1 = . 10011, Gate Source.Timer3 = CLC2_OUT. 10010, Gate Source.Timer1 = . 10010, Gate Source.Timer3 = CLC1_OUT. 10001, Gate Source.Timer1 = . 10001, Gate Source.Timer3 = ZCD_OUT. 10000, Gate Source.Timer1 = . 10000, Gate Source.Timer3 = CMP2_OUT. 01111, Gate Source.Timer1 = . 01111, Gate Source.Timer3 = CMP1_OUT. 01110, Gate Source.Timer1 = . 01110, Gate Source.Timer3 = NCO1_OUT. 01101, Gate Source.Timer1 = . 01101, Gate",
    "25.12.4  TxGATE\nSource.Timer3 = PWM3S1P2_OUT. 01100, Gate Source.Timer1 = . 01100, Gate Source.Timer3 = PWM3S1P1_OUT. 01011, Gate Source.Timer1 = . 01011, Gate Source.Timer3 = PWM2S1P2_OUT. 01010, Gate Source.Timer1 = . 01010, Gate Source.Timer3 = PWM2S1P1_OUT. 01001, Gate Source.Timer1 = . 01001, Gate Source.Timer3 = PWM1S1P2_OUT. 01000, Gate Source.Timer1 = . 01000, Gate Source.Timer3 = PWM1S1P1_OUT. 00111, Gate Source.Timer1 = . 00111, Gate Source.Timer3 = CCP1_OUT. 00110, Gate Source.Timer1 = . 00110, Gate Source.Timer3 = SMT1_OUT. 00101, Gate Source.Timer1 = . 00101, Gate Source.Timer3 =",
    "25.12.4  TxGATE\nTMR4_Postscaler_OUT. 00100, Gate Source.Timer1 = TMR3_OUT. 00100, Gate Source.Timer3 = Reserved. 00011, Gate Source.Timer1 = TMR2_Postscaler_OUT. 00011, Gate Source.Timer3 = TMR2_Postscaler_OUT. 00010, Gate Source.Timer1 = Reserved. 00010, Gate Source.Timer3 = TMR1_OUT. 00001, Gate Source.Timer1 = TMR0_OUT. 00001, Gate Source.Timer3 = TMR0_OUT. 00000, Gate Source.Timer1 = Pin selected by T1GPPS. 00000, Gate Source.Timer3 = Pin selected by T3GPPS",
    "25.12.5  TMRx\nName: Address:\nTMRx 0x312,0x323",
    "Timer Register\nAccess, 15.TMRx[15:8] = R/W. Access, 14.TMRx[15:8] = R/W. Access, 13.TMRx[15:8] = R/W. Access, 12.TMRx[15:8] = R/W. Access, 11.TMRx[15:8] = R/W. Access, 10.TMRx[15:8] = R/W. Access, 9.TMRx[15:8] = R/W. Access, 8.TMRx[15:8] = R/W. Reset, 15.TMRx[15:8] = 0. Reset, 14.TMRx[15:8] = 0. Reset, 13.TMRx[15:8] = 0. Reset, 12.TMRx[15:8] = 0. Reset, 11.TMRx[15:8] = 0. Reset, 10.TMRx[15:8] = 0. Reset, 9.TMRx[15:8] =",
    "Timer Register\n0. Reset, 8.TMRx[15:8] = 0. Bit, 15.TMRx[15:8] = 7. Bit, 14.TMRx[15:8] = 6. Bit, 13.TMRx[15:8] = 5. Bit, 12.TMRx[15:8] = 4. Bit, 11.TMRx[15:8] = 3. Bit, 10.TMRx[15:8] = 2. Bit, 9.TMRx[15:8] = 1. Bit, 8.TMRx[15:8] = 0. , 15.TMRx[15:8] = TMRx[7:0]. , 14.TMRx[15:8] = TMRx[7:0]. , 13.TMRx[15:8] = TMRx[7:0]. , 12.TMRx[15:8] = TMRx[7:0]. , 11.TMRx[15:8] =",
    "Timer Register\nTMRx[7:0]. , 10.TMRx[15:8] = TMRx[7:0]. , 9.TMRx[15:8] = TMRx[7:0]. , 8.TMRx[15:8] = TMRx[7:0]. Access, 15.TMRx[15:8] = R/W. Access, 14.TMRx[15:8] = R/W. Access, 13.TMRx[15:8] = R/W. Access, 12.TMRx[15:8] = R/W. Access, 11.TMRx[15:8] = R/W. Access, 10.TMRx[15:8] = R/W. Access, 9.TMRx[15:8] = R/W. Access, 8.TMRx[15:8] = R/W. Reset, 15.TMRx[15:8] = 0. Reset, 14.TMRx[15:8] =",
    "Timer Register\n0. Reset, 13.TMRx[15:8] = 0. Reset, 12.TMRx[15:8] = 0. Reset, 11.TMRx[15:8] = 0. Reset, 10.TMRx[15:8] = 0. Reset, 9.TMRx[15:8] = 0. Reset, 8.TMRx[15:8] = 0",
    "Bits 15:0 - TMRx[15:0] Timer Register Value\nReset States: POR/BOR = 0000000000000000 All Other Resets = uuuuuuuuuuuuuuuu\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 TMRxH: Accesses the high byte TMRx[15:8]\n\u00b7 TMRxL: Accesses the low byte TMRx[7:0]",
    "25.13 Register Summary - Timer1\n0x00 ... 0x0311, Name = Reserved. 0x00 ... 0x0311, Bit Pos. = . 0x00 ... 0x0311, 7 = . 0x00 ... 0x0311, 6 = . 0x00 ... 0x0311, 5 = . 0x00 ... 0x0311, 4 = . 0x00 ... 0x0311, 3 = . 0x00 ... 0x0311, 2 = . 0x00 ... 0x0311, 1 = . 0x00 ... 0x0311, 0 = . 0x0312, Name = TMR1. 0x0312, Bit Pos. = 7:0. 0x0312, 7 = TMR1[7:0]. 0x0312, 6 = TMR1[7:0]. 0x0312, 5 = TMR1[7:0]. 0x0312, 4 =",
    "25.13 Register Summary - Timer1\nTMR1[7:0]. 0x0312, 3 = TMR1[7:0]. 0x0312, 2 = TMR1[7:0]. 0x0312, 1 = TMR1[7:0]. 0x0312, 0 = TMR1[7:0]. 0x0312, Name = TMR1. 0x0312, Bit Pos. = 15:8. 0x0312, 7 = TMR1[15:8]. 0x0312, 6 = TMR1[15:8]. 0x0312, 5 = TMR1[15:8]. 0x0312, 4 = TMR1[15:8]. 0x0312, 3 = TMR1[15:8]. 0x0312, 2 = TMR1[15:8]. 0x0312, 1 = TMR1[15:8]. 0x0312, 0 =",
    "25.13 Register Summary - Timer1\nTMR1[15:8]. 0x0314, Name = T1CON. 0x0314, Bit Pos. = 7:0. 0x0314, 7 = . 0x0314, 6 = . 0x0314, 5 = CKPS[1:0]. 0x0314, 4 = CKPS[1:0]. 0x0314, 3 = . 0x0314, 2 = SYNC. 0x0314, 1 = RD16. 0x0314, 0 = ON. 0x0315, Name = T1GCON. 0x0315, Bit Pos. = 7:0. 0x0315, 7 = GE. 0x0315, 6 = GPOL. 0x0315, 5 = GTM. 0x0315, 4 = GSPM. 0x0315, 3 = GGO/DONE. 0x0315, 2 = GVAL. 0x0315, 1 = . 0x0315, 0 = . 0x0316, Name =",
    "25.13 Register Summary - Timer1\nT1GATE. 0x0316, Bit Pos. = 7:0. 0x0316, 7 = . 0x0316, 6 = . 0x0316, 5 = . 0x0316, 4 = . 0x0316, 3 = . 0x0316, 2 = GSS[4:0]. 0x0316, 1 = . 0x0316, 0 = . 0x0317, Name = T1CLK. 0x0317, Bit Pos. = 7:0. 0x0317, 7 = . 0x0317, 6 = . 0x0317, 5 = . 0x0317, 4 = . 0x0317, 3 = . 0x0317, 2 = CS[4:0]. 0x0317, 1 = . 0x0317, 0 = . 0x0318 ... 0x0322, Name = Reserved. 0x0318 ... 0x0322, Bit Pos. = . 0x0318",
    "25.13 Register Summary - Timer1\n... 0x0322, 7 = . 0x0318 ... 0x0322, 6 = . 0x0318 ... 0x0322, 5 = . 0x0318 ... 0x0322, 4 = . 0x0318 ... 0x0322, 3 = . 0x0318 ... 0x0322, 2 = . 0x0318 ... 0x0322, 1 = . 0x0318 ... 0x0322, 0 = . 0x0323, Name = TMR3. 0x0323, Bit Pos. = 7:0. 0x0323, 7 = TMR3[7:0]. 0x0323, 6 = TMR3[7:0]. 0x0323, 5 = TMR3[7:0]. 0x0323, 4 = TMR3[7:0]. 0x0323, 3 =",
    "25.13 Register Summary - Timer1\nTMR3[7:0]. 0x0323, 2 = TMR3[7:0]. 0x0323, 1 = TMR3[7:0]. 0x0323, 0 = TMR3[7:0]. 0x0323, Name = TMR3. 0x0323, Bit Pos. = 15:8. 0x0323, 7 = TMR3[15:8]. 0x0323, 6 = TMR3[15:8]. 0x0323, 5 = TMR3[15:8]. 0x0323, 4 = TMR3[15:8]. 0x0323, 3 = TMR3[15:8]. 0x0323, 2 = TMR3[15:8]. 0x0323, 1 = TMR3[15:8]. 0x0323, 0 = TMR3[15:8]. 0x0325, Name = T3CON.",
    "25.13 Register Summary - Timer1\n0x0325, Bit Pos. = 7:0. 0x0325, 7 = . 0x0325, 6 = . 0x0325, 5 = CKPS[1:0]. 0x0325, 4 = CKPS[1:0]. 0x0325, 3 = . 0x0325, 2 = SYNC. 0x0325, 1 = RD16. 0x0325, 0 = ON. 0x0326, Name = T3GCON. 0x0326, Bit Pos. = 7:0. 0x0326, 7 = GE. 0x0326, 6 = GPOL. 0x0326, 5 = GTM. 0x0326, 4 = GSPM. 0x0326, 3 = GGO/DONE. 0x0326, 2 = GVAL. 0x0326, 1 = . 0x0326, 0 = . 0x0327, Name = T3GATE. 0x0327, Bit Pos. = 7:0.",
    "25.13 Register Summary - Timer1\n0x0327, 7 = . 0x0327, 6 = . 0x0327, 5 = . 0x0327, 4 = . 0x0327, 3 = . 0x0327, 2 = GSS[4:0]. 0x0327, 1 = . 0x0327, 0 = . 0x0328, Name = T3CLK. 0x0328, Bit Pos. = 7:0. 0x0328, 7 = . 0x0328, 6 = . 0x0328, 5 = . 0x0328, 4 = . 0x0328, 3 = . 0x0328, 2 = CS[4:0]. 0x0328, 1 = . 0x0328, 0 = ",
    "26. TMR2 - Timer2 Module\nThe Timer2 module is an 8-bit timer that incorporates the following features:\n\u00b7 8-bit timer and period registers\n\u00b7 Readable and writable\n\u00b7 Software programmable prescaler (1:1 to 1:128)\n\u00b7 Software programmable postscaler (1:1 to 1:16)\n\u00b7 Interrupt on T2TMR match with T2PR\n\u00b7 One-shot operation\n\u00b7 Full asynchronous operation\n\u00b7 Includes Hardware Limit Timer (HLT)\n\u00b7 Alternate clock sources\n\u00b7 External timer Reset signal sources\n\u00b7 Configurable timer Reset operation\nSee the figure below for a block diagram of Timer2.\nImportant: References to module Timer2 apply to all the even numbered timers on this device (Timer2, Timer4, etc.).\nFigure 26-1. Timer2 with Hardware Limit Timer (HLT) Block Diagram",
    "Notes:\n1. Signal to the CCP peripheral for PWM pulse trigger in PWM mode.\n2. See RSEL for external Reset sources.\n3. See CS for clock source selections.",
    "26.1 Timer2 Operation\nTimer2 operates in three major modes:\n\u00b7 Free-Running Period\n\u00b7 One Shot\n\u00b7 Monostable\nWithin each operating mode, there are several options for starting, stopping and Reset. Table 26-1 lists the options.\nIn all modes, the T2TMR count register increments on the rising edge of the clock signal from the programmable prescaler. When T2TMR equals T2PR, a high-level output to the postscaler counter is generated. T2TMR is cleared on the next clock input.\nAn external signal from hardware can also be configured to gate the timer operation or force a T2TMR count Reset. In Gate modes, the counter stops when the gate is disabled and resumes when the gate is enabled. In Reset modes, the T2TMR count is reset on either the level or edge from the external source.\nThe T2TMR and T2PR registers are both directly readable and writable. The T2TMR register is cleared and the T2PR register initializes to 0xFF on any device Reset. Both the prescaler and postscaler counters are cleared on the following events:",
    "26.1 Timer2 Operation\n\u00b7 A write to the T2TMR register\n\u00b7 A write to the T2CON register\n\u00b7 Any device Reset\n\u00b7 External Reset source event that resets the timer\nImportant: T2TMR is not cleared when T2CON is written.",
    "26.1.1 Free-Running Period Mode\nThe value of T2TMR is compared to that of the period register, T2PR, on each clock cycle. When the two values match, the comparator resets the value of T2TMR to 0x00 on the next cycle and increments the output postscaler counter. When the postscaler count equals the value in the OUTPS bits of the T2CON register, a one clock period wide pulse occurs on the TMR2_postscaled output, and the postscaler count is cleared.",
    "26.1.2 One Shot Mode\nThe One Shot mode is identical to the Free-Running Period mode except that the ON bit is cleared and the timer is stopped when T2TMR matches T2PR and will not restart until the ON bit is cycled off and on. Postscaler (OUTPS) values other than zero are ignored in this mode because the timer is stopped at the first period event and the postscaler is reset when the timer is restarted.",
    "26.1.3 Monostable Mode\nMonostable modes are similar to One Shot modes except that the ON bit is not cleared and the timer can be restarted by an external Reset event.\nPIC18F04/05/14/15Q41 TMR2 - Timer2 Module",
    "26.2 Timer2 Output\nThe Timer2 module's primary output is TMR2_postscaled, which pulses for a single TMR2_clk period upon each match of the postscaler counter and the OUTPS bits of the T2CON register. The postscaler is incremented each time the T2TMR value matches the T2PR value. This signal can also be selected as an input to other Core Independent Peripherals.\nIn addition, the Timer2 is also used by the CCP module for pulse generation in PWM mode. See the ' PWM Overview ' and ' PWM Period ' sections in the 'CCP - Capture/Compare/PWM Module' chapter for more details on setting up Timer2 for use with the CCP and PWM modules.",
    "26.3 External Reset Sources\nIn addition to the clock source, the Timer2 can also be driven by an external Reset source input. This external Reset input is selected for each timer with the corresponding TxRST register. The external Reset input can control starting and stopping of the timer, as well as resetting the timer, depending on the mode used.",
    "26.4 Timer2 Interrupt\nTimer2 can also generate a device interrupt. The interrupt is generated when the postscaler counter matches the selected postscaler value (OUTPS bits of T2CON register). The interrupt is enabled by setting the TMR2IE interrupt enable bit. Interrupt timing is illustrated in the figure below.\nFigure 26-2. Timer2 Prescaler, Postscaler, and Interrupt Timing Diagram\nRev. 10-000 205B\n3/6/201 9\nTMRx_clk\nTxPR\nTxTMR\n1\n0\nCKPS\n'b010\nTMRx_postscaled\nOUTPS\n'b0001\n1\n0\n1\n0\n1\n0\nTMRxIF\n(1)\n(1)\n(2)\nNotes:\n1. Setting the interrupt flag is synchronized with the instruction clock.\nSynchronization may take as many as two instruction cycles .\n2 Cleared by software. .",
    "26.5 PSYNC Bit\nSetting the PSYNC bit synchronizes the prescaler output to F OSC/4. Setting this bit is required for reading the Timer2 counter register while the selected Timer clock is asynchronous to F OSC/4.\nNote: Setting PSYNC requires that the output of the prescaler is slower than F OSC/4. Setting PSYNC when the output of the prescaler is greater than or equal to F OSC/4 may cause unexpected results.",
    "26.6 CSYNC Bit\nAll bits in the Timer2 SFRs are synchronized to F OSC/4 by default, not the Timer2 input clock. As such, if the Timer2 input clock is not synchronized to F OSC/4, it is possible for the Timer2 input clock to transition at the same time as the ON bit is set in software, which may cause undesirable behavior and glitches in the counter. Setting the CSYNC bit remedies this problem by synchronizing the ON bit to the Timer2 input clock instead of F OSC/4. However, as this synchronization uses an edge of the TMR2 input clock, up to one input clock cycle will be consumed and not counted by the Timer2 when\nCSYNC is set. Conversely, clearing the CSYNC bit synchronizes the ON bit to F OSC/4, which does not consume any clock edges but has the previously stated risk of glitches.",
    "26.7 Operating Modes\nThe mode of the timer is controlled by the MODE bits. Edge Triggered modes require six Timer clock periods between external triggers. Level Triggered modes require the triggering level to be at least three Timer clock periods long. External triggers are ignored while in Debug mode.\n\nTable 26-1. Operating Modes Table",
    "26.7 Operating Modes\nFree-Running Period, MODE.[4:3] = . Free-Running Period, MODE.[2:0] = 000 001. Free-Running Period, Output Operation. = Period Pulse. Free-Running Period, Operation. = Software gate (Figure 26-3) Hardware gate, active-high (Figure 26-4). Free-Running Period, Timer Control.Start = ON = 1 ON = 1 and TMRx_ers = 1. Free-Running Period, Timer Control.Reset = - -. Free-Running Period, Timer Control.Stop = ON = 0 ON = 0 or TMRx_ers = 0. Free-Running Period, MODE.[4:3] = . Free-Running Period, MODE.[2:0] = . Free-Running Period, Output Operation. = Period Pulse. Free-Running Period, Operation. = . Free-Running Period, Timer Control.Start = ON = 1 and TMRx_ers = 0. Free-Running Period, Timer Control.Reset = -. Free-Running Period, Timer Control.Stop = ON = 0 or TMRx_ers = 1. Free-Running",
    "26.7 Operating Modes\nPeriod, MODE.[4:3] = . Free-Running Period, MODE.[2:0] = 010. Free-Running Period, Output Operation. = Period Pulse. Free-Running Period, Operation. = Hardware gate, active-low. Free-Running Period, Timer Control.Start = ON = 1. Free-Running Period, Timer Control.Reset = TMRx_ers \u2195. Free-Running Period, Timer Control.Stop = . Free-Running Period, MODE.[4:3] = 00. Free-Running Period, MODE.[2:0] = 011 100. Free-Running Period, Output Operation. = . Free-Running Period, Operation. = Rising or falling edge Reset Rising edge Reset (Figure 26-5). Free-Running Period, Timer Control.Start = . Free-Running Period, Timer Control.Reset = TMRx_ers \u2191. Free-Running Period, Timer Control.Stop = ON = 0. Free-Running Period, MODE.[4:3] = . Free-Running Period, MODE.[2:0] = 101. Free-Running Period, Output Operation. = Period Pulse with Hardware Reset.",
    "26.7 Operating Modes\nFree-Running Period, Operation. = . Free-Running Period, Timer Control.Start = . Free-Running Period, Timer Control.Reset = . Free-Running Period, Timer Control.Stop = ON = 0. Free-Running Period, MODE.[4:3] = . Free-Running Period, MODE.[2:0] = 110. Free-Running Period, Output Operation. = Period Pulse with Hardware Reset. Free-Running Period, Operation. = Falling edge Reset Low-level Reset. Free-Running Period, Timer Control.Start = . Free-Running Period, Timer Control.Reset = TMRx_ers \u2193 TMRx_ers = 0. Free-Running Period, Timer Control.Stop = ON = 0 or TMRx_ers = 0. Free-Running Period, MODE.[4:3] = . Free-Running Period, MODE.[2:0] = 111. Free-Running Period, Output Operation. = Period Pulse with Hardware Reset. Free-Running Period, Operation. = High-level Reset (Figure 26-6). Free-Running Period, Timer Control.Start = . Free-Running Period, Timer Control.Reset",
    "26.7 Operating Modes\n= TMRx_ers = 1. Free-Running Period, Timer Control.Stop = ON = 0 or TMRx_ers = 1. , MODE.[4:3] = . , MODE.[2:0] = 000. , Output Operation. = One-shot. , Operation. = Software start (Figure 26-7). , Timer Control.Start = ON = 1. , Timer Control.Reset = -. , Timer Control.Stop = ON = 0 or. , MODE.[4:3] = . , MODE.[2:0] = 001. , Output Operation. = . , Operation. = Rising edge start (Figure 26-8). , Timer Control.Start = ON = 1 and TMRx_ers \u2191. , Timer Control.Reset = -. , Timer Control.Stop = ON = 0 or. , MODE.[4:3] = . , MODE.[2:0] = 010. , Output Operation. = Edge-Triggered Start (Note 1). , Operation. = Falling edge start. , Timer Control.Start = ON = 1 and TMRx_ers \u2193. , Timer",
    "26.7 Operating Modes\nControl.Reset = -. , Timer Control.Stop = . , MODE.[4:3] = . , MODE.[2:0] = 011. , Output Operation. = . , Operation. = Any edge start. , Timer Control.Start = ON = 1 and TMRx_ers \u2195. , Timer Control.Reset = -. , Timer Control.Stop = Next clock after. One Shot, MODE.[4:3] = 01. One Shot, MODE.[2:0] = 100. One Shot, Output Operation. = . One Shot, Operation. = Rising edge start and Rising edge Reset (Figure 26-9). One Shot, Timer Control.Start = ON = 1 and TMRx_ers \u2191. One Shot, Timer Control.Reset = TMRx_ers \u2191. One Shot, Timer Control.Stop = TxTMR = TxPR. , MODE.[4:3] = . , MODE.[2:0] = 101. , Output Operation. = Edge-Triggered Start and. , Operation. = Falling edge start and Falling edge Reset. , Timer Control.Start = ON = 1 and",
    "26.7 Operating Modes\nTMRx_ers \u2193. , Timer Control.Reset = TMRx_ers \u2193. , Timer Control.Stop = (Note 2). , MODE.[4:3] = . , MODE.[2:0] = 110. , Output Operation. = Hardware Reset (Note 1). , Operation. = Rising edge start and Low-level Reset (Figure 26-10). , Timer Control.Start = ON = 1 and TMRx_ers \u2191. , Timer Control.Reset = TMRx_ers = 0. , Timer Control.Stop = TxTMR = TxPR. , MODE.[4:3] = . , MODE.[2:0] = 111. , Output Operation. = Hardware Reset (Note 1). , Operation. = Falling edge start and High-level Reset. , Timer Control.Start = ON = 1 and TMRx_ers \u2193. , Timer Control.Reset = TMRx_ers = 1. , Timer Control.Stop = TxTMR = TxPR. , MODE.[4:3] = . , MODE.[2:0] = 000. ,",
    "26.7 Operating Modes\nOutput Operation. = Reserved. , Operation. = Reserved. , Timer Control.Start = Reserved. , Timer Control.Reset = Reserved. , Timer Control.Stop = Reserved. , MODE.[4:3] = . , MODE.[2:0] = 001. , Output Operation. = . , Operation. = Rising edge start (Figure 26-11). , Timer Control.Start = ON = 1 and TMRx_ers \u2191. , Timer Control.Reset = -. , Timer Control.Stop = ON = 0 or. Monostable, MODE.[4:3] = . Monostable, MODE.[2:0] = 010. Monostable, Output Operation. = Edge-Triggered Start (Note 1). Monostable, Operation. = Falling edge start. Monostable, Timer Control.Start = ON = 1 and TMRx_ers \u2193. Monostable, Timer Control.Reset = -. Monostable, Timer Control.Stop = Next clock after TxTMR = TxPR. , MODE.[4:3] = . , MODE.[2:0] = 011. , Output Operation. =",
    "26.7 Operating Modes\nEdge-Triggered Start (Note 1). , Operation. = Any edge start. , Timer Control.Start = ON = 1 and TMRx_ers \u2195. , Timer Control.Reset = -. , Timer Control.Stop = (Note 3). Reserved, MODE.[4:3] = 10. Reserved, MODE.[2:0] = 100. Reserved, Output Operation. = Reserved. Reserved, Operation. = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved. Reserved, MODE.[4:3] = . Reserved, MODE.[2:0] = 101. Reserved, Output Operation. = Reserved. Reserved, Operation. = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved. , MODE.[4:3] = . , MODE.[2:0] = 110. , Output Operation. = Level-Triggered Start and. , Operation. = High-level start and Low-level Reset (Figure 26-12). , Timer Control.Start = ON = 1 and",
    "26.7 Operating Modes\nTMRx_ers = 1. , Timer Control.Reset = TMRx_ers = 0. , Timer Control.Stop = ON = 0 or Held in Reset. One Shot, MODE.[4:3] = . One Shot, MODE.[2:0] = 111. One Shot, Output Operation. = Hardware Reset. One Shot, Operation. = Low-level start and High-level Reset. One Shot, Timer Control.Start = ON = 1 and TMRx_ers = 0. One Shot, Timer Control.Reset = TMRx_ers = 1. One Shot, Timer Control.Stop = (Note 2). Reserved, MODE.[4:3] = 11. Reserved, MODE.[2:0] = xxx. Reserved, Output Operation. = Reserved. Reserved, Operation. = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved",
    "Notes:\n1. If ON = 0 , then an edge is required to restart the timer after ON = 1 .\n2. When T2TMR = T2PR, the next clock clears ON and stops T2TMR at 00h .\n3. When T2TMR = T2PR, the next clock stops T2TMR at 00h but does not clear ON.",
    "26.8 Operation Examples\nUnless otherwise specified, the following notes apply to the following timing diagrams:\n\u00b7 Both the prescaler and postscaler are set to 1:1 (both the CKPS and OUTPS bits).\n\u00b7 The diagrams illustrate any clock except F OSC/4 and show clock-sync delays of at least two full cycles for both ON and TMRx_ers. When using FOSC/4, the clock-sync delay is at least one instruction period for TMRx_ers; ON applies in the next instruction period.\n\u00b7 ON and TMRx_ers are somewhat generalized, and clock-sync delays may produce results that are slightly different than illustrated.\n\u00b7 The PWM Duty Cycle and PWM output are illustrated assuming that the timer is used for the PWM function of the CCP module as described in the ' PWM Overview ' section in the ' CCP Capture/Compare/PWM Module ' chapter. The signals are not a part of the Timer2 module.",
    "26.8.1 Software Gate Mode\nThis mode corresponds to legacy Timer2 operation. The timer increments with each clock input when ON = 1 and does not increment when ON = 0 . When the TxTMR count equals the TxPR period count, the timer resets on the next clock and continues counting from zero. Operation with the ON bit software controlled is illustrated in Figure 26-3. With TxPR = 5 , the counter advances until TxTMR = 5 and goes to zero with the next clock.\nFigure 26-3. Software Gate Mode Timing Diagram (MODE = 'b00000 )\nRev. 10-000 195C\n3/6/201 9\nTMRx_clk\nInstruction (1)\nON\nTxPR\nTxTMR\nTMRx_postscaled\nBSF\nBCF\nBSF\n5\n0\n1\n2\n3\n4\n5\n0\n1\n2\n2\n3\n4\n5\n3\n4\n5\n0\n1\n0\n1\nPWM Duty Cycle\n3\nPWM Output\nNote:\n1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "26.8.2 Hardware Gate Mode\nThe Hardware Gate modes operate the same as the Software Gate mode, except the TMRx_ers external signal can also gate the timer. When used with the CCP, the gating extends the PWM period. If the timer is stopped when the PWM output is high, then the duty cycle is also extended.\nWhen MODE = 'b00001 , then the timer is stopped when the external signal is high. When MODE = 'b00010 , then the timer is stopped when the external signal is low.\nFigure 26-4 illustrates the Hardware Gating mode for MODE = 'b00001 in which a high input level starts the counter.\nFigure 26-4. Hardware Gate Mode Timing Diagram (MODE = 'b00001 )\n\u2e20\n\u3130",
    "26.8.3 Edge Triggered Hardware Limit Mode\nIn Hardware Limit mode, the timer can be reset by the TMRx_ers external signal before the timer reaches the period count. Three types of Resets are possible:\n\u00b7 Reset on rising or falling edge (MODE = 'b00011 )\n\u00b7 Reset on rising edge (MODE = 'b00100 )\n\u00b7 Reset on falling edge (MODE = 'b00101 )\nWhen the timer is used in conjunction with the CCP in PWM mode then an early Reset shortens the period and restarts the PWM pulse after a two clock delay. Refer to Figure 26-5.",
    "Figure 26-5. Edge Triggered Hardware Limit Mode Timing Diagram (MODE = 'b00100 )\nRev. 10-000197C 3/6/2019\nNote:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.\nPIC18F04/05/14/15Q41\nTMR2 - Timer2 Module",
    "26.8.4 Level Triggered Hardware Limit Mode\nIn the Level Triggered Hardware Limit Timer modes the counter is reset by high or low levels of the external signal TMRx_ers, as shown in Figure 26-6. Selecting MODE = 'b00110 will cause the timer to reset on a low-level external signal. Selecting MODE = 'b00111 will cause the timer to reset on a high-level external signal. In the example, the counter is reset while TMRx_ers = 1 . ON is controlled by BSF and BCF instructions. When ON = 0 , the external signal is ignored.\nWhen the CCP uses the timer as the PWM time base, then the PWM output will be set high when the timer starts counting and then set low only when the timer count matches the CCPRx value. The timer is reset when either the timer count matches the TxPR value or two clock periods after the external Reset signal goes true and stays true.",
    "26.8.4 Level Triggered Hardware Limit Mode\nThe timer starts counting, and the PWM output is set high on either the clock following the TxPR match or two clocks after the external Reset signal relinquishes the Reset. The PWM output will remain high until the timer counts up to match the CCPRx pulse-width value. If the external Reset signal goes true while the PWM output is high, then the PWM output will remain high until the Reset signal is released allowing the timer to count up to match the CCPRx value.\nFigure 26-6. Level Triggered Hardware Limit Mode Timing Diagram (MODE = 'b00111 )\nRev. 10-000 198C\n3/5/201 9",
    "TMRx_clk\nON\nTxPR\nTxTMR\nBSF\nBCF\nBSF\n5\n0\n1\n2\n0\n1\n2\n3\n4\n5\n1\n2\n3\nTMRx_ers\n0\n0\n4\nTMRx_postscaled\n5\n0\nPWM Duty Cycle\n3\nPWM Output\nInstruction (1)\nNote:\n1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.\nPIC18F04/05/14/15Q41 TMR2 - Timer2 Module",
    "26.8.5 Software Start One Shot Mode\nIn One Shot mode, the timer resets and the ON bit is cleared when the timer value matches the TxPR period value. The ON bit must be set by software to start another timer cycle. Setting MODE = 'b01000 selects One Shot mode which is illustrated in Figure 26-7. In the example, ON is controlled by BSF and BCF instructions. In the first case, a BSF instruction sets ON and the counter runs to completion and clears ON. In the second case, a BSF instruction starts the cycle, the BCF BSF / instructions turn the counter off and on during the cycle, and then it runs to completion.",
    "26.8.5 Software Start One Shot Mode\nWhen One Shot mode is used in conjunction with the CCP PWM operation, the PWM pulse drive starts concurrent with setting the ON bit. Clearing the ON bit while the PWM drive is active will extend the PWM drive. The PWM drive will terminate when the timer value matches the CCPRx pulse-width value. The PWM drive will remain off until the software sets the ON bit to start another cycle. If the software clears the ON bit after the CCPRx match but before the TxPR match, then the PWM drive will be extended by the length of time the ON bit remains cleared. Another timing cycle can only be initiated by setting the ON bit after it has been cleared by a TxPR period count match.\nFigure 26-7. Software Start One Shot Mode Timing Diagram (MODE = 'b01000 )\nNote:\n1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON.  CPU execution is asynchronous to the timer clock input.",
    "26.8.5 Software Start One Shot Mode\nPIC18F04/05/14/15Q41 TMR2 - Timer2 Module",
    "26.8.6 Edge Triggered One Shot Mode\nThe Edge Triggered One Shot modes start the timer on an edge from the external signal input after the ON bit is set and clear the ON bit when the timer matches the TxPR period value. The following edges will start the timer:\n\u00b7 Rising edge (MODE = 'b01001 )\n\u00b7 Falling edge (MODE = 'b01010 )\n\u00b7 Rising or Falling edge (MODE = 'b01011 )\nIf the timer is halted by clearing the ON bit, then another TMRx_ers edge is required after the ON bit is set to resume counting. Figure 26-8 illustrates operation in the rising edge One Shot mode.\nWhen Edge Triggered One Shot mode is used in conjunction with the CCP, then the edge-trigger will activate the PWM drive and the PWM drive will deactivate when the timer matches the CCPRx pulse-width value and stay deactivated when the timer halts at the TxPR period count match.\nFigure 26-8. Edge Triggered One Shot Mode Timing Diagram (MODE = 'b01001 )\nNote:",
    "26.8.6 Edge Triggered One Shot Mode\n1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.\nPIC18F04/05/14/15Q41 TMR2 - Timer2 Module",
    "26.8.7 Edge Triggered Hardware Limit One Shot Mode\nIn Edge Triggered Hardware Limit One Shot modes, the timer starts on the first external signal edge after the ON bit is set and resets on all subsequent edges. Only the first edge after the ON bit is set is needed to start the timer. The counter will resume counting automatically two clocks after all subsequent external Reset edges. Edge triggers are as follows:\n\u00b7 Rising edge start and Reset (MODE = 'b01100 )\n\u00b7 Falling edge start and Reset (MODE = 'b01101 )\nThe timer resets and clears the ON bit when the timer value matches the TxPR period value. External signal edges will have no effect until after software sets the ON bit. Figure 26-9 illustrates the rising edge hardware limit one-shot operation.\nWhen this mode is used in conjunction with the CCP, the first starting edge trigger and all subsequent Reset edges will activate the PWM drive. The PWM drive will deactivate when the timer matches the CCPRx pulse-width value and stay deactivated until the timer halts at the TxPR period match unless an external signal edge resets the timer before the match occurs.",
    "26.8.7 Edge Triggered Hardware Limit One Shot Mode\nFigure 26-9. Edge Triggered Hardware Limit One Shot Mode Timing Diagram (MODE = 'b01100 )\nRev. 10-000 201C\n3/6/201 9\nNote:\n1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.\nPIC18F04/05/14/15Q41 TMR2 - Timer2 Module",
    "26.8.8 Level Reset, Edge Triggered Hardware Limit One Shot Modes\nIn Level Triggered One Shot mode, the timer count is reset on the external signal level and starts counting on the rising/falling edge of the transition from Reset level to the active level while the ON bit is set. Reset levels are selected as follows:\n\u00b7 Low Reset level (MODE = 'b01110 )\n\u00b7 High Reset level (MODE = 'b01111 )\nWhen the timer count matches the TxPR period count, the timer is reset and the ON bit is cleared. When the ON bit is cleared by either a TxPR match or by software control, a new external signal edge is required after the ON bit is set to start the counter.\nWhen Level-Triggered Reset One Shot mode is used in conjunction with the CCP PWM operation, the PWM drive goes active with the external signal edge that starts the timer. The PWM drive goes inactive when the timer count equals the CCPRx pulse-width count. The PWM drive does not go active when the timer count clears at the TxPR period count match.\nFigure 26-10. Low Level Reset, Edge Triggered Hardware Limit One Shot Mode Timing Diagram (MODE = 'b01110 )",
    "26.8.8 Level Reset, Edge Triggered Hardware Limit One Shot Modes\nNote: 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "26.8.9 Edge Triggered Monostable Modes\nThe Edge Triggered Monostable modes start the timer on an edge from the external Reset signal input after the ON bit is set and stop incrementing the timer when the timer matches the TxPR period value. The following edges will start the timer:\n\u00b7 Rising edge (MODE = 'b10001 )\n\u00b7 Falling edge (MODE = 'b10010 )\n\u00b7 Rising or Falling edge (MODE = 'b10011 )\nWhen an Edge Triggered Monostable mode is used in conjunction with the CCP PWM operation, the PWM drive goes active with the external Reset signal edge that starts the timer but will not go active when the timer matches the TxPR value. While the timer is incrementing, additional edges on the external Reset signal will not affect the CCP PWM.",
    "Figure 26-11. Rising Edge Triggered Monostable Mode Timing Diagram (MODE = 'b10001 )\nRev. 10-000203B\n3/6/2019",
    "26.8.10  Level Triggered Hardware Limit One Shot Modes\nThe Level Triggered Hardware Limit One Shot modes hold the timer in Reset on an external Reset level and start counting when both the ON bit is set and the external signal is not at the Reset level. If one of either the external signal is not in Reset or the ON bit is set, then the other signal being set/made active will start the timer. Reset levels are selected as follows:\n\u00b7 Low Reset level (MODE = 'b10110 )\n\u00b7 High Reset level (MODE = 'b10111 )\nWhen the timer count matches the TxPR period count, the timer is reset and the ON bit is cleared. When the ON bit is cleared by either a TxPR match or by software control, the timer will stay in Reset until both the ON bit is set and the external signal is not at the Reset level.\nWhen Level Triggered Hardware Limit One Shot modes are used in conjunction with the CCP PWM operation, the PWM drive goes active with either the external signal edge or the setting of the ON bit, whichever of the two starts the timer.\nFigure 26-12. Level Triggered Hardware Limit One Shot Mode Timing Diagram (MODE = 'b10110 )\nRev. 10-000 204B",
    "26.8.10  Level Triggered Hardware Limit One Shot Modes\n3/6/201 9",
    "TMRx_clk\nInstruction (1)\nON\nTxPR\nTxTMR\nBSF\nBSF\n5\n0\n1 2 3 4 5\n0\n1 2 3\nTMRx_postscaled\nTMRx_ers\n1 2\n0\nPWM Duty Cycle\nD3\nPWM Output\nNote:\n3\n4 5 0\nBSF\nBCF\n1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "26.9 Timer2 Operation During Sleep\nWhen PSYNC = 1 , Timer2 cannot be operated while the processor is in Sleep mode. The contents of the T2TMR and T2PR registers will remain unchanged while the processor is in Sleep mode.\nWhen PSYNC = 0 , Timer2 will operate in Sleep as long as the clock source selected is also still running. If any internal oscillator is selected as the clock source, it will stay active during Sleep mode.",
    "26.10 Register Definitions: Timer2 Control\nLong bit name prefixes for the Timer2 peripherals are shown in the table below. Refer to the 'Long Bit Names' section of the 'Register and Bit Naming Conventions' chapter for more information.\nTable 26-2. Timer2 Long Bit Name Prefixes\n\nTimer2, Bit Name Prefix = T2. Timer4, Bit Name Prefix = T4\nImportant: References to module Timer2 apply to all the even numbered timers on this device (Timer2, Timer4, etc.).",
    "26.10.1  TxTMR\nName:\nTxTMR 0x31C,0x329\nAddress:\nTimer Counter Register",
    "26.10.1  TxTMR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TxTMR[7:0]. , 2 = TxTMR[7:0]. , 3 = TxTMR[7:0]. , 4 = TxTMR[7:0]. , 5 = TxTMR[7:0]. , 6 = TxTMR[7:0]. , 7 = TxTMR[7:0]. , 8 = TxTMR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "26.10.1  TxTMR\n0. Reset, 8 = 0\nBits 7:0 - TxTMR[7:0] Timerx Counter",
    "26.10.2  TxPR\nName: Address:\nTxPR 0x31D,0x32A\nTimer Period Register",
    "26.10.2  TxPR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TxPR[7:0]. , 2 = TxPR[7:0]. , 3 = TxPR[7:0]. , 4 = TxPR[7:0]. , 5 = TxPR[7:0]. , 6 = TxPR[7:0]. , 7 = TxPR[7:0]. , 8 = TxPR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:0 - TxPR[7:0] Timer Period Register\n0 to 255, Description = The timer restarts at ' 0 ' when TxTMR reaches the TxPR value",
    "26.10.3  TxCON\nName:\nTxCON 0x31E,0x32B\nAddress:\nTimerx Control Register",
    "26.10.3  TxCON\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ON. , 2 = CKPS[2:0]. , 3 = CKPS[2:0]. , 4 = CKPS[2:0]. , 5 = OUTPS[3:0]. , 6 = OUTPS[3:0]. , 7 = OUTPS[3:0]. , 8 = OUTPS[3:0]. Access, 1 = R/W/HC. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ON  Timer On (1)\n1, Description = Timer is on. 0, Description = Timer is off: All counters and state machines are reset",
    "Bits 6:4 - CKPS[2:0] Timer Clock Prescale Select\n111, Description = 1:128 Prescaler. 110, Description = 1:64 Prescaler. 101, Description = 1:32 Prescaler. 100, Description = 1:16 Prescaler. 011, Description = 1:8 Prescaler. 010, Description = 1:4 Prescaler. 001, Description = 1:2 Prescaler. 000, Description = 1:1 Prescaler",
    "Bits 3:0 - OUTPS[3:0] Timer Output Postscaler Select\n1111, Description = 1:16 Postscaler. 1110, Description = 1:15 Postscaler. 1101, Description = 1:14 Postscaler. 1100, Description = 1:13 Postscaler. 1011, Description = 1:12 Postscaler. 1010, Description = 1:11 Postscaler. 1001, Description = 1:10 Postscaler. 1000, Description = 1:9 Postscaler. 0111, Description = 1:8 Postscaler. 0110, Description = 1:7 Postscaler. 0101, Description = 1:6 Postscaler. 0100, Description = 1:5 Postscaler. 0011, Description = 1:4 Postscaler. 0010, Description = 1:3 Postscaler. 0001, Description = 1:2 Postscaler. 0000, Description = 1:1 Postscaler",
    "Note:\n- 1. In certain modes, the ON bit will be auto-cleared by hardware. See Table 26-1.",
    "26.10.4  TxHLT\nName:\nTxHLT 0x31F,0x32C\nAddress:",
    "Timer Hardware Limit Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSYNC. , 2 = CPOL. , 3 = CSYNC. , 4 = MODE[4:0]. , 5 = MODE[4:0]. , 6 = MODE[4:0]. , 7 = MODE[4:0]. , 8 = MODE[4:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PSYNC  Timer Prescaler Synchronization Enable (1, 2)\n1, Description = Timer Prescaler Output is synchronized to F OSC /4. 0, Description = Timer Prescaler Output is not synchronized to F OSC /4",
    "Bit 6 - CPOL  Timer Clock Polarity Selection (3)\n1, Description = Falling edge of input clock clocks timer/prescaler. 0, Description = Rising edge of input clock clocks timer/prescaler",
    "Bit 5 - CSYNC  Timer Clock Synchronization Enable (4, 5)\n1, Description = ON bit is synchronized to timer clock input. 0, Description = ON bit is not synchronized to timer clock input",
    "Bits 4:0 - MODE[4:0]  Timer Control Mode Selection (6, 7)\n00000,  = to. 00000, Description = See Table 26-1. 11111,  = . 11111, Description = ",
    "Notes:\n1. Setting this bit ensures that reading TxTMR will return a valid data value.\n2. When this bit is ' 1 ', the Timer cannot operate in Sleep mode.\n3. CKPOL must not be changed while ON = 1 .\n4. Setting this bit ensures glitch-free operation when the ON is enabled or disabled.\n5. When this bit is set, then the timer operation will be delayed by two input clocks after the ON bit is set.\n6. Unless otherwise indicated, all modes start upon ON = 1 and stop upon ON = 0 (stops occur without affecting the value of TxTMR).\n7. When TxTMR = TxPR, the next clock clears TxTMR, regardless of the operating mode.",
    "26.10.5  TxCLKCON\nName: Address:\nTxCLKCON 0x320,0x32D\nTimer Clock Source Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CS[3:0]. , 6 = CS[3:0]. , 7 = CS[3:0]. , 8 = CS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 3:0 - CS[3:0] Timer Clock Source Selection\n\nTable 26-3. Clock Source Selection",
    "26.10.5  TxCLKCON\n1111, Clock Source.Timer2 = . 1111, Timer4 = CLC4_OUT. 1110, Clock Source.Timer2 = . 1110, Timer4 = CLC3_OUT. 1101, Clock Source.Timer2 = . 1101, Timer4 = CLC2_OUT. 1100, Clock Source.Timer2 = . 1100, Timer4 = CLC1_OUT. 1011, Clock Source.Timer2 = . 1011, Timer4 = ZCD_OUT. 1010, Clock Source.Timer2 = . 1010, Timer4 = NCO1_OUT. 1001, Clock Source.Timer2 = . 1001, Timer4 = CLKREF_OUT. 1000, Clock Source.Timer2 = . 1000, Timer4 = EXTOSC. 0111, Clock Source.Timer2 = . 0111, Timer4 = SOSC. 0110, Clock Source.Timer2 = . 0110, Timer4 = MFINTOSC (32 kHz). 0101, Clock Source.Timer2 = . 0101, Timer4 = MFINTOSC (500 kHz). 0100, Clock Source.Timer2 =",
    "26.10.5  TxCLKCON\n. 0100, Timer4 = LFINTOSC. 0011, Clock Source.Timer2 = . 0011, Timer4 = HFINTOSC. 0010, Clock Source.Timer2 = . 0010, Timer4 = F OSC. 0001, Clock Source.Timer2 = . 0001, Timer4 = F OSC /4. 0000, Clock Source.Timer2 = Pin selected by T2INPPS. 0000, Timer4 = Pin selected by",
    "26.10.6  TxRST\nName: Address:\nTxRST 0x321,0x32E\nTimer External Reset Signal Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = RSEL[4:0]. , 5 = RSEL[4:0]. , 6 = RSEL[4:0]. , 7 = RSEL[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - RSEL[4:0] External Reset Source Selection\n\nTable 26-4. External Reset Sources",
    "Bits 4:0 - RSEL[4:0] External Reset Source Selection\n11111 - 11000, Reset Source.TMR2 = Reserved. 11111 - 11000, Reset Source.TMR4 = Reserved. 10111, Reset Source.TMR2 = U3TX_Edge (Positive/Negative). 10111, Reset Source.TMR4 = U3TX_Edge (Positive/Negative). 10110, Reset Source.TMR2 = U3RX_Edge (Positive/Negative). 10110, Reset Source.TMR4 = U3RX_Edge (Positive/Negative). 10101, Reset Source.TMR2 = U2TX_Edge (Positive/Negative). 10101, Reset Source.TMR4 = U2TX_Edge (Positive/Negative). 10100, Reset Source.TMR2 = U2RX_Edge (Positive/Negative). 10100, Reset Source.TMR4 = U2RX_Edge (Positive/Negative). 10011, Reset Source.TMR2 = U1TX_Edge (Positive/Negative). 10011, Reset",
    "Bits 4:0 - RSEL[4:0] External Reset Source Selection\nSource.TMR4 = U1TX_Edge (Positive/Negative). 10010, Reset Source.TMR2 = U1RX_Edge (Positive/Negative). 10010, Reset Source.TMR4 = U1RX_Edge (Positive/Negative). 10001, Reset Source.TMR2 = CLC4_OUT. 10001, Reset Source.TMR4 = CLC4_OUT. 10000, Reset Source.TMR2 = CLC3_OUT. 10000, Reset Source.TMR4 = CLC3_OUT. 01111, Reset Source.TMR2 = CLC2_OUT. 01111, Reset Source.TMR4 = CLC2_OUT. 01110, Reset Source.TMR2 = CLC1_OUT. 01110, Reset Source.TMR4 = CLC1_OUT. 01101, Reset Source.TMR2 = ZCD_OUT. 01101, Reset Source.TMR4 = ZCD_OUT.",
    "Bits 4:0 - RSEL[4:0] External Reset Source Selection\n01100, Reset Source.TMR2 = CMP2_OUT. 01100, Reset Source.TMR4 = CMP2_OUT. 01011, Reset Source.TMR2 = CMP1_OUT. 01011, Reset Source.TMR4 = CMP1_OUT. 01010, Reset Source.TMR2 = PWM3S1P2_OUT. 01010, Reset Source.TMR4 = PWM3S1P2_OUT. 01001, Reset Source.TMR2 = PWM3S1P1_OUT. 01001, Reset Source.TMR4 = PWM3S1P1_OUT. 01000, Reset Source.TMR2 = PWM2S1P2_OUT. 01000, Reset Source.TMR4 = PWM2S1P2_OUT. 00111, Reset Source.TMR2 = PWM2S1P1_OUT. 00111, Reset Source.TMR4",
    "Bits 4:0 - RSEL[4:0] External Reset Source Selection\n= PWM2S1P1_OUT. 00110, Reset Source.TMR2 = PWM1S1P2_OUT. 00110, Reset Source.TMR4 = PWM1S1P2_OUT. 00101, Reset Source.TMR2 = PWM1S1P1_OUT. 00101, Reset Source.TMR4 = PWM1S1P1_OUT. 00100, Reset Source.TMR2 = CCP1_OUT. 00100, Reset Source.TMR4 = CCP1_OUT. 00011, Reset Source.TMR2 = Reserved Reserved. 00011, Reset Source.TMR4 = Reserved Reserved. 00010, Reset Source.TMR2 = TMR4_Postscaler_OUT. 00010, Reset Source.TMR4 = . , Reset Source.TMR2 = . , Reset Source.TMR4 = Reserved. 00001, Reset Source.TMR2 = Reserved. 00001, Reset Source.TMR4",
    "Bits 4:0 - RSEL[4:0] External Reset Source Selection\n= TMR2_Postscaler_OUT. 00000, Reset Source.TMR2 = Pin selected by T2INPPS. 00000, Reset Source.TMR4 = Pin selected by T4INPPS",
    "26.11 Register Summary - Timer2\n0x00 ... 0x031B, Name = Reserved. 0x00 ... 0x031B, Bit Pos. = . 0x00 ... 0x031B, 7 = . 0x00 ... 0x031B, 6 = . 0x00 ... 0x031B, 5 = . 0x00 ... 0x031B, 4 = . 0x00 ... 0x031B, 3 = . 0x00 ... 0x031B, 2 = . 0x00 ... 0x031B, 1 = . 0x00 ... 0x031B, 0 = . 0x031C, Name = T2TMR. 0x031C, Bit Pos. = 7:0. 0x031C, 7 = T2TMR[7:0]. 0x031C, 6 = T2TMR[7:0]. 0x031C, 5 = T2TMR[7:0]. 0x031C, 4 =",
    "26.11 Register Summary - Timer2\nT2TMR[7:0]. 0x031C, 3 = T2TMR[7:0]. 0x031C, 2 = T2TMR[7:0]. 0x031C, 1 = T2TMR[7:0]. 0x031C, 0 = T2TMR[7:0]. 0x031D, Name = T2PR. 0x031D, Bit Pos. = 7:0. 0x031D, 7 = T2PR[7:0]. 0x031D, 6 = T2PR[7:0]. 0x031D, 5 = T2PR[7:0]. 0x031D, 4 = T2PR[7:0]. 0x031D, 3 = T2PR[7:0]. 0x031D, 2 = T2PR[7:0]. 0x031D, 1 = T2PR[7:0]. 0x031D, 0 = T2PR[7:0].",
    "26.11 Register Summary - Timer2\n0x031E, Name = T2CON. 0x031E, Bit Pos. = 7:0. 0x031E, 7 = ON. 0x031E, 6 = . 0x031E, 5 = CKPS[2:0]. 0x031E, 4 = . 0x031E, 3 = OUTPS[3:0]. 0x031E, 2 = OUTPS[3:0]. 0x031E, 1 = OUTPS[3:0]. 0x031E, 0 = OUTPS[3:0]. 0x031F, Name = T2HLT. 0x031F, Bit Pos. = 7:0. 0x031F, 7 = PSYNC. 0x031F, 6 = CPOL. 0x031F, 5 = CSYNC. 0x031F, 4 = . 0x031F, 3 = MODE[4:0]. 0x031F, 2 = MODE[4:0]. 0x031F, 1 =",
    "26.11 Register Summary - Timer2\nMODE[4:0]. 0x031F, 0 = MODE[4:0]. 0x0320, Name = T2CLKCON. 0x0320, Bit Pos. = 7:0. 0x0320, 7 = . 0x0320, 6 = . 0x0320, 5 = . 0x0320, 4 = . 0x0320, 3 = CS[3:0]. 0x0320, 2 = CS[3:0]. 0x0320, 1 = CS[3:0]. 0x0320, 0 = CS[3:0]. 0x0321, Name = T2RST. 0x0321, Bit Pos. = 7:0. 0x0321, 7 = . 0x0321, 6 = . 0x0321, 5 = . 0x0321, 4 = . 0x0321, 3 = RSEL[4:0]. 0x0321, 2 = RSEL[4:0]. 0x0321,",
    "26.11 Register Summary - Timer2\n1 = RSEL[4:0]. 0x0321, 0 = RSEL[4:0]. 0x0322 ... 0x0328, Name = Reserved. 0x0322 ... 0x0328, Bit Pos. = . 0x0322 ... 0x0328, 7 = . 0x0322 ... 0x0328, 6 = . 0x0322 ... 0x0328, 5 = . 0x0322 ... 0x0328, 4 = . 0x0322 ... 0x0328, 3 = . 0x0322 ... 0x0328, 2 = . 0x0322 ... 0x0328, 1 = . 0x0322 ... 0x0328, 0 = . 0x0329, Name = T4TMR. 0x0329, Bit Pos. = 7:0. 0x0329, 7 = T4TMR[7:0].",
    "26.11 Register Summary - Timer2\n0x0329, 6 = T4TMR[7:0]. 0x0329, 5 = T4TMR[7:0]. 0x0329, 4 = T4TMR[7:0]. 0x0329, 3 = T4TMR[7:0]. 0x0329, 2 = T4TMR[7:0]. 0x0329, 1 = T4TMR[7:0]. 0x0329, 0 = T4TMR[7:0]. 0x032A, Name = T4PR. 0x032A, Bit Pos. = 7:0. 0x032A, 7 = T4PR[7:0]. 0x032A, 6 = T4PR[7:0]. 0x032A, 5 = T4PR[7:0]. 0x032A, 4 = T4PR[7:0]. 0x032A, 3 = T4PR[7:0]. 0x032A, 2 =",
    "26.11 Register Summary - Timer2\nT4PR[7:0]. 0x032A, 1 = T4PR[7:0]. 0x032A, 0 = T4PR[7:0]. 0x032B, Name = T4CON. 0x032B, Bit Pos. = 7:0. 0x032B, 7 = ON. 0x032B, 6 = . 0x032B, 5 = CKPS[2:0]. 0x032B, 4 = . 0x032B, 3 = OUTPS[3:0]. 0x032B, 2 = OUTPS[3:0]. 0x032B, 1 = OUTPS[3:0]. 0x032B, 0 = OUTPS[3:0]. 0x032C, Name = T4HLT. 0x032C, Bit Pos. = 7:0. 0x032C, 7 = PSYNC. 0x032C, 6 = CPOL. 0x032C, 5 = CSYNC. 0x032C, 4",
    "26.11 Register Summary - Timer2\n= . 0x032C, 3 = MODE[4:0]. 0x032C, 2 = MODE[4:0]. 0x032C, 1 = MODE[4:0]. 0x032C, 0 = MODE[4:0]. 0x032D, Name = T4CLKCON. 0x032D, Bit Pos. = 7:0. 0x032D, 7 = . 0x032D, 6 = . 0x032D, 5 = . 0x032D, 4 = . 0x032D, 3 = CS[3:0]. 0x032D, 2 = CS[3:0]. 0x032D, 1 = CS[3:0]. 0x032D, 0 = CS[3:0]. 0x032E, Name = T4RST. 0x032E, Bit Pos. = 7:0. 0x032E, 7 = . 0x032E, 6 = . 0x032E, 5 = . 0x032E, 4",
    "26.11 Register Summary - Timer2\n= . 0x032E, 3 = RSEL[4:0]. 0x032E, 2 = RSEL[4:0]. 0x032E, 1 = RSEL[4:0]. 0x032E, 0 = RSEL[4:0]",
    "27. SMT - Signal Measurement Timer\nThe Signal Measurement Timer (SMT) is a 24-bit counter with advanced clock and gating logic, which can be configured for measuring a variety of digital signal parameters such as pulse width, frequency and duty cycle, and the time difference between edges on two signals.\nFeatures of the SMT include:\n\u00b7 24-Bit Timer/Counter\n\u00b7 Two 24-Bit Measurement Capture Registers\n\u00b7 One 24-Bit Period Match Register\n\u00b7 Multi-Mode Operation, Including Relative Timing Measurement\n\u00b7 Interrupt-on-Period Match and Acquisition Complete\n\u00b7 Multiple Clock, Signal and Window Sources\nBelow is the block diagram for the SMT module.\nFigure 27-1. Signal Measurement Timer Block Diagram",
    "27.1.1 Clock Source Selection\nThe SMT clock source is selected by configuring the CSEL bits. The clock source is prescaled by using the PS bits. The prescaled clock source is used to clock both the counter and any synchronization logic used by the module.\nThe polarity of the clock source is selected by using the CPOL bit.",
    "27.1.2 Signal and Window Source Selection\nThe SMT signal and window sources are selected by configuring the SSEL bits and the WSEL bits (refer to the figure below).\nThe polarity of the signal and window sources is selected by using the SPOL and WPOL bits, respectively.\nFigure 27-2. SMT Signal and SMT Window Source Selections",
    "27.1.3 Time Base\nThe SMTxTMR register is the 24-bit counter/timer used for measurement in each of the modes of the SMT. Setting the RST bit clears the SMTxTMR register to 0x000000. It can be written to and read by software. It is not guarded for atomic access, therefore reads and writes to the SMTxTMR register must be made only when GO = 0 .\nThe counter can be prevented from resetting at the end of the timer period by using the STP bit. When STP = 1 , the SMTxTMR will stop and remain equal to the SMTxPR register. When STP = 0 , the SMTxTMR register resets to 0x000000 at the end of the period.",
    "27.1.4 Pulse-Width and Period Captures\nThe SMTxCPW and SMTxCPR registers are used to latch in the value of the SMTxTMR register, based on the SMT mode of operation. These registers can also be updated with the current value of the SMTxTMR value by setting the CPWUP and CPRUP bits, respectively.",
    "27.1.5 Status Information\nThe SMT provides input status information for the user without requiring the need to monitor the raw incoming signals.\nGo Status: Timer run status is indicated by the TS bit. The TS bit is delayed in time by synchronizer delays in non-counter modes.\nSignal Status: Signal status is indicated by the AS bit. This bit is used in all modes, except Window Measure, Time-of-Flight, and Capture modes, and is only valid when TS = 1 . The signal status is delayed in time by synchronizer delays in non-counter modes.\nWindow Status: Window status is indicated by the WS bit. This bit is only used in Windowed Measure, Gated Counter, and Gated Window Measure modes, and is only valid when TS = 1 . Window status is delayed in time by synchronizer delays in non-counter modes.",
    "27.1.6 Modes of Operation\nThe modes of operation are summarized in the table below. The sections following the table provide descriptions and examples of how each mode can be used. Note that all waveforms assume WPOL/ SPOL/CPOL = 0 .\nFor all modes, the REPEAT bit controls whether the acquisition happens only once or is repeated. When REPEAT = 0 (Single Acquisition mode), the timer will stop incrementing and the GO bit will\nbe cleared upon the completion of an acquisition. Otherwise, the timer will continue and allow for continued acquisitions to overwrite the previous ones, until the timer is stopped by software.\n\nTable 27-1. Modes of Operation",
    "27.1.6 Modes of Operation\n1111-1011, Mode of Operation = Reserved. 1111-1011, Synchronous Operation = -. 1010, Mode of Operation = Windowed Counter. 1010, Synchronous Operation = No. 1001, Mode of Operation = Gated Counter. 1001, Synchronous Operation = No. 1000, Mode of Operation = Counter. 1000, Synchronous Operation = No. 0111, Mode of Operation = Capture. 0111, Synchronous Operation = Yes. 0110, Mode of Operation = Time of Flight Measurement. 0110, Synchronous Operation = Yes. 0101, Mode of Operation = Gated Windowed Measurement. 0101, Synchronous Operation = Yes. 0100, Mode of Operation = Windowed Measurement. 0100, Synchronous Operation = Yes. 0011, Mode of Operation = High and Low Time Measurement. 0011, Synchronous Operation = Yes. 0010, Mode of Operation = Period and Duty Cycle Measurement. 0010, Synchronous Operation = Yes. 0001, Mode of Operation = Gated Timer. 0001, Synchronous Operation = Yes.",
    "27.1.6 Modes of Operation\n0000, Mode of Operation = Timer. 0000, Synchronous Operation = Yes",
    "27.1.6.1 Timer Mode\nTimer mode is the basic mode of operation where the SMTxTMR register is used as a 24-bit timer. No data acquisition takes place in this mode. The timer increments as long as the GO bit has been set by software. No SMT window or SMT signal events affect the GO bit. Everything is synchronized to the SMT clock source. When the timer experiences a period match (SMTxTMR = SMTxPR), the SMTxTMR register is reset and the period match interrupt is set. Refer to the figure below.\nFigure 27-3. Timer Mode Timing Diagram\nRev. 10-000174A\n11/13/2018\nSMTx Clock\nSMTxEN\nSMTxGO\nSMTxTMR\nSMTxPR\nSMTxIF\nSMTxGO_sync\n0\n1 2 3 4 5 6 7 8 9 10 11 0 1 2 3 4 5 6 7 8\n9\n11",
    "27.1.6.2 Gated Timer Mode\nGated Timer mode uses the SMT_signal input, selected with the SSEL bits, to control whether or not the SMTxTMR register will increment. Upon a falling edge of the signal, the SMTxCPW register will update to the current value of the SMTxTMR register. Example waveforms for both repeated and single acquisitions are provided in the figures below.",
    "Figure 27-4. Gated Timer Mode, Repeat Acquisition Timing Diagram\nRev. 10-000176A",
    "27.1.6.3 Period and Duty Cycle Measurement Mode\nIn this mode, either the duty cycle or period of the input signal can be acquired relative to the SMT clock. The SMTxCPW register is updated on a falling edge of the signal, and the SMTxCPR register is updated on a rising edge of the signal. The rising edge also resets the SMTxTMR register to 0x000001. The GO bit is reset on a rising edge when the SMT is in Single Acquisition mode. Refer to the figures below.\nFigure 27-6. Period and Duty Cycle, Repeat Acquisition Mode Timing Diagram\nFigure 27-7. Period and Duty Cycle, Single Acquisition Mode Timing Diagram",
    "27.1.6.4 High and Low Measurement Mode\nThis mode measures the high and low pulse time of the SMT_signal, relative to the SMT clock. The SMTxTMR register starts incrementing on a rising edge of the input signal. On the falling edge, the SMTxTMR register value is written to the SMTxCPW register. The SMTxTMR register is then reset and continues to increment. On the next rising edge, the SMTxTMR register value is written to the SMTxCPR register. The SMTxTMR register is then reset and continues to increment. Refer to the figures below.\nFigure 27-8. High and Low Measurement Mode, Repeat Acquisition Timing Diagram\nFigure 27-9. High and Low Measurement Mode, Single Acquisition Timing Diagram",
    "27.1.6.5 Windowed Measurement Mode\nThis mode measures the period of the SMT_window input, selected with the WSEL bits, relative to the SMT clock. On the rising edge of the window input, the SMTxTMR register value is written to the SMTxCPR register. In Repeat mode, the SMTxTMR register is reset and continues to increment. The capture and Reset process repeats on the next rising edge. Refer to the figures below.\nFigure 27-10. Windowed Measurement Mode, Repeat Acquisition Timing Diagram\nFigure 27-11. Windowed Measurement Mode, Single Acquisition Timing Diagram",
    "27.1.6.6 Gated Window Measurement Mode\nThis mode measures the duty cycle of the SMT_signal input over a known input window. It does so by incrementing the SMTxTMR register on each rising edge of the SMTx clock signal when the SMT_signal input is high. The accumulated SMTxTMR register value is written to the SMTxCPR register, and the SMTxTMR register is reset on every rising edge of the window input after the first. Refer to the figures below.\nFigure 27-12. Gated Windowed Measurement Mode, Repeat Acquisition Timing Diagram\nFigure 27-13. Gated Windowed Measurement Mode, Single Acquisition Timing Diagram",
    "27.1.6.7 Time-of-Flight Measurement Mode\nThis mode measures the time interval between a rising edge on the SMT_window input and a rising edge on the SMT_signal input. The SMTxTMR register starts incrementing on the rising edge of the window input. The SMTxTMR register value is written to the SMTxCPR register and the SMTxTMR register is reset on a rising edge of the signal input. In the event of two rising edges of the window signal without a signal rising edge, the SMTxCPW register will be written with the current value of the SMTxTMR register, which will then be reset. Refer to the figures below.\nFigure 27-14. Time-of-Flight Mode, Repeat Acquisition Timing Diagram\nFigure 27-15. Time-of-Flight Mode, Single Acquisition Timing Diagram",
    "27.1.6.8 Capture Mode\nThis mode captures the SMTxTMR register value based on a rising or falling edge of the SMT_window input and triggers an interrupt. This mimics the capture feature of a CCP module. The timer begins incrementing upon the GO bit being set. The SMTxTMR register value is written to the SMTxCPR register on each rising edge of the SMT_window input. The SMTxTMR register value is written to the SMTxCPW register on each falling edge of the SMT_window input. The timer is not reset by any hardware conditions in this mode and must be reset by software, if desired. Refer to the figures below.\nFigure 27-16. Capture Mode, Repeat Acquisition Timing Diagram\nFigure 27-17. Capture Mode, Single Acquisition Timing Diagram\nRev. 10-000187A",
    "27.1.6.9 Counter Mode\nThis mode increments the SMTxTMR register on each rising edge of the SMT_signal input. This mode is asynchronous to the SMT clock and uses the SMT_signal input as a time source. The SMTxCPW register will be updated with the current SMTxTMR register value on the falling edge of the SMT_window input. Refer to the figure below.\nFigure 27-18. Counter Mode Timing Diagram",
    "27.1.6.10 Gated Counter Mode\nThis mode counts rising edges on the SMT_signal input, gated by the SMT_window input. It increments the SMTxTMR register for each rising edge of the SMT_signal input while the SMT_window input is high. The SMTxTMR register value is written to the SMTxCPW register upon a falling edge of the SMT_window input. Refer to the figures below.\nFigure 27-19. Gated Counter Mode, Repeat Acquisition Timing Diagram\nRev. 10-000190A\n11/15/2018\nSMTx_signal\nSMTxEN\nSMTxWIN\n0\nSMTxGO\nSMTxTMR\nSMTxCPW\n5 1 2 3 4 7 6\n11\n8\n9\n10\n12\n13\n8\n13\nSMTxPWAIF\nFigure 27-20. Gated Counter Mode, Single Acquisition Timing Diagram\nRev. 10-000191A\n11/15/2018\nSMTx_signal\nSMTxEN\nSMTxWIN\n0\nSMTxGO\nSMTxTMR\nSMTxCPW\n5 1 2 3 4 7 6\n8\n8\nSMTxPWAIF",
    "27.1.6.11 Windowed Counter Mode\nThis mode counts rising edges of the SMT_signal between rising edges of the SMT_window input. Beginning with the rising edge of the SMT_window input, the SMTxTMR register is incremented for every rising edge of the SMT_signal input. The SMTxTMR register value is written to the SMTxCPW register on the falling edge of the SMT_window input and the SMTxTMR register continues to increment. The SMTxTMR register value is written to the SMTxCPR register, then reset on each rising edge of the SMT_window input after the first. Refer to the figures below.\nFigure 27-21. Windowed Counter Mode, Repeat Acquisition Timing Diagram\nRev. 10-000192A\n11/15/2018\nSMTx_signal\nSMTxEN\nSMTxWIN\n0\nSMTxGO\nSMTxTMR\nSMTxCPW\n5 1 2 3 4 3 7 1 2 6 4 8 9 10 11 12 13 14 15 16\n5\n9\n5\nSMTxPRAIF\nSMTxPWAIF\nSMTxCPR\n16",
    "Figure 27-22. Windowed Counter Mode, Single Acquisition Timing Diagram\nRev. 10-000193A\n11/15/2018\nSMTx_signal\nSMTxEN\nSMTxWIN\n0\nSMTxGO\nSMTxTMR\nSMTxCPW\n5 1 2 3 4 7 6 8 9 10 11 12 13 14 15 16\n9\nSMTxPRAIF\nSMTxPWAIF\nSMTxCPR\n16",
    "27.1.7 Interrupts\nThe SMT has three interrupts located in one of the PIR registers:\n\u00b7 Pulse-Width Acquisition Interrupt (SMTxPWAIF): Interrupt triggers when the SMTxCPW register is updated with the SMTxTMR register value.\n\u00b7 Period Acquisition Interrupt (SMTxPRAIF): Interrupt triggers when the SMTxCPR register is updated with the SMTxTMR register value.\n\u00b7 Counter Period Match Interrupt (SMTxIF): Interrupt triggers when the SMTxTMR register equals the SMTxPR register.\nEach of the above interrupts can be enabled/disabled using the corresponding bits in the PIE register.",
    "27.1.8 Operation During Sleep\nThe SMT can operate during Sleep mode, provided that the clock and signal sources continue to function. In general, internal clock sources, such as HFINTOSC, continue to operate in Sleep mode when selected as the clock source, whereas external oscillators, such as F OSC and FOSC/4 cease to operate in Sleep.",
    "27.2 Register Definitions: SMT Control\nLong bit name prefixes for the SMT peripherals are shown in the table below. Replace the x in SMTx with the SMT peripheral instance number. Refer to the 'Long Bit Names' section in the 'Register and Nit Naming Conventions' chapter for more information.\nTable 27-2. SMT Long Bit Name Prefixes\n\nSMT1, Bit Name Prefix = SMT1",
    "27.2.1 SMTxCON0\nName:\nSMTxCON0\nAddress:\n0x030C",
    "SMT Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = EN. , 2 = . , 3 = STP. , 4 = WPOL. , 5 = SPOL. , 6 = CPOL PS[1:0]. , 7 = CPOL PS[1:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bit 7 - EN SMT Enable\n1, Description = SMT is enabled. 0, Description = SMT is disabled; internal states are reset, clock requests are disabled",
    "Bit 5 - STP SMT Counter Halt Enable\n1, Condition = When SMTxTMR = SMTxPR. 1, Description = Counter remains at SMTxPR; period match interrupt occurs when clocked. 0, Condition = When SMTxTMR = SMTxPR. 0, Description = Counter resets to 0x000000; period match interrupt occurs when clocked",
    "Bit 4 - WPOL SMT_window Input Polarity Control\n1, Description = SMT_window input is active-low/falling edge enabled. 0, Description = SMT_window input is active-high/rising edge enabled",
    "Bit 3 - SPOL SMT_signal Input Polarity Control\n1, Description = SMT_signal input is active-low/falling edge enabled. 0, Description = SMT_signal input is active-high/rising edge enabled",
    "Bit 2 - CPOL SMT Clock Input Polarity Control\n1, Description = SMTxTMR increments on the falling edge of the selected clock signal. 0, Description = SMTxTMR increments on the rising edge of the selected clock signal",
    "Bits 1:0 - PS[1:0] SMT Prescale Select\n11, Description = Prescaler = 1:8. 10, Description = Prescaler = 1:4. 01, Description = Prescaler = 1:2. 00, Description = Prescaler = 1:1",
    "27.2.2 SMTxCON1\nName:\nSMTxCON1 0x030D\nAddress:\nSMT Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GO. , 2 = REPEAT. , 3 = . , 4 = . , 5 = MODE[3:0]. , 6 = MODE[3:0]. , 7 = MODE[3:0]. , 8 = MODE[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - GO SMT GO Data Acquisition\n1, Description = Incrementing, acquiring data are enabled. 0, Description = Incrementing, acquiring data are disabled",
    "Bit 6 - REPEAT SMT Repeat Acquisition Enable\n1, Description = Repeat Data Acquisition mode is enabled. 0, Description = Single Acquisition mode is enabled",
    "Bits 3:0 - MODE[3:0] SMT Operation Mode Select\n1111, Description = Reserved. 1110, Description = Reserved. 1101, Description = Reserved. 1100, Description = Reserved. 1011, Description = Reserved. 1010, Description = Windowed Counter. 1001, Description = Gated Counter. 1000, Description = Counter. 0111, Description = Capture. 0110, Description = Time-of-Flight. 0101, Description = Gated Windowed Measurement. 0100, Description = Windowed Measurement. 0011, Description = High and Low Time Measurement. 0010, Description = Period and Duty Cycle Acquisition. 0001, Description = Gated Timer. 0000, Description = Timer",
    "27.2.3 SMTxSTAT\nName: Address:\nSMTxSTAT\n0x030E",
    "SMT Status Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CPRUP. , 2 = CPWUP. , 3 = RST. , 4 = . , 5 = . , 6 = TS. , 7 = WS. , 8 = AS. Access, 1 = R/W/HC. Access, 2 = R/W/HC. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - CPRUP SMT Manual Period Buffer Update\n1, Description = Request write of SMTxTMR value to SMTxCPR registers. 0, Description = SMTxCPR registers update is complete",
    "Bit 6 - CPWUP SMT Manual Pulse-Width Buffer Update\n1, Description = Request write of SMTxTMR value to SMTxCPW registers. 0, Description = SMTxCPW registers update is complete",
    "Bit 5 - RST SMT Manual Timer Reset\n1, Description = Request Reset to SMTxTMR registers. 0, Description = SMTxTMR registers update is complete",
    "Bit 2 - TS SMT GO Value Status\n1, Description = SMTxTMR is incrementing. 0, Description = SMTxTMR is not incrementing",
    "Bit 1 - WS SMT Window Status\n1, Description = SMT window is open. 0, Description = SMT window is closed",
    "Bit 0 - AS SMT Signal Value Status\n1, Description = SMT acquisition is in progress. 0, Description = SMT acquisition is not in progress",
    "27.2.4 SMTxCLK\nName:\nSMTxCLK\nAddress:\n0x030F\nSMT Clock Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CSEL[3:0]. , 6 = CSEL[3:0]. , 7 = CSEL[3:0]. , 8 = CSEL[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - CSEL[3:0] SMT Clock Selection\n1111-1001, Source = Reserved. 1111-1001, Active in Sleep = No. 1000, Source = CLKR. 1000, Active in Sleep = No. 0111, Source = EXTOSC. 0111, Active in Sleep = Yes. 0110, Source = SOSC. 0110, Active in Sleep = Yes. 0101, Source = MFINTOSC (32 kHz). 0101, Active in Sleep = Yes. 0100, Source = MFINTOSC (500 kHz). 0100, Active in Sleep = Yes. 0011, Source = LFINTOSC. 0011, Active in Sleep = Yes. 0010, Source = HFINTOSC. 0010, Active in Sleep = Yes. 0001, Source = F OSC. 0001, Active in Sleep = No. 0000, Source = F OSC /4. 0000, Active in Sleep = No",
    "27.2.5 SMTxWIN\nName:\nSMTxWIN\nAddress:\n0x0311\nSMT Window Input Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = WSEL[4:0]. , 5 = WSEL[4:0]. , 6 = WSEL[4:0]. , 7 = WSEL[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - WSEL[4:0] SMT Window Signal Selection\n11111 - 11000, Window Source = Reserved. 11111 - 11000, Active in Sleep = No. 10111, Window Source = CLC4_OUT. 10111, Active in Sleep = No. 10110, Window Source = CLC3_OUT. 10110, Active in Sleep = No. 10101, Window Source = CLC2_OUT. 10101, Active in Sleep = No. 10100, Window Source = CLC1_OUT. 10100, Active in Sleep = No. 10011, Window Source = ZCD_OUT. 10011, Active in Sleep = No. 10010, Window Source = CMP2_OUT. 10010, Active in Sleep = No. 10001, Window Source = CMP1_OUT. 10001, Active in Sleep = No. 10000, Window Source = NCO1_OUT. 10000, Active in Sleep = No. 01111, Window Source = PWM3S1P2_OUT. 01111, Active in Sleep = No. 01110, Window Source = PWM3S1P1_OUT.",
    "Bits 4:0 - WSEL[4:0] SMT Window Signal Selection\n01110, Active in Sleep = No. 01101, Window Source = PWM2S1P2_OUT. 01101, Active in Sleep = No. 01100, Window Source = PWM2S1P1_OUT. 01100, Active in Sleep = No. 01011, Window Source = PWM1S1P2_OUT. 01011, Active in Sleep = No. 01010, Window Source = PWM1S1P1_OUT. 01010, Active in Sleep = No. 01001, Window Source = CCP1_OUT. 01001, Active in Sleep = No. 01000, Window Source = TMR4_Postscaler_OUT. 01000, Active in Sleep = No. 00111, Window Source = TMR2_Postscaler_OUT. 00111, Active in Sleep = No. 00110, Window Source = TMR0_OUT. 00110, Active in Sleep = No. 00101, Window Source = CLKREF. 00101, Active in Sleep = No.",
    "Bits 4:0 - WSEL[4:0] SMT Window Signal Selection\n00100, Window Source = EXTOSC. 00100, Active in Sleep = Yes. 00011, Window Source = SOSC. 00011, Active in Sleep = Yes. 00010, Window Source = MFINTOSC (32 kHz). 00010, Active in Sleep = Yes. 00001, Window Source = LFINTOSC. 00001, Active in Sleep = Yes. 00000, Window Source = SMT1WINPPS. 00000, Active in Sleep = No",
    "27.2.6 SMTxSIG\nName:\nSMTxSIG\nAddress:\n0x0310\nSMT Signal Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = SSEL[4:0]. , 5 = SSEL[4:0]. , 6 = SSEL[4:0]. , 7 = SSEL[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - SSEL[4:0] SMT Signal Selection\n11111 - 10101, Source = Reserved. 10100, Source = CLC4_OUT. 10011, Source = CLC3_OUT. 10010, Source = CLC2_OUT. 10001, Source = CLC1_OUT. 10000, Source = ZCD_OUT. 01111, Source = CMP2_OUT. 01110, Source = CMP1_OUT. 01101, Source = NCO1_OUT. 01100, Source = PWM3S1P2_OUT. 01011, Source = PWM3S1P1_OUT. 01010, Source = PWM2S1P2_OUT. 01001, Source = PWM2S1P1_OUT. 01000, Source = PWM1S1P2_OUT. 00111, Source = PWM1S1P1_OUT. 00110, Source = CCP1_OUT. 00101, Source = TMR4_Postscaler_OUT. 00100, Source = TMR3_OUT.",
    "Bits 4:0 - SSEL[4:0] SMT Signal Selection\n00011, Source = TMR2_Postscaler_OUT. 00010, Source = TMR1_OUT. 00001, Source = TMR0_OUT. 00000, Source = SMT1SIGPPS",
    "27.2.7 SMTxTMR\nName:\nSMTxTMR\nAddress:\n0x0300",
    "SMT Timer Register\nAccess, 23.TMR[23:16] = R/W. Access, 22.TMR[23:16] = R/W. Access, 21.TMR[23:16] = R/W. Access, 20.TMR[23:16] = R/W. Access, 19.TMR[23:16] = R/W. Access, 18.TMR[23:16] = R/W. Access, 17.TMR[23:16] = R/W. Access, 16.TMR[23:16] = R/W. Reset, 23.TMR[23:16] = 0. Reset, 22.TMR[23:16] = 0. Reset, 21.TMR[23:16] = 0. Reset, 20.TMR[23:16] = 0. Reset, 19.TMR[23:16] = 0. Reset, 18.TMR[23:16] = 0. Reset, 17.TMR[23:16] = 0. Reset,",
    "SMT Timer Register\n16.TMR[23:16] = 0. Bit, 23.TMR[23:16] = 15. Bit, 22.TMR[23:16] = 14. Bit, 21.TMR[23:16] = 13. Bit, 20.TMR[23:16] = 12. Bit, 19.TMR[23:16] = 11. Bit, 18.TMR[23:16] = 10. Bit, 17.TMR[23:16] = 9. Bit, 16.TMR[23:16] = 8. , 23.TMR[23:16] = TMR[15:8]. , 22.TMR[23:16] = TMR[15:8]. , 21.TMR[23:16] = TMR[15:8]. , 20.TMR[23:16] = TMR[15:8]. , 19.TMR[23:16] = TMR[15:8]. , 18.TMR[23:16] =",
    "SMT Timer Register\nTMR[15:8]. , 17.TMR[23:16] = TMR[15:8]. , 16.TMR[23:16] = TMR[15:8]. Access, 23.TMR[23:16] = R/W. Access, 22.TMR[23:16] = R/W. Access, 21.TMR[23:16] = R/W. Access, 20.TMR[23:16] = R/W. Access, 19.TMR[23:16] = R/W. Access, 18.TMR[23:16] = R/W. Access, 17.TMR[23:16] = R/W. Access, 16.TMR[23:16] = R/W. Reset, 23.TMR[23:16] = 0. Reset, 22.TMR[23:16] = 0. Reset, 21.TMR[23:16] = 0. Reset, 20.TMR[23:16] = 0. Reset,",
    "SMT Timer Register\n19.TMR[23:16] = 0. Reset, 18.TMR[23:16] = 0. Reset, 17.TMR[23:16] = 0. Reset, 16.TMR[23:16] = 0. Bit, 23.TMR[23:16] = 7. Bit, 22.TMR[23:16] = 6. Bit, 21.TMR[23:16] = 5. Bit, 20.TMR[23:16] = 4. Bit, 19.TMR[23:16] = 3. Bit, 18.TMR[23:16] = 2. Bit, 17.TMR[23:16] = 1. Bit, 16.TMR[23:16] = 0. , 23.TMR[23:16] = TMR[7:0]. , 22.TMR[23:16] = TMR[7:0]. , 21.TMR[23:16] = TMR[7:0]. , 20.TMR[23:16]",
    "SMT Timer Register\n= TMR[7:0]. , 19.TMR[23:16] = TMR[7:0]. , 18.TMR[23:16] = TMR[7:0]. , 17.TMR[23:16] = TMR[7:0]. , 16.TMR[23:16] = TMR[7:0]. Access, 23.TMR[23:16] = R/W. Access, 22.TMR[23:16] = R/W. Access, 21.TMR[23:16] = R/W. Access, 20.TMR[23:16] = R/W. Access, 19.TMR[23:16] = R/W. Access, 18.TMR[23:16] = R/W. Access, 17.TMR[23:16] = R/W. Access, 16.TMR[23:16] = R/W. Reset, 23.TMR[23:16] = 0. Reset,",
    "SMT Timer Register\n22.TMR[23:16] = 0. Reset, 21.TMR[23:16] = 0. Reset, 20.TMR[23:16] = 0. Reset, 19.TMR[23:16] = 0. Reset, 18.TMR[23:16] = 0. Reset, 17.TMR[23:16] = 0. Reset, 16.TMR[23:16] = 0",
    "Bits 23:0 - TMR[23:0] SMT Timer Value\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 SMTxTMRU: Accesses the upper byte TMR[23:16]\n\u00b7 SMTxTMRH: Accesses the high byte TMR[15:8]\n\u00b7 SMTxTMRL: Accesses the low byte TMR[7:0]",
    "27.2.8 SMTxCPR\nName: Address:\nSMTxCPR 0x0303",
    "SMT Captured Period Register\nAccess, 23.CPR[23:16] = R. Access, 22.CPR[23:16] = R. Access, 21.CPR[23:16] = R. Access, 20.CPR[23:16] = R. Access, 19.CPR[23:16] = R. Access, 18.CPR[23:16] = R. Access, 17.CPR[23:16] = R. Access, 16.CPR[23:16] = R. Reset, 23.CPR[23:16] = x. Reset, 22.CPR[23:16] = x. Reset, 21.CPR[23:16] = x. Reset, 20.CPR[23:16] = x. Reset, 19.CPR[23:16] = x. Reset, 18.CPR[23:16] = x. Reset, 17.CPR[23:16] = x. Reset, 16.CPR[23:16] = x. Bit, 23.CPR[23:16] = 15. Bit, 22.CPR[23:16] =",
    "SMT Captured Period Register\n14. Bit, 21.CPR[23:16] = 13. Bit, 20.CPR[23:16] = 12. Bit, 19.CPR[23:16] = 11. Bit, 18.CPR[23:16] = 10. Bit, 17.CPR[23:16] = 9. Bit, 16.CPR[23:16] = 8. , 23.CPR[23:16] = CPR[15:8]. , 22.CPR[23:16] = CPR[15:8]. , 21.CPR[23:16] = CPR[15:8]. , 20.CPR[23:16] = CPR[15:8]. , 19.CPR[23:16] = CPR[15:8]. , 18.CPR[23:16] = CPR[15:8]. , 17.CPR[23:16] = CPR[15:8]. , 16.CPR[23:16] = CPR[15:8]. Access, 23.CPR[23:16] =",
    "SMT Captured Period Register\nR. Access, 22.CPR[23:16] = R. Access, 21.CPR[23:16] = R. Access, 20.CPR[23:16] = R. Access, 19.CPR[23:16] = R. Access, 18.CPR[23:16] = R. Access, 17.CPR[23:16] = R. Access, 16.CPR[23:16] = R. Reset, 23.CPR[23:16] = x. Reset, 22.CPR[23:16] = x. Reset, 21.CPR[23:16] = x. Reset, 20.CPR[23:16] = x. Reset, 19.CPR[23:16] = x. Reset, 18.CPR[23:16] = x. Reset, 17.CPR[23:16] = x. Reset, 16.CPR[23:16] = x. Bit, 23.CPR[23:16] = 7. Bit, 22.CPR[23:16] = 6. Bit, 21.CPR[23:16]",
    "SMT Captured Period Register\n= 5. Bit, 20.CPR[23:16] = 4. Bit, 19.CPR[23:16] = 3. Bit, 18.CPR[23:16] = 2. Bit, 17.CPR[23:16] = 1. Bit, 16.CPR[23:16] = 0. , 23.CPR[23:16] = CPR[7:0]. , 22.CPR[23:16] = CPR[7:0]. , 21.CPR[23:16] = CPR[7:0]. , 20.CPR[23:16] = CPR[7:0]. , 19.CPR[23:16] = CPR[7:0]. , 18.CPR[23:16] = CPR[7:0]. , 17.CPR[23:16] = CPR[7:0]. , 16.CPR[23:16] = CPR[7:0]. Access, 23.CPR[23:16] = R. Access, 22.CPR[23:16] =",
    "SMT Captured Period Register\nR. Access, 21.CPR[23:16] = R. Access, 20.CPR[23:16] = R. Access, 19.CPR[23:16] = R. Access, 18.CPR[23:16] = R. Access, 17.CPR[23:16] = R. Access, 16.CPR[23:16] = R. Reset, 23.CPR[23:16] = x. Reset, 22.CPR[23:16] = x. Reset, 21.CPR[23:16] = x. Reset, 20.CPR[23:16] = x. Reset, 19.CPR[23:16] = x. Reset, 18.CPR[23:16] = x. Reset, 17.CPR[23:16] = x. Reset, 16.CPR[23:16] = x",
    "Bits 23:0 - CPR[23:0] SMTxTMR Value at Time of Period Capture Event\nReset States: POR/BOR = xxxxxxxxxxxxxxxxxxxxxxxx All Other Resets = uuuuuuuuuuuuuuuuuuuuuuuu\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 SMTxCPRU: Accesses the upper byte CPR[23:16]\n\u00b7 SMTxCPRH: Accesses the high byte CPR[15:8]\n\u00b7 SMTxCPRL: Accesses the low byte CPR[7:0]",
    "27.2.9 SMTxCPW\nName:\nSMTxCPW 0x0306\nAddress:",
    "SMT Captured Pulse-Width Register\nAccess, 23.CPW[23:16] = R. Access, 22.CPW[23:16] = R. Access, 21.CPW[23:16] = R. Access, 20.CPW[23:16] = R. Access, 19.CPW[23:16] = R. Access, 18.CPW[23:16] = R. Access, 17.CPW[23:16] = R. Access, 16.CPW[23:16] = R. Reset, 23.CPW[23:16] = x. Reset, 22.CPW[23:16] = x. Reset, 21.CPW[23:16] = x. Reset, 20.CPW[23:16] = x. Reset, 19.CPW[23:16] = x. Reset, 18.CPW[23:16] = x. Reset, 17.CPW[23:16] = x. Reset, 16.CPW[23:16] = x. Bit, 23.CPW[23:16] = 15. Bit, 22.CPW[23:16]",
    "SMT Captured Pulse-Width Register\n= 14. Bit, 21.CPW[23:16] = 13. Bit, 20.CPW[23:16] = 12. Bit, 19.CPW[23:16] = 11. Bit, 18.CPW[23:16] = 10. Bit, 17.CPW[23:16] = 9. Bit, 16.CPW[23:16] = 8. , 23.CPW[23:16] = CPW[15:8]. , 22.CPW[23:16] = CPW[15:8]. , 21.CPW[23:16] = CPW[15:8]. , 20.CPW[23:16] = CPW[15:8]. , 19.CPW[23:16] = CPW[15:8]. , 18.CPW[23:16] = CPW[15:8]. , 17.CPW[23:16] = CPW[15:8]. , 16.CPW[23:16] = CPW[15:8]. Access,",
    "SMT Captured Pulse-Width Register\n23.CPW[23:16] = R. Access, 22.CPW[23:16] = R. Access, 21.CPW[23:16] = R. Access, 20.CPW[23:16] = R. Access, 19.CPW[23:16] = R. Access, 18.CPW[23:16] = R. Access, 17.CPW[23:16] = R. Access, 16.CPW[23:16] = R. Reset, 23.CPW[23:16] = x. Reset, 22.CPW[23:16] = x. Reset, 21.CPW[23:16] = x. Reset, 20.CPW[23:16] = x. Reset, 19.CPW[23:16] = x. Reset, 18.CPW[23:16] = x. Reset, 17.CPW[23:16] = x. Reset, 16.CPW[23:16] = x. Bit, 23.CPW[23:16] = 7. Bit, 22.CPW[23:16] =",
    "SMT Captured Pulse-Width Register\n6. Bit, 21.CPW[23:16] = 5. Bit, 20.CPW[23:16] = 4. Bit, 19.CPW[23:16] = 3. Bit, 18.CPW[23:16] = 2. Bit, 17.CPW[23:16] = 1. Bit, 16.CPW[23:16] = 0. , 23.CPW[23:16] = CPW[7:0]. , 22.CPW[23:16] = CPW[7:0]. , 21.CPW[23:16] = CPW[7:0]. , 20.CPW[23:16] = CPW[7:0]. , 19.CPW[23:16] = CPW[7:0]. , 18.CPW[23:16] = CPW[7:0]. , 17.CPW[23:16] = CPW[7:0]. , 16.CPW[23:16] = CPW[7:0]. Access, 23.CPW[23:16]",
    "SMT Captured Pulse-Width Register\n= R. Access, 22.CPW[23:16] = R. Access, 21.CPW[23:16] = R. Access, 20.CPW[23:16] = R. Access, 19.CPW[23:16] = R. Access, 18.CPW[23:16] = R. Access, 17.CPW[23:16] = R. Access, 16.CPW[23:16] = R. Reset, 23.CPW[23:16] = x. Reset, 22.CPW[23:16] = x. Reset, 21.CPW[23:16] = x. Reset, 20.CPW[23:16] = x. Reset, 19.CPW[23:16] = x. Reset, 18.CPW[23:16] = x. Reset, 17.CPW[23:16] = x. Reset, 16.CPW[23:16] = x",
    "Bits 23:0 - CPW[23:0] SMTxTMR Value at Time of Capture Event\nReset States: POR/BOR = xxxxxxxxxxxxxxxxxxxxxxxx\nAll Other Resets = uuuuuuuuuuuuuuuuuuuuuuuu\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 SMTxCPWU: Accesses the upper byte CPW[23:16]\n\u00b7 SMTxCPWH: Accesses the high byte CPW[15:8]\n\u00b7 SMTxCPWL: Accesses the low byte CPW[7:0]",
    "27.2.10  SMTxPR\nName: Address:\nSMTxPR\n0x0309",
    "SMT Period Register\nAccess, 23.PR[23:16] = R/W. Access, 22.PR[23:16] = R/W. Access, 21.PR[23:16] = R/W. Access, 20.PR[23:16] = R/W. Access, 19.PR[23:16] = R/W. Access, 18.PR[23:16] = R/W. Access, 17.PR[23:16] = R/W. Access, 16.PR[23:16] = R/W. Reset, 23.PR[23:16] = 1. Reset, 22.PR[23:16] = 1. Reset, 21.PR[23:16] = 1. Reset, 20.PR[23:16] = 1. Reset, 19.PR[23:16] = 1. Reset, 18.PR[23:16] = 1. Reset, 17.PR[23:16] = 1. Reset, 16.PR[23:16] = 1. Bit, 23.PR[23:16] = 15. Bit, 22.PR[23:16] = 14. Bit,",
    "SMT Period Register\n21.PR[23:16] = 13. Bit, 20.PR[23:16] = 12. Bit, 19.PR[23:16] = 11. Bit, 18.PR[23:16] = 10. Bit, 17.PR[23:16] = 9. Bit, 16.PR[23:16] = 8. , 23.PR[23:16] = PR[15:8]. , 22.PR[23:16] = PR[15:8]. , 21.PR[23:16] = PR[15:8]. , 20.PR[23:16] = PR[15:8]. , 19.PR[23:16] = PR[15:8]. , 18.PR[23:16] = PR[15:8]. , 17.PR[23:16] = PR[15:8]. , 16.PR[23:16] = PR[15:8]. Access, 23.PR[23:16] = R/W. Access, 22.PR[23:16] = R/W. Access, 21.PR[23:16]",
    "SMT Period Register\n= R/W. Access, 20.PR[23:16] = R/W. Access, 19.PR[23:16] = R/W. Access, 18.PR[23:16] = R/W. Access, 17.PR[23:16] = R/W. Access, 16.PR[23:16] = R/W. Reset, 23.PR[23:16] = 1. Reset, 22.PR[23:16] = 1. Reset, 21.PR[23:16] = 1. Reset, 20.PR[23:16] = 1. Reset, 19.PR[23:16] = 1. Reset, 18.PR[23:16] = 1. Reset, 17.PR[23:16] = 1. Reset, 16.PR[23:16] = 1. Bit, 23.PR[23:16] = 7. Bit, 22.PR[23:16] = 6. Bit, 21.PR[23:16] = 5. Bit, 20.PR[23:16] = 4. Bit, 19.PR[23:16] = 3. Bit,",
    "SMT Period Register\n18.PR[23:16] = 2. Bit, 17.PR[23:16] = 1. Bit, 16.PR[23:16] = 0. , 23.PR[23:16] = PR[7:0]. , 22.PR[23:16] = PR[7:0]. , 21.PR[23:16] = PR[7:0]. , 20.PR[23:16] = PR[7:0]. , 19.PR[23:16] = PR[7:0]. , 18.PR[23:16] = PR[7:0]. , 17.PR[23:16] = PR[7:0]. , 16.PR[23:16] = PR[7:0]. Access, 23.PR[23:16] = R/W. Access, 22.PR[23:16] = R/W. Access, 21.PR[23:16] = R/W. Access, 20.PR[23:16] = R/W. Access, 19.PR[23:16] = R/W. Access,",
    "SMT Period Register\n18.PR[23:16] = R/W. Access, 17.PR[23:16] = R/W. Access, 16.PR[23:16] = R/W. Reset, 23.PR[23:16] = 1. Reset, 22.PR[23:16] = 1. Reset, 21.PR[23:16] = 1. Reset, 20.PR[23:16] = 1. Reset, 19.PR[23:16] = 1. Reset, 18.PR[23:16] = 1. Reset, 17.PR[23:16] = 1. Reset, 16.PR[23:16] = 1\nBits 23:0 - PR[23:0] The SMTxTMR Value at Which the SMTxTMR Resets to Zero\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 SMTxPRU: Accesses the upper byte PR[23:16]\n\u00b7 SMTxPRH: Accesses the high byte PR[15:8]\n\u00b7 SMTxPRL: Accesses the low byte PR[7:0]",
    "27.3 Register Summary - SMT Control\n0x00 ... 0x02FF, Name = Reserved. 0x00 ... 0x02FF, Bit Pos. = . 0x00 ... 0x02FF, 7 = . 0x00 ... 0x02FF, 6 = . 0x00 ... 0x02FF, 5 = . 0x00 ... 0x02FF, 4 = . 0x00 ... 0x02FF, 3 = . 0x00 ... 0x02FF, 2 = . 0x00 ... 0x02FF, 1 = . 0x00 ... 0x02FF, 0 = . 0x0300, Name = SMT1TMR. 0x0300, Bit Pos. = 7:0. 0x0300, 7 = TMR[7:0]. 0x0300, 6 = TMR[7:0]. 0x0300, 5 = TMR[7:0]. 0x0300, 4 =",
    "27.3 Register Summary - SMT Control\nTMR[7:0]. 0x0300, 3 = TMR[7:0]. 0x0300, 2 = TMR[7:0]. 0x0300, 1 = TMR[7:0]. 0x0300, 0 = TMR[7:0]. 0x0300, Name = SMT1TMR. 0x0300, Bit Pos. = 15:8. 0x0300, 7 = TMR[15:8]. 0x0300, 6 = TMR[15:8]. 0x0300, 5 = TMR[15:8]. 0x0300, 4 = TMR[15:8]. 0x0300, 3 = TMR[15:8]. 0x0300, 2 = TMR[15:8]. 0x0300, 1 = TMR[15:8]. 0x0300, 0 = TMR[15:8].",
    "27.3 Register Summary - SMT Control\n0x0300, Name = SMT1TMR. 0x0300, Bit Pos. = 23:16. 0x0300, 7 = TMR[23:16]. 0x0300, 6 = TMR[23:16]. 0x0300, 5 = TMR[23:16]. 0x0300, 4 = TMR[23:16]. 0x0300, 3 = TMR[23:16]. 0x0300, 2 = TMR[23:16]. 0x0300, 1 = TMR[23:16]. 0x0300, 0 = TMR[23:16]. 0x0303, Name = SMT1CPR. 0x0303, Bit Pos. = 7:0. 0x0303, 7 = CPR[7:0]. 0x0303, 6 = CPR[7:0]. 0x0303, 5 = CPR[7:0].",
    "27.3 Register Summary - SMT Control\n0x0303, 4 = CPR[7:0]. 0x0303, 3 = CPR[7:0]. 0x0303, 2 = CPR[7:0]. 0x0303, 1 = CPR[7:0]. 0x0303, 0 = CPR[7:0]. 0x0303, Name = SMT1CPR. 0x0303, Bit Pos. = 15:8. 0x0303, 7 = CPR[15:8]. 0x0303, 6 = CPR[15:8]. 0x0303, 5 = CPR[15:8]. 0x0303, 4 = CPR[15:8]. 0x0303, 3 = CPR[15:8]. 0x0303, 2 = CPR[15:8]. 0x0303, 1 = CPR[15:8]. 0x0303, 0 = CPR[15:8]. 0x0303, Name =",
    "27.3 Register Summary - SMT Control\nSMT1CPR. 0x0303, Bit Pos. = 23:16. 0x0303, 7 = CPR[23:16]. 0x0303, 6 = CPR[23:16]. 0x0303, 5 = CPR[23:16]. 0x0303, 4 = CPR[23:16]. 0x0303, 3 = CPR[23:16]. 0x0303, 2 = CPR[23:16]. 0x0303, 1 = CPR[23:16]. 0x0303, 0 = CPR[23:16]. 0x0306, Name = SMT1CPW. 0x0306, Bit Pos. = 7:0. 0x0306, 7 = CPW[7:0]. 0x0306, 6 = CPW[7:0]. 0x0306, 5 = CPW[7:0]. 0x0306, 4 = CPW[7:0].",
    "27.3 Register Summary - SMT Control\n0x0306, 3 = CPW[7:0]. 0x0306, 2 = CPW[7:0]. 0x0306, 1 = CPW[7:0]. 0x0306, 0 = CPW[7:0]. 0x0306, Name = SMT1CPW. 0x0306, Bit Pos. = 15:8. 0x0306, 7 = CPW[15:8]. 0x0306, 6 = CPW[15:8]. 0x0306, 5 = CPW[15:8]. 0x0306, 4 = CPW[15:8]. 0x0306, 3 = CPW[15:8]. 0x0306, 2 = CPW[15:8]. 0x0306, 1 = CPW[15:8]. 0x0306, 0 = CPW[15:8]. 0x0306, Name = SMT1CPW. 0x0306, Bit Pos. =",
    "27.3 Register Summary - SMT Control\n23:16. 0x0306, 7 = CPW[23:16]. 0x0306, 6 = CPW[23:16]. 0x0306, 5 = CPW[23:16]. 0x0306, 4 = CPW[23:16]. 0x0306, 3 = CPW[23:16]. 0x0306, 2 = CPW[23:16]. 0x0306, 1 = CPW[23:16]. 0x0306, 0 = CPW[23:16]. 0x0309, Name = SMT1PR. 0x0309, Bit Pos. = 7:0. 0x0309, 7 = PR[7:0]. 0x0309, 6 = PR[7:0]. 0x0309, 5 = PR[7:0]. 0x0309, 4 = PR[7:0]. 0x0309, 3 = PR[7:0]. 0x0309, 2 =",
    "27.3 Register Summary - SMT Control\nPR[7:0]. 0x0309, 1 = PR[7:0]. 0x0309, 0 = PR[7:0]. 0x0309, Name = SMT1PR. 0x0309, Bit Pos. = 15:8. 0x0309, 7 = PR[15:8]. 0x0309, 6 = PR[15:8]. 0x0309, 5 = PR[15:8]. 0x0309, 4 = PR[15:8]. 0x0309, 3 = PR[15:8]. 0x0309, 2 = PR[15:8]. 0x0309, 1 = PR[15:8]. 0x0309, 0 = PR[15:8]. 0x0309, Name = SMT1PR. 0x0309, Bit Pos. = 23:16. 0x0309, 7 = PR[23:16]. 0x0309, 6 = PR[23:16].",
    "27.3 Register Summary - SMT Control\n0x0309, 5 = PR[23:16]. 0x0309, 4 = PR[23:16]. 0x0309, 3 = PR[23:16]. 0x0309, 2 = PR[23:16]. 0x0309, 1 = PR[23:16]. 0x0309, 0 = PR[23:16]. 0x030C, Name = SMT1CON0. 0x030C, Bit Pos. = 7:0. 0x030C, 7 = EN. 0x030C, 6 = . 0x030C, 5 = STP. 0x030C, 4 = WPOL. 0x030C, 3 = SPOL. 0x030C, 2 = CPOL. 0x030C, 1 = PS[1:0]. 0x030C, 0 = PS[1:0]. 0x030D, Name = SMT1CON1. 0x030D, Bit Pos. = 7:0. 0x030D,",
    "27.3 Register Summary - SMT Control\n7 = GO. 0x030D, 6 = REPEAT. 0x030D, 5 = . 0x030D, 4 = . 0x030D, 3 = . 0x030D, 2 = MODE[3:0]. 0x030D, 1 = MODE[3:0]. 0x030D, 0 = MODE[3:0]. 0x030E, Name = SMT1STAT. 0x030E, Bit Pos. = 7:0. 0x030E, 7 = CPRUP. 0x030E, 6 = CPWUP. 0x030E, 5 = RST. 0x030E, 4 = . 0x030E, 3 = . 0x030E, 2 = TS. 0x030E, 1 = WS. 0x030E, 0 = AS. 0x030F, Name = SMT1CLK. 0x030F, Bit Pos. = 7:0. 0x030F, 7 = . 0x030F, 6 = .",
    "27.3 Register Summary - SMT Control\n0x030F, 5 = . 0x030F, 4 = . 0x030F, 3 = . 0x030F, 2 = CSEL[3:0]. 0x030F, 1 = CSEL[3:0]. 0x030F, 0 = CSEL[3:0]. 0x0310, Name = SMT1SIG. 0x0310, Bit Pos. = 7:0. 0x0310, 7 = . 0x0310, 6 = . 0x0310, 5 = . 0x0310, 4 = . 0x0310, 3 = . 0x0310, 2 = SSEL[4:0]. 0x0310, 1 = SSEL[4:0]. 0x0310, 0 = SSEL[4:0]. 0x0311, Name = SMT1WIN. 0x0311, Bit Pos. = 7:0. 0x0311, 7 = . 0x0311, 6 = .",
    "27.3 Register Summary - SMT Control\n0x0311, 5 = . 0x0311, 4 = . 0x0311, 3 = . 0x0311, 2 = WSEL[4:0]. 0x0311, 1 = WSEL[4:0]. 0x0311, 0 = WSEL[4:0]",
    "28. CCP - Capture/Compare/PWM Module\nThe Capture/Compare/PWM module is a peripheral that allows the user to time and control different events and to generate Pulse-Width Modulation (PWM) signals. In Capture mode, the peripheral allows the timing of the duration of an event. The Compare mode allows the user to trigger an external event when a predetermined amount of time has expired. The PWM mode can generate Pulse-Width Modulated signals of varying frequency and duty cycle.\nEach individual CCP module can select the timer source that controls the module. The default timer selection is Timer1 when using Capture/Compare mode and Timer2 when using PWM mode in the CCPx module.\nNote that the Capture/Compare mode operation is described with respect to Timer1 and the PWM mode operation is described with respect to Timer2 in the following sections.\nThe Capture and Compare functions are identical for all CCP modules.",
    "28. CCP - Capture/Compare/PWM Module\nImportant: In devices with more than one CCP module, it is very important to pay close attention to the register names used. Throughout this section, the prefix 'CCPx' is used as a generic replacement for specific numbering. A number placed where the 'x' is in the prefix is used to distinguish between separate modules. For example, CCP1CON and CCP2CON control the same operational aspects of two completely different CCP modules.",
    "28.1 CCP Module Configuration\nEach Capture/Compare/PWM module is associated with a control register (CCPxCON), a capture input selection register (CCPxCAP) and a data register (CCPRx). The data register, in turn, is comprised of two 8-bit registers: CCPRxL (low byte) and CCPRxH (high byte).",
    "28.1.1 CCP Modules and Timer Resources\nThe CCP modules utilize Timers 1 through 4 that vary with the selected mode. Various timers are available to the CCP modules in Capture, Compare or PWM modes, as shown in the table below.\nTable 28-1. CCP Mode - Timer Resources\n\nCapture, Timer Resource = . Compare, Timer Resource = Timer1, Timer3. PWM, Timer Resource = . , Timer Resource = Timer2, Timer4\nThe assignment of a particular timer to a module is selected as shown in the 'Capture, Compare, and PWM Timers Selection' chapter. All of the modules may be active at once and may share the same timer resource if they are configured to operate in the same mode (Capture/Compare or PWM) at the same time.",
    "28.1.2 Open-Drain Output Option\nWhen operating in Output mode (the Compare or PWM modes), the drivers for the CCPx pins can be optionally configured as open-drain outputs. This feature allows the voltage level on the pin to be pulled to a higher level through an external pull-up resistor and allows the output to communicate with external circuits without the need for additional level shifters.",
    "28.2 Capture Mode\nCapture mode makes use of the 16-bit odd numbered timer resources (Timer1, Timer3, etc.). When an event occurs on the capture source, the 16-bit CCPRx register captures and stores the 16-bit\nvalue of the TMRx register. An event is defined as one of the following and is configured by the MODE bits:\n\u00b7 Every falling edge of CCPx input\n\u00b7 Every rising edge of CCPx input\n\u00b7 Every 4 th  rising edge of CCPx input\n\u00b7 Every 16 th  rising edge of CCPx input\n\u00b7 Every edge of CCPx input (rising or falling)\nWhen a capture is made, the Interrupt Request Flag bit CCPxIF of the PIRx register is set. The interrupt flag must be cleared in software. If another capture occurs before the value in the CCPRx register is read, the old captured value is overwritten by the new captured value. The following figure shows a simplified diagram of the capture operation.",
    "28.2 Capture Mode\nImportant: If an event occurs during a 2-byte read, the high and low-byte data will be from different events. It is recommended while reading the CCPRx register pair to either disable the module or read the register pair twice for data integrity.\nFigure 28-1. Capture Mode Operation Block Diagram",
    "28.2.1 Capture Sources\nThe capture source is selected with the CTS bits.\nIn Capture mode, the CCPx pin must be configured as an input by setting the associated TRIS control bit.\nImportant: If the CCPx pin is configured as an output, a write to the port can cause a capture event.",
    "28.2.2 Timer1 Mode for Capture\nTimer1 must be running in Timer mode or Synchronized Counter mode for the CCP module to use the capture feature. In Asynchronous Counter mode, the capture operation may not work.\nSee the 'TMR1 - Timer1 Module with Gate Control' chapter for more information on configuring Timer1.",
    "28.2.3 Software Interrupt Mode\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user will keep the CCPxIE Interrupt Enable bit of the PIEx register clear to avoid false interrupts. Additionally, the user will clear the CCPxIF Interrupt Flag bit of the PIRx register following any change in Operating mode.\nImportant: Clocking Timer1 from the system clock (FOSC) must not be used in Capture mode. For Capture mode to recognize the trigger event on the CCPx pin, Timer1 must be clocked from the instruction clock (FOSC/4) or from an external clock source.",
    "28.2.4 CCP Prescaler\nThere are four prescaler settings specified by the MODE bits. Whenever the CCP module is turned off or when the CCP module is not in Capture mode, the prescaler counter is cleared. Any Reset will clear the prescaler counter.\nSwitching from one capture prescaler to another does not clear the prescaler and may generate a false interrupt. To avoid this unexpected operation, turn the module off by clearing the CCPxCON register before changing the prescaler. The example below demonstrates the code to perform this function.\n```\nExample 28-1. Changing between Capture Prescalers BANKSEL CCP1CON        ;only needed when CCP1CON is not in ACCESS space CLRF    CCP1CON        ;Turn CCP module off MOVLW   NEW_CAPT_PS    ;CCP ON and Prescaler select \u2192 W MOVWF   CCP1CON        ;Load CCP1CON with this value\n```",
    "28.2.5 Capture During Sleep\nCapture mode depends upon the Timer1 module for proper operation. There are two options for driving the Timer1 module in Capture mode. It can be driven by the instruction clock (F OSC/4) or by an external clock source.\nWhen Timer1 is clocked by FOSC/4, Timer1 will not increment during Sleep. When the device wakes from Sleep, Timer1 will continue from its previous state.\nCapture mode will operate during Sleep when Timer1 is clocked by an external clock source.",
    "28.3 Compare Mode\nThe Compare mode function described in this section is available and identical for all CCP modules.\nCompare mode makes use of the 16-bit odd numbered Timer resources (Timer1, Timer3, etc.). The 16-bit value of the CCPRx register is constantly compared against the 16-bit value of the TMRx register. When a match occurs, one of the following events can occur:\n\u00b7 Toggle the CCPx output and clear TMRx\n\u00b7 Toggle the CCPx output without clearing TMRx\n\u00b7 Set the CCPx output\n\u00b7 Clear the CCPx output\n\u00b7 Generate a Pulse output\n\u00b7 Generate a Pulse output and clear TMRx\nThe action on the pin is based on the value of the MODE control bits.\nAll Compare modes can generate an interrupt. When MODE = 'b0001 or 'b1011 , the CCP resets the TMRx register.\nThe following figure shows a simplified diagram of the compare operation.\nFigure 28-2. Compare Mode Operation Block Diagram\n\u5050",
    "28.3.1 CCPx Pin Configuration\nThe CCPx pin must be configured as an output in software by clearing the associated TRIS bit and defining the appropriate output pin through the RxyPPS registers. See the 'PPS - Peripheral Pin Select Module' chapter for more details.\nThe CCP output can also be used as an input for other peripherals.\nImportant: Clearing the CCPxCON register will force the CCPx compare output latch to the default low level. This is not the PORT I/O data latch.",
    "28.3.2 Timer1 Mode for Compare\nIn Compare mode, Timer1 must be running in either Timer mode or Synchronized Counter mode. The compare operation may not work in Asynchronous Counter mode.\nSee the ' TMR1 - Timer1 Module with Gate Control ' chapter for more information on configuring Timer1.\nImportant: Clocking Timer1 from the system clock (FOSC) must not be used in Compare mode. For Compare mode to recognize the trigger event on the CCPx pin, Timer1 must be clocked from the instruction clock (FOSC/4) or from an external clock source.",
    "28.3.3 Compare During Sleep\nSince F OSC is shut down during Sleep mode, the Compare mode will not function properly during Sleep, unless the timer is running. The device will wake on interrupt (if enabled).",
    "28.4 PWM Overview\nPulse-Width Modulation (PWM) is a scheme that controls power to a load by switching quickly between fully ON and fully OFF states. The PWM signal resembles a square wave where the high\nportion of the signal is considered the ON state and the low portion of the signal is considered the OFF state. The high portion, also known as the pulse width, can vary in time and is defined in steps. A larger number of steps applied, which lengthens the pulse width, also supplies more power to the load. Lowering the number of steps applied, which shortens the pulse width, supplies less power. The PWM period is defined as the duration of one complete cycle or the total amount of ON and OFF time combined.\nPWM resolution defines the maximum number of steps that can be present in a single PWM period. A higher resolution allows for more precise control of the power applied to the load.",
    "28.4 PWM Overview\nThe term duty cycle describes the proportion of the ON time to the OFF time and is expressed in percentages, where 0% is fully OFF and 100% is fully ON. A lower duty cycle corresponds to less power applied and a higher duty cycle corresponds to more power applied. The figure below shows a typical waveform of the PWM signal.\nFigure 28-3. CCP PWM Output Signal",
    "28.4.1 Standard PWM Operation\nThe standard PWM function described in this section is available and identical for all CCP modules. It generates a Pulse-Width Modulation (PWM) signal on the CCPx pin with up to ten bits of resolution. The period, duty cycle and resolution are controlled by the following registers:\n\u00b7 Even numbered TxPR registers (T2PR, T4PR, etc.)\n\u00b7 Even numbered TxCON registers (T2CON, T4CON, etc.)\n\u00b7 16-bit CCPRx registers\n\u00b7 CCPxCON registers\nIt is required to have F OSC/4 as the clock input to TxTMR for correct PWM operation. The following figure shows a simplified block diagram of the PWM operation.",
    "Figure 28-4. Simplified PWM Block Diagram\nNotes : 1. An 8-bit timer is concatenated with two bits generated by Fosc or two bits of the internal prescaler to create 10-bit time base.\n2. The alignment of the 10 bits from the CCPR register is determined by the CCPxFMT bit.\nImportant: The corresponding TRIS bit must be cleared to enable the PWM output on the CCPx pin.",
    "28.4.2 Setup for PWM Operation\nThe following steps illustrate how to configure the CCP module for standard PWM operation:",
    "28.4.2 Setup for PWM Operation\n1. Select the desired output pin with the RxyPPS control to select CCPx as the source. Disable the selected pin output driver by setting the associated TRIS bit. The output will be enabled later at the end of the PWM setup.\n2. Load the selected timer TxPR period register with the PWM period value.\n3. Configure the CCP module for the PWM mode by loading the CCPxCON register with the appropriate values.\n4. Load the CCPRx register with the PWM duty cycle value and configure the FMT bit to set the proper register alignment.\n5. Configure and start the selected timer:\n-Clear the TMRxIF Interrupt Flag bit of the PIRx register. See the Important Note below.\n-Select the timer clock source to be as F OSC/4. This is required for correct operation of the PWM module.\n-Configure the TxCKPS bits of the TxCON register with the desired timer prescale value.\n-Enable the timer by setting the TxON bit.\n6. Enable the PWM output:",
    "28.4.2 Setup for PWM Operation\n-Wait until the timer overflows and the TMRxIF bit of the PIRx register is set. See the Important Note below.\n-Enable the CCPx pin output driver by clearing the associated TRIS bit.\nImportant: To send a complete duty cycle and period on the first PWM output, the above steps must be included in the setup sequence. If it is not critical to start with a complete PWM signal on the first output, then step 6 may be ignored.",
    "28.4.3 Timer2 Timer Resource\nThe PWM Standard mode makes use of the 8-bit Timer2 timer resources to specify the PWM period.",
    "28.4.4 PWM Period\nThe PWM period is specified by the T2PR register of Timer2. The PWM period can be calculated using the formula in the equation below.\nEquation 28-1. PWM Period PWMPeriod = T2PR + 1 \u00b7 4 \u00b7 T OSC \u00b7 TMR2Prescale Value where TOSC = 1/FOSC\nWhen T2TMR is equal to T2PR, the following three events occur on the next increment event:\n\u00b7 T2TMR is cleared\n\u00b7 The CCPx pin is set (Exception: If the PWM duty cycle = 0%, the pin will not be set)\n\u00b7 The PWM duty cycle is transferred from the CCPRx register into a 10-bit buffer\nImportant: The Timer postscaler (see the ' Timer2 Interrupt ' section in the 'TMR2 - Timer2 Module' chapter) is not used in the determination of the PWM frequency.",
    "28.4.5 PWM Duty Cycle\nThe PWM duty cycle is specified by writing a 10-bit value to the CCPRx register. The alignment of the 10-bit value is determined by the FMT bit (see Figure 28-5). The CCPRx register can be written to at any time. However, the duty cycle value is not latched onto the 10-bit buffer until after a match between T2PR and T2TMR.\nThe equations below are used to calculate the PWM pulse width and the PWM duty cycle ratio.",
    "Figure 28-5. PWM 10-Bit Alignment\nEquation 28-2. Pulse Width Pulse Widt\u210e = CCPRxH:CCPRxL register value \u00b7 T OSC \u00b7 TMR2Prescale Value\nThe CCPRx register is used to double buffer the PWM duty cycle. This double buffering is essential for glitchless PWM operation.\n<!-- formula-not-decoded -->\nThe 8-bit timer T2TMR register is concatenated with either the 2-bit internal system clock (F OSC), or two bits of the prescaler, to create the 10-bit time base. The system clock is used if the Timer2 prescaler is set to 1:1.\nWhen the 10-bit time base matches the CCPRx register, then the CCPx pin is cleared (see Figure 28-4).",
    "28.4.6 PWM Resolution\nThe resolution determines the number of available duty cycles for a given period. For example, a 10-bit resolution will result in 1024 discrete duty cycles, whereas an 8-bit resolution will result in 256 discrete duty cycles.\nThe maximum PWM resolution is 10 bits when T2PR is 0xFF . The resolution is a function of the T2PR register value, as shown below.\n<!-- formula-not-decoded -->\nImportant: If the pulse-width value is greater than the period, the assigned PWM pin(s) will remain unchanged.\nTable 28-2. Example PWM Frequencies and Resolutions (FOSC = 20 MHz)",
    "28.4.6 PWM Resolution\nTimer Prescale, 1.22 kHz = 16. Timer Prescale, 4.88 kHz = 4. Timer Prescale, 19.53 kHz = 1. Timer Prescale, 78.12 kHz = 1. Timer Prescale, 156.3 kHz = 1. Timer Prescale, 208.3 kHz = 1. T2PR Value, 1.22 kHz = 0xFF. T2PR Value, 4.88 kHz = 0xFF. T2PR Value, 19.53 kHz = 0xFF. T2PR Value, 78.12 kHz = 0x3F. T2PR Value, 156.3 kHz = 0x1F. T2PR Value, 208.3 kHz = 0x17. Maximum Resolution (bits), 1.22 kHz = 10. Maximum Resolution (bits), 4.88 kHz = 10. Maximum Resolution (bits), 19.53 kHz = 10. Maximum Resolution (bits), 78.12 kHz = 8. Maximum Resolution (bits), 156.3 kHz = 7. Maximum Resolution (bits), 208.3 kHz = 6.6\n",
    "28.4.6 PWM Resolution\nTable 28-3. Example PWM Frequencies and Resolutions (FOSC = 8 MHz)",
    "28.4.6 PWM Resolution\nTimer Prescale, 1.22 kHz = 16. Timer Prescale, 4.90 kHz = 4. Timer Prescale, 19.61 kHz = 1. Timer Prescale, 76.92 kHz = 1. Timer Prescale, 153.85 kHz = 1. Timer Prescale, 200.0 kHz = 1. T2PR Value, 1.22 kHz = 0x65. T2PR Value, 4.90 kHz = 0x65. T2PR Value, 19.61 kHz = 0x65. T2PR Value, 76.92 kHz = 0x19. T2PR Value, 153.85 kHz = 0x0C. T2PR Value, 200.0 kHz = 0x09. Maximum Resolution (bits), 1.22 kHz = 8. Maximum Resolution (bits), 4.90 kHz = 8. Maximum Resolution (bits), 19.61 kHz = 8. Maximum Resolution (bits), 76.92 kHz = 6. Maximum Resolution (bits), 153.85 kHz = 5. Maximum Resolution (bits), 200.0 kHz = 5",
    "28.4.7 Operation in Sleep Mode\nIn Sleep mode, the T2TMR register will not increment and the state of the module will not change. If the CCPx pin is driving a value, it will continue to drive that value. When the device wakes up, T2TMR will continue from the previous state.",
    "28.4.8 Changes in System Clock Frequency\nThe PWM frequency is derived from the system clock frequency. Any changes in the system clock frequency will result in changes to the PWM frequency. See the 'OSC - Oscillator Module (With Fail-Safe Clock Monitor)' chapter for additional details.",
    "28.4.9 Effects of Reset\nAny Reset will force all ports to Input mode and the CCP registers to their Reset states.",
    "28.5 Register Definitions: CCP Control\nLong bit name prefixes for the CCP peripherals are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 28-4. CCP Long Bit Name Prefixes\n\nCCP1, Bit Name Prefix = CCP1",
    "28.5.1 CCPxCON\nName: Address:\nCCPxCON\n0x0342",
    "CCP Control Register\nAccess, 7.EN = R/W. Access, 6. = . Access, 5.OUT = R. Access, 4.FMT = R/W. Access, 3.MODE[3:0] = R/W. Access, 2.MODE[3:0] = R/W. Access, 1.MODE[3:0] = R/W. Access, 0. = R/W. Reset, 7.EN = 0. Reset, 6. = . Reset, 5.OUT = x. Reset, 4.FMT = 0. Reset, 3.MODE[3:0] = 0. Reset, 2.MODE[3:0] = 0. Reset, 1.MODE[3:0] = 0. Reset, 0. = 0",
    "Bit 7 - EN CCP Module Enable\n1, Description = CCP is enabled. 0, Description = CCP is disabled",
    "Bit 4 - FMT CCPxRH:L Value Alignment (PWM mode)\nx, Condition = Capture mode. x, Description = Not used. x, Condition = Compare mode. x, Description = Not used. 1, Condition = PWMmode. 1, Description = Left aligned format. 0, Condition = PWMmode. 0, Description = Right aligned format",
    "Table 28-5. CCPx Mode Select\n11xx, Operating Mode = PWM. 11xx, Operation = PWMoperation. 11xx, Set CCPxIF = Yes. 1011, Operating Mode = Compare. 1011, Operation = Pulse output; clear TMR1 (2). 1011, Set CCPxIF = Yes. 1010, Operating Mode = Compare. 1010, Operation = Pulse output. 1010, Set CCPxIF = Yes. 1001, Operating Mode = Compare. 1001, Operation = Clear output (1). 1001, Set CCPxIF = Yes. 1000, Operating Mode = Compare. 1000, Operation = Set output (1). 1000, Set CCPxIF = Yes. 0111, Operating Mode = . 0111, Operation = Every 16 th rising edge of CCPx input. 0111, Set CCPxIF = Yes. 0110, Operating Mode = . 0110, Operation = Every 4 th rising edge of CCPx input. 0110, Set CCPxIF = Yes. 0101, Operating Mode = Capture. 0101, Operation = Every rising edge of CCPx input. 0101, Set",
    "Table 28-5. CCPx Mode Select\nCCPxIF = Yes. 0100, Operating Mode = . 0100, Operation = Every falling edge of CCPx input. 0100, Set CCPxIF = Yes. 0011, Operating Mode = . 0011, Operation = Every edge of CCPx input. 0011, Set CCPxIF = Yes. 0010, Operating Mode = Compare. 0010, Operation = Toggle output. 0010, Set CCPxIF = Yes. 0001, Operating Mode = . 0001, Operation = Toggle output; clear TMR1 (2). 0001, Set CCPxIF = Yes. 0000, Operating Mode = Disabled. 0000, Operation = . 0000, Set CCPxIF = -",
    "Notes:\n1. The set and clear operations of the Compare mode are reset by setting MODE = 'b0000 or EN = 0 .\n2. When MODE = 'b0001 or 'b1011 , then the timer associated with the CCP module is cleared. TMR1 is the default selection for the CCP module, so it is used for indication purposes only.",
    "28.5.2 CCPxCAP\nName:\nCCPxCAP\nAddress:\n0x0343\nCapture Trigger Input Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = CTS[2:0]. , 7 = CTS[2:0]. , 8 = CTS[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 2:0 - CTS[2:0] Capture Trigger Input Selection\nTable 28-6. Capture Trigger Sources\n\n111, Source = CLC4_OUT. 110, Source = CLC3_OUT. 101, Source = CLC2_OUT. 100, Source = CLC1_OUT. 011, Source = IOC Interrupt. 010, Source = CMP2_OUT. 001, Source = CMP1_OUT. 000, Source = Pin selected by CCPxPPS",
    "28.5.3 CCPRx\nName:\nCCPRx\nAddress:\n0x0340",
    "Capture/Compare/Pulse-Width Register\nAccess, 15.CCPR[15:8] = R/W. Access, 14.CCPR[15:8] = R/W. Access, 13.CCPR[15:8] = R/W. Access, 12.CCPR[15:8] = R/W. Access, 11.CCPR[15:8] = R/W. Access, 10.CCPR[15:8] = R/W. Access, 9.CCPR[15:8] = R/W. Access, 8.CCPR[15:8] = R/W. Reset, 15.CCPR[15:8] = x. Reset, 14.CCPR[15:8] = x. Reset, 13.CCPR[15:8] = x. Reset, 12.CCPR[15:8] = x. Reset, 11.CCPR[15:8] = x. Reset, 10.CCPR[15:8] = x. Reset, 9.CCPR[15:8] = x. Reset, 8.CCPR[15:8] = x. Bit,",
    "Capture/Compare/Pulse-Width Register\n15.CCPR[15:8] = 7. Bit, 14.CCPR[15:8] = 6. Bit, 13.CCPR[15:8] = 5. Bit, 12.CCPR[15:8] = 4. Bit, 11.CCPR[15:8] = 3. Bit, 10.CCPR[15:8] = 2. Bit, 9.CCPR[15:8] = 1. Bit, 8.CCPR[15:8] = 0. , 15.CCPR[15:8] = CCPR[7:0]. , 14.CCPR[15:8] = CCPR[7:0]. , 13.CCPR[15:8] = CCPR[7:0]. , 12.CCPR[15:8] = CCPR[7:0]. , 11.CCPR[15:8] = CCPR[7:0]. , 10.CCPR[15:8] = CCPR[7:0]. , 9.CCPR[15:8] = CCPR[7:0]. ,",
    "Capture/Compare/Pulse-Width Register\n8.CCPR[15:8] = CCPR[7:0]. Access, 15.CCPR[15:8] = R/W. Access, 14.CCPR[15:8] = R/W. Access, 13.CCPR[15:8] = R/W. Access, 12.CCPR[15:8] = R/W. Access, 11.CCPR[15:8] = R/W. Access, 10.CCPR[15:8] = R/W. Access, 9.CCPR[15:8] = R/W. Access, 8.CCPR[15:8] = R/W. Reset, 15.CCPR[15:8] = x. Reset, 14.CCPR[15:8] = x. Reset, 13.CCPR[15:8] = x. Reset, 12.CCPR[15:8] = x. Reset, 11.CCPR[15:8] = x. Reset, 10.CCPR[15:8] = x. Reset, 9.CCPR[15:8] = x. Reset,",
    "Capture/Compare/Pulse-Width Register\n8.CCPR[15:8] = x",
    "Bits 15:0 - CCPR[15:0] Capture/Compare/Pulse-Width\nReset States: POR/BOR = xxxxxxxxxxxxxxxx All other Resets = uuuuuuuuuuuuuuuu",
    "Notes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 When MODE = Capture or Compare\n-CCPRxH: Accesses the high byte CCPR[15:8]\n-CCPRxL: Accesses the low byte CCPR[7:0]\n\u00b7 When MODE = PWM and FMT = 0\n-CCPRx[15:10]: Not used\n-CCPRxH[1:0]: Accesses the two Most Significant bits CCPR[9:8]\n-CCPRxL: Accesses the eight Least Significant bits CCPR[7:0]\n\u00b7 When MODE = PWM and FMT = 1\n-CCPRxH: Accesses the eight Most Significant bits CCPR[9:2]\n-CCPRxL[7:6]: Accesses the two Least Significant bits CCPR[1:0]\n-CCPRx[5:0]: Not used",
    "28.6 Register Summary - CCP Control\n0x00 ... 0x033F, Name = Reserved. 0x00 ... 0x033F, Bit Pos. = . 0x00 ... 0x033F, 7 = . 0x00 ... 0x033F, 6 = . 0x00 ... 0x033F, 5 = . 0x00 ... 0x033F, 4 = . 0x00 ... 0x033F, 3 = . 0x00 ... 0x033F, 2 = . 0x00 ... 0x033F, 1 = . 0x00 ... 0x033F, 0 = . 0x0340, Name = CCPR1. 0x0340, Bit Pos. = 7:0. 0x0340, 7 = CCPR[7:0]. 0x0340, 6 = CCPR[7:0]. 0x0340, 5 = CCPR[7:0]. 0x0340, 4 = CCPR[7:0].",
    "28.6 Register Summary - CCP Control\n0x0340, 3 = CCPR[7:0]. 0x0340, 2 = CCPR[7:0]. 0x0340, 1 = CCPR[7:0]. 0x0340, 0 = CCPR[7:0]. 0x0340, Name = CCPR1. 0x0340, Bit Pos. = 15:8. 0x0340, 7 = CCPR[15:8]. 0x0340, 6 = CCPR[15:8]. 0x0340, 5 = CCPR[15:8]. 0x0340, 4 = CCPR[15:8]. 0x0340, 3 = CCPR[15:8]. 0x0340, 2 = CCPR[15:8]. 0x0340, 1 = CCPR[15:8]. 0x0340, 0 = CCPR[15:8]. 0x0342, Name = CCP1CON. 0x0342, Bit Pos. = 7:0.",
    "28.6 Register Summary - CCP Control\n0x0342, 7 = EN. 0x0342, 6 = . 0x0342, 5 = OUT. 0x0342, 4 = FMT. 0x0342, 3 = MODE[3:0]. 0x0342, 2 = MODE[3:0]. 0x0342, 1 = MODE[3:0]. 0x0342, 0 = MODE[3:0]. 0x0343, Name = CCP1CAP. 0x0343, Bit Pos. = 7:0. 0x0343, 7 = . 0x0343, 6 = . 0x0343, 5 = . 0x0343, 4 = . 0x0343, 3 = . 0x0343, 2 = CTS[2:0]. 0x0343, 1 = CTS[2:0]. 0x0343, 0 = CTS[2:0]",
    "29. Capture, Compare, and PWM Timers Selection\nEach of these modules has an independent timer selection which can be accessed using the timer selection register. The default timer selection is Timer1 for capture or compare functions and Timer2 for PWM functions.",
    "29.1.1 CCPTMRS0\nName:\nCCPTMRS0\nAddress:\n0x34C\nCCP Timers Selection Register\nBit, 1 = 5 4. Bit, 2 = 3. Bit, 3 = 2. Bit, 4 = 1. Bit, 5 = 0. , 1 = C3TSEL[1:0]. , 2 = C3TSEL[1:0]. , 3 = C2TSEL[1:0]. , 4 = C2TSEL[1:0]. , 5 = C1TSEL[1:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W R/W. Access, 4 = R/W. Access, 5 = R/W. Reset, 1 = 0. Reset, 2 = 1. Reset, 3 = 0 1. Reset, 4 = 0. Reset, 5 = 1",
    "Bits 0:1, 2:3, 4:5 - CnTSEL CCPn Timer Selection\n11, Capture/Compare = Reserved. 11, PWM = Reserved. 10, Capture/Compare = Timer3. 10, PWM = Timer4. 01, Capture/Compare = Timer1. 01, PWM = Timer2. 00, Capture/Compare = Reserved. 00, PWM = ",
    "29.2 Register Summary - Capture, Compare, and PWM Timers Selection\n0x00 ... 0x034B, Name = Reserved. 0x00 ... 0x034B, Bit Pos. = . 0x00 ... 0x034B, 7 = . 0x00 ... 0x034B, 6 = . 0x00 ... 0x034B, 5 = . 0x00 ... 0x034B, 4 = . 0x00 ... 0x034B, 3 = . 0x00 ... 0x034B, 2 = . 0x00 ... 0x034B, 1 = . 0x00 ... 0x034B, 0 = . 0x034C, Name = CCPTMRS0. 0x034C, Bit Pos. = 7:0. 0x034C, 7 = . 0x034C, 6 = . 0x034C, 5 = C3TSEL[1:0]. 0x034C, 4 = . 0x034C, 3 =",
    "29.2 Register Summary - Capture, Compare, and PWM Timers Selection\nC2TSEL[1:0]. 0x034C, 2 = . 0x034C, 1 = C1TSEL[1:0]. 0x034C, 0 = ",
    "30. PWM - Pulse-Width Modulator with Compare\nThis module is a 16-bit Pulse-Width Modulator (PWM) with a compare feature and multiple outputs. The outputs are grouped in slices where each slice has two outputs. There can be up to four slices in each PWM module. The EN bit enables the PWM operation for all slices simultaneously. The prescale counter, postscale counter, and all internal logic is held in Reset while the EN bit is low.\nFeatures of this module include the following:\n\u00b7 Five main operating modes:\n-Left Aligned\n-Right Aligned\n-Center-Aligned\n-Variable Aligned\n-Compare\n\u00b7 Pulsed\n\u00b7 Toggled\n\u00b7 Push-pull operation (available in Left and Right Aligned modes only)\n\u00b7 Independent 16-bit period timer\n\u00b7 Programmable clock sources\n\u00b7 Programmable trigger sources for synchronous duty cycle and period changes\n\u00b7 Programmable synchronous/asynchronous Reset sources\n\u00b7 Programmable Reset source polarity control\n\u00b7 Programmable PWM output polarity control\n\u00b7 Up to four two-output slices per module\nBlock diagrams of each PWM mode are shown in their respective sections.",
    "30.1 Output Slices\nA PWM module can have up to four output slices. An output slice consists of two PWM outputs, PWMx_SaP1_out and PWMx_SaP2_out. Both share the same operating mode. However, other slices may operate in a different mode. PWMx_SaP1_out and PWMx_SaP2_out have independent duty cycles which are set with the respective P1 and P2 parameter registers.",
    "30.1.1 Output Polarity\nThe polarity for the PWMx_SaP1_out and PWMx_SaP2_out is controlled with the respective POL1 and POL2 bits. Setting the polarity bit inverts the output Active state to Low True. Toggling the polarity bit toggles the output whether or not the PWM module is enabled.",
    "30.1.2 Operating Modes\nEach output slice can operate in one of six modes selected with the MODE bits. The Left and Right Aligned modes can also be operated in Push-Pull mode by setting the PPEN bit. The following sections provide more details on each mode, including block diagrams.",
    "30.1.2.1 Left Aligned Mode\nIn Left Aligned mode, the active part of the duty cycle is at the beginning of the period. The outputs start active and stay active for the number of prescaled PWM clock periods specified by the P1 and P2 parameter registers, then go inactive for the remainder of the period. Block and timing diagrams follow.\nFigure 30-1. Left-Aligned Block Diagram",
    "Figure 30-2. Left-Aligned Timing Diagram\nNote: MODE = ' b000 , PR = 5, P1 = 4, P2 = 2 .",
    "30.1.2.2 Right Aligned Mode\nIn Right Aligned mode, the active part of the duty cycle is at the end of the period. The outputs start in the Inactive state and then go Active the number of prescaled PWM clock periods specified by the P1 and P2 parameter registers before the end of the period. Block and timing diagrams follow.\nFigure 30-3. Right-Aligned Block Diagram\nFigure 30-4. Right-Aligned Timing Diagram\nNote: MODE = ' b001 , PR = 5, P1 = 4, P2 = 2 .",
    "30.1.2.3 Center-Aligned Mode\nIn Center-Aligned mode, the active duty cycle is centered in the period. The period for this mode is twice that of other modes, as shown in the following equation.",
    "Equation 30-1. Center-Aligned Period\nThe parameter register specifies the number of PWM clock periods that the output goes Active before the period center. The output goes inactive the same number of prescaled PWM clock periods after the period center. Block and timing diagrams follow.\n<!-- formula-not-decoded -->\nFigure 30-5. Center-Aligned Block Diagram\nFigure 30-6. Center-Aligned Timing Diagram\nNote: MODE = ' b010 , PR = 5, P1 = 4 , P2 = 2.",
    "30.1.2.4 Variable Alignment Mode\nIn Variable Alignment mode, the active part of the duty cycle starts when the parameter 1 value (P1) matches the timer and ends when the parameter 2 value (P2) matches the timer. Both outputs are identical because both parameter values are used for the same duty cycle. Block and timing diagrams follow.\nFigure 30-7. Variable Alignment Block Diagram\nFigure 30-8. Variable Alignment Timing Diagram\nNote: MODE = ' b011 , PR = 5, P1 = 4, P2 = 2 .",
    "30.1.2.5 Compare Modes\nIn the Compare modes, the PWM timer is compared to the P1 and P2 parameter values. When a match occurs, the output is either pulsed or toggled. In Pulsed Compare mode, the duty cycle is always one prescaled PWM clock period. In Toggle Compare mode, the duty cycle is always one full PWM period. Refer to the following sections for more details.",
    "30.1.2.5.1 Pulsed Compare Mode\nIn Pulsed Compare mode, the duty cycle is one prescaled PWM clock period that starts when the timer matches the parameter value and ends one prescaled PWM clock period later. The outputs start in the Inactive state and then go Active during the duty cycle. Block and timing diagrams follow.\nFigure 30-9. Pulsed Compare Block Diagram\nFigure 30-10. Pulsed Compare Timing Diagram\nNote: MODE = ' b100 , PR = 5, P1 = 4, P2 = 2 .",
    "30.1.2.5.2 Toggled Compare\nIn Toggled Compare mode, the duty cycle is alternating full PWM periods. The output goes Active when the PWM timer matches the P1 or P2 parameter value and goes Inactive in the next period at the same match point. Block and timing diagrams follow.\nFigure 30-11. Toggled Compare Block Diagram\nFigure 30-12. Toggled Compare Timing Diagram\nNote: MODE = ' b101 , PR = 5, P1 = 4, P2 = 2 .",
    "30.1.3 Push-Pull Mode\nThe Push-Pull mode is enabled by setting the PPEN bit. Push-Pull operates only in the Left Aligned and Right Aligned modes. In the Push-Pull mode, the outputs are Active every other PWM period. PWMx_SaP1_out is Active when the PWMx_SaP2_out is not and the PWMx_SaP2_out is Active when the PWMx_SaP1_out is not. When the parameter value (P1 or P2) is greater than the period value (PR), then the corresponding output is Active for one full PWM period. The following figures illustrate timing examples of Left and Right Aligned Push-Pull modes.\nFigure 30-13. Left Aligned Push-Pull Mode Timing Diagram\nNote: MODE = ' b000 , PR = 5, P1 = 4, P2 = 2, PPEN = 1 .\nFigure 30-14. Right Aligned Push-Pull Mode Timing Diagram\nNote: MODE = ' b001 , PR = 5, P1 = 6, P2 = 2, PPEN = 1 .",
    "30.2 Period Timer\nAll slices in a PWM instance operate with the same period. The value written to the PWMxPR register is one less than the number of prescaled PWM clock periods (PWM_clk) in the PWM period.\nThe PWMxPR register is double-buffered. When the PWM is operating, writes to the PWMxPR register are transferred to the period buffer only after the LD bit is set or an external load event occurs. The transfer occurs at the next period Reset event. If the LD bit is set less than three PWM clock periods before the end of the period, then the transfer may be one full period later.\nLoading the buffers of multiple PWM instances can be coordinated using the PWMLOAD register. See the Buffered Period and Parameter Registers section for more details.",
    "30.3 Clock Sources\nThe time base for the PWM period prescaler is selected with the CLK bits. Changes take effect immediately when written. Clearing the EN bit before making clock source changes is recommended to avoid unexpected behavior.",
    "30.3.1 Clock Prescaler\nThe PWM clock frequency can be reduced with the clock prescaler. There are 256 prescale selections from 1:1 to 1:256.\nThe CPRE bits select the prescale value. Changes to the prescale value take effect immediately. Clearing the EN bit before making prescaler changes is recommended to avoid unexpected behavior. The prescale counter is reset when the EN bit is cleared.",
    "30.4 External Period Resets\nThe period timer can be reset and held at zero by a logic level from one of various sources. The Reset event also resets the postscaler counter. The resetting source is selected with the ERS bits.\nThe Reset can be configured with the ERSNOW bit to occur on either the next PWM clock or the next PWM period Reset event. When the ERSNOW bit is set, then the Reset will occur on the next PWM clock. When the ERSNOW bit is cleared, then the Reset will be held off until the timer resets at the end of the period. The difference between a normal period Reset and an ERS Reset is that once the timer is reset, it is held at zero until the ERS signal goes false. The following timing diagrams illustrate the two types of external Reset.\nFigure 30-15. Right Aligned Mode with ERSNOW = 1\nPWMx_clk\nPWMx_timer\nSaP1_out\nSaP2_out\n0\n1\n2\n3\n4\n5\n0\nPWMx_ers\n1\n2\n3\n0\n0\n0\n1\nNote: PR = 5, P1 = 4, P2 = 2 .",
    "Figure 30-16. Left Aligned Mode with ERSNOW = 0\nPWMx_clk\nPWMx_timer\nSaP1_out\nSaP2_out\n0\n1\n2\n3\n4\n5\n0\nPWMx_ers\n0\n0\n1\n2\n3\n4\n5\nNote: PR = 5, P1 = 4, P2 = 2 .",
    "30.5 Buffered Period and Parameter Registers\nThe PWMxPR, PWMxSaP1 and PWMxSaP2 registers are double-buffered. The PWM module operates on the buffered copies. The values in all these registers are copied to the buffer registers when the PWM module is enabled.\nChanges to the PWMxPR, PWMxSaP1 and PWMxSaP2 registers do not affect the buffer registers while the PWM is operating until either software sets the LD bit or an external load event occurs. For all operating modes except Center-Aligned, the values are copied to the buffer registers when the PWM timer is reloaded at the end of the period in which the load request occurred. In the Center-Aligned mode, the buffer update occurs on every other period Reset event because one full center-aligned period uses two period cycles. Load requests occurring three or less clocks before the end of the period may not be serviced until the following period.\nA list of external load trigger sources is shown in the PWMxLDS register. Software can set the LD bits of multiple PWM instances simultaneously with the PWMLOAD register.",
    "30.5 Buffered Period and Parameter Registers\nImportant: No changes are allowed after the LD bit is set until after the LD bit is cleared by hardware. Unexpected behavior may result if the LD bit is cleared by software.",
    "30.6 Synchronizing Multiple PWMs\nTo synchronize multiple PWMs, the PWMEN register is used to enable selected PWMs simultaneously. The bits in the PWMEN register are mirror copies of the EN bit of every PWM in the device. Setting or clearing the EN bits in the PWMEN register enables or disables all the corresponding PWMs simultaneously.",
    "30.7 Interrupts\nEach PWM instance has a period interrupt and interrupts associated with the mode and parameter settings.",
    "30.7.1 Period Interrupt\nThe period interrupt occurs when the PWMx timer value matches the PR value, thereby also resetting the PWMx timer. Refer to Figure 30-2 for a timing example. The period interrupt is indicated with the PWMxPIF flag bit in one of the PIR registers and is set whether or not the interrupt is enabled. This flag must be reset by software. The PWMxPIF interrupt is enabled with the PWMxPIE bit in the corresponding PIE register.",
    "30.7.1.1 Period Interrupt Postscaler\nThe frequency of the period interrupt events can be reduced with the period interrupt postscaler. A postscaler counter suppresses period interrupts until the postscale count is reached. Only one PWM period interrupt is generated for every postscale counts. There are 256 postscale selections from 1:1 to 1:256.\nThe PIPOS bits select the postscale value. Changes to the postscale value take effect immediately. Clearing the EN bit before making postscaler changes is recommended to avoid unexpected behavior. The postscale counter is reset when the EN bit is cleared.",
    "30.7.2 Parameter Interrupts\nThe P1 and P2 parameters in each slice have interrupts that occur depending on the selected mode. The individual parameter interrupts are indicated in the PWMxGIR register and enabled by the corresponding bits in the PWMxGIE register.\nA timing example is shown in Figure 30-2. Refer to the timing diagrams of each of the other modes for more details.\nAll the enabled PWMxGIR interrupts of one PMW instance are OR'd together into the PWMxIF bit in one of the PIR registers. The PWMxIF bit is read-only. When any of the PWMxGIR bits are set then the PWMxIF bit is true. All PWMxGIF flags must be reset to clear the PWMxIF bit. The PWMxIF interrupt is enabled with the PWMxIE bit in the corresponding PIE register.",
    "30.8 Operation During Sleep\nThe PWM module operates in Sleep only if the PWM clock is Active. Some internal clock sources are automatically enabled to operate in Sleep when a peripheral using them is enabled. Those clock sources are identified in the clock source table shown in the PWMxCLK clock source selection register.",
    "30.9 Register Definitions: PWM Control\nLong bit name prefixes for the PWM peripherals are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 30-1. PWM Long Bit Name Prefixes\n\nPWM1, Bit Name Prefix = PWM1. PWM2, Bit Name Prefix = PWM2. PWM3, Bit Name Prefix = PWM3",
    "30.9.1 PWMxERS\nName:\nPWMxERS 0x460,0x46F,0x47E\nAddress:\nPWMx External Reset Source\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = ERS[3:0]. , 6 = ERS[3:0]. , 7 = ERS[3:0]. , 8 = ERS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - ERS[3:0] External Reset Source Select\n1111 - 1100, Reset Source.PWM1 = Reserved (ERS Disabled). 1111 - 1100, Reset Source.PWM2 = Reserved (ERS Disabled). 1111 - 1100, Reset Source.PWM3 = Reserved (ERS Disabled). 1011, Reset Source.PWM1 = CLC4_OUT. 1011, Reset Source.PWM2 = CLC4_OUT. 1011, Reset Source.PWM3 = CLC4_OUT. 1010, Reset Source.PWM1 = CLC3_OUT. 1010, Reset Source.PWM2 = CLC3_OUT. 1010, Reset Source.PWM3 = CLC3_OUT. 1001, Reset Source.PWM1 = CLC2_OUT. 1001, Reset Source.PWM2 = CLC2_OUT. 1001, Reset Source.PWM3 = CLC2_OUT. 1000, Reset Source.PWM1 = CLC1_OUT. 1000, Reset Source.PWM2 =",
    "Bits 3:0 - ERS[3:0] External Reset Source Select\nCLC1_OUT. 1000, Reset Source.PWM3 = CLC1_OUT. 0111, Reset Source.PWM1 = PWM3S1P2_OUT. 0111, Reset Source.PWM2 = PWM3S1P2_OUT. 0111, Reset Source.PWM3 = Reserved. 0110, Reset Source.PWM1 = PWM3S1P1_OUT. 0110, Reset Source.PWM2 = PWM3S1P1_OUT. 0110, Reset Source.PWM3 = Reserved. 0101, Reset Source.PWM1 = PWM2S1P2_OUT. 0101, Reset Source.PWM2 = Reserved. 0101, Reset Source.PWM3 = PWM2S1P2_OUT. 0100, Reset Source.PWM1 = PWM2S1P1_OUT. 0100, Reset Source.PWM2 = Reserved. 0100, Reset Source.PWM3 =",
    "Bits 3:0 - ERS[3:0] External Reset Source Select\nPWM2S1P1_OUT. 0011, Reset Source.PWM1 = Reserved. 0011, Reset Source.PWM2 = PWM1S1P2_OUT. 0011, Reset Source.PWM3 = PWM1S1P2_OUT. 0010, Reset Source.PWM1 = Reserved. 0010, Reset Source.PWM2 = PWM1S1P1_OUT. 0010, Reset Source.PWM3 = PWM1S1P1_OUT. 0001, Reset Source.PWM1 = PWM1ERSPPS. 0001, Reset Source.PWM2 = PWM2ERSPPS. 0001, Reset Source.PWM3 = PWM3ERSPPS. 0000, Reset Source.PWM1 = ERS Disabled. 0000, Reset Source.PWM2 = ERS Disabled. 0000, Reset Source.PWM3 = ERS Disabled",
    "30.9.2 PWMxCLK\nName:\nPWMxCLK 0x461,0x470,0x47F\nAddress:\nPWMx Clock Source\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CLK[3:0]. , 6 = CLK[3:0]. , 7 = CLK[3:0]. , 8 = CLK[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - CLK[3:0] PWM Clock Source Select\n1111, Source = Reserved. 1111, Operates in Sleep = N/A. 1110, Source = CLC4_OUT. 1110, Operates in Sleep = Yes (1). 1101, Source = CLC3_OUT. 1101, Operates in Sleep = Yes (1). 1100, Source = CLC2_OUT. 1100, Operates in Sleep = Yes (1). 1011, Source = CLC1_OUT. 1011, Operates in Sleep = Yes (1). 1010, Source = NCO1_OUT. 1010, Operates in Sleep = Yes (1). 1001, Source = CLKREF. 1001, Operates in Sleep = Yes (1). 1000, Source = EXTOSC. 1000, Operates in Sleep = Yes. 0111, Source = SOSC. 0111, Operates in Sleep = Yes. 0110, Source = MFINTOSC (32 kHz). 0110, Operates in Sleep = Yes. 0101, Source = MFINTOSC (500 kHz). 0101, Operates in Sleep = Yes. 0100, Source =",
    "Bits 3:0 - CLK[3:0] PWM Clock Source Select\nLFINTOSC. 0100, Operates in Sleep = Yes. 0011, Source = HFINTOSC. 0011, Operates in Sleep = Yes. 0010, Source = F OSC. 0010, Operates in Sleep = No. 0001, Source = PWMIN1PPS. 0001, Operates in Sleep = Yes (1). 0000, Source = PWMIN0PPS. 0000, Operates in Sleep = Yes (1)",
    "30.9.3 PWMxLDS\nName:\nPWMxLDS 0x462,0x471,0x480\nAddress:\nPWMx Auto-load Trigger Source Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = LDS[3:0]. , 6 = LDS[3:0]. , 7 = LDS[3:0]. , 8 = LDS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - LDS[3:0] Auto-load Trigger Source Select\n1111 - 1011, Source = Auto-load Disabled. 1010, Source = DMA4_Destination_Count_Done. 1001, Source = DMA3_Destination_Count_Done. 1000, Source = DMA2_Destination_Count_Done. 0111, Source = DMA1_Destination_Count_Done. 0110, Source = CLC4_OUT. 0101, Source = CLC3_OUT. 0100, Source = CLC2_OUT. 0011, Source = CLC1_OUT. 0010, Source = PWMIN1PPS. 0001, Source = PWMIN0PPS. 0000, Source = Auto-load Disabled",
    "30.9.4 PWMxPR\nName:\nPWMxPR 0x463,0x472,0x481\nAddress:\nPWMx Period Register\nDetermines the PWMx period",
    "30.9.4 PWMxPR\nAccess, 15.PR[15:8] = R/W. Access, 14.PR[15:8] = R/W. Access, 13.PR[15:8] = R/W. Access, 12.PR[15:8] = R/W. Access, 11.PR[15:8] = R/W. Access, 10.PR[15:8] = R/W. Access, 9.PR[15:8] = R/W. Access, 8.PR[15:8] = R/W. Reset, 15.PR[15:8] = 0. Reset, 14.PR[15:8] = 0. Reset, 13.PR[15:8] = 0. Reset, 12.PR[15:8] = 0. Reset, 11.PR[15:8] = 0. Reset, 10.PR[15:8] = 0. Reset, 9.PR[15:8] = 0. Reset, 8.PR[15:8] = 0. Bit, 15.PR[15:8] = 7. Bit, 14.PR[15:8]",
    "30.9.4 PWMxPR\n= 6. Bit, 13.PR[15:8] = 5. Bit, 12.PR[15:8] = 4. Bit, 11.PR[15:8] = 3. Bit, 10.PR[15:8] = 2. Bit, 9.PR[15:8] = 1. Bit, 8.PR[15:8] = 0. , 15.PR[15:8] = PR[7:0]. , 14.PR[15:8] = PR[7:0]. , 13.PR[15:8] = PR[7:0]. , 12.PR[15:8] = PR[7:0]. , 11.PR[15:8] = PR[7:0]. , 10.PR[15:8] = PR[7:0]. , 9.PR[15:8] = PR[7:0]. , 8.PR[15:8] = PR[7:0]. Access, 15.PR[15:8] = R/W. Access, 14.PR[15:8] = R/W.",
    "30.9.4 PWMxPR\nAccess, 13.PR[15:8] = R/W. Access, 12.PR[15:8] = R/W. Access, 11.PR[15:8] = R/W. Access, 10.PR[15:8] = R/W. Access, 9.PR[15:8] = R/W. Access, 8.PR[15:8] = R/W. Reset, 15.PR[15:8] = 0. Reset, 14.PR[15:8] = 0. Reset, 13.PR[15:8] = 0. Reset, 12.PR[15:8] = 0. Reset, 11.PR[15:8] = 0. Reset, 10.PR[15:8] = 0. Reset, 9.PR[15:8] = 0. Reset, 8.PR[15:8] = 0",
    "Bits 15:0 - PR[15:0] PWM Period\nNumber of PWM clocks periods in the PWM period\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 PWMxPRH: Accesses the high byte PR[15:8]\n\u00b7 PWMxPRL: Accesses the low byte PR[7:0]",
    "30.9.5 PWMxCPRE\nName:\nPWMxCPRE\nAddress:\n0x465,0x474,0x483\nPWMx Clock Prescaler Register",
    "30.9.5 PWMxCPRE\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CPRE[7:0]. , 2 = CPRE[7:0]. , 3 = CPRE[7:0]. , 4 = CPRE[7:0]. , 5 = CPRE[7:0]. , 6 = CPRE[7:0]. , 7 = CPRE[7:0]. , 8 = CPRE[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 =",
    "30.9.5 PWMxCPRE\n0",
    "Bits 7:0 - CPRE[7:0] PWM Clock Prescale Value\nn, Description = PWMclock is prescaled by n+1",
    "30.9.6 PWMxPIPOS\nName:\nPWMxPIPOS 0x466,0x475,0x484\nAddress:\nPWMx Period Interrupt Postscaler Register",
    "30.9.6 PWMxPIPOS\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PIPOS[7:0]. , 2 = PIPOS[7:0]. , 3 = PIPOS[7:0]. , 4 = PIPOS[7:0]. , 5 = PIPOS[7:0]. , 6 = PIPOS[7:0]. , 7 = PIPOS[7:0]. , 8 = PIPOS[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8",
    "30.9.6 PWMxPIPOS\n= 0",
    "Bits 7:0 - PIPOS[7:0] Period Interrupt Postscale Value\nn, Description = Period interrupt occurs after n+1 period events",
    "30.9.7 PWMxGIR\nName:\nPWMxGIR 0x467,0x476,0x485\nAddress:\nPWMx Interrupt Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = S1P2. , 8 = S1P1. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 1 - SaP2 Slice 'a' Parameter 2 Interrupt Flag\n1, Mode = Variable Aligned or Compare. 1, Description = Compare match between P2 and PWMcounter has occurred. 1, Mode = Center-Aligned. 1, Description = PWMx_SaP2_out has changed. 1, Mode = Right Aligned. 1, Description = Left edge of PWMx_SaP2_out pulse has occurred. 1, Mode = Left Aligned. 1, Description = Right edge of PWMx_SaP2_out pulse has occurred. 0, Mode = All. 0, Description = Interrupt event has not occurred",
    "Bit 0 - SaP1 Slice 'a' Parameter 1 Interrupt Flag\n1, Mode = Variable Aligned or Compare. 1, Description = Compare match between P1 and PWMcounter has occurred. 1, Mode = Center-Aligned. 1, Description = PWMx_SaP1_out has changed. 1, Mode = Right Aligned. 1, Description = Left edge of PWMx_SaP1_out pulse has occurred. 1, Mode = Left Aligned. 1, Description = Right edge of PWMx_SaP1_out pulse has occurred. 0, Mode = All. 0, Description = Interrupt event has not occurred",
    "30.9.8 PWMxGIE\nName:\nPWMxGIE\nAddress:\n0x468,0x477,0x486\nPWMx Interrupt Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = S1P2. , 8 = S1P1. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 1 - SaP2 Slice 'a' Parameter 2 Interrupt Enable\n1, Description = Slice 'a' Parameter 2 match interrupt is enabled. 0, Description = Slice 'a' Parameter 2 match interrupt is not enabled",
    "Bit 0 - SaP1 Slice 'a' Parameter 1 Interrupt Enable\n1, Description = Slice 'a' Parameter 1 match interrupt is enabled. 0, Description = Slice 'a' Parameter 1 match interrupt is not enabled",
    "30.9.9 PWMxCON\nName:\nPWMxCON 0x469,0x478,0x487\nAddress:\nPWM Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = LD. , 7 = ERSPOL. , 8 = ERSNOW. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W/HC. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN PWM Module Enable\n1, Description = PWMmodule is enabled. 0, Description = PWMmodule is disabled. The prescaler, postscaler, and all internal logic are reset. Outputs go to their default states. Register values remain unchanged.",
    "Bit 2 - LD Reload Registers\nReload the period and duty cycle registers on the next period event\n1, Description = Reload PR/P1/P2 registers. 0, Description = Reload not enabled or reload complete",
    "Bit 1 - ERSPOL External Reset Polarity Select\n1, Description = External Reset input is active-low. 0, Description = External Reset input is active-high",
    "Bit 0 - ERSNOW External Reset Mode Select\nDetermines when an external Reset event takes effect.\n1, Description = Stop counter on the next PWMclock. Output goes to the Inactive state.. 0, Description = Stop counter at the end of the period. Output goes to the Inactive state.",
    "Name: PWMxSaCFG\nPWM Slice 'a' Configuration Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POL2. , 2 = POL1. , 3 = . , 4 = . , 5 = PPEN. , 6 = MODE[2:0]. , 7 = MODE[2:0]. , 8 = MODE[2:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - POL2 PWM Slice 'a' Parameter 2 Output Polarity\n1, Description = PWMx_SaP2_out is low true. 0, Description = PWMx_SaP2_out is high true",
    "Bit 6 - POL1 PWM Slice 'a' Parameter 1 Output Polarity\n1, Description = PWMx_SaP1_out is low true. 0, Description = PWMx_SaP1_out is high true",
    "Bit 3 - PPEN Push-Pull Mode Enable\nEach period the output alternates between PWMx_SaP1_out and PWMx_SaP2_out. Only Left and Right Aligned modes are supported. Other modes may exhibit unexpected results.\n1, Description = PWMx Slice 'a' Push-Pull mode is enabled. 0, Description = PWMx Slice 'a' Push-Pull mode is not enabled",
    "Bits 2:0 - MODE[2:0] PWM Module Slice 'a' Operating Mode Select Selects operating mode for both PWMx_SaP1_out and PWMx_SaP2_out\n11x, Description = Reserved. Outputs go to Reset state.. 101, Description = Compare mode: Toggle PWMx_SaP1_out and PWMx_SaP2_out on PWMtimer match with corresponding parameter register. 100, Description = Compare mode: Set PWMx_SaP1_out and PWMx_SaP2_out high on PWMtimer match with corresponding parameter register. 011, Description = Variable Aligned mode. 010, Description = Center-Aligned mode. 001, Description = Right Aligned mode. 000, Description = Left Aligned mode",
    "Note:\n- 1. Changes to this register must be done only when the EN bit is cleared.",
    "Name: PWMxSaP1\nPWM Slice 'a' Parameter 1 Register\nDetermines the active period of slice 'a', parameter 1 output",
    "Name: PWMxSaP1\nAccess, 15.P1[15:8] = R/W. Access, 14.P1[15:8] = R/W. Access, 13.P1[15:8] = R/W. Access, 12.P1[15:8] = R/W. Access, 11.P1[15:8] = R/W. Access, 10.P1[15:8] = R/W. Access, 9.P1[15:8] = R/W. Access, 8.P1[15:8] = R/W. Reset, 15.P1[15:8] = 0. Reset, 14.P1[15:8] = 0. Reset, 13.P1[15:8] = 0. Reset, 12.P1[15:8] = 0. Reset, 11.P1[15:8] = 0. Reset, 10.P1[15:8] = 0. Reset, 9.P1[15:8] = 0. Reset, 8.P1[15:8] = 0. Bit,",
    "Name: PWMxSaP1\n15.P1[15:8] = 7. Bit, 14.P1[15:8] = 6. Bit, 13.P1[15:8] = 5. Bit, 12.P1[15:8] = 4. Bit, 11.P1[15:8] = 3. Bit, 10.P1[15:8] = 2. Bit, 9.P1[15:8] = 1. Bit, 8.P1[15:8] = 0. , 15.P1[15:8] = P1[7:0]. , 14.P1[15:8] = P1[7:0]. , 13.P1[15:8] = P1[7:0]. , 12.P1[15:8] = P1[7:0]. , 11.P1[15:8] = P1[7:0]. , 10.P1[15:8] = P1[7:0]. , 9.P1[15:8] = P1[7:0]. ,",
    "Name: PWMxSaP1\n8.P1[15:8] = P1[7:0]. Access, 15.P1[15:8] = R/W. Access, 14.P1[15:8] = R/W. Access, 13.P1[15:8] = R/W. Access, 12.P1[15:8] = R/W. Access, 11.P1[15:8] = R/W. Access, 10.P1[15:8] = R/W. Access, 9.P1[15:8] = R/W. Access, 8.P1[15:8] = R/W. Reset, 15.P1[15:8] = 0. Reset, 14.P1[15:8] = 0. Reset, 13.P1[15:8] = 0. Reset, 12.P1[15:8] = 0. Reset, 11.P1[15:8] = 0. Reset, 10.P1[15:8] = 0. Reset, 9.P1[15:8] = 0. Reset,",
    "Name: PWMxSaP1\n8.P1[15:8] = 0",
    "Bits 15:0 - P1[15:0] Parameter 1 Value\nn, Mode = Compare. n, Description = Compare match event occurs when PWMx timer = n (refer to MODE selections). n, Mode = Variable Aligned. n, Description = PWMx_SaP1_out and PWMx_SaP2 both go high when PWMx timer = n. n, Mode = Center-Aligned. n, Description = PWMx_SaP1_out is high 2*n PWMx clock periods centered around PWMx period event. n, Mode = Right Aligned. n, Description = PWMx_SaP1_out is high n PWMx clock periods at end of PWMx period. n, Mode = Left Aligned. n, Description = PWMx_SaP1_out is high n PWMx clock periods at beginning of PWMx period\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 PWMxSaP1H: Accesses the high byte P1[15:8]\n\u00b7 PWMxSaP1L: Accesses the low byte P1[7:0]",
    "Name: PWMxSaP2\nPWM Slice 'a' Parameter 2 Register\nDetermines the active period of slice 'a', parameter 2 output",
    "Name: PWMxSaP2\nAccess, 15.P2[15:8] = R/W. Access, 14.P2[15:8] = R/W. Access, 13.P2[15:8] = R/W. Access, 12.P2[15:8] = R/W. Access, 11.P2[15:8] = R/W. Access, 10.P2[15:8] = R/W. Access, 9.P2[15:8] = R/W. Access, 8.P2[15:8] = R/W. Reset, 15.P2[15:8] = 0. Reset, 14.P2[15:8] = 0. Reset, 13.P2[15:8] = 0. Reset, 12.P2[15:8] = 0. Reset, 11.P2[15:8] = 0. Reset, 10.P2[15:8] = 0. Reset, 9.P2[15:8] = 0. Reset, 8.P2[15:8] = 0. Bit,",
    "Name: PWMxSaP2\n15.P2[15:8] = 7. Bit, 14.P2[15:8] = 6. Bit, 13.P2[15:8] = 5. Bit, 12.P2[15:8] = 4. Bit, 11.P2[15:8] = 3. Bit, 10.P2[15:8] = 2. Bit, 9.P2[15:8] = 1. Bit, 8.P2[15:8] = 0. , 15.P2[15:8] = P2[7:0]. , 14.P2[15:8] = P2[7:0]. , 13.P2[15:8] = P2[7:0]. , 12.P2[15:8] = P2[7:0]. , 11.P2[15:8] = P2[7:0]. , 10.P2[15:8] = P2[7:0]. , 9.P2[15:8] = P2[7:0]. ,",
    "Name: PWMxSaP2\n8.P2[15:8] = P2[7:0]. Access, 15.P2[15:8] = R/W. Access, 14.P2[15:8] = R/W. Access, 13.P2[15:8] = R/W. Access, 12.P2[15:8] = R/W. Access, 11.P2[15:8] = R/W. Access, 10.P2[15:8] = R/W. Access, 9.P2[15:8] = R/W. Access, 8.P2[15:8] = R/W. Reset, 15.P2[15:8] = 0. Reset, 14.P2[15:8] = 0. Reset, 13.P2[15:8] = 0. Reset, 12.P2[15:8] = 0. Reset, 11.P2[15:8] = 0. Reset, 10.P2[15:8] = 0. Reset, 9.P2[15:8] = 0. Reset,",
    "Name: PWMxSaP2\n8.P2[15:8] = 0",
    "Bits 15:0 - P2[15:0] Parameter 2 Value\nn, Mode = Compare. n, Description = Compare match event occurs when PWMx timer = n (refer to MODE selections). n, Mode = Variable Aligned. n, Description = PWMx_SaP1_out and PWMx_SaP2 both go low when PWMx timer = n. n, Mode = Center-Aligned. n, Description = PWMx_SaP2_out is high 2*n PWMx clock periods centered around PWMx period event. n, Mode = Right Aligned. n, Description = PWMx_SaP2_out is high n PWMx clock periods at end of PWMx period. n, Mode = Left Aligned. n, Description = PWMx_SaP2_out is high n PWMx clock periods at beginning of PWMx period\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 PWMxSaP2H: Accesses the high byte P2[15:8]\n\u00b7 PWMxSaP2L: Accesses the low byte P2[7:0]",
    "30.9.13  PWMLOAD\nName:\nPWMLOAD\nAddress:\n0x49C\nMirror copies of all PWMxLD bits\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nMPWM3LD\nMPWM2LD\nMPWM1LD\nAccess Reset\nR/W\nR/W\nR/W\n0\n0\n0",
    "Bits 0, 1, 2 - MPWMxLD Mirror copy of PWMxLD bit\nMirror copies of all PWMxLD bits can be set simultaneously to synchronize the load event across all PWMs\n1, Description = PWMx parameter and period values will be transferred to their buffer registers at the next period Reset event. 0, Description = There are no PWMx period and parameter value transfers pending",
    "30.9.14  PWMEN\nName:\nPWMEN 0x49D\nAddress:\nMirror copies of all PWMxEN bits\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2 - MPWMxEN Mirror copy of PWMxEN bit\nMirror copies of all PWMxEN bits can be set simultaneously to synchronize the enable event across all PWMs\n1, Description = PWMx is enabled. 0, Description = PWMx is not enabled",
    "30.10 Register Summary - PWM\n0x00 ..., Name = Reserved. 0x00 ..., Bit Pos. = . 0x00 ..., 7 = . 0x00 ..., 6 = . 0x00 ..., 5 = . 0x00 ..., 4 = . 0x00 ..., 1 = . 0x00 ..., 0 = . 0x045F, Name = . 0x045F, Bit Pos. = . 0x045F, 7 = . 0x045F, 6 = . 0x045F, 5 = . 0x045F, 4 = . 0x045F, 1 = . 0x045F, 0 = . 0x0460, Name = PWM1ERS. 0x0460, Bit Pos. = 7:0. 0x0460, 7 = . 0x0460, 6 = . 0x0460, 5 = . 0x0460, 4 = . 0x0460, 1 = ERS[3:0]. 0x0460, 0",
    "30.10 Register Summary - PWM\n= . 0x0461, Name = PWM1CLK. 0x0461, Bit Pos. = 7:0. 0x0461, 7 = . 0x0461, 6 = . 0x0461, 5 = . 0x0461, 4 = . 0x0461, 1 = CLK[3:0]. 0x0461, 0 = . 0x0462, Name = PWM1LDS. 0x0462, Bit Pos. = 7:0. 0x0462, 7 = . 0x0462, 6 = . 0x0462, 5 = . 0x0462, 4 = . 0x0462, 1 = LDS[3:0]. 0x0462, 0 = . 0x0463, Name = PWM1PR. 0x0463, Bit Pos. = 7:0. 0x0463, 7 = . 0x0463, 6 = . 0x0463, 5 = . 0x0463, 4 =",
    "30.10 Register Summary - PWM\nPR[7:0]. 0x0463, 1 = . 0x0463, 0 = . 0x0465, Name = PWM1CPRE. 0x0465, Bit Pos. = 15:8 7:0. 0x0465, 7 = . 0x0465, 6 = . 0x0465, 5 = . 0x0465, 4 = PR[15:8] CPRE[7:0]. 0x0465, 1 = . 0x0465, 0 = . 0x0466, Name = PWM1PIPOS. 0x0466, Bit Pos. = 7:0. 0x0466, 7 = . 0x0466, 6 = . 0x0466, 5 = . 0x0466, 4 = PIPOS[7:0]. 0x0466, 1 = . 0x0466, 0 = . 0x0467, Name = PWM1GIR. 0x0467, Bit Pos. = 7:0.",
    "30.10 Register Summary - PWM\n0x0467, 7 = . 0x0467, 6 = . 0x0467, 5 = . 0x0467, 4 = . 0x0467, 1 = S1P2. 0x0467, 0 = S1P1. 0x0468, Name = PWM1GIE. 0x0468, Bit Pos. = 7:0. 0x0468, 7 = . 0x0468, 6 = . 0x0468, 5 = . 0x0468, 4 = . 0x0468, 1 = S1P2. 0x0468, 0 = S1P1. 0x0469, Name = PWM1CON. 0x0469, Bit Pos. = 7:0. 0x0469, 7 = EN. 0x0469, 6 = . 0x0469, 5 = . 0x0469, 4 = . 0x0469, 1 = ERSPOL. 0x0469, 0 = ERSNOW.",
    "30.10 Register Summary - PWM\n0x046A, Name = PWM1S1CFG. 0x046A, Bit Pos. = 7:0. 0x046A, 7 = POL2. 0x046A, 6 = POL1. 0x046A, 5 = . 0x046A, 4 = PPEN. 0x046A, 1 = MODE[2:0]. 0x046A, 0 = . 0x046B, Name = PWM1S1P1. 0x046B, Bit Pos. = 7:0. 0x046B, 7 = . 0x046B, 6 = . 0x046B, 5 = . 0x046B, 4 = P1[7:0]. 0x046B, 1 = . 0x046B, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = P1[15:8]. , 1 = . , 0 = . 0x046D, Name =",
    "30.10 Register Summary - PWM\nPWM1S1P2. 0x046D, Bit Pos. = 7:0. 0x046D, 7 = . 0x046D, 6 = . 0x046D, 5 = . 0x046D, 4 = P2[7:0]. 0x046D, 1 = . 0x046D, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = P2[15:8]. , 1 = . , 0 = . 0x046F, Name = PWM2ERS. 0x046F, Bit Pos. = 7:0. 0x046F, 7 = . 0x046F, 6 = . 0x046F, 5 = . 0x046F, 4 = . 0x046F, 1 = ERS[3:0]. 0x046F, 0 = . 0x0470, Name = PWM2CLK. 0x0470, Bit Pos. =",
    "30.10 Register Summary - PWM\n7:0. 0x0470, 7 = . 0x0470, 6 = . 0x0470, 5 = . 0x0470, 4 = . 0x0470, 1 = CLK[3:0]. 0x0470, 0 = . 0x0471, Name = PWM2LDS. 0x0471, Bit Pos. = 7:0. 0x0471, 7 = . 0x0471, 6 = . 0x0471, 5 = . 0x0471, 4 = . 0x0471, 1 = LDS[3:0]. 0x0471, 0 = . 0x0472, Name = PWM2PR. 0x0472, Bit Pos. = 7:0 15:8. 0x0472, 7 = . 0x0472, 6 = . 0x0472, 5 = . 0x0472, 4 = PR[7:0] PR[15:8]. 0x0472, 1 = .",
    "30.10 Register Summary - PWM\n0x0472, 0 = . 0x0474, Name = PWM2CPRE. 0x0474, Bit Pos. = 7:0. 0x0474, 7 = . 0x0474, 6 = . 0x0474, 5 = . 0x0474, 4 = CPRE[7:0]. 0x0474, 1 = . 0x0474, 0 = . 0x0475, Name = PWM2PIPOS. 0x0475, Bit Pos. = 7:0. 0x0475, 7 = . 0x0475, 6 = . 0x0475, 5 = . 0x0475, 4 = PIPOS[7:0]. 0x0475, 1 = . 0x0475, 0 = . 0x0476, Name = PWM2GIR. 0x0476, Bit Pos. = 7:0. 0x0476, 7 = . 0x0476, 6 = . 0x0476, 5",
    "30.10 Register Summary - PWM\n= . 0x0476, 4 = . 0x0476, 1 = S1P2. 0x0476, 0 = S1P1. 0x0477, Name = PWM2GIE. 0x0477, Bit Pos. = 7:0. 0x0477, 7 = . 0x0477, 6 = . 0x0477, 5 = . 0x0477, 4 = . 0x0477, 1 = S1P2. 0x0477, 0 = S1P1. 0x0478, Name = PWM2CON. 0x0478, Bit Pos. = 7:0. 0x0478, 7 = EN. 0x0478, 6 = . 0x0478, 5 = . 0x0478, 4 = PPEN. 0x0478, 1 = ERSPOL MODE[2:0]. 0x0478, 0 = ERSNOW. 0x0479, Name = PWM2S1CFG.",
    "30.10 Register Summary - PWM\n0x0479, Bit Pos. = 7:0 7:0. 0x0479, 7 = POL2. 0x0479, 6 = POL1. 0x0479, 5 = . 0x0479, 4 = P1[7:0]. 0x0479, 1 = . 0x0479, 0 = . 0x047A, Name = PWM2S1P1. 0x047A, Bit Pos. = 15:8. 0x047A, 7 = . 0x047A, 6 = . 0x047A, 5 = . 0x047A, 4 = P1[15:8]. 0x047A, 1 = . 0x047A, 0 = . 0x047C, Name = . 0x047C, Bit Pos. = 7:0. 0x047C, 7 = . 0x047C, 6 = . 0x047C, 5 = . 0x047C, 4 = P2[7:0].",
    "30.10 Register Summary - PWM\n0x047C, 1 = . 0x047C, 0 = . , Name = PWM2S1P2. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = P2[15:8]. , 1 = . , 0 = . 0x047E, Name = PWM3ERS. 0x047E, Bit Pos. = 7:0. 0x047E, 7 = . 0x047E, 6 = . 0x047E, 5 = . 0x047E, 4 = . 0x047E, 1 = ERS[3:0]. 0x047E, 0 = . 0x047F, Name = PWM3CLK. 0x047F, Bit Pos. = 7:0. 0x047F, 7 = . 0x047F, 6 = . 0x047F, 5 = . 0x047F, 4 = . 0x047F, 1 = CLK[3:0].",
    "30.10 Register Summary - PWM\n0x047F, 0 = . 0x0480, Name = PWM3LDS. 0x0480, Bit Pos. = 7:0. 0x0480, 7 = . 0x0480, 6 = . 0x0480, 5 = . 0x0480, 4 = . 0x0480, 1 = LDS[3:0]. 0x0480, 0 = . 0x0481, Name = PWM3PR. 0x0481, Bit Pos. = 7:0 15:8. 0x0481, 7 = . 0x0481, 6 = . 0x0481, 5 = . 0x0481, 4 = PR[7:0] PR[15:8]. 0x0481, 1 = . 0x0481, 0 = . 0x0483, Name = PWM3CPRE. 0x0483, Bit Pos. = 7:0. 0x0483, 7 = . 0x0483, 6 = .",
    "30.10 Register Summary - PWM\n0x0483, 5 = . 0x0483, 4 = CPRE[7:0]. 0x0483, 1 = . 0x0483, 0 = . 0x0484, Name = PWM3PIPOS. 0x0484, Bit Pos. = 7:0. 0x0484, 7 = . 0x0484, 6 = . 0x0484, 5 = . 0x0484, 4 = PIPOS[7:0]. 0x0484, 1 = . 0x0484, 0 = . 0x0485, Name = PWM3GIR. 0x0485, Bit Pos. = 7:0. 0x0485, 7 = . 0x0485, 6 = . 0x0485, 5 = . 0x0485, 4 = . 0x0485, 1 = S1P2. 0x0485, 0 = S1P1. 0x0486, Name = PWM3GIE. 0x0486,",
    "30.10 Register Summary - PWM\nBit Pos. = 7:0. 0x0486, 7 = . 0x0486, 6 = . 0x0486, 5 = . 0x0486, 4 = . 0x0486, 1 = S1P2. 0x0486, 0 = S1P1 ERSNOW. 0x0487 0x0488, Name = PWM3CON PWM3S1CFG. 0x0487 0x0488, Bit Pos. = 7:0 7:0. 0x0487 0x0488, 7 = EN POL2. 0x0487 0x0488, 6 = POL1. 0x0487 0x0488, 5 = . 0x0487 0x0488, 4 = PPEN. 0x0487 0x0488, 1 = ERSPOL MODE[2:0]. 0x0487 0x0488, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = .",
    "30.10 Register Summary - PWM\n, 5 = . , 4 = P1[7:0]. , 1 = . , 0 = . 0x0489, Name = PWM3S1P1. 0x0489, Bit Pos. = 15:8. 0x0489, 7 = . 0x0489, 6 = . 0x0489, 5 = . 0x0489, 4 = P1[15:8]. 0x0489, 1 = . 0x0489, 0 = . 0x048B, Name = PWM3S1P2. 0x048B, Bit Pos. = 7:0. 0x048B, 7 = . 0x048B, 6 = . 0x048B, 5 = . 0x048B, 4 = P2[7:0]. 0x048B, 1 = . 0x048B, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = P2[15:8]. ,",
    "30.10 Register Summary - PWM\n1 = . , 0 = . 0x048D ..., Name = . 0x048D ..., Bit Pos. = . 0x048D ..., 7 = . 0x048D ..., 6 = . 0x048D ..., 5 = . 0x048D ..., 4 = . 0x048D ..., 1 = . 0x048D ..., 0 = . , Name = Reserved. , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 1 = . , 0 = . 0x049B 0x049C, Name = PWMLOAD. 0x049B 0x049C, Bit Pos. = 7:0. 0x049B 0x049C, 7 = . 0x049B 0x049C, 6 = . 0x049B 0x049C, 5 = . 0x049B 0x049C, 4 = . 0x049B",
    "30.10 Register Summary - PWM\n0x049C, 1 = MPWM2LD. 0x049B 0x049C, 0 = MPWM1LD. 0x049D, Name = PWMEN. 0x049D, Bit Pos. = 7:0. 0x049D, 7 = . 0x049D, 6 = . 0x049D, 5 = . 0x049D, 4 = . 0x049D, 1 = MPWM2EN. 0x049D, 0 = MPWM1EN",
    "31. CWG - Complementary Waveform Generator Module\nThe Complementary Waveform Generator (CWG) produces half-bridge, full-bridge, and steering of PWM waveforms. It is backward compatible with previous CCP functions.\nThe CWG has the following features:\n\u00b7 Six Operating modes:\n-Synchronous Steering mode\n-Asynchronous Steering mode\n-Full Bridge mode, Forward\n-Full Bridge mode, Reverse\n-Half Bridge mode\n-Push-Pull mode\n\u00b7 Output Polarity Control\n\u00b7 Output Steering\n\u00b7 Independent 6-bit Rising and Falling Event Dead-Band Timers:\n-Clocked dead band\n-Independent rising and falling dead-band enables\n\u00b7 Auto-Shutdown Control with:\n-Selectable shutdown sources\n-Auto-restart option\n-Auto-shutdown pin override control",
    "31.1 Fundamental Operation\nThe CWG generates two output waveforms from the selected input source.\nThe off-to-on transition of each output can be delayed from the on-to-off transition of the other output, thereby creating a time delay immediately where neither output is driven. This is referred to as dead time and is covered in the Dead-Band Control section.\nIt may be necessary to guard against the possibility of circuit faults or a feedback event arriving too late or not at all. In this case, the active drive must be terminated before the Fault condition causes damage. This is referred to as auto-shutdown and is covered in the Auto-Shutdown section.",
    "31.2 Operating Modes\nThe CWG module can operate in six different modes, as specified by the MODE bits:\n\u00b7 Half Bridge mode\n\u00b7 Push-Pull mode\n\u00b7 Asynchronous Steering mode\n\u00b7 Synchronous Steering mode\n\u00b7 Full Bridge mode, Forward\n\u00b7 Full Bridge mode, Reverse\nAll modes accept a single pulse input and provide up to four outputs as described in the following sections.\nAll modes include auto-shutdown control as described in the Auto-Shutdown section.\nImportant: Except as noted for Full Bridge mode, mode changes must only be performed while EN = 0 .",
    "31.2.1 Half Bridge Mode\nIn Half Bridge mode, two output signals are generated as true and inverted versions of the input as illustrated in Figure 31-1. A nonoverlap (dead band) time is inserted between the two outputs to prevent shoot-through current in various power supply applications. Dead-band control is described in the Dead-Band Control section. The output steering feature cannot be used in this mode. A basic block diagram of this mode is shown in Figure 31-2.\nThe unused outputs CWGxC and CWGxD drive similar signals as CWGxA and CWGxB, with polarity independently controlled by the POLC and POLD bits, respectively.\nFigure 31-1. CWG Half Bridge Mode Operation\nFigure 31-2. Simplified CWG Block Diagram (Half Bridge Mode, MODE = 'b100 )",
    "31.2.2 Push-Pull Mode\nIn Push-Pull mode, two output signals are generated, alternating copies of the input as illustrated in Figure 31-3. This alternation creates the Push-Pull effect required for driving some transformerbased power supply designs. Steering modes are not used in Push-Pull mode. A basic block diagram for the Push-Pull mode is shown in Figure 31-4.\nThe Push-Pull sequencer is reset whenever EN = 0 or if an auto-shutdown event occurs. The sequencer is clocked by the first input pulse, and the first output appears on CWGxA.\nThe unused outputs CWGxC and CWGxD drive copies of CWGxA and CWGxB, respectively, but with polarity controlled by the POLC and POLD bits.",
    "Figure 31-3. CWG Push-Pull Mode Operation\nRev. 30-000098A\n4/14/2017",
    "CWGx clock\nCWG Data Input\nCWGxA\nCWGxB\nFigure 31-4. Simplified CWG Block Diagram (Push-Pull Mode, MODE = 'b101 )",
    "31.2.3 Full Bridge Mode\nIn Forward and Reverse Full Bridge modes, three outputs drive static values while the fourth is modulated by the input data signal. The mode selection may be toggled between forward and reverse by toggling the MODE[0] bit of the CWGxCON0 register while keeping the MODE[2:1] bits static, without disabling the CWG module. When connected, as shown in Figure 31-5, the outputs are appropriate for a full-bridge motor driver. Each CWG output signal has independent polarity control, so the circuit can be adapted to high-active and low-active drivers. A simplified block diagram for the Full Bridge modes is shown in Figure 31-6.\nFigure 31-5. Example of Full-Bridge Application\n\u2e20\n\u3130\n\u5142\n\u5144\n\u6572\n\u6572\n\u5141\n\u4f41\n\u4444\n\u5143\n\u6572\n\u6572\nFigure 31-6. Simplified CWG Block Diagram (Forward and Reverse Full Bridge Modes)\nMODE = ' b010 : Forward",
    "31.2.3 Full Bridge Mode\nIn Forward Full Bridge mode (MODE = 'b010 ), CWGxA is driven to its Active state, CWGxB and CWGxC are driven to their Inactive state, and CWGxD is modulated by the input signal, as shown in Figure 31-7.\nIn Reverse Full Bridge mode (MODE = 'b011 ), CWGxC is driven to its Active state, CWGxA and CWGxD are driven to their Inactive states, and CWGxB is modulated by the input signal, as shown in Figure 31-7.\nIn Full Bridge mode, the dead-band period is used when there is a switch from forward to reverse or vice versa. This dead-band control is described in the Dead-Band Control section, with additional details in the Rising Edge and Reverse Dead Band and Falling Edge and Forward Dead Band sections. Steering modes are not used with either of the Full Bridge modes.\nFigure 31-7. Example of Full-Bridge Output\nRev. 30-000099A",
    "Notes:\n1. A rising CWG data input creates a rising event on the modulated output.\n2. Output signals shown as active-high; all POLy bits are clear.",
    "31.2.3.1 Direction Change in Full Bridge Mode\nIn Full Bridge mode, changing the MODE[0] bit controls the forward/reverse direction. Direction changes occur on the next rising edge of the modulated input. The sequence, described as follows, is illustrated in Figure 31-8.\n1. The associated active output CWGxA and the inactive output CWGxC are switched to drive in the opposite direction.\n2. The previously modulated output CWGxD is switched to the Inactive state, and the previously inactive output CWGxB begins to modulate.\n3. CWG modulation resumes after the direction-switch dead band has elapsed.\nFigure 31-8. Example of PWM Direction Change at Near 100% Duty Cycle",
    "31.2.3.2 Dead-Band Delay in Full Bridge Mode\nDead-band delay is important when either of the following conditions is true:\n\u00b7 The direction of the CWG output changes when the duty cycle of the data input is at or near 100%\n\u00b7 The turn-off time of the power switch, including the power device and driver circuit, is greater than the turn-on time\nThe dead-band delay is inserted only when changing directions and only the modulated output is affected. The statically-configured outputs (CWGxA and CWGxC) are not afforded dead band and switch essentially simultaneously.\nFigure 31-8 shows an example of the CWG outputs changing directions from forward to reverse, at near 100% duty cycle. In this example, at time t1, the output of CWGxA and CWGxD becomes inactive, while the output of CWGxC becomes active. Since the turn-off time of the power devices is longer than the turn-on time, a shoot-through current will flow through the power devices QC and QD for the duration of 'T'. The same phenomenon will occur to power devices QA and QB for the CWG direction change from reverse to forward.",
    "31.2.3.2 Dead-Band Delay in Full Bridge Mode\nWhen changing the CWG direction at high duty cycle is required for an application, two possible solutions for eliminating the shoot-through current are:\n- 1. Reduce the CWG duty cycle for one period before changing directions.\n- 2. Use switch drivers that can drive the switches off faster than they can drive them on.",
    "31.2.4 Steering Modes\nIn both Synchronous and Asynchronous Steering modes, the CWG Data can be steered to any combination of four CWG outputs. A fixed value will be presented on all the outputs not used for the PWM output. Each output has independent polarity, steering, and shutdown options. Dead-band control is not used in either Steering mode.\nFor example, when STRA = 0 , the corresponding pin is held at the level defined by OVRA. When STRA = 1 , the pin is driven by the CWG Data signal. The POLy bits control the signal polarity only when STRy = 1 .\nThe CWG auto-shutdown operation also applies in Steering modes as described in the AutoShutdown section. An auto-shutdown event will only affect pins that have STRy = 1 .",
    "Figure 31-9. Simplified CWG Block Diagram (Output Steering Modes)\nMODE = ' b000 : Asynchronous\nMODE = ' b001 : Synchronous",
    "31.2.4.1 Synchronous Steering Mode\nIn Synchronous Steering mode (MODE = 'b001 ), the changes to steering selection registers take effect on the next rising edge of CWG Data (see the figure below). In Synchronous Steering mode, the output will always produce a complete waveform.\nImportant: Only the STRx bits are synchronized; the OVRx bits are not synchronized.\nFigure 31-10. Example of Synchronous Steering (MODE = 'b001 )\nRev. 30-000101A\n4/14/2017\nCWGx clock",
    "31.2.4.2 Asynchronous Steering Mode\nIn Asynchronous mode (MODE = 'b000 ), steering takes effect at the end of the instruction cycle that writes to STRx. In Asynchronous Steering mode, the output signal may be an incomplete waveform (see the figure below). This operation may be useful when the user firmware needs to immediately remove a signal from the output pin.\nFigure 31-11. Example of Asynchronous Steering (MODE = 'b000 )",
    "31.2.4.3 Start-Up Considerations\nThe application hardware must use the proper external pull-up and/or pull-down resistors on the CWG output pins. This is required because all I/O pins are forced to high-impedance at Reset.\nThe Polarity Control (POLy) bits allow the user to choose whether the output signals are active-high or active-low.",
    "31.3 Clock Source\nThe clock source is used to drive the dead-band timing circuits. The CWG module allows the following clock sources to be selected:\n\u00b7 FOSC (system clock)\n\u00b7 HFINTOSC\nWhen the HFINTOSC is selected, the HFINTOSC will be kept running during Sleep. Therefore, the CWG modes requiring dead band can operate in Sleep, provided that the CWG data input is also active during Sleep. The clock sources are selected using the CS bit. The system clock F OSC is disabled in Sleep and thus dead-band control cannot be used.",
    "31.4 Selectable Input Sources\nThe CWG generates the output waveforms from the input sources which are selected with the ISM bits. Refer to the CWGxISM register for more details.",
    "31.5.1 CWG Output\nEach CWG output can be routed to a Peripheral Pin Select (PPS) output via the RxyPPS register. Refer to the 'PPS - Peripheral Pin Select Module' chapter for more details.",
    "31.5.2 Polarity Control\nThe polarity of each CWG output can be selected independently. When the output polarity bit is set, the corresponding output is active-high. Clearing the output polarity bit configures the corresponding output as active-low. However, polarity does not affect the override levels. Output polarity is selected with the POLy bits. Auto-shutdown and steering options are unaffected by polarity.",
    "31.6 Dead-Band Control\nThe dead-band control provides nonoverlapping complementary outputs to prevent shoot-through current when the outputs switch. Dead-band operation is employed for Half Bridge and Full Bridge modes. The CWG contains two 6-bit dead-band counters. One is used for the rising edge of the input source control in Half Bridge mode or for reverse direction change dead band in Full Bridge mode. The other is used for the falling edge of the input source control in Half Bridge mode or for forward direction change dead band in Full Bridge mode.\nDead band is timed by counting CWG clock periods from zero up to the value in the rising or falling dead-band counter registers.",
    "31.6.1 Dead-Band Functionality in Half Bridge Mode\nIn Half Bridge mode, the dead-band counters dictate the delay between the falling edge of the normal output and the rising edge of the inverted output. This can be seen in Figure 31-1.",
    "31.6.2 Dead-Band Functionality in Full Bridge Mode\nIn Full Bridge mode, the dead-band counters are used when undergoing a direction change. The MODE[0] bit can be set or cleared while the CWG is running, allowing for changes from Forward to Reverse mode. The CWGxA and CWGxC signals will change immediately upon the first rising input edge following a direction change, but the modulated signals (CWGxB or CWGxD, depending on the direction of the change) will experience a delay dictated by the dead-band counters.",
    "31.7 Rising Edge and Reverse Dead Band\nIn Half Bridge mode, the rising edge dead band delays the turn-on of the CWGxA output after the rising edge of the CWG data input. In Full Bridge mode, the reverse dead-band delay is only inserted when changing directions from Forward mode to Reverse mode, and only the modulated output, CWGxB, is affected.\nThe CWGxDBR register determines the duration of the dead-band interval on the rising edge of the input source signal. This duration is from 0 to 64 periods of the CWG clock. The following figure illustrates different dead-band delays for rising and falling CWG Data events.\nFigure 31-12. Dead-Band Operation, CWGxDBR = 0x01 , CWGxDBF = 0x02\nDead band is always initiated on the edge of the input source signal. A count of zero indicates that no dead band is present.\nIf the input source signal reverses polarity before the dead-band count is completed, then no signal will be seen on the respective output.",
    "31.7 Rising Edge and Reverse Dead Band\nThe CWGxDBR register value is double-buffered. When EN = 0 , the buffer is loaded when CWGxDBR is written. When EN = 1 , the buffer will be loaded at the rising edge following the first falling edge of the CWG Data, after the LD bit is set.",
    "31.8 Falling Edge and Forward Dead Band\nIn Half Bridge mode, the falling edge dead band delays the turn-on of the CWGxB output at the falling edge of the CWG data input. In Full Bridge mode, the forward dead-band delay is only inserted when changing directions from Reverse mode to Forward mode, and only the modulated output, CWGxD, is affected.\nThe CWGxDBF register determines the duration of the dead-band interval on the falling edge of the input source signal. This duration is from 0 to 64 periods of the CWG clock.\nDead-band delay is always initiated on the edge of the input source signal. A count of zero indicates that no dead band is present.\nIf the input source signal reverses polarity before the dead-band count is completed, then no signal will be seen on the respective output.\nFigure 31-13. Dead-Band Operation, CWGxDBR = 0x03 , CWGxDBF = 0x06 , Source Shorter Than Dead Band\nsource shorter than dead band",
    "31.8 Falling Edge and Forward Dead Band\nThe CWGxDBF register value is double-buffered. When EN = 0 , the buffer is loaded when CWGxDBF is written. When EN = 1 , the buffer will be loaded at the rising edge following the first falling edge of the data input after the LD bit is set.",
    "31.9 Dead-Band Jitter\nWhen the rising and falling edges of the input source are asynchronous to the CWG clock, it creates jitter in the dead-band time delay. The maximum jitter is equal to one CWG clock period. Refer to the equations below for more details.\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "DEAD - BAND_MAX DEAD - BAND_MIN +T JITTER Dead-Band Delay Example Calculation\nDBx = 0x0A = 10 F CWG_CLOCK = 8 MHz T JITTER = 8 MHz 1 = 125 ns T DEAD - BAND_MIN",
    "31.10 Auto-Shutdown\n= 125 ns \u00b7 10 = 1.25 \u03bcs T DEAD - BAND_MAX = 1.25 \u03bcs + 0.125 \u03bcs = 1.37 \u03bcs\nAuto-shutdown is a method to immediately override the CWG output levels with specific overrides that allow for safe shutdown of the circuit. The Shutdown state can be either cleared automatically or held until cleared by software. The auto-shutdown circuit is illustrated in the following figure.\nFigure 31-14. CWG Shutdown Block Diagram\n\u7269\n\u00b5\n\u00b6\n\u6f20\n\u5348\n\u4f57\n\u6269\n\u7841\n\u3120\n\u7374\n\u2e20\n\u3130\n\u5348\n\u6269\n\u434b",
    "31.10.1  Shutdown\nThe Shutdown state can be entered by either of the following two methods:\n\u00b7 Software Generated\n\u00b7 External Input",
    "31.10.2  Software Generated Shutdown\nSetting the SHUTDOWN bit will force the CWG into the Shutdown state.\nWhen the auto-restart is disabled, the Shutdown state will persist as long as the SHUTDOWN bit is set.\n\u7269\n\u454e\n\u00b5\n\u00b6\nWhen auto-restart is enabled, the SHUTDOWN bit will clear automatically and resume operation on the next rising edge event. The SHUTDOWN bit indicates when a Shutdown condition exists. The bit may be set or cleared in software or by hardware.",
    "31.10.3  External Input Source\nExternal shutdown inputs provide the fastest way to safely suspend CWG operation in the event of a Fault condition. When any of the selected shutdown inputs goes active, the CWG outputs will immediately go to the selected override levels without software delay. The override levels are selected by the LSBD and LSAC bits. Several input sources can be selected to cause a Shutdown condition. All input sources are active-low. The shutdown input sources are individually enabled by the ASyE bits.\nImportant: Shutdown inputs are level sensitive, not edge sensitive. The Shutdown state cannot be cleared, except by disabling auto-shutdown, as long as the shutdown input level persists.",
    "31.10.4  Pin Override Levels\nThe levels driven to the CWG outputs during an auto-shutdown event are controlled by the LSBD and LSAC bits. The LSBD bits control CWGxB/D output levels, while the LSAC bits control the CWGxA/C output levels.",
    "31.10.5  Auto-Shutdown Interrupts\nWhen an auto-shutdown event occurs, either by software or hardware setting SHUTDOWN, the CWGxIF flag bit of the PIRx register is set.",
    "31.11 Auto-Shutdown Restart\nAfter an auto-shutdown event has occurred, there are two ways to resume operation:\n\u00b7 Software controlled\n\u00b7 Auto-restart\nIn either case, the shutdown source must be cleared before the restart can take place. That is, either the Shutdown condition must be removed, or the corresponding ASyE bit must be cleared.",
    "31.11.1  Software-Controlled Restart\nWhen the REN bit is clear (REN = 0 ), the CWG module must be restarted after an auto-shutdown event through software.\nOnce all auto-shutdown sources are removed, the software must clear the SHUTDOWN bit. Once SHUTDOWN is cleared, the CWG module will resume operation upon the first rising edge of the CWG data input.\nImportant: The SHUTDOWN bit cannot be cleared in software if the AutoShutdown condition is still present.\nCWG - Complementary Waveform Generator Module\nFigure 31-15. Shutdown Functionality, Auto-Restart Disabled (REN = 0 , LSAC = 'b01 , LSBD = 'b01 )",
    "31.11.2  Auto-Restart\nWhen the REN bit is set (REN = 1 ), the CWG module will restart from the Shutdown state automatically.\nOnce all Auto-Shutdown conditions are removed, the hardware will automatically clear the SHUTDOWN bit. Once SHUTDOWN is cleared, the CWG module will resume operation upon the first rising edge of the CWG data input.\nImportant: The SHUTDOWN bit cannot be cleared in software if the AutoShutdown condition is still present.\nFigure 31-16. Shutdown Functionality, Auto-Restart Enabled (REN = 1 , LSAC = 'b01 , LSBD = 'b01 )",
    "31.12 Operation During Sleep\nThe CWG module operates independently from the system clock and will continue to run during Sleep, provided that the clock and input sources selected remain active.\nThe HFINTOSC remains active during Sleep when all the following conditions are met:\n\u00b7 CWG module is enabled\n\u00b7 Input source is active\n\u00b7 HFINTOSC is selected as the clock source, regardless of the system clock source selected.\nIn other words, if the HFINTOSC is simultaneously selected as the system clock and the CWG clock source when the CWG is enabled and the input source is active, then the CPU will go Idle during Sleep, but the HFINTOSC will remain active, and the CWG will continue to operate. This will have a direct effect on the Sleep mode current.",
    "31.13 Configuring the CWG\n1. Ensure that the TRIS control bits corresponding to CWG outputs are set so that all are configured as inputs, ensuring that the outputs are inactive during setup. External hardware must ensure that pin levels are held to safe levels.\n2. Clear the EN bit, if not already cleared.\n3. Configure the MODE bits to set the output operating mode.\n4. Configure the POLy bits to set the output polarities.\n5. Configure the ISM bits to select the data input source.\n6. If a Steering mode is selected, configure the STRy bits to select the desired output on the CWG outputs.\n7. Configure the LSBD and LSAC bits to select the Auto-Shutdown Output Override states (this is necessary even if not using auto-shutdown, because start-up will be from a Shutdown state).\n8. If auto-restart is desired, set the REN bit.\n9. If auto-shutdown is desired, configure the ASyE bits to select the shutdown source.",
    "31.13 Configuring the CWG\n10. Set the desired rising and falling dead-band times with the CWGxDBR and CWGxDBF registers.\n11. Select the clock source with the CS bit.\n12. Set the EN bit to enable the module.\n13. Clear the TRIS bits that correspond to the CWG outputs to set them as outputs.\nIf auto-restart is to be used, set the REN bit and the SHUTDOWN bit will be cleared automatically. Otherwise, clear the SHUTDOWN bit in software to start the CWG.",
    "31.14 Register Definitions: CWG Control\nLong bit name prefixes for the CWG peripherals are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 31-1. CWG Long Bit Name Prefixes\n\nCWG1, Bit Name Prefix = CWG1",
    "31.14.1  CWGxCON0\nName:\nCWGxCON0\nAddress:\n0x03C0\nCWG Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = LD. , 3 = . , 4 = . , 5 = . , 6 = MODE[2:0]. , 7 = MODE[2:0]. , 8 = MODE[2:0]. Access, 1 = R/W. Access, 2 = R/W/HC. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CWG Enable\n1, Description = Module is enabled. 0, Description = Module is disabled",
    "Bit 6 - LD  CWG1 Load Buffers (1)\n1, Description = Dead-band count buffers to be loaded on CWG data rising edge, following first falling edge after this bit is set. 0, Description = Buffers remain unchanged",
    "Bits 2:0 - MODE[2:0] CWG Mode\n111, Description = Reserved. 110, Description = Reserved. 101, Description = CWG outputs operate in Push-Pull mode. 100, Description = CWG outputs operate in Half Bridge mode. 011, Description = CWG outputs operate in Reverse Full Bridge mode. 010, Description = CWG outputs operate in Forward Full Bridge mode. 001, Description = CWG outputs operate in Synchronous Steering mode. 000, Description = CWG outputs operate in Asynchronous Steering mode",
    "Note:\n- 1. This bit can only be set after EN = 1 ; it cannot be set in the same cycle when EN is set.",
    "31.14.2  CWGxCON1\nName: Address:\nCWGxCON1\n0x03C1\nCWG Control Register 1\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2 1. Bit, 6 = 0. , 1 = . , 2 = IN. , 3 = POLD. , 4 = POLC. , 5 = POLB. , 6 = POLA. Access, 1 = . Access, 2 = R. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bit 5 - IN CWG Input Value (read-only)\n1, Description = CWG data input is a logic ' 1 '. 0, Description = CWG data input is a logic ' 0 '",
    "Bits 0, 1, 2, 3 - POLy CWG Output 'y' Polarity\n1, Description = Signal output is inverted polarity. 0, Description = Signal output is normal polarity",
    "31.14.3  CWGxCLK\nName:\nCWGxCLK\nAddress:\n0x03BC\nCWG Clock Input Selection Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nCS\nAccess Reset\nR/W\n0",
    "Bit 0 - CS CWG Clock Source Selection Select\n1, Description = HFINTOSC (remains operating during Sleep). 0, Description = F OSC",
    "31.14.4  CWGxISM\nName: Address:\nCWGxISM\n0x03BD\nCWGx Input Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = ISM[3:0]. , 6 = ISM[3:0]. , 7 = ISM[3:0]. , 8 = ISM[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - ISM[3:0] CWG Data Input Source Select\n1111, Input Selection CWG1 = CLC4_OUT. 1110, Input Selection CWG1 = CLC3_OUT. 1101, Input Selection CWG1 = CLC2_OUT. 1100, Input Selection CWG1 = CLC1_OUT. 1011, Input Selection CWG1 = DSM1_OUT. 1010, Input Selection CWG1 = CMP2_OUT. 1001, Input Selection CWG1 = CMP1_OUT. 1000, Input Selection CWG1 = NCO1_OUT. 0111, Input Selection CWG1 = PWM3S1P2_OUT. 0110, Input Selection CWG1 = PWM3S1P1_OUT. 0101, Input Selection CWG1 = PWM2S1P2_OUT. 0100, Input Selection CWG1 = PWM2S1P1_OUT. 0011, Input Selection CWG1 = PWM1S1P2_OUT. 0010, Input Selection CWG1 = PWM1S1P1_OUT.",
    "Bits 3:0 - ISM[3:0] CWG Data Input Source Select\n0001, Input Selection CWG1 = CCP1_OUT. 0000, Input Selection CWG1 = Pin selected by CWG1PPS",
    "31.14.5  CWGxSTR\nName: Address:\nCWGxSTR 0x03C4",
    "CWG Steering Control Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OVRD. , 2 = OVRC. , 3 = OVRB. , 4 = OVRA. , 5 = STRD. , 6 = STRC. , 7 = STRB. , 8 = STRA. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 4, 5, 6, 7 - OVRy Steering Data OVR'y'\nx, Condition = STRy = 1. x, Description = CWGx'y' output has the CWG data input waveform with polarity control from POLy bit. 1, Condition = STRy = 0 and POLy = x. 1, Description = CWGx'y' output is high. 0, Condition = STRy = 0 and POLy = x. 0, Description = CWGx'y' output is low",
    "Bits 0, 1, 2, 3 - STRy  STR'y' Steering Enable (2)\n1, Description = CWGx'y' output has the CWG data input waveform with polarity control from the POLy bit. 0, Description = CWGx'y' output is assigned to value of the OVRy bit",
    "Notes:\n1. The bits in this register apply only when MODE = 'b00x (CWGxCON0, Steering modes).\n2. This bit is double-buffered when MODE = 'b001 .",
    "31.14.6  CWGxAS0\nName: Address:\nCWGxAS0\n0x03C2",
    "CWG Auto-Shutdown Control Register 0\nAccess, 7.SHUTDOWN = R/W/HS/HC. Access, 6.REN = R/W. Access, 5.LSBD[1:0] = R/W. Access, 4.LSBD[1:0] = R/W. Access, 3.LSAC[1:0] = R/W. Access, 2.LSAC[1:0] = R/W. Access, 1. = . Access, 0. = . Reset, 7.SHUTDOWN = 0. Reset, 6.REN = 0. Reset, 5.LSBD[1:0] = 0. Reset, 4.LSBD[1:0] = 1. Reset, 3.LSAC[1:0] = 0. Reset, 2.LSAC[1:0] = 1. Reset, 1. = . Reset, 0. = ",
    "Bit 7 - SHUTDOWN  Auto-Shutdown Event Status (1,2)\n1, Description = An Auto-Shutdown state is in effect. 0, Description = No auto-shutdown event has occurred",
    "Bit 6 - REN Auto-Restart Enable\n1, Description = Auto-restart is enabled. 0, Description = Auto-restart is disabled",
    "Bits 5:4 - LSBD[1:0] CWGxB and CWGxD Auto-Shutdown State Control\n11, Description = A logic ' 1 ' is placed on CWGxB/D when an auto-shutdown event occurs. 10, Description = A logic ' 0 ' is placed on CWGxB/D when an auto-shutdown event occurs. 01, Description = Pin is tri-stated on CWGxB/D when an auto-shutdown event occurs. 00, Description = The Inactive state of the pin, including polarity, is placed on CWGxB/D after the required dead-band interval when an auto-shutdown event occurs",
    "Bits 3:2 - LSAC[1:0] CWGxA and CWGxC Auto-Shutdown State Control\n11, Description = A logic ' 1 ' is placed on CWGxA/C when an auto-shutdown event occurs. 10, Description = A logic ' 0 ' is placed on CWGxA/C when an auto-shutdown event occurs. 01, Description = Pin is tri-stated on CWGxA/C when an auto-shutdown event occurs. 00, Description = The Inactive state of the pin, including polarity, is placed on CWGxA/C after the required dead-band interval when an auto-shutdown event occurs",
    "Notes:\n1. This bit may be written while EN = 0 , to place the outputs into the shutdown configuration.\n2. The outputs will remain in Auto-Shutdown state until the next rising edge of the CWG data input after this bit is cleared.",
    "31.14.7  CWGxAS1\nName: Address:\nCWGxAS1 0x03C3\nCWG Auto-Shutdown Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = AS7E. , 2 = AS6E. , 3 = AS5E. , 4 = AS4E. , 5 = AS3E. , 6 = AS2E. , 7 = AS1E. , 8 = AS0E. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ASyE  CWG Auto-Shutdown Source Enable (1,2)\nAS7E, Auto-Shutdown Source CWG1 = Reserved. AS6E, Auto-Shutdown Source CWG1 = CLC4_OUT. AS5E, Auto-Shutdown Source CWG1 = CLC2_OUT. AS4E, Auto-Shutdown Source CWG1 = CMP2_OUT. AS3E, Auto-Shutdown Source CWG1 = CMP1_OUT. AS2E, Auto-Shutdown Source CWG1 = TMR4_Postscaler_OUT (Inverted). AS1E, Auto-Shutdown Source CWG1 = TMR2_Postscaler_OUT (Inverted). AS0E, Auto-Shutdown Source CWG1 = Pin selected by CWG1PPS",
    "Notes:\n1. This bit may be written while EN = 0 , to place the outputs into the shutdown configuration.\n2. The outputs will remain in Auto-Shutdown state until the next rising edge of the CWG data input after this bit is cleared.",
    "31.14.8  CWGxDBR\nName: Address:\nCWGxDBR\n0x03BE\nCWG Rising Dead-Band Count Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = DBR[5:0]. , 3 = DBR[5:0]. , 4 = DBR[5:0]. , 5 = DBR[5:0]. , 6 = DBR[5:0]. , 7 = DBR[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "31.14.8  CWGxDBR\nBits 5:0 - DBR[5:0] CWG Rising Edge-Triggered Dead-Band Count\nAll Other Resets = uuuuuu\nReset States: POR/BOR = xxxxxx\nn, Description = Dead band is active no less than n and no more than n+1 CWG clock periods after the rising edge. 0, Description = 0 CWG clock periods. Dead-band generation is bypassed.",
    "31.14.9  CWGxDBF\nName: Address:\nCWGxDBF\n0x03BF\nCWG Falling Dead-Band Count Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = DBF[5:0]. , 3 = DBF[5:0]. , 4 = DBF[5:0]. , 5 = DBF[5:0]. , 6 = DBF[5:0]. , 7 = DBF[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "Bits 5:0 - DBF[5:0] CWG Falling Edge-Triggered Dead-Band Count\nReset States: POR/BOR = xxxxxx\nn, Description = Dead band is active no less than n and no more than n+1 CWG clock periods after the falling edge. 0, Description = 0 CWG clock periods. Dead-band generation is bypassed.\nAll Other Resets = uuuuuu",
    "31.15 Register Summary - CWG\n0x00 ... 0x03BB, Name = Reserved. 0x00 ... 0x03BB, Bit Pos. = . 0x00 ... 0x03BB, 7 = . 0x00 ... 0x03BB, 6 = . 0x00 ... 0x03BB, 5 = . 0x00 ... 0x03BB, 4 = . 0x00 ... 0x03BB, 3 = . 0x00 ... 0x03BB, 2 = . 0x00 ... 0x03BB, 1 = . 0x00 ... 0x03BB, 0 = . 0x03BC, Name = CWG1CLK. 0x03BC, Bit Pos. = 7:0. 0x03BC, 7 = . 0x03BC, 6 = . 0x03BC, 5 = . 0x03BC, 4 = . 0x03BC, 3 = . 0x03BC, 2 = . 0x03BC, 1 = .",
    "31.15 Register Summary - CWG\n0x03BC, 0 = CS. 0x03BD, Name = CWG1ISM. 0x03BD, Bit Pos. = 7:0. 0x03BD, 7 = . 0x03BD, 6 = . 0x03BD, 5 = . 0x03BD, 4 = . 0x03BD, 3 = ISM[3:0]. 0x03BD, 2 = ISM[3:0]. 0x03BD, 1 = ISM[3:0]. 0x03BD, 0 = ISM[3:0]. 0x03BE, Name = CWG1DBR. 0x03BE, Bit Pos. = 7:0. 0x03BE, 7 = . 0x03BE, 6 = . 0x03BE, 5 = . 0x03BE, 4 = . 0x03BE, 3 = DBR[5:0]. 0x03BE, 2 = DBR[5:0].",
    "31.15 Register Summary - CWG\n0x03BE, 1 = . 0x03BE, 0 = . 0x03BF, Name = CWG1DBF. 0x03BF, Bit Pos. = 7:0. 0x03BF, 7 = . 0x03BF, 6 = . 0x03BF, 5 = . 0x03BF, 4 = . 0x03BF, 3 = DBF[5:0]. 0x03BF, 2 = DBF[5:0]. 0x03BF, 1 = . 0x03BF, 0 = . 0x03C0, Name = CWG1CON0. 0x03C0, Bit Pos. = 7:0. 0x03C0, 7 = EN. 0x03C0, 6 = LD. 0x03C0, 5 = . 0x03C0, 4 = . 0x03C0, 3 = . 0x03C0, 2 = MODE[2:0]. 0x03C0, 1 = MODE[2:0].",
    "31.15 Register Summary - CWG\n0x03C0, 0 = MODE[2:0]. 0x03C1, Name = CWG1CON1. 0x03C1, Bit Pos. = 7:0. 0x03C1, 7 = . 0x03C1, 6 = . 0x03C1, 5 = IN. 0x03C1, 4 = . 0x03C1, 3 = POLD. 0x03C1, 2 = POLC. 0x03C1, 1 = POLB. 0x03C1, 0 = POLA. 0x03C2, Name = CWG1AS0. 0x03C2, Bit Pos. = 7:0. 0x03C2, 7 = SHUTDOWN. 0x03C2, 6 = REN. 0x03C2, 5 = LSBD[1:0]. 0x03C2, 4 = LSBD[1:0]. 0x03C2, 3 = LSAC[1:0].",
    "31.15 Register Summary - CWG\n0x03C2, 2 = LSAC[1:0]. 0x03C2, 1 = . 0x03C2, 0 = . 0x03C3, Name = CWG1AS1. 0x03C3, Bit Pos. = 7:0. 0x03C3, 7 = AS7E. 0x03C3, 6 = AS6E. 0x03C3, 5 = AS5E. 0x03C3, 4 = AS4E. 0x03C3, 3 = AS3E. 0x03C3, 2 = AS2E. 0x03C3, 1 = AS1E. 0x03C3, 0 = AS0E. 0x03C4, Name = CWG1STR. 0x03C4, Bit Pos. = 7:0. 0x03C4, 7 = OVRD. 0x03C4, 6 = OVRC. 0x03C4, 5 = OVRB.",
    "31.15 Register Summary - CWG\n0x03C4, 4 = OVRA. 0x03C4, 3 = STRD. 0x03C4, 2 = STRC. 0x03C4, 1 = STRB. 0x03C4, 0 = STRA",
    "32. NCO - Numerically Controlled Oscillator Module\nThe Numerically Controlled Oscillator (NCO) module is a timer that uses overflow from the addition of an increment value to divide the input frequency. The advantage of the addition method over a simple counter driven timer is that the output frequency resolution does not vary with the divider value. The NCO is most useful for applications that require frequency accuracy and fine resolution at a fixed duty cycle.\nFeatures of the NCO include:\n\u00b7 20-Bit Increment Function\n\u00b7 Fixed Duty Cycle (FDC) mode\n\u00b7 Pulse Frequency (PF) mode\n\u00b7 Output Pulse-Width Control\n\u00b7 Multiple Clock Input Sources\n\u00b7 Output Polarity Control\n\u00b7 Interrupt Capability\nThe following figure is a simplified block diagram of the NCO module.\nFigure 32-1. Numerically Controlled Oscillator Module Simplified Block Diagram",
    "32. NCO - Numerically Controlled Oscillator Module\nNote 1: The increment registers are double-buffered to allow for value changes to be made without first disabling the NCO module. The full increment value is loaded into the buffer registers on the second rising edge of the NCOx_clk signal that occurs immediately after a write to the NCOxINCL register. The buffers are not useraccessible and are shown here for reference.",
    "32.1 NCO Operation\nThe NCO operates by repeatedly adding a fixed value to an accumulator. Additions occur at the input clock rate. The accumulator will overflow with a carry periodically, which is the raw NCO output (NCO_overflow). This effectively reduces the input clock by the ratio of the addition value to the maximum accumulator value. See the following equation.\n<!-- formula-not-decoded -->\nIt is apparent from the equation that there is a linear relationship between the increment value and the overflow frequency. This linear advantage over divide-by-n timers comes at the cost of output jitter. However, the jitter is always plus or minus one NCO clock period that occurs periodically, depending on the division remainder. For example, there is no jitter when there is no division remainder, whereas a division remainder of 0.5 will result in a jitter frequency one half of the overflow frequency.",
    "32.1.1 NCO Clock Sources\nThe NCO can be clocked from a variety of sources including the system clock, internal timers, and other peripherals. The NCO clock source is selected by configuring the CKS bits.",
    "32.1.2 Accumulator\nThe accumulator is a 20-bit register. Read and write access to the accumulator is available through three registers:\n\u00b7 NCOxACCL\n\u00b7 NCOxACCH\n\u00b7 NCOxACCU",
    "32.1.3 Adder\nThe NCO adder is a full adder, which operates synchronously from the source clock. The addition of the previous result and the increment value replaces the accumulator value on the rising edge of each input clock.",
    "32.1.4 Increment Registers\nThe increment value is stored in three registers making up a 20-bit word. In order of LSB to MSB, they are:\n\u00b7 NCOxINCL\n\u00b7 NCOxINCH\n\u00b7 NCOxINCU\nThe increment registers are readable and writable and are double-buffered to allow value changes to be made without first disabling the NCO module.\nWhen the NCO module is enabled, the NCOxINCU and NCOxINCH registers will be written first, followed by the NCOxINCL register. Writing to the NCOxINCL register initiates the increment buffer registers to be loaded simultaneously on the second rising edge of the NCO_clk signal.\nWhen the NCO module is disabled, the increment buffers are loaded immediately after a write to the increment registers.\nImportant: The increment buffer registers are not user-accessible.",
    "32.2 Fixed Duty Cycle Mode\nIn Fixed Duty Cycle (FDC) mode, every time the accumulator overflows, the output is toggled. This provides a 50% duty cycle at half the F OVERFLOW frequency, provided that the increment value remains constant. For more information, see the figure below.\nThe FDC mode is selected by clearing the PFM bit.\nFigure 32-2. FDC Output Mode Timing Diagram\n001",
    "32.3 Pulse Frequency Mode\nIn Pulse Frequency (PF) mode, the output becomes active on the rising clock edge immediately following the overflow event and goes inactive 1 to 128 clock periods later, determined by the PWS bits. This provides a pulsed output at the F OVERFLOW frequency. For more information, refer to the figure above.\nImportant: When the selected pulse width is greater than the accumulator overflow time frame, then the NCO output does not toggle.\nThe level of the Active and Inactive states is determined by the POL bit.\nPF mode is selected by setting the PFM bit.",
    "32.4 Output Polarity Control\nThe last stage in the NCO module is the output polarity. The POL bit selects the output polarity. The active level of the Pulse Frequency mode is high true when the POL bit is cleared.\nChanging the polarity while the interrupts are enabled will cause an interrupt for the resulting output transition.\nThe NCO output signal (NCOx_out) is available by internal routing to several other peripherals.",
    "32.5 Interrupts\nWhen the accumulator overflows, the NCO Interrupt Flag bit, NCOxIF, in the associated PIR register is set. To enable interrupt service on this event, the following bits must be set:\n\u00b7 EN bit\n\u00b7 NCOxIE bit in the associated PIE register\n\u00b7 Peripheral and Global Interrupt Enable bits\nThe interrupt must be cleared by software by clearing the NCOxIF bit in the Interrupt Service Routine.",
    "32.6 Effects of a Reset\nAll of the NCO registers are cleared to zero as the result of any Reset.",
    "32.7 Operation in Sleep\nThe NCO module operates independently from the system clock and will continue to run during Sleep, provided that the clock source selected remains active.\nThe HFINTOSC remains active during Sleep when the NCO module is enabled and the HFINTOSC is selected as the clock source, regardless of the system clock source selected.\nIn other words, if the HFINTOSC is simultaneously selected as the system clock and the NCO clock source, when the NCO is enabled, the CPU will go Idle during Sleep, but the NCO will continue to operate and the HFINTOSC will remain active.\nWith a clock running, it will have a direct effect on the Sleep mode current.",
    "32.8 Register Definitions: NCO\nLong bit name prefixes for the NCO peripherals are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 32-1. NCO Long Bit Name Prefixes\n\nNCO1, Bit Name Prefix = NCO1",
    "32.8.1 NCOxCON\nName:\nNCOxCON\nAddress:\n0x0446\nNCO Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = POL. , 5 = . , 6 = . , 7 = . , 8 = PFM. Access, 1 = R/W. Access, 2 = . Access, 3 = R. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - EN NCO Enable\n1, Description = NCO module is enabled. 0, Description = NCO module is disabled",
    "Bit 5 - OUT NCO Output\nDisplays the current logic level of the NCO module output.",
    "Bit 4 - POL NCO Polarity\n1, Description = NCO output signal is inverted. 0, Description = NCO output signal is not inverted",
    "Bit 0 - PFM NCO Pulse Frequency Mode\n1, Description = NCO operates in Pulse Frequency mode. Output frequency is F OVERFLOW .. 0, Description = NCO operates in Fixed Duty Cycle mode. Output frequency is F OVERFLOW divided by 2.",
    "32.8.2 NCOxCLK\nName: Address:\nNCOxCLK 0x0447",
    "NCO Input Clock Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWS[2:0]. , 2 = PWS[2:0]. , 3 = PWS[2:0]. , 4 = . , 5 = CKS[3:0]. , 6 = CKS[3:0]. , 7 = CKS[3:0]. , 8 = CKS[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:5 - PWS[2:0]  NCO Output Pulse-Width Select (1)\n111, Description = NCO output is active for 128 input clock periods. 110, Description = NCO output is active for 64 input clock periods. 101, Description = NCO output is active for 32 input clock periods. 100, Description = NCO output is active for 16 input clock periods. 011, Description = NCO output is active for 8 input clock periods. 010, Description = NCO output is active for 4 input clock periods. 001, Description = NCO output is active for 2 input clock periods. 000, Description = NCO output is active for 1 input clock periods",
    "Bits 3:0 - CKS[3:0]  NCO Clock Source Select\n1111 - 1110, Clock Source.NCO1 = Reserved. 1111 - 1110, Active in Sleep. = -. 1101, Clock Source.NCO1 = CLC4_OUT. 1101, Active in Sleep. = No. 1100, Clock Source.NCO1 = CLC3_out. 1100, Active in Sleep. = No. 1011, Clock Source.NCO1 = CLC2_OUT. 1011, Active in Sleep. = No. 1010, Clock Source.NCO1 = CLC1_OUT. 1010, Active in Sleep. = No. 1001, Clock Source.NCO1 = TMR4_OUT. 1001, Active in Sleep. = No. 1000, Clock Source.NCO1 = TMR2_OUT. 1000, Active in Sleep. = No. 0111, Clock Source.NCO1 = CLKREF. 0111, Active in Sleep. = No. 0110, Clock Source.NCO1 = EXTOSC. 0110, Active in Sleep. = Yes. 0101, Clock Source.NCO1",
    "Bits 3:0 - CKS[3:0]  NCO Clock Source Select\n= SOSC. 0101, Active in Sleep. = Yes. 0100, Clock Source.NCO1 = MFINTOSC. 0100, Active in Sleep. = Yes. 0011, Clock Source.NCO1 = MFINTOSC. 0011, Active in Sleep. = Yes. 0010, Clock Source.NCO1 = LFINTOSC. 0010, Active in Sleep. = Yes. 0001, Clock Source.NCO1 = HFINTOSC. 0001, Active in Sleep. = Yes. 0000, Clock Source.NCO1 = F OSC. 0000, Active in Sleep. = No",
    "Note:\n- 1. PWS applies only when operating in Pulse Frequency mode.",
    "32.8.3 NCOxACC\nName:\nNCOxACC 0x0440\nAddress:\nNCO Accumulator Register",
    "32.8.3 NCOxACC\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20. = . Access, 19.ACC[19:16] = R/W. Access, 18.ACC[19:16] = R/W. Access, 17.ACC[19:16] = R/W. Access, 16.ACC[19:16] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20. = . Reset, 19.ACC[19:16] = 0. Reset, 18.ACC[19:16] = 0. Reset, 17.ACC[19:16] = 0. Reset, 16.ACC[19:16] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20. = 12. Bit, 19.ACC[19:16] = 11. Bit, 18.ACC[19:16] = 10. Bit, 17.ACC[19:16] = 9. Bit, 16.ACC[19:16] = 8. , 23. =",
    "32.8.3 NCOxACC\nACC[15:8]. , 22. = ACC[15:8]. , 21. = ACC[15:8]. , 20. = ACC[15:8]. , 19.ACC[19:16] = ACC[15:8]. , 18.ACC[19:16] = ACC[15:8]. , 17.ACC[19:16] = ACC[15:8]. , 16.ACC[19:16] = ACC[15:8]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20. = R/W. Access, 19.ACC[19:16] = R/W. Access, 18.ACC[19:16] = R/W. Access, 17.ACC[19:16] = R/W. Access, 16.ACC[19:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20. = 0. Reset, 19.ACC[19:16] = 0. Reset,",
    "32.8.3 NCOxACC\n18.ACC[19:16] = 0. Reset, 17.ACC[19:16] = 0. Reset, 16.ACC[19:16] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20. = 4. Bit, 19.ACC[19:16] = 3. Bit, 18.ACC[19:16] = 2. Bit, 17.ACC[19:16] = 1. Bit, 16.ACC[19:16] = 0. , 23. = ACC[7:0]. , 22. = ACC[7:0]. , 21. = ACC[7:0]. , 20. = ACC[7:0]. , 19.ACC[19:16] = ACC[7:0]. , 18.ACC[19:16] = ACC[7:0]. , 17.ACC[19:16] = ACC[7:0]. , 16.ACC[19:16] = ACC[7:0]. Access, 23. = R/W. Access, 22. = R/W.",
    "32.8.3 NCOxACC\nAccess, 21. = R/W. Access, 20. = R/W. Access, 19.ACC[19:16] = R/W. Access, 18.ACC[19:16] = R/W. Access, 17.ACC[19:16] = R/W. Access, 16.ACC[19:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20. = 0. Reset, 19.ACC[19:16] = 0. Reset, 18.ACC[19:16] = 0. Reset, 17.ACC[19:16] = 0. Reset, 16.ACC[19:16] = 0",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-NCOxACCU: Accesses the upper byte ACC[23:16]\n-NCOxACCH: Accesses the high byte ACC[15:8]\n-NCOxACCL: Accesses the low byte ACC[7:0].\n2. The accumulator spans registers NCOxACCU:NCOxACCH:NCOxACCL. The 24 bits are reserved, but not all are used. This register updates in real-time, asynchronously to the CPU; there is no provision to ensure atomic access to this 24-bit space using an 8-bit bus. Writing to this register while the module is operating will produce undefined results.",
    "32.8.4 NCOxINC\nName: Address:\nNCOxINC 0x0443\nNCO Increment Register",
    "32.8.4 NCOxINC\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20. = . Access, 19.INC[19:16] = R/W. Access, 18.INC[19:16] = R/W. Access, 17.INC[19:16] = R/W. Access, 16.INC[19:16] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20. = . Reset, 19.INC[19:16] = 0. Reset, 18.INC[19:16] = 0. Reset, 17.INC[19:16] = 0. Reset, 16.INC[19:16] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20. = 12. Bit, 19.INC[19:16] = 11. Bit, 18.INC[19:16] = 10. Bit, 17.INC[19:16] = 9. Bit, 16.INC[19:16] = 8. , 23. =",
    "32.8.4 NCOxINC\nINC[15:8]. , 22. = INC[15:8]. , 21. = INC[15:8]. , 20. = INC[15:8]. , 19.INC[19:16] = INC[15:8]. , 18.INC[19:16] = INC[15:8]. , 17.INC[19:16] = INC[15:8]. , 16.INC[19:16] = INC[15:8]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20. = R/W. Access, 19.INC[19:16] = R/W. Access, 18.INC[19:16] = R/W. Access, 17.INC[19:16] = R/W. Access, 16.INC[19:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20. = 0. Reset, 19.INC[19:16] = 0. Reset,",
    "32.8.4 NCOxINC\n18.INC[19:16] = 0. Reset, 17.INC[19:16] = 0. Reset, 16.INC[19:16] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20. = 4. Bit, 19.INC[19:16] = 3. Bit, 18.INC[19:16] = 2. Bit, 17.INC[19:16] = 1. Bit, 16.INC[19:16] = 0. , 23. = INC[7:0]. , 22. = INC[7:0]. , 21. = INC[7:0]. , 20. = INC[7:0]. , 19.INC[19:16] = INC[7:0]. , 18.INC[19:16] = INC[7:0]. , 17.INC[19:16] = INC[7:0]. , 16.INC[19:16] = INC[7:0]. Access, 23. = R/W. Access, 22. = R/W.",
    "32.8.4 NCOxINC\nAccess, 21. = R/W. Access, 20. = R/W. Access, 19.INC[19:16] = R/W. Access, 18.INC[19:16] = R/W. Access, 17.INC[19:16] = R/W. Access, 16.INC[19:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20. = 0. Reset, 19.INC[19:16] = 0. Reset, 18.INC[19:16] = 0. Reset, 17.INC[19:16] = 0. Reset, 16.INC[19:16] = 1\nBits 19:0 - INC[19:0] Value by which the NCOxACC is increased by each NCO clock",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-NCOxINCU: Accesses the upper byte INC[19:16]\n-NCOxINCH: Accesses the high byte INC[15:8]\n-NCOxINCL: Accesses the low byte INC[7:0].\n2. The logical increment spans NCOxINCU:NCOxINCH:NCOxINCL.\n3. NCOxINC is double-buffered as INCBUF:\n-INCBUF is updated on the next falling edge of NCOxCLK after writing to NCOxINCL\n-NCOxINCU and NCOxINCH will be written prior to writing NCOxINCL.",
    "32.9 Register Summary - NCO\n0x00 ... 0x043F, Name = Reserved. 0x00 ... 0x043F, Bit Pos. = . 0x00 ... 0x043F, 7 = . 0x00 ... 0x043F, 6 = . 0x00 ... 0x043F, 5 = . 0x00 ... 0x043F, 4 = . 0x00 ... 0x043F, 2 = . 0x00 ... 0x043F, 1 = . 0x00 ... 0x043F, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = ACC[7:0]. , 2 = . , 1 = . , 0 = . 0x0440, Name = NCO1ACC. 0x0440, Bit Pos. = 15:8. 0x0440, 7 = . 0x0440, 6 = . 0x0440, 5 = .",
    "32.9 Register Summary - NCO\n0x0440, 4 = ACC[15:8]. 0x0440, 2 = . 0x0440, 1 = . 0x0440, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = ACC[19:16]. , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = INC[7:0]. , 2 = . , 1 = . , 0 = . 0x0443, Name = NCO1INC. 0x0443, Bit Pos. = 15:8. 0x0443, 7 = . 0x0443, 6 = . 0x0443, 5 = . 0x0443, 4 = INC[15:8]. 0x0443, 2 = . 0x0443, 1 = . 0x0443, 0 = . , Name = . , Bit Pos. =",
    "32.9 Register Summary - NCO\n23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = INC[19:16]. , 1 = . , 0 = . 0x0446, Name = NCO1CON. 0x0446, Bit Pos. = 7:0. 0x0446, 7 = EN. 0x0446, 6 = . 0x0446, 5 = OUT. 0x0446, 4 = POL. 0x0446, 2 = . 0x0446, 1 = . 0x0446, 0 = PFM. 0x0447, Name = NCO1CLK. 0x0447, Bit Pos. = 7:0. 0x0447, 7 = PWS[2:0]. 0x0447, 6 = PWS[2:0]. 0x0447, 5 = . 0x0447, 4 = . 0x0447, 2 = CKS[3:0]. 0x0447, 1 = . 0x0447, 0 = ",
    "33. DSM - Data Signal Modulator Module\nThe Data Signal Modulator (DSM) is a peripheral that allows the user to mix a data stream, also known as a modulator signal, with a carrier signal to produce a modulated output. Both the carrier and the modulator signals are supplied to the DSM module either internally from the output of a peripheral or externally through an input pin. The modulated output signal is generated by performing a logical 'AND' operation of both the carrier and modulator signals and then provided to the DSM_out pin.\nThe carrier signal is comprised of two distinct and separate signals. A Carrier High (CARH) signal and a Carrier Low (CARL) signal. During the time in which the modulator (MOD) signal is in a Logic High state, the DSM mixes the CARH signal with the modulator signal. When the modulator signal is in a Logic Low state, the DSM mixes the CARL signal with the modulator signal.\nUsing this method, the DSM can generate the following types of key modulation schemes:\n\u00b7 Frequency Shift Keying (FSK)\n\u00b7 Phase-Shift Keying (PSK)\n\u00b7 ON-OFF Keying (OOK)",
    "33. DSM - Data Signal Modulator Module\nAdditionally, the following features are provided within the DSM module:\n\u00b7 Carrier Synchronization\n\u00b7 Carrier Source Polarity Select\n\u00b7 Programmable Modulator Data\n\u00b7 Modulated Output Polarity Select\n\u00b7 Peripheral Module Disable, which provides the ability to place the DSM module in the lowest power consumption mode\nThe figure below shows a simplified block diagram of the data signal modulator peripheral.\nFigure 33-1. Simplified Block Diagram of the Data Signal Modulator\n\u4348\n\u5369\n\u5359\n\u6565\n\u7465\n\u6567\n\u504f",
    "33.1 DSM Operation\nThe DSM module is enabled by setting the EN bit. Clearing the EN bit disables the output of the module but retains the carrier and source signal selections. The module will resume operation when the EN bit is set again. The output of the DSM module can be rerouted to several pins using the PPS output source selection register. When the EN bit is cleared the output pin is held low.",
    "33.1.1 Modulator Signal Sources\nThe modulator signal can be supplied from several different sources and is selected by configuring the MS bits.",
    "33.1.2 Carrier Signal Sources\nThe carrier high signal and carrier low signal can be supplied from several different sources and is selected by the CH bits and CL bits, respectively.\n\u7465\n\u6567\n\u7465\n\u6567\n\u6565\n\u4d53\n\u434c\n\u504f\n\u5359\n\u5359\n\u5359\n\u504f\n\u7950\n\u5053\n\u5050",
    "33.2 Carrier Synchronization\nDuring the time when the DSM switches between carrier high and carrier low signal sources, the carrier data in the modulated output signal can become truncated. To prevent this, the carrier signal can be synchronized to the modulator signal. When synchronization is enabled, the carrier pulse that is being mixed at the time of the transition is allowed to transition low before the DSM switches over to the next carrier source.\nSynchronization is enabled separately for the carrier high and carrier low signal sources. Synchronization for the carrier high signal is enabled by setting the CHSYNC bit. Synchronization for the carrier low signal is enabled by setting the CLSYNC bit. The figures below show the timing diagrams of using various synchronization methods.\nFigure 33-2. On-Off Keying (OOK) Synchronization\nFigure 33-3. No Synchronization (CHSYNC = 0 , CLSYNC = 0 )\n\u7269\n\u6172\n\u6869\n\u6768\n\u7269\n\u6172\n\u6c6f\n\u4163\n\u6520\n\u6172\n\u7269\n\u6572\n\u5374\n\u6174\n\u6f64\n\u6c61\n\u6f72\n\u534d\n\u6f75\n\u6172\n\u7269\n\u6572\n\u6768\n\u6869\n\u7269\n\u6172\n\u6c6f\n\u7269\n\u6172\n\u6768\n\u6869\n\u7269\n\u6172\n\u6f77",
    "Figure 33-4. Carrier High Synchronization (CHSYNC = 1 , CLSYNC = 0 )\n\u6965\n\u7272\n\u6967\n\u7269\n\u6172\n\u6c6f\n\u4163\n\u6520\n\u6172\n\u7269\n\u6572\n\u5374\n\u6174\n\u6f75\n\u6965\n\u6172\n\u6967\n\u7272\n\u6965\n\u6c6f\nFigure 33-5. Carrier Low Synchronization (CHSYNC = 0 , CLSYNC = 1 )\n\u6965\n\u7272\n\u6869\n\u6768\n\u6965\n\u6172\n\u6c6f\n\u534d\n\u6f75\n\u6965\n\u7272\n\u6172\n\u7269\n\u6869\n\u6768\n\u6172\n\u7269\n\u6c6f\nFigure 33-6. Full Synchronization (CHSYNC = 1 , CLSYNC = 1 )\n\u6965\n\u7272\n\u6967\n\u7269\n\u6172\n\u6c6f\n\u4163\n\u6520\n\u6172\n\u7269\n\u6572\n\u5374\n\u6174\n\u534d\n\u6f75\n\u7269\n\u6172\n\u6869\n\u6768\n\u7272\n\u6965\n\u6c6f\n\u7272\n\u6965\n\u6967\n\u434c",
    "33.3 Carrier Source Polarity Select\nThe signal provided from any selected input source for the carrier high and carrier low signals can be inverted. Inverting the signal for the carrier high and low source is enabled by setting the CHPOL bit and the CLPOL bit, respectively.",
    "33.4 Programmable Modulator Data\nThe BIT control bit can used to generate the modulation signal. This gives the user the ability to provide software driven modulation.",
    "33.5 Modulated Output Polarity\nThe modulated output signal provided on the DSM_out pin can also be inverted. Inverting the modulated output signal is enabled by setting the OPOL bit.\n\u756c\n\u6f64\n\u6f72\n\u6f64\n\u756c\n\u6f72\n\u6c61\n\u6c6c\n\u7269\n\u6172\n\u7269\n\u6172\n\u6768\n\u6869\n\u6869\n\u6768\n\u7269\n\u6172\n\u7269\n\u6172\n\u6c6f\n\u6c6f",
    "33.6 Operation in Sleep Mode\nThe DSM can operate during Sleep, if the carrier and modulator input sources are also operable during Sleep. Refer to the 'Power-Saving Modes' chapter for more details.",
    "33.7 Effects of a Reset\nUpon any device Reset, the DSM module is disabled. The user's firmware is responsible for initializing the module before enabling the output. All the registers are reset to their default values.",
    "33.8 Peripheral Module Disable\nThe DSM module can be completely disabled using the PMD module to achieve maximum power saving. When the DSMMD bit of the PMD registers is set, the DSM module is completely disabled. This puts the module in its lowest power consumption state. When enabled again all the registers of the DSM module default to POR status.",
    "33.9 Register Definitions: Modulation Control\nLong bit name prefixes for the modulation control peripherals are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 33-1. Modulation Control Long Bit Name Prefixes\nDSM1, Bit Name Prefix = MD1",
    "33.9.1 MDxCON0\nName:\nMDxCON0\nAddress:\n0x6A\nModulation Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = OPOL. , 5 = . , 6 = . , 7 = . , 8 = BIT. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - EN Modulator Module Enable\n1, Description = DSM is enabled and mixing input signals. 0, Description = DSM is disabled and has no output",
    "Bit 5 - OUT  Modulator Output (1)\nDisplays the current DSM_out value",
    "Bit 4 - OPOL Modulator Output Polarity Select\n1, Description = DSM output signal is inverted; idle high output. 0, Description = DSM output signal is not inverted; idle low output",
    "Bit 0 - BIT  Modulation Source Signal (2)\nAllows direct software control of the modulation signal",
    "Notes:\n1. The modulated output frequency can be greater and asynchronous from the clock that updates this register bit. The bit value may not be valid for higher speed modulator or carrier signals.\n2. MDBIT must be selected as the modulation source in the MDxSRC register for this operation.",
    "33.9.2 MDxCON1\nName:\nMDxCON1\nAddress:\n0x6B",
    "Modulation Control Register 1\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = CHPOL. , 3 = CHSYNC. , 4 = . , 5 = . , 6 = CLPOL. , 7 = CLSYNC. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - CHPOL Modulator High Carrier Polarity Select\n1, Description = Selected high carrier signal is inverted. 0, Description = Selected high carrier signal is not inverted",
    "Bit 4 - CHSYNC Modulator High Carrier Synchronization Enable\n1, Description = Modulator waits for a falling edge on the high time carrier signal before allowing a switch to the low time carrier. 0, Description = Modulator output is not synchronized to the high time carrier signal (1)",
    "Bit 1 - CLPOL Modulator Low Carrier Polarity Select\n1, Description = Selected low carrier signal is inverted. 0, Description = Selected low carrier signal is not inverted",
    "Bit 0 - CLSYNC Modulator Low Carrier Synchronization Enable\n1, Description = Modulator waits for a falling edge on the low time carrier signal before allowing a switch to the high time carrier. 0, Description = Modulator output is not synchronized to the low time carrier signal (1)",
    "Note:\n- 1. Narrowed carrier pulse widths or spurs may occur in the signal stream if the carrier is not synchronized.",
    "33.9.3 MDxCARH\nName: Address:\nMDxCARH\n0x6E\nModulation High Carrier Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CH[3:0]. , 6 = CH[3:0]. , 7 = CH[3:0]. , 8 = CH[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - CH[3:0] Modulator Carrier High Selection\n1111, Connection = Reserved. 1110, Connection = Reserved. 1101, Connection = CLC4_OUT. 1100, Connection = CLC3_OUT. 1011, Connection = CLC2_OUT. 1010, Connection = CLC1_OUT. 1001, Connection = NCO1_OUT. 1000, Connection = PWM3S1P1_OUT. 0111, Connection = PWM2S1P1_OUT. 0110, Connection = PWM1S1P1_OUT. 0101, Connection = CCP1_OUT. 0100, Connection = CLKREF_OUT. 0011, Connection = EXTOSC. 0010, Connection = HFINTOSC. 0001, Connection = F OSC (System Clock). 0000, Connection = Pin selected by MDCARHPPS",
    "33.9.4 MDxCARL\nName: Address:\nMDxCARL\n0x6D\nModulation Low Carrier Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CL[3:0]. , 6 = CL[3:0]. , 7 = CL[3:0]. , 8 = CL[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - CL[3:0] Modulator Carrier Low Input Selection\n1111, Connection = Reserved. 1110, Connection = Reserved. 1101, Connection = CLC4_OUT. 1100, Connection = CLC3_OUT. 1011, Connection = CLC2_OUT. 1010, Connection = CLC1_OUT. 1001, Connection = NCO1_OUT. 1000, Connection = PWM3S1P2_OUT. 0111, Connection = PWM2S1P2_OUT. 0110, Connection = PWM1S1P2_OUT. 0101, Connection = CCP1_OUT. 0100, Connection = CLKREF_OUT. 0011, Connection = EXTOSC. 0010, Connection = HFINTOSC. 0001, Connection = F OSC (System Clock). 0000, Connection = Pin selected by MDCARLPPS",
    "33.9.5 MDxSRC\nName: Address:\nMDxSRC\n0x6C\nModulation Source Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - MS[4:0] Modulator Source Selection\n10101 - 11111, Connection = Reserved. 10100, Connection = SPI2_SDO. 10011, Connection = SPI1_SDO. 10010, Connection = UART3_TX. 10001, Connection = UART2_TX. 10000, Connection = UART1_TX. 01111, Connection = CLC4_OUT. 01110, Connection = CLC3_OUT. 01101, Connection = CLC2_OUT. 01100, Connection = CLC1_OUT. 01011, Connection = CMP2_OUT. 01010, Connection = CMP1_OUT. 01001, Connection = NCO1_OUT. 01000, Connection = PWM3S1P2_OUT. 00111, Connection = PWM3S1P1_OUT. 00110, Connection = PWM2S1P2_OUT. 00101, Connection = PWM2S1P1_OUT. 00100, Connection = PWM1S1P2_OUT. 00011, Connection =",
    "Bits 4:0 - MS[4:0] Modulator Source Selection\nPWM1S1P1_OUT. 00010, Connection = CCP1_OUT. 00001, Connection = MDBIT. 00000, Connection = Pin selected by MDSRCPPS",
    "33.10 Register Summary - DSM\n0x00 ... 0x69, Name = Reserved. 0x00 ... 0x69, Bit Pos. = . 0x00 ... 0x69, 7 = . 0x00 ... 0x69, 6 = . 0x00 ... 0x69, 5 = . 0x00 ... 0x69, 4 = . 0x00 ... 0x69, 3 = . 0x00 ... 0x69, 2 = . 0x00 ... 0x69, 1 = . 0x00 ... 0x69, 0 = . 0x6A, Name = MD1CON0. 0x6A, Bit Pos. = 7:0. 0x6A, 7 = EN. 0x6A, 6 = . 0x6A, 5 = OUT. 0x6A, 4 = OPOL. 0x6A, 3 = . 0x6A, 2 = . 0x6A, 1 = . 0x6A, 0 = BIT. 0x6B, Name =",
    "33.10 Register Summary - DSM\nMD1CON1. 0x6B, Bit Pos. = 7:0. 0x6B, 7 = . 0x6B, 6 = . 0x6B, 5 = CHPOL. 0x6B, 4 = CHSYNC. 0x6B, 3 = . 0x6B, 2 = . 0x6B, 1 = CLPOL. 0x6B, 0 = CLSYNC. 0x6C, Name = MD1SRC. 0x6C, Bit Pos. = 7:0. 0x6C, 7 = . 0x6C, 6 = . 0x6C, 5 = . 0x6C, 4 = . 0x6C, 3 = MS[4:0]. 0x6C, 2 = MS[4:0]. 0x6C, 1 = MS[4:0]. 0x6C, 0 = MS[4:0]. 0x6D, Name = MD1CARL. 0x6D, Bit Pos. = 7:0. 0x6D, 7 = . 0x6D, 6 =",
    "33.10 Register Summary - DSM\n. 0x6D, 5 = . 0x6D, 4 = . 0x6D, 3 = CL[3:0]. 0x6D, 2 = CL[3:0]. 0x6D, 1 = CL[3:0]. 0x6D, 0 = CL[3:0]. 0x6E, Name = MD1CARH. 0x6E, Bit Pos. = 7:0. 0x6E, 7 = . 0x6E, 6 = . 0x6E, 5 = . 0x6E, 4 = . 0x6E, 3 = CH[3:0]. 0x6E, 2 = CH[3:0]. 0x6E, 1 = CH[3:0]. 0x6E, 0 = CH[3:0]",
    "34. UART - Universal Asynchronous Receiver Transmitter with Protocol Support\nThe Universal Asynchronous Receiver Transmitter (UART) module is a serial I/O communications peripheral. It contains all the clock generators, shift registers and data buffers necessary to perform an input or output serial data transfer, independent of device program execution. The UART, also known as a Serial Communications Interface (SCI), can be configured as a full-duplex asynchronous system or one of several automated protocols. The Full Duplex mode is useful for communications with peripheral systems, such as wireless modems and USB to serial interface modules.\nSupported protocols include:\n\u00b7 LIN Host and Client\n\u00b7 DMX Controller and Receiver\n\u00b7 DALI Control Gear and Control Device\nThe UART module includes the following capabilities:",
    "34. UART - Universal Asynchronous Receiver Transmitter with Protocol Support\n\u00b7 Half and full-duplex asynchronous transmit and receive\n\u00b7 Two-byte input buffer\n\u00b7 One-byte output buffer\n\u00b7 Programmable 7-bit or 8-bit byte width\n\u00b7 9th bit address detection\n\u00b7 9th bit even or odd parity\n\u00b7 Input buffer overrun error detection\n\u00b7 Receive framing error detection\n\u00b7 Hardware and software flow control\n\u00b7 Automatic checksum calculation and verification\n\u00b7 Programmable 1, 1.5, and 2 Stop bits\n\u00b7 Programmable data polarity\n\u00b7 Manchester encoder/decoder\n\u00b7 Operation in Sleep\n\u00b7 Automatic detection and calibration of the baud rate\n\u00b7 Wake-up on Break reception\n\u00b7 Automatic and user timed Break period generation\n\u00b7 RX and TX inactivity time-outs (with Timer2)\nThe operation of the UART module is controlled through 19 8-bit registers:",
    "34. UART - Universal Asynchronous Receiver Transmitter with Protocol Support\n\u00b7 Three control registers (UxCON0-UxCON2)\n\u00b7 Error enable and status (UxERRIE, UxERRIR, UxUIR)\n\u00b7 UART buffer status and control (UxFIFO)\n\u00b7 Three 9-bit protocol parameters (UxP1-UxP3)\n\u00b7 16-bit Baud Rate Generator (UxBRG)\n\u00b7 Transmit buffer write (UxTXB)\n\u00b7 Receive buffer read (UxRXB)\n\u00b7 Receive checksum (UxRXCHK)\n- \u00b7 Transmit checksum (UxTXCHK)\nThe UART transmit output (TX_out) is available to the TX pin and internally to various peripherals. Block diagrams of the UART transmitter and receiver are shown in the following figures.\nFigure 34-1. UART Transmitter Block Diagram\nFigure 34-2. UART Receiver Block Diagram",
    "34.1 UART I/O Pin Configuration\nThe RX input pin is selected with the UxRPPS register. The TX output pin is selected with each pin's RxyPPS register. When the TRIS control for the pin corresponding to the TX output is cleared, the UART will control the logic level on the TX pin. Changing the TXPOL bit in UxCON2 will immediately change the TX pin logic level, regardless of the value of EN or TXEN.",
    "34.2 UART Asynchronous Modes\nThe UART has five Asynchronous modes:\n\u00b7 7-bit\n\u00b7 8-bit\n\u00b7 8-bit with even parity in the 9th bit\n\u00b7 8-bit with odd parity in the 9th bit\n\u00b7 8-bit with address indicator in the 9th bit",
    "34.2 UART Asynchronous Modes\nThe UART transmits and receives data using the standard Non-Return-to-Zero (NRZ) format. NRZ is implemented with two levels: A VOH Mark state, which represents a ' 1 ' data bit, and a VOL Space state, which represents a ' 0 ' data bit. NRZ implies that consecutively transmitted data bits of the same value stay at the output level of that bit without returning to a neutral level between each bit transmission. An NRZ transmission port idles in the Mark state. Each character transmission consists of one Start bit followed by seven or eight data bits, one optional parity or address bit, and is always terminated by one or more Stop bits. The Start bit is always a space and the Stop bits are always marks. The most common data format is eight bits with no parity. Each transmitted bit persists for a period of 1/ (Baud Rate). An on-chip dedicated 16-bit Baud Rate Generator is used to derive standard baud rate frequencies from the system oscillator. See the UART Baud Rate Generator section for more information.",
    "34.2 UART Asynchronous Modes\nIn all Asynchronous modes, the UART transmits and receives the LSb first. The UART's transmitter and receiver are functionally independent but share the same data format and baud rate. Parity is supported by the hardware with even and odd parity modes.",
    "34.2.1 UART Asynchronous Transmitter\nThe UART transmitter block diagram is shown in Figure 34-1. The heart of the transmitter is the serial Transmit Shift Register (TSR), which is not directly accessible by software. The TSR obtains its data from the transmit buffer, which is the UxTXB register.",
    "34.2.1.1 Enabling the Transmitter\nThe UART transmitter is enabled for asynchronous operations by configuring the following control bits:\n\u00b7 TXEN = 1\n\u00b7 MODE = 0000 through 0011\n\u00b7 UxBRG = desired baud rate\n\u00b7 BRGS = desired baud rate multiplier\n\u00b7 RxyPPS = code for desired output pin\n\u00b7 ON = 1\nAll other UART control bits are assumed to be in their default state.\nSetting the TXEN bit enables the transmitter circuitry of the UART. The MODE bits select the desired mode. Setting the ON bit enables the UART. When TXEN is set and the transmitter is not Idle, the TX pin is automatically configured as an output. When the transmitter is Idle, the TX pin drive is relinquished to the port TRIS control. If the TX pin is shared with an analog peripheral, the analog I/O function will be disabled by clearing the corresponding ANSEL bit.\nImportant: The UxTXIF Transmitter Interrupt flag is set when the TXEN Enable bit is set and the UxTXB register can accept data.",
    "34.2.1.2 Transmitting Data\nA transmission is initiated by writing a character to the UxTXB register. If this is the first character, or the previous character has been completely transmitted from the TSR, the data in the UxTXB is immediately transferred to the TSR register. If the TSR still contains all or part of a previous character, the new character data are held in the UxTXB until the previous character transmission is complete. The pending character in the UxTXB is then transferred to the TSR at the beginning of the previous character Stop bit transmission. The transmission of the Start bit, data bits and Stop bit sequence commences immediately following the completion of all of the previous character's Stop bits.",
    "34.2.1.3 Transmit Data Polarity\nThe polarity of the transmit data is controlled with the TXPOL bit. The default state of this bit is ' 0 ', which selects high true transmit Idle and data bits. Setting the TXPOL bit to ' 1 ' will invert the transmit data, resulting in low true Idle and data bits. The TXPOL bit controls transmit data polarity in all modes.",
    "34.2.1.4 Transmit Interrupt Flag\nThe UxTXIF Interrupt Flag bit in the PIR register is set whenever the UART transmitter is enabled and no character is being held for transmission in the UxTXB register. In other words, the UxTXIF bit is clear only when the TSR is busy with a character and a new character has been queued for transmission in the UxTXB register.\nThe UxTXIF interrupt is enabled by setting the UxTXIE Interrupt Enable bit in the PIE register. However, the UxTXIF Flag bit will be set whenever the UxTXB register is empty, regardless of the state of the UxTXIE Enable bit. The UxTXIF bit is read-only and cannot be set or cleared by software.\nTo use interrupts when transmitting data, set the UxTXIE bit only when there is more data to send. Clear the UxTXIE Interrupt Enable bit upon writing the UxTXB register with the last character of the transmission.",
    "34.2.1.5 TSR Status\nThe TXMTIF bit indicates the status of the TSR. This is a read-only bit. The TXMTIF bit is set when the TSR is empty and Idle. The TXMTIF bit is cleared when a character is transferred to the TSR from the UxTXB. The TXMTIF bit remains clear until all bits, including the Stop bits, have been shifted out of the TSR and a byte is not waiting in the UxTXB register.\nThe TXMTIF will generate a summary UxEIF interrupt when the TXMTIE bit is set.\nImportant: The TSR is not mapped in data memory, so it is not available to the user.",
    "34.2.1.6 Transmitter 7-Bit Mode\nThe 7-bit mode is selected when the MODE bits are set to ' 0001 '. In 7-bit mode, only the seven Least Significant bits of the data written to UxTXB are transmitted. The Most Significant bit is ignored.",
    "34.2.1.7 Transmitter Parity Modes\nWhen Odd or Even Parity mode is selected, all data are sent as nine bits. The first eight bits are data and the 9th bit is parity. Even and odd parity is selected when the MODE bits are set to ' 0011 ' and ' 0010 ', respectively. Parity is automatically determined by the module and inserted in the serial data stream.",
    "34.2.1.8 Asynchronous Transmission Setup\nUse the following steps as a guide for configuring the UART for asynchronous transmissions.\n1. Initialize the UxBRG register pair and the BRGS bit to achieve the desired baud rate.\n2. Set the MODE bits to the desired Asynchronous mode.\n3. Set the TXPOL bit if inverted TX output is desired.\n4. Enable the asynchronous serial port by setting the ON bit.\n5. Enable the transmitter by setting the TXEN Control bit. This will cause the UxTXIF Interrupt flag to be set.\n6. If the device has PPS, configure the desired I/O pin RxyPPS register with the code for the TX output.\n7. If interrupts are desired, set the UxTXIE Interrupt Enable bit in the respective PIE register. An interrupt will occur immediately provided that global interrupts are also enabled.\n8. Write one byte of data into the UxTXB register. This will start the transmission.\n9. Subsequent bytes may be written when the UxTXIF bit is ' 1 '.\nFigure 34-3. UART Asynchronous Transmission",
    "34.2.1.8 Asynchronous Transmission Setup\nFigure 34-4. UART Asynchronous Transmission (Back-to-Back)",
    "34.2.2 UART Asynchronous Receiver\nThe Asynchronous mode is typically used in RS-232 systems. The receiver block diagram is shown in Figure 34-2. The data are received on the RX pin and drive the data recovery block. The data recovery block is actually a high-speed shifter operating at 4 or 16 times the baud rate, whereas the serial Receive Shift Register (RSR) operates at the bit rate. When all bits of the character have been shifted in, they are immediately transferred to a two-character First-In First-Out (FIFO) memory. The FIFO buffering allows reception of two complete characters and the start of a third character before software must begin servicing the UART receiver. The FIFO registers and RSR are not directly accessible by software. Access to the received data is made via the UxRXB register.",
    "34.2.2.1 Enabling the Receiver\nThe UART receiver is enabled for asynchronous operation by configuring the following control bits:\n\u00b7 RXEN = 1\n\u00b7 MODE = 0000 through 0011\n\u00b7 UxBRG = desired baud rate\n\u00b7 BRGS = desired baud rate multiplier\n\u00b7 RXPPS = code for desired input pin\n\u00b7 Input pin ANSEL bit = 0\n\u00b7 ON = 1\nAll other UART control bits are assumed to be in their default state.\nSetting the RXEN bit enables the receiver circuitry of the UART. Setting the MODE bits configures the UART for the desired Asynchronous mode. Setting the ON bit enables the UART. The TRIS bit corresponding to the selected RX I/O pin must be set to configure the pin as an input.\nImportant: If the RX function is on an analog pin, the corresponding ANSEL bit must be cleared for the receiver to function.",
    "34.2.2.2 Receiving Data\nData are recovered from the bit stream by timing to the center of the bits and sampling the input level. In High-Speed mode, there are four BRG clocks per bit and only one sample is taken per bit. In Normal Speed mode, there are 16 BRG clocks per bit and three samples are taken per bit.\nThe receiver data recovery circuit initiates character reception on the falling edge of the Start bit. The Start bit is always a ' 0 '. The Start bit is qualified in the middle of the bit. In Normal Speed mode only, the Start bit is also qualified at the leading edge of the bit. The following paragraphs describe the majority-detect sampling of the Normal Speed mode without inverted polarity.\nThe falling edge starts the Baud Rate Generator (BRG) clock. The input is sampled at the first and second BRG clocks.\nIf both samples are high, then the falling edge is deemed a glitch and the UART returns to the Start bit detection state without generating an error.",
    "34.2.2.2 Receiving Data\nIf either sample is low, the data recovery circuit continues counting BRG clocks and takes samples at clock counts: 7, 8 and 9. When less than two samples are low, the Start bit is deemed invalid, and the data recovery circuit aborts character reception without generating an error and resumes looking for the falling edge of the Start bit.\nWhen two or more samples are low, the Start bit is deemed valid and the data recovery continues. After a valid Start bit is detected, the BRG clock counter continues and resets at count 16. This is the beginning of the first data bit.\nThe data recovery circuit counts the BRG clocks from the beginning of the bit and takes samples at clocks 7, 8 and 9. The bit value is determined from the majority of the samples. The resulting ' 0 ' or ' 1 ' is shifted into the RSR. The BRG clock counter continues and resets at count 16. This sequence repeats until all data bits have been sampled and shifted into the RSR.",
    "34.2.2.2 Receiving Data\nAfter all data bits have been shifted in, the first Stop bit is sampled. Stop bits are always a ' 1 '. If the bit sampling determines that a ' 0 ' is in the Stop bit position, the framing error is set for this character. Otherwise, the framing error is cleared for this character. See the Receive Framing Error section for more information on framing errors.",
    "34.2.2.3 Receive Data Polarity\nThe polarity of the receive data is controlled with the RXPOL bit. The default state of this bit is ' 0 ', which selects high true receive Idle and data bits. Setting the RXPOL bit to ' 1 ' will invert the receive data, resulting in low true Idle and data bits. The RXPOL bit controls receive data polarity in all modes.",
    "34.2.2.4 Receive Interrupts\nImmediately after all data bits and the Stop bit have been received, the character in the RSR is transferred to the UART receive FIFO. The UxRXIF Interrupt flag in the respective PIR register is set at this time, provided it is not being suppressed.\nThe UxRXIF is suppressed by any of the following:\n\u00b7 FERIF when FERIE is set\n\u00b7 PERIF when PERIE is set\nWhen the UART uses DMA for reception, suppressing the UxRXIF suspends the DMA transfer of data until software processes the error and reads UxRXB to advance the FIFO beyond the error.\nThe UxRXIF interrupts are enabled by setting all of the following bits:\n\u00b7 UxRXIE, Interrupt Enable bit in the PIE register\n\u00b7 Global Interrupt Enable bits",
    "34.2.2.4 Receive Interrupts\nThe UxRXIF Interrupt Flag bit will be set when it is not suppressed and there is an unread character in the FIFO, regardless of the state of interrupt enable bits. Reading the UxRXB register will transfer the top character out of the FIFO and reduce the FIFO contents by one. The UxRXIF Interrupt Flag bit is read-only and therefore cannot be set or cleared by software.",
    "34.2.2.5 Receive Framing Error\nEach character in the receive FIFO buffer has a corresponding Framing Error Flag bit. A framing error indicates that the Stop bit was not seen at the expected time. For example, a Break condition will be received as a 0x00 byte with the framing error bit set.\nThe Framing Error flag is accessed via the FERIF bit. The FERIF bit represents the frame status of the top unread character of the receive FIFO. Therefore, the FERIF bit must be read before reading UxRXB.\nThe FERIF bit is read-only and only applies to the top unread character of the receive FIFO. A framing error (FERIF = 1 ) does not preclude reception of additional characters. It is neither necessary nor possible to clear the FERIF bit directly. Reading the next character from the FIFO buffer will advance the FIFO to the next character and the next corresponding framing error, if any.",
    "34.2.2.5 Receive Framing Error\nThe FERIF bit is cleared when the character at the top of the FIFO does not have a framing error or when all bytes in the receive FIFO have been read. Clearing the ON bit resets the receive FIFO, thereby also clearing the FERIF bit.\nA framing error will generate a summary UxEIF interrupt when the FERIE bit is set. The summary error is reset when the FERIF bit of the top of the FIFO is ' 0 ' or when all FIFO characters have been retrieved.\nImportant: When FERIE is set, UxRXIF interrupts are suppressed by FERIF = 1 .",
    "34.2.2.6 Receiver Parity Modes\nEven or odd parity is automatically detected when the MODE bits are set to ' 0011 ' or ' 0010 ', respectively. The parity modes receive eight data bits and one parity bit for a total of nine bits for each character. The PERIF bit represents the parity error of the top unread character of the receive FIFO rather than the parity bit itself. The parity error must be read before the UxRXB register is read because reading the UxRXB register will advance the FIFO pointer to the next byte with its associated PERIF flag.\nA parity error will generate a summary UxEIF interrupt when the PERIE bit is set. The summary error is reset when the PERIF bit of the top of the FIFO is ' 0 ' or when all FIFO characters have been retrieved.\nImportant: When PERIE is set, the UxRXIF interrupts are suppressed by PERIF = 1 .",
    "34.2.2.7 Receive FIFO Overflow\nWhen more characters are received than the receive FIFO can hold, the RXFOIF bit is set. The character causing the Overflow condition is discarded. The RUNOVF bit determines how the receive circuit responds to characters while the Overflow condition persists. When RUNOVF is set, the receive shifter stays synchronized to the incoming data stream by responding to Start, data, and Stop bits. However, all received bytes not already in the FIFO are discarded. When RUNOVF is cleared, the receive shifter ceases operation and Start, data, and Stop bits are ignored. The Receive Overflow condition is cleared by reading the UxRXB register and clearing the RXFOIF bit. If the UxRXB register is not read, thereby opening a space in the FIFO, the next character received will be discarded and cause another Overflow condition.\nA receive overflow error will generate a summary UxEIF interrupt when the RXFOIE bit is set.",
    "34.2.2.8 Asynchronous Reception Setup\nUse the following steps as a guide for configuring the UART for asynchronous reception:",
    "34.2.2.8 Asynchronous Reception Setup\n1. Initialize the UxBRG register pair and the BRGS bit to achieve the desired baud rate.\n2. Configure the RXPPS register for the desired RX pin.\n3. Clear the ANSEL bit for the RX pin (if applicable).\n4. Set the MODE bits to the desired Asynchronous mode.\n5. Set the RXPOL bit if the data stream is inverted.\n6. Enable the serial port by setting the ON bit.\n7. If interrupts are desired, set the UxRXIE bit in the PIEx register and enable global interrupts.\n8. Enable reception by setting the RXEN bit.\n9. Read the UxERRIR register to get the error flags.\n10. The UxRXIF Interrupt Flag bit will be set when a character is transferred from the RSR to the receive buffer. An interrupt will be generated if the UxRXIE interrupt enable bit is also set.\n11. Read the UxRXB register to get the received byte.\n12. If an overrun occurred, clear the RXFOIF bit.",
    "34.2.2.8 Asynchronous Reception Setup\nRev. 10-000117B 1/24/2019\nNote: This timing diagram shows three bytes appearing on the RX input. The UxRXB is not read before the third word is received, causing the RXFOIF (FIFO overrun) bit to be set. STPMD = 0 , STP = 00 .",
    "34.2.3 Asynchronous Address Mode\nA special Address Detection mode is available for use when multiple receivers share the same transmission line, as seen in RS-485 systems.\nWhen Asynchronous Address mode is enabled, all data are transmitted and received as 9-bit characters. The 9th bit determines whether the character is address or data. When the 9th bit is set, the eight Least Significant bits are the address. When the 9th bit is clear, the Least Significant bits are data. In either case, the 9th bit is stored in PERIF when the byte is written to the receive FIFO. When PERIE is also set, the RXIF will be suppressed, thereby suspending DMA transfers allowing software to process the received address.\nAn address character will enable all receivers that match the address and disable all other receivers. Once a receiver is enabled, all non-address characters will be received until an address character that does not match is received.",
    "34.2.3.1 Address Mode Transmit\nThe UART transmitter is enabled for asynchronous address operation by configuring the following control bits:\n\u00b7 TXEN = 1\n\u00b7 MODE = 0100\n\u00b7 UxBRG = desired baud rate\n\u00b7 BRGS = desired baud rate multiplier\n\u00b7 RxyPPS = code for desired output pin\n\u00b7 ON = 1\nAddresses are sent by writing to the UxP1L register. This transmits the written byte with the 9th bit set, which indicates that the byte is an address.\nData are sent by writing to the UxTXB register. This transmits the written byte with the 9th bit cleared, which indicates that the byte is data.\nTo send data to a particular device on the transmission bus, first transmit the address of the intended device. All subsequent data will be accepted only by that device until an address of another device is transmitted.\nWrites to UxP1L take precedence over writes to UxTXB. When both the UxP1L and UxTXB registers are written while the TSR is busy, the next byte to be transmitted will be from UxP1L.",
    "34.2.3.1 Address Mode Transmit\nTo ensure all data intended for one device are sent before the address is changed, wait until the TXMTIF bit is high before writing UxP1L with the new address.",
    "34.2.3.2 Address Mode Receive\nThe UART receiver is enabled for asynchronous address operation by configuring the following control bits:\n\u00b7 RXEN = 1\n\u00b7 MODE = 0100\n\u00b7 UxBRG = desired baud rate\n\u00b7 BRGS = desired baud rate multiplier\n\u00b7 RXPPS = code for desired input pin\n\u00b7 Input pin ANSEL bit = 0\n\u00b7 UxP2L = receiver address\n\u00b7 UxP3L = address mask\n\u00b7 ON = 1\nIn Address mode, no data will be transferred to the input FIFO until a valid address is received. This is the default state. Any of the following conditions will cause the UART to revert to the default state:\n\u00b7 ON = 0\n\u00b7 RXEN = 0\n\u00b7 Received address does not match\nWhen a character with the 9th bit set is received, the Least Significant eight bits of that character will be qualified by the values in the UxP2L and UxP3L registers.",
    "34.2.3.2 Address Mode Receive\nThe byte is XORed with UxP2L then ANDed with UxP3L. A match occurs when the result is 0h, in which case, the unaltered received character is stored in the receive FIFO, thereby setting the UxRXIF Interrupt bit. The 9th bit is stored in the corresponding PERIF bit, identifying this byte as an address.\nAn address match also enables the receiver for all data such that all subsequent characters without the 9th bit set will be stored in the receive FIFO.\nWhen the 9th bit is set and a match does not occur, the character is not stored in the receive FIFO and all subsequent data are ignored.\nThe UxP3L register mask allows a range of addresses to be accepted. Software can then determine the sub-address of the range by processing the received address character.",
    "34.3 DMX Mode (Full-Featured UARTs Only)\nDMX is a protocol used in stage and show equipment. This includes lighting, fog machines, motors, etc. The protocol consists of a controller that sends out commands and a receiver, such as theater lights, that receive these commands. The DMX protocol is usually unidirectional but can be a bidirectional protocol in either Half or Full Duplex mode. An example of a Half Duplex mode is the RDM (Remote Device Management) protocol that sits on DMX512A. The controller transmits commands and the receiver receives them. There are no Error conditions or retransmit mechanisms.\nDMX, or DMX512A, consists of a 'universe' of 512 channels. This means that one controller can output up to 512 bytes on a single DMX link. Each piece of equipment on the line is programmed to listen to a consecutive sequence of one or more of these bytes.\nFor example, a fog machine connected to one of the universes may be programmed to receive one byte, starting at byte number 10, and a lighting unit may be programmed to receive four bytes starting at byte number 22.",
    "34.3.1 DMX Controller\nThe DMX Controller mode is configured with the following settings:\n\u00b7 MODE = 1010\n\u00b7 TXEN = 1\n\u00b7 RXEN = 0\n\u00b7 TXPOL = 0\n\u00b7 UxP1 = one less than the number of bytes to transmit (excluding the Start code)\n\u00b7 UxBRG = value to achieve 250K baud rate\n\u00b7 STP = 10 for two Stop bits\n\u00b7 RxyPPS = TX pin output code\n\u00b7 ON = 1\nEach DMX transmission begins with a Break followed by a byte called the 'Start Code'. The width of the Break is fixed at 25 bit times. The Break is followed by a 'Mark After Break' (MAB) Idle period. After this Idle period, the first through the 'n'th byte is transmitted, where 'n-1' is the value in UxP1. See the following figure.\nFigure 34-6. DMX Transmit Sequence\nNote: 1  The MAB period is fixed at 3 bit times . .",
    "34.3.1 DMX Controller\nSoftware sends the Start Code and the 'n' data bytes by writing the UxTXB register with each byte to be sent in the desired order. A UxTXIF value of ' 1 ' indicates when the UxTXB is ready to accept the next byte.\nThe internal byte counter is not accessible to software. Software needs to keep track of the number of bytes written to UxTXB to ensure that no more and no less than 'n' bytes are sent because the DMX state machine will automatically insert a Break and reset its internal counter after 'n' bytes are written. One way to ensure synchronization between hardware and software is to toggle TXEN after\nthe last byte of the universe is completely free of the transmit shift register, as indicated by the TXMTIF bit.",
    "34.3.2 DMX Receiver\nThe DMX Receiver mode is configured with the following settings:\n\u00b7 MODE = 1010\n\u00b7 TXEN = 0\n\u00b7 RXEN = 1\n\u00b7 RXPOL = 0\n\u00b7 UxP2 = number of first byte to receive\n\u00b7 UxP3 = number of last byte to receive\n\u00b7 UxBRG = value to achieve 250K baud rate\n\u00b7 STP = 10 for two Stop bits\n\u00b7 ON = 1\n\u00b7 UxRXPPS = code for desired input pin\n\u00b7 Input pin ANSEL bit = 0\nWhen configured as a DMX Receiver, the UART listens for a Break character that is at least 23 bit periods wide. If the Break is shorter than 23 bit times, the Break is ignored and the DMX state machine remains in Idle mode. Upon receiving the Break, the DMX counters will be reset to align with the incoming data stream. Immediately after the Break, the UART will see the 'Mark after Break' (MAB). This space is ignored by the UART. The Start Code follows the MAB and will always be stored in the receive FIFO.",
    "34.3.2 DMX Receiver\nAfter the Start Code, the first through the 512th byte will be received, but not all of them are stored in the receive FIFO. The UART ignores all received bytes until the bytes of interest are received. This is done using the UxP2 and UxP3 registers. The UxP2 register holds the value of the byte number to start the receive process. The byte counter starts at ' 0 ' for the first byte after the Start Code. For example, to receive four bytes starting at the 10th byte after the Start Code, write 009h (9 decimal) to UxP2H:L and 00Ch (12 decimal) to UxP3H:L. The receive FIFO depth is limited, therefore the bytes must be retrieved by reading UxRXB as they come in to avoid a receive FIFO Overrun condition.\nTypically, two Stop bits are inserted between bytes. If either Stop bit is detected as a ' 0 ', the framing error for that byte will be set.",
    "34.3.2 DMX Receiver\nSince the DMX sequence always starts with a Break, the software can verify that it is in sync with the sequence by monitoring the RXBKIF flag to ensure that the next byte received after the RXBKIF flag is processed as the Start Code and subsequent bytes are processed as the expected data.",
    "34.4 LIN Modes (Full-Featured UARTs Only)\nLIN is a protocol used primarily in automotive applications. The LIN network consists of two kinds of software processes: a Host process and a Client process. Each network has only one Host process and one or more Client processes.\nFrom a physical layer point of view, the UART on one processor may be driven by both a Host and a Client process, as long as only one Host process exists on the network.\nA LIN transaction consists of a Host process followed by a Client process. The Client process may involve more than one client where one is transmitting and the other(s) receiving. The transaction begins by the following Host process transmission sequence:\n1. Break.\n2. Delimiter bit.\n3. Sync Field.\n4. PID byte.\nThe PID determines which Client processes are expected to respond to the host. When the PID byte is complete, the TX output remains in the Idle state. One or more of the Client processes may respond to the Host process. If no one responds within the inter-byte period, the host is free to start another transmission. The inter-byte period is timed by software using a means other than the UART.",
    "34.4 LIN Modes (Full-Featured UARTs Only)\nThe Client process follows the Host process. When the client software recognizes the PID, that Client process responds by either transmitting the required response or by receiving the transmitted data. Only Client processes send data. Therefore, Client processes receiving data are receiving that of another Client process.\nWhen a client sends data, the client UART automatically calculates the checksum for the transmitted bytes as they are sent and appends the inverted checksum byte to the client response.\nWhen a client receives data, the checksum is accumulated on each byte as it is received using the same algorithm as the sending process. The last byte, which is the inverted checksum value calculated by the sending process, is added to the locally calculated checksum by the UART. The check passes when the result is all ' 1 's, otherwise the check fails and the CERIF bit is set.",
    "34.4 LIN Modes (Full-Featured UARTs Only)\nTwo methods for computing the checksum are available: legacy and enhanced. The legacy checksum includes only the data bytes. The enhanced checksum includes the PID and the data. The C0EN control bit determines the checksum method. Setting C0EN to ' 1 ' selects the enhanced method. Software must select the appropriate method before the Start bit of the checksum byte is received.",
    "34.4.1 LIN Host/Client Mode\nThe LIN Host mode includes capabilities to generate client processes. The host process stops at the PID transmission. Any data that is transmitted in Host/Client mode is done as a client process. LIN Host/Client mode is configured by the following settings:\n\u00b7 MODE = 1100\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxBRG = value to achieve desired baud rate\n\u00b7 TXPOL = 0 (for high Idle state)\n\u00b7 STP = desired Stop bits selection\n\u00b7 C0EN = desired Checksum mode\n\u00b7 RxyPPS = TX pin selection code\n\u00b7 TX pin TRIS control = 0\n\u00b7 ON = 1\nImportant: The TXEN bit must be set before the Host process is received and remain set while in LIN mode whether or not the Client process is a transmitter.\nThe Host process is started by writing the PID to the UxP1L register when UxP2 is ' 0 ' and the UART is Idle. The UxTXIF will not be set in this case. Only the six Least Significant bits of UxP1L are used in the PID transmission.",
    "34.4.1 LIN Host/Client Mode\nThe two Most Significant bits of the transmitted PID are PID parity bits. PID[6] is the exclusive-or of PID bits 0, 1, 2 and 4. PID[7] is the inverse of the exclusive-or of PID bits 1, 3, 4 and 5.\nThe UART hardware calculates and inserts these bits in the serial stream.\nWriting UxP1L automatically clears the UxTXCHK and UxRXCHK registers and generates the Break, the delimiter bit, the Sync character (55h), and the PID transmission portion of the transaction. The data portion of the transaction that follows, if there is one, is a Client process. See the LIN Client Mode section for more details of that process. The host receives its own PID if RXEN is set. Software performs the Client process corresponding to the PID that was sent and received. Attempting to write UxP1L before an active Host process is complete will not succeed. Instead, the TXWRE bit will be set.",
    "34.4.2 LIN Client Mode\nThe LIN Client mode is configured by the following settings:\n\u00b7 MODE = 1011\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxP2 = number of data bytes to transmit\n\u00b7 UxP3 = number of data bytes to receive\n\u00b7 UxBRG = value to achieve default baud rate\n\u00b7 TXPOL = 0 (for high Idle state)\n\u00b7 STP = desired Stop bits selection\n\u00b7 C0EN = desired Checksum mode\n\u00b7 RxyPPS = TX pin selection code\n\u00b7 TX pin TRIS control = 0\n\u00b7 ON = 1",
    "34.4.2 LIN Client Mode\nThe Client process starts upon detecting a Break on the RX pin. The Break clears the UxTXCHK, UxRXCHK, UxP2 and UxP3 registers. At the end of the Break, the auto-baud circuity is activated and the baud rate is automatically set using the Sync character following the Break. The character following the Sync character is received as the PID code and is saved in the receive FIFO. The UART computes the two PID parity bits from the six Least Significant bits of the PID. If either parity bit does not match the corresponding bit of the received PID code, the PERIF flag is set and saved at the same FIFO location as the PID code. The UxRXIF bit is set indicating that the PID is available.\nSoftware retrieves the PID by reading the UxRXB register and determines the Client process to execute from that. The checksum method, number of data bytes, and whether to send or receive data are defined by the software according to the PID code.",
    "34.4.2.1 LIN Client Receiver\nWhen the Client process is a Receiver, the software performs the following tasks:\n\u00b7 The UxP3 register is written with a value equal to the number of data bytes to receive\n\u00b7 The C0EN bit is set or cleared to select the appropriate checksum. This must be completed before the Start bit of the checksum byte is received.\n\u00b7 Each byte of the process response is read from UxRXB when UxRXIF is set\nThe UART updates the checksum on each received byte. When the last data byte is received, the computed checksum total is stored in the UxRXCHK register. The next received byte is saved in the receive FIFO and added with the value in UxRXCHK. The result of this addition is not accessible. However, if the result is not all ' 1 's, the CERIF bit is set. The CERIF flag persists until cleared by software. Software needs to read UxRXB to remove the checksum byte from the FIFO, but the byte can be discarded if not needed for any other purpose.",
    "34.4.2.1 LIN Client Receiver\nAfter the checksum is received, the UART ignores all activity on the RX pin until a Break starts the next transaction.",
    "34.4.2.2 LIN Client Transmitter\nWhen the Client process is a transmitter, software performs the following tasks in the order shown:\n\u00b7 The UxP2 register is written with a value equal to the number of bytes to transmit. This will enable the UxTXIF flag which is disabled when UxP2 is ' 0 '.\n\u00b7 The C0EN bit is set or cleared to select the appropriate checksum\n\u00b7 Each byte of the process response is written to UxTXB when UxTXIF is set\nThe UART accumulates the checksum as each byte is written to UxTXB. After the last byte is written, the UART stores the calculated checksum in the UxTXCHK register and transmits the inverted result as the last byte in the response.\nThe UxTXIF flag is disabled when the number of bytes specified by the value in the UxP2 register have been written. Any writes to UxTXB that exceed the UxP2 count will be ignored and set the TXWRE flag.",
    "34.5 DALI Mode (Full-Featured UARTs Only)\nDALI is a protocol used for intelligent lighting control for building automation. The protocol consists of Control Devices and Control Gear. A Control Device is an application controller that sends out commands to the light fixtures. The light fixture itself is termed as a Control Gear. The communication is done using Manchester encoding, which is performed by the UART hardware.\nThere are two types of Manchester encoding: traditional and differential. The type used by Microchip is traditional manchester encoding. It consists of the clock and data in a single bit stream (refer to Figure 34-9). A high-to-low or a low-to-high transition always occurs in the middle of the bit period and may or may not occur at the bit period boundaries. When the consecutive bits in the bit stream are of the same value (i.e., consecutive ' 1 's or consecutive ' 0 's), a transition occurs at the bit boundary. However, when the bit value changes, there is no transition at the bit boundary. According to the standard, a half-bit time is typically 416.7 \u03bcs long. A double half-bit time or a single bit is typically 833.3 \u03bcs.",
    "34.5 DALI Mode (Full-Featured UARTs Only)\nThe protocol is inherently half-duplex. Communication over the bus occurs in the form of forward and backward frames. Wait times between the frames are defined in the standard to prevent collision between the frames.\nA Control Device transmission is termed as the forward frame. In the DALI 2.0 standard, a forward frame can be two or three bytes in length. The two-byte forward frame is used for communication between Control Device and Control Gear whereas the three-byte forward frame is used for communication between Control Devices on the bus. The first byte in the forward frame is the control byte and is followed by either one or two data bytes. The transaction begins when the Control Device starts a transmission. Unlike other protocols, each byte in the frame is transmitted MSb first. Typical frame timing is shown below.",
    "Figure 34-7. DALI Frame Timing\nDuring the communication between two Control Devices, three bytes are required to be transmitted. In this case, the software must write the third byte to UxTXB as soon as UxTXIF goes true and before the output shifter becomes empty. This ensures that the three bytes of the forward frame are transmitted back-to-back without any interruption.\nAll Control Gear on the bus receive the forward frame. If the forward frame requires a reply to be sent, one of the Control Gear may respond with a single byte, called the backward frame. The 2.0 standard requires the Control Gear to begin transmission of the backward frame between 5.5 ms to 10.5 ms (~14 to 22 half-bit times) after reception of the forward frame. Once the backward frame is received by the Control Device, it is required to wait a minimum of 2.4 ms (~6 half-bit times). After this wait time, the Control Device is free to transmit another forward frame. Refer to the figure below.\nFigure 34-8. DALI Forward/Backward Frame Timing",
    "Figure 34-7. DALI Frame Timing\nA Start bit is used to indicate the start of the forward and backward frames. When ABDEN = 0 , the receiver bit rate is determined by the BRG register. When ABDEN = 1 , the first bit synchronizes the receiver with the transmitter and sets the receiver bit rate. The low period of the Start bit is measured and is used as the timing reference for all data bits in the forward and backward frames. The ABDOVF bit is set if the Start bit low period causes the measurement counter to overflow. All the bits following the Start bit are data bits. The bit stream terminates when no transition is detected in the middle of a bit period. Refer to the figure below.",
    "Figure 34-9. Manchester Timing\nThe forward and backward frames are terminated by two Idle bit periods or Stop bits. Normally, these start in the first bit period of a byte. If both Stop bits are valid, the byte reception is terminated.\nIf either of the Stop bits is invalid, the frame is tagged as invalid by saving it as a null byte and setting the framing error in the receive FIFO.\nA framing error also occurs when no transition is detected on the bus in the middle of a bit period when the byte reception is not complete. In such a scenario, the byte will be saved with the FERIF bit set.",
    "34.5.1 Control Device\nThe Control Device mode is configured with the following settings:\n\u00b7 MODE = 'b1000\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxP1 = forward frames are held for transmission with this number of half-bit periods after the completion of a forward or backward frame\n\u00b7 UxP2 = forward/backward frame threshold delimiter. Any reception that starts this number of half-bit periods after the completion of a forward or backward frame is detected as forward frame and sets the PERIF flag of the corresponding received byte.\n\u00b7 UxBRG = value to achieve 1200 baud rate\n\u00b7 TXPOL = appropriate polarity for interface circuit\n\u00b7 STP = 'b10 for two Stop bits\n\u00b7 RxyPPS = TX pin selection code\n\u00b7 TX pin TRIS control = 0\n\u00b7 ON = 1",
    "34.5.1 Control Device\nA forward frame is initiated by writing the control byte to the UxTXB register. After sending the control byte, each data byte must be written to the UxTXB register as soon as UxTXIF goes true. It is necessary to perform every write after UxTXIF goes true to ensure that the transmit buffer is ready to accept the byte. Each write must also occur before the TXMTIF bit goes true, to ensure that the bit stream of the forward frame is generated without interruption.\nWhen TXMTIF goes true, indicating the transmit shift register has completed sending the last byte in the frame, the TX output is held in Idle state for the number of half-bit periods selected by the STP bits.\nAfter the last Stop bit, the TX output is held in the Idle state for an additional wait time determined by the half-bit period count in the UxP1 register. For example, a 2450 \u03bcs delay (~6 half-bit times) requires a value of 6 in UxP1L.",
    "34.5.1 Control Device\nAny writes to the UxTXB register that occur after TXMTIF goes true, but before the UxP1 wait time expires, are held and then transmitted immediately following the wait time. If a backward frame is received during the wait time, any bytes that may have been written to UxTXB will be transmitted after completion of the backward frame reception plus the UxP1 wait time.\nThe wait timer is reset by the backward frame and starts over immediately following the reception of the Stop bits of the backward frame. Data pending in the transmit shift register will be sent when the wait time elapses.\nTo replace or delete any pending forward frame data, the TXBE bit needs to be set to flush the shift register and transmit buffer. A new control byte can then be written to the UxTXB register. The control byte will be held in the buffer and sent at the beginning of the next forward frame following the UxP1 wait time.",
    "34.5.1 Control Device\nIn Control Device mode, PERIF is set when a forward frame is received. This helps the software to determine whether the received byte is part of a forward frame from a Control Device (either from the Control Device under consideration or from another Control Device on the bus) or a backward frame from a Control Gear.",
    "34.5.2 Control Gear\nThe Control Gear mode is configured with the following settings:\n\u00b7 MODE = 'b1001\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxP1 = back frames are held for transmission with this number of half-bit periods after the completion of a forward frame\n\u00b7 UxP2 = forward/back frame threshold delimiter. Idle periods longer than this number of half-bit periods are detected as forward frames.\n\u00b7 UxBRG = value to achieve 1200 baud rate\n\u00b7 TXPOL = appropriate polarity for interface circuit\n\u00b7 RXPOL = same as TXPOL\n\u00b7 STP = 'b10 for two Stop bits\n\u00b7 RxyPPS = TX pin output code\n\u00b7 TX pin TRIS control = 0\n\u00b7 RXPPS = RX pin selection code\n\u00b7 RX pin TRIS control = 1\n\u00b7 Input pin ANSEL bit = 0\n\u00b7 ON = 1",
    "34.5.2 Control Gear\nThe UART starts listening for a forward frame when the Control Gear mode is entered. Only the frames that follow an Idle period longer than UxP2 half-bit periods are detected as forward frames. Backward frames from other Control Gear are ignored. Only forward frames will be stored in UxRXB. This is necessary because a backward frame can be sent only as a response to a forward frame.\nThe forward frame is received one byte at a time in the receive FIFO and retrieved by reading the UxRXB register. The end of the forward frame starts a timer to delay the backward frame response by a wait time equal to the number of half-bit periods stored in UxP1.\nThe data received in the forward frame is processed by the application software. If the application decides to send a backward frame in response to the forward frame, the value of the backward frame is written to UxTXB. This value is held for transmission in the transmit shift register until the wait time expires, being transmitted afterward.",
    "34.5.2 Control Gear\nIf the backward frame data are written to UxTXB after the wait time has expired, it is held in the UxTXB register until the end of the wait time following the next forward frame. The TXMTIF bit is false when the backward frame data are held in the transmit shift register. Receiving a UxRXIF interrupt before the TXMTIF goes true indicates that the backward frame write was too late and another forward frame was received before sending the backward frame. The pending backward frame is flushed by setting the TXBE bit to prevent it from being sent after the next forward frame.",
    "34.6 General Purpose Manchester (Full-Featured UARTs Only)\nGeneral purpose Manchester is a subset of the DALI mode. When the UxP1L register is cleared, there is no minimum wait time between frames. This allows full- and half-duplex operation because writes to the UxTXB register are not held waiting for a receive operation to complete.\nGeneral purpose Manchester operation maintains all other aspects of DALI mode as shown in Figure 34-9 such as:\n\u00b7 Single-pulse Start bit\n\u00b7 Most Significant bit first\n\u00b7 No stop periods between back-to-back bytes\nThe general purpose Manchester mode is configured with the following settings:\n\u00b7 MODE = 'b1000\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxP1 = 0h\n\u00b7 UxBRG = desired baud rate\n\u00b7 TXPOL and RXPOL = desired Idle state\n\u00b7 STP = desired number of stop periods\n\u00b7 RxyPPS = TX pin selection code\n\u00b7 TX pin TRIS control = 0\n\u00b7 RXPPS = RX pin selection code\n\u00b7 RX pin TRIS control = 1\n\u00b7 Input pin ANSEL bit = 0\n\u00b7 ON = 1\nThe Manchester bit stream timing is shown in Figure 34-9.",
    "34.7 Polarity\nReceive and transmit polarity is user selectable and affects all modes of operation.\nThe idle level is programmable with the TXPOL and RXPOL polarity control bits. Both control bits default to ' 0 ', which selects a high idle level for transmit and receive. The low level Idle state is selected by setting the control bit to ' 1 '. TXPOL controls the TX idle level. RXPOL controls the RX idle level.",
    "34.8 Stop Bits\nThe number of Stop bits is user selectable with the STP bits. The STP bits affect all modes of operation.\nStop bits selections are shown in the table below:\nTable 34-1. Stop Bits Selections\n\n1, Receiver Verification = Verify Stop bit. 1.5, Receiver Verification = Verify first Stop bit. 2, Receiver Verification = Verify both Stop bits. 2, Receiver Verification = Verify only first Stop bit\nIn all modes, except DALI, the transmitter is Idle for the number of Stop bit periods between each consecutively transmitted word. In DALI, the Stop bits are generated after the last bit in the transmitted data stream.\nThe input is checked for the idle level in the middle of the first Stop bit, when receive verify on first is selected, as well as in the middle of the second Stop bit, when verify on both is selected. If any Stop bit verification indicates a nonidle level, the framing error FERIF bit is set for the received word.",
    "34.8.1 Delayed Receive Interrupt\nWhen operating in Half Duplex mode, where the microcontroller needs to reverse the transceiver direction after a reception, it may be more convenient to hold off the UxRXIF interrupt until the end of the Stop bits to avoid line contention. The user selects when the UxRXIF interrupt occurs with the STPMD bit. When STPMD is ' 1 ', the UxRXIF interrupt occurs at the end of the last Stop bit. When STPMD is ' 0 ', the UxRXIF interrupt occurs when the received byte is stored in the receive FIFO. When STP = 10 , the store operation is performed in the middle of the second Stop bit. Otherwise, it is performed in the middle of the first Stop bit.\nThe FERIF and PERIF interrupts are not delayed with STPMD. When STPMD is set, the preferred indicator for reversing transceiver direction is the UxRXIF interrupt because it is delayed whereas the others are not.",
    "34.9 Operation After FIFO Overflow\nThe Receive Shift Register (RSR) can be configured to stop or continue running during a receive FIFO Overflow condition. Stopped operation is the Legacy mode.\nWhen the RSR continues to run during an Overflow condition, the first word received after clearing the overflow will always be valid.\nWhen the RSR is stopped during an Overflow condition, the synchronization with the Start bits is lost. Therefore, the first word received after the overflow is cleared may start in the middle of a word.\nOperation during overflow is selected with the RUNOVF bit. When the RUNOVF bit is set, the receiver maintains synchronization with the Start bits throughout the Overflow condition.",
    "34.10 Receive and Transmit Buffers\nThe UART uses small buffer areas to transmit and receive data. These are sometimes referred to as FIFOs.\nThe receiver has a Receive Shift Register (RSR) and two or more buffer registers. The buffer at the top of the FIFO (earliest byte to enter the FIFO) is retrieved by reading the UxRXB register.\nThe transmitter has one or more Transmit Shift Register (TSR) and one buffer register. Writes to UxTXB go to the transmit buffer and then immediately to the TSR, if it is empty. When the TSR is not empty, writes to UxTXB are held and then transferred to the TSR when it becomes available.",
    "34.10.1  FIFO Status\nThe UxFIFO register contains several Status bits for determining the state of the receive and transmit buffers.\nThe RXBE bit indicates that the receive FIFO is empty. This bit is essentially the inverse of UxRXIF. The RXBF bit indicates that the receive FIFO is full.\nThe TXBE bit indicates that the transmit buffer is empty (same as UxTXIF) and the TXBF bit indicates that the buffer is full. A third transmitter Status bit, TXWRE (transmit write error), is set whenever a UxTXB write is performed when the TXBF bit is set. This indicates that the write was unsuccessful.",
    "34.10.2  FIFO Reset\nAll modes support resetting the receive and transmit buffers.\nThe receive buffer is flushed and all unread data discarded when the RXBE bit is written to ' 1 '. Instead of using a BSF instruction to set RXBE, the MOVWF instruction with the TXBE bit cleared will be used to avoid inadvertently clearing a byte pending in the TSR when UxTXB is empty.\nData written to UxTXB when TXEN is low will be held in the Transmit Shift Register (TSR), then sent when TXEN is set. The transmit buffer and inactive TSR are flushed by setting the TXBE bit. Setting TXBE while a character is actively transmitting from the TSR will complete the transmission without being flushed.\nClearing the ON bit will discard all received data and transmit data pending in the TSR and UxTXB.",
    "34.11 Flow Control\nThis section does not apply to the LIN, DALI, or DMX modes.\nFlow control is the means by which a sending UART data stream can be suspended by a receiving UART. Flow control prevents input buffers from overflowing without software intervention. The UART supports both hardware and XON/XOFF methods of flow control.\nThe flow control method is selected with the FLO bits. Flow control is disabled when both bits are cleared.",
    "34.11.1  Hardware Flow Control\nThe hardware flow control is selected by setting the FLO bits to ' 10 '.\nThe hardware flow control consists of three lines. The RS-232 signal names for two of these are RTS and CTS. Both are low true. The third line is called TXDE for transmit drive enable which may be used to control an RS-485 transceiver. This output is high when the TX output is actively sending a character and low at all other times. The UART is configured as DTE (computer) equipment, which means RTS is an output and CTS is an input.\nThe RTS and CTS signals work as a pair to control the transmission flow. A DTE-to-DTE configuration connects the RTS output of the receiving UART to the CTS input of the sending UART. Refer to the following figure.\nFigure 34-10. Hardware Flow Control Connections\nThe UART receiving data asserts the RTS output low when the input FIFO is empty. When a character is received, the RTS output goes high until the UxRXB is read to free up both FIFO locations.",
    "34.11.1  Hardware Flow Control\nWhen the CTS input goes high after a byte has started to transmit, the transmission will complete normally. The receiver accommodates this by accepting the character in the second FIFO location even when the CTS input is high.",
    "34.11.2  RS-485 Transceiver Control\nThe hardware flow control can be used to control the direction of an RS-485 transceiver as shown in the following figure. The CTS input will be configured to be always enabled by setting the UxCTSPPS selection to an unimplemented PORT pin, such as RD0. When the signal and control lines are configured as shown in the figure below, the UART will not receive its own transmissions. To verify that there are no collisions on the RS-485 lines, the transceiver RE control can be disconnected from TXDE and tied low, thereby enabling loopback reception of all transmissions. See the Collision Detection section for more information.\nFigure 34-11. RS-485 Configuration\nConfigure UxCTSPPS to an unimplemented input such as RD0. (e.g. UxCTSPPS = 0x18) Note 1:",
    "34.11.3  XON/XOFF Flow Control\nXON/XOFF flow control is selected by setting the FLO bits to ' 01 '.\nXON/XOFF is a data-based flow control method. The signals to suspend and resume transmission are special characters sent by the receiver to the transmitter. The advantage is that additional hardware lines are not needed.\nXON/XOFF flow control requires full-duplex operation because the transmitter must be able to receive the signal to suspend transmitting while the transmission is in progress. Although XON and XOFF are not defined in the ASCII code, the generally accepted values are 13h for XOFF and 11h for XON. The UART uses those codes.\nThe transmitter defaults to XON, or transmitter enabled. This state is also indicated by the read-only XON bit.\nWhen an XOFF character is received, the transmitter stops transmitting after completing the character actively being transmitted. The transmitter remains disabled until an XON character is received.\nXON will be forced on when software toggles the TXEN bit.",
    "34.11.3  XON/XOFF Flow Control\nWhen the RUNOVF bit is set, the XON and XOFF characters continue to be received and processed without the need to clear the input FIFO by reading UxRXB. However, if the RUNOVF bit is clear then\nUxRXB must be read to avoid a receive overflow which will suspend flow control when the receive buffer overflows.",
    "34.12 Checksum (Full-Featured UARTs Only)\nThis section does not apply to the LIN mode, which handles checksums automatically.\nThe transmit and receive checksum adders are enabled when the C0EN bit is set. When enabled, the adders accumulate every byte that is transmitted or received. The accumulated sum includes the carry of the addition. Software is responsible for clearing the checksum registers before a transaction and performing the check at the end of the transaction.\nThe following examples illustrate how the checksum registers can be used in the Asynchronous modes.",
    "34.12.1  Transmit Checksum Method\n1. Clear the UxTXCHK register.\n2. Set the C0EN bit.\n3. Send all bytes of the transaction output.\n4. Invert UxTXCHK and send the result as the last byte of the transaction.",
    "34.12.2  Receive Checksum Method\n1. Clear the UxRXCHK register.\n2. Set the C0EN bit.\n3. Receive all bytes in the transaction including the checksum byte.\n4. Set MSb of UxRXCHK if 7-bit mode is selected.\n5. Add ' 1 ' to UxRXCHK.\n6. If the result is ' 0 ', the checksum passes, otherwise it fails.\nThe CERIF Checksum Interrupt flag is not active in any mode other than LIN.",
    "34.13 Collision Detection (Full-Featured UARTs Only)\nExternal forces that interfere with the transmit line are detected in all modes of operation with collision detection. Collision detection is always active when RXEN and TXEN are both set. When the receive input is connected to the transmit output through either the same I/O pin or external circuitry, a character will be received for every character transmitted. The collision detection circuit provides a warning when the word received does not match the word transmitted.\nThe TXCIF flag is used to signal collisions. This signal is only useful when the TX output is looped back to the RX input and everything that is transmitted is expected to be received. If more than one transmitter is active at the same time, it can be assumed that the TX word will not match the RX word. The TXCIF detects this mismatch and flags an interrupt. The TXCIF bit will also be set in DALI mode transmissions when the received bit is missing the expected mid-bit transition.",
    "34.13 Collision Detection (Full-Featured UARTs Only)\nCollision detection is always active, regardless of whether or not the RX input is connected to the TX output. It is up to the user to disable the TXCIE bit when collision interrupts are not required. The software overhead of unloading the receive buffer of transmitted data is avoided by setting the RUNOVF bit, ignoring the receive interrupt, and letting the receive buffer overflow. When the transmission is complete, prepare to receive data by flushing the receive buffer (see the FIFO Reset section) and clearing the RXFOIF overflow flag.",
    "34.14 RX/TX Activity Time-Out\nThe UART works in conjunction with the HLT timers to monitor activity on the RX and TX lines. Use this feature to determine when there has been no activity on the receive or transmit lines for a user-specified period of time.\nTo use this feature, set the HLT to the desired time-out period by a combination of the HLT clock source, timer prescale value and timer period registers. Configure the HLT to reset on the UART TX or RX line and start the HLT at the same time the UART is started. UART activity will keep resetting the HLT to prevent a full HLT period from elapsing. When there has been no activity on the selected TX or RX line for longer than the HLT period, an HLT interrupt will occur signaling the time-out event.\nFor example, the following register settings will configure HLT2 for a 5 ms time-out of no activity on U1RX:",
    "34.14 RX/TX Activity Time-Out\n\u00b7 T2PR = 0x9C (156 prescale periods)\n\u00b7 T2CLKCON = 0x05 (500 kHz internal oscillator)\n\u00b7 T2HLT = 0x04 (free-running, Reset on rising edge)\n\u00b7 T2RST = 0x15 (Reset on U1RX)\n\u00b7 T2CON = 0xC0 (Timer2 on with 1:16 prescale)",
    "34.15 Clock Accuracy with Asynchronous Operation\nThe factory calibrates the internal oscillator block output (INTOSC). However, the INTOSC frequency may drift as V DD or temperature changes, which directly affects the asynchronous baud rate. Two methods may be used to adjust the baud rate clock, but both require a reference clock source of some kind.\nThe first (preferred) method uses the OSCTUNE register to adjust the INTOSC output. Adjusting the value of the OSCTUNE register allows for fine resolution changes to the system clock source. See the 'HFINTOSC Frequency Tuning' section for more information.\nThe other method adjusts the value of the Baud Rate Generator. This can be done automatically with the Auto-Baud Detect feature (see the Auto-Baud Detect section). There may not be fine enough resolution when adjusting the Baud Rate Generator to compensate for a gradual change of the peripheral clock frequency.",
    "34.16 UART Baud Rate Generator\nThe Baud Rate Generator (BRG) is a 16-bit timer that is dedicated to the support of the UART operation. The UxBRG register pair determines the period of the free-running baud rate timer. The multiplier of the baud rate period is determined by the BRGS bit.\nThe high baud rate range (BRGS = 1 ) is intended to extend the baud rate range up to a faster rate when the desired baud rate is not otherwise possible and to improve the baud rate resolution at high baud rates. Using the normal baud rate range (BRGS = 0 ) is recommended when the desired baud rate is achievable with either range.\nImportant: BRGS = 1 is not supported in the DALI mode.\nWriting a new value to UxBRG causes the BRG timer to be reset (or cleared). This ensures that the BRG does not wait for a timer overflow before outputting the new baud rate.",
    "34.16 UART Baud Rate Generator\nIf the system clock is changed during an active receive operation, a receive error or data loss may result. To avoid this problem, check the status of the RXIDL bit to make sure that the receive operation is Idle before changing the system clock. The following table contains formulas for determining the baud rate.\nTable 34-2. Baud Rate Formulas\n\n1, BRG/UART Mode = High Rate. 1, Baud Rate Formula = Fosc/[4(UxBRG+1)]. 0, BRG/UART Mode = Normal Rate. 0, Baud Rate Formula = Fosc/[16(UxBRG+1)]\nThe following example provides a sample calculation for determining the baud rate and baud rate error.",
    "Example 34-1. Baud Rate Error Calculation\nFor a device with Fosc of 16 MHz, desired baud rate of 9600, Asynchronous mode, and BRGS = 0 .\nUxBRG = 16000000 16 \u00d7 9600 -1\nDesiredBaudrate = F OSC 16 \u00d7 UxBRG + 1 Solving for UxBRG: UxBRG = F OSC 16 \u00d7 DesiredBaudrate -1\nError =\nUxBRG = 103.17 \u2243 103 CalculatedBaudrate = 16000000 16 \u00d7 103 + 1 CalculatedBaudrate = 9615\nCalculatedBaudrate - DesiredBaudrate\nDesiredBaudrate\n<!-- formula-not-decoded -->",
    "34.16.1  Auto-Baud Detect\nThe UART module supports automatic detection and calibration of the baud rate in the 8-bit Asynchronous and LIN modes. However, setting ABDEN to start auto-baud detection is neither necessary, nor possible in LIN mode because that mode supports auto-baud detection automatically at the beginning of every data packet. Enabling auto-baud detect with the ABDEN bit applies to the Asynchronous modes only.\nWhen Auto-Baud Detect (ABD) is active, the clock to the BRG is reversed. Rather than the BRG clocking the incoming RX signal, the RX signal is timing the BRG. The Baud Rate Generator is used to time the period of a received 55h (ASCII 'U'), which is the Sync character for the LIN bus. The unique feature of this character is that it has five falling edges, including the Start bit edge, and five rising edges, including the Stop bit edge.",
    "34.16.1  Auto-Baud Detect\nIn 8-bit Asynchronous mode, setting the ABDEN bit enables the auto-baud calibration sequence. The first falling edge of the RX input after ABDEN is set will start the auto-baud calibration sequence. While the ABD sequence takes place, the UART state machine is held in Idle. On the first falling edge of the receive line, the UxBRG begins counting up using the BRG counter clock, as shown in the following figure. The fifth falling edge will occur on the RX pin at the beginning of the bit 7 period. At that time, an accumulated value totaling the proper BRG period is left in the UxBRG register pair, the ABDEN bit is automatically cleared and the ABDIF interrupt flag is set. ABDIF must be cleared by software.",
    "Figure 34-12. Automatic Baud Rate Calibration\nRev. 10-000120B\nRXIDL indicates that the sync input is active. RXIDL will go low on the first falling edge and go high on the fifth rising edge.\nThe BRG auto-baud clock is determined by the BRGS bit, as shown in the following table.\nTable 34-3. BRG Counter Clock Rates\n\n1, BRG Base Clock = Fosc/4. 1, BRG ABD Clock = Fosc/32. 0, BRG Base Clock = Fosc/16. 0, BRG ABD Clock = Fosc/128\nDuring ABD, the internal BRG register is used as a 16-bit counter. However, the UxBRG registers retain the previous BRG value until the auto-baud process is successfully completed. While calibrating the baud rate period, the internal BRG register is clocked at 1/8th the BRG base clock rate. The resulting byte measurement is the average bit time when clocked at full speed and is transferred to the UxBRG registers when complete.",
    "Important:\n1. When both the WUE and ABDEN bits are set, the auto-baud detection will occur on the byte following the Break character (see the Auto Wake-on-Break section).\n2. It is up to the user to verify that the incoming character baud rate is within the range of the selected BRG clock source. Some combinations of oscillator frequency and UART baud rates are not possible.",
    "34.16.2  Auto-Baud Overflow\nDuring the course of automatic baud detection, the ABDOVF bit will be set if the baud rate counter overflows before the fifth falling edge is detected on the RX pin. The ABDOVF bit indicates that the counter has exceeded the maximum count that can fit in the 16 bits of the UxBRG register pair. After the ABDOVF bit has been set, the state machine continues to search until the fifth falling edge is detected on the RX pin. Upon detecting the fifth falling RX edge, the hardware will set the ABDIF\nInterrupt flag and clear the ABDEN bit. The UxBRG register values retain their previous value. The ABDIF flag and ABDOVF flag can be cleared by software directly. To generate an interrupt on an Auto-Baud Overflow condition, all the following bits must be set:\n\u00b7 ABDOVE bit\n\u00b7 UxEIE bit in the PIEx register\n\u00b7 Global Interrupt Enable bits\nTo terminate the auto-baud process before the ABDIF flag is set, clear the ABDEN bit, then clear the ABDOVF bit.",
    "34.16.3  Auto Wake-on-Break\nDuring Sleep mode, all clocks to the UART are suspended. Because of this, the Baud Rate Generator is inactive and a proper character reception cannot be performed. The Auto Wake-on-Break feature allows the controller to wake up due to activity on the RX line.\nThe Auto-Wake-up feature is enabled by setting both the WUE bit and the UxIE bit in the PIEx register. Once set, the normal receive sequence on RX is disabled, and the UART remains in an Idle state, monitoring for a wake-up event independent of the CPU mode. A wake-up event consists of a transition out of the Idle state on the RX line (this coincides with the start of a Break or a wake-up signal character for the LIN protocol).\nThe UART module generates a WUIF interrupt coincident with the wake-up event. The interrupt is generated synchronously to the Q clocks in normal CPU operating modes (Figure 34-13) and asynchronously if the device is in Sleep mode (Figure 34-14). The interrupt condition is cleared by clearing the WUIF bit.",
    "34.16.3  Auto Wake-on-Break\nFigure 34-13. Auto-Wake-Up Timing During Normal Operation\nNote 1: The UART remains in Idle while the WUE bit is set.",
    "Figure 34-14. Auto-Wake-Up Timing During Sleep\nNote 1: The UART remains in  dle while the WUE bit is set. I\nTo generate an interrupt on a wake-up event, all the following bits must be set:\n\u00b7 The UxIE bit in the PIEx register\n\u00b7 Global interrupt enables\nThe WUE bit is automatically cleared by the transition to the Idle state on the RX line at the end of the Break. This signals to the user that the Break event is over. At this point, the UART module is in Idle mode, waiting to receive the next character.",
    "Break Character\nTo avoid character errors or character fragments during a wake-up event, all bits in the character causing the Wake event must be zero.\nWhen the wake-up is enabled, the function works independent of the low time on the data stream. If the WUE bit is set and a valid nonzero character is received, the low time from the Start bit to the first rising edge will be interpreted as the wake-up event. The remaining bits of the character will be received as a fragmented character and subsequent characters can result in framing or overrun errors.\nTherefore, the initial character of the transmission must be all zeros. This must be eleven or more bit times, 13 bit times recommended for LIN bus, or any number of bit times for standard RS-232 devices.",
    "Oscillator Start-Up Time\nThe oscillator start-up time must be considered, especially in applications using oscillators with longer start-up intervals (i.e., LP, XT or HS/PLL modes). The Sync Break (or wake-up signal) character must be of sufficient length and must be be followed by a sufficient interval to allow enough time for the selected oscillator to start and provide proper initialization of the UART.",
    "The WUE Bit\nTo ensure that no actual data are lost, check the RXIDL bit to verify that a receive operation is not in process before setting the WUE bit. If a receive operation is not occurring, the WUE bit may then be set just prior to entering the Sleep mode.",
    "34.17 Transmitting a Break\nThe UART module has the capability of sending either a fixed length Break period or a softwaretimed Break period. The fixed length Break consists of a Start bit, followed by 12 ' 0 ' bits and a Stop bit. The software-timed Break is generated by setting and clearing the BRKOVR bit.\nTo send the fixed length Break, set the SENDB and TXEN bits. The Break sequence is then initiated by a write to UxTXB. The timed Break will occur first, followed by the character written to UxTXB that initiated the Break. The initiating character is typically the Sync character of the LIN specification.\nSENDB is disabled in the LIN and DMX modes because those modes generate the Break sequence automatically.\nThe SENDB bit is automatically reset by hardware after the Break Stop bit is complete.\nThe TXMTIF bit indicates when the transmit operation is Active or Idle, just as it does during normal transmission. The following figure illustrates the Break sequence.\nFigure 34-15. Send-Break Sequence",
    "34.18 Receiving a Break\nThe UART has counters to detect when the RX input remains in the Space state for an extended period of time. When this happens, the RXBKIF bit is set.\nA Break is detected when the RX input remains in the Space state for 11 bit periods for asynchronous and LIN modes and 23 bit periods for DMX mode.\nThe user can select to receive the Break interrupt as soon as the Break is detected or at the end of the Break, when the RX input returns to the Idle state. When the RXBIMD bit is ' 1 ', then RXBKIF is set immediately upon Break detection. When RXBIMD is ' 0 ', then RXBKIF is set when the RX input returns to the Idle state.",
    "34.19 UART Operation During Sleep\nThe UART ceases to operate during Sleep. The safe way to wake the device from Sleep by a serial operation is to use the Wake-on-Break feature of the UART. See the Auto Wake-on-Break section.",
    "34.20 Register Definitions: UART\nLong bit name prefixes for the UART peripherals are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 34-4. UART Long Bit Name Prefixes\n\nUART1 (full featured), Bit Name Prefix = U1\n, Peripheral = UART2 (limited features). ,  = U2. , Peripheral = UART3 (limited features). ,  = U3",
    "34.20.1  UxCON0\nName: Address:\nUxCON0 0x2AB,0x2BE,0x2D1\nUART Control Register 0",
    "34.20.1  UxCON0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BRGS. , 2 = ABDEN. , 3 = TXEN. , 4 = RXEN. , 5 = MODE[3:0]. , 6 = MODE[3:0]. , 7 = MODE[3:0]. , 8 = MODE[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - BRGS Baud Rate Generator Speed Select\n1, Description = Baud Rate Generator is high speed with 4 baud clocks per bit. 0, Description = Baud Rate Generator is normal speed with 16 baud clocks per bit",
    "Bit 6 - ABDEN  Auto-Baud Detect Enable (3)\n1, Description = Auto-baud is enabled. Receiver is waiting for Sync character ( 0x55 ).. 0, Description = Auto-baud is not enabled or auto-baud is complete",
    "Bit 5 - TXEN  Transmit Enable Control (2)\n1, Description = Transmit is enabled. TX output pin drive is forced on when transmission is active and is controlled by PORT TRIS control when transmission is Idle.. 0, Description = Transmit is disabled. TX output pin drive is controlled by PORT TRIS control.",
    "Bit 4 - RXEN  Receive Enable Control (2)\n1, Description = Receiver is enabled. 0, Description = Receiver is disabled",
    "Bits 3:0 - MODE[3:0]  UART Mode Select (1)\n1111 1101, Description = Reserved. 1100, Description = LIN Host/Client mode (4). 1011, Description = LIN Client Only mode (4). 1010, Description = DMX mode (4). 1001, Description = DALI Control Gear mode (4). 1000, Description = DALI Control Device mode (4). 0111 0101, Description = Reserved. 0100, Description = Asynchronous 9-bit UART Address mode. 9th bit: 1 = address, 0 = data. 0011, Description = Asynchronous 8-bit UART mode with 9th bit even parity. 0010, Description = Asynchronous 8-bit UART mode with 9th bit odd parity. 0001, Description = Asynchronous 7-bit UART mode. 0000, Description = Asynchronous 8-bit UART mode",
    "Notes:\n1. Changing the UART MODE while ON = 1 may cause unexpected results.\n2. Clearing TXEN or RXEN will not clear the corresponding buffers. Use TXBE or RXBE to clear the buffers.\n3. ABDEN is read-only when MODE > 'b0111 .\n4. Full-featured UARTs only.",
    "34.20.2  UxCON1\nName:\nUxCON1 0x2AC,0x2BF,0x2D2\nAddress:",
    "UART Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = ON. , 2 = . , 3 = . , 4 = WUE. , 5 = RXBIMD. , 6 = BRKOVR. , 7 = SENDB. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = R/W/HC. Access, 5 = R/W. Access, 6 = . Access, 7 = R/W R/W/HC. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = . Reset, 7 = 0 0",
    "Bit 7 - ON Serial Port Enable\n1, Description = Serial port enabled. 0, Description = Serial port disabled (held in Reset)",
    "Bit 4 - WUE Wake-Up Enable\n1, Description = Receiver is waiting for falling RX input edge which will set the UxIF bit. Cleared by hardware on wake-up event. Also requires the UxIE bit of PIEx to enable wake.. 0, Description = Receiver operates normally",
    "Bit 3 - RXBIMD Receive Break Interrupt Mode Select\n1, Description = Set RXBKIF immediately when RX in has been low for the minimum Break time. 0, Description = Set RXBKIF on rising RX input after RX in has been low for the minimum Break time",
    "Bit 1 - BRKOVR Send Break Software Override\n1, Description = TX output is forced to non-Idle state. 0, Description = TX output is driven by transmit shift register",
    "Bit 0 - SENDB  Send Break Control (1)\n1, Description = Output Break upon UxTXB write. Written byte follows Break. Bit is cleared by hardware.. 0, Description = Break transmission completed or disabled",
    "Note:\n- 1. This bit is read-only in LIN, DMX and DALI modes.",
    "UART Control Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RUNOVF. , 2 = RXPOL. , 3 = STP[1:0]. , 4 = STP[1:0]. , 5 = C0EN. , 6 = TXPOL. , 7 = FLO[1:0]. , 8 = FLO[1:0]. Access, 1 = R/W. Access, 2 = R/W/HC. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - RUNOVF Run During Overflow Control\n1, Description = RX input shifter continues to synchronize with Start bits after Overflow condition. 0, Description = RX input shifter stops all activity on receiver Overflow condition",
    "Bit 6 - RXPOL Receive Polarity Control\n1, Description = Invert RX polarity, Idle state is low. 0, Description = RX polarity is not inverted, Idle state is high",
    "Bits 5:4 - STP[1:0]  Stop Bit Mode Control (1)\n11, Description = Transmit 2 Stop bits, receiver verifies first Stop bit. 10, Description = Transmit 2 Stop bits, receiver verifies first and second Stop bits. 01, Description = Transmit 1.5 Stop bits, receiver verifies first Stop bit. 00, Description = Transmit 1 Stop bit, receiver verifies first Stop bit",
    "Bit 3 - C0EN  Checksum Mode Select (2)\n1, Condition = MODE = LIN. 1, Description = Enhanced LIN checksum includes PID in sum. 0, Condition = MODE = LIN. 0, Description = Legacy LIN checksum does not include PID in sum. 1, Condition = MODE = not LIN. 1, Description = Checksum is the sum of all TX and RX characters. 0, Condition = MODE = not LIN. 0, Description = Checksum is disabled",
    "Bit 2 - TXPOL  Transmit Control Polarity (1)\n1, Description = Output data are inverted, TX output is low in Idle state. 0, Description = Output data are not inverted, TX output is high in Idle state",
    "Bits 1:0 - FLO[1:0] Handshake Flow Control\n11, Description = Reserved. 10, Description = RTS/CTS and TXDE Hardware flow control. 01, Description = XON/XOFF Software flow control. 00, Description = Flow control is off",
    "Notes:\n1. All modes transmit selected number of Stop bits.\n2. Full-featured UARTs only.",
    "Name: UxERRIR\nUART Error Interrupt Flag Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXMTIF. , 2 = PERIF. , 3 = ABDOVF. , 4 = CERIF. , 5 = FERIF. , 6 = RXBKIF. , 7 = RXFOIF. , 8 = TXCIF. Access, 1 = R/S/C. Access, 2 = R/W/HC. Access, 3 = R/W/S. Access, 4 = R/W/S. Access, 5 = R/S/C. Access, 6 = R/W/S. Access, 7 = R/W/S. Access, 8 = R/W/S. Reset, 1 = 1. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - TXMTIF Transmit Shift Register Empty Interrupt Flag\n1, Description = Transmit shift register is empty (Set at end of Stop bits). 0, Description = Transmit shift register is actively shifting data",
    "Bit 6 - PERIF Parity Error Interrupt Flag\n1, Condition = MODE = LIN or Parity. 1, Description = Unread byte at top of input FIFO has parity error. 0, Condition = MODE = LIN or Parity. 0, Description = Unread byte at top of input FIFO does not have parity error. 1, Condition = MODE = DALI Device. 1, Description = Unread byte at top of input FIFO received as Forward Frame. 0, Condition = MODE = DALI Device. 0, Description = Unread byte at top of input FIFO received as Back Frame. 1, Condition = MODE = Address. 1, Description = Unread byte at top of input FIFO received as address. 0, Condition = MODE = Address. 0, Description = Unread byte at top of input FIFO received as data. x, Condition = MODE = All others. x, Description = Not used",
    "Bit 5 - ABDOVF Auto-baud Detect Overflow Interrupt Flag\n1, Condition = MODE = DALI. 1, Description = Start bit measurement overflowed counter. 0, Condition = MODE = DALI. 0, Description = No overflow during Start bit measurement. 1, Condition = MODE = All others. 1, Description = Baud Rate Generator overflowed during the auto-detection sequence. 0, Condition = MODE = All others. 0, Description = Baud Rate Generator has not overflowed",
    "Bit 4 - CERIF Checksum Error Interrupt Flag\n1, Condition = MODE = DALI. 1, Description = Stop bit detected. 0, Condition = MODE = DALI. 0, Description = Stop bit not detected. x, Condition = MODE = not DALI. x, Description = Not used",
    "Bit 3 - FERIF Framing Error Interrupt Flag\n1, Description = Unread byte at top of input FIFO has framing error. 0, Description = Unread byte at top of input FIFO does not have framing error",
    "Bit 2 - RXBKIF Break Reception Interrupt Flag\n1, Description = Break detected. 0, Description = No break detected",
    "Bit 1 - RXFOIF Receive FIFO Overflow Interrupt Flag\n1, Description = Receive FIFO has overflowed. 0, Description = Receive FIFO has not overflowed",
    "Bit 0 - TXCIF  Transmit Collision Interrupt Flag (1)\n1, Description = Transmitted word is not equal to the word received during transmission. 0, Description = Transmitted word equals the word received during transmission",
    "Note:\n- 1. Full-featured UARTs only.",
    "UART Error Interrupt Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXMTIE. , 2 = PERIE. , 3 = ABDOVE. , 4 = CERIE. , 5 = FERIE. , 6 = RXBKIE. , 7 = RXFOIE. , 8 = TXCIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - TXMTIE Transmit Shift Register Empty Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 6 - PERIE Parity Error Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 5 - ABDOVE Auto-baud Detect Overflow Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 4 - CERIE Checksum Error Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 3 - FERIE Framing Error Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 2 - RXBKIE Break Reception Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 1 - RXFOIE Receive FIFO Overflow Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 0 - TXCIE  Transmit Collision Interrupt Enable (1)\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Note:\n- 1. Full-featured UARTs only.",
    "34.20.6  UxUIR\nName:\nUxUIR 0x2B1,0x2C4,0x2D7\nAddress:",
    "UART General Interrupt Flag Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WUIF. , 2 = ABDIF. , 3 = . , 4 = . , 5 = . , 6 = ABDIE. , 7 = . , 8 = . Access, 1 = R/W/S. Access, 2 = R/W/S. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = . Reset, 8 = ",
    "Bit 7 - WUIF Wake-Up Interrupt\n1, Description = Idle to non-Idle transition on RX line detected when WUE is set. Also sets UxIF. (WUIF must be cleared by software to clear UxIF). 0, Description = WUE not enabled by software or no transition detected",
    "Bit 6 - ABDIF Auto-Baud Detect Interrupt\n1, Description = Auto-baud detection complete. Status shown in UxIF when ABDIE is set. (Must be cleared by software). 0, Description = Auto-baud not enabled or auto-baud enabled and auto-baud detection not complete",
    "Bit 2 - ABDIE Auto-Baud Detect Interrupt Enable\n1, Description = ABDIF will set the UxIF bit in the PIRx register. 0, Description = ABDIF will not set UxIF",
    "34.20.7  UxFIFO\nName: Address:\nUxFIFO 0x2B0,0x2C3,0x2D6",
    "UART FIFO Status Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXWRE. , 2 = STPMD. , 3 = TXBE. , 4 = TXBF. , 5 = RXIDL. , 6 = XON. , 7 = RXBE. , 8 = RXBF. Access, 1 = R/W/S. Access, 2 = R/W. Access, 3 = R/W/S/C. Access, 4 = R/S/C. Access, 5 = R/S/C. Access, 6 = S/C. Access, 7 = R/W/S/C. Access, 8 = R/S/C. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 1. Reset, 4 = 0. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 0",
    "Bit 7 - TXWRE Transmit Write Error Status (must be cleared by software)\n1, Condition = MODE = LIN Host. 1, Description = UxP1L was written when a host process was active. 1, Condition = MODE = LIN Client. 1, Description = UxTXB was written when UxP2 = 0 or more than UxP2 bytes have been written to UxTXB since last Break. 1, Condition = MODE = Address detect. 1, Description = UxP1L was written before the previous data in UxP1L was transferred to TX shifter. 1, Condition = MODE = All. 1, Description = A new byte was written to UxTXB when the output FIFO was full. 0, Condition = MODE = All. 0, Description = No error",
    "Bit 6 - STPMD Stop Bit Detection Mode\n1, Condition = STP = 11. 1, Description = Assert UxRXIF at end of first Stop bit. 1, Condition = STP \u2260 11. 1, Description = Assert UxRXIF at end of last Stop bit. 0, Condition = STP = xx. 0, Description = Assert UxRXIF in middle of first Stop bit",
    "Bit 5 - TXBE Transmit Buffer Empty Status\n1, Description = Transmit buffer is empty. Setting this bit will clear the transmit buffer and output shift register.. 0, Description = Transmit buffer is not empty. Software cannot clear this bit.",
    "Bit 4 - TXBF Transmit Buffer Full Status\n1, Description = Transmit buffer is full. 0, Description = Transmit buffer is not full",
    "Bit 3 - RXIDL Receive Pin Idle Status\n1, Description = Receive pin is in Idle state. 0, Description = UART is receiving Start, Stop, Data, Auto-baud, or Break",
    "Bit 2 - XON Software Flow Control Transmit Enable Status\n1, Description = Transmitter is enabled. 0, Description = Transmitter is disabled",
    "Bit 1 - RXBE Receive Buffer Empty Status\n1, Description = Receive buffer is empty. Setting this bit will clear the RX buffer (1) .. 0, Description = Receive buffer is not empty. Software cannot clear this bit.",
    "Bit 0 - RXBF Receive Buffer Full Status\n1, Description = Receive buffer is full. 0, Description = Receive buffer is not full",
    "Note:\n- 1. The BSF instruction will not be used to set RXBE because doing so will clear a byte pending in the transmit shift register when the UxTXB register is empty. Instead, use the MOVWF instruction with a ' 0 ' in the TXBE bit location.",
    "34.20.8  UxBRG\nName: Address:\nUxBRG 0x2AE,0x2C1,0x2D4",
    "UART Baud Rate Generator\nAccess, 15.BRG[15:8] = R/W. Access, 14.BRG[15:8] = R/W. Access, 13.BRG[15:8] = R/W. Access, 12.BRG[15:8] = R/W. Access, 11.BRG[15:8] = R/W. Access, 10.BRG[15:8] = R/W. Access, 9.BRG[15:8] = R/W. Access, 8.BRG[15:8] = R/W. Reset, 15.BRG[15:8] = 0. Reset, 14.BRG[15:8] = 0. Reset, 13.BRG[15:8] = 0. Reset, 12.BRG[15:8] = 0. Reset, 11.BRG[15:8] = 0. Reset, 10.BRG[15:8] = 0. Reset, 9.BRG[15:8] = 0. Reset, 8.BRG[15:8] = 0. Bit,",
    "UART Baud Rate Generator\n15.BRG[15:8] = 7. Bit, 14.BRG[15:8] = 6. Bit, 13.BRG[15:8] = 5. Bit, 12.BRG[15:8] = 4. Bit, 11.BRG[15:8] = 3. Bit, 10.BRG[15:8] = 2. Bit, 9.BRG[15:8] = 1. Bit, 8.BRG[15:8] = 0. , 15.BRG[15:8] = BRG[7:0]. , 14.BRG[15:8] = BRG[7:0]. , 13.BRG[15:8] = BRG[7:0]. , 12.BRG[15:8] = BRG[7:0]. , 11.BRG[15:8] = BRG[7:0]. , 10.BRG[15:8] = BRG[7:0]. , 9.BRG[15:8] = BRG[7:0]. ,",
    "UART Baud Rate Generator\n8.BRG[15:8] = BRG[7:0]. Access, 15.BRG[15:8] = R/W. Access, 14.BRG[15:8] = R/W. Access, 13.BRG[15:8] = R/W. Access, 12.BRG[15:8] = R/W. Access, 11.BRG[15:8] = R/W. Access, 10.BRG[15:8] = R/W. Access, 9.BRG[15:8] = R/W. Access, 8.BRG[15:8] = R/W. Reset, 15.BRG[15:8] = 0. Reset, 14.BRG[15:8] = 0. Reset, 13.BRG[15:8] = 0. Reset, 12.BRG[15:8] = 0. Reset, 11.BRG[15:8] = 0. Reset, 10.BRG[15:8] = 0. Reset, 9.BRG[15:8] = 0. Reset,",
    "UART Baud Rate Generator\n8.BRG[15:8] = 0",
    "Bits 15:0 - BRG[15:0] Baud Rate Generator Value\nThe UART Baud Rate equals [Fosc*(1+(BRGS*3)]/[(16*(BRG+1))]",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-UxBRGH: Accesses the high byte BRG[15:8]\n-UxBRGL: Accesses the low byte BRG[7:0]\n2. The UxBRG registers will only be written when ON = 0 .\n3. Maximum BRG value when MODE = '100x and BRGS = 1 is 0x7FFE .\n4. Maximum BRG value when MODE = '100x and BRGS = 0 is 0x1FFE .",
    "34.20.9  UxRXB\nName:\nUxRXB\nAddress:\n0x2A1,0x2B4,0x2C7\nUART Receive Register",
    "34.20.9  UxRXB\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RXB[7:0]. , 2 = RXB[7:0]. , 3 = RXB[7:0]. , 4 = RXB[7:0]. , 5 = RXB[7:0]. , 6 = RXB[7:0]. , 7 = RXB[7:0]. , 8 = RXB[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "34.20.9  UxRXB\nBits 7:0 - RXB[7:0] Top of Receive FIFO",
    "34.20.10 UxTXB\nName:\nUxTXB\nAddress:\n0x2A3,0x2B6,0x2C9\nUART Transmit Register",
    "34.20.10 UxTXB\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXB[7:0]. , 2 = TXB[7:0]. , 3 = TXB[7:0]. , 4 = TXB[7:0]. , 5 = TXB[7:0]. , 6 = TXB[7:0]. , 7 = TXB[7:0]. , 8 = TXB[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "34.20.10 UxTXB\nBits 7:0 - TXB[7:0] Bottom of Transmit FIFO",
    "34.20.11 UxP1\nName:\nUxP1",
    "34.20.11 UxP1\nAccess, 15 = . Access, 14 = . Access, 13 = . Access, 12 = . Access, 11 = . Access, 10 = . Access, 9 = . Access, 8 = P1[8]. Reset, 15 = . Reset, 14 = . Reset, 13 = . Reset, 12 = . Reset, 11 = . Reset, 10 = . Reset, 9 = . Reset, 8 = R/W 0. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = P1[7:0]. , 14 = P1[7:0]. , 13 = P1[7:0]. , 12 = P1[7:0]. , 11 = P1[7:0]. , 10 = P1[7:0]. , 9 = P1[7:0]. , 8 = P1[7:0]. Access, 15 = R/W. Access, 14 = R/W. Access, 13 =",
    "34.20.11 UxP1\nR/W. Access, 12 = R/W. Access, 11 = R/W. Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = 0. Reset, 14 = 0. Reset, 13 = 0. Reset, 12 = 0. Reset, 11 = 0. Reset, 10 = 0. Reset, 9 = 0. Reset, 8 = 0",
    "Bit 8 - P1[8] Parameter 1 Most Significant bit UART mode operating parameter values\nn, Condition = MODE = DMX. n, Description = Most Significant bit of number of bytes to transmit between Start Code and automatic Break generation. n, Condition = MODE = DALI Control Device. n, Description = Most Significant bit of Idle time delay after which a Forward Frame is sent. Measured in half-bit periods.. n, Condition = MODE = DALI Control Gear. n, Description = Most Significant bit of delay between the end of a Forward Frame and the start of the Back Frame. Measured in half-bit periods.. x, Condition = All other modes/Limited featured UART. x, Description = Not used",
    "Bits 7:0 - P1[7:0] Parameter 1 Least Significant bits UART mode operating parameter values\nn, Condition = MODE = DMX. n, Description = Least Significant bits of number of bytes to transmit between Start Code and automatic Break generation. n, Condition = MODE = DALI Control Device. n, Description = Least Significant bits of Idle time delay after which a Forward Frame is sent. Measured in half-bit periods.. n, Condition = MODE = DALI Control Gear. n, Description = Least Significant bits of delay between the end of a Forward Frame and the start of the Back Frame. Measured in half-bit periods.. n, Condition = MODE = LIN. n, Description = PID to transmit (Only Least Significant six bits used). n, Condition = MODE = Asynchronous Address. n, Description = Address to transmit (9th transmit bit automatically set to ' 1 '). x, Condition = All other modes. x, Description = Not used\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:",
    "Bits 7:0 - P1[7:0] Parameter 1 Least Significant bits UART mode operating parameter values\n\u00b7 UxP1H: Accesses the high byte P1[8]\n\u00b7 UxP1L: Accesses the low byte P1[7:0]",
    "34.20.12 UxP2\nName:\nUxP2",
    "34.20.12 UxP2\nAccess, 15 = . Access, 14 = . Access, 13 = . Access, 12 = . Access, 11 = . Access, 10 = . Access, 9 = . Access, 8 = P2[8]. Reset, 15 = . Reset, 14 = . Reset, 13 = . Reset, 12 = . Reset, 11 = . Reset, 10 = . Reset, 9 = . Reset, 8 = R/W 0. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = P2[7:0]. , 14 = P2[7:0]. , 13 = P2[7:0]. , 12 = P2[7:0]. , 11 = P2[7:0]. , 10 = P2[7:0]. , 9 = P2[7:0]. , 8 = P2[7:0]. Access, 15 = R/W. Access, 14 = R/W. Access, 13 =",
    "34.20.12 UxP2\nR/W. Access, 12 = R/W. Access, 11 = R/W. Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = 0. Reset, 14 = 0. Reset, 13 = 0. Reset, 12 = 0. Reset, 11 = 0. Reset, 10 = 0. Reset, 9 = 0. Reset, 8 = 0",
    "Bit 8 - P2[8] Parameter 2 Most Significant bit UART mode operating parameter values\nn, Condition = MODE = DMX. n, Description = Most Significant bit of first address of receive block. n, Condition = MODE = DALI. n, Description = Most Significant bit of number of half-bit periods of Idle time in Forward Frame detection threshold. x, Condition = All other modes/Limited featured UART. x, Description = Not used",
    "Bits 7:0 - P2[7:0] Parameter 2 Least Significant bits UART mode operating parameter values\nn, Condition = MODE = DMX. n, Description = Least Significant bits of first address of receive block. n, Condition = MODE = DALI. n, Description = Least Significant bits of number of half-bit periods of Idle time in Forward Frame detection threshold. n, Condition = MODE = LIN. n, Description = Number of data bytes to transmit. n, Condition = MODE = Asynchronous Address. n, Description = Receiver address. x, Condition = All other modes. x, Description = Not used\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 UxP2H: Accesses the high byte P2[8]\n\u00b7 UxP2L: Accesses the low byte P2[7:0]",
    "34.20.13 UxP3\nName:\nUxP3",
    "34.20.13 UxP3\nAccess, 15 = . Access, 14 = . Access, 13 = . Access, 12 = . Access, 11 = . Access, 10 = . Access, 9 = . Access, 8 = P3[8]. Reset, 15 = . Reset, 14 = . Reset, 13 = . Reset, 12 = . Reset, 11 = . Reset, 10 = . Reset, 9 = . Reset, 8 = R/W 0. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = P3[7:0]. , 14 = P3[7:0]. , 13 = P3[7:0]. , 12 = P3[7:0]. , 11 = P3[7:0]. , 10 = P3[7:0]. , 9 = P3[7:0]. , 8 = P3[7:0]. Access, 15 = R/W. Access, 14 = R/W. Access, 13 =",
    "34.20.13 UxP3\nR/W. Access, 12 = R/W. Access, 11 = R/W. Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = 0. Reset, 14 = 0. Reset, 13 = 0. Reset, 12 = 0. Reset, 11 = 0. Reset, 10 = 0. Reset, 9 = 0. Reset, 8 = 0",
    "Bit 8 - P3[8] Parameter 3 Most Significant bit UART mode operating parameter values\nn, Condition = MODE = DMX. n, Description = Most Significant bit of last address of receive block. x, Condition = All other modes/Limited featured UART. x, Description = Not used",
    "Bits 7:0 - P3[7:0] Parameter 3 Least Significant bits UART mode operating parameter values\nn, Condition = MODE = DMX. n, Description = Least Significant bits of last address of receive block. n, Condition = MODE = LIN Client. n, Description = Number of data bytes to receive. n, Condition = MODE = Asynchronous Address. n, Description = Receiver address mask. Received address is XOR'd with UxP2L, then AND'd with UxP3L. Match occurs when result is zero.. x, Condition = All other modes. x, Description = Not used\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 UxP3H: Accesses the high byte P3[8]\n\u00b7 UxP3L: Accesses the low byte P3[7:0]",
    "34.20.14 UxTXCHK\nName: Address:\nUxTXCHK\n0x02A4",
    "UART Transmit Checksum Result Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXCHK[7:0]. , 2 = TXCHK[7:0]. , 3 = TXCHK[7:0]. , 4 = TXCHK[7:0]. , 5 = TXCHK[7:0]. , 6 = TXCHK[7:0]. , 7 = TXCHK[7:0]. , 8 = TXCHK[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "UART Transmit Checksum Result Register\n0. Reset, 8 = 0",
    "Bits 7:0 - TXCHK[7:0] Transmit Checksum Value\nn, Condition = MODE = LIN and C0EN = 1. n, Description = Sum of all transmitted bytes including PID. n, Condition = MODE = LIN and C0EN = 0. n, Description = Sum of all transmitted bytes except PID. n, Condition = MODE = All others and C0EN = 1. n, Description = Sum of all transmitted bytes since last clear. x, Condition = MODE = All others and C0EN = 0. x, Description = Not used",
    "34.20.15 UxRXCHK\nName: Address:\nUxRXCHK\n0x02A2",
    "UART Receive Checksum Result Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RXCHK[7:0]. , 2 = RXCHK[7:0]. , 3 = RXCHK[7:0]. , 4 = RXCHK[7:0]. , 5 = RXCHK[7:0]. , 6 = RXCHK[7:0]. , 7 = RXCHK[7:0]. , 8 = RXCHK[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6",
    "UART Receive Checksum Result Register\n= 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - RXCHK[7:0] Receive Checksum Value\nn, Condition = MODE = LIN and C0EN = 1. n, Description = Sum of all received bytes including PID. n, Condition = MODE = LIN and C0EN = 0. n, Description = Sum of all received bytes except PID. n, Condition = MODE = All others and C0EN = 1. n, Description = Sum of all received bytes since last clear. x, Condition = MODE = All others and C0EN = 0. x, Description = Not used",
    "34.21 Register Summary - UART\n0x00, Name = . 0x00, Bit Pos. = . 0x00, 7 = . 0x00, 6 = . 0x00, 5 = . 0x00, 4 = . 0x00, 3 = . 0x00, 2 = . 0x00, 1 = . 0x00, 0 = . ... 0x02A0, Name = Reserved. ... 0x02A0, Bit Pos. = . ... 0x02A0, 7 = . ... 0x02A0, 6 = . ... 0x02A0, 5 = . ... 0x02A0, 4 = . ... 0x02A0, 3 = . ... 0x02A0, 2 = . ... 0x02A0, 1 = . ... 0x02A0, 0 = . 0x02A1, Name = U1RXB. 0x02A1, Bit Pos. = 7:0. 0x02A1, 7 = .",
    "34.21 Register Summary - UART\n0x02A1, 6 = . 0x02A1, 5 = . 0x02A1, 4 = RXB[7:0]. 0x02A1, 3 = . 0x02A1, 2 = . 0x02A1, 1 = . 0x02A1, 0 = . 0x02A2, Name = U1RXCHK. 0x02A2, Bit Pos. = 7:0. 0x02A2, 7 = . 0x02A2, 6 = . 0x02A2, 5 = . 0x02A2, 4 = RXCHK[7:0]. 0x02A2, 3 = . 0x02A2, 2 = . 0x02A2, 1 = . 0x02A2, 0 = . 0x02A3, Name = U1TXB. 0x02A3, Bit Pos. = 7:0. 0x02A3, 7 = . 0x02A3, 6 = .",
    "34.21 Register Summary - UART\n0x02A3, 5 = . 0x02A3, 4 = TXB[7:0]. 0x02A3, 3 = . 0x02A3, 2 = . 0x02A3, 1 = . 0x02A3, 0 = . 0x02A4, Name = U1TXCHK. 0x02A4, Bit Pos. = 7:0. 0x02A4, 7 = . 0x02A4, 6 = . 0x02A4, 5 = . 0x02A4, 4 = TXCHK[7:0]. 0x02A4, 3 = . 0x02A4, 2 = . 0x02A4, 1 = . 0x02A4, 0 = . 0x02A5, Name = U1P1. 0x02A5, Bit Pos. = 7:0 15:8. 0x02A5, 7 = . 0x02A5, 6 = . 0x02A5, 5",
    "34.21 Register Summary - UART\n= . 0x02A5, 4 = P1[7:0]. 0x02A5, 3 = . 0x02A5, 2 = . 0x02A5, 1 = . 0x02A5, 0 = P1[8]. 0x02A7, Name = U1P2. 0x02A7, Bit Pos. = 7:0 15:8. 0x02A7, 7 = . 0x02A7, 6 = . 0x02A7, 5 = . 0x02A7, 4 = P2[7:0]. 0x02A7, 3 = . 0x02A7, 2 = . 0x02A7, 1 = . 0x02A7, 0 = P2[8]. 0x02A9, Name = U1P3. 0x02A9, Bit Pos. = 7:0 15:8. 0x02A9, 7 = . 0x02A9, 6 = .",
    "34.21 Register Summary - UART\n0x02A9, 5 = . 0x02A9, 4 = P3[7:0]. 0x02A9, 3 = . 0x02A9, 2 = . 0x02A9, 1 = . 0x02A9, 0 = P3[8]. 0x02AB, Name = U1CON0. 0x02AB, Bit Pos. = 7:0. 0x02AB, 7 = BRGS. 0x02AB, 6 = ABDEN. 0x02AB, 5 = TXEN. 0x02AB, 4 = RXEN. 0x02AB, 3 = . 0x02AB, 2 = MODE[3:0]. 0x02AB, 1 = MODE[3:0]. 0x02AB, 0 = . 0x02AC, Name = U1CON1. 0x02AC, Bit Pos. = 7:0. 0x02AC, 7 = ON. 0x02AC, 6 = . 0x02AC, 5 =",
    "34.21 Register Summary - UART\n. 0x02AC, 4 = WUE. 0x02AC, 3 = RXBIMD. 0x02AC, 2 = . 0x02AC, 1 = BRKOVR. 0x02AC, 0 = SENDB. 0x02AD, Name = U1CON2. 0x02AD, Bit Pos. = 7:0. 0x02AD, 7 = RUNOVF. 0x02AD, 6 = RXPOL. 0x02AD, 5 = STP[1:0]. 0x02AD, 4 = STP[1:0]. 0x02AD, 3 = C0EN. 0x02AD, 2 = TXPOL. 0x02AD, 1 = FLO[1:0]. 0x02AD, 0 = FLO[1:0]. 0x02AE, Name = U1BRG. 0x02AE, Bit Pos. = 7:0. 0x02AE, 7 = . 0x02AE, 6 = . 0x02AE,",
    "34.21 Register Summary - UART\n5 = . 0x02AE, 4 = BRG[7:0]. 0x02AE, 3 = . 0x02AE, 2 = . 0x02AE, 1 = . 0x02AE, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = BRG[15:8]. , 3 = . , 2 = . , 1 = . , 0 = . 0x02B0, Name = U1FIFO. 0x02B0, Bit Pos. = 7:0. 0x02B0, 7 = TXWRE. 0x02B0, 6 = STPMD. 0x02B0, 5 = TXBE. 0x02B0, 4 = TXBF. 0x02B0, 3 = RXIDL. 0x02B0, 2 = XON. 0x02B0, 1 = RXBE. 0x02B0, 0 = RXBF. 0x02B1, Name =",
    "34.21 Register Summary - UART\nU1UIR. 0x02B1, Bit Pos. = 7:0. 0x02B1, 7 = WUIF. 0x02B1, 6 = ABDIF. 0x02B1, 5 = . 0x02B1, 4 = . 0x02B1, 3 = . 0x02B1, 2 = ABDIE. 0x02B1, 1 = . 0x02B1, 0 = . 0x02B2, Name = U1ERRIR. 0x02B2, Bit Pos. = 7:0. 0x02B2, 7 = TXMTIF. 0x02B2, 6 = PERIF. 0x02B2, 5 = ABDOVF. 0x02B2, 4 = CERIF. 0x02B2, 3 = FERIF. 0x02B2, 2 = RXBKIF. 0x02B2, 1 = RXFOIF. 0x02B2, 0 = TXCIF.",
    "34.21 Register Summary - UART\n0x02B3, Name = U1ERRIE. 0x02B3, Bit Pos. = 7:0. 0x02B3, 7 = TXMTIE. 0x02B3, 6 = PERIE. 0x02B3, 5 = ABDOVE. 0x02B3, 4 = CERIE. 0x02B3, 3 = FERIE. 0x02B3, 2 = RXBKIE. 0x02B3, 1 = RXFOIE. 0x02B3, 0 = TXCIE. 0x02B4, Name = U2RXB. 0x02B4, Bit Pos. = 7:0. 0x02B4, 7 = . 0x02B4, 6 = . 0x02B4, 5 = . 0x02B4, 4 = RXB[7:0]. 0x02B4, 3 = . 0x02B4, 2 = . 0x02B4, 1 = . 0x02B4, 0 =",
    "34.21 Register Summary - UART\n. 0x02B5, Name = Reserved. 0x02B5, Bit Pos. = . 0x02B5, 7 = . 0x02B5, 6 = . 0x02B5, 5 = . 0x02B5, 4 = . 0x02B5, 3 = . 0x02B5, 2 = . 0x02B5, 1 = . 0x02B5, 0 = . 0x02B6, Name = U2TXB. 0x02B6, Bit Pos. = 7:0. 0x02B6, 7 = . 0x02B6, 6 = . 0x02B6, 5 = . 0x02B6, 4 = TXB[7:0]. 0x02B6, 3 = . 0x02B6, 2 = . 0x02B6, 1 = . 0x02B6, 0 = . 0x02B7, Name = Reserved U2P1. 0x02B7, Bit Pos. =",
    "34.21 Register Summary - UART\n7:0. 0x02B7, 7 = . 0x02B7, 6 = . 0x02B7, 5 = . 0x02B7, 4 = P1[7:0]. 0x02B7, 3 = . 0x02B7, 2 = . 0x02B7, 1 = . 0x02B7, 0 = . 0x02B8, Name = U2P2. 0x02B8, Bit Pos. = 15:8 7:0. 0x02B8, 7 = . 0x02B8, 6 = . 0x02B8, 5 = . 0x02B8, 4 = P2[7:0]. 0x02B8, 3 = . 0x02B8, 2 = . 0x02B8, 1 = . 0x02B8, 0 = . 0x02BA, Name = . 0x02BA, Bit Pos. = 15:8 7:0. 0x02BA, 7 = .",
    "34.21 Register Summary - UART\n0x02BA, 6 = . 0x02BA, 5 = . 0x02BA, 4 = P3[7:0]. 0x02BA, 3 = . 0x02BA, 2 = . 0x02BA, 1 = . 0x02BA, 0 = . 0x02BC, Name = U2P3. 0x02BC, Bit Pos. = 15:8. 0x02BC, 7 = . 0x02BC, 6 = . 0x02BC, 5 = . 0x02BC, 4 = . 0x02BC, 3 = . 0x02BC, 2 = . 0x02BC, 1 = . 0x02BC, 0 = . 0x02BE, Name = U2CON0. 0x02BE, Bit Pos. = 7:0. 0x02BE, 7 = BRGS. 0x02BE, 6 = ABDEN. 0x02BE, 5 = TXEN. 0x02BE, 4 = RXEN. 0x02BE, 3",
    "34.21 Register Summary - UART\n= . 0x02BE, 2 = MODE[3:0]. 0x02BE, 1 = MODE[3:0]. 0x02BE, 0 = MODE[3:0]. 0x02BF, Name = U2CON1. 0x02BF, Bit Pos. = 7:0. 0x02BF, 7 = ON. 0x02BF, 6 = . 0x02BF, 5 = . 0x02BF, 4 = WUE. 0x02BF, 3 = RXBIMD. 0x02BF, 2 = . 0x02BF, 1 = BRKOVR. 0x02BF, 0 = SENDB. 0x02C0, Name = U2CON2. 0x02C0, Bit Pos. = 7:0. 0x02C0, 7 = RUNOVF. 0x02C0, 6 = RXPOL. 0x02C0, 5 = STP[1:0]. 0x02C0, 4 = STP[1:0].",
    "34.21 Register Summary - UART\n0x02C0, 3 = . 0x02C0, 2 = TXPOL. 0x02C0, 1 = FLO[1:0]. 0x02C0, 0 = FLO[1:0]. 0x02C1, Name = U2BRG. 0x02C1, Bit Pos. = 7:0. 0x02C1, 7 = . 0x02C1, 6 = . 0x02C1, 5 = . 0x02C1, 4 = BRG[7:0]. 0x02C1, 3 = . 0x02C1, 2 = . 0x02C1, 1 = . 0x02C1, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = BRG[15:8]. , 3 = . , 2 = . , 1 = . , 0 = . 0x02C3, Name = U2FIFO. 0x02C3, Bit",
    "34.21 Register Summary - UART\nPos. = 7:0. 0x02C3, 7 = TXWRE. 0x02C3, 6 = STPMD. 0x02C3, 5 = TXBE. 0x02C3, 4 = TXBF. 0x02C3, 3 = RXIDL. 0x02C3, 2 = XON. 0x02C3, 1 = RXBE. 0x02C3, 0 = RXBF. 0x02C4, Name = U2UIR. 0x02C4, Bit Pos. = 7:0. 0x02C4, 7 = WUIF. 0x02C4, 6 = ABDIF. 0x02C4, 5 = . 0x02C4, 4 = . 0x02C4, 3 = . 0x02C4, 2 = ABDIE. 0x02C4, 1 = . 0x02C4, 0 = . 0x02C5, Name = U2ERRIR. 0x02C5, Bit",
    "34.21 Register Summary - UART\nPos. = 7:0. 0x02C5, 7 = TXMTIF. 0x02C5, 6 = PERIF. 0x02C5, 5 = ABDOVF. 0x02C5, 4 = CERIF. 0x02C5, 3 = FERIF. 0x02C5, 2 = RXBKIF. 0x02C5, 1 = RXFOIF. 0x02C5, 0 = . 0x02C6, Name = U2ERRIE. 0x02C6, Bit Pos. = 7:0. 0x02C6, 7 = TXMTIE. 0x02C6, 6 = PERIE. 0x02C6, 5 = ABDOVE. 0x02C6, 4 = CERIE. 0x02C6, 3 = FERIE. 0x02C6, 2 = RXBKIE. 0x02C6, 1 = RXFOIE. 0x02C6, 0 = . 0x02C7, Name =",
    "34.21 Register Summary - UART\nU3RXB. 0x02C7, Bit Pos. = 7:0. 0x02C7, 7 = . 0x02C7, 6 = . 0x02C7, 5 = . 0x02C7, 4 = RXB[7:0]. 0x02C7, 3 = . 0x02C7, 2 = . 0x02C7, 1 = . 0x02C7, 0 = . 0x02C8, Name = Reserved. 0x02C8, Bit Pos. = . 0x02C8, 7 = . 0x02C8, 6 = . 0x02C8, 5 = . 0x02C8, 4 = . 0x02C8, 3 = . 0x02C8, 2 = . 0x02C8, 1 = . 0x02C8, 0 = . 0x02C9, Name = U3TXB. 0x02C9, Bit Pos. = 7:0.",
    "34.21 Register Summary - UART\n0x02C9, 7 = . 0x02C9, 6 = . 0x02C9, 5 = . 0x02C9, 4 = TXB[7:0]. 0x02C9, 3 = . 0x02C9, 2 = . 0x02C9, 1 = . 0x02C9, 0 = . 0x02CA, Name = Reserved. 0x02CA, Bit Pos. = . 0x02CA, 7 = . 0x02CA, 6 = . 0x02CA, 5 = . 0x02CA, 4 = . 0x02CA, 3 = . 0x02CA, 2 = . 0x02CA, 1 = . 0x02CA, 0 = . 0x02CB, Name = U3P1. 0x02CB, Bit Pos. = 7:0 15:8. 0x02CB, 7 = . 0x02CB, 6 = . 0x02CB, 5 = . 0x02CB, 4 =",
    "34.21 Register Summary - UART\nP1[7:0]. 0x02CB, 3 = . 0x02CB, 2 = . 0x02CB, 1 = . 0x02CB, 0 = . 0x02CD, Name = U3P2. 0x02CD, Bit Pos. = 7:0 15:8. 0x02CD, 7 = . 0x02CD, 6 = . 0x02CD, 5 = . 0x02CD, 4 = P2[7:0]. 0x02CD, 3 = . 0x02CD, 2 = . 0x02CD, 1 = . 0x02CD, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = P3[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x02CF, Name = U3P3. 0x02CF, Bit Pos. = 15:8. 0x02CF, 7 = .",
    "34.21 Register Summary - UART\n0x02CF, 6 = . 0x02CF, 5 = . 0x02CF, 4 = . 0x02CF, 3 = . 0x02CF, 2 = . 0x02CF, 1 = . 0x02CF, 0 = . 0x02D1, Name = U3CON0. 0x02D1, Bit Pos. = 7:0. 0x02D1, 7 = BRGS. 0x02D1, 6 = ABDEN. 0x02D1, 5 = TXEN. 0x02D1, 4 = RXEN. 0x02D1, 3 = . 0x02D1, 2 = MODE[3:0]. 0x02D1, 1 = MODE[3:0]. 0x02D1, 0 = . 0x02D2, Name = U3CON1. 0x02D2, Bit Pos. = 7:0. 0x02D2, 7 = ON.",
    "34.21 Register Summary - UART\n0x02D2, 6 = . 0x02D2, 5 = . 0x02D2, 4 = WUE. 0x02D2, 3 = RXBIMD. 0x02D2, 2 = . 0x02D2, 1 = BRKOVR. 0x02D2, 0 = SENDB. 0x02D3, Name = U3CON2. 0x02D3, Bit Pos. = 7:0. 0x02D3, 7 = RUNOVF. 0x02D3, 6 = RXPOL. 0x02D3, 5 = . 0x02D3, 4 = STP[1:0]. 0x02D3, 3 = . 0x02D3, 2 = TXPOL. 0x02D3, 1 = . 0x02D3, 0 = FLO[1:0]. , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 =",
    "34.21 Register Summary - UART\nBRG[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x02D4, Name = U3BRG. 0x02D4, Bit Pos. = 15:8. 0x02D4, 7 = . 0x02D4, 6 = . 0x02D4, 5 = . 0x02D4, 4 = BRG[15:8]. 0x02D4, 3 = . 0x02D4, 2 = . 0x02D4, 1 = . 0x02D4, 0 = . 0x02D6, Name = U3FIFO. 0x02D6, Bit Pos. = 7:0. 0x02D6, 7 = TXWRE. 0x02D6, 6 = STPMD. 0x02D6, 5 = TXBE. 0x02D6, 4 = TXBF. 0x02D6, 3 = RXIDL. 0x02D6, 2 = XON.",
    "34.21 Register Summary - UART\n0x02D6, 1 = RXBE. 0x02D6, 0 = RXBF. 0x02D7, Name = U3UIR. 0x02D7, Bit Pos. = 7:0. 0x02D7, 7 = WUIF. 0x02D7, 6 = ABDIF. 0x02D7, 5 = . 0x02D7, 4 = . 0x02D7, 3 = . 0x02D7, 2 = ABDIE. 0x02D7, 1 = . 0x02D7, 0 = . 0x02D8, Name = U3ERRIR. 0x02D8, Bit Pos. = 7:0. 0x02D8, 7 = TXMTIF. 0x02D8, 6 = PERIF. 0x02D8, 5 = ABDOVF. 0x02D8, 4 = CERIF. 0x02D8, 3 = FERIF. 0x02D8, 2 =",
    "34.21 Register Summary - UART\nRXBKIF. 0x02D8, 1 = RXFOIF. 0x02D8, 0 = \n...........continued\n0x02D9, Name = U3ERRIE. 0x02D9, Bit Pos. = 7:0. 0x02D9, 7 = TXMTIE. 0x02D9, 6 = PERIE. 0x02D9, 5 = ABDOVE. 0x02D9, 4 = CERIE. 0x02D9, 3 = FERIE. 0x02D9, 2 = RXBKIE. 0x02D9, 1 = RXFOIE",
    "35. SPI - Serial Peripheral Interface Module\nThe Serial Peripheral Interface (SPI) module is a synchronous serial data communication bus that operates in Full Duplex mode. Devices communicate in a host/client environment where the host device initiates the communication. A client device is typically controlled through a chip select known as Client Select. Some examples of client devices include serial EEPROMs, shift registers, display drivers, A/D converters and other PIC  devices with SPI capabilities. \u00ae\nThe SPI bus specifies four signal connections:\n\u00b7 Serial Clock (SCK)\n\u00b7 Serial Data Out (SDO)\n\u00b7 Serial Data In (SDI)\n\u00b7 Client Select (SS)\nThe following figure shows the block diagram of the SPI module.\nFigure 35-1. SPI Module Simplified Block Diagram\nData bus\nNote: 1 If the transmit FIFO is empty and TXR = . 1 , the previous value of the receive shift register will be sent to the transmit serializer.\nThe SPI transmit output (SDO_out) is available to the remappable PPS SDO pin and internally to the select peripherals.",
    "35. SPI - Serial Peripheral Interface Module\nThe SPI bus typically operates with a single host device and one or more client devices. When multiple client devices are used, an independent Client Select connection is required from the host device to each client device.\nThe host selects only one client at a time. Most client devices have tri-state outputs so their output signal appears disconnected from the bus when they are not selected.\nTransmissions typically involve Shift registers, eight bits in size, one in the host and one in the client. With either the host or the client device, data are shifted out one bit at a time, with the Most Significant bit (MSb) shifted out first. At the same time, a new bit is shifted into the device. Unlike older Microchip devices, the SPI module on this device contains one register for incoming data and another register for outgoing data. Both registers also have multibyte FIFO buffers and allow for DMA bus connections.\nThe figure below shows a typical connection between two devices configured as host and client devices.\nFigure 35-2. SPI Host/Client Connection with FIFOs\nNotes: 1  In some modes, if the Transmit FIFO is empty, the most recently received byte of data will be .\ntransmitted.",
    "35. SPI - Serial Peripheral Interface Module\n2. This diagram assumes that the LSBF bit is cleared (communications are MSb-first). When LSBF is set, the communications will be LSb-first.\nData are shifted out of the transmit FIFO on the programmed clock edge and into the receive Shift register on the opposite edge of the clock.\nThe host device transmits information on its SDO output pin, which is connected to and received by the client's SDI input pin. The client device transmits information on its SDO output pin, which is connected to, and received by, the host's SDI input pin.\nThe host device sends out the clock signal. Both the host and the client devices need to be configured for the same clock phase and clock polarity.",
    "35. SPI - Serial Peripheral Interface Module\nDuring each SPI clock cycle, a full-duplex data transmission occurs. This means that while the host device is sending out the MSb from its output register (on its SDO pin) and the client device is reading this bit and saving it as the LSb of its input register. The client device is also sending out the MSb from its Shift register (on its SDO pin) and the host device is reading this bit and saving it as the LSb of its input register.\nAfter eight bits have been shifted out, the host and client have exchanged register values and stored the incoming data into the receiver FIFOs.\nIf there is more data to exchange, the registers are loaded with new data and the process repeats.\nWhether the data are meaningful or not (dummy data) depends on the application software. This leads to three scenarios for data transmission:\n\u00b7 Host sends useful data and client sends dummy data\n\u00b7 Host sends useful data and client sends useful data\n\u00b7 Host sends dummy data and client sends useful data",
    "35. SPI - Serial Peripheral Interface Module\nIn this SPI module, dummy data may be sent without software involvement. Dummy transmit data are automatically handled by clearing the TXR bit and receive data are ignored by clearing the RXR bit. See Table 35-1 as well as Host Mode and Client Mode for further TXR/RXR setting details.\nThis SPI module can send transmissions of any number of bits and can send information in segments of varying size (from 1-8 bits in width). As such, transmissions may involve any number of clock cycles, depending on the amount of data to be transmitted.\nWhen there is no more data to be transmitted, the host stops sending the clock signal and deselects the client. Every client device connected to the bus that has not been selected through its Client Select line disregards the clock and transmission signals and does not transmit out any data of its own.",
    "35.1 SPI Controls\nThe following registers control the SPI operation:\n\u00b7 SPI Interrupt Flag (SPIxINTF) Register\n\u00b7 SPI Interrupt Enable (SPIxINTE) Register\n\u00b7 SPI Byte Count High and Low (SPIxTCNTH/L) Registers\n\u00b7 SPI Bit Count (SPIxTWIDTH) Register\n\u00b7 SPI Baud Rate (SPIxBAUD) Register\n\u00b7 SPI Control (SPIxCON0) Register 0\n\u00b7 SPI Control (SPIxCON1) Register 1\n\u00b7 SPI Control (SPIxCON2) Register 2\n\u00b7 SPI FIFO Status (SPIxSTATUS) Register\n\u00b7 SPI Receiver Buffer (SPIxRXB) Register\n\u00b7 SPI Transmit Buffer (SPIxTXB) Register\n\u00b7 SPI Clock Select (SPIxCLK) Register\nSPIxCON0, SPIxCON1 and SPIxCON2 are control registers for the SPI module.\nSPIxSTATUS reflects the status of both the SPI module and the receive and transmit FIFOs.",
    "35.1 SPI Controls\nSPIxBAUD and SPIxCLK control the Baud Rate Generator (BRG) of the SPI module when in Host mode. The SPIxCLK selects the clock source that is used by the BRG. The SPIxBAUD configures the clock divider used on that clock source. More information on the BRG is available in the Host Mode SPI Clock Configuration section.\nSPIxTxB and SPIxRxB are the Transmit and Receive Buffer registers used to send and receive data on the SPI bus. The Transmit and Receive Buffer registers offer indirect access to Shift registers that are used for shifting the data in and out. Both registers access the multibyte FIFOs, allowing for multiple transmissions or receptions to be stored between software transfers of the data.\nThe SPIxTCNTH:L register pair either count or control the number of bits or bytes in a data transfer. When BMODE = 1 , the SPIxTCNT value signifies bytes and the SPIxTWIDTH value signifies",
    "35.1 SPI Controls\nthe number of bits in a byte. When BMODE = 0 , the SPIxTCNT value is concatenated with the SPIxTWIDTH register to signify bits. In Host Receive Only mode (TXR = 0 and RXR = 1 ), the data transfer is initiated by writing SPIxTCNT with the desired bit or byte value to transfer. In Host Transmit mode (TXR = 1 ), the data transfer is initiated by writing the SPIxTxB register, in which case the SPIxTCNT is a down counter for the bits or bytes transferred.",
    "35.1 SPI Controls\nThe SPIxINTF and SPIxINTE are the flags and enables, respectively, for SPI specific interrupts. They are tied to the SPIxIF flag and SPIxIE enable bit in the PIR and PIE registers, which is triggered when any interrupt contained in the SPIxINTF/SPIxINTE registers is triggered. The PIR/PIE registers also contain SPIxTXIF/SPIxTXIE bits, which are the Interrupt flag and Enable bit for the SPI Transmit Interrupt, as well as the SPIxRXIF/SPIxRXIE bits, which are the Interrupt flag and Enable bit for the SPI receive interrupt.",
    "35.2 SPI Operation\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control bits of the SPIxCON0, SPIxCON1 and SPIxCON2 registers. These control bits allow the following to be configured:\n\u00b7 Host mode (SCK is the clock output)\n\u00b7 Client mode (SCK is the clock input)\n\u00b7 Clock Polarity (Idle state of SCK)\n\u00b7 Input, Output, and Client Select Polarity\n\u00b7 Data Input Sample Phase (middle or end of data output time)\n\u00b7 Clock Edge (output data on first/second edge of SCK)\n\u00b7 Clock Rate (Host mode only)\n\u00b7 Client Select mode (Host or Client mode)\n\u00b7 MSB-First or LSB-First\n\u00b7 Receive/Transmit modes:\n-Full Duplex\n-Receive Only (receive without transmit)\n-Transmit Only (transmit without receive)\n\u00b7 Transfer Counter mode (only available in Transmit Only mode)",
    "35.2.1 Enabling and Disabling the SPI Module\nSetting the EN bit enables the SPI peripheral. However, to reset or reconfigure the SPI mode, the EN bit must be cleared.\nSetting the EN bit enables the SPI inputs and outputs: SDI, SDO, SCK_out, SCK_in, SS_out and SS_in. The pins for all of these inputs and outputs are selected by the PPS controls and thus must have their functions mapped properly to the device pins to function. Refer to the 'PPS - Peripheral Pin Select Module' chapter for more details.\nSS_out and SCK_out must have the pins to which they are assigned set as outputs (TRIS bits must be ' 0 ') to properly output. Clearing the TRIS bit of the SDO pin will cause the SPI module to always control that pin, but is not necessary for SDO functionality (see the Input and Output Polarity Control section).\nConfigurations selected by the following registers will not be changed while the EN bit is set:\n\u00b7 SPIxBAUD\n\u00b7 SPIxCON1\n\u00b7 SPIxCON0 (with the exception of clearing the EN bit)",
    "35.2.1 Enabling and Disabling the SPI Module\nClearing the EN bit aborts any transmissions in progress, disables the setting of interrupt flags by hardware, and resets the FIFO occupancy (see the Transmit and Receive FIFOs section).",
    "35.2.2 BUSY Bit\nWhile a data transfer is in progress, the SPI hardware sets the BUSY bit. This bit can be polled by the user to determine the current status of the SPI module and to know when a communication is complete. The following registers and bits will not be changed by software while the BUSY bit is set:\n\u00b7 SPIxTCNT\n\u00b7 SPIxTWIDTH\n\u00b7 SPIxCON2\n\u00b7 The CLB bit",
    "Important:\n1. The BUSY bit is subject to synchronization delay of up to two instruction cycles. The user must wait for it to set after loading the transmit buffer (SPIxTXB register) before using it to determine the status of the SPI module.\n2. It is also not recommended to read SPIxTCNT while the BUSY bit is set, as the value in the registers may not be a reliable indicator of the transfer counter. Use the TCZIF bit to accurately determine that the transfer counter has reached zero.",
    "35.2.3 Transmit and Receive FIFOs\nThe transmission and reception of data from the SPI module is handled by two FIFOs, one for reception and one for transmission. These are addressed by the SFRs, SPIxRXB and SPIxTXB, respectively.\nThe transmit FIFO is written to by software and is read by the SPI module to shift the data onto the SDO pin. The receive FIFO is written to by the SPI module as it shifts in the data from the SDI pin and is read by software. Setting the CLB bit resets the occupancy for both FIFOs, emptying both buffers. The FIFOs are also reset by clearing the EN bit, thus disabling the SPI module.\nImportant: The transmit and receive FIFO occupancy refer to the number of bytes that are currently being stored in each FIFO. These values are used in this chapter to illustrate the function of these FIFOs and are not directly accessible through software.",
    "35.2.3 Transmit and Receive FIFOs\nThe SPIxRXB register addresses the receive FIFO and is read-only. Reading from this register will read from the first FIFO location that was written to by hardware and decrease the receive FIFO occupancy. If the FIFO is empty, reading from this register will instead return a value of ' 0 ' and set the RXRE (Receive Buffer Read Error) bit. The RXRE bit must then be cleared in software to properly reflect the status of the read error. When the receive FIFO is full, the RXBF bit will be set.\nThe SPIxTXB register addresses the transmit FIFO and is write-only. Writing to the register will write to the first empty FIFO location and increase the occupancy. If the FIFO is full, writing to this register will not affect the data and will set the TXWE bit. When the transmit FIFO is empty, the TXBE bit will be set.\nMore details on enabling and disabling the receive and transmit functions is summarized in Table 35-1 and Client Mode Transmit Options.",
    "35.2.4 LSb vs. MSb-First Operation\nTypically, the SPI communication outputs the Most Significant bit first, but some devices or buses may not conform to this standard. In this case, the LSBF bit may be used to alter the order in which bits are shifted out during the data exchange. In both Host and Client mode, the LSBF bit controls whether data are shifted to the MSb or LSb first. Clearing the bit (default) configures the data to transfer to the MSb first, which conforms to traditional SPI operation, while setting the bit configures the data to transfer to the LSb first.",
    "35.2.5 Input and Output Polarity Control\nSPIxCON1 has three bits that control the polarity of the SPI inputs and outputs:\n\u00b7 The SDIP bit controls the polarity of the SDI input\n\u00b7 The SDOP bit controls the polarity of the SDO output\n\u00b7 The SSP bit controls the polarity of both the client SS input and the host SS output\nFor all three bits, when the bit is clear, the input or output is active-high, and when the bit is set, the input or output is active-low. When the EN bit is cleared, SS_out and SCK_out both revert to the Inactive state dictated by their polarity bits. The SDO Output state, when the EN bit is cleared, is determined by several factors as follows:",
    "35.2.5 Input and Output Polarity Control\n\u00b7 When the associated TRIS bit for the SDO pin is cleared and the SPI goes Idle after a transmission, the SDO output will remain at the last bit level.\n\u00b7 When the associated TRIS bit for the SDO pin is set, its behavior varies in Client and Host modes:\n-In Client mode, the SDO pin tri-states when any of the following is true:\n\u00b7 Client Select is inactive\n\u00b7 EN = 0\n\u00b7 TXR = 0\n-In Host mode:\n\u00b7 The SDO pin tri-states when TXR = 0\n\u00b7 When TXR = 1 and the SPI goes Idle after a transmission, the SDO output will remain at the last bit level. The SDO pin will revert to the Idle state when EN is cleared.",
    "35.2.6 Transfer Counter\nIn all Host modes, the transfer counter can be used to determine how many data transfers the SPI will send/receive. The transfer counter is comprised of the SPIxTCNT registers and is also partially controlled by the SPIxTWIDTH register.\nThe transfer counter has two primary modes, determined by the BMODE bit. Each mode uses the SPIxTCNT and SPIxTWIDTH registers to determine the number and size of the transfers. In both modes, when the transfer counter reaches zero, the TCZIF interrupt flag is set.",
    "Important:\nIn all Client modes and when BMODE = 1 in Host modes, the transfer counter will still decrement as transfers occur and can be used to count the number of messages sent/received, control SS_out, and trigger TCZIF. Also, when BMODE = 1 , the SPIxTWIDTH register can be used in Host and Client modes to determine the size of messages sent and received by the SPI, even if the transfer counter is not being actively used to control the number of messages being sent/received by the SPI module.",
    "35.2.6.1 Total Bit Count Mode (BMODE = 0 )\nIn this mode, SPIxTCNT and SPIxTWIDTH are concatenated to determine the total number of bits to be transferred. These bits will be loaded from/into the transmit/receive FIFOs in 8-bit increments and the transfer counter will be decremented by eight until the total number of remaining bits is less than eight. If there are any remaining bits (SPIxTWIDTH \u2260 0 ), the transmit FIFO will send out one final message with any extra bits greater than the remainder ignored.",
    "35.2.6.1 Total Bit Count Mode (BMODE = 0 )\nThe SPIxTWIDTH is the remaining bit count but the value does not change as it does for the SPIxTCNT value. The receiver will load a final byte into the receiver FIFO and pad the extra bits with zeros. The LSBF bit determines whether the Most Significant or Least Significant bits of this final byte are ignored or padded. For example, when LSBF = 0 and the final transfer contains only two bits, if the last byte sent was 0x5F, the RXB of the receiver will contain 0x40, which are the two MSbs of the final byte padded with zeros in the LSbs.\nIn this mode, the SPI host will only transmit messages when the SPIxTCNT value is greater than zero, regardless of the TXR and RXR settings.\nIn Host Transmit mode, the transfer starts with the data write to the SPIxTXB register or the count value written to the SPIxTCNTL register, whichever occurs last.",
    "35.2.6.1 Total Bit Count Mode (BMODE = 0 )\nIn Host Receive Only mode, the transfer clocks start when the SPIxTCNTL value is written. Transfer clocks are suspended when the receive FIFO is full and resume as the FIFO is read.",
    "35.2.6.2 Variable Transfer Size Mode (BMODE = 1 )\nIn this mode, SPIxTWIDTH specifies the width of every individual piece of the data transfer in bits. SPIxTCNT specifies the number of transfers of this bit length. If SPIxTWIDTH = 0 , each piece is a full byte of data. If SPIxTWIDTH \u2260 0 , then only that specified number of bits from the transmit FIFO are shifted out, with the unused bits ignored.\nReceived data are padded with zeros in the unused bit areas when transferred into the receive FIFO. The LSBF bit determines whether the Most Significant or Least Significant bits of the transfers are ignored or padded.\nIn this mode, the transfer counter being zero only stops messages from being sent or received when in Receive Only mode.",
    "Important:\nWith BMODE = 1 , it is possible for the transfer counter (SPIxTCNT) to decrement below zero, although when in Host Receive Only mode, transfer clocks will cease when the transfer counter reaches zero.",
    "35.2.6.3 Transfer Counter in Client Mode\nIn Client mode, the transfer counter will still decrement as data are shifted into and out of the SPI module, but it will not control data transfers. The BMODE bit along with the transfer counter is used to determine when the device will look for Client Select faults.\nWhen BMODE = 0 , the SSFLT bit will be set if Client Select transitions from its Active to Inactive state during bytes of data or if it transitions before the last bit sent during the final byte (if SPIxTWIDTH \u2260 0 ).\nWhen BMODE = 1 , the SSFLT bit will be set if Client Select transitions from its Active to Inactive state before the final bit of each individual transfer is completed.\nNote: SSFLT does not have an associated interrupt, so it will be checked in the software. An ideal time to do this is when the End of Client Select Interrupt (EOSIF) is triggered (see the Start of Client Select and End of Client Select Interrupts section).",
    "35.3 Host Mode\nIn Host mode, the device controls the SCK line and, as such, initiates data transfers and determines when any clients broadcast data onto the SPI bus.\nHost mode can be configured in four different modes, configured by the TXR and RXR bits:\n\u00b7 Full Duplex mode\n\u00b7 Receive Only mode\n\u00b7 Transmit Only mode\n\u00b7 Transfer Off mode\nThe modes are illustrated in the following table:",
    "35.3 Host Mode\nTable 35-1. Host Mode TXR/RXR Settings\n\n= 1 Full Duplex mode BMODE = 1 : Transfer when RxFIFO is not full and TxFIFO is not empty BMODE = 0 : Transfer when RXFIFO is not full, TXFIFO is not empty, the Transfer Counter is nonzero, TXR = 1 = and Receive Only mode Transfer when RxFIFO is not full and the Transfer Counter is nonzero Transmitted data are either the top of FIFO or the most recently received data. = 1 Full Duplex mode BMODE = 1 : Transfer when RxFIFO is not full and TxFIFO is not empty BMODE = 0 : Transfer when RXFIFO is not full, TXFIFO is not empty, the Transfer Counter is nonzero, TXR = 0 = RXR. RXR =, TXR = 1 = Transmit Only BMODE = 1 : Transfer when TxFIFO is not empty BMODE = 0 : Transfer when TXFIFO is not empty and the Transfer Counter is nonzero Received data are not stored. RXR =, TXR = 0 = 0 mode No Transfers",
    "35.3.1 Full Duplex Mode\nWhen both TXR and RXR are set, the SPI host is in Full Duplex mode. In this mode, data transfer triggering is affected by the BMODE bit.\nWhen BMODE = 1 , data transfers will occur whenever the receive FIFO is not full and data are present in the transmit FIFO. In practice, as long as the receive FIFO is not full, data will be transmitted/received as soon as the SPIxTXB register is written to, matching the functionality of SPI (MSSP) modules on older 8-bit Microchip devices. The SPIxTCNT will decrement with each transfer. However, when SPIxTCNT is zero, the next transfer is not inhibited and the corresponding SPIxTCNT decrement will cause the count to roll over to the maximum value. The following figure shows an example of a communication using this mode.",
    "Figure 35-3. SPI Host Operation - Data Exchange, RXR = 1 , TXR = 1\nNotes:\n1. SS(out) is not shown on this diagram .\n2. SPIxTCNT write is optional when TXR/RXR = 1 1 / and BMODE = 1 . If BMODE = 0 , a write to SPIxTCNT is required to start transmission; TCZIF signals the transition of SPIxTCNT from 1 to 0 .\n3. Transmission gap occurs while waiting for transmitter data.\nWhen BMODE = 0 , the transfer counter (SPIxTCNT) must also be written to before transfers will occur. Transfers will cease when the transfer counter reaches ' 0 '. For example, if SPIxTXB is written twice and then SPIxTCNTL is written with ' 3 ', the transfer will start with the SPIxTCNTL write. The two bytes in the TXFIFO will be sent after which the transfer will suspend until the third and last byte is written to SPIxTXB.",
    "35.3.2 Transmit Only Mode\nWhen TXR is set and RXR is clear, the SPI host is in Transmit Only mode. In this mode, data transfer triggering is affected by the BMODE bit.\nWhen BMODE = 1 , data transfers will occur whenever the transmit FIFO is not empty. Data will be transmitted as soon as the SPIxTXB register is written to, matching the functionality of the SPI (MSSP) modules on previous 8-bit devices. The SPIxTCNT will decrement with each transfer. However, when SPIxTCNT is zero, the next transfer is not inhibited and the corresponding SPIxTCNT decrement will cause the count to roll over to the maximum value. Any data received in this mode is not stored in the receive FIFO. The following figure shows an example of sending a command and then sending a byte of data using this mode.\nRev. 10-000282A\n11/6/2018\nNotes: 1. SS_out is not shown",
    "35.3.2 Transmit Only Mode\n.\n2. The byte counter is optional when TXR/RXR = 1 0 / .\n3. After the command bytes, wait for SRMTIF before loading SPIxTXB  otherwise the command data w , ill decrement SPIxTXCNT (alternati vely, the command bytes can be taken into consideration along with the data being transmitted by loading 0x05 to the SPIxTXCNT register). TCZIF signals the end of the transmission.\n4. Transmit data interrupt handler (or DMA) must write only the bytes necessary; the byte counter is not available as an indicator.\n5. Reading the SPIxRXB is not required because RXR = 0 .\nWhen BMODE = 0 , the transfer counter (SPIxTCNT) must also be written to before transfers will occur, and transfers will cease when the transfer counter reaches ' 0 '.",
    "35.3.2 Transmit Only Mode\nFor example, if SPIxTXB is written twice and then SPIxTCNTL is written with ' 3 ', the transfer will start with the SPIxTCNTL write. The two bytes in the TXFIFO will be sent after which the transfer will suspend until the third and last byte is written to SPIxTXB.",
    "35.3.3 Receive Only Mode\nWhen RXR is set and TXR is clear, the SPI host is in Receive Only mode. In this mode, data transfers when the receive FIFO is not full and the transfer counter is nonzero. In this mode, writing a value to SPIxTCNTL will start the clocks for transfer. The clocks will suspend while the receive FIFO is full and will cease when the SPIxTCNT reaches zero (see the Transfer Counter section). If there is any data in the transmit FIFO, the first data written to SPIxTXB will be transmitted on each data exchange, although the transmit FIFO occupancy will not change, meaning that the same message will be sent on each transmission. If there is no data in the transmit FIFO, the most recently received data will be transmitted. The following figure shows an example of sending a command using the Transmit Only mode and then receiving a byte of data using the Receive Only mode.",
    "35.3.3 Receive Only Mode\nImportant: When operating in Receive Only mode and the size of every SPI transaction is less than 8 bits, it is recommended to operate in BMODE = 1 mode. The size of the packet can be configured using the SPIxTWIDTH register.",
    "Figure 35-5. SPI Host Operation - Command+Read Data, TXR = 0 , RXR = 1\nRev. 10-000283A\n11/6/2018\nNotes:\n1. SS_out is not shown .\n2. Software must wait for shift-register empty (SRMTIF) before changing TXR, RXR, SPIxTCNT and SPIxTWIDTH controls. In this case, t his is not considered an imposition because the client likely needs time to load output data.",
    "35.3.4 Transfer Off Mode\nWhen both TXR and RXR are cleared, the SPI host is in Transfer Off mode. In this mode, SCK will not toggle, and no data are exchanged. However, writes to SPIxTXB will be transferred to the transmit FIFO which will then be transmitted when the TXR bit is set.",
    "35.3.5.1 Hardware Client Select Control\nThe SPI module allows for direct hardware control of a Client Select output. The Client Select output (SS_out) is controlled both directly, through the SSET bit, and indirectly by the hardware, while the transfer counter is nonzero (see the Transfer Counter section). The SS_out pin is selected with the PPS controls. The SS_out polarity is controlled by the SSP bit.\nSetting the SSET bit will assert SS_out. Clearing the SSET bit will leave SS_out to be controlled by the transfer counter. When the transfer counter is loaded, the SPI module will automatically assert SS_out. When the transfer counter decrements to zero, the SPI module will deassert SS_out either one baud period after the final SCK pulse of the final transfer (when CKE/SMP = 0/1 ) or one half baud period otherwise, as shown in the following figure.",
    "Figure 35-6. SPI Host SS Operation - CKE = 0 , BMODE = 1 , TWIDTH = 0 , SSP = 0\n1\n0\nminimum 1 baud clock when FST = 0\napprox. 1 baud clock\n7\n6\n5\n4\n3\nSPIEN\nbaud_clock\nSoftware Write to SPIxTCNTL\nTransfer Counter\nSS_out\nSCK_out\nSDO_bit_number\n2\n1\n0\nRev. 10-000284A\n11/6/2018\nNotes: 1. SDO bit number illustrates the transmitted bit number and is not intended to imply SDO_out tristate operation.\n2. Assumes SPIxTXB holds data when SPIxTCNTL is written.",
    "35.3.5.2 Software Client Select Control\nClient Select can be controlled through software via a general purpose I/O pin. In this case, ensure that the desired pin is configured as a general purpose output with the PPS and TRIS controls. In this case, SSET will not affect the Client Select, the Transfer Counter will not automatically control the Client Select output, and all setting and clearing of the Client Select output line must be directly controlled by software.",
    "35.3.6.1 SPI Clock Selection\nThe clock source for SPI Host modes is selected by the SPIxCLK register.\nThe SPIxBAUD register allows for dividing this clock. The frequency of the SCK output is defined by the following equation:",
    "Equation 35-1. SCK Output Frequency\nwhere FBAUD is the baud rate frequency output on the SCK pin, FCSEL is the frequency of the input clock selected by the SPIxCLK register, and BAUD is the value contained in the SPIxBAUD register.\n<!-- formula-not-decoded -->",
    "35.3.6.2 Clock and Data Change Alignment\nThe CKP, CKE and SMP bits control the relationship between the SCK clock output, SDO output data changes, and SDI input data sampling. The bit functions are as follows:\n\u00b7 CKP controls SCK output polarity\n\u00b7 CKE controls SDO output change relative to the SCK clock\n\u00b7 SMP controls SDI input sampling relative to the clock edges\nThe CKE bit, when set, inverts the low Idle state of the SCK output to a high Idle state.\nThe following figures illustrate the eight possible combinations of the CKP, CKE and SMP bit selections.",
    "Important: All timing diagrams assume the LSBF bit is cleared.\nFigure 35-7. Clocking Detail - Host Mode, CKE = 0 , SMP = 0\nFigure 35-8. Clocking Detail - Host Mode, CKE = 1 , SMP = 1",
    "Figure 35-9. Clocking Detail - Host Mode, CKE = 0 , SMP = 1\nFigure 35-10. Clocking Detail - Host Mode, CKE = 1 , SMP = 0",
    "35.3.6.3 SCK Start-Up Delay\nWhen starting an SPI data exchange, the host device asserts the SS output by either setting the SSET bit or loading the TCNT value, which then triggers the module to send data by writing SPIxTXB. These data triggers are synchronized to the clock selected by the SPIxCLK register before the first SCK pulse appears, usually requiring one or two clock periods of the selected SPI source clock.\nThe SPI module includes additional synchronization delays on SCK generation specifically designed to ensure that the Client Select output timing is correct, without requiring precision software timing loops. By default, this synchronization delay is \u00bd baud period.\nWhen the value of the SPIxBAUD register is a small number (indicating higher SCK frequencies), the code execution delay between asserting SS and writing SPIxTXB is relatively long compared to the added synchronization delay before the first SCK edge. With larger values of SPIxBAUD (indicating lower SCK frequencies), the code execution delay is much smaller relative to the synchronization delay. Therefore, the first SCK edge after SS is asserted will be closer to the synchronization delay.",
    "35.3.6.3 SCK Start-Up Delay\nSetting the FST bit removes the synchronization delay, allowing systems with low SPIxBAUD values (and thus, long synchronization delays) to forgo this extra delay, in which case the time between the SS assertion and the first SCK edge depends entirely on the code execution delay.",
    "35.4.1 Client Mode Transmit Options\nThe SDO output of the SPI module in Client mode is controlled by the following:\n\u00b7 TXR bit\n\u00b7 TRIS bit associated with the SDO pin\n\u00b7 Client Select input\n\u00b7 Current state of the transmit FIFO\nThis control is summarized in the following table where TRISxn refers to the bit in the TRIS register corresponding to the pin that SDO has been assigned with PPS, TXR is the Transmit Data Required Control bit, SS is the state of the Client Select input, and TXBE is the transmit FIFO Buffer Empty bit.\n\nTable 35-2. Client Mode Transmit",
    "35.4.1 Client Mode Transmit Options\n0, TXR = 0. 0, SS = FALSE. 0, TXBE = 0. 0, SDO State = Drives state determined by LATxn (2). 0, TXR = 0. 0, SS = FALSE. 0, TXBE = 1. 0, SDO State = Drives state determined by LATxn (2). 0, TXR = 0. 0, SS = TRUE. 0, TXBE = 0. 0, SDO State = Outputs the oldest byte in the transmit FIFO Does not remove data from the transmit FIFO. 0, TXR = 0. 0, SS = TRUE. 0, TXBE = 1. 0, SDO State = Outputs the most recently received byte. 0, TXR = 1. 0, SS = FALSE. 0, TXBE = 0. 0, SDO State = Drives state determined by LATxn (2). 0, TXR = 1. 0, SS = FALSE. 0, TXBE = 1. 0, SDO State = Drives state determined by LATxn (2). 0, TXR = 1. 0, SS = TRUE. 0, TXBE",
    "35.4.1 Client Mode Transmit Options\n= 0. 0, SDO State = Outputs the oldest byte in the transmit FIFO Removes transmitted byte from the transmit FIFO Decrements occupancy of transmit FIFO. 0, TXR = 1. 0, SS = TRUE. 0, TXBE = 1. 0, SDO State = Outputs the most recently received byte Sets the TXUIF bit. 1, TXR = 0. 1, SS = FALSE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = FALSE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = TRUE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = TRUE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 1. 1, SS = FALSE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 1. 1, SS = FALSE. 1, TXBE = 1.",
    "35.4.1 Client Mode Transmit Options\n1, SDO State = Tri-stated. 1, TXR = 1. 1, SS = TRUE. 1, TXBE = 0. 1, SDO State = Outputs the oldest byte in the transmit FIFO Removes transmitted byte from the transmit FIFO Decrements the FIFO occupancy. 1, TXR = 1. 1, SS = TRUE. 1, TXBE = 1. 1, SDO State = Outputs the most recently received byte Sets the TXUIF bit",
    "Notes:\n1. TRISxn is the bit in the TRISx register corresponding to the pin to which SDO has been assigned with PPS.\n2. LATxn is the bit in the LATx register corresponding to the pin to which SDO has been assigned with PPS.",
    "35.4.1.1 SDO Drive/Tri-State\nThe TRIS bit associated with the SDO pin controls whether the SDO pin will tri-state. When this TRIS bit is cleared, the pin will always be driving to a level, even when the SPI module is inactive. When the SPI module is inactive (either due to the host not clocking the SCK line or the SS being false), the SDO pin will be driven to the value of the LAT bit associated with the SDO pin. When the SPI module is active, its output is determined by both TXR and whether there is data in the transmit FIFO.\nWhen the TRIS bit associated with the SDO pin is set, the pin will only have an output level driven to it when TXR = 1 and the Client Select input is true. In all other cases, the pin will be tri-stated.\n\nTable 35-3. Client Mode Transmit",
    "35.4.1.1 SDO Drive/Tri-State\n0, TXR = 0. 0, SS = FALSE. 0, TXBE = 0. 0, SDO State = Output level determined by LATxn (2). 0, TXR = 0. 0, SS = FALSE. 0, TXBE = 1. 0, SDO State = Output level determined by LATxn (2). 0, TXR = 0. 0, SS = TRUE. 0, TXBE = 0. 0, SDO State = Outputs the oldest byte in the TXFIFO. Does not remove data from the TXFIFO.. 0, TXR = 0. 0, SS = TRUE. 0, TXBE = 1. 0, SDO State = Outputs the most recently received byte. 0, TXR = 1. 0, SS = FALSE. 0, TXBE = 0. 0, SDO State = Output level determined by LATxn (2). 0, TXR = 1. 0, SS = FALSE. 0, TXBE = 1. 0, SDO State = Output level determined by LATxn (2). 0, TXR = 1. 0, SS",
    "35.4.1.1 SDO Drive/Tri-State\n= TRUE. 0, TXBE = 0. 0, SDO State = Outputs the oldest byte in the TXFIFO. Removes transmitted byte from the TXFIFO. Decrements occupancy of TXFIFO.. 0, TXR = 1. 0, SS = TRUE. 0, TXBE = 1. 0, SDO State = Outputs the most recently received byte. Sets the TXUIF bit.. 1, TXR = 0. 1, SS = FALSE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = FALSE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = TRUE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = TRUE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 1. 1, SS = FALSE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1,",
    "35.4.1.1 SDO Drive/Tri-State\nTXR = 1. 1, SS = FALSE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 1. 1, SS = TRUE. 1, TXBE = 0. 1, SDO State = Outputs the oldest byte in the TXFIFO. Removes transmitted byte from the TXFIFO. Decrements occupancy of TXFIFO.. 1, TXR = 1. 1, SS = TRUE. 1, TXBE = 1. 1, SDO State = Outputs the most recently received byte. Sets the TXUIF bit.",
    "Notes:\n1. TRISxn is the bit in the TRISx register corresponding to the pin that SDO has been assigned with PPS.\n2. LATxn is the bit in the LATx register corresponding to the pin that SDO has been assigned with PPS.",
    "35.4.1.2 SDO Output Data\nThe TXR bit controls the nature of the data that is transmitted in Client mode. When TXR is set, transmitted data are taken from the transmit FIFO. If the FIFO is empty, the most recently received data will be transmitted and the TXUIF flag will be set to indicate that a transmit FIFO underflow has occurred.\nWhen TXR is cleared, the data will be taken from the transmit FIFO, and the FIFO occupancy will not decrease. If the transmit FIFO is empty, the most recently received data will be transmitted, and the TXUIF bit will not be set. However, if the TRIS bit associated with the SDO pin is set, clearing the TXR bit will cause the SPI module to not output any data to the SDO pin.",
    "35.4.2 Client Mode Receive Options\nThe RXR bit controls the nature of receptions in Client mode. When RXR is set, the SDI input data will be stored in the receive FIFO if it is not full. If the receive FIFO is full, the RXOIF bit will be set to indicate a receive FIFO overflow error and the data are discarded. When RXR is cleared, all received data will be ignored and not stored in the receive FIFO (although it may still be used for transmission if the transmit FIFO is empty).\nThe following figure presents a typical Client mode communication, showing a case where the host writes two and then three bytes, showing interrupts as well as the behavior of the transfer counter in Client mode (see the Transfer Counter in Client Mode section for more details on the transfer counter in Client mode as well as the SPI Interrupts section for more information on interrupts).\nFigure 35-11. SPI Client Mode Operation - Interrupt-Driven, Host Writes 2+3 Bytes\nNotes: 1. This delay is exaggerated for illustration and can be as short as1/2 bit period.",
    "35.4.2 Client Mode Receive Options\n2. If the device is sleeping, SOSIF will wake it up for interrupt service.\n3. Setting SPIxTCNTL is optional in this example, otherwise it will count -3, -4, -5, and TCZIF will not occur .",
    "35.4.3 Client Mode Client Select\nIn Client mode, an external Client Select signal can be used to synchronize communication with the host device. The Client Select line is held in its Inactive state (high by default) until the host device is ready to communicate. When the Client Select transitions to its Active state, the client knows that a new transmission is starting.\nWhen the Client Select goes false at the end of the transmission, the receive function of the selected SPI client device returns to the Inactive state. The client is then ready to receive a new transmission when the Client Select goes true again.",
    "35.4.3 Client Mode Client Select\nThe Client Select signal is received on the SS input pin. This pin is selected with the SPIxSSPPS register (refer to the 'PPS Inputs' section). When the input on this pin is true, transmission and reception are enabled, and the SDO pin is driven. When the input on this pin is false, the SDO pin is either tri-stated (if the TRIS bit associated with the SDO pin is set) or driven to the value of the LAT bit associated with the SDO pin (if the TRIS bit associated with the SDO pin is cleared). The SCK input is ignored when the SS input is false.\nIf the SS input goes false while a data transfer is still in progress, it is considered a Client Select fault. The SSFLT bit indicates whether such an event has occurred. The transfer counter value determines the number of bits in a valid data transfer (see the Transfer Counter section for more details).\nThe Client Select polarity is controlled by the SSP bit. When SSP is set (its default state), the Client Select input is active-low, and when it is cleared, the Client Select input is active-high.",
    "35.4.3 Client Mode Client Select\nThe Client Select for the SPI module is controlled by the SSET bit. When SSET is cleared (its default state), the Client Select will act as described above. When the bit is set, the SPI module will behave as if the SS input is always in its Active state.",
    "Important:\nWhen SSET is set, the effective SS_in signal is always active. Hence, the SSFLT bit may be disregarded.",
    "35.4.4 Client Mode Clock Configuration\nIn Client mode, SCK is an input and must be configured to the same polarity and clock edge as the host device. As in Host mode, the polarity of the clock input is controlled by the CKP bit, and the clock edge used for transmitting data is controlled by the CKE bit.",
    "35.4.5 Daisy-Chain Configuration\nThe SPI bus can be connected in a daisy-chain configuration, where the first client output is connected to the second client input, the second client output is connected to the third client input, and so on. The final client output is connected to the host input. Each client sends out, during a second group of clock pulses, an exact copy of what was received during the first group of clock pulses. The whole chain acts as one large communication shift register. The daisy-chain feature only requires a single Client Select line from the host device connected to all client devices (alternately, the client devices can be configured to ignore the Client Select line by setting the SSET bit).\nIn a typical daisy-chain configuration, the SCK signal from the host is connected to each of the client device SCK inputs. However, the SCK input and output are separate signals selected by the PPS control. When the PPS selection is made to configure the SCK input and SCK output on separate pins, the SCK output will follow the SCK input, allowing for SCK signals to be daisy-chained like the SDO/SDI signals.",
    "35.4.5 Daisy-Chain Configuration\nThe following two figures show block diagrams of a typical daisy-chain connection and a daisy-chain connection with daisy-chained SPI clocks, respectively.\nFigure 35-12. Traditional SPI Daisy-Chain Connection",
    "Figure 35-13. SPI Daisy-Chain Connection with Chained SCK\nRev. 10-000082C\n11/8/2018",
    "35.5 SPI Operation in Sleep Mode\nThe SPI Host mode will operate in Sleep, provided that the clock source selected by SPIxCLK is active in Sleep mode. FIFOs will operate as they do when the part is awake. When TXR = 1 , the transmit FIFO will need to contain data for transfers to take place in Sleep. All interrupts will still set the interrupt flags in Sleep, but only enabled interrupts will wake the device from Sleep.\nThe SPI Client mode will operate in Sleep because the clock is provided by an external host device. FIFOs will still operate, interrupts will set interrupt flags, and enabled interrupts will wake the device from Sleep.",
    "35.6 SPI Interrupts\nThere are three top level SPI interrupts in the PIRx register:\n\u00b7 SPI Transmit (SPIxTXIF)\n\u00b7 SPI Receive (SPIxRXIF)\n\u00b7 SPI Module status (SPIxIF)\nThe SPI Module status interrupts are enabled at the module level in the SPIxINTE register. Only enabled status interrupts will cause the single top level SPIxIF flag to be set.",
    "35.6.1 SPI Receive Interrupt\nThe SPI receive interrupt is set when the receive FIFO contains data and is cleared when the receive FIFO is empty. The interrupt flag, SPIxRXIF, is located in one of the PIR registers. The interrupt enable, SPIxRXIE, is located in the corresponding PIE register. The SPIxRXIF interrupt flag is readonly.",
    "35.6.2 SPI Transmit Interrupt\nThe SPI Transmit interrupt is set when the transmit FIFO is not full and can accept a character and is cleared when the transmit FIFO is full and cannot accept a character. The interrupt flag, SPIxTXIF, is located in one of the PIR registers. The interrupt enable, SPIxTXIE, is located in the corresponding PIE register. The SPIxTXIF interrupt flag is read-only.",
    "35.6.3 SPI Status Interrupts\nThe SPIxIF flag is located in one of the PIR registers. This flag is set when any of the individual status flags in SPIxINTF and their respective SPIxINTE bits are set. For any specific interrupt flag to interrupt normal program flow, both the SPIxIE bit in the PIE register corresponding to the PIR register and the specific bit in SPIxINTE associated with that interrupt must be set.\nThe Status Interrupts include the following:\n\u00b7 Shift Register Empty (SRMTIF)\n\u00b7 Transfer Counter is Zero (TCZIF)\n\u00b7 Start of Client Select (SOSIF)\n\u00b7 End of Client Select (EOSIF)\n\u00b7 Receiver Overflow (RXOIF)\n\u00b7 Transmitter Underflow (TXUIF)",
    "35.6.3.1 Shift Register Empty Interrupt\nThe Shift Register Empty Interrupt Flag and Shift Register Empty Interrupt Enable are the SRMTIF and SRMTIE bits, respectively. This interrupt is only available in Host mode and triggers when a data transfer completes and conditions are not present to start a new transfer, as dictated by the TXR and RXR bits (see Table 35-1 for conditions for starting a new Host mode data transfer with different TXR/ RXR settings). This interrupt will be triggered at the end of the last full bit period after SCK has been low for one \u00bd-baud period. See the figure below for more details of the timing of this interrupt as well as other interrupts. This bit will not clear itself when the conditions for starting a new transfer occur and must be cleared in software.\nFigure 35-14. Transfer And Client Select Interrupt Timing\nNotes:\n1  SRMTIF available only in . Host mode .\n2  Clearing of interrupt flags is shown for illustration; actual interrupt flags must be cleared in software . .\n3  SOSIF and EOSIF are set according to SS_in, even in . Host mode.",
    "35.6.3.2 Transfer Counter Is Zero Interrupt\nThe Transfer Counter Is Zero Interrupt Flag and Transfer Counter Is Zero Interrupt Enable are the TCZIF and TCZIE bits, respectively. This interrupt will trigger when the transfer counter (defined by BMODE, SPIxTCNT and SPIxTWIDTH) decrements from one to zero. See Figure 35-14 for more details on the timing of this interrupt as well as other interrupts. This bit must be cleared in software.",
    "Important:\nThe TCZIF flag only indicates that the transfer counter has decremented from one to zero and may not indicate that the entire data transfer process is complete. Either poll the BUSY bit and wait for it to be cleared or use the Shift Register Empty Interrupt (SRMTIF) to determine when a data transfer is fully complete.",
    "35.6.3.3 Start of Client Select and End of Client Select Interrupts\nThe Start of Client Select Interrupt Flag and Start of Client Select Interrupt Enable are the SOSIF and SOSIE bits, respectively. The End of Client Select Interrupt Flag and End of Client Select Interrupt Enable are the EOSIF and EOSIE bits, respectively. These interrupts trigger at the leading and trailing edges of the Client Select input.\nThe interrupts are active in both Host and Client mode and will trigger on transitions of the Client Select input, regardless of which mode the SPI is in. In Host mode, the PPS controls will be used to assign the Client Select input to the same pin as the Client Select output, allowing these interrupts to trigger on changes to the Client Select output.\nIn Client mode, changing the SSET bit can trigger these interrupts, as it changes the effective input value of Client Select.\nBoth SOSIF and EOSIF must be cleared in software.",
    "35.6.3.4 Receiver Overflow and Transmitter Underflow Interrupts\nThe receiver overflow interrupt triggers if data are received when the receive FIFO is already full and RXR = 1 . In this case, the data will be discarded, and the RXOIF bit will be set. The Receiver Overflow Interrupt Enable bit is RXOIE.\nThe Transmitter Underflow Interrupt flag triggers if a data transfer begins when the transmit FIFO is empty and TXR = 1 . In this case, the most recently received data will be transmitted and the TXUIF bit will be set. The Transmitter Underflow Interrupt Enable bit is TXUIE.\nBoth these interrupts will only occur in Client mode, as Host mode will not allow the receive FIFO to overflow or the transmit FIFO to underflow.",
    "35.7 Register Definitions: Serial Peripheral Interface\nLong bit name prefixes for the SPI peripherals are shown in the table below where 'x' refers to the SPI instance number. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 35-4. SPI Long Bit Name Prefixes\n\nSPI1, Bit Name Prefix = SPI1. SPI2, Bit Name Prefix = SPI2",
    "35.7.1 SPIxCON0\nName:\nSPIxCON0 0x084,0x091\nAddress:",
    "SPI Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = LSBF. , 7 = MST. , 8 = BMODE. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN SPI Enable\n1, Description = SPI is enabled. 0, Description = SPI is disabled",
    "Bit 2 - LSBF  LSb-First Data Exchange Select (1)\n1, Description = Data are exchanged LSb first. 0, Description = Data are exchanged MSb first (traditional SPI operation)",
    "Bit 1 - MST  SPI Host Operating Mode Select (1)\n1, Description = SPI module operates as the bus host. 0, Description = SPI module operates as a bus client",
    "Bit 0 - BMODE  Bit-Length Mode Select (1)\n1, Description = SPIxTWIDTH setting applies to every byte: total bits sent is SPIxTWIDTH*SPIxTCNT, end-of-packet occurs when SPIxTCNT = 0. 0, Description = SPIxTWIDTH setting applies only to the last byte exchanged; total bits sent is SPIxTWIDTH + (SPIxTCNT*8)",
    "Note:\n- 1. Do not change this bit when EN = 1 .",
    "35.7.2 SPIxCON1\nName: Address:\nSPIxCON1 0x085,0x092",
    "SPI Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SMP. , 2 = CKE. , 3 = CKP. , 4 = FST. , 5 = . , 6 = SSP. , 7 = SDIP. , 8 = SDOP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 1. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SMP SPI Input Sample Phase Control\n1, Mode = Client. 1, Description = Reserved. 1, Mode = Host. 1, Description = SDI input is sampled at the end of data output time. 0, Mode = Client or Host. 0, Description = SDI input is sampled in the middle of data output time",
    "Bit 6 - CKE Clock Edge Select\n1, Description = Output data changes on transition from Active to Idle clock state. 0, Description = Output data changes on transition from Idle to Active clock state",
    "Bit 5 - CKP Clock Polarity Select\n1, Description = Idle state for SCK is high level. 0, Description = Idle state for SCK is low level",
    "Bit 4 - FST Fast Start Enable\nx, Mode = Client. x, Description = This bit is ignored. 1, Mode = Host. 1, Description = Delay to first SCK may be less than \u00bd baud period. 0, Mode = Host. 0, Description = Delay to first SCK will be at least \u00bd baud period",
    "Bit 2 - SSP Client Select Input/Output Polarity Control\n1, Description = SS is active-low. 0, Description = SS is active-high",
    "Bit 1 - SDIP SPI Input Polarity Control\n1, Description = SDI input is active-low. 0, Description = SDI input is active-high",
    "Bit 0 - SDOP SPI Output Polarity Control\n1, Description = SDO output is active-low. 0, Description = SDO output is active-high",
    "35.7.3 SPIxCON2\nName:\nSPIxCON2 0x086,0x093\nAddress:\nSPI Control Register 2 (3)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BUSY. , 2 = SSFLT. , 3 = . , 4 = . , 5 = . , 6 = SSET. , 7 = TXR. , 8 = RXR. Access, 1 = R. Access, 2 = R. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - BUSY  SPI Module Busy Status (1)\n1, Description = Data exchange is busy. 0, Description = Data exchange is not taking place",
    "Bit 6 - SSFLT SS_in Fault Status\nx, Condition = SSET = 1. x, Description = This bit is unchanged. 1, Condition = SSET = 0. 1, Description = SS_in ends the transaction unexpectedly, and the data byte being received is lost. 0, Condition = SSET = 0. 0, Description = SS_in ends normally",
    "Bit 2 - SSET Client Select Enable\n1, Mode = Host. 1, Description = SS_out is driven to the Active state continuously. 0, Mode = Host. 0, Description = SS_out is driven to the Active state while the transmit counter is not zero. 1, Mode = Client. 1, Description = SS_in is ignored and data are clocked on all SCK_in (as though SS = TRUE at all times). 0, Mode = Client. 0, Description = SS_in enables/disables data input and tri-states SDO if the TRIS bit associated with the SDO pin is set (see the Client Mode Transmit table for details)",
    "Bit 1 - TXR  Transmit Data-Required Control (2)\n1, Description = TxFIFO data are required for a transfer. 0, Description = TxFIFO data are not required for a transfer",
    "Bit 0 - RXR  Receive FIFO Space-Required Control (2)\n1, Description = Data transfers are suspended when RxFIFO is full. 0, Description = Received data are not stored in the FIFO",
    "Notes:\n1. The BUSY bit is subject to synchronization delay of up to two instruction cycles. The user must wait after loading the transmit buffer (the SPIxTXB register) before using it to determine the status of the SPI module.\n2. See the Host Mode TXR/RXR Settings table as well as the Host Mode and Client Mode sections for more details pertaining to TXR and RXR function.\n3. This register will not be written to while a transfer is in progress (the BUSY bit is set).",
    "35.7.4 SPIxCLK\nName: Address:\nSPIxCLK 0x08C,0x099\nSPI Clock Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CLKSEL[3:0]. , 6 = CLKSEL[3:0]. , 7 = CLKSEL[3:0]. , 8 = CLKSEL[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - CLKSEL[3:0] SPI Clock Source Selection\nTable 35-5. SPI CLK Source Selections\n\n1111 - 1101, Selection = Reserved. 1100, Selection = CLC4_OUT. 1011, Selection = CLC3_OUT. 1010, Selection = CLC2_OUT. 1001, Selection = CLC1_OUT. 1000, Selection = SMT1_OUT. 0111, Selection = TMR4_Postscaler_OUT. 0110, Selection = TMR2_Postscaler_OUT. 0101, Selection = TMR0_OUT. 0100, Selection = Clock Reference Output. 0011, Selection = EXTOSC. 0010, Selection = MFINTOSC (500 kHz). 0001, Selection = HFINTOSC. 0000, Selection = F OSC (System Clock)",
    "35.7.5 SPIxBAUD\nName:\nSPIxBAUD 0x089,0x096\nAddress:\nSPI Baud Rate Register",
    "35.7.5 SPIxBAUD\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BAUD[7:0]. , 2 = BAUD[7:0]. , 3 = BAUD[7:0]. , 4 = BAUD[7:0]. , 5 = BAUD[7:0]. , 6 = BAUD[7:0]. , 7 = BAUD[7:0]. , 8 = BAUD[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - BAUD[7:0] Baud Clock Prescaler Select\nn, Description = SCK high or low time: TSC = SPI Clock Period*(n+1) SCK toggle frequency: FSCK = FBAUD = SPI Clock Frequency/(2*(n+1))",
    "35.7.6 SPIxTCNT\nName: Address:\nSPIxTCNT 0x082,0x08F",
    "SPI Transfer Counter Register\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11. = . Access, 10.TCNTH[2:0] = R/W. Access, 9.TCNTH[2:0] = R/W. Access, 8.TCNTH[2:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11. = . Reset, 10.TCNTH[2:0] = 0. Reset, 9.TCNTH[2:0] = 0. Reset, 8.TCNTH[2:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11. = 3. Bit, 10.TCNTH[2:0] = 2. Bit, 9.TCNTH[2:0] = 1. Bit, 8.TCNTH[2:0] = 0. , 15. = TCNTL[7:0]. ,",
    "SPI Transfer Counter Register\n14. = TCNTL[7:0]. , 13. = TCNTL[7:0]. , 12. = TCNTL[7:0]. , 11. = TCNTL[7:0]. , 10.TCNTH[2:0] = TCNTL[7:0]. , 9.TCNTH[2:0] = TCNTL[7:0]. , 8.TCNTH[2:0] = TCNTL[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11. = R/W. Access, 10.TCNTH[2:0] = R/W. Access, 9.TCNTH[2:0] = R/W. Access, 8.TCNTH[2:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11. = 0. Reset,",
    "SPI Transfer Counter Register\n10.TCNTH[2:0] = 0. Reset, 9.TCNTH[2:0] = 0. Reset, 8.TCNTH[2:0] = 0",
    "Bits 10:8 - TCNTH[2:0] SPI Transfer Counter Most Significant Byte\nn, Condition = BMODE = 0. n, Description = Bits 13-11 of the transfer bit count. n, Condition = BMODE = 1. n, Description = Bits 10-8 of the transfer byte count",
    "Bits 7:0 - TCNTL[7:0] SPI Transfer Counter Least Significant Byte\nn, Condition = BMODE = 0. n, Description = Bits 10-3 of the transfer bit count. n, Condition = BMODE = 1. n, Description = Bits 7-0 of the transfer byte count",
    "35.7.7 SPIxTWIDTH\nName:\nSPIxTWIDTH 0x088,0x095\nAddress:\nSPI Transfer Width Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = TWIDTH[2:0]. , 7 = TWIDTH[2:0]. , 8 = TWIDTH[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 2:0 - TWIDTH[2:0] SPI Transfer Count Byte Width or three LSbs of the Transfer Bit Count\nn, Condition = BMODE = 0. n, Description = Bits 2-0 of the transfer bit count. n, Condition = BMODE = 1. n, Description = Number of bits in each transfer byte count. Bits = n (when n > 0 ) or 8 (when n = 0 ).",
    "35.7.8 SPIxSTATUS\nName:\nSPIxSTATUS 0x087,0x094\nAddress:\nSPI Status Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXWE. , 2 = . , 3 = TXBE. , 4 = . , 5 = RXRE. , 6 = CLB. , 7 = . , 8 = RXBF. Access, 1 = R/C/HS. Access, 2 = . Access, 3 = R. Access, 4 = . Access, 5 = R/C/HS. Access, 6 = S. Access, 7 = . Access, 8 = R. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 1. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - TXWE Transmit Buffer Write Error\n1, Description = SPIxTXB was written while TxFIFO was full. 0, Description = No error has occurred",
    "Bit 5 - TXBE Transmit Buffer Empty\n1, Description = Transmit buffer TxFIFO is empty. 0, Description = Transmit buffer is not empty",
    "Bit 3 - RXRE Receive Buffer Read Error\n1, Description = SPIxRXB was read while RxFIFO was empty. 0, Description = No error has occurred",
    "Bit 2 - CLB Clear Buffer Control\n1, Description = Reset the receive and transmit buffers, making both buffers empty. 0, Description = Take no action",
    "Bit 0 - RXBF Receive Buffer Full\n1, Description = Receive buffer is full. 0, Description = Receive buffer is not full",
    "35.7.9 SPIxRXB\nName:\nSPIxRXB\nAddress:\n0x080,0x08D",
    "SPI Receive Buffer\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RXB[7:0]. , 2 = RXB[7:0]. , 3 = RXB[7:0]. , 4 = RXB[7:0]. , 5 = RXB[7:0]. , 6 = RXB[7:0]. , 7 = RXB[7:0]. , 8 = RXB[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 7:0 - RXB[7:0] Receive Buffer\nn, Condition = Receive buffer is not empty. n, Description = Contains the top-most byte of the RXFIFO. Reading this register will remove the RXFIFO top-most byte and decrease the occupancy of the RXFIFO by 1.. 0, Condition = Receive buffer is empty. 0, Description = Reading this register will return ' 0 ', leave the occupancy unchanged, and set the RXRE Status bit",
    "35.7.10  SPIxTXB\nName: Address:\nSPIxTXB 0x081,0x08E",
    "SPI Transmit Buffer\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXB[7:0]. , 2 = TXB[7:0]. , 3 = TXB[7:0]. , 4 = TXB[7:0]. , 5 = TXB[7:0]. , 6 = TXB[7:0]. , 7 = TXB[7:0]. , 8 = TXB[7:0]. Access, 1 = W. Access, 2 = W. Access, 3 = W. Access, 4 = W. Access, 5 = W. Access, 6 = W. Access, 7 = W. Access, 8 = W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 7:0 - TXB[7:0] Transmit Buffer\nn, Condition = Transmit buffer is not full. n, Description = Writing to this register adds the data to the top of the TXFIFO and increases the occupancy of the TXFIFO by 1.. x, Condition = Transmit buffer is full. x, Description = Writing to this register does not affect the data in the TXFIFO or the occupancy count. The TXWE Status bit will be set.",
    "35.7.11  SPIxINTE\nName: Address:\nSPIxINTE 0x08B,0x098",
    "SPI Interrupt Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SRMTIE. , 2 = TCZIE. , 3 = SOSIE. , 4 = EOSIE. , 5 = . , 6 = RXOIE. , 7 = TXUIE. , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = ",
    "Bit 7 - SRMTIE Shift Register Empty Interrupt Enable\n1, Description = Interrupt is enabled. 0, Description = Interrupt is not enabled",
    "Bit 6 - TCZIE Transfer Counter is Zero Interrupt Enable\n1, Description = Interrupt is enabled. 0, Description = Interrupt is not enabled",
    "Bit 5 - SOSIE Start of Client Select Interrupt Enable\n1, Description = Interrupt is enabled. 0, Description = Interrupt is not enabled",
    "Bit 4 - EOSIE End of Client Select Interrupt Enable\n1, Description = Interrupt is enabled. 0, Description = Interrupt is not enabled",
    "Bit 2 - RXOIE Receiver Overflow Interrupt Enable\n1, Description = Interrupt is enabled. 0, Description = Interrupt is not enabled",
    "Bit 1 - TXUIE Transmitter Underflow Interrupt Enable\n1, Description = Interrupt is enabled. 0, Description = Interrupt is not enabled",
    "35.7.12  SPIxINTF\nName: Address:\nSPIxINTF 0x08A,0x097",
    "SPI Interrupt Flag Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SRMTIF. , 2 = TCZIF. , 3 = SOSIF. , 4 = EOSIF. , 5 = . , 6 = RXOIF. , 7 = TXUIF. , 8 = . Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = . Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = ",
    "Bit 7 - SRMTIF Shift Register Empty Interrupt Flag\nx, Mode = Client. x, Description = This bit is ignored. 1, Mode = Host. 1, Description = The data transfer is complete. 0, Mode = Host. 0, Description = Either no data transfers have occurred or a data transfer is in progress",
    "Bit 6 - TCZIF Transfer Counter is Zero Interrupt Flag\n1, Description = The transfer counter has decremented to zero. 0, Description = No interrupt pending",
    "Bit 5 - SOSIF Start of Client Select Interrupt Flag\n1, Description = SS_in transitioned from false to true. 0, Description = No interrupt pending",
    "Bit 4 - EOSIF End of Client Select Interrupt Flag\n1, Description = SS_in transitioned from true to false. 0, Description = No interrupt pending",
    "Bit 2 - RXOIF Receiver Overflow Interrupt Flag\n1, Description = Data transfer completed when RXBF = 1 (edge-triggered) and RXR = 1. 0, Description = No interrupt pending",
    "Bit 1 - TXUIF Transmitter Underflow Interrupt Flag\n1, Description = Client Data transfer started when TXBE = 1 and TXR = 1. 0, Description = No interrupt pending",
    "35.8 Register Summary - SPI Control\n0x00 ... 0x7F, Name = Reserved. 0x00 ... 0x7F, Bit Pos. = . 0x00 ... 0x7F, 7 = . 0x00 ... 0x7F, 6 = . 0x00 ... 0x7F, 5 = . 0x00 ... 0x7F, 4 = . 0x00 ... 0x7F, 3 = . 0x00 ... 0x7F, 2 = . 0x00 ... 0x7F, 1 = . 0x00 ... 0x7F, 0 = . 0x80, Name = SPI1RXB. 0x80, Bit Pos. = 7:0. 0x80, 7 = . 0x80, 6 = . 0x80, 5 = . 0x80, 4 = RXB[7:0]. 0x80, 3 = . 0x80, 2 = . 0x80, 1 = . 0x80, 0 = . 0x81, Name =",
    "35.8 Register Summary - SPI Control\nSPI1TXB. 0x81, Bit Pos. = 7:0. 0x81, 7 = . 0x81, 6 = . 0x81, 5 = . 0x81, 4 = TXB[7:0]. 0x81, 3 = . 0x81, 2 = . 0x81, 1 = . 0x81, 0 = . 0x82, Name = SPI1TCNT. 0x82, Bit Pos. = 7:0. 0x82, 7 = . 0x82, 6 = . 0x82, 5 = . 0x82, 4 = TCNTL[7:0]. 0x82, 3 = . 0x82, 2 = . 0x82, 1 = . 0x82, 0 = . 0x82, Name = SPI1TCNT. 0x82, Bit Pos. = 15:8. 0x82, 7 = . 0x82, 6 = . 0x82, 5 = . 0x82,",
    "35.8 Register Summary - SPI Control\n4 = . 0x82, 3 = . 0x82, 2 = TCNTH[2:0]. 0x82, 1 = TCNTH[2:0]. 0x82, 0 = TCNTH[2:0]. 0x84, Name = SPI1CON0. 0x84, Bit Pos. = 7:0. 0x84, 7 = EN. 0x84, 6 = . 0x84, 5 = . 0x84, 4 = . 0x84, 3 = . 0x84, 2 = LSBF. 0x84, 1 = MST. 0x84, 0 = BMODE. 0x85, Name = SPI1CON1. 0x85, Bit Pos. = 7:0. 0x85, 7 = SMP. 0x85, 6 = CKE. 0x85, 5 = CKP. 0x85, 4 = FST. 0x85, 3 = . 0x85, 2 = SSP. 0x85, 1 = SDIP.",
    "35.8 Register Summary - SPI Control\n0x85, 0 = SDOP. 0x86, Name = SPI1CON2. 0x86, Bit Pos. = 7:0. 0x86, 7 = BUSY. 0x86, 6 = SSFLT. 0x86, 5 = . 0x86, 4 = . 0x86, 3 = . 0x86, 2 = SSET. 0x86, 1 = TXR. 0x86, 0 = RXR. 0x87, Name = SPI1STATUS. 0x87, Bit Pos. = 7:0. 0x87, 7 = TXWE. 0x87, 6 = . 0x87, 5 = TXBE. 0x87, 4 = . 0x87, 3 = RXRE. 0x87, 2 = CLB. 0x87, 1 = . 0x87, 0 = RXBF. 0x88, Name = SPI1TWIDTH. 0x88, Bit Pos. = 7:0. 0x88, 7 = . 0x88, 6",
    "35.8 Register Summary - SPI Control\n= . 0x88, 5 = . 0x88, 4 = . 0x88, 3 = . 0x88, 2 = TWIDTH[2:0]. 0x88, 1 = TWIDTH[2:0]. 0x88, 0 = TWIDTH[2:0]. 0x89, Name = SPI1BAUD. 0x89, Bit Pos. = 7:0. 0x89, 7 = . 0x89, 6 = . 0x89, 5 = . 0x89, 4 = BAUD[7:0]. 0x89, 3 = . 0x89, 2 = . 0x89, 1 = . 0x89, 0 = . 0x8A, Name = SPI1INTF. 0x8A, Bit Pos. = 7:0. 0x8A, 7 = SRMTIF. 0x8A, 6 = TCZIF. 0x8A, 5 = SOSIF. 0x8A, 4 = EOSIF.",
    "35.8 Register Summary - SPI Control\n0x8A, 3 = . 0x8A, 2 = RXOIF. 0x8A, 1 = TXUIF. 0x8A, 0 = . 0x8B, Name = SPI1INTE. 0x8B, Bit Pos. = 7:0. 0x8B, 7 = SRMTIE. 0x8B, 6 = TCZIE. 0x8B, 5 = SOSIE. 0x8B, 4 = EOSIE. 0x8B, 3 = . 0x8B, 2 = RXOIE. 0x8B, 1 = TXUIE. 0x8B, 0 = . 0x8C, Name = SPI1CLK. 0x8C, Bit Pos. = 7:0. 0x8C, 7 = . 0x8C, 6 = . 0x8C, 5 = . 0x8C, 4 = . 0x8C, 3 = . 0x8C, 2 = CLKSEL[3:0]. 0x8C, 1 = CLKSEL[3:0].",
    "35.8 Register Summary - SPI Control\n0x8C, 0 = CLKSEL[3:0]. 0x8D, Name = SPI2RXB. 0x8D, Bit Pos. = 7:0. 0x8D, 7 = . 0x8D, 6 = . 0x8D, 5 = . 0x8D, 4 = RXB[7:0]. 0x8D, 3 = . 0x8D, 2 = . 0x8D, 1 = . 0x8D, 0 = . 0x8E, Name = SPI2TXB. 0x8E, Bit Pos. = 7:0. 0x8E, 7 = . 0x8E, 6 = . 0x8E, 5 = . 0x8E, 4 = TXB[7:0]. 0x8E, 3 = . 0x8E, 2 = . 0x8E, 1 = . 0x8E, 0 = . 0x8F, Name = SPI2TCNT. 0x8F, Bit Pos. = 7:0. 0x8F,",
    "35.8 Register Summary - SPI Control\n7 = . 0x8F, 6 = . 0x8F, 5 = . 0x8F, 4 = TCNTL[7:0]. 0x8F, 3 = . 0x8F, 2 = . 0x8F, 1 = . 0x8F, 0 = . 0x8F, Name = SPI2TCNT. 0x8F, Bit Pos. = 15:8. 0x8F, 7 = . 0x8F, 6 = . 0x8F, 5 = . 0x8F, 4 = . 0x8F, 3 = . 0x8F, 2 = TCNTH[2:0]. 0x8F, 1 = TCNTH[2:0]. 0x8F, 0 = TCNTH[2:0]. 0x91, Name = SPI2CON0. 0x91, Bit Pos. = 7:0. 0x91, 7 = EN. 0x91, 6 = . 0x91, 5 = . 0x91, 4 = . 0x91,",
    "35.8 Register Summary - SPI Control\n3 = . 0x91, 2 = LSBF. 0x91, 1 = MST. 0x91, 0 = BMODE. 0x92, Name = SPI2CON1. 0x92, Bit Pos. = 7:0. 0x92, 7 = SMP. 0x92, 6 = CKE. 0x92, 5 = CKP. 0x92, 4 = FST. 0x92, 3 = . 0x92, 2 = SSP. 0x92, 1 = SDIP. 0x92, 0 = SDOP. 0x93, Name = SPI2CON2. 0x93, Bit Pos. = 7:0. 0x93, 7 = BUSY. 0x93, 6 = SSFLT. 0x93, 5 = . 0x93, 4 = . 0x93, 3 = . 0x93, 2 = SSET. 0x93, 1 = TXR. 0x93, 0 = RXR. 0x94,",
    "35.8 Register Summary - SPI Control\nName = SPI2STATUS. 0x94, Bit Pos. = 7:0. 0x94, 7 = TXWE. 0x94, 6 = . 0x94, 5 = TXBE. 0x94, 4 = . 0x94, 3 = RXRE. 0x94, 2 = CLB. 0x94, 1 = . 0x94, 0 = RXBF. 0x95, Name = SPI2TWIDTH. 0x95, Bit Pos. = 7:0. 0x95, 7 = . 0x95, 6 = . 0x95, 5 = . 0x95, 4 = . 0x95, 3 = . 0x95, 2 = TWIDTH[2:0]. 0x95, 1 = TWIDTH[2:0]. 0x95, 0 = TWIDTH[2:0]. 0x96, Name = SPI2BAUD. 0x96, Bit Pos. = 7:0.",
    "35.8 Register Summary - SPI Control\n0x96, 7 = . 0x96, 6 = . 0x96, 5 = . 0x96, 4 = BAUD[7:0]. 0x96, 3 = . 0x96, 2 = . 0x96, 1 = . 0x96, 0 = . 0x97, Name = SPI2INTF. 0x97, Bit Pos. = 7:0. 0x97, 7 = SRMTIF. 0x97, 6 = TCZIF. 0x97, 5 = SOSIF. 0x97, 4 = EOSIF. 0x97, 3 = . 0x97, 2 = RXOIF. 0x97, 1 = TXUIF. 0x97, 0 = . 0x98, Name = SPI2INTE. 0x98, Bit Pos. = 7:0. 0x98, 7 = SRMTIE. 0x98, 6 = TCZIE. 0x98, 5 = SOSIE. 0x98, 4 =",
    "35.8 Register Summary - SPI Control\nEOSIE. 0x98, 3 = . 0x98, 2 = RXOIE. 0x98, 1 = TXUIE. 0x98, 0 = . 0x99, Name = SPI2CLK. 0x99, Bit Pos. = 7:0. 0x99, 7 = . 0x99, 6 = . 0x99, 5 = . 0x99, 4 = . 0x99, 3 = . 0x99, 2 = CLKSEL[3:0]. 0x99, 1 = CLKSEL[3:0]. 0x99, 0 = ",
    "36. I 2 C - Inter-Integrated Circuit Module\nThe Inter-Integrated Circuit (I 2 C) bus is a multi-host serial data communication bus. Devices communicate in a host/client environment where the host devices initiate the communication. A client device is controlled through addressing.\nThe following figure shows a block diagram of the I 2 C interface module and shows both Host and Client modes together.\nFigure 36-1. I 2 C Block Diagram",
    "36.1 I 2 C Features\nThe I 2 C supports the following modes and features:\n\u00b7 Modes\n-Host mode\n-Client mode\n-Multi-Host mode\n\u00b7 Features\n-Supports Standard mode (100 kHz), Fast mode (400 kHz) and Fast mode Plus (1 MHz) modes of operation\n-Dedicated Address, Receive, and Transmit buffers\n-Up to four unique Client addresses\n-General Call addressing",
    "36.1 I 2 C Features\n-7-bit and 10-bit addressing with optional masking\n-Interrupts for:\n\u00b7 Start condition\n\u00b7 Restart condition\n\u00b7 Stop condition\n\u00b7 Address match\n\u00b7 Data Write\n\u00b7 Acknowledge Status\n\u00b7 NACK detection\n\u00b7 Data Byte Count\n\u00b7 Bus Collision\n\u00b7 Bus Time-out\n-Clock Stretching for:\n\u00b7 RX buffer full\n\u00b7 TX buffer empty\n\u00b7 Incoming address match\n\u00b7 Data Write\n\u00b7 Acknowledge Status\n-Bus Collision Detection with Arbitration\n-Bus Time-out Detection\n\u00b7 Selectable clock sources\n\u00b7 Clock prescaler\n-Selectable Serial Data (SDA) Hold Time\n-Dedicated I 2 C Pad (I/O) Control\n\u00b7 Standard GPIO or I 2 C-specific slew rate control\n\u00b7 Selectable I 2 C pull-up levels\n\u00b7 I 2 C-specific, SMBus 2.0/3.0, or standard GPIO input threshold level selections\n-Integrated Direct Memory Access (DMA) support\n-Remappable pin locations using Peripheral Pin Select (PPS)",
    "36.2 I 2 C Terminology\nThe I 2 C communication protocol terminology used throughout this document have been adapted from the Phillips I 2 C Specification and can be found in the table below.",
    "I 2 C Bus Terminology and Definitions\nHost, Definition = The device that initiates a transfer, generates the clock signal and terminates a transfer. Client, Definition = The device addressed by the host. Multi-Host, Definition = A bus containing more than one host device that can initiate communication. Transmitter, Definition = The device that shifts data out onto the bus. Receiver, Definition = The device that shifts data in from the bus. Arbitration, Definition = Procedure that ensures only one host at a time controls the bus. Synchronization, Definition = Procedure that synchronizes the clock signal between two or more devices on the bus. Idle, Definition = The state in which no activity occurs on the bus and both bus lines are at a high logic level",
    "I 2 C Bus Terminology and Definitions\nActive, 1 = The state in which one or more devices are communicating on the bus. Matching Address, 1 = The address byte received by a client that matches the value that is stored in the I2CxADR0/1/2/3 registers. Addressed Client, 1 = Client device that has received a matching address and is actively being clocked by a host device. Write Request, 1 = Host transmits an address with the R/W bit clear indicating that it wishes to transmit data to a client device. Read Request, 1 = Host transmits an address with the R/W bit set indicating that it wishes to receive data from a client device. Clock Stretching, 1 = The action in which a device holds the SCL line low to stall communication. Bus Collision, 1 = Occurs when the module samples the SDA line and returns a low state while expecting a high state. Bus Time-out, 1 = Occurs whenever communication stalls for a period longer than acceptable",
    "36.3 I 2 C Module Overview\nThe I 2 C module provides a synchronous serial interface between the microcontroller and other I 2 C compatible devices using a bidirectional two-wire bus. Devices operate in a host/client environment that may contain one or more host devices and one or more client devices. The host device always initiates communication.\nThe I 2 C bus consists of two signal connections:\n\u00b7 Serial Clock (SCL)\n\u00b7 Serial Data (SDA)",
    "36.3 I 2 C Module Overview\nBoth the SCL and SDA connections are open-drain lines, each line requiring pull-up resistors to the application's supply voltage. Pulling the line to ground is considered a logic ' 0 ', while allowing the line to float is considered a logic ' 1 '. It is important to note that the voltage levels of the logic low and logic high are not fixed and are dependent on the bus supply voltage. According to the I 2 C Specification, a logic low input level is up to 30% of V DD (V IL \u2264 0.3 V DD), while the logic high input level is 70% to 100% of VDD (VIH \u2265 0.7 V DD). Both signal connections are considered bidirectional, although the SCL signal can only be an output in Host mode and an input in Client mode.\nAll transactions on the bus are initiated and terminated by the host device. Depending on the direction of the data being transferred, there are four main operations performed by the I 2 C module:",
    "36.3 I 2 C Module Overview\n\u00b7 Host Transmit: Host is transmitting data to a client\n\u00b7 Host Receive: Host is receiving data from a client\n\u00b7 Client Transmit: Client is transmitting data to a host\n\u00b7 Client Receive: Client is receiving data from a host\nThe I 2 C interface allows for a multi-host bus, meaning that there can be several host devices present on the bus. A host can select a client device by transmitting a unique address on the bus. When the address matches a client's address, the client responds with an Acknowledge (ACK) condition, and communication between the host and that client can commence. All other devices connected to the bus must ignore any transactions not intended for them.\nThe following figure shows a typical I 2 C bus configuration with one host and two clients.",
    "36.3.1 Byte Format\nAs previously mentioned, all I 2 C communication is performed in 9-bit segments. The transmitting device sends a byte to a receiver, and once the byte is processed by the receiver, the receiver returns an Acknowledge bit. There are no limits to the amount of data bytes in a I 2 C transmission.\nAfter the 8 th falling edge of the SCL line, the transmitting device releases control of the SDA line to allow the receiver to respond with either an Acknowledge (ACK) sequence or a Not Acknowledge (NACK) sequence. At this point, if the receiving device is a client, it can hold the SCL line low (clock stretch) to allow itself time to process the incoming byte. Once the byte has been processed, the receiving device releases the SCL line, allowing the host device to provide the 9 th  clock pulse, within which the client responds with either an ACK or a NACK sequence. If the receiving device is a host, it may also hold the SCL line low until it has processed the received byte. Once the byte has been processed, the host device will generate the 9 th  clock pulse and transmit the ACK or NACK sequence.",
    "36.3.1 Byte Format\nData are valid to change only while the SCL signal is in a Low state and sampled on the rising edge of SCL. Changes on the SDA line while the SCL line is high indicate either a Start or Stop condition.",
    "36.3.2 SDA and SCL Pins\nThe SDA and SCL pins must be configured as open-drain outputs. Open-drain configuration is accomplished by setting the appropriate bits in the Open-Drain Control (ODCONx) registers, while output direction configuration is handled by clearing the appropriate bits in the Tri-State Control (TRISx) registers. Input threshold, slew rate, and internal pull-up settings are configured using the RxyI2C registers. The RxyI2C registers are used exclusively on the default I 2 C pin locations and provide the following selections:\n\u00b7 Input threshold levels:\n-SMBus 3.0 (1.35V) input threshold",
    "36.3.2 SDA and SCL Pins\n-SMBus 2.0 (2.1V) input threshold\n-I 2 C-specific input thresholds\n-Standard GPIO input thresholds (controlled by the Input Level Control (INLVLx) registers)\n\u00b7 Slew rate limiting:\n-I 2 C-specific slew rate limiting\n-Standard GPIO slew rate (controlled by the Slew Rate Control (SLRCONx) registers)\n\u00b7 I 2 C pull-ups:\n-Programmable ten or two times the current of the standard internal pull-up\n-Standard GPIO pull-up (controlled by the Weak Pull-Up Control (WPUx) registers)",
    "36.3.2 SDA and SCL Pins\nImportant: The pin locations for SDA and SCL are remappable through the Peripheral Pin Select (PPS) registers. If new pin locations for SDA and SCL are desired, user software must configure the INLVLx, SLRCONx, ODCONx, and TRISx registers for each new pin location. The RxyI2C registers cannot be used since they are dedicated to the default pin locations. Additionally, the internal pull-ups for non-I 2 C pins are not strong enough to drive the pins; therefore, external pull-up resistors must be used.",
    "36.3.2.1 SDA Hold Time Filename: Title:\nSDA Hold Time.vsdx\nSDA hold time refers to the amount of time between the low threshold region of the falling edge of SCL (VIL \u2264 0.3 V DD) and either the low threshold region of the rising edge of SDA (V IL \u2264 0.3 V DD) or the high threshold region of the falling edge of SDA (V IH \u2265 0.7 V DD) (see Figure 36-3). If the SCL fall time is long or close to the maximum allowable time set by the I 2 C Specification, data may be sampled in the undefined Logic state between the 70% and 30% region of the falling SCL edge, leading to data corruption. The I 2 C module offers selectable SDA hold times, which can be useful to ensure valid data transfers at various bus data rates and capacitance loads. Last Edit: 11/15/2018 First Used: Notes:\nFigure 36-3. SDA Hold Time",
    "36.3.3 Start Condition\nAll I 2 C transmissions begin with a Start condition. The Start condition is used to synchronize the SCL signals between the host and client devices. The I 2 C Specification defines a Start condition as a transition of the SDA line from a logic high level (Idle state) to a logic low level (Active state) while the SCL line is at a logic high (see Figure 36-4). A Start condition is always generated by the host, and is initiated by either writing to the Start (S) bit or by writing to the I 2 C Transmit Buffer (I2CxTXB) register, depending on the Address Buffer Disable (ABD) bit setting.",
    "36.3.3 Start Condition\nWhen the I 2 C module is configured in Host mode, module hardware waits until the bus is free (Idle state). Module hardware checks the Bus Free Status (BFRE) bit to ensure the bus is Idle before initiating a Start condition. When the BFRE bit is set, the bus is considered Idle and indicates that the SCL and SDA lines have been in a Logic High state for the amount of I 2 C clock cycles as selected by the Bus Free Time Selection (BFRET) bits. When a Start condition is detected on the bus, module hardware clears the BFRE bit, indicating an active bus. Filename: Start Condition.vsdx\nIn Multi-Host mode, it is possible for two host devices to issue Start conditions at the same time. If two or more hosts initiate a Start at the same time, a bus collision will occur; however, the I 2 C Specification states that a bus collision cannot occur on a Start. In this case, the competing host devices must go through bus arbitration during the addressing phase. Last Edit: 11/15/2018 First Used: Notes:\nTitle:\nThe figure below shows a Start condition.\nFigure 36-4. Start Condition",
    "36.3.4 Acknowledge Sequence\nThe 9th SCL pulse for any transferred address/data byte is reserved for the Acknowledge (ACK) sequence. During an Acknowledge sequence, the transmitting device relinquishes control of the SDA line to the receiving device. At this time, the receiving device must decide whether to pull the SDA line low (ACK) or allow the line to float high (NACK). Since the Acknowledge sequence is an active-low signal, pulling the SDA line low informs the transmitter that the receiver has successfully received the transmitted data.",
    "36.3.4 Acknowledge Sequence\nThe Acknowledge Data (ACKDT) bit holds the value to be transmitted during an Acknowledge sequence while the I2CxCNT register is nonzero (I2CxCNT != 0 ). When a client device receives a matching address, or a receiver receives valid data, the ACKDT bit is cleared by user software to indicate an ACK. If the client does not receive a matching address, user software sets the ACKDT bit, indicating a NACK. In Client or Multi-Host modes, if the Address Interrupt and Hold Enable (ADRIE) or Write Interrupt and Hold Enable (WRIE) bits are set, the clock is stretched after receiving a matching\naddress or after the 8th falling edge of SCL when a data byte is received. This allows user software time to determine the ACK/NACK response to send back to the transmitter.",
    "36.3.4 Acknowledge Sequence\nThe Acknowledge End of Count (ACKCNT) bit holds the value that will be transmitted once the I2CxCNT register reaches a zero value (I2CxCNT = 0 ). When the I2CxCNT register reaches a zero value, the ACKCNT bit can be cleared (ACKCNT = 0 ), indicating an ACK, or ACKCNT can be set (ACKCNT = 1 ), indicating a NACK.\nImportant: The ACKCNT bit is only used when the I2CxCNT register is zero, otherwise the ACKDT bit is used for ACK/NACK sequences.\nIn Host Write or Client Read modes, the Acknowledge Status (ACKSTAT) bit holds the result of the Acknowledge sequence transmitted by the receiving device. The ACKSTAT bit is cleared when the receiver sends an ACK, and is set when the receiver does not Acknowledge (NACK).",
    "36.3.4 Acknowledge Sequence\nThe Acknowledge Time Status (ACKT) bit indicates whether or not the bus is in an Acknowledge sequence. The ACKT bit is set during an ACK/NACK sequence on the 8th falling edge of SCL, and is cleared on the 9th rising edge of SCL, indicating that the bus is not in an ACK/NACK sequence.\nCertain conditions will cause a NACK sequence to be sent automatically. A NACK sequence is generated by module hardware when any of the following bits are set:\n\u00b7 Transmit Write Error Status (TXWE)\n\u00b7 Transmit Underflow Status (TXU)\n\u00b7 Receive Read Error Status (RXRE)\n\u00b7 Receive Overflow Status (RXO)\nFilename:\nAcknowledge Sequence.vsdx\nTitle:\nImportant: Once a NACK is detected on the bus, all subsequent Acknowledge sequences will consist of a NACK until all Error conditions are cleared. Last Edit: 1/8/2019 First Used: Notes:\nThe following figure shows ACK and NACK sequences.\nFigure 36-5. ACK/NACK Sequences",
    "36.3.5 Restart Condition\nA Restart condition is essentially the same as a Start condition - the SDA line transitions from an idle level to an active level while the SCL line is Idle - but may be used in place of a Stop condition whenever the host device has completed its current transfer but wishes to keep control of the bus. A Restart condition has the same effect as a Start condition, resetting all client logic and preparing it to receive an address.\nRev. Acknowledg\n1/8/2019",
    "36.3.5 Restart Condition\nA Restart condition is also used when the host wishes to use a combined data transfer format. A combined data transfer format is used when a host wishes to communicate with a specific register address or memory location. In a combined format, the host issues a Start condition, followed by the client's address, followed by a data byte which represents the desired client register or memory address. Once the client address and data byte have been acknowledged by the client, the host issues a Restart condition, followed by the client address. If the host wishes to write data to the client, the LSb of the client address, the Read/not Write (R/W) bit, will be clear. If the host wishes to read data from the client, the R/W bit will be set. Once the client has acknowledged the second address byte, the host issues a Restart condition, followed by the upper byte of the client address with the R/W bit set. Client logic will then acknowledge the upper byte and begin to transmit data to the host. Filename: Restart condition.vsdx Title:\nLast Edit:\n11/15/2018\nFirst Used:",
    "36.3.5 Restart Condition\nImportant: In 10-bit Client mode, a Restart is required for the host to read data out of the client, regardless of which data transfer format is used - host read-only or combined. For example, if the host wishes to perform a bulk read, it will transmit the client's 10-bit address with the R/W bit clear. Notes:\nThe figure below shows a Restart condition.\nFigure 36-6. Restart Condition",
    "36.3.6 Stop Condition\nAll I 2 C transmissions end with a Stop condition. A Stop condition occurs when the SDA line transitions from a logic low (active) level to a logic high (idle) level while the SCL line is at a logic high level. A Stop condition is always generated by the host device and is generated by module hardware when a Not Acknowledge (NACK) is detected on the bus, a bus time-out event occurs, or when the I 2 C Byte Count (I2CxCNT) register reaches a zero count. A Stop condition may also be generated through software by setting the Stop (P) bit.\nThe figure below shows a Stop condition.",
    "36.3.7 Bus Time-Out\nThe SMBus protocol requires a bus watchdog to prevent a stalled device from holding the bus indefinitely. The I2C Bus Time-Out Clock Source Selection (I2CxBTOC) register provides several clock sources that can be used as the time-out time base. The I2C Bus Time-Out (I2CxBTO) register is used to determine the actual bus time-out time period, as well as how the module responds to a time-out.\nThe bus time-out hardware monitors for the following conditions:\n\u00b7 SCL = 0 (regardless of whether or not the bus is Active)\n\u00b7 SCL = 1 and SDA = 0 while the bus is Active\nIf either of these conditions are true, an internal time-out counter increments and continues to increment as long as the condition stays true or until the time-out period has expired. If these conditions change (e.g. SCL = 1 ), the internal time-out counter is reset by module hardware.",
    "36.3.7 Bus Time-Out\nThe Bus Time-Out Clock Source Selection (BTOC) bits select the time-out clock source. If an oscillator is selected as the time-out clock source, such as the LFINTOSC, the time-out clock base period is approximately 1 ms. If a timer is selected as the time-out clock source, the timer can be configured to produce a variety of time periods.\nRemember: The SMBus protocol dictates a 25 ms time-out for client devices and a 35 ms time-out for host devices.",
    "36.3.7 Bus Time-Out\nThe Time-Out Time Selection (TOTIME) bits and the Time-Out Prescaler Extension Enable (TOBY32) bit are used to determine the time-out period. The value written into TOTIME multiplies the base time-out clock period. For example, if a value of ' 35 ' is written into the TOTIME bits, and the LFINTOSC is selected as the time-out clock source, the time-out period is approximately 35 ms (35 x 1 ms). If the TOBY32 bit is set (TOBY32 = 1 ), the time-out period determined by the TOTIME bits is multiplied by 32. If TOBY32 is clear (TOBY32 = 0 ), the time-out period determined by the TOTIME bits is used as the time-out period.\nThe examples below illustrate possible time-out configurations.",
    "36.3.7 Bus Time-Out\nThe Time-Out Recovery Selection (TOREC) bit determines how the module will respond to a bus time-out. When a bus time-out occurs and TOREC is set (TOREC = 1 ), the I2C module is reset and module hardware sets the Bus Time-Out Interrupt Flag (BTOIF). If the Bus Time-Out Interrupt Enable (BTOIE) is also set, an interrupt will be generated. If a bus time-out occurs and TOREC is clear (TOREC = 0 ), the BTOIF bit is set, but the module is not reset.\nIf the module is configured in Client mode with TOREC set (TOREC = 1 ) and a bus time-out event occurs (regardless of the state of the Client Mode Active (SMA) bit), the module is immediately reset, the SMA and Client Clock Stretching (CSTR) bits are cleared, and the Bus Time-Out Interrupt Flag (BTOIF) bit is set.",
    "36.3.7 Bus Time-Out\nIf the module is configured in Client mode with TOREC clear (TOREC = 0 ) and a bus time-out event occurs (regardless of the state of the Client Mode Active (SMA) bit), the BTOIF bit is set, but user software must reset the module.\nImportant: It is recommended to set TOREC (TOREC = 1 ) when operating in Client mode.\nIf the module is configured in Host mode with TOREC set (TOREC = 1 ) and the bus time-out event occurs while the Host is active (Host Mode Active (MMA) = 1 ), the Host Data Ready (MDR) bit is cleared, the module will immediately attempt to transmit a Stop condition and the BTOIF bit is set. Stop condition generation may be delayed if a client device is stretching the clock, but will resume once the clock is released or if the client holding the bus also has a time-out event occur. The MMA bit is only cleared after the Stop condition has been generated.",
    "36.3.7 Bus Time-Out\nIf the module is configured in Host mode with TOREC clear (TOREC = 0 ) and the bus time-out event occurs while the Host is active (Host Mode Active (MMA) = 1 ), the MDR bit is cleared and the BTOIF bit is set, but user software must initiate the Stop condition by setting the P bit.\nThe figure below shows an example of a Bus Time-Out event when the module is operating in Host mode.\nTitle:\nLast Edit:\nFirst Used:\nNotes:",
    "Figure 36-8. Host Mode Bus Time-Out Example\n,",
    "36.3.8 Address Buffers\nThe I 2 C module has two address buffer registers, I2CxADB0 and I2CxADB1, which can be used as address receive buffers in Client mode, address transmit buffers in Host mode, or both address transmit and address receive buffers in 7-bit Multi-Host mode (see Table 36-1). The address buffers are enabled/disabled via the Address Buffer Disable (ABD) bit.\nWhen the ABD bit is clear (ABD = 0 ), the buffers are enabled, which means:",
    "36.3.8 Address Buffers\n\u00b7 In 7-bit Host mode, the desired client address with the R/W value is transmitted from the I2CxADB1 register, bypassing the I2C Transmit Buffer (I2CxTXB). I2CxADB0 is unused.\n\u00b7 In 10-bit Host mode, I2CxADB1 holds the upper bits and R/W value of the desired client address, while I2CxADB0 holds the lower eight bits of the desired client address. Host hardware copies the contents of I2CxADB1 to the transmit shift register and waits for an ACK from the client. Once the ACK is received, host hardware copies the contents of I2CxADB0 to the transmit shift register.\n\u00b7 In 7-bit Client mode, a matching received address is loaded into I2CxADB0, bypassing the I2C Receive Buffer (I2CxRXB). I2CxADB1 is unused.",
    "36.3.8 Address Buffers\n\u00b7 In 10-bit Client mode, I2CxADB0 is loaded with the lower eight bits of the matching received address, while I2CxADB1 is loaded with the upper bits and R/W value of the matching received address.\n\u00b7 In 7-bit Multi-Host mode, the device can be both a host and a client depending on the sequence of events on the bus. When being addressed as a client, the matching received address with R/W value is stored into I2CxADB0. When being used as a host, the desired client address and R/W value are loaded into the I2CxADB1 register.\nWhen the ABD bit is set (ABD = 1 ), the buffers are disabled, which means:\n\u00b7 In Host mode, the desired client address is transmitted from the I2CxTXB register.\n\u00b7 In Client mode, a matching received address is loaded into the I2CxRXB register.\nTable 36-1. Address Buffer Direction\nMode\nI2CxADB0\nI2CxADB1\n1/9/2019",
    "36.3.8 Address Buffers\nClient (10-bit), RX = RX (address low byte). Client (10-bit), Unused = RX (address high byte). Host (7-bit), RX = Unused. Host (7-bit), Unused = TX. Host (10-bit), RX = TX (address low byte). Host (10-bit), Unused = TX (address high byte). Multi-Host (7-bit), RX = RX. Multi-Host (7-bit), Unused = TX",
    "36.3.9 Transmit Buffer\nThe I 2 C module has a dedicated transmit buffer, I2CxTXB, which is independent from the receive buffer.\nThe transmit buffer is loaded with an address byte (when ABD = 1 ), or a data byte, that is copied into the transmit shift register and transmitted onto the bus. When the I2CxTXB register does not contain any transmit data, the Transmit Buffer Empty Status (TXBE) bit is set (TXBE = 1 ), allowing user software or the DMA to load a new byte into the buffer. When the TXBE bit is set and the I2CxCNT register is nonzero (I2CxCNT != 0 ), the I 2 C Transmit Interrupt Flag (I2CxTXIF) bit of the PIR registers is set and can be used as a DMA trigger. A write to I2CxTXB will clear both the TXBE and I2CxTXIF bits. Setting the Clear Buffer (CLRBF) bit clears I2CxTXIF, the I2Cx Receive Buffer (I2CxRXB) and I2CxTXB.",
    "36.3.9 Transmit Buffer\nIf user software attempts to load I2CxTXB while it is full, the Transmit Write Error Status (TXWE) bit is set, a NACK is generated, and the new data are ignored. If TXWE is set, user software must clear the bit before attempting to load the buffer again.\nWhen module hardware attempts to transfer the contents of I2CxTXB to the transmit shift register while I2CxTXB is empty (TXBE = 1 ), the Transmit Underflow Status (TXU) bit is set, I2CxTXB is loaded with 0xFF , and a NACK is generated.\nImportant: A transmit underflow can only occur when clock stretching is disabled (Clock Stretching Disable (CSD) bit = 1 ). Clock stretching prevents transmit underflows because the clock is stretched after the 8th falling SCL edge and is only released upon the write of new data into I2CxTXB.",
    "36.3.10  Receive Buffer\nThe I 2 C module has a dedicated receive buffer, I2CxRXB, which is independent from the transmit buffer.\nData received through the shift register is transferred to I2CxRXB when the byte is complete. User software or the DMA can access the byte by reading the I2CxRXB register. When new data are loaded into I2CxRXB, the Receive Buffer Full Status (RXBF) bit is set, allowing user software or the DMA to read the new data. When the RXBF bit is set, the I 2 C Receive Interrupt Flag (I2CxRXIF) bit of the PIR registers is set and can be used to trigger the DMA. A read of the I2CxRXB register will clear both RXBF and I2CxRXIF bits. Setting the CLRBF bit clears the I2CxRXIF bit and the I2CxRXB and I2CxTXB registers.",
    "36.3.10  Receive Buffer\nIf the buffer is read while empty (RXBF = 0 ), the Receive Read Error Status (RXRE) bit is set, and the module generates a NACK. User software must clear RXRE to resume normal operation.\nWhen the module attempts to transfer the contents of the receive shift register to I2CxRXB while I2CxRXB is full (RXBF = 1 ), the Receive Overflow Status (RXO) bit is set, and a NACK is generated. The data currently stored in I2CxRXB remains unchanged, but the data in the receive shift register is lost.\nImportant: A receive overflow can only occur when clock stretching is disabled. Clock stretching prevents receive overflows because the receive shift register cannot receive any more data until user software or the DMA reads I2CxRXB and the SCL line is released.",
    "36.3.11  Clock Stretching\nClock stretching occurs when a client device holds the SCL line low to pause bus communication. A client device may stretch the clock to allow more time to process incoming data, prepare a response for the host device, or to prevent Receive Overflow or Transmit Underflow conditions. Clock stretching is enabled by clearing the Clock Stretch Disable (CSD) bit and is only available in Client and Multi-Host modes.\nWhen clock stretching is enabled (CSD = 0 ), the Client Clock Stretching (CSTR) bit can be used to determine if the clock is currently being stretched. While the client is actively stretching the clock, CSTR is set by hardware (CSTR = 1 ). Once the client has completed its current transaction and clock stretching is no longer required, either module hardware or user software must clear CSTR to release the clock and resume communication.\nFilename:\nReceive Buffer Clock Stretching.vsdx",
    "36.3.11.1 Clock Stretching for Buffer Operations Title: Last Edit: 5/8/2019\nWhen enabled (CSD = 0 ), clock stretching is forced during buffer read/write operations. This allows the client device time to either load I2CxTXB with transmit data or read data from I2CxRXB to clear the buffer. First Used: Notes:\nIn Client Receive mode, clock stretching prevents receive data overflows. When the first seven bits of a new byte are received into the receive shift register while I2CxRXB is full (RXBF = 1 ), client hardware automatically stretches the clock and sets CSTR. When the client has read the data in I2CxRXB, client hardware automatically clears CSTR to release the SCL line and continue communication (see Figure 36-9).\nFigure 36-9. Receive Buffer Clock Stretching\nLast Edit:\nFirst Used:\nNotes:",
    "36.3.11.1 Clock Stretching for Buffer Operations Title: Last Edit: 5/8/2019\nIn Client Transmit mode, clock stretching prevents transmit underflows. When I2CxTXB is empty (TXBE = 1 ) and the I2CxCNT register is nonzero (I2CxCNT != 0 ), client hardware stretches the clock and sets CSTR upon the 8th falling SCL edge. Once the client has loaded new data into I2CxTXB, client hardware automatically clears CSTR to release the SCL line and allow further communication (see Figure 36-10).\nFigure 36-10. Transmit Buffer Clock Stretching",
    "36.3.11.2 Clock Stretching for Other Client Operations\nThe I 2 C module provides three Interrupt and Hold Enable features:\n\u00b7 Address Interrupt and Hold Enable\n\u00b7 Data Write Interrupt and Hold Enable\n\u00b7 Acknowledge Status Time Interrupt and Hold Enable\nWhen clock stretching is enabled (CSD = 0 ), the Interrupt and Hold Enable features provide an interrupt response and stretch the clock to allow time for address recognition, data processing, or an ACK/NACK response.\nThe Address Interrupt and Hold Enable feature will generate an interrupt event and stretch the SCL line when a matching address is received. This feature is enabled by setting the Address Interrupt and Hold Enable (ADRIE) bit. When enabled (ADRIE = 1 ), the CSTR bit and the Address Interrupt Flag (ADRIF) bit are set by module hardware, and the SCL line is stretched following the 8th falling SCL edge of a received matching address. Once the client has completed processing the address, software determines whether to send an ACK or a NACK back to the host device. Client software must clear both the ADRIF and CSTR bits to resume communication.",
    "36.3.11.2 Clock Stretching for Other Client Operations\nImportant: In 10-bit Client Addressing mode, clock stretching occurs only after the client receives a matching low address byte or a matching high address byte with the R/W bit = 1 (Host read) while the Client Mode Active (SMA) bit is set (SMA = 1 ). Clock stretching does not occur after the client receives a matching high address byte with the R/W bit = 0 (Host write).\n5/8/2019\nThe Data Write Interrupt and Hold Enable feature provides an interrupt event and stretches the SCL signal after the client receives a data byte. This feature is enabled by setting the Data Write Interrupt and Hold Enable (WRIE) bit. When enabled (WRIE = 1 ), module hardware sets both the CSTR bit and the Data Write Interrupt Flag (WRIF) bit and stretches the SCL line after the 8th falling edge of SCL. Once the client has read the new data, software determines whether to send an ACK or a NACK back to the host device. Client software must clear both the CSTR and WRIF bits to resume communication.",
    "36.3.11.2 Clock Stretching for Other Client Operations\nThe Acknowledge Status Time Interrupt and Hold Enable feature generates an interrupt event and stretches the SCL line after the acknowledgement phase of a transaction. This feature is enabled by setting the Acknowledge Status Time Interrupt and Hold Enable (ACKTIE) bit. When enabled (ACKTIE = 1 ), module hardware sets the CSTR bit and the Acknowledge Status Time Interrupt Flag (ACKTIF) bit and stretches the clock after the 9th falling edge of SCL for all address, read, or write operations. Client software must clear both the ACKTIF and CSTR bits to resume communication.",
    "36.3.12  Data Byte Count\nThe data byte count refers to the number of data bytes in a complete I 2 C packet. The data byte count does not include address bytes. The I2C Byte Count (I2CxCNT) register is used to specify the length, in bytes, of the complete transaction. The value loaded into I2CxCNT will be decremented by module hardware each time a data byte is transmitted or received by the module.\nImportant: The I2CxCNT register will not decrement past a zero value.\nWhen a byte transfer causes the I2CxCNT register to decrement to ' 0 ', the Byte Count Interrupt Flag (CNTIF) bit is set, and if the Byte Count Interrupt Enable (CNTIE) is set, the general purpose I2C Interrupt Flag (I2CxIF) bit of the Peripheral Interrupt Registers (PIR) is also set. If the I2C Interrupt Enable (I2CxIE) bit of the Peripheral Interrupt Enable (PIE) registers is set, module hardware will generate an interrupt event.",
    "36.3.12  Data Byte Count\nImportant: The I2CxIF bit is read-only and can only be cleared by clearing all the interrupt flag bits of the I2CxPIR register.\nThe I2CxCNT register can be read at any time, but it is recommended that a double read is performed to ensure a valid count value.",
    "36.3.12  Data Byte Count\nThe I2CxCNT register can be written to; however, care is required to prevent register corruption. If the I2CxCNT register is written to during the 8th falling SCL edge of a reception or during the 9th falling SCL edge of a transmission, the register value may be corrupted. In Client mode, I2CxCNT can be safely written to any time the clock is not being stretched (CSTR = 0 ) or after a Stop condition has been received (Stop Condition Interrupt Flag (PCIF) = 1 ). In Host mode, I2CxCNT can be safely written to any time the Host Data Ready (MDR) or Bus Free (BFRE) bits are set. If the I 2 C packet is longer than 65,536 bytes, the I2CxCNT register can be updated mid-message to prevent the count from reaching zero; however, the preventative measures listed above must be followed.",
    "36.3.12  Data Byte Count\nWhen in either Client Read or Host Write mode and the I2CxCNT value is nonzero (I2CxCNT != 0 ), the value of the ACKDT bit is used as the acknowledgement response. When I2CxCNT reaches zero (I2CxCNT = 0 ), the value of the Acknowledge End of Count (ACKCNT) bit is used for the acknowledgement response.\nIn Host read or write operations, when the I2CxCNT register is clear (I2CxCNT = 0 ) and the Restart Enable (RSEN) bit is clear, host hardware automatically generates a Stop condition upon the 9th falling edge of SCL. When I2CxCNT is clear (I2CxCNT = 0 ) and RSEN is set (RSEN = 1 ), host hardware will stretch the clock while it waits for the Start (S) bit to be set (S = 1 ). When the Start bit has been\nset, module hardware transmits a Restart condition followed by the address of the client it wishes to communicate with.",
    "36.3.12.1 Auto-Load I2CxCNT\nThe I2CxCNTL register can be automatically loaded. Auto-loading of the I2CxCNTL register is enabled when the Auto-Load I 2 C Count Register Enable (ACNT) bit is set (ACNT = 1 ).\nIn Host Transmit mode, the first byte following either the 7-bit or 10-bit client address is transferred from I2CxTXB into both I2CxCNTL and the transmit shift register.\nIn Host Reception mode, the first byte received from the client are loaded into both I2CxCNTL and I2CxRXB. The value of the Acknowledge Data (ACKDT) bit is used as the host's acknowledgement response to prevent a false NACK from being generated before the I2CxCNTL register is updated with the new count value.\nIn Client Reception mode, the first byte received after receiving a matching 7-bit or 10-bit address is loaded into both I2CxCNTL and I2CxRXB, and the value of the ACKDT bit is used as the client's acknowledgement response.",
    "36.3.12.1 Auto-Load I2CxCNT\nIn Client Transmit mode, the first byte loaded into I2CxTXB following the reception of a matching 7-bit or 10-bit address is transferred into both I2CxCNTL and the transmit shift register.\nImportant: It is not necessary to preload the I2CxCNT register when using the auto-load feature. If no value is loaded by the 9th falling SCL edge following an address transmission or reception, the Byte Count Interrupt Flag (CNTIF) will be set by module hardware and must be cleared by software to prevent an interrupt event before I2CxCNTL is updated. Alternatively, I2CxCNTL can be preloaded with a nonzero value to prevent the CNTIF from being set. In this case, the preloaded value will be overwritten once the new count value has been loaded into I2CxCNTL.",
    "36.3.13  DMA Integration\nThe I 2 C module can be used with the DMA for data transfers. The DMA can be triggered through software via the DMA Transaction (DGO) bit or through the use of the following hardware triggers:\n\u00b7 I 2 C Transmit Interrupt Flag (I2CxTXIF)\n\u00b7 I 2 C Receive Interrupt Flag (I2CxRXIF)\n\u00b7 I 2 C Interrupt Flag (I2CxIF)\n\u00b7 I 2 C Error Interrupt Flag (I2CxEIF)\nFor I 2 C communication, the I2CxTXIF is commonly used as the hardware trigger source for host or client transmission, and I2CxRXIF is commonly used as the hardware trigger source for host or client reception.",
    "36.3.13.1 7-Bit Host Transmission\nWhen address buffers are enabled (ABD = 0 ), I2CxADB1 is loaded with the client address, and I2CxCNT is loaded with a count value. At this point, I2CxTXB does not contain data, and the Transmit Buffer Empty (TXBE) bit is set (TXBE = 1 ). The I2CxTXIF bit is not set since it can only be set when the Host Mode Active (MMA) and TXBE bits are set. Once software sets the Start (S) bit, the MMA bit is set and hardware transmits the client address. Upon the 8th falling SCL edge, since TXBE = 1 , the Host Data Request (MDR) and I2CxTXIF bits are set, and hardware stretches the clock while the DMA loads I2CxTXB with data. Once the DMA loads I2CxTXB, the TXBE, MDR and I2CxTXIF bits are cleared by hardware, and the DMA waits for the next occurrence of I2CxTXIF being set.",
    "36.3.13.1 7-Bit Host Transmission\nWhen address buffers are disabled (ABD = 1 ), software must load I2CxTXB with the client address to begin transmission. This is because I2CxTXIF can only be set when MMA = 1 , and since a Start has\nnot occurred, MMA = 0 . Once the address has been transmitted, I2CxTXIF will be set, triggering the DMA to load I2CxTXB with data.",
    "36.3.13.2 10-Bit Host Transmission\nWhen address buffers are enabled (ABD = 0 ), I2CxADB1 is loaded with the client high address, I2CxADB0 is loaded with the client low address, and I2CxCNT is loaded with a count value. Once software sets the Start (S) bit, the MMA bit is set and hardware transmits the 10-bit client address. Upon the 8th falling SCL edge of the transmitted address low byte, since TXBE = 1 , the MDR and I2CxTXIF bits are set, and hardware stretches the clock while the DMA loads I2CxTXB with data. Once the DMA loads I2CxTXB, the TXBE, MDR and I2CxTXIF bits are cleared by hardware, and the DMA waits for the next occurrence of I2CxTXIF being set.",
    "36.3.13.2 10-Bit Host Transmission\nWhen address buffers are disabled (ABD = 1 ), software must load I2CxTXB with the client high address to begin transmission. Once the client high address has been transmitted, I2CxTXIF will be set, triggering the DMA to load I2CxTXB with client low address. Once the DMA loads I2CxTXB with the client low address, the TXBE, MDR and I2CxTXIF bits are cleared by hardware, and the DMA waits for the next occurrence of I2CxTXIF being set.",
    "36.3.13.3 7/10-Bit Host Reception\nIn both 7-bit and 10-bit Host Receive modes, the state of the ABD bit is ignored. Once the complete 7-bit or 10-bit address has been received by the client, the client will transmit a data byte. Once the byte has been received by the host, hardware sets the I2CxRXIF bit, which triggers the DMA to read I2CxRXB. Once the DMA has read I2CxRXB, I2CxRXIF is cleared by hardware and the DMA waits for the next occurrence of I2CxRXIF being set.",
    "36.3.13.4 7-Bit Client Transmission\nIn 7-bit Client Transmission mode, the state of ABD is ignored. If the client receives the matching 7-bit address and TXBE is set, I2CxTXIF is set by hardware, triggering the DMA to load data into I2CxTXB. Once the data are transmitted from I2CxTXB, I2CxTXIF is set by hardware, triggering the DMA to once again load I2CxTXB with data. The DMA will continue to load data into I2CxTXB until I2CxCNT reaches a zero value. Once I2CxCNT reaches zero and the data are transmitted from I2CxTXB, I2CxTXIF will not be set, and the DMA will stop loading data.",
    "36.3.13.5 10-Bit Client Transmission\nIn 10-bit Client Transmission mode, the state of ABD is ignored. If there is no data in I2CxTXB after the client has received the address high byte with the R/W bit set, hardware sets I2CxTXIF, triggering the DMA to load I2CxTXB. The DMA will continue to load data into I2CxTXB until I2CxCNT reaches a zero value. Once I2CxCNT reaches zero and the data are transmitted from I2CxTXB, I2CxTXIF will not be set, and the DMA will stop loading data.",
    "36.3.13.6 7/10-Bit Client Reception\nWhen address buffers are enabled (ABD = 0 ), client hardware loads I2CxADB0/1 with the matching address, while all data are received by I2CxRXB. Once the client loads I2CxRXB with a received data byte, hardware sets I2CxRXIF, which triggers the DMA to read I2CxRXB. The DMA will continue to read I2CxRXB whenever I2CxRXIF is set.\nWhen address buffers are disabled (ABD = 1 ), the client loads I2CxRXB with the matching address byte(s) as they are received. Each received address byte sets I2CxRXIF, which triggers the DMA to read I2CxRXB. The DMA will continue to read I2CxRXB whenever I2CxRXIF is set.",
    "36.3.14  Interrupts\nThe I 2 C module offers several interrupt features designed to assist with communication functions. The interrupt hardware contains four high-level interrupts and several condition-specific interrupts.",
    "36.3.14.1 High-Level Interrupts\nModule hardware provides four high-level interrupts:\n\u00b7 Transmit\n\u00b7 Receive\n\u00b7 General Purpose\n\u00b7 Error\nThese flag bits are read-only bits and cannot be cleared by software.\nThe I2C Transmit Interrupt Flag (I2CxTXIF) bit is set when the I2CxCNT register is nonzero (I2CxCNT != 0 ) and the transmit buffer, I2CxTXB, is empty as indicated by the Transmit Buffer Empty Status (TXBE) bit (TXBE = 1 ). If the I2C Transmit Interrupt Enable (I2CxTXIE) bit is set, an interrupt event will occur when the I2CxTXIF bit becomes set. Writing new data to I2CxTXB or setting the Clear Buffer (CLRBF) bit will clear the interrupt condition. The I2CxTXIF bit is also used by the DMA as a trigger source.",
    "36.3.14.1 High-Level Interrupts\nImportant: I2CxTXIF can only be set when either the Client Mode Active (SMA) or Host Mode Active (MMA) bits are set, and the I2CxCNT register is nonzero (I2CxCNT != 0 ). The SMA bit is only set after an address has been successfully acknowledged by a client device, which prevents false interrupts from being triggered on address reception. The MMA bit is set once the host completes the transmission of a Start condition.",
    "36.3.14.1 High-Level Interrupts\nThe I2C Receive Interrupt Flag (I2CxRXIF) bit is set when the receive shift register has loaded new data into the receive buffer, I2CxRXB. When new data are loaded into I2CxRXB, the Receive Buffer Full Status (RXBF) bit is set (RXBF = 1 ), which also sets I2CxRXIF. If the I2C Receive Interrupt Enable (I2CxRXIE) bit is set, an interrupt event will occur when the I2CxRXIF bit becomes set. Reading data from I2CxRXB or setting the CLRBF bit will clear the interrupt condition. The I2CxRXIF bit is also used by the DMA as a trigger source.\nImportant: I2CxRXIF can only be set when either the Client Mode Active (SMA) or Host Mode Active (MMA) bits are set.",
    "36.3.14.1 High-Level Interrupts\nThe I2C Interrupt Flag (I2CxIF) is the general purpose interrupt. I2CxIF is set whenever any of the interrupt flag bits contained in the I2C Peripheral Interrupt (I2CxPIR) Register and the associated interrupt enable bits contained in the I2C Peripheral Interrupt Enable (I2CxPIE) Register are set. If I2CxIF becomes set while the I2C Interrupt Enable (I2CxIE) bit is set, an interrupt event will occur. I2CxIF is cleared by module hardware when all enabled interrupt flag bits in I2CxPIR are clear.",
    "36.3.14.1 High-Level Interrupts\nThe I2C Error Interrupt Flag (I2CxEIF) is set whenever any of the interrupt flag bits contained in the I2C Error (I2CxERR) Register and their associated interrupt enable bits are set. If I2CxEIF becomes set while the I2C Error Interrupt Enable (I2CxEIE) bit is set, an interrupt event will occur. I2CxEIF is cleared by hardware when all enabled error interrupt flag bits in the I2CxERR register are clear.",
    "36.3.14.2 Condition-Specific Interrupts\nIn addition to the high-level interrupts, module hardware provides several condition-specific interrupts.\nThe I2C Peripheral Interrupt (I2CxPIR) Register contains the following interrupt flag bits:\n\u00b7 CNTIF: Byte Count Interrupt Flag\n\u00b7 ACKTIF: Acknowledge Status Time Interrupt Flag\n\u00b7 WRIF: Data Write Interrupt Flag\n\u00b7 ADRIF: Address Interrupt Flag\n\u00b7 PCIF: Stop Condition Interrupt Flag\n\u00b7 RSCIF: Restart Condition Interrupt Flag\n\u00b7 SCIF: Start Condition Interrupt Flag\nWhen any of the flag bits in I2CxPIR becomes set and the associated interrupt enable bits in I2CxPIE are set, the generic I2CxIF is also set. If the generic I2CxIE bit is set, an interrupt event is generated whenever one of the I2CxPIR flag bits becomes set. If the I2CxIE bit is clear, the I2CxPIR flag bit will still be set by hardware; however, no interrupt event will be triggered.",
    "36.3.14.2 Condition-Specific Interrupts\nCNTIF becomes set (CNTIF = 1 ) when the I2CxCNT register value reaches zero, indicating that all data bytes in the I 2 C packet have been transmitted or received. CNTIF is set after the 9th falling SCL edge when I2CxCNT reaches zero (I2CxCNT = 0 ).\nACKTIF is set (ACKTIF = 1 ) by the 9th falling edge of SCL for any byte when the device is addressed as a client in any Client or Multi-Host mode. If the Acknowledge Interrupt and Hold Enable (ACKTIE) bit is set and ACKTIF becomes set:\n\u00b7 If an ACK is detected, clock stretching is also enabled (CSTR = 1 )\n\u00b7 If a NACK is detected, no clock stretching occurs (CSTR = 0 )",
    "36.3.14.2 Condition-Specific Interrupts\nWRIF is set (WRIF = 1 ) after the 8th falling edge of SCL when the module receives a data byte in Client or Multi-Host modes. Once the data byte is received, WRIF is set, as is the Receive Buffer Full Status (RXBF) and the I2CxRXIF bits, and if the Data Write Interrupt and Hold Enable (WRIE) bit is set, the generic I2CxIF bit is also set. WRIF is a read/write bit and must be cleared in software, while the RXBF, I2CxRXIF and I2CxIF bits are read-only and are cleared by reading I2CxRXB or by setting the Clear Buffer bit (CLRBF = 1 ).",
    "36.3.14.2 Condition-Specific Interrupts\nADRIF is set on the 8th falling edge of SCL after the module has received a matching 7-bit address, after receiving a matching 10-bit upper address byte, and after receiving a matching 10-bit lower address byte in Client or Multi-Host modes. Upon receiving a matching 7-bit address or 10-bit upper address, the address is copied to I2CxADB0, the R/W bit setting is copied to the Read Information (R) bit, the Data (D) bit is cleared, and the ADRIF bit is set. If the Address Interrupt and Hold Enable (ADRIE) bit is set, I2CxIF is set, and the clock will be stretched while the module determines whether to ACK or NACK the transmitter. Upon receiving the matching 10-bit lower address, the address is copied to I2CxADB1, and the ADRIF bit is set. If ADRIE is also set, the clock is stretched while the module determines the ACK/NACK response to return to the transmitter.\nPCIF is set whenever a Stop condition is detected on the bus.",
    "36.3.14.2 Condition-Specific Interrupts\nRSCIF is set upon the detection of a Restart condition.\nSCIF is set upon the detection of a Start condition.\nIn addition to the I2CxPIR register, the I2C Error (I2CxERR) register contains three interrupt flag bits that are used to detect bus errors. These read/write bits are set by module hardware, but must be cleared by user software. The I2CxERR register also includes the interrupt enable bits for these three Error conditions and, when set, will cause an interrupt event whenever the associated interrupt flag bit becomes set.\nI2CxERR contains the following interrupt flag bits:\n\u00b7 BTOIF: Bus Time-Out Interrupt Flag\n\u00b7 BCLIF: Bus Collision Interrupt Flag\n\u00b7 NACKIF: NACK Detect Interrupt Flag\nBTOIF is set when a bus time-out occurs. The bus time-out period is configured using one of the time-out sources selected by the I2C Bus Time-Out Clock Source Selection (I2CxBTOC) register.",
    "36.3.14.2 Condition-Specific Interrupts\nIf the module is configured in Client mode with TOREC set (TOREC = 1 ) and a bus time-out event occurs (regardless of the state of the Client Mode Active (SMA) bit), the module is immediately reset,\nthe SMA and Client Clock Stretching (CSTR) bits are cleared, and the BTOIF bit is set. If the Bus Time-Out Interrupt Enable (BTOIE) bit is set, the generic I2C Error Interrupt Flag (I2CxEIF) bit is set.\nIf the module is configured in Client mode with TOREC clear (TOREC = 0 ) and a bus time-out event occurs (regardless of the state of the Client Mode Active (SMA) bit), the BTOIF bit is set, but user software must reset the module. If the Bus Time-Out Interrupt Enable (BTOIE) bit is set, the generic I2C Error Interrupt Flag (I2CxEIF) bit is set.",
    "36.3.14.2 Condition-Specific Interrupts\nIf the module is configured in Host mode with TOREC set (TOREC = 1 ) and the bus time-out event occurs while the Host is active (Host Mode Active (MMA) = 1 ), the Host Data Ready (MDR) bit is cleared, the module will immediately attempt to transmit a Stop condition, and the BTOIF bit is set. Stop condition generation may be delayed if a client device is stretching the clock but will resume once the clock is released or if the client holding the bus also has a time-out event occur. The MMA bit is only cleared after the Stop condition has been generated. If the Bus Time-Out Interrupt Enable (BTOIE) bit is set, the generic I2C Error Interrupt Flag (I2CxEIF) bit is set.",
    "36.3.14.2 Condition-Specific Interrupts\nIf the module is configured in Host mode with TOREC clear (TOREC = 0 ) and the bus time-out event occurs while the Host is active (Host Mode Active (MMA) = 1 ), the MDR bit is cleared and the BTOIF bit is set, but user software must initiate the Stop condition by setting the P bit. If the Bus Time-Out Interrupt Enable (BTOIE) bit is set, the generic I2C Error Interrupt Flag (I2CxEIF) bit is set.\nBCLIF is set upon the detection of a bus collision. A bus collision occurs any time the SDA line is sampled at a logic low while the module expects both SCL and SDA lines to be at a high logic level. When a bus collision occurs, BCLIF is set, and if the Bus Collision Detect Interrupt Enable (BCLIE) bit is set, I2CxEIF is also set, and the module is reset.",
    "36.3.14.2 Condition-Specific Interrupts\nNACKIF is set when either the host or client is active (SMA = 1 || MMA = 1 ) and a NACK response is detected on the bus. A NACK response occurs during the 9th SCL pulse in which the SDA line is released to a logic high. In Host mode, a NACK can be issued when the host has finished receiving data from a client or when the host receives incorrect data. In Client mode, a NACK is issued when the client does not receive a matching address or when it receives incorrect data. A NACK can also be automatically issued when any of the following bits becomes set, which will also set NACKIF and I2CxEIF:\n\u00b7 TXWE: Transmit Write Error Status\n\u00b7 RXRE: Receive Read Error Status\n\u00b7 TXU: Transmit Underflow Status\n\u00b7 RXO: Receive Overflow Status\nImportant: The I2CxEIF bit is read-only and is only cleared by hardware after all enabled I2CxERR error flags have been cleared.",
    "36.3.15  Operation in Sleep\nThe I 2 C module can operate while in Sleep mode.\nIn Client mode, the module can transmit and receive data as long as the system clock source operates in Sleep. If the generic I2C Interrupt Enable (I2CxIE) bit is set and the client receives or transmits a complete byte, I2CxIF is set and the device wakes up from Sleep.\nIn Host mode, both the system clock and the selected I2CxCLK source must be able to operate in Sleep. If the I2CxIE bit is set and the I2CxIF bit becomes set, the device wakes from Sleep.",
    "36.4 I 2 C Operation\nAll I 2 C communication is performed in 9-bit segments consisting of an 8-bit address/data segment followed by a 1-bit acknowledgement segment. Address and data bytes are transmitted with the\nMost Significant bit (MSb) first. Interaction between the I 2 C module and other devices on the bus is controlled and monitored through several I 2 C Control, Status, and Interrupt registers.\nTo begin any I 2 C communication, mater hardware checks to ensure that the bus is in an Idle state as indicated by the Bus Free Status (BFRE) bit. When BFRE = 1 , both SDA and SCL lines are floating to a logic high and the bus is considered 'Idle'. When the host detects an Idle bus, it transmits a Start condition, followed by the address of the client it intends to communicate with. The client address can be either 7-bit or 10-bit, depending on the application design.",
    "36.4 I 2 C Operation\nIn 7-bit Addressing mode, the Least Significant bit (LSb) of the 7-bit client address is reserved for the Read/not Write (R/W) bit, while in 10-bit Addressing mode, the LSb of the high address byte is reserved as the R/W bit. If the R/W bit is clear (R/W = 0 ), the host intends to read information from the client. If R/W is set (R/W = 1 ), the host intends to write information to the client. If the addressed client exists on the bus, it must respond with an Acknowledgement (ACK) sequence.\nOnce a client has been successfully addressed, the host will continue to receive data from the client, write data to the client, or a combination of both. Data are always transmitted Most Significant bit (MSb) first. When the host has completed its transactions, it can either issue a Stop condition, signaling to the client that communication is to be terminated, or a Restart condition, informing the bus that the current host wishes to hold the bus to communicate with the same or other client devices.",
    "36.4.1 I 2 C Client Mode Operation\nThe I 2 C module provides four Client Operation modes as selected by the I2C Mode Select (MODE) bits:\n\u00b7 I 2 C Client mode with recognition of up to four 7-bit addresses\n\u00b7 I 2 C Client mode with recognition of up to two masked 7-bit addresses\n\u00b7 I 2 C Client mode with recognition of up to two 10-bit addresses\n\u00b7 I 2 C Client mode with recognition of one masked 10-bit address",
    "36.4.1 I 2 C Client Mode Operation\nDuring operation, the client device waits until module hardware detects a Start condition on the bus. Once the Start condition is detected, the client waits for the incoming address information to be received by the receive shift register. The address is then compared to the addresses stored in the I2C Address 0/1/2/3 registers (I2CxADR0, I2CxADR1, I2CxADR2, I2CxADR3), and if an address match is detected, client hardware transfers the matching address into either the I2CxADB0/I2CxADB1 registers or the I2CxRXB register, depending on the state of the Address Buffer Disable (ABD) bit. If there are no address matches, there is no response from the client.",
    "36.4.1.1 Client Addressing Modes\nThe I2CxADR0, I2CxADR1, I2CxADR2 and I2CxADR3 registers contain the client's addresses. The first byte (7-bit mode) or first and second bytes (10-bit mode) following a Start or Restart condition are compared to the values stored in the I2CxADR registers (see Figure 36-11). If an address match occurs, the valid address is transferred to the I2CxADB0/I2CxADB1 registers or I2CxRXB register, depending on the Addressing mode and the state of the ABD bit.\n\nTable 36-2. I 2 C Address Registers",
    "36.4.1.1 Client Addressing Modes\nMode, 1 = I2CxADR0. Mode, 2 = I2CxADR1. Mode, 3 = I2CxADR2. Mode, 4 = I2CxADR3. 7-bit, 1 = 7-bit address. 7-bit, 2 = 7-bit address. 7-bit, 3 = 7-bit address. 7-bit, 4 = 7-bit address. 7-bit w/ masking, 1 = 7-bit address. 7-bit w/ masking, 2 = 7-bit mask for I2CxADR0. 7-bit w/ masking, 3 = 7-bit address. 7-bit w/ masking, 4 = 7-bit mask for I2CxADR2. 10-bit, 1 = Address low byte. 10-bit, 2 = Address high byte. 10-bit, 3 = Address low byte. 10-bit, 4 = Address high byte. 10-bit w/ masking, 1 = Address low byte. 10-bit w/ masking, 2 = Address high byte. 10-bit w/ masking, 3 = Address low byte mask.",
    "36.4.1.1 Client Addressing Modes\n10-bit w/ masking, 4 = Address high byte mask\nIn 7-bit Address mode, the received address byte is compared to all four I2CxADR registers independently to determine a match. The R/W bit is ignored during address comparison. If a match occurs, the matching received address is transferred from the receive shift register to either the\nFilename:\nMasking Example.vsdx\nIn 7-bit Address with Masking mode, I2CxADR0 holds one client address and I2CxADR1 holds the mask value for I2CxADR0, while I2CxADR2 holds a second client address and I2CxADR3 holds the mask value for I2CxADR2. A zero bit in a mask register means that the associated bit in the address register is a 'don't care', which means that the particular address bit is not used in the address comparison between the received address in the shift register and the address stored in either I2CxADR0 or I2CxADR2 (see Figure 36-11). Notes:",
    "36.4.1.1 Client Addressing Modes\nI2CxADB0 register (when ABD = 0 ) or to the I2CxRXB register (when ABD = 1 ), and the value of the R/W bit is loaded into the Read Information (R) bit. Title: Last Edit: 1/8/2019 First Used:\nFigure 36-11. 7-Bit Address with Masking Example\nIn 10-bit Address mode, I2CxADR0 and I2CxADR1, and I2CxADR2 and I2CxADR3 are combined to create two 10-bit addresses. I2CxADR0 and I2CxADR2 hold the lower eight bits of the address, while I2CxADR1 and I2CxADR3 hold the upper two bits of the address, the R/W bit, and the five-digit ' 11110 ' code assigned to the five Most Significant bits of the high address byte.",
    "36.4.1.1 Client Addressing Modes\nImportant: The ' 11110 ' code is specified by the I 2 C Specification, but is not supported by Microchip. It is up to the user to ensure the correct bit values are loaded into the address high byte. If a host device has included the five-digit code in the address it intends to transmit, the client must also include those bits in client address.\nThe upper received address byte is compared to the values in I2CxADR1 and I2CxADR3. If a match occurs, the address is stored in either I2CxADB1 (when ABD = 0 ) or in I2CxRXB (when ABD = 1 ), and the value of the R/W bit is transferred into the R bit. The lower received address byte is compared to the values in I2CxADR0 and I2CxADR2, and if a match occurs, the address is stored in either I2CxADB0 (when ABD = 0 ) or in I2CxRXB (when ABD = 1 ).",
    "36.4.1.1 Client Addressing Modes\nIn 10-bit Address with Masking mode, I2CxADR0 and I2CxADR1 are combined to form the 10-bit address, while I2CxADR2 and I2CxADR3 are combined to form the 10-bit mask. The upper received address byte is compared to the masked value in I2CxADR1. If a match occurs, the address is stored in either I2CxADB1 (when ABD = 0 ) or in I2CxRXB (when ABD = 1 ), and the value of the R/W bit is transferred into the R bit. The lower received address byte is compared to the value in I2CxADR0, and if a match occurs, the address is stored in either I2CxADB0 (when ABD = 0 ) or in I2CxRXB (when ABD = 1 ).",
    "36.4.1.2 General Call Addressing Support\nThe I 2 C Specification reserves the address 0x00 as the General Call address. The General Call address is used to address all client modules connected to the bus at the same time. When a host issues a General Call, all client devices may respond with an ACK. The General Call Enable (GCEN) bit determines whether client hardware will respond to a General Call address. When GCEN is set (GCEN = 1 ), client hardware will respond to a General Call with an ACK, and when GCEN is clear (GCEN = 0 ), the General Call is ignored, and the client responds with a NACK.\nWhen the module receives a General Call, the ADRIF bit is set and the address is stored in I2CxADB0. If the ADRIE bit is set, the module will generate an interrupt and stretch the clock after the 8th falling edge of SCL. This allows the client to determine the acknowledgement response to return to the host (see Figure 36-12).\nFilename:\nGeneral Call Addressing.vsdx",
    "36.4.1.2 General Call Addressing Support\nImportant: When using the General Call addressing feature, loading the I2CxADR0/1/2/3 registers with the 0x00 address is not recommended. Additionally, client hardware only supports General Call addressing in 7-bit Addressing modes. Title: Last Edit: 1/8/2019 First Used: Notes:\nFigure 36-12. General Call Addressing\nRev. General Ca\n1/8/2019",
    "36.4.1.3 Client Operation in 7-Bit Addressing Modes\nThe upper seven bits of an address byte are used to determine a client's address, while the LSb of the address byte is reserved as the Read/not Write (R/W) bit. When R/W is set (R/W = 1 ), the host device intends to read data from the client. When R/W is clear (R/W = 0 ), the host device intends to write data to the client. When an address match occurs, the R/W bit is copied to the Read Information (R) bit, and the 7-bit address is copied to I2CxADB0.",
    "36.4.1.3.1 Client Transmission (7-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is transmitting data in 7-bit Addressing mode:\n1. The host device issues a Start condition. Once the Start condition has been detected, client hardware sets the Start Condition Interrupt Flag (SCIF) bit. If the Start Condition Interrupt Enable (SCIE) bit is also set, the generic I2CxIF is also set.\n2. Host hardware transmits the 7-bit client address with the R/W bit set, indicating that it intends to read data from the client.\n3. The received address is compared to the values in the I2CxADR registers. If the client is configured in 7-bit Addressing mode (no masking), the received address is independently compared to each of the I2CxADR0/1/2/3 registers. In 7-bit Addressing with Masking mode, the received address is compared to the masked value of I2CxADR0 and I2CxADR2.",
    "If an address match occurs:\n-The Client Mode Active (SMA) bit is set by module hardware.\n-The R/W bit value is copied to the Read Information (R) bit by module hardware.\n-The Data (D) bit is cleared by hardware, indicating the last received byte was an address.\n-The Address Interrupt Flag (ADRIF) bit is set. If the Address Interrupt and Hold Enable (ADRIE) bit is set and the Clock Stretching Disable (CSD) bit is clear, hardware sets the Client Clock Stretching (CSTR) bit and the generic I2CxIF bit. This allows time for the client to read either I2CxADB0 or I2CxRXB and selectively ACK/NACK based on the received address. When the client has finished processing the address, software must clear CSTR to resume operation.",
    "If an address match occurs:\n-The matching received address is loaded into either the I2CxADB0 register or into the I2CxRXB register as determined by the Address Buffer Disable (ABD) bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB0. When ABD is set (ABD = 1 ), the matching address is copied to I2CxRXB, which also sets the Receive Buffer Full Status (RXBF) bit and the I2C Receive Interrupt Flag (I2CxRXIF) bit. I2CxRXIF is a read-only bit and must be cleared by either reading I2CxRXB or by setting the Clear Buffer (CLRBF) bit (CLRBF = 1 ).\nIf no address match occurs, the module remains Idle.",
    "If an address match occurs:\n4. If the Transmit Buffer Empty Status (TXBE) bit is set (TXBE = 1 ), I2CxCNT has a nonzero value (I2CxCNT != 0 ) and the I2C Transmit Interrupt Flag (I2CxTXIF) is set (I2CxTXIF = 1 ), client hardware sets CSTR, stretches the clock (when CSD = 0 ), and waits for software to load I2CxTXB with data. I2CxTXB must be loaded to clear I2CxTXIF. Once data are loaded into I2CxTXB, hardware automatically clears CSTR to resume communication.\n5. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive overflow (RXO = 1 ), client hardware automatically generates a NACK condition. NACKIF is set, and the module goes Idle.",
    "If an address match occurs:\n6. Upon the 9th falling SCL edge, the data byte in I2CxTXB is transferred to the transmit shift register, and I2CxCNT is decremented by one. Additionally, the Acknowledge Status Time Interrupt Flag (ACKTIF) bit is set. If the Acknowledge Status Time Interrupt and Hold Enable (ACKTIE) bit is also set, the generic I2CxIF is set, and if client hardware generated an ACK, the CSTR bit is also set and the clock is stretched (when CSD = 0 ). If a NACK was generated, the CSTR bit remains unchanged. Once complete, software must clear CSTR and ACKTIF to release the clock and continue operation.\n7. If the client generated an ACK and I2CxCNT is nonzero, host hardware transmits eight clock pulses, and client hardware begins to shift the data byte out of the shift register starting with the Most Significant bit (MSb).",
    "If an address match occurs:\n8. After the 8th falling edge of SCL, client hardware checks the status of TXBE and I2CxCNT. If TXBE is set and I2CxCNT has a nonzero count value, hardware sets CSTR and the clock is stretched (when CSD = 0 ) until software loads I2CxTXB with new data. Once I2CxTXB has been loaded, hardware clears TXBE, I2CxTXIF, and CSTR to resume communication.\n9. Once the host hardware clocks in all eight data bits, it transmits the 9th clock pulse along with the ACK/NACK response back to the client. Client hardware copies the ACK/NACK value to the Acknowledge Status (ACKSTAT) bit and sets ACKTIF. If ACKTIE is also set, client hardware sets the generic I2CxIF bit and CSTR, and stretches the clock (when CSD = 0 ). Software must clear CSTR to resume operation.",
    "If an address match occurs:\n10. After the 9th falling edge of SCL, data currently loaded in I2CxTXB is transferred to the transmit shift register, setting both TXBE and I2CxTXIF. I2CxCNT is decremented by one. If I2CxCNT is zero (I2CxCNT = 0 ), CNTIF is set.",
    "If an address match occurs:\n11. If I2CxCNT is nonzero and the host issued an ACK on the last byte (ACKSTAT = 0 ), the host transmits eight clock pulses, and client hardware begins to shift data out of the shift register.\n12. Repeat steps 8 - 11 until the host has received all the requested data (I2CxCNT = 0 ). Once all data has been received, the host issues a NACK, followed by either a Stop or Restart condition. Once the NACK has been received by the client, hardware sets NACKIF and clears SMA. If the NACK Detect Interrupt Enable (NACKIE) bit is also set, the generic I2C Error Interrupt Flag (I2CxEIF) is set. If the host issued a Stop condition, client hardware sets the Stop Condition Interrupt Flag (PCIF). If the host issued a Restart condition, client hardware sets the Restart Condition Interrupt Flag (RSCIF). If the associated interrupt enable bits are also set, the generic I2CxIF is also set.",
    "If an address match occurs:\nImportant: I2CxEIF is read-only and is cleared by hardware when all enable interrupt flag bits in I2CxERR are cleared.\n)\n7-Bit Client Mode Transmission (ACKTIE =\nFigure 36-15.",
    "36.4.1.3.2 Client Reception (7-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is receiving data in 7-bit Addressing mode:",
    "36.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n1. The host issues a Start condition. Once the Start is detected, client hardware sets the Start Condition Interrupt Flag (SCIF) bit. If the Start Condition Interrupt Enable (SCIE) bit is also set, the generic I2CxIF bit is also set.\n2. The host transmits the 7-bit client address with the R/W bit clear, indicating that it intends to write data to the client.\n3. The received address is compared to the values in the I2CxADR registers. If the client is configured in 7-bit Addressing mode (no masking), the received address is independently compared to each of the I2CxADR0/1/2/3 registers. In 7-bit Addressing with Masking mode, the received address is compared to the masked value of I2CxADR0 and I2CxADR2. If an address match occurs:\n-The Client Mode Active (SMA) bit is set by module hardware.\n-The R/W bit value is copied to the Read Information (R) bit by module hardware.",
    "36.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n-The Data (D) bit is cleared (D = 0 ) by hardware, indicating the last received byte was an address.\n-The Address Interrupt Flag (ADRIF) bit is set (ADRIF = 1 ). If the Address Interrupt and Hold Enable (ADRIE) bit is set (ADRIE = 1 ) and the Clock Stretching Disable (CSD) bit is clear (CSD = 0 ), hardware sets the Client Clock Stretching (CSTR) bit and the generic I2CxIF bit. This allows time for the client to read either I2CxADB0 or I2CxRXB and selectively ACK/NACK based on the received address. When the client has finished processing the address, software must clear CSTR to resume operation.",
    "36.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n-The matching received address is loaded into either the I2CxADB0 register or into the I2CxRXB register as determined by the Address Buffer Disable (ABD) bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB0. When ABD is set (ABD = 1 ), the matching address is copied to I2CxRXB, which also sets the Receive Buffer Full Status (RXBF) bit and the I2C Receive Interrupt Flag (I2CxRXIF) bit. I2CxRXIF is a read-only bit and must be cleared by either reading I2CxRXB or by setting the Clear Buffer (CLRBF) bit (CLRBF = 1 ).\nIf no address match occurs, the module remains Idle.",
    "36.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n4. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive overflow (RXO = 1 ), client hardware automatically generates a NACK condition. NACKIF is set, and the module goes Idle.\n5. Upon the 9th falling SCL edge, the Acknowledge Status Time Interrupt Flag (ACKTIF) bit is set. If the Acknowledge Interrupt and Hold Enable (ACKTIE) bit is also set, the generic I2CxIF is set, and if client hardware generated an ACK, the CSTR bit is also set and the clock is stretched (when CSD = 0 ). If a NACK was generated, the CSTR bit remains unchanged. Once complete, software must clear CSTR and ACKTIF to release the clock and continue operation.",
    "36.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n6. If client hardware generated a NACK, host hardware generates a Stop condition, the Stop Condition Interrupt Flag (PCIF) bit is set when client hardware detects the Stop condition, and the client goes Idle. If an ACK was generated, host hardware transmits the first seven bits of the 8-bit data byte.\n7. If data remains in I2CxRXB (RXBF = 1 and I2CxRXIF = 1 ) when the first seven bits of the new byte are received by the shift register, CSTR is set, and if CSD is clear, the clock is stretched after the 7th falling edge of SCL. This allows time for the client to read I2CxRXB, which clears RXBF and I2CxRXIF and prevents a receive buffer overflow. Once RXBF and I2CxRXIF are cleared, hardware releases SCL.",
    "36.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n8. Host hardware transmits the 8th bit of the current data byte into the client receive shift register. Client hardware then transfers the complete byte into I2CxRXB on the 8th falling edge of SCL and sets the following bits:\n-I2CxRXIF\n-I2CxIF\n-Data Write Interrupt Flag (WRIF)\n-Data (D)\n-RXBF\nI2CxCNT is decremented by one. If the Data Write Interrupt and Hold Enable (WRIE) is set (WRIE = 1 ), hardware sets CSTR (when CSD = 0 ) and stretches the clock, allowing time for client software to read I2CxRXB and determine the state of the ACKDT bit that is transmitted back to the host. Once the client determines the Acknowledgement response, software clears CSTR to allow further communication.",
    "36.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n9. Host hardware transmits the 9th clock pulse. If there are pending errors, such as receive buffer overflow, client hardware automatically generates a NACK condition, sets NACKIF, and the module goes Idle. If I2CxCNT is nonzero (I2CxCNT != 0 ), client hardware transmits the value of ACKDT as the acknowledgement response to the host. It is up to software to configure ACKDT appropriately. In most cases, the ACKDT bit must be clear (ACKDT = 0 ) so that the host receives an ACK response (logic low level on SDA during the 9th clock pulse). If I2CxCNT is zero (I2CxCNT = 0 ), client hardware transmits the value of the Acknowledge End of Count (ACKCNT) bit as the Acknowledgement response, rather than the value of ACKDT. It is up to software to configure ACKCNT appropriately. In most cases, ACKCNT must be set (ACKCNT = 1 ), which represents a NACK",
    "36.4.1.3.2 Client Reception (7-Bit Addressing Mode)\ncondition. When host hardware detects a NACK on the bus, it will generate a Stop condition. If ACKCNT is clear (ACKCNT = 0 ), an ACK will be issued and host\nhardware will not issue a Stop condition.\n10. Upon the 9th falling edge of SCL, the ACKTIF bit is set. If ACKTIE is also set, the generic I2CxIF is set, and if CSD is clear, client hardware sets CSTR and stretches the clock. This allows time for software to read I2CxRXB. Once complete, software must clear both CSTR and ACKTIF to release the clock and continue communication.\n11. Repeat steps 6 -10 until the host has transmitted all the data (I2CxCNT = 0 ) or until the host issues a Stop or Restart condition.\nFigure 36-16. 7-Bit Client Mode Reception (No Clock Stretching) rota e hisp g 90\nRev. I2C Client\n1/9/2019\nFigure 36-19. 7-Bit Client Mode Reception (WRIE = 1 ) rota e hisp g 90",
    "36.4.1.4 Client Operation in 10-Bit Addressing Modes\nIn 10-bit Addressing modes, the first two bytes following a Start condition form the 10-bit address (see Figure 36-20). The first byte (address high byte) holds the upper two address bits, the R/W bit, and a five digit code ( 11110 ) as defined by the I 2 C Specification. The second byte (address low byte) holds the lower eight address bits. In all 10-bit Addressing modes, the R/W value contained in the first byte must always be zero (R/W = 0 ). If the host intends to read data from the client, it must issue a Restart condition, followed by the address high byte with R/W set (R/W = 1 ). Filename: Upper and Lower 10-bit Address Bytes.vsdx Title: Last Edit: 12/6/2018",
    "36.4.1.4 Client Operation in 10-Bit Addressing Modes\nThe first byte is compared to the values in the I2CxADR1 and I2CxADR3 registers in 10-bit Addressing mode or to the masked value of I2CxADR1 in 10-bit Addressing with Masking mode. The second byte is compared to the values in the I2CxADR0 and I2CxADR2 registers in 10-bit Addressing mode or to the masked value of I2CxADR0 in 10-bit Addressing with Masking mode. If an address high byte match occurs, the high address byte is copied to I2CxADB1 and the R/W bit value is copied to the Read Information (R) bit, and if an address low byte match occurs, the low address byte is copied to I2CxADB0. First Used: Notes:\nFigure 36-20. Upper and Lower 10-Bit Address Bytes",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is transmitting data in 10-bit Addressing mode:",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n1. The host device issues a Start condition. Once the Start condition has been detected, client hardware sets the Start Condition Interrupt Flag (SCIF) bit. If the Start Condition Interrupt Enable (SCIE) bit is also set, the generic I2CxIF is also set.\n2. Host hardware transmits the 10-bit high address byte with the R/W bit clear (R/W = 0 ).\n3. Client hardware compares the received address to the values in the I2CxADR registers. If the client is configured in 10-bit Addressing mode (no masking), the received high address byte is compared to the values in I2CxADR1 and I2CxADR3. In 10-bit Addressing with Masking mode, the received high address byte is compared to the masked value of I2CxADR1. If an address match occurs:\n-The R/W value is copied to the Read Information (R) bit by module hardware.\n-The Data (D) bit is cleared by hardware.\n-The Address Interrupt Flag (ADRIF) bit is set (ADRIF = 1 ).",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n-The matching address is loaded into either the I2CxADB1 register or into the I2CxRXB register as determined by the Address Buffer Disable (ABD) bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB1. When ABD is set (ABD = 1 ), the matching address is copied to I2CxRXB, which also sets the Receive Buffer Full Status (RXBF) bit and the I2C Receive Interrupt Flag (I2CxRXIF) bit.\nImportant: Regardless of whether the Address Interrupt and Hold Enable (ADRIE) bit is set, clock stretching does not occur when the R/W bit is clear in 10-bit Addressing modes.\nIf no address match occurs, the module remains Idle.",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n4. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive buffer overflow (RXO = 1 ), client hardware generates a NACK and the module goes Idle.\n5. The host device transmits the low address byte. If the client is configured in 10-bit Addressing mode (no masking), the received low address byte is compared to the values in I2CxADR0 and I2CxADR2. In 10-bit Addressing with Masking mode, the received low address byte is compared to the masked value of I2CxADR0.\nIf a match occurs:",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n-The Client Mode Active (SMA) bit is set by module hardware.\n-ADRIF is set. If ADRIE is set and the Clock Stretching Disable (CSD) bit is clear, hardware sets the Client Clock Stretching (CSTR) bit and the generic I2CxIF bit. This allows time for the client to read either I2CxADB0 or I2CxRXB and selectively ACK/NACK based on the received address. When the client has finished processing the address, software must clear CSTR to resume operation.",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n-The matching received address is loaded into either the I2CxADB0 register or into the I2CxRXB register as determined by the ABD bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB0. When ABD is set (ABD = 1 ), the matching address is copied to I2CxRXB, which also sets RXBF and I2CxRXIF. I2CxRXIF is a read-only bit and must be cleared by either reading I2CxRXB or by setting the Clear Buffer (CLRBF) bit (CLRBF = 1 ).\nIf no match occurs, the module goes Idle.",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n6. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive buffer overflow (RXO = 1 ), client hardware generates a NACK and the module goes Idle.\n7. After the 9th falling edge of SCL, the Acknowledge Status Time Interrupt Flag (ACKTIF) bit is set. If the Acknowledge Time Interrupt and Hold Enable (ACKTIE) bit is also set, the generic I2CxIF is set, and if client hardware generated an ACK, the CSTR bit is also set and the clock is stretched (when CSD = 0 ). If a NACK was generated, the CSTR bit remains unchanged. Once completed, software must clear CSTR and ACKTIF to release the clock and resume operation.",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n8. Host hardware issues a Restart condition (cannot be a Start condition), and once the client detects the Restart, hardware sets the Restart Condition Interrupt Flag (RSCIF). If the Restart Condition Interrupt Enable (RSCIE) bit is also set, the generic I2CxIF is also set.\n9. Host hardware transmits the client's high address byte with R/W set. If the received high address byte matches:\n-The R/W bit value is copied to the R bit.\n-The SMA bit is set.\n-The D bit is cleared, indicating the last byte as an address.\n-ADRIF is set. If ADRIE is set, and the CSD bit is clear, hardware sets CSTR and the generic I2CxIF bit. This allows time for the client to read either I2CxADB1 or I2CxRXB and selectively ACK/NACK based on the received address. When the client has finished processing the address, software must clear CSTR to resume operation.",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n-The matching received address is loaded into either the I2CxADB1 register or into the I2CxRXB register as determined by the ABD bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB1. When ABD is set (ABD = 1 ), the matching address is copied to\nI2CxRXB, which also sets RXBF and I2CxRXIF. I2CxRXIF is a read-only bit and must be cleared by either reading I2CxRXB or by setting CLRBF (CLRBF = 1 ).\nIf the address does not match, the module goes Idle.",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n10. If the Transmit Buffer Empty Status (TXBE) bit is set (TXBE = 1 ), I2CxCNT has a nonzero value (I2CxCNT != 0 ) and the I2C Transmit Interrupt Flag (I2CxTXIF) is set (I2CxTXIF = 1 ), client hardware sets CSTR, stretches the clock (when CSD = 0 ), and waits for software to load I2CxTXB with data. I2CxTXB must be loaded to clear I2CxTXIF. Once data are loaded into I2CxTXB, hardware automatically clears CSTR to resume communication.\n11. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive overflow (RXO = 1 ), client hardware automatically generates a NACK condition. NACKIF is set, and the module goes Idle.",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n12. Upon the 9th falling SCL edge, the data byte in I2CxTXB is transferred to the transmit shift register, and I2CxCNT is decremented by one. Additionally, the ACKTIF bit is set. If the ACKTIE bit is also set, the generic I2CxIF is set, and if client hardware generated an ACK, the CSTR bit is also set and the clock is stretched (when CSD = 0 ). If a NACK was generated, the CSTR bit remains unchanged. Once complete, software must clear CSTR and ACKTIF to release the clock and continue operation.\n13. If the client generated an ACK and I2CxCNT is nonzero, host hardware transmits eight clock pulses, and client hardware begins to shift the data byte out of the shift register starting with the Most Significant bit (MSb).",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n14. After the 8th falling edge of SCL, client hardware checks the status of TXBE and I2CxCNT. If TXBE is set and I2CxCNT has a nonzero count value, hardware sets CSTR and the clock is stretched (when CSD = 0 ) until software loads I2CxTXB with new data. Once I2CxTXB has been loaded, hardware clears CSTR to resume communication.\n15. Once the host hardware clocks in all eight data bits, it transmits the 9th clock pulse along with the ACK/NACK response back to the client. Client hardware copies the ACK/NACK value to the Acknowledge Status (ACKSTAT) bit and sets ACKTIF. If ACKTIE is also set, client hardware sets the generic I2CxIF bit and CSTR and stretches the clock (when CSD = 0 ). Software must clear CSTR to resume operation.",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n16. After the 9th falling edge of SCL, data currently loaded in I2CxTXB is transferred to the transmit shift register, setting both TXBE and I2CxTXIF. I2CxCNT is decremented by one. If I2CxCNT is zero (I2CxCNT = 0 ), CNTIF is set.\n17. If I2CxCNT is nonzero and the host issued an ACK on the last byte (ACKSTAT = 0 ), the host transmits eight clock pulses, and client hardware begins to shift data out of the shift register.",
    "36.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n18. Repeat Steps 13-17 until the host has received all the requested data (I2CxCNT = 0 ). Once all data are received, host hardware transmits a NACK condition, followed by either a Stop or Restart condition. Once the NACK has been received by the client, hardware sets NACKIF and clears SMA. If the NACK Detect Interrupt Enable (NACKIE) bit is also set, the generic I2C Error Interrupt Flag (I2CxEIF) is set. If the host issued a Stop condition, client hardware sets the Stop Condition Interrupt Flag (PCIF). If the host issued a Restart condition, client hardware sets the Restart Condition Interrupt Flag (RSCIF) bit. If the associated interrupt enable bits are also set, the generic I2CxIF is also set.\nFigure 36-21. 10-Bit Client Mode Transmission rota e hisp g 90",
    "36.4.1.4.2 Client Reception (10-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is receiving data in 7-bit Addressing mode:\n1. The host issues a Start condition. Once the Start is detected, client hardware sets the Start Condition Interrupt Flag (SCIF) bit. If the Start Condition Interrupt Enable (SCIE) bit is also set, the generic I2CxIF bit is also set.\n2. Host hardware transmits the address high byte with the R/W bit clear (R/W = 0 ).\n3. The received high address byte is compared to the values in the I2CxADR registers. If the client is configured in 10-bit Addressing mode (no masking), the received high address byte is compared to the values in the I2CxADR1 and I2CxADR3 registers. If the client is configured in 10-bit Addressing with Masking mode, the received high address byte is compared to the masked value in the I2CxADR1 register.\nIf a high address match occurs:",
    "36.4.1.4.2 Client Reception (10-Bit Addressing Mode)\n-The R/W bit value is copied to the Read Information (R) bit by module hardware.\n-The Data (D) bit is cleared (D = 0 ) by hardware, indicating the last received byte was an address.\n-The Address Interrupt Flag (ADRIF) bit is set (ADRIF = 1 ). It is important to note that regardless of whether the Address Interrupt and Hold Enable (ADRIE) bit is set, clock stretching does not occur when the R/W bit is clear in 10-bit Addressing modes.\n-The matching address is loaded into either the I2CxADB1 register or into the I2CxRXB register as determined by the Address Buffer Disable (ABD) bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB1. When ABD is set (ABD = 1 ), the matching address is copied to I2CxRXB, which also sets the Receive Buffer Full Status (RXBF) bit and the I2C Receive Interrupt Flag (I2CxRXIF) bit.",
    "36.4.1.4.2 Client Reception (10-Bit Addressing Mode)\nIf no address match occurs, the module remains Idle.\n4. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive buffer overflow (RXO = 1 ), client hardware generates a NACK and the module goes Idle.\n5. The host device transmits the low address byte. If the client is configured in 10-bit Addressing mode (no masking), the received low address byte is compared to the values in I2CxADR0 and I2CxADR2. In 10-bit Addressing with Masking mode, the received low address byte is compared to the masked value of I2CxADR0.\nIf a match occurs:",
    "36.4.1.4.2 Client Reception (10-Bit Addressing Mode)\n-The Client Mode Active (SMA) bit is set by module hardware.\n-ADRIF is set. If ADRIE is set and the Clock Stretching Disable (CSD) bit is clear, hardware sets the Client Clock Stretching (CSTR) bit and the generic I2CxIF bit. This allows time for the client to read either I2CxADB0 or I2CxRXB and selectively ACK/NACK based on the received address. When the client has finished processing the address, software must clear CSTR to resume operation.",
    "36.4.1.4.2 Client Reception (10-Bit Addressing Mode)\n-The matching received address is loaded into either the I2CxADB0 register or into the I2CxRXB register as determined by the ABD bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB0. When ABD is set (ABD = 1 ), the matching address is copied to I2CxRXB, which also sets the RXBF and the I2CxRXIF bits. I2CxRXIF is a read-only bit and must be cleared by either reading I2CxRXB or by setting the Clear Buffer (CLRBF) bit (CLRBF = 1 ).\nIf no match occurs, the module goes Idle.\n- 6. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive buffer overflow (RXO = 1 ), client hardware generates a NACK and the module goes Idle.",
    "36.4.1.4.2 Client Reception (10-Bit Addressing Mode)\n7. After the 9th falling edge of SCL, the Acknowledge Status Time Interrupt Flag (ACKTIF) bit is set. If the Acknowledge Time Interrupt and Hold Enable (ACKTIE) bit is also set, the generic I2CxIF is set, and if client hardware generated an ACK, the CSTR bit is also set and the clock is stretched (when CSD = 0 ). If a NACK was generated, the CSTR bit remains unchanged. Once completed, software must clear CSTR and ACKTIF to release the clock and resume operation.\n8. If client hardware generated a NACK, host hardware generates a Stop condition, the Stop Condition Interrupt Flag (PCIF) is set when client hardware detects the Stop condition, and the client goes Idle. If an ACK was generated, host hardware transmits the first seven bits of the 8-bit data byte.",
    "36.4.1.4.2 Client Reception (10-Bit Addressing Mode)\n9. If data remains in I2CxRXB (RXBF = 1 and I2CxRXIF = 1 ) when the first seven bits of the new byte are received by the shift register, CSTR is set, and if CSD is clear, the clock is stretched after the 7th falling edge of SCL. This allows time for the client to read I2CxRXB, which clears RXBF and I2CxRXIF, and prevents a receive buffer overflow. Once I2CxRXB has been read, RXBF and I2CxRXIF are cleared, and hardware releases SCL.\n10. Host hardware transmits the 8th bit of the current data byte into the client receive shift register. Client hardware then transfers the complete byte into I2CxRXB on the 8th falling edge of SCL and sets the following bits:\n-I2CxRXIF\n-I2CxIF\n-Data Write Interrupt Flag (WRIF)\n-Data (D)\n-RXBF",
    "36.4.1.4.2 Client Reception (10-Bit Addressing Mode)\nI2CxCNT is decremented by one. If the Data Write Interrupt and Hold Enable (WRIE) bit is set (WRIE = 1 ), hardware sets CSTR (when CSD = 0 ) and stretches the clock, allowing time for client software to read I2CxRXB and determine the state of the ACKDT bit that is transmitted back to the host. Once the client determines the Acknowledgement response, software clears CSTR to allow further communication.\n11. Upon the 9th falling edge of SCL, the ACKTIF bit is set. If ACKTIE is also set, the generic I2CxIF is set, and if CSD is clear, client hardware sets CSTR and stretches the clock. This allows time for software to read I2CxRXB. Once complete, software must clear both CSTR and ACKTIF to release the clock and continue communication.\n12. Repeat Steps 8 - 11 until the host has transmitted all the data (I2CxCNT = 0 ) or until the host issues a Stop or Restart condition.",
    "36.4.1.4.2 Client Reception (10-Bit Addressing Mode)\nFigure 36-22. 10-Bit Client Mode Reception rota e hisp g 90",
    "36.4.2 I 2 C Host Mode Operation\nThe I 2 C module provides two Host Operation modes as selected by the I2C Mode Select (MODE) bits:\n\u00b7 I 2 C Host mode with 7-bit addressing\n\u00b7 I 2 C Host mode with 10-bit addressing\nTo begin any I 2 C communication, host hardware checks to ensure that the bus is in an Idle state, which means both the SCL and SDA lines are floating in a high Logic state as indicated by the Bus Free Status (BFRE) bit.\nOnce Host hardware has determined that the bus is free (BFRE = 1 ), it examines the state of the Address Buffer Disable (ABD) bit. The ABD bit determines whether the I2CxADB registers are used.",
    "36.4.2 I 2 C Host Mode Operation\nWhen ABD is clear (ABD = 0 ), address buffers I2CxADB0 and I2CxADB1 are active. In 7-bit Addressing mode, software loads I2CxADB1 with the 7-bit client address and R/W bit setting and also loads I2CxTXB with the first byte of data. In 10-bit Addressing mode, software loads I2CxADB1 with the address high byte and I2CxADB0 with the address low byte and also loads I2CxTXB with the first data byte. Software must issue a Start condition to initiate communication with the client.\nWhen ABD is set (ABD = 1 ), the address buffers are inactive. In this case, communication begins as soon as software loads the client address into I2CxTXB. Writes to the Start (S) bit are ignored.",
    "36.4.2 I 2 C Host Mode Operation\nIn 7-bit Addressing mode, the Least Significant bit (LSb) of the 7-bit address byte acts as the Read/not Write (R/W) information bit, while in 10-bit Addressing mode, the LSb of the address high byte is reserved as the R/W bit. When R/W is set, the host intends to read data from the client (see the figure below). When R/W is clear, the host intends to write data to the client (see the figure below). The host may also wish to read or write data to a specific location, such as writing to a specific EEPROM location. In this case, the host issues a Start condition, followed by the client's address with the R/W bit clear. Once the client acknowledges the address, the first data byte following the 7-bit or 10-bit address is used as the client's specific register location. If the host intends to read data from the specific location, it must issue a Restart condition, followed by the client address with the R/W bit set (see the figure below). If the addressed client device exists on the bus, it must respond with an",
    "36.4.2 I 2 C Host Mode Operation\nAcknowledge (ACK) sequence.\nOnce a client has acknowledged its address, the host begins to receive data from the client or transmits data to the client. Data are always transmitted Most Significant bit (MSb) first. When the host wishes to halt further communication, it transmits either a Stop condition, signaling to the client that communication is to be terminated, or a Restart condition, informing the bus that the current host wishes to hold the bus to communicate with the same or other client devices.\nFigure 36-23. 7-Bit Host Read Diagram\nFigure 36-25. 10-Bit Host Read Diagram\n(from client)\nFigure 36-26. 7-Bit Host Write Diagram\nFigure 36-28. 10-Bit Host Write Diagram",
    "36.4.2.1 Bus Free Time\nThe Bus Free Status (BFRE) bit indicates the activity status of the bus. When BFRE is set (BFRE = 1 ), the bus is in an Idle state (both SDA and SCL are floating high), and any host device residing on the bus can compete for control of the bus. When BFRE is clear (BFRE = 0 ), the bus is in an Active state, and any attempts by a host to control the bus will cause a collision.\nThe Bus Free Time (BFRET) bits determine the length of time, in terms of I 2 C clock pulses, before the bus is considered Idle. Once module hardware detects logic high levels on both SDA and SCL, it monitors the I 2 C clock signal, and when the desired number of pulses have occurred, module hardware sets BFRE. The BFRET bits are also used to ensure that the module meets the minimum Stop hold time as defined by the I 2 C Specification.",
    "36.4.2.2 Host Clock Timing\nThe Serial Clock (SCL) signal is generated by module hardware via the I2C Clock Selection (I2CxCLK) Register, the I2C Baud Rate Prescaler (I2CxBAUD) Register, and the Fast Mode Enable (FME) bit.\nThe figure below illustrates the SCL clock generation.",
    "Figure 36-29. SCL Clock Generation\n\u3131\n\u3130\n\u3131\n\u3030\n\u3030\nI2CxCLK contains several clock source selections. The clock source selections typically include variants of the system clock and timer resources.\nImportant: When using a timer as the clock source, the timer must also be configured. Additionally, when using the HFINTOSC as a clock source, it is important to understand that the HFINTOSC frequency selected by the OSCFRQ register is used as the clock source. The clock divider selected by the NDIV bits is not used. For example, if OSCFRQ selects 4 MHz as the HFINTOSC clock frequency, and the NDIV bits select a divide by four scaling factor, the I2C Clock Frequency will be 4 MHz and not 1 MHz since the divider is ignored.\nI2CxBAUD is used to determine the prescaler (clock divider) for the I2CxCLK source.\nThe FME bit acts as a secondary divider to the prescaled clock source.",
    "Figure 36-29. SCL Clock Generation\nWhen FME is clear (FME = 0 ), one SCL period (T SCL ) is equal to five clock periods of the prescaled I2CxCLK source. In other words, the prescaled I2CxCLK source is divided by five. For example, if the HFINTOSC (set to 4 MHz) clock source is selected, I2CxBAUD is loaded with a value of ' 7 ', and the FME bit is clear, the actual SCL frequency is 100 kHz (see the equation below).\nEquation 36-1. SCL Frequency (FME = 0 )\nExample:\n\u00b7 I2CxCLK: HFINTOSC (4 MHz)\n\u00b7 I2CxBAUD: 7\n\u00b7 FME: FME = 0",
    "Figure 36-29. SCL Clock Generation\nWhen FME is clear, host hardware uses the first prescaled I2CxCLK source period to drive SCL low (see Figure 36-30). During the second period, hardware verifies that SCL is in fact low. During the third period, hardware releases SCL, allowing it to float high. Host hardware then uses the fourth and fifth periods to sample SCL to verify that SCL is high. If a client is holding SCL low (clock stretch)\n<!-- formula-not-decoded -->\n\u3030\n\u3130\n\u3031\n\u3131\n\u2b20\n\u3d20\nRev. FME = 0.vs\n7/30/2019\nduring the fourth and/or fifth period, host hardware samples each successive prescaled I2CxCLK period until a high level is detected on SCL. Once the high level is detected, host hardware samples SCL during the next two I2CxCLK periods to verify that SCL is high.",
    "Figure 36-30. SCL Timing (FME = 0 )\nWhen FME is set (FME = 1 ), one SCL period (T SCL ) is equal to four clock periods of the prescaled I2CxCLK source. In other words, the prescaled I2CxCLK source is divided by four. Using the example from above, if the HFINTOSC (4 MHz) clock source is selected, I2CxBAUD is loaded with a value of ' 7 ', and the FME bit is set, the actual SCL frequency is 125 kHz (see the equation below).",
    "Example:\n\u00b7 I2CxCLK: HFINTOSC (4 MHz)\n\u00b7 I2CxBAUD: 7\n\u00b7 FME: FME = 1\nWhen FME is set, host hardware uses the first prescaled I2CxCLK source period to drive SCL low (see Figure 36-31). During the second prescaled period, hardware verifies that SCL is in fact low. During the third period, hardware releases SCL, allowing it to float high. Host hardware then uses the fourth period to sample SCL to verify that SCL is high. If a client is holding SCL low (clock stretch) during the fourth period, host hardware samples each successive prescaled I2CxCLK period until a high level is detected on SCL. Once the high level is detected, host hardware samples SCL during the next period to verify that SCL is high.\n<!-- formula-not-decoded -->\nFirst Used:\nNotes:",
    "Figure 36-31. SCL Timing (FME = 1 )\nRev. FME = 1.vs\n7/30/2019",
    "36.4.2.3 Start Condition Timing\nA Start condition is initiated by either writing to the Start (S) bit (when ABD = 0 ) or by writing to I2CxTXB (when ABD = 1 ). When the Start condition is initiated, host hardware verifies that the bus is Idle, then begins to count the number of I2CxCLK periods as determined by the Bus Free Time Status (BFRET) bits. Once the Bus Free Time period has been reached, hardware sets BFRE (BFRE = 1 ), the Start condition is asserted on the bus, which pulls the SDA line low, and the Start Condition Interrupt Flag (SCIF) bit is set (SCIF = 1 ). Host hardware then waits one full SCL period (T SCL ) before pulling the SCL line low, signaling the end of the Start condition. At this point, hardware loads the transmit shift register from either I2CxADB0/I2CxADB1 (ABD = 0 ) or I2CxTXB (ABD = 1 ). Filename: Start Condition Timing.vsdx Title: Last Edit: 1/28/2019 First Used: Notes:",
    "36.4.2.3 Start Condition Timing\nThe figure below shows an example of a Start condition.\nFigure 36-32. Start Condition Timing\nRev. Start Co nd\n1/28/2019",
    "Important:\n1. See the device data sheet for Start condition hold time parameters.\n2. SDA hold times are configured via the SDAHT bits.",
    "36.4.2.4 Acknowledge Sequence Timing\nThe 9th SCL pulse for any transferred address/data byte is reserved for the Acknowledge (ACK) sequence. During an Acknowledge sequence, the transmitting device relinquishes control of the SDA line to the receiving device. At this time, the receiving device must decide whether to pull the SDA line low (ACK) or allow the line to float high (NACK).",
    "36.4.2.4 Acknowledge Sequence Timing\nAn Acknowledge sequence is enabled automatically by module hardware following an address/data byte reception. On the 8th falling edge of SCL, the value of either the ACKDT or ACKCNT bits are copied to the SDA output, depending on the state of I2CxCNT. When I2CxCNT holds a nonzero value (I2CxCNT != 0 ), the value of ACKDT is copied to SDA (see Figure 36-33). When I2CxCNT reaches a zero count (I2CxCNT = 0 ), the value of ACKCNT is copied to SDA (see Figure 36-34). In most applications, the value of ACKDT needs to be zero (ACKDT = 0 ), which represents an ACK, while the value of ACKCNT needs to be one (ACKCNT = 1 ), which represents a NACK. Filename: ACK Sequence Timing.vsdx Title: Last Edit: 1/10/2019 First Used: Notes:\nFigure 36-33. Acknowledge (ACK) Sequence Timing",
    "36.4.2.5 Restart Condition Timing\nA Restart condition is identical to a Start condition. A host device may issue a Restart instead of a Stop condition if it intends to hold the bus after completing the current data transfer. A Restart condition occurs when the Restart Enable (RSEN) bit is set (RSEN = 1 ), either I2CxCNT is zero (I2CxCNT = 0 ) or ACKSTAT is set (ACKSTAT = 1 ), and either host hardware (ABD = 1 ) or user software (ABD = 0 ) sets the Start (S) bit.",
    "36.4.2.5 Restart Condition Timing\nWhen the Start bit is set, host hardware releases SDA (SDA floats high) for half of an SCL clock period (T SCL /2) and then releases SCL for another half of an SCL period, then samples SDA (see Figure 36-35). If SDA is sampled low while SCL is sampled high, a bus collision has occurred. In this case, the Bus Collision Detect Interrupt Flag (BCLIF) is set, and if the Bus Collision Detect Interrupt Enable (BCLIE) bit is also set, the generic I2CxEIF is set and the module goes Idle. If SDA is sampled high while SCL is also sampled high, host hardware issues a Start condition. Once the Restart condition is detected on the bus, the Restart Condition Interrupt Flag (RSCIF) is set by hardware, and if the Restart Condition Interrupt Enable (RSCIE) bit is set, the generic I2CxIF is also set.",
    "Figure 36-35. Restart Condition Timing\nRSCIF =\n1",
    "Important:\n1. See the device data sheet for Restart condition setup times.",
    "36.4.2.6 Stop Condition Timing\nA Stop condition occurs when SDA transitions from an Active state to an Idle state while SCL is Idle. Host hardware will issue a Stop condition when it has completed its current transmission and is ready to release control of the bus. A Stop condition is also issued after an Error condition occurs, such as a bus time-out, or when a NACK condition is detected on the bus. User software may also generate a Stop condition by setting the Stop (P) bit.\nAfter the ACK/NACK sequence of the final byte of the transmitted/received packet, hardware pulls SCL low for half of an SCL period (T SCL /2) (see Figure 36-36). After the half SCL period, hardware releases SCL, then samples SCL to ensure it is in an Idle state (SCL = 1 ). Host hardware then waits the duration of the Stop condition setup time (T SU:STO ) and releases SDA, setting the Stop Condition Interrupt Flag (PCIF). If the Stop Condition Interrupt Enable (PCIE) bit is also set, the generic I2CxIF is also set.",
    "36.4.2.6 Stop Condition Timing\nImportant: At least one SCL low period must appear before a Stop condition is valid. If the SDA line transitions low and then high again while SCL is high, the Stop condition is ignored, and a Start condition will be detected by the receiver.\nNotes:",
    "Important:\n1. At least one SCL low period must appear before a Stop is valid.\n2. See the device data sheet Electrical Specifications for Stop condition setup and hold times.",
    "36.4.2.7 Host Operation in 7-Bit Addressing Modes\nIn Host 7-bit Addressing modes, the client's 7-bit address and R/W bit value are loaded into either I2CxADB1 or I2CxTXB, depending on the Address Buffer Disable (ABD) bit setting. When the host wishes to read data from the client, software must set the R/W bit (R/W = 1 ). When the host wishes to write data to the client, software must clear the R/W bit (R/W = 0 ).",
    "36.4.2.7.1 Host Transmission (7-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is transmitting data in 7-bit Addressing mode:\n1. Depending on the configuration of the Address Buffer Disable (ABD) bit, one of two methods may be used to begin communication:\na. When ABD is clear (ABD = 0 ), the address buffer, I2CxADB1, is enabled. In this case, the 7-bit client address and R/W bit are loaded into I2CxADB1, with the R/W bit clear (R/W = 0 ). The number of data bytes are loaded into I2CxCNT, and the first data byte is loaded into I2CxTXB. After these registers are loaded, software must set the Start (S) bit to begin communication. Once the S bit is set, host hardware waits for the Bus Free (BFRE) bit to be set before transmitting the Start condition to avoid bus collisions.",
    "36.4.2.7.1 Host Transmission (7-Bit Addressing Mode)\nb. When ABD is set (ABD = 1 ), the address buffer is disabled. In this case, the number of data bytes are loaded into I2CxCNT, and the client's 7-bit address and R/W bit are loaded into I2CxTXB. A write to I2CxTXB will cause host hardware to automatically issue a Start condition once the bus is Idle (BFRE = 1 ). Software writes to the Start bit are ignored.",
    "36.4.2.7.1 Host Transmission (7-Bit Addressing Mode)\n2. Host hardware waits for BFRE to be set, then shifts out the Start condition. Module hardware sets the Host Mode Active (MMA) bit and the Start Condition Interrupt Flag (SCIF). If the Start Condition Interrupt Enable (SCIE) bit is set, the generic I2CxIF is also set.\n3. Host hardware transmits the 7-bit client address and R/W bit.\n4. If upon the 8th falling edge of SCL, I2CxTXB is empty (Transmit Buffer Empty Status (TXBE) = 1 ), I2CxCNT is nonzero (I2CxCNT != 0 ), and the Clock Stretching Disable (CSD) bit is clear (CSD = 0 ):\n-The I2C Transmit Interrupt Flag (I2CxTXIF) is set. If the I2C Transmit Interrupt Enable (I2CxTXIE) bit is also set, the generic I2CxIF is also set.",
    "36.4.2.7.1 Host Transmission (7-Bit Addressing Mode)\n-The Host Data Request (MDR) bit is set, and the clock is stretched, allowing time for software to load I2CxTXB with new data. Once I2CxTXB has been written, hardware releases SCL and clears MDR.\n5. Hardware transmits the 9th clock pulse and waits for an ACK/NACK response from the client. If the host receives an ACK, module hardware transfers the data from I2CxTXB into the transmit shift register, and I2CxCNT is decremented by one. If the host receives a NACK, hardware will attempt to issue a Stop condition. If the clock is currently being stretched by a client, the host must wait until the bus is free before issuing the Stop.\n6. Host hardware checks I2CxCNT for a zero value. If I2CxCNT is zero:",
    "36.4.2.7.1 Host Transmission (7-Bit Addressing Mode)\na. If ABD is clear (ABD = 0 ), host hardware issues a Stop condition or sets MDR if the Restart Enable (RSEN) bit is set and waits for software to set the Start bit to issue a Restart condition. CNTIF is set.\nb. If ABD is set (ABD = 1 ), host hardware issues a Stop condition or sets MDR if RSEN is set and waits for software to load I2CxTXB with a new client address. CNTIF is set.\n7. Host hardware transmits the data byte.\n8. If upon the 8th falling edge of SCL I2CxTXB is empty (TXBE = 1 ), I2CxCNT is nonzero (I2CxCNT != 0 ), and CSD is clear (CSD = 0 ):\n-I2CxTXIF is set. If the I2CxTXIE bit is also set, the generic I2CxIF is also set.",
    "36.4.2.7.1 Host Transmission (7-Bit Addressing Mode)\n-The MDR bit is set, and the clock is stretched, allowing time for software to load I2CxTXB with new data. Once I2CxTXB has been written, hardware releases SCL and clears MDR.\nIf TXBE is set (TXBE = 1 ) and I2CxCNT is zero (I2CxCNT = 0 ):\n-I2CxTXIF is NOT set.\n-CNTIF is set.\n-Host hardware issues a Stop condition, setting PCIF.\n9. Repeat Steps 5 - 8 until all data has been transmitted.\nRev. I2C Host\n1/9/2019\nFigure 36-37. 7-Bit Host Mode Transmission rota e hisp g 90",
    "36.4.2.7.2 Host Reception (7-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is receiving data in 7-bit Addressing mode:\n1. Depending on the configuration of the Address Buffer Disable (ABD) bit, one of two methods may be used to begin communication:\na. When ABD is clear (ABD = 0 ), the address buffer, I2CxADB1, is enabled. In this case, the 7-bit client address and R/W bit are loaded into I2CxADB1, with the R/W bit set (R/W = 1 ). The number of expected received data bytes are loaded into I2CxCNT. After these registers are loaded, software must set the Start (S) bit to begin communication. Once the S bit is set, host hardware waits for the Bus Free (BFRE) bit to be set before transmitting the Start condition to avoid bus collisions.",
    "36.4.2.7.2 Host Reception (7-Bit Addressing Mode)\nb. When ABD is set (ABD = 1 ), the address buffer is disabled. In this case, the number of expected received data bytes are loaded into I2CxCNT, and the client's 7-bit address and R/W bit are loaded into I2CxTXB. A write to I2CxTXB will cause host hardware to automatically issue a Start condition once the bus is Idle (BFRE = 1 ). Software writes to the Start bit are ignored.\n2. Host hardware waits for BFRE to be set, then shifts out the Start condition. Module hardware sets the Host Mode Active (MMA) bit and the Start Condition Interrupt Flag (SCIF). If the Start Condition Interrupt Enable (SCIE) bit is set, the generic I2CxIF is also set.\n3. Host hardware transmits the 7-bit client address and R/W bit.\n4. Host hardware samples SCL to determine if the client is stretching the clock and continues to sample SCL until the line is sampled high.",
    "36.4.2.7.2 Host Reception (7-Bit Addressing Mode)\n5. Host hardware transmits the 9th clock pulse and receives the ACK/NACK response from the client.\nIf an ACK is received, host hardware receives the first seven bits of the data byte into the receive shift register.\nIf a NACK is received, hardware sets the NACK Detect Interrupt Flag (NACKIF), and:\na. ABD = 0 : Host generates a Stop condition or sets the MDR bit (if RSEN is also set) and waits for software to set the Start bit to generate a Restart condition.\nb. ABD = 1 : Host generates a Stop condition or sets the MDR bit (if RSEN is also set) and waits for software to load a new address into I2CxTXB. Software writes to the Start bit are ignored.\nIf the NACK Detect Interrupt Enable (NACKIE) is also set, hardware sets the generic I2CxEIF bit.",
    "36.4.2.7.2 Host Reception (7-Bit Addressing Mode)\n6. If previous data remains in the I2C Receive Buffer (I2CxRXB) when the first seven bits of the new byte are received into the receive shift register (RXBF = 1 ), the MDR bit is set (MDR = 1 ), and the clock is stretched after the 7th falling edge of SCL. This allows the host time to read I2CxRXB, which clears the RXBF bit and prevents receive buffer overflows. Once RXBF is clear, hardware releases SCL.\n7. The host clocks in the 8th bit of the data byte into the receive shift register, then transfers the full byte into I2CxRXB. Host hardware sets the I2C Receive Interrupt Flag (I2CxRXIF) and RXBF, and if the I2C Receive Interrupt Enable (I2CxRXIE) is set, the generic I2CxIF is also set. Finally, I2CxCNT is decremented by one.\n8. Host hardware checks I2CxCNT for a zero value.",
    "36.4.2.7.2 Host Reception (7-Bit Addressing Mode)\nIf I2CxCNT is nonzero (I2CxCNT != 0 ), hardware transmits the value of the Acknowledge Data (ACKDT) bit as the acknowledgement response to the client. It is up to user software to properly configure ACKDT. In most cases, ACKDT must be clear (ACKDT = 0 ), which indicates an ACK response.\nIf I2CxCNT is zero (I2CxCNT = 0 ), hardware transmits the value of the Acknowledge End of Count (ACKCNT) bit as the acknowledgement response to the client. CNTIF is set, and host hardware either issues a Stop condition or a Restart condition. It is up to user software to properly",
    "36.4.2.7.2 Host Reception (7-Bit Addressing Mode)\nconfigure ACKCNT. In most cases, ACKCNT must be set (ACKCNT = 1 ), which indicates a NACK response. When hardware detects a NACK on the bus, it automatically issues a Stop condition. If a NACK is not detected, the Stop will not be generated, which may lead to a stalled Bus condition.\n9. Host hardware receives the first seven bits of the next data byte into the receive shift register.\n10. Repeat Steps 6 - 9 until all expected bytes have been received.\nRev. I2C Host\n1/9/2019\nFigure 36-38. 7-Bit Host Mode Reception rota e hisp g 90",
    "36.4.2.8 Host Operation in 10-Bit Addressing Modes\nIn Host 10-bit Addressing modes, the client's 10-bit address and R/W bit value are loaded into either the I2CxADB0 and I2CxADB1 registers (when ABD = 0 ) or I2CxTXB (when ABD = 1 ). When the host intends to read data from the client, it must first transmit the full 10-bit address with the R/W bit clear (R/W = 0 ), issue a Restart condition, then transmit the address high byte with the R/W bit set (R/W = 1 ). When the host intends to write data to the client, it must transmit the full 10-bit address with the R/W bit clear (R/W = 0 ).",
    "36.4.2.8.1 Host Transmission (10-Bit)\nThe following section describes the sequence of events that occur when the module is transmitting data in 10-bit Addressing mode:",
    "36.4.2.8.1 Host Transmission (10-Bit)\n1. Depending on the configuration of the Address Buffer Disable (ABD) bit, one of two methods may be used to begin communication:\na. When ABD is clear (ABD = 0 ), the address buffers, I2CxADB0 and I2CxADB1, are enabled. In this case, the address high byte is loaded into I2CxADB1 with the R/W bit clear, while the address low byte is loaded into I2CxADB0. I2CxCNT is loaded with the total number of data bytes to transmit, and the first data byte is loaded into I2CxTXB. After these registers are loaded, software must set the Start bit to begin communication.\nb. When ABD is set (ABD = 1 ), the address buffers are disabled. In this case, I2CxCNT must be loaded with the total number of bytes to transmit prior to loading I2CxTXB with the address high byte and R/W bit. A write to I2CxTXB forces module hardware to issue a Start condition automatically; software writes to the S bit are ignored.",
    "36.4.2.8.1 Host Transmission (10-Bit)\n2. Host hardware waits for BFRE to be set, then shifts out the Start condition. Module hardware sets the Host Mode Active (MMA) bit and the Start Condition Interrupt Flag (SCIF). If the Start Condition Interrupt Enable (SCIE) bit is also set, the generic I2CxIF is also set.\n3. Host hardware transmits the address high byte and R/W bit from I2CxADB1.\n4. Host hardware transmits the 9th clock pulse and shifts in the ACK/NACK response from the client.\nIf the host receives a NACK, it issues a Stop condition.\nIf the host receives and ACK and:\na. ABD = 0 : Hardware transmits the address low byte from I2CxADB0.\nb. ABD = 1 : Hardware sets I2CxTXIF and the Host Data Request (MDR) bit and waits for software to load I2CxTXB with the address low byte. Software must load I2CxTXB to resume communication.",
    "36.4.2.8.1 Host Transmission (10-Bit)\n5. If upon the 8th falling edge of SCL I2CxTXB is empty (TXBE = 1 ), I2CxCNT is nonzero (I2CxCNT != 0 ), and the Clock Stretching Disable (CSD) bit is clear (CSD = 0 ):\n-I2CxTXIF is set. If the I2C Transmit Interrupt Enable (I2CxTXIE) bit is also set, the generic I2CxIF is also set.\n-MDR bit is set, and the clock is stretched, allowing time for software to load I2CxTXB with the address low byte. Once I2CxTXB has been written, hardware releases SCL and clears MDR.",
    "36.4.2.8.1 Host Transmission (10-Bit)\n6. Hardware transmits the 9th clock pulse and waits for an ACK/NACK response from the client. If the host receives an ACK, module hardware transfers the data from I2CxTXB into the transmit shift register, and I2CxCNT is decremented by one. If the host receives a NACK, hardware will attempt to issue a Stop condition. If the clock is currently being stretched by a client, the host must wait until the bus is free before issuing the Stop.\n7. Host hardware checks I2CxCNT for a zero value. If I2CxCNT is zero:\na. If ABD is clear (ABD = 0 ), host hardware issues a Stop condition or sets MDR if the Restart Enable (RSEN) bit is set and waits for software to set the Start bit to issue a Restart condition. CNTIF is set.",
    "36.4.2.8.1 Host Transmission (10-Bit)\nb. If ABD is set (ABD = 1 ), host hardware issues a Stop condition or sets MDR if RSEN is set and waits for software to load I2CxTXB with a new client address. CNTIF is set.\n8. Host hardware transmits the data byte.\n9. If upon the 8th falling edge of SCL I2CxTXB is empty (TXBE = 1 ), I2CxCNT is nonzero (I2CxCNT != 0 ), and CSD is clear (CSD = 0 ):\n-The I2CxTXIF bit is set. If the I2CxTXIE bit is also set, the generic I2CxIF is also set.\n-The MDR bit is set, and the clock is stretched, allowing time for software to load I2CxTXB with new data. Once I2CxTXB has been written, hardware releases SCL and clears MDR.\nIf TXBE is set (TXBE = 1 ) and I2CxCNT is zero (I2CxCNT = 0 ):",
    "36.4.2.8.1 Host Transmission (10-Bit)\n-I2CxTXIF is NOT set.\n-CNTIF is set.\n-Host hardware issues a Stop condition, setting PCIF.\n10. Repeat Steps 6 - 9 until all data has been transmitted.\nFigure 36-39. 10-Bit Host Mode Transmission rota e hisp g 90",
    "36.4.2.8.2 Host Reception (10-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is receiving data in 10-bit Addressing mode:\n1. Depending on the configuration of the Address Buffer Disable (ABD) bit, one of two methods may be used to begin communication:\na. When ABD is clear (ABD = 0 ), the address buffers, I2CxADB0 and I2CxADB1, are enabled. In this case, the address high byte and R/W bit are loaded into I2CxADB1, with R/W clear (R/W = 0 ). The address low byte is loaded into I2CxADB0, and the Restart Enable (RSEN) bit is set by software. After these registers are loaded, software must set the Start (S) bit to begin communication. Once the S bit is set, host hardware waits for the Bus Free (BFRE) bit to be set before transmitting the Start condition to avoid bus collisions.",
    "36.4.2.8.2 Host Reception (10-Bit Addressing Mode)\nb. When ABD is set (ABD = 1 ), the address buffers are disabled. In this case, the number of expected received bytes are loaded into I2CxCNT, the address high byte and R/W bit are loaded into I2CxTXB, with R/W clear (R/W = 0 ). A write to I2CxTXB will cause host hardware to automatically issue a Start condition once the bus is Idle (BFRE = 1 ). Software writes to the Start bit are ignored.\n2. Host hardware waits for BFRE to be set, then shifts out the Start condition. Module hardware sets the Host Mode Active (MMA) bit and the Start Condition Interrupt Flag (SCIF). If the Start Condition Interrupt Enable (SCIE) bit is set, the generic I2CxIF is also set.\n3. Host hardware transmits the address high byte and R/W bit.\n4. Host hardware samples SCL to determine if the client is stretching the clock and continues to sample SCL until the line is sampled high.",
    "36.4.2.8.2 Host Reception (10-Bit Addressing Mode)\n5. Host hardware transmits the 9th clock pulse and receives the ACK/NACK response from the client.\nIf a NACK was received, the NACK Detect Interrupt Flag (NACKIF) is set and the host immediately issues a Stop condition.\nIf an ACK was received, module hardware transmits the address low byte.\n6. Host hardware samples SCL to determine if the client is stretching the clock and continues to sample SCL until the line is sampled high.\n7. Host hardware transmits the 9th clock pulse and receives the ACK/NACK response from the client.\nIf an ACK is received, hardware sets MDR and waits for hardware or software to set the Start bit. If a NACK is received, hardware sets NACKIF, and:\na. ABD = 0 : Host generates a Stop condition or sets the MDR bit (if RSEN is also set) and waits for software to set the Start bit to generate a Restart condition.",
    "36.4.2.8.2 Host Reception (10-Bit Addressing Mode)\nb. ABD = 1 : Host generates a Stop condition or sets the MDR bit (if RSEN is also set) and waits for software to load a new address into I2CxTXB. Software writes to the Start bit are ignored.\nIf the NACK Detect Interrupt Enable (NACKIE) is also set, hardware sets the generic I2CxEIF bit.\n8. Software loads I2CxCNT with the expected number of received bytes.\n9. If ABD is clear (ABD = 0 ), software sets the Start bit. If ABD is set (ABD = 1 ), software writes the address high byte with R/W bit into I2CxTXB, with R/W set (R/W = 1 ).\n10. Host hardware transmits the Restart condition, which sets the Restart Condition Interrupt Flag (RSCIF) bit. If the Restart Condition Interrupt Enable (RSCIE) bit is set, the generic I2CxIF is set by hardware.\n11. Host hardware transmits the high address byte and R/W bit.",
    "36.4.2.8.2 Host Reception (10-Bit Addressing Mode)\n12. Host hardware samples SCL to determine if the client is stretching the clock and continues to sample SCL until the line is sampled high.\n13. Host hardware transmits the 9th clock pulse and receives the ACK/NACK response from the client.\nIf an ACK is received, host hardware receives the first seven bits of the data byte into the receive shift register.\nIf a NACK is received, and:\na. ABD = 0 : Host generates a Stop condition or sets the MDR bit (if RSEN is also set) and waits for software to set the Start bit to generate a Restart condition.\nb. ABD = 1 : Host generates a Stop condition or sets the MDR bit (if RSEN is also set) and waits for software to load a new address into I2CxTXB. Software writes to the Start bit are ignored.",
    "36.4.2.8.2 Host Reception (10-Bit Addressing Mode)\n14. If previous data are currently in I2CxRXB (RXBF = 1 ) when the first seven bits are received by the receive shift register, hardware sets MDR, and the clock is stretched after the 7th falling edge of SCL. This allows software to read I2CxRXB, which clears the RXBF bit and prevents a receive buffer overflow. Once the RXBF bit is cleared, hardware releases SCL.\n15. Host hardware clocks in the 8th bit of the data byte into the receive shift register, then transfers the complete byte into I2CxRXB, which sets the I2CxRXIF and RXBF bits. If I2CxRXIE is also set, hardware sets the generic I2CxIF bit. I2CxCNT is decremented by one.",
    "36.4.2.8.2 Host Reception (10-Bit Addressing Mode)\n16. Hardware checks I2CxCNT for a zero value. If I2CxCNT is nonzero (I2CxCNT != 0 ), hardware transmits the value of the Acknowledge Data (ACKDT) bit as the acknowledgement response to the client. It is up to user software to properly\nconfigure ACKDT. In most cases, ACKDT must be clear (ACKDT = 0 ), which indicates an ACK response.",
    "36.4.2.8.2 Host Reception (10-Bit Addressing Mode)\nIf I2CxCNT is zero (I2CxCNT = 0 ), hardware transmits the value of the Acknowledge End of Count (ACKCNT) bit as the acknowledgement response to the client. CNTIF is set, and host hardware either issues a Stop condition or a Restart condition. It is up to user software to properly configure ACKCNT. In most cases, ACKCNT must be set (ACKCNT = 1 ), which indicates a NACK response. When hardware detects a NACK on the bus, it automatically issues a Stop condition. If a NACK is not detected, the Stop will not be generated, which may lead to a stalled Bus condition.\n17. Host hardware receives the first seven bits of the next data byte into the receive shift register.\n18. Repeat Steps 14 - 17 until all expected bytes have been received.\nFigure 36-40. 10-Bit Host Mode Reception rota e hisp g 90",
    "36.4.3 I 2 C Multi-Host Mode Operation\nIn Multi-Host mode, multiple host devices reside on the same bus. A single device, or all devices, may act as both a host and a client. Control of the bus is achieved through clock synchronization and bus arbitration.\nThe Bus Free (BFRE) bit is used to determine if the bus is free. When BFRE is set (BFRE = 1 ), the bus is in an Idle state, allowing a host device to take control of the bus.\nIn Multi-Host mode, the Address Interrupt and Hold Enable (ADRIE) bit must be set (ADRIE = 1 ), and the Clock Stretching Disable (CSD) bit must be clear (CSD = 0 ), for a host device to be addressed as a client.",
    "36.4.3 I 2 C Multi-Host Mode Operation\nWhen a matching address is received into the receive shift register, the SMA bit is set, and the Address Interrupt Flag (ADRIF) bit is set. Since ADRIE is also set, hardware sets the Client Clock Stretching (CSTR) bit, and hardware stretches the clock to allow time for software to respond to the host device being addressed as a client. Once the address has been processed, software must clear CSTR to resume communication.\nImportant: Client hardware has priority over host hardware in Multi-Host mode. Host mode communication can only be initiated when SMA = 0 .",
    "36.4.3.1 Multi-Host Mode Clock Synchronization\nIn a multi-host system, each host may begin to generate a clock signal as soon as the bus is Idle. Clock synchronization allows all devices on the bus to use a single SCL signal.\nWhen a high-to-low transition on SCL occurs, all active host devices begin SCL low period timing, with their clocks held low until their low hold time expires and the High state is reached. If one host's clock signal is still low, SCL will be held low until that host reaches its High state. During this time, all other host devices are held in a Wait state (see Figure 36-41).\nOnce all hosts have counted off their low period times, SCL is released high, and all host devices begin counting their high periods. The first host to complete its high period pulls the SCL line low again.\nThis means that when the clocks are synchronized, the SCL low period is determined by the host with the longest SCL low period, while the SCL high period is determined by the host device with the shortest SCL high period.",
    "36.4.3.1 Multi-Host Mode Clock Synchronization\nImportant: The I 2 C Specification does not require the SCL signal to have a 50% duty cycle. In other words, one host's clock signal may have a low time that is 60% of the SCL period and a high time that is 40% of the SCL period, while another host may be 50/50. This creates a timing difference between the two clock signals, which may result in data loss.\nFirst Used:\nNotes:",
    "36.4.3.2 Multi-Host Mode Bus Arbitration\nWhen the bus is Idle, any host device may attempt to take control of the bus. Two or more host devices may issue a Start condition within the minimum hold time (THD:STA), which triggers a valid Start on the bus. The host devices must then compete using bus arbitration to determine who takes control of the bus and completes their transaction.\nBus arbitration takes place bit by bit, and it may be possible for two hosts who have identical messages to complete the entire transaction without either device losing arbitration.\nDuring every bit period, while SCL is high each host device compares the actual signal level of SDA to the signal level the host actually transmitted. SDA sampling is performed during the SCL high period because the SDA data must be stable during this period; therefore, the first host to detect a low signal level on SDA while it expects a high signal level loses arbitration. In this case, the 'losing' host device detects a bus collision and sets the Bus Collision Detect Interrupt Flag (BCLIF), and if the Bus Collision Detect Interrupt Enable (BCLIE) bit is set, the generic I2CxEIF is also set.",
    "36.4.3.2 Multi-Host Mode Bus Arbitration\nArbitration can be lost in any of the following states:\n\u00b7 Address transfer\n\u00b7 Data transfer\n\u00b7 Start condition\n\u00b7 Restart condition\n\u00b7 Acknowledge sequence\n\u00b7 Stop condition\nIf a collision occurs during the data transfer phase, the transmission is halted and both SCL and SDA are released by hardware. If a collision occurs during a Start, Restart, Acknowledge, or Stop, the operation is aborted and hardware releases SCL and SDA. If a collision occurs during the addressing phase, the host that 'wins' arbitration may be attempting to address the 'losing' host as a client. In this case, the host that lost arbitration must switch to its Client mode and check to see if an address matches.\nImportant: The I 2 C Specification states that a bus collision cannot occur during a Start condition. If a collision occurs during a Start, BCLIF will be set during the addressing phase. Filename: Bus Collision.vsdx Title: Last Edit: 1/9/2019 First Used:\nNotes:\nUser software must clear BCLIF to resume operation.\nFigure 36-42. Bus Collision\nFigure 36-43. Multi-Host Mode Transmission rota e hisp g 90",
    "36.5 Register Definitions: I C Control 2\nLong bit name prefixes for the I 2 C peripherals are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 36-3. I 2 C Long Bit Name Prefixes\n\nI2C1, Bit Name Prefix = I2C1",
    "36.5.1 I2CxCON0\nName: Address:\nI2CxCON0\n0x0294",
    "I2C Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = RSEN. , 3 = S. , 4 = CSTR. , 5 = MDR. , 6 = MODE[2:0]. , 7 = MODE[2:0]. , 8 = MODE[2:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W/HS/HC. Access, 4 = R/C/HS/HC. Access, 5 = R. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN  I2C Module Enable (1,2)\n1, Description = The I 2 C module is enabled. 0, Description = The I 2 C module is disabled",
    "Bit 6 - RSEN  Restart Enable (used only when MODE = 1xx )\n1, Description = Hardware sets MDR on 9th falling SCL edge (when I2CxCNT = 0 or ACKSTAT = 1 ). 0, Description = Hardware issues Stop condition on 9th falling SCL edge (when I2CxCNT = 0 or ACKSTAT = 1 )",
    "Bit 5 - S  Host Start (used only when MODE = 1xx )\n1, Condition = MMA= 0 :. 1, Description = Set by write to I2CxTXB or S bit, hardware issues Start condition. 0, Condition = MMA= 0 :. 0, Description = Cleared by hardware after sending Start condition. 1, Condition = MMA= 1 and MDR = 1 :. 1, Description = Set by write to I2CxTXB or S bit, communication resumes with a Restart condition. 0, Condition = MMA= 1 and MDR = 1 :. 0, Description = Cleared by hardware after sending Restart condition",
    "Bit 4 - CSTR  Client Clock Stretching (3)\n1, Condition = . 1, Description = Clock is held low (clock stretching). 0, Condition = . 0, Description = Enable clocking, SCL control is released. , Condition = SMA = 1 and RXBF = 1 (6) :. , Description = Set by hardware on 7th falling SCL edge User must read I2CxRXB and clear CSTR to release SCL. , Condition = SMA = 1 and TXBE = 1 and I2CxCNT != 0 :. , Description = Set by hardware on 8th falling SCL edge User must write to I2CxTXB and clear CSTR to release SCL. , Condition = when ADRIE = 1 (4) :. , Description = Set by hardware on 8th falling edge of matching received address User must clear CSTR to release SCL. , Condition = SMA = 1 and WRIE = 1 :. , Description = Set by hardware on 8th falling SCL edge of received data byte User must clear CSTR to release SCL. , Condition = SMA = 1 and ACKTIE = 1 :. , Description = Set by hardware on 9th falling SCL edge",
    "Bit 4 - CSTR  Client Clock Stretching (3)\nUser must clear CSTR to release SCL",
    "Bit 3 - MDR  Host Data Request (Host pause)\n1, Condition = . 1, Description = Host state machine pauses until data are read/written (SCL is held low). 0, Condition = . 0, Description = Host clocking of data is enabled. , Condition = MMA= 1 and RXBF = 1 ( pause for RX ):. , Description = Set by hardware on 7th falling SCL edge User must read I2CxRXB to release SCL. , Condition = MMA= 1 and TXBE = 1 and I2CxCNT != 0 ( pause for TX ):. , Description = Set by hardware on the 8th falling SCL edge User must write to I2CxTXB to release SCL\n, Condition = RSEN = 1 and MMA= 1 and (I2CxCNT = 0 or ACKSTAT = 1 ) ( pause for Restart ):. , Description = Set by hardware on 9th falling SCL edge User must set S bit or write to I2CxTXB to release SCL and issue a Restart condition",
    "Bits 2:0 - MODE[2:0]  I2C Mode Select\n111, Description = I 2 C Multi-Host mode (SMBus 2.0 Host) (5). 110, Description = I 2 C Multi-Host mode (SMBus 2.0 Host) (5). 101, Description = I 2 C Host mode, 10-bit address. 100, Description = I 2 C Host mode, 7-bit address. 011, Description = I 2 C Client mode, one 10-bit address with masking. 010, Description = I 2 C Client mode, two 10-bit addresses. 001, Description = I 2 C Client mode, two 7-bit addresses with masking. 000, Description = I 2 C Client mode, four 7-bit addresses",
    "Notes:\n1. SDA and SCL pins must be configured as open-drain I/Os and use either internal or external pull-up resistors.\n2. SDA and SCL signals must configure both the input and output PPS registers for each signal.\n3. CSTR can be set by multiple hardware sources; all sources must be addressed by user software before the SCL line can be released.\n4. SMA is set on the same SCL edge as CSTR for a matching received address.\n5. In this mode, ADRIE needs to be set, allowing an interrupt to clear the BCLIF condition and the ACK of a matching address.\n6. In 10-bit Client mode (when ABD = 1 ), CSTR will be set when the high address has not been read from I2CxRXB before the low address is shifted in.",
    "36.5.2 I2CxCON1\nName: Address:\nI2CxCON1\n0x0295\nI2C Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ACKCNT. , 2 = ACKDT. , 3 = ACKSTAT. , 4 = ACKT. , 5 = P. , 6 = RXO. , 7 = TXU. , 8 = CSD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R. Access, 4 = R. Access, 5 = R/S/HC. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ACKCNT  Acknowledge End of Count (2)\n1, Condition = I2CxCNT = 0. 1, Description = Not Acknowledge (NACK) copied to SDA output. 0, Condition = I2CxCNT = 0. 0, Description = Acknowledge (ACK) copied to SDA output",
    "Bit 6 - ACKDT  Acknowledge Data (1,2)\n1, Condition = Matching received address. 1, Description = Not Acknowledge (NACK) copied to SDA output. 0, Condition = Matching received address. 0, Description = Acknowledge (ACK) copied to SDA output. 1, Condition = I2CxCNT != 0. 1, Description = Not Acknowledge (NACK) copied to SDA output. 0, Condition = I2CxCNT != 0. 0, Description = Acknowledge (ACK) copied to SDA output",
    "Bit 5 - ACKSTAT  Acknowledge Status (Transmission only)\n1, Description = Acknowledge was not received for the most recent transaction. 0, Description = Acknowledge was received for the most recent transaction",
    "Bit 4 - ACKT Acknowledge Time Status\n1, Description = Indicates that the bus is in an Acknowledge sequence, set on the 8th falling SCL edge. 0, Description = Not in an Acknowledge sequence, cleared on the 9th rising SCL edge",
    "Bit 3 - P  Host Stop (4)\n1, Condition = MMA= 1. 1, Description = Initiate a Stop condition. 0, Condition = MMA= 1. 0, Description = Cleared by hardware after sending Stop",
    "Bit 2 - RXO  Receive Overflow Status (used only when MODE = 0xx or MODE = 11x ) (3)\n1, Description = Set when SMA = 1 and a host receives data when RXBF = 1. 0, Description = No client receive Overflow condition\nBit 1 - TXU  Transmit Underflow Status (used only when MODE = 0xx or MODE = 11x ) (3)\n1, Description = Set when SMA = 1 and a host transmits data when TXBE = 1. 0, Description = No client transmit Underflow condition\nBit 0 - CSD  Clock Stretching Disable (used only when MODE = 0xx or MODE = 11x )\n1, Description = When SMA = 1 , the CSTR bit will not be set. 0, Description = Client clock stretching proceeds normally",
    "Notes:\n1. Software writes to ACKDT must be followed by a minimum SDA setup time before clearing CSTR.\n2. A NACK may still be generated by hardware when bus errors are present as indicated by the I2CxSTAT1 or I2CxERR registers.\n3. This bit can only be set when CSD = 1 .\n4. If SCL is high (SCL = 1 ) when this bit is set, the current clock pulse will complete (SCL = 0 ) with the proper SCL/SDA timing required for a valid Stop condition; any data in the transmit or receive shift registers will be lost.",
    "36.5.3 I2CxCON2\nName:\nI2CxCON2\nAddress:\n0x0296",
    "I2C Control Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ACNT. , 2 = GCEN. , 3 = FME. , 4 = ABD. , 5 = SDAHT[1:0]. , 6 = SDAHT[1:0]. , 7 = BFRET[1:0]. , 8 = BFRET[1:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ACNT  Auto-Load I2C Count Register Enable\n1, Description = The first transmitted/received byte after the address is automatically loaded into the I2CxCNT register. 0, Description = Auto-load of I2CxCNT is disabled",
    "Bit 6 - GCEN  General Call Address Enable (used when MODE = 00x or MODE = 11x )\n1, Description = General Call Address (0x00) causes an address match event. 0, Description = General Call Addressing is disabled",
    "Bit 5 - FME Fast Mode Enable\n1, Description = SCL frequency (F SCL ) = F I2CxCLK /4. 0, Description = SCL frequency (F SCL ) = F I2CxCLK /5",
    "Bit 4 - ABD Address Buffer Disable\n1, Description = Address buffers are disabled. Received address is loaded into I2CxRXB, address to transmit is loaded into I2CxTXB.. 0, Description = Address buffers are enabled. Received address is loaded into I2CxADB0/I2CxADB1, address to transmit is loaded into I2CxADB0/I2CxADB1.",
    "Bits 3:2 - SDAHT[1:0] SDA Hold Time Selection\n11, Description = Reserved. 10, Description = Minimum of 30 ns hold time on SDA after the falling SCL edge. 01, Description = Minimum of 100 ns hold time on SDA after the falling SCL edge. 00, Description = Minimum of 300 ns hold time on SDA after the falling SCL edge",
    "Bits 1:0 - BFRET[1:0] Bus Free Time Selection\n11, Description = 64 I2CxCLK pulses. 10, Description = 32 I2CxCLK pulses. 01, Description = 16 I2CxCLK pulses. 00, Description = 8 I2CxCLK pulses",
    "36.5.4 I2CxSTAT0\nName:\nI2CxSTAT0\nAddress:\n0x0298\nI2C Status Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BFRE. , 2 = SMA. , 3 = MMA. , 4 = R. , 5 = D. , 6 = . , 7 = . , 8 = . Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = . Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = . Reset, 7 = . Reset, 8 = ",
    "Bit 7 - BFRE  Bus Free Status (2)\n1, Description = Indicates an Idle bus; both SCL and SDA have been high for the time selected by the BFRET bits. 0, Description = Bus is not Idle",
    "Bit 6 - SMA Client Mode Active Status\n1, Description = Client mode is active. Set after the 8th falling SCL edge of a received matching 7-bit client address. Set after the 8th falling SCL edge of a matching received 10-bit client low address. Set after the 8th falling SCL edge of a received matching 10-bit client high w/read address, only after a previous received matching high and low w/write address.. 0, Description = Client mode is not active. Cleared when any Restart/Stop condition is detected on the bus. Cleared by the BTOIF and BCLIF conditions.",
    "Bit 5 - MMA Host Mode Active Status\n1, Description = Host mode is active. Set when Host state machine asserts a Start condition.. 0, Description = Host mode is not active. Cleared when BCLIF is set. issued.. , Description = Cleared when Stop condition is. , Description = Cleared for the BTOIF condition after the host successfully shifts out a Stop condition.",
    "Bit 4 - R  Read Information (1)\n1, Description = Indicates that the last matching received address was a Read request. 0, Description = Indicates that the last matching received address was a Write request",
    "Bit 3 - D Data\n1, Description = Indicates that the last byte received or transmitted was data. 0, Description = Indicates that the last byte received or transmitted was an address",
    "Notes:\n1. This bit holds the R/W bit information following the last received address match. Addresses transmitted by the host do not affect the host's R bit, and addresses appearing on the bus without a match do not affect the R bit.\n2. I2CxCLK must have a valid clock source selected for this bit to function.",
    "36.5.5 I2CxSTAT1\nName:\nI2CxSTAT1\nAddress:\n0x0299",
    "I2C Status Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXWE. , 2 = . , 3 = TXBE. , 4 = . , 5 = RXRE. , 6 = CLRBF. , 7 = . , 8 = RXBF. Access, 1 = R/W/HS. Access, 2 = . Access, 3 = R. Access, 4 = . Access, 5 = R/W/HS. Access, 6 = R/S. Access, 7 = . Access, 8 = R. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 1. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - TXWE  Transmit Write Error Status (1)\n1, Description = A new byte of data was written into I2CxTXB when it was full ( must be cleared by software ). 0, Description = No transmit write error occurred",
    "Bit 5 - TXBE  Transmit Buffer Empty Status (2)\n1, Description = I2CxTXB is empty ( cleared by writing to the I2CxTXB register ). 0, Description = I2CxTXB is full",
    "Bit 3 - RXRE  Receive Read Error Status (1)\n1, Description = A byte of data was read from I2CxRXB when it was empty ( must be cleared by software ). 0, Description = No receive overflow occurred",
    "Bit 2 - CLRBF  Clear Buffer (3)\n1, Description = Setting this bit clears/empties the receive and transmit buffers, causing a Reset of RXBF and TXBE Setting this bit clears the I2CxRXIF and I2CxTXIF interrupt flags",
    "Bit 0 - RXBF  Receive Buffer Full Status (2)\n1, Description = I2CxRXB is full ( cleared by reading the I2CxRXB register ). 0, Description = I2CxRXB is empty",
    "Notes:\n1. This bit, when set, will cause a NACK to be issued.\n2. Used as a trigger source for DMA operations.\n3. This bit is special function; it can only be set by user software and always reads ' 0 '.",
    "36.5.6 I2CxPIR\nName: Address:\nI2CxPIR\n0x029A",
    "I2C Interrupt Flag Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CNTIF. , 2 = ACKTIF. , 3 = . , 4 = WRIF. , 5 = ADRIF. , 6 = PCIF. , 7 = RSCIF. , 8 = SCIF. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = . Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - CNTIF  Byte Count Interrupt Flag (1)\n1, Description = Set on the 9th falling SCL edge when I2CxCNT = 0. 0, Description = I2CxCNT value is not zero",
    "Bit 6 - ACKTIF  Acknowledge Status Time Interrupt Flag (used only when MODE = 0xx or MODE = 11x ) (1,2)\n1, Description = Acknowledge sequence detected, set on the 9th falling SCL edge for any byte when addressed as a client. 0, Description = Acknowledge sequence not detected",
    "Bit 4 - WRIF  Data Write Interrupt Flag (used only when MODE = 0xx or MODE = 11x ) (1)\n1, Description = Data byte detected, set on the 8th falling SCL edge for a received data byte. 0, Description = Data byte not detected",
    "Bit 3 - ADRIF  Address Interrupt Flag (used only when MODE = 0xx or MODE = 11x ) (1)\n1, Description = Address detected, set on the 8th falling SCL edge for a matching received address byte. 0, Description = Address not detected",
    "Bit 2 - PCIF  Stop Condition Interrupt Flag (1)\n1, Description = Stop condition detected. 0, Description = Stop condition not detected",
    "Bit 1 - RSCIF  Restart Condition Interrupt Flag (1)\n1, Description = Restart condition detected. 0, Description = Restart condition not detected",
    "Bit 0 - SCIF  Start Condition Interrupt Flag (1)\n1, Description = Start condition detected. 0, Description = Start condition not detected",
    "Notes:\n1. Enabled interrupt flags are OR'ed to produce the PIRx[I2CxIF] bit.\n2. ACKTIF is not set by a matching 10-bit high address byte with the R/W bit clear. It is only set after the matching low address byte is shifted in.",
    "36.5.7 I2CxPIE\nName: Address:\nI2CxPIE\n0x029B",
    "I2C Interrupt and Hold Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CNTIE. , 2 = ACKTIE. , 3 = . , 4 = WRIE. , 5 = ADRIE. , 6 = PCIE. , 7 = RSCIE. , 8 = SCIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - CNTIE  Byte Count Interrupt Enable (1)\n1, Description = Enables Byte Count interrupts. 0, Description = Disables Byte Count interrupts",
    "Bit 6 - ACKTIE  Acknowledge Status Time Interrupt and Hold Enable (1,2)\n1, Description = Enables Acknowledge Status Time Interrupt and Hold condition. 0, Description = Disables Acknowledge Status Time Interrupt and Hold condition",
    "Bit 4 - WRIE  Data Write Interrupt and Hold Enable (1,3)\n1, Description = Enables Data Write Interrupt and Hold condition. 0, Description = Disables Data Write Interrupt and Hold condition",
    "Bit 3 - ADRIE  Address Interrupt and Hold Enable (1,4)\n1, Description = Enables Address Interrupt and Hold condition. 0, Description = Disables Address Interrupt and Hold condition",
    "Bit 2 - PCIE  Stop Condition Interrupt Enable (1)\n1, Description = Enables interrupt on the detection of a Stop condition. 0, Description = Disables interrupt on the detection of a Stop condition",
    "Bit 1 - RSCIE  Restart Condition Interrupt Enable (1)\n1, Description = Enables interrupt on the detection of a Restart condition. 0, Description = Disables interrupt on the detection of a Restart condition",
    "Bit 0 - SCIE  Stop Condition Interrupt Enable (1)\n1, Description = Enables interrupt on the detection of a Start condition. 0, Description = Disables interrupt on the detection of a Start condition",
    "Notes:\n1. Enabled interrupt flags are OR'ed to produce the PIRx[I2CxIF] bit.\n2. When ACKTIE is set (ACKTIE = 1 ) and ACKTIF becomes set (ACKTIF = 1 ), if an ACK is generated, CSTR is also set. If a NACK is generated, CSTR remains unchanged.\n3. When WRIE is set (WRIE = 1 ) and WRIF becomes set (WRIF = 1 ), CSTR is also set.\n4. When ADRIE is set (ADRIE = 1 ) and ADRIF becomes set (ADRIF = 1 ), CSTR is also set.",
    "36.5.8 I2CxERR\nName:\nI2CxERR\nAddress:\n0x0297",
    "I2C Error Register\nBit, 1 = 7 6. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = BTOIF. , 2 = BCLIF. , 3 = NACKIF. , 4 = . , 5 = BTOIE. , 6 = BLCIE. , 7 = NACKIE. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 6 - BTOIF  Bus Time-Out Interrupt Flag (1,2)\n1, Description = Bus time-out event occurred. 0, Description = No bus time-out event occurred",
    "Bit 5 - BCLIF  Bus Collision Detect Interrupt Flag (1)\n1, Description = Bus collision detected. 0, Description = No bus collision occurred",
    "Bit 4 - NACKIF  NACK Detect Interrupt Flag (1,3,4)\n1, Description = NACK detected on the bus (when SMA = 1 or MMA= 1 ). 0, Description = No NACK detected on the bus",
    "Bit 2 - BTOIE Bus Time-Out Interrupt Enable\n1, Description = Enable bus time-out interrupts. 0, Description = Disable bus time-out interrupts",
    "Bit 1 - BLCIE Bus Collision Detect Interrupt Enable\n1, Description = Enable Bus Collision interrupts. 0, Description = Disable Bus Collision interrupts",
    "Bit 0 - NACKIE NACK Detect Interrupt Enable\n1, Description = Enable NACK detect interrupts. 0, Description = Disable NACK detect interrupts",
    "Notes:\n1. Enabled error interrupt flags are OR'ed to produce the PIRx[I2CxEIF] bit.\n2. User software must select the bus time-out source in the I2CxBTOC register.\n3. NACKIF is also set when any of the TXWE, RXRE, TXU, or RXO bits are set.\n4. NACKIF is not set for the NACK response to a nonmatching client address.",
    "36.5.9 I2CxCLK\nName:\nI2CxCLK\nAddress:\n0x029E\nI2C Clock Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CLK[3:0]. , 6 = CLK[3:0]. , 7 = CLK[3:0]. , 8 = CLK[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - CLK[3:0] I2C Clock Selection\nTable 36-4.\n\n1111 - 1110, Selection = Reserved. 1101, Selection = CLC4_OUT. 1100, Selection = CLC3_OUT. 1011, Selection = CLC2_OUT. 1010, Selection = CLC1_OUT. 1001, Selection = SMT1_OUT. 1000, Selection = TMR4_Postscaler_OUT. 0111, Selection = TMR2_Postscaler_OUT. 0110, Selection = TMR0_OUT. 0101, Selection = EXTOSC. 0100, Selection = Clock Reference Output. 0011, Selection = MFINTOSC (500 kHz). 0010, Selection = HFINTOSC. 0001, Selection = F OSC (System Clock). 0000, Selection = F OSC /4",
    "36.5.10  I2CxBAUD\nName: Address:\nI2CxBAUD\n0x029D\nI2C Baud Rate Prescaler",
    "36.5.10  I2CxBAUD\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BAUD[7:0]. , 2 = BAUD[7:0]. , 3 = BAUD[7:0]. , 4 = BAUD[7:0]. , 5 = BAUD[7:0]. , 6 = BAUD[7:0]. , 7 = BAUD[7:0]. , 8 = BAUD[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8",
    "36.5.10  I2CxBAUD\n= 0",
    "Bits 7:0 - BAUD[7:0] Baud Rate Prescaler Selection\nn, Description = Prescaled I2C Clock Frequency (F PRECLK ) =\nI\n2\nCxCLK\nNote: It is recommended to write this register only when the module is Idle (MMA = 0 or SMA = 0 ) or when the module is clock stretching (CSTR = 1 or MDR = 1 ).\nBAUD\n+ 1",
    "36.5.11  I2CxCNT\nName: Address:\nI2CxCNT\n0x028C",
    "I2C Byte Count Register (1,2)\nAccess, 15.CNT[15:8] = R/W. Access, 14.CNT[15:8] = R/W. Access, 13.CNT[15:8] = R/W. Access, 12.CNT[15:8] = R/W. Access, 11.CNT[15:8] = R/W. Access, 10.CNT[15:8] = R/W. Access, 9.CNT[15:8] = R/W. Access, 8.CNT[15:8] = R/W. Reset, 15.CNT[15:8] = 0. Reset, 14.CNT[15:8] = 0. Reset, 13.CNT[15:8] = 0. Reset, 12.CNT[15:8] = 0. Reset, 11.CNT[15:8] = 0. Reset, 10.CNT[15:8] = 0. Reset, 9.CNT[15:8] = 0. Reset, 8.CNT[15:8] = 0. Bit,",
    "I2C Byte Count Register (1,2)\n15.CNT[15:8] = 7. Bit, 14.CNT[15:8] = 6. Bit, 13.CNT[15:8] = 5. Bit, 12.CNT[15:8] = 4. Bit, 11.CNT[15:8] = 3. Bit, 10.CNT[15:8] = 2. Bit, 9.CNT[15:8] = 1. Bit, 8.CNT[15:8] = 0. , 15.CNT[15:8] = CNT[7:0]. , 14.CNT[15:8] = CNT[7:0]. , 13.CNT[15:8] = CNT[7:0]. , 12.CNT[15:8] = CNT[7:0]. , 11.CNT[15:8] = CNT[7:0]. , 10.CNT[15:8] = CNT[7:0]. , 9.CNT[15:8] = CNT[7:0]. ,",
    "I2C Byte Count Register (1,2)\n8.CNT[15:8] = CNT[7:0]. Access, 15.CNT[15:8] = R/W. Access, 14.CNT[15:8] = R/W. Access, 13.CNT[15:8] = R/W. Access, 12.CNT[15:8] = R/W. Access, 11.CNT[15:8] = R/W. Access, 10.CNT[15:8] = R/W. Access, 9.CNT[15:8] = R/W. Access, 8.CNT[15:8] = R/W. Reset, 15.CNT[15:8] = 0. Reset, 14.CNT[15:8] = 0. Reset, 13.CNT[15:8] = 0. Reset, 12.CNT[15:8] = 0. Reset, 11.CNT[15:8] = 0. Reset, 10.CNT[15:8] = 0. Reset, 9.CNT[15:8] = 0.",
    "I2C Byte Count Register (1,2)\nReset, 8.CNT[15:8] = 0",
    "Bits 15:0 - CNT[15:0] Byte Count\nIf receiving data:, Description = Count value decremented on 8th falling SCL edge when a new byte is loaded into I2CxRXB. If transmitting data:, Description = Count value is decremented on the 9th falling SCL edge when a new byte is moved from I2CxTXB",
    "Notes:\n1. It is recommended to write this register only when the module is Idle (MMA = 0 or SMA = 0 ) or when the module is clock stretching (CSTR = 1 or MDR = 1 ).\n2. CNTIF is set on the 9th falling SCL edge when I2CxCNT = 0 .",
    "36.5.12  I2CxBTO\nName: Address:\nI2CxBTO\n0x029C",
    "I2C Bus Time-Out Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TOREC. , 2 = TOBY32. , 3 = TOTIME[5:0]. , 4 = TOTIME[5:0]. , 5 = TOTIME[5:0]. , 6 = TOTIME[5:0]. , 7 = TOTIME[5:0]. , 8 = TOTIME[5:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - TOREC Time-Out Recovery Selection\n1, Description = A BTO event will reset the I2C module and set BTOIF. 0, Description = A BTO event will set BTOIF, but will not reset the I2C module",
    "Bit 6 - TOBY32  Time-Out Prescaler Extension Enable (2)\n1, Description = BTO time = TOTIME * T BTOCLK. 0, Description = BTO time = TOTIME * T BTOCLK * 32",
    "Bits 5:0 - TOTIME[5:0] Time-Out Time Selection\nn, Condition Description = TOBY32 = 1 Time-out is TOTIME periods of the prescaled BTO clock (TOTIME = n * T BTOCLK. n, Condition Description = TOBY32 = 0 Time-out is TOTIME periods of the prescaled BTO clock multiplied by 32 (TOTIME = n * T BTOCLK * 32)",
    "Notes:\n1. It is recommended to write this register only when the module is Idle (MMA = 0 or SMA = 0 ) or when the module is clock stretching (CSTR = 1 or MDR = 1 ).\n2. When TOBY32 is set (TOBY32 = 1 ) and the LFINTOSC, MFINTOSC, or SOSC is selected as the BTO clock source, the time-out time (TOTIME) will be approximately in milliseconds.",
    "36.5.13  I2CxBTOC\nName:\nI2CxBTOC\nAddress:\n0x029F\nI2C Bus Time-Out Clock Source Selection\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nBTOC[2:0]\nAccess Reset\nR/W\nR/W\nR/W\n0\n0\n0\nBits 2:0 - BTOC[2:0] Bus Time-Out Clock Source Selection\nTable 36-5.\n\n111, Selection = Reserved. 110, Selection = Reserved. 101, Selection = SOSC. 100, Selection = MFINTOSC (32 kHz). 011, Selection = LFINTOSC. 010, Selection = TMR4_postscaled. 001, Selection = TMR2_postscaled. 000, Selection = Reserved",
    "36.5.14  [I2CxADB0]\nName:\nI2CxADB0\nAddress:\n0x028E\nI2C Address Buffer 0 Register (1)",
    "36.5.14  [I2CxADB0]\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADB[7:0]. , 2 = ADB[7:0]. , 3 = ADB[7:0]. , 4 = ADB[7:0]. , 5 = ADB[7:0]. , 6 = ADB[7:0]. , 7 = ADB[7:0]. , 8 = ADB[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0.",
    "36.5.14  [I2CxADB0]\nReset, 8 = 0",
    "Bits 7:0 - ADB[7:0]  I2C Address Buffer 0\n7-bit Client/Multi-Host modes ( MODE = 00x or 11x ) :, Description = ADB[7:1]: Received matching 7-bit client address ADB[0]: Received R/W value from 7-bit address. 10-bit Client modes ( MODE = 01x ) :, Description = ADB[7:0]: Received matching lower eight bits of 10-bit client address. 7-bit Host mode ( MODE = 100 ) :, Description = Unused in this mode. 10-bit Host mode ( MODE = 101 ) :, Description = ADB[7:0]: Eight Least Significant bits of the 10-bit client address",
    "Note:\n- 1. This register is read-only except in Host 10-bit Address mode (MODE = 101 ) .",
    "36.5.15  I2CxADB1\nName: Address:\nI2CxADB1\n0x028F\nI2C Address Buffer 1 Register (1)",
    "36.5.15  I2CxADB1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADB[7:0]. , 2 = ADB[7:0]. , 3 = ADB[7:0]. , 4 = ADB[7:0]. , 5 = ADB[7:0]. , 6 = ADB[7:0]. , 7 = ADB[7:0]. , 8 = ADB[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8",
    "36.5.15  I2CxADB1\n= 0",
    "Bits 7:0 - ADB[7:0] I2C Address Buffer 1\n7-bit Client modes ( MODE = 00x ) :, Description = Unused in this mode. 10-bit Client modes ( MODE = 01x ) :, Description = ADB[7:1]: Received matching 10-bit client address high byte ADB[0]: Received R/W value from 10-bit high address byte. 7-bit Host mode ( MODE = 100 ) :, Description = ADB[7:1]: 7-bit client address ADB[0]: R/W value. 10-bit Host mode ( MODE = 101 ) :, Description = ADB[7:1]: 10-bit client high address byte ADB[0]: R/W value. 7-bit Multi-Host modes ( MODE = 11x ) :, Description = ADB[7:1]: 7-bit client address ADB[0]: R/W value",
    "Note:\n- 1. This register is read-only in 7-bit Client Address modes (MODE = 0xx ) .",
    "36.5.16  I2CxADR0\nName:\nI2CxADR0\nAddress:\n0x0290\nI2C Address 0 Register",
    "36.5.16  I2CxADR0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADR[7:0]. , 2 = ADR[7:0]. , 3 = ADR[7:0]. , 4 = ADR[7:0]. , 5 = ADR[7:0]. , 6 = ADR[7:0]. , 7 = ADR[7:0]. , 8 = ADR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8",
    "36.5.16  I2CxADR0\n= 1",
    "Bits 7:0 - ADR[7:0]  I2C Client Address 0\n7-bit Client/Multi-Host modes ( MODE = 00x or 11x ) :, Description = ADR[7:1]: 7-bit client address ADR[0]: Unused; bit state is 'don't care'. 10-bit Client modes ( MODE = 01x ) :, Description = ADR[7:0]: Eight Least Significant bits of first 10-bit address",
    "36.5.17  I2CxADR1\nName:\nI2CxADR1\nAddress:\n0x0291\nI2C Address 1 Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = ADR[6:0]. , 5 = . , 6 = . , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = . Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = ",
    "Bits 7:1 - ADR[6:0]  I2C Client Address 1\n7-bit Client/Multi-Host modes ( MODE = 000 or 110 ) :, Description = 7-bit client address 1. 7-bit Client/Multi-Host modes with Masking ( MODE = 011 or 111 ) :, Description = 7-bit client address mask for I2CxADR0. 10-bit Client mode ( MODE = 010 ) :, Description = ADR[7:3]: Bit pattern ( 11110 ) as defined by the I 2 C Specification (1) ADR[2:1]: Two Most Significant bits of first 10-bit address. 10-bit Client mode with Masking ( MODE = 011 ) :, Description = ADR[7:3]: Bit pattern ( 11110 ) as defined by the I 2 C Specification (1) ADR[2:1]: Two Most Significant bits of 10-bit address",
    "Note:\n- 1. The ' 11110 ' bit pattern used in the 10-bit address high byte is defined by the I 2 C Specification. It is up to the user to define these bits. These bit values are compared to the received address by hardware to determine a match. The bit pattern transmitted by the host must be the same as the client address's bit pattern used for comparison or a match will not occur.",
    "36.5.18  I2CxADR2\nName:\nI2CxADR2\nAddress:\n0x0292\nI2C Address 2 Register",
    "36.5.18  I2CxADR2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADR[7:0]. , 2 = ADR[7:0]. , 3 = ADR[7:0]. , 4 = ADR[7:0]. , 5 = ADR[7:0]. , 6 = ADR[7:0]. , 7 = ADR[7:0]. , 8 = ADR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8",
    "36.5.18  I2CxADR2\n= 1",
    "Bits 7:0 - ADR[7:0]  I2C Client Address 2\n7-bit Client/Multi-Host modes ( MODE = 000 or 110 ) :, Description = ADR[7:1]: 7-bit client address 2 ADR[0]: Unused; bit state is 'don't care'. 7-bit Client/Multi-Host modes with Masking ( MODE = 001 or 111 ) :, Description = ADR[7:1]: 7-bit client address ADR[0]: Unused; bit state is 'don't care'. 10-bit Client mode ( MODE = 010 ) :, Description = ADR[7:0]: Eight Least Significant bits of the second 10-bit address. 10-bit Client mode with Masking ( MODE = 011 ) :, Description = ADR[7:0]: Eight Least Significant bits of 10-bit address mask",
    "36.5.19  I2CxADR3\nName:\nI2CxADR3\nAddress:\n0x0293\nI2C Address 3 Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = ADR[6:0]. , 5 = . , 6 = . , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = . Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = ",
    "Bits 7:1 - ADR[6:0]  I2C Client Address 3\n7-bit Client/Multi-Host modes ( MODE = 000 or 110 ) :, Description = 7-bit client address 3. 7-bit Client/Multi-Host modes with Masking ( MODE = 001 or 111 ) :, Description = 7-bit client address mask for I2CxADR2. 10-bit Client mode ( MODE = 010 ) :, Description = ADR[7:3]: Bit pattern ( 11110 ) as defined by the I 2 C Specification (1) ADR[2:1]: Two Most Significant bits of second 10-bit address. 10-bit Client mode with Masking ( MODE = 011 ) :, Description = ADR[7:3]: Bit pattern ( 11110 ) as defined by the I 2 C Specification (1) ADR[2:1]: Two Most Significant bits of 10-bit address mask",
    "Note:\n- 1. The ' 11110 ' bit pattern used in the 10-bit address high byte is defined by the I 2 C Specification. It is up to the user to define these bits. These bit values are compared to the received address by hardware to determine a match. The bit pattern transmitted by the host must be the same as the client address's bit pattern used for comparison or a match will not occur.",
    "36.5.20  I2CxTXB\nName: Address:\nI2CxTXB\n0x028B",
    "I2C Transmit Buffer Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXB[7:0]. , 2 = TXB[7:0]. , 3 = TXB[7:0]. , 4 = TXB[7:0]. , 5 = TXB[7:0]. , 6 = TXB[7:0]. , 7 = TXB[7:0]. , 8 = TXB[7:0]. Access, 1 = W. Access, 2 = W. Access, 3 = W. Access, 4 = W. Access, 5 = W. Access, 6 = W. Access, 7 = W. Access, 8 = W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 7:0 - TXB[7:0] I2C Transmit Buffer\nNote: This register is write-only. Reading this register will return a value of 0x00 .",
    "36.5.21  I2CxRXB\nName: Address:\nI2CxRXB\n0x028A\nI2C Receive Buffer (1)",
    "36.5.21  I2CxRXB\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RXB[7:0]. , 2 = RXB[7:0]. , 3 = RXB[7:0]. , 4 = RXB[7:0]. , 5 = RXB[7:0]. , 6 = RXB[7:0]. , 7 = RXB[7:0]. , 8 = RXB[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 7:0 - RXB[7:0] I2C Receive Buffer\nNote: This register is read-only. Writes to this register are ignored.",
    "36.6 Register Summary - I2C\n0x00 ... 0x0289, Name = Reserved. 0x00 ... 0x0289, Bit Pos. = . 0x00 ... 0x0289, 7 = . 0x00 ... 0x0289, 6 = . 0x00 ... 0x0289, 5 = . 0x00 ... 0x0289, 4 = . 0x00 ... 0x0289, 3 = . 0x00 ... 0x0289, 2 = . 0x00 ... 0x0289, 1 = . 0x00 ... 0x0289, 0 = . 0x028A, Name = I2C1RXB. 0x028A, Bit Pos. = 7:0. 0x028A, 7 = . 0x028A, 6 = . 0x028A, 5 = . 0x028A, 4 = RXB[7:0]. 0x028A, 3 = RXB[7:0].",
    "36.6 Register Summary - I2C\n0x028A, 2 = . 0x028A, 1 = . 0x028A, 0 = . 0x028B, Name = I2C1TXB. 0x028B, Bit Pos. = 7:0. 0x028B, 7 = . 0x028B, 6 = . 0x028B, 5 = . 0x028B, 4 = TXB[7:0]. 0x028B, 3 = TXB[7:0]. 0x028B, 2 = . 0x028B, 1 = . 0x028B, 0 = . 0x028C, Name = I2C1CNT. 0x028C, Bit Pos. = 7:0. 0x028C, 7 = . 0x028C, 6 = . 0x028C, 5 = . 0x028C, 4 = CNT[7:0]. 0x028C, 3 = CNT[7:0]. 0x028C, 2 = .",
    "36.6 Register Summary - I2C\n0x028C, 1 = . 0x028C, 0 = . 0x028C, Name = I2C1CNT. 0x028C, Bit Pos. = . 0x028C, 7 = 15:8. 0x028C, 6 = 15:8. 0x028C, 5 = 15:8. 0x028C, 4 = CNT[15:8]. 0x028C, 3 = CNT[15:8]. 0x028C, 2 = . 0x028C, 1 = . 0x028C, 0 = . 0x028E, Name = I2C1ADB0. 0x028E, Bit Pos. = . 0x028E, 7 = 7:0. 0x028E, 6 = 7:0. 0x028E, 5 = 7:0. 0x028E, 4 = ADB[7:0]. 0x028E, 3 = ADB[7:0]. 0x028E, 2 = .",
    "36.6 Register Summary - I2C\n0x028E, 1 = . 0x028E, 0 = . 0x028F, Name = I2C1ADB1. 0x028F, Bit Pos. = . 0x028F, 7 = 7:0. 0x028F, 6 = 7:0. 0x028F, 5 = 7:0. 0x028F, 4 = ADB[7:0]. 0x028F, 3 = ADB[7:0]. 0x028F, 2 = . 0x028F, 1 = . 0x028F, 0 = . 0x0290, Name = I2C1ADR0. 0x0290, Bit Pos. = . 0x0290, 7 = 7:0. 0x0290, 6 = 7:0. 0x0290, 5 = 7:0. 0x0290, 4 = ADR[7:0]. 0x0290, 3 = ADR[7:0]. 0x0290, 2 = .",
    "36.6 Register Summary - I2C\n0x0290, 1 = . 0x0290, 0 = . 0x0291, Name = I2C1ADR1. 0x0291, Bit Pos. = . 0x0291, 7 = 7:0. 0x0291, 6 = 7:0. 0x0291, 5 = 7:0. 0x0291, 4 = ADR[6:0]. 0x0291, 3 = ADR[6:0]. 0x0291, 2 = . 0x0291, 1 = . 0x0291, 0 = . 0x0292, Name = I2C1ADR2. 0x0292, Bit Pos. = . 0x0292, 7 = 7:0. 0x0292, 6 = 7:0. 0x0292, 5 = 7:0. 0x0292, 4 = ADR[7:0]. 0x0292, 3 = ADR[7:0]. 0x0292, 2 = .",
    "36.6 Register Summary - I2C\n0x0292, 1 = . 0x0292, 0 = . 0x0293, Name = I2C1ADR3. 0x0293, Bit Pos. = . 0x0293, 7 = 7:0. 0x0293, 6 = 7:0. 0x0293, 5 = 7:0. 0x0293, 4 = ADR[6:0]. 0x0293, 3 = ADR[6:0]. 0x0293, 2 = . 0x0293, 1 = . 0x0293, 0 = . 0x0294, Name = I2C1CON0. 0x0294, Bit Pos. = 7:0. 0x0294, 7 = EN. 0x0294, 6 = RSEN. 0x0294, 5 = S. 0x0294, 4 = CSTR. 0x0294, 3 = MDR. 0x0294, 2 = MODE[2:0]. 0x0294, 1 =",
    "36.6 Register Summary - I2C\nMODE[2:0]. 0x0294, 0 = MODE[2:0]. 0x0295, Name = I2C1CON1. 0x0295, Bit Pos. = 7:0. 0x0295, 7 = ACKCNT. 0x0295, 6 = ACKDT. 0x0295, 5 = ACKSTAT. 0x0295, 4 = ACKT. 0x0295, 3 = P. 0x0295, 2 = RXO. 0x0295, 1 = TXU. 0x0295, 0 = CSD. 0x0296, Name = I2C1CON2. 0x0296, Bit Pos. = 7:0. 0x0296, 7 = ACNT. 0x0296, 6 = GCEN. 0x0296, 5 = FME. 0x0296, 4 = ABD. 0x0296, 3 = SDAHT[1:0]. 0x0296, 2 =",
    "36.6 Register Summary - I2C\nSDAHT[1:0]. 0x0296, 1 = BFRET[1:0]. 0x0296, 0 = BFRET[1:0]. 0x0297, Name = I2C1ERR. 0x0297, Bit Pos. = 7:0. 0x0297, 7 = . 0x0297, 6 = BTOIF. 0x0297, 5 = BCLIF. 0x0297, 4 = NACKIF. 0x0297, 3 = . 0x0297, 2 = BTOIE. 0x0297, 1 = BLCIE. 0x0297, 0 = NACKIE. 0x0298, Name = I2C1STAT0. 0x0298, Bit Pos. = 7:0. 0x0298, 7 = BFRE. 0x0298, 6 = SMA. 0x0298, 5 = MMA. 0x0298, 4 = R. 0x0298, 3 = D.",
    "36.6 Register Summary - I2C\n0x0298, 2 = . 0x0298, 1 = . 0x0298, 0 = . 0x0299, Name = I2C1STAT1. 0x0299, Bit Pos. = 7:0. 0x0299, 7 = TXWE. 0x0299, 6 = . 0x0299, 5 = TXBE. 0x0299, 4 = . 0x0299, 3 = RXRE. 0x0299, 2 = CLRBF. 0x0299, 1 = . 0x0299, 0 = RXBF. 0x029A, Name = I2C1PIR. 0x029A, Bit Pos. = 7:0. 0x029A, 7 = CNTIF. 0x029A, 6 = ACKTIF. 0x029A, 5 = . 0x029A, 4 = WRIF. 0x029A, 3 = ADRIF. 0x029A, 2 = PCIF. 0x029A, 1",
    "36.6 Register Summary - I2C\n= RSCIF. 0x029A, 0 = SCIF. 0x029B, Name = I2C1PIE. 0x029B, Bit Pos. = 7:0. 0x029B, 7 = CNTIE. 0x029B, 6 = ACKTIE. 0x029B, 5 = . 0x029B, 4 = WRIE. 0x029B, 3 = ADRIE. 0x029B, 2 = PCIE. 0x029B, 1 = RSCIE. 0x029B, 0 = SCIE. 0x029C, Name = I2C1BTO. 0x029C, Bit Pos. = 7:0. 0x029C, 7 = TOREC. 0x029C, 6 = TOBY32. 0x029C, 5 = . 0x029C, 4 = TOTIME[5:0]. 0x029C, 3 = TOTIME[5:0]. 0x029C, 2 = TOTIME[5:0]. 0x029C,",
    "36.6 Register Summary - I2C\n1 = TOTIME[5:0]. 0x029C, 0 = TOTIME[5:0]. , Name = I2C1BAUD. , Bit Pos. = 7:0. , 7 = 0x029D BAUD[7:0]. , 6 = 0x029D BAUD[7:0]. , 5 = 0x029D BAUD[7:0]. , 4 = 0x029D BAUD[7:0]. , 3 = 0x029D BAUD[7:0]. , 2 = 0x029D BAUD[7:0]. , 1 = 0x029D BAUD[7:0]. , 0 = 0x029D BAUD[7:0]. 0x029E, Name = I2C1CLK. 0x029E, Bit Pos. = 7:0. 0x029E, 7 = . 0x029E, 6 = . 0x029E, 5 = . 0x029E, 4 = . 0x029E, 3",
    "36.6 Register Summary - I2C\n= . 0x029E, 2 = CLK[3:0]. 0x029E, 1 = . 0x029E, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = 0x029F I2C1BTOC. , 6 = 0x029F I2C1BTOC. , 5 = 0x029F I2C1BTOC. , 4 = 0x029F I2C1BTOC. , 3 = 0x029F I2C1BTOC. , 2 = 0x029F I2C1BTOC. , 1 = BTOC[2:0]. , 0 = 0x029F I2C1BTOC",
    "37. HLVD - High/Low-Voltage Detect\nThe HLVD module can be configured to monitor the device voltage. This is useful in battery monitoring applications. Complete control of the HLVD module is provided through the HLVDCON0 and HLVDCON1 registers.\nRefer to the figure below for a simplified block diagram of the HLVD module.\nFigure 37-1. HLVD Module Block Diagram\nSince the HLVD can be software enabled through the EN bit, setting and clearing the enable bit does not produce a false HLVD event glitch. Each time the HLVD module is enabled, the RDY bit can be used to detect when the module is stable and ready to use.\nThe INTH and INTL bits determine the overall operation of the module. When INTH is set, the module monitors for rises in VDD above the trip point set by the bits. When INTL is set, the module monitors for drops in VDD below the trip point set by the SEL bits. When both the INTH and INTL bits are set, any changes above or below the trip point set by the SEL bits can be monitored.",
    "37. HLVD - High/Low-Voltage Detect\nThe OUT bit can be read to determine if the voltage is greater than or less than the selected trip point.",
    "37.1 Operation\nWhen the HLVD module is enabled, a comparator uses an internally generated voltage reference as the set point. The set point is compared with the trip point, where each node in the resistor divider represents a trip point voltage. The 'trip point' voltage is the voltage level at which the device detects a high- or low-voltage event, depending on the configuration of the module.\nWhen the supply voltage is equal to the trip point, the voltage tapped off of the resistor array is equal to the internal reference voltage generated by the voltage reference module. The comparator then generates an interrupt signal by setting the HLVDIF bit.\nThe trip point voltage is software programmable using the SEL bits.",
    "37.2 Setup\nTo set up the HLVD module:\n1. Select the desired HLVD trip point by writing the value to the SEL bits.\n2. Depending on the application to detect high-voltage peaks or low-voltage drops or both, set the INTH or INTL bit appropriately.\n3. Enable the HLVD module by setting the EN bit.\n4. Clear the HLVD Interrupt Flag (HLVDIF), which may have been set from a previous interrupt.\n5. If interrupts are desired, enable the HLVD interrupt by setting the HLVDIE and GIE bits. An interrupt will not be generated until the RDY bit is set.\nImportant: Before changing any module settings (interrupts and tripping point), first disable the module (EN = 0 ), make the changes and re-enable the module. This prevents the generation of false HLVD events.",
    "37.3 Current Consumption\nWhen the module is enabled, the HLVD comparator and voltage divider are enabled and consume static current. The total current consumption, when enabled, is specified in the 'Electrical Specifications' chapter.\nDepending on the application, the HLVD module does not need to operate constantly. To reduce the current consumption, the module can be disabled when not in use. Refer to the 'PMD - Peripheral Module Disable' chapter for more details.",
    "37.4 HLVD Start-Up Time\nIf the HLVD or other circuits using the internal voltage reference are disabled to lower the device's current consumption, the reference voltage circuit will require time to become stable before a Lowor High-Voltage condition can be reliably detected. This start-up time, T FVRST , is an interval that is independent of device clock speed. It is specified in the 'Electrical Specifications' chapter of the device specific data sheet.\nThe HLVD interrupt flag is not enabled until T FVRST has expired and a stable reference voltage is reached. For this reason, brief excursions beyond the set point may not be detected during this interval (see the figures below).",
    "Figure 37-2. Low-Voltage Detect Operation (INTL = 1 )\nRev. 30-000141A\n5/26/2017\nHLVDIF Cleared in Software,\nHLVDIF Remains Set since HLVD Condition still Exists",
    "Figure 37-3. High-Voltage Detect Operation (INTH = 1 )\nRev. 30-000142A\n5/26/2017\nHLVDIF Cleared in Software,\nHLVDIF Remains Set since HLVD Condition still Exists",
    "37.5 Applications\nIn many applications, it is desirable to detect a drop below or rise above a particular voltage threshold. For example, the HLVD module can be periodically enabled to detect Universal Serial Bus (USB) attach or detach. This assumes the device is powered by a lower voltage source than the USB when detached. An attach indicates a High-Voltage Detect from, for example, 3.3V to 5V (the voltage on USB) and vice versa for a detach. This feature can save a design a few extra components and an attach signal (input pin).\nFor general battery applications, the figure below shows a possible voltage curve. Over time, the device voltage decreases. When the device voltage reaches voltage, VA, the HLVD logic generates an interrupt at time, T A. The interrupt can cause the execution of an Interrupt Service Routine (ISR), which will allow the application to perform 'housekeeping tasks' and a controlled shutdown before the device voltage exits the valid operating range at T B. This will give the application a time window, represented by the difference between TA and TB, to safely exit.",
    "Figure 37-4. Typical Low-Voltage Detect Application\nTime\nRev. 30-000143A\n5/26/2017\nVA = HLVD trip point VB = Minimum valid device operating voltage Legend:",
    "37.6 Operation During Sleep\nWhen enabled, the HLVD circuitry continues to operate during Sleep. When the device voltage crosses the trip point, the HLVDIF bit will be set and the device will wake up from Sleep. If interrupts are enabled, the device will execute code from the interrupt vector. If interrupts are disabled, the device will continue execution from the next instruction after SLEEP .",
    "37.7 Operation During Idle and Doze Modes\nThe performance of the module is independent of the Idle and Doze modes. The module will generate the events based on the trip points. The response to these events will depend on the Doze and Idle mode settings.",
    "37.8 Effects of a Reset\nA device Reset forces all registers to their Reset state. This forces the HLVD module to be turned off. User firmware has to configure the module again.",
    "37.9 Register Definitions: HLVD Control\nLong bit name prefixes for the HLVD peripheral are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bits Naming Conventions' chapter for more information.\nTable 37-1. HLVD Long Bit Name Prefixes\n\nHLVD, Bit Name Prefix = HLVD",
    "37.9.1 HLVDCON0\nName:\nHLVDCON0\nAddress:\n0x04A",
    "High/Low-Voltage Detect Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = RDY. , 5 = . , 6 = . , 7 = INTH. , 8 = INTL. Access, 1 = R/W. Access, 2 = . Access, 3 = R. Access, 4 = R. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = x. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN High/Low-Voltage Detect Power Enable\n1, Description = Enables the HLVD module. 0, Description = Disables the HLVD module",
    "Bit 5 - OUT HLVD Comparator Output\n1, Description = Voltage < selected detection limit (SEL). 0, Description = Voltage > selected detection limit (SEL)",
    "Bit 4 - RDY Band Gap Reference Voltages Stable Status Flag\n1, Description = Indicates HLVD Module is ready and output is stable. 0, Description = Indicates HLVD Module is not ready",
    "Bit 1 - INTH HLVD Positive going (High-Voltage) Interrupt Enable\n1, Description = HLVDIF will be set when voltage \u2265 selected detection limit (SEL). 0, Description = HLVDIF will not be set",
    "Bit 0 - INTL HLVD Negative going (Low-Voltage) Interrupt Enable\n1, Description = HLVDIF will be set when voltage \u2264 selected detection limit (SEL). 0, Description = HLVDIF will not be set",
    "37.9.2 HLVDCON1\nName:\nHLVDCON1\nAddress:\n0x04B\nLow-Voltage Detect Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = SEL[3:0]. , 6 = SEL[3:0]. , 7 = SEL[3:0]. , 8 = SEL[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 3:0 - SEL[3:0] High/Low-Voltage Detection Limit Selection",
    "37.9.2 HLVDCON1\nRefer to the 'High/Low-Voltage Detect Characteristic' table in the 'Electrical Specifications' chapter for more details about the voltage detection limit selection.\nReset States: POR/BOR = 0000\nAll other Resets = uuuu",
    "37.10 Register Summary - HLVD\n0x00 ... 0x49, Name = Reserved. 0x00 ... 0x49, Bit Pos. = . 0x00 ... 0x49, 7 = . 0x00 ... 0x49, 6 = . 0x00 ... 0x49, 5 = . 0x00 ... 0x49, 4 = . 0x00 ... 0x49, 3 = . 0x00 ... 0x49, 2 = . 0x00 ... 0x49, 1 = . 0x00 ... 0x49, 0 = . 0x4A, Name = HLVDCON0. 0x4A, Bit Pos. = 7:0. 0x4A, 7 = EN. 0x4A, 6 = . 0x4A, 5 = OUT. 0x4A, 4 = RDY. 0x4A, 3 = . 0x4A, 2 = . 0x4A, 1 = INTH. 0x4A, 0 = INTL. 0x4B, Name = HLVDCON1.",
    "37.10 Register Summary - HLVD\n0x4B, Bit Pos. = 7:0. 0x4B, 7 = . 0x4B, 6 = . 0x4B, 5 = . 0x4B, 4 = . 0x4B, 3 = . 0x4B, 2 = SEL[3:0]. 0x4B, 1 = . 0x4B, 0 = ",
    "38. FVR - Fixed Voltage Reference\nThe Fixed Voltage Reference (FVR) is a stable voltage reference, independent of V DD, with 1.024V, 2.048V or 4.096V selectable output levels. The output of the FVR can be configured to supply a reference voltage to analog peripherals such as those listed below.\n\u00b7 ADC input channel\n\u00b7 ADC positive reference\n\u00b7 Comparator input\n\u00b7 Digital-to-Analog Converter (DAC)\nThe FVR can be enabled by setting the EN bit to ' 1 '.\nNote: Fixed Voltage Reference output cannot exceed VDD.",
    "38.1 Independent Gain Amplifiers\nThe output of the FVR is routed through two independent programmable gain amplifiers. Each amplifier can be programmed for a gain of 1x, 2x or 4x, to produce the three possible voltage levels.\nThe ADFVR bits are used to enable and configure the gain amplifier settings for the reference supplied to the ADC module. Refer to the 'ADC - Analog-to-Digital Converter with Computation Module' chapter for additional information.\nThe CDAFVR bits are used to enable and configure the gain amplifier settings for the reference supplied to the DAC and comparator modules. Refer to the 'DAC - Digital-to-Analog Converter Module' and 'CMP - Comparator Module' chapters for additional information.\nRefer to the figure below for the block diagram of the FVR module.\nFigure 38-1. Fixed Voltage Reference Block Diagram\n\u4144\n\u5652\n\u4146\n\u7265\n\u7269\n\u7865\n\u416e\n\u7920\n\u7269\n\u7261\n\u6365\n\u7265",
    "38.2 FVR Stabilization Period\nWhen the Fixed Voltage Reference module is enabled, it requires time for the reference and amplifier circuits to stabilize. Once the circuits stabilize and are ready for use, the RDY bit will be set.",
    "38.3 Register Definitions: FVR\nLong bit name prefixes for the FVR peripherals are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bits Naming Conventions' chapter for more information.\n\u454e\n\u7220\n\u4275\n\u5652\n\u7220\n\u7820\n\u7820\n\u6d6f\n\u7220\n\u6d6f\n\u7261\n\u6d70\n\u4144\n\u6368\n\u6365\n\u6d6f\n\u6368\n\u4144\n\u7265",
    "Table 38-1. FVR Bit Name Prefixes\nFVR, Bit Name Prefix = FVR",
    "38.3.1 FVRCON\nName:\nFVRCON\nAddress:\n0x3D7",
    "FVR Control Register\nImportant: This register is shared between the Fixed Voltage Reference (FVR) module and the temperature indicator module.\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = RDY. , 3 = TSEN. , 4 = TSRNG. , 5 = CDAFVR[1:0]. , 6 = CDAFVR[1:0]. , 7 = ADFVR[1:0]. , 8 = ADFVR[1:0]. Access, 1 = R/W. Access, 2 = R. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = q. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN Fixed Voltage Reference Enable\n1, Description = Enables module. 0, Description = Disables module",
    "Bit 6 - RDY Fixed Voltage Reference Ready Flag\n1, Description = Fixed Voltage Reference output is ready for use. 0, Description = Fixed Voltage Reference output is not ready for use or not enabled",
    "Bit 5 - TSEN Temperature Indicator Enable\n1, Description = Temperature Indicator is enabled. 0, Description = Temperature Indicator is disabled",
    "Bit 4 - TSRNG Temperature Indicator Range Selection\n1, Description = V OUT = 3V T (High Range). 0, Description = V OUT = 2V T (Low Range)",
    "Bits 3:2 - CDAFVR[1:0]  FVR Buffer 2 Gain Selection (1)\n11, Description = FVR Buffer 2 Gain is 4x, (4.096V) (3). 10, Description = FVR Buffer 2 Gain is 2x, (2.048V) (3). 01, Description = FVR Buffer 2 Gain is 1x, (1.024V). 00, Description = FVR Buffer 2 is OFF",
    "Bits 1:0 - ADFVR[1:0]  FVR Buffer 1 Gain Selection (2)\n11, Description = FVR Buffer 1 Gain is 4x, (4.096V) (3). 10, Description = FVR Buffer 1 Gain is 2x, (2.048V) (3). 01, Description = FVR Buffer 1 Gain is 1x, (1.024V). 00, Description = FVR Buffer 1 is OFF",
    "Notes:\n1. This output goes to the DAC and comparator modules and to the ADC module as an input channel only.\n2. This output goes to the ADC module as a reference and as an input channel.\n3. Fixed Voltage Reference output cannot exceed VDD.",
    "38.4 Register Summary - FVR\n0x00 ... 0x03D6, Name = Reserved. 0x00 ... 0x03D6, Bit Pos. = . 0x00 ... 0x03D6, 7 = . 0x00 ... 0x03D6, 6 = . 0x00 ... 0x03D6, 5 = . 0x00 ... 0x03D6, 4 = . 0x00 ... 0x03D6, 3 = . 0x00 ... 0x03D6, 2 = . 0x00 ... 0x03D6, 1 = . 0x00 ... 0x03D6, 0 = . 0x03D7, Name = FVRCON. 0x03D7, Bit Pos. = 7:0. 0x03D7, 7 = EN. 0x03D7, 6 = RDY. 0x03D7, 5 = TSEN. 0x03D7, 4 = TSRNG. 0x03D7, 3 = CDAFVR[1:0]. 0x03D7,",
    "38.4 Register Summary - FVR\n2 = . 0x03D7, 1 = ADFVR[1:0]. 0x03D7, 0 = ",
    "39. Temperature Indicator Module\nThis family of devices is equipped with a temperature circuit designed to measure the operating temperature of the silicon die. The temperature indicator module provides a temperaturedependent voltage that can be measured by the internal Analog-to-Digital Converter.\nThe circuit's range of operating temperature falls between -40 \u2103 and +125 \u2103 . The circuit may be used as a temperature threshold detector or a more accurate temperature indicator, depending on the level of calibration performed. A one-point calibration allows the circuit to indicate a temperature closely surrounding that point. A two-point calibration allows the circuit to sense the entire range of temperature more accurately.",
    "39.1 Module Operation\nThe temperature indicator module consists of a temperature-sensing circuit that provides a corresponding voltage to the device ADC. The analog voltage output varies inversely to the device temperature. The output of the temperature indicator is referred to as V MEAS.\nThe following figure shows a simplified block diagram of the temperature indicator module.\nFigure 39-1. Temperature Indicator Module Block Diagram\nThe output of the circuit is measured using the internal Analog-to-Digital Converter. A channel is reserved for the temperature circuit output. Refer to the 'ADC - Analog-to-Digital Converter with Computation Module' chapter for more details.\nThe ON/OFF bit for the module is located in the FVRCON register. The circuit is enabled by setting the TSEN bit. When the module is disabled, the circuit draws no current. Refer to the 'FVR - Fixed Reference Voltage' chapter for more details.",
    "39.1.1 Temperature Indicator Range\nThe temperature indicator circuit operates in either high or low range. The high range, selected by setting the TSRNG bit, provides a wider output voltage. This provides more resolution over the temperature range. High range requires a higher bias voltage to operate and thus, a higher VDD is needed. The low range is selected by clearing the TSRNG bit. The low range generates a lower sensor voltage and thus, a lower VDD voltage is needed to operate the circuit.\nThe output voltage of the sensor is the highest value at -40 \u2103 and the lowest value at +125 \u2103 .\n\u00b7 High Range: The high range is used in applications with the reference for the ADC, V REF = 2.048V. This range may not be suitable for battery-powered applications.\n\u00b7 Low Range: This mode is useful in applications in which the V DD is too low for high-range operation. The VDD in this mode can be as low as 1.8V. However, VDD must be at least 0.5V higher than the maximum sensor voltage depending on the expected low operating temperature.",
    "39.1.1 Temperature Indicator Range\nImportant: The standard parameters for the Temperature Sensor for both high range and low range are stored in the DIA table. Refer to the DIA table in the 'Memory Organization' chapter for more details.",
    "39.1.2 Minimum Operating VDD\nWhen the temperature circuit is operated in low range, the device may be operated at any operating voltage that is within the device specifications. When the temperature circuit is operated in high range, the device operating voltage, V DD, must be high enough to ensure that the temperature circuit is correctly biased.\nThe following table shows the recommended minimum VDD vs. Range setting.\nTable 39-1. Recommended VDD vs. Range\n\n\u2265 2.5, Min. V DD , TSRNG = 0 (Low Range) = \u2265 1.8",
    "39.2 Temperature Calculation\nThis section describes the steps involved in calculating the die temperature, T MEAS:\n1. Obtain the ADC count value of the measured analog voltage: The analog output voltage, VMEAS, is converted to a digital count value by the Analog-to-Digital Converter (ADC) and is referred to as ADCMEAS.\n2. Obtain the Gain value from the DIA table. This parameter is TSLR1 for the low range setting or TSHR1 for the high range setting of the temperature indicator module. Refer to the DIA table in the 'Memory Organization' chapter for more details.\n3. Obtain the Offset value from the DIA table. This parameter is TSLR3 for the low range setting or TSHR3 for the high range setting of the temperature indicator module. Refer to the DIA table in the 'Memory Organization' chapter for more details.\nThe following equation provides an estimate for the die temperature based on the above parameters:\nEquation 39-1. Sensor Temperature (in \u2103 )\nADCMEAS = ADC reading at temperature being estimated\nGain = Gain value stored in the DIA table\nOffset = Offset value stored in the DIA table\n<!-- formula-not-decoded -->",
    "39.2 Temperature Calculation\nNote: It is recommended to take the average of ten measurements of ADCMEAS to reduce noise and improve accuracy.",
    "39.2.1 Higher-Order Calibration\nIf the application requires more precise temperature measurement, additional calibrations steps will be necessary. For these applications, two-point or three-point calibration is recommended. For additional information on two-point calibration method, refer to the following Microchip application note, available at the corporate website (www.microchip.com):\n- \u00b7 AN2798, 'Using the PIC16F/PIC18F Ground Referenced Temperature Indicator Module'",
    "39.3 ADC Acquisition Time\nTo ensure accurate temperature measurements, the user must wait a certain minimum acquisition time (parameter TS01) after the temperature indicator output is selected as ADC input. This is required for the ADC sampling circuit to settle before the conversion is performed.\nNote: Parameter TS01 can be found in the Temperature Indicator Requirements table of the 'Electrical Specifications' chapter.",
    "39.4.1 FVRCON\nName:\nFVRCON\nAddress:\n0x3D7",
    "FVR Control Register\nImportant: This register is shared between the Fixed Voltage Reference (FVR) module and the temperature indicator module.\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = RDY. , 3 = TSEN. , 4 = TSRNG. , 5 = CDAFVR[1:0]. , 6 = CDAFVR[1:0]. , 7 = ADFVR[1:0]. , 8 = ADFVR[1:0]. Access, 1 = R/W. Access, 2 = R. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = q. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN Fixed Voltage Reference Enable\n1, Description = Enables module. 0, Description = Disables module",
    "Bit 6 - RDY Fixed Voltage Reference Ready Flag\n1, Description = Fixed Voltage Reference output is ready for use. 0, Description = Fixed Voltage Reference output is not ready for use or not enabled",
    "Bit 5 - TSEN Temperature Indicator Enable\n1, Description = Temperature Indicator is enabled. 0, Description = Temperature Indicator is disabled",
    "Bit 4 - TSRNG Temperature Indicator Range Selection\n1, Description = V OUT = 3V T (High Range). 0, Description = V OUT = 2V T (Low Range)",
    "Bits 3:2 - CDAFVR[1:0]  FVR Buffer 2 Gain Selection (1)\n11, Description = FVR Buffer 2 Gain is 4x, (4.096V) (3). 10, Description = FVR Buffer 2 Gain is 2x, (2.048V) (3). 01, Description = FVR Buffer 2 Gain is 1x, (1.024V). 00, Description = FVR Buffer 2 is OFF",
    "Bits 1:0 - ADFVR[1:0]  FVR Buffer 1 Gain Selection (2)\n11, Description = FVR Buffer 1 Gain is 4x, (4.096V) (3). 10, Description = FVR Buffer 1 Gain is 2x, (2.048V) (3). 01, Description = FVR Buffer 1 Gain is 1x, (1.024V). 00, Description = FVR Buffer 1 is OFF",
    "Notes:\n1. This output goes to the DAC and comparator modules and to the ADC module as an input channel only.\n2. This output goes to the ADC module as a reference and as an input channel.\n3. Fixed Voltage Reference output cannot exceed VDD.",
    "39.5 Register Summary - Temperature Indicator\n0x00 ... 0x03D6, Name = Reserved. 0x00 ... 0x03D6, Bit Pos. = . 0x00 ... 0x03D6, 7 = . 0x00 ... 0x03D6, 6 = . 0x00 ... 0x03D6, 5 = . 0x00 ... 0x03D6, 4 = . 0x00 ... 0x03D6, 3 = . 0x00 ... 0x03D6, 2 = . 0x00 ... 0x03D6, 1 = . 0x00 ... 0x03D6, 0 = . 0x03D7, Name = FVRCON. 0x03D7, Bit Pos. = 7:0. 0x03D7, 7 = EN. 0x03D7, 6 = RDY. 0x03D7, 5 = TSEN. 0x03D7, 4 = TSRNG. 0x03D7, 3 = CDAFVR[1:0]. 0x03D7,",
    "39.5 Register Summary - Temperature Indicator\n2 = . 0x03D7, 1 = ADFVR[1:0]. 0x03D7, 0 = ",
    "40. ADCC - Analog-to-Digital Converter with Computation Module\nThe Analog-to-Digital Converter with Computation (ADCC) allows conversion of an analog input signal to a 12-bit binary representation of that signal. This device uses analog inputs that are multiplexed into a single Sample-and-Hold circuit. The output of the Sample-and-Hold is connected to the input of the converter. The converter generates a 12-bit binary result via successive approximation and stores the conversion result into the ADC result registers.\nAdditionally, the following features are provided within the ADC module:\n\u00b7 Acquisition Timer\n\u00b7 Hardware Capacitive Voltage Divider (CVD) support:\n-Precharge timer\n-Adjustable Sample-and-Hold capacitor array\n-Guard ring digital output drive\n\u00b7 Automatic Repeat and Sequencing:\n-Automated double sample conversion for CVD\n-Two sets of Result registers (Current Result and Previous Result)\n-Auto-conversion trigger\n-Internal re-trigger\n\u00b7 Computation Features:\n-Averaging and low-pass filter functions\n-Reference comparison\n-2-level threshold comparison\n-Selectable interrupts\nFigure 40-1 shows the block diagram of the ADC.\nThe ADC voltage reference is software selectable to be either internally generated or externally supplied.",
    "40. ADCC - Analog-to-Digital Converter with Computation Module\nThe ADC can generate an interrupt upon completion of a conversion and upon threshold comparison. These interrupts can be used to wake up the device from Sleep.",
    "40.1 ADC Configuration\nWhen configuring the ADC the following functions must be considered:\n\u00b7 Port Configuration\n\u00b7 Channel Selection\n\u00b7 ADC Voltage Reference Selection\n\u00b7 ADC Conversion Clock Source\n\u00b7 Interrupt Control\n\u00b7 Result Formatting\n\u00b7 Conversion Trigger Selection\n\u00b7 ADC Acquisition Time\n\u00b7 ADC Precharge Time\n\u00b7 Additional Sample-and-Hold Capacitor\n\u00b7 Single/Double Sample Conversion\n\u00b7 Guard Ring Outputs",
    "40.1.1 Port Configuration\nThe ADC will convert the voltage level on a pin whether or not the ANSEL bit is set. When converting analog signals, the I/O pin will be configured for analog by setting the associated TRIS and ANSEL bits. Refer to the 'I/O Ports' chapter for more information.\nImportant: Analog voltages on any pin that is defined as a digital input may cause the input buffer to conduct excess current.",
    "40.1.2 Channel Selection\nThe ADPCH register determines which channel is connected to the Sample-and-Hold circuit for conversion. When switching channels, it is recommended to have some acquisition time (ADACQ register) before starting the next conversion. Refer to the ADC Operation section for more information.\nImportant: To reduce the chance of measurement error, it is recommended to discharge the Sample-and-Hold capacitor when switching between ADC channels by starting a conversion on a channel connected to VSS and terminating the conversion after the acquisition time has elapsed. If the ADC does not have a dedicated VSS input channel, the V SS selection through the DAC output channel can be used. If the DAC is in use, a free input channel can be connected to V SS , and can be used in place of the DAC.",
    "40.1.3 ADC Voltage Reference\nThe PREF bits provide control of the positive voltage reference. The NREF bit provides control of the negative voltage reference. Refer to the ADREF register for the list of available positive and negative sources.",
    "40.1.4 Conversion Clock\nThe conversion clock source is selected with the CS bit. When CS = 1 the ADC clock source is an internal fixed-frequency clock referred to as ADCRC. When CS = 0 the ADC clock source is derived from FOSC.\nImportant: When CS = 0 , the clock can be divided using the ADCLK register to meet the ADC clock period requirements.\nThe time to complete one bit conversion is defined as the T AD. Refer to Figure 40-2 for the complete timing details of the ADC conversion.\nFor correct conversion, the appropriate T AD specification must be met. Refer to the ADC Timing Specifications table in the 'Electrical Specifications' chapter for more details. The table below gives examples of appropriate ADC clock selections.\nTable 40-1. ADC Clock Period (T AD) Vs. Device Operating Frequencies (1,3)",
    "40.1.4 Conversion Clock\nF OSC /2, ADCLK.ADCLK = 'b000000. F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 31.25 ns (2). F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 62.5 ns (2). F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 100 ns (2). F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 125 ns (2). F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 250 ns (2). F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 500 ns. F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = 2.0",
    "40.1.4 Conversion Clock\n\u03bcs. F OSC /4, ADCLK.ADCLK = 'b000001. F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 62.5 ns (2). F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 125 ns (2). F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 200 ns (2). F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 250 ns (2). F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 500 ns. F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 1.0 \u03bcs. F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz =",
    "40.1.4 Conversion Clock\n4.0 \u03bcs. F OSC /6, ADCLK.ADCLK = 'b000010. F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 93.75 ns (2). F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 187.5 ns (2). F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 300 ns (2). F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 375 ns (2). F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 750 ns. F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 1.5 \u03bcs. F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC",
    "40.1.4 Conversion Clock\n).1 MHz = 6.0 \u03bcs. F OSC /8, ADCLK.ADCLK = 'b000011. F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 125 ns (2). F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 250 ns (2). F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 400 ns (2). F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 500 ns. F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 1.0 \u03bcs. F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 2.0 \u03bcs. F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC",
    "40.1.4 Conversion Clock\n).1 MHz = 8.0 \u03bcs. ..., ADCLK.ADCLK = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = .... F OSC /16, ADCLK.ADCLK =",
    "40.1.4 Conversion Clock\n'b000111. F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 250 ns (2). F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 500 ns. F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 800 ns. F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 1.0 \u03bcs. F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 2.0 \u03bcs. F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 4.0 \u03bcs. F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = 16.0 \u03bcs (2). ..., ADCLK.ADCLK =",
    "40.1.4 Conversion Clock\n.... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = .... F OSC /32, ADCLK.ADCLK = 'b001111. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC",
    "40.1.4 Conversion Clock\n).64 MHz = 500 ns. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 1.0 \u03bcs. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 1.6 \u03bcs. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 2.0 \u03bcs. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 4.0 \u03bcs. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 8.0 \u03bcs. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = 32.0 \u03bcs (2). ..., ADCLK.ADCLK = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz",
    "40.1.4 Conversion Clock\n= .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = .... F OSC /64, ADCLK.ADCLK = 'b0111111. F OSC /64, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 1.0 \u03bcs. F OSC /64, ADC Clock Period (T AD ) for Different",
    "40.1.4 Conversion Clock\nDevice Frequency (F OSC ).32 MHz = 2.0 \u03bcs. F OSC /64, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 3.2 \u03bcs. F OSC /64, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 4.0 \u03bcs. F OSC /64, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 8.0 \u03bcs. F OSC /64, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 16.0 \u03bcs (3). F OSC /64, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = 64.0 \u03bcs (2). ..., ADCLK.ADCLK = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency",
    "40.1.4 Conversion Clock\n(F OSC ).32 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = .... F OSC /128, ADCLK.ADCLK = 'b111111. F OSC /128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 2.0 \u03bcs. F OSC /128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 4.0 \u03bcs. F OSC",
    "40.1.4 Conversion Clock\n/128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 6.4 \u03bcs. F OSC /128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 8.0 \u03bcs. F OSC /128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 16.0 \u03bcs (2). F OSC /128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 32.0 \u03bcs (2). F OSC /128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = 128.0 \u03bcs (2). ADCRC, ADCLK.ADCLK = CS = 1. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 1.0-6.0 \u03bcs. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz =",
    "40.1.4 Conversion Clock\n1.0-6.0 \u03bcs. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 1.0-6.0 \u03bcs. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 1.0-6.0 \u03bcs. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 1.0-6.0 \u03bcs. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 1.0-6.0 \u03bcs. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = 1.0-6.0 \u03bcs",
    "Notes:\n1. Refer to the 'Electrical Specifications' chapter to see the T AD parameter for the ADCRC source typical TAD value.\n2. These values violate the required T AD time.\n3. The ADC clock period (TAD) and total ADC conversion time can be minimized when the ADC clock is derived from the system clock FOSC. However, the ADCRC oscillator source must be used when conversions are to be performed with the device in Sleep mode.",
    "Important:\n\u00b7 Except for the ADCRC clock source, any changes in the system clock frequency will change the ADC clock frequency, which may adversely affect the ADC result.\n\u00b7 The internal control logic of the ADC runs off of the clock selected by the CS bit. When the CS bit is set to ' 1 ' (ADC runs on ADCRC), there may be unexpected delays in operation when setting the ADC control bits.",
    "Figure 40-2. Analog-to-Digital Conversion Cycles\nSet the GO bit",
    "Note:\nchapter 1. Refer to the ADC Conversion Timing Specifications table in the Electrical Specifications .\n2. Refer to the ADPRE register for more details.\n3. Refer to the ADACQ register for more details.",
    "40.1.5 Interrupts\nThe ADC module allows for the ability to generate an interrupt upon completion of an Analog-toDigital Conversion. The ADC Interrupt Flag is the ADIF bit in the PIRx register. The ADC Interrupt Enable is the ADIE bit in the PIEx register. The ADIF bit must be cleared by software.",
    "Important:\n1. The ADIF bit is set at the completion of every conversion, regardless of whether or not the ADC interrupt is enabled.\n2. The ADC operates during Sleep only when the ADCRC oscillator is selected.",
    "While the device is operating in Sleep:\n\u00b7 If ADIE = 1 and GIE = 0 : An interrupt will wake up the device from Sleep. Upon waking from Sleep, the instructions following the SLEEP instruction is executed. Interrupt Service Routine is not executed.\n\u00b7 If ADIE = 1 and GIE = 1 : An interrupt will wake up the device from Sleep. Upon waking from Sleep, the instruction following the SLEEP instruction is always executed. Then the execution will switch to the Interrupt Service Routine.",
    "40.1.6 Result Formatting\nThe ADC conversion result can be supplied in two formats, left justified or right justified. The FM bit controls the output format as shown in Figure 40-3.",
    "ADRESL\nMSB\nLSB\nbit 7\nbit 0\nbit 7\nbit 0\n(FM = 0 )\nMSB\nLSB\nbit 7\nbit 0\nbit 7\nbit 0\n(FM = 1 )\n12-bit ADC Result\nUnimplemented: Read as 0\n12-bit ADC Result\nUnimplemented: Read as 0\nImportant: Writes to the ADRES register pair are always right justified regardless of the selected format mode. Therefore, a data read after writing to ADRES when FM = 0 will be shifted left four places.",
    "40.2.1 Starting a Conversion\nTo enable the ADC module, the ON bit must be set to ' 1 '. A conversion may be started by any of the following:\n\u00b7 Software setting the GO bit to ' 1 '\n\u00b7 An external trigger (source selected by ADACT)\n\u00b7 A Continuous-mode retrigger (see the Continuous Sampling Mode section for more details)\nImportant: The GO bit will not be set in the same instruction that turns on the ADC. Refer to the ADC Conversion Procedure (Basic Mode) section for more details.",
    "40.2.2 Completion of a Conversion\nWhen any individual conversion is complete, the existing value in ADRES is written into ADPREV (if PSIS = 0 ) and the new conversion results appear in ADRES. When the conversion completes, the ADC module will:\n\u00b7 Clear the GO bit (unless the CONT bit is set)\n\u00b7 Set the ADIF Interrupt Flag bit\n\u00b7 Set the MATH bit\n\u00b7 Update ADACC\nAfter every conversion when DSEN = 0 , or after every other conversion when DSEN = 1 , the following events occur:\n\u00b7 ADERR is calculated\n\u00b7 ADTIF interrupt is set if ADERR calculation meets threshold comparison",
    "40.2.3 ADC Operation During Sleep\nThe ADC module can operate during Sleep. This requires the ADC clock source to be set to the ADCRC option. When the ADCRC oscillator source is selected, the ADC waits one additional instruction before starting the conversion. This allows the SLEEP instruction to be executed, which can reduce system noise during the conversion. If the ADC interrupt is enabled, the device will wake up from Sleep when the conversion completes. If the ADC interrupt is disabled, the device remains in Sleep and the ADC module is turned off after the conversion completes, although the ON bit remains set.",
    "40.2.4 External Trigger During Sleep\nIf the external trigger is received during Sleep while the ADC clock source is set to the ADCRC, the ADC module will perform the conversion and set the ADIF bit upon completion.\nIf an external trigger is received when the ADC clock source is something other than ADCRC, the trigger will be recorded, but the conversion will not begin until the device exits Sleep.",
    "40.2.5 Auto-Conversion Trigger\nThe auto-conversion trigger allows periodic ADC measurements without software intervention. When a rising edge of the selected source occurs, the GO bit is set by hardware.\nThe auto-conversion trigger source is selected with the ACT bits.\nUsing the auto-conversion trigger does not ensure proper ADC timing. It is the user's responsibility to ensure that the ADC timing requirements are met.",
    "40.2.6 ADC Conversion Procedure (Basic Mode)\nThis is an example procedure for using the ADC to perform an Analog-to-Digital Conversion:\n1. Configure Port:\n-Disable pin output driver (refer to the TRISx register)\n-Configure pin as analog (refer to the ANSELx register)\n2. Configure the ADC module:\n-Select ADC conversion clock\n-Configure voltage reference\n-Select ADC input channel\n-Configure precharge (ADPRE) and acquisition (ADACQ) time period\n-Turn on ADC module\n3. Configure ADC interrupt (optional):\n-Clear ADC interrupt flag\n-Enable ADC interrupt\n-Enable global interrupt (GIE bit) (1)\n4. If ADACQ = 0 , software must wait the required acquisition time (2) .\n5. Start conversion by setting the GO bit.\n6. Wait for ADC conversion to complete by one of the following:\n-Polling the GO bit\n-Waiting for the ADC interrupt (if interrupt is enabled)\n7. Read ADC Result.\n8. Clear the ADC interrupt flag (if interrupt is enabled).",
    "Notes:\n1. With global interrupts disabled (GIE = 0 ), the device will wake from Sleep but will not enter an Interrupt Service Routine.\n2. Refer to the ADC Acquisition Requirements section for more details.",
    "Example 40-1. ADC Conversion (assembly)\n```\n; This code block configures the ADC for polling, Vdd and Vss references, ; ADCRC oscillator, and AN0 input. ; Conversion start & polling for completion are included. BANKSEL ADCON1      ; clrf    ADCON1      ; clrf    ADCON2      ; Legacy mode, no filtering, ADRES->ADPREV clrf    ADCON3      ; no math functions clrf    ADREF       ; Vref = Vdd & Vss clrf    ADPCH       ; select RA0/AN0 clrf    ADACQ       ; software controlled acquisition time clrf    ADCAP       ; default S&H capacitance clrf    ADRPT       ; no repeat measurements clrf    ADACT       ; auto-conversion disabled movlw   B'10010100' ; ADC On, right-justified, ADCRC clock movwf   ADCON0 BANKSEL TRISA       ; bsf     TRISA,0     ; Set RA0 to input BANKSEL ANSEL",
    "Example 40-1. ADC Conversion (assembly)\n; bsf     ANSEL,0     ; Set RA0 to analog call    SampleTime  ; Acquisiton delay BANKSEL ADCON0 bsf     ADCON0,GO   ; Start conversion btfsc   ADCON0,GO   ; Is conversion done? goto    $-2\n; No, test again BANKSEL ADRESH      ; movf    ADRESH,W    ; Read upper byte movwf   RESULTHI    ; store in GPR space movf    ADRESL,W    ; Read lower byte movwf   RESULTLO    ; Store in GPR space\n```",
    "Example 40-2. ADC Conversion (C)\n```\n/*This code block configures the ADC for polling, VDD and VSS references, ADCRC oscillator and AN0 input. Conversion start & polling for completion are included. */ void main () { //System Initialize initializeSystem(); //Setup ADC ADCON0bits.FM = 1; //right justify ADCON0bits.CS = 1; //ADCRC Clock ADPCH = 0x00; //RA0 is Analog channel TRISAbits.TRISA0 = 1; //Set RA0 to input ANSELAbits.ANSELA0 = 1; //Set RA0 to analog ADACQ = 32; //Set acquisition time ADCON0bits.ON = 1; //Turn ADC On while (1) { ADCON0bits.GO = 1; //Start conversion while (ADCON0bits.GO); //Wait for conversion done resultHigh = ADRESH; //Read result resultLow = ADRESL; //Read result } }\n```",
    "40.3 ADC Acquisition Requirements\nFor the ADC to meet its specified accuracy, the charge holding capacitor (C HOLD) must be allowed to fully charge to the input channel voltage level. The analog input model is shown in Figure 40-4. The source impedance (RS) and the internal sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD. The sampling switch (RSS) impedance varies over the device voltage (V DD). The maximum recommended impedance for analog sources is 10 k\u03a9. As the source impedance is decreased, the acquisition time may be decreased. After the analog input channel is selected (or changed), an ADC acquisition time must be completed before the conversion can be started. To calculate the minimum acquisition time, Equation 40-1 may be used. This equation assumes an error of 1/2 LSb. The 1/2 LSb error is the maximum error allowed for the ADC to meet its specified resolution.\nEquation 40-1. Acquisition Time Example\nAssumptions: Temperature = 50\u00b0C; External impedance = 10 k\u03a9; VDD = 5.0V\nTACQ = Amplifier Settling Time + Hold Capacitor Charging Time + Temperature Coefficient",
    "40.3 ADC Acquisition Requirements\n<!-- formula-not-decoded -->\nT ACQ = T AMP + T C + T COFF T ACQ = 2 \u03bcs + T C + Temperature - 25\u00b0C 0.05 \u03bcs/\u00b0C The value for T C can be approximated with the following equations:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "Important:\n\u00b7 The reference voltage (VREF ) has no effect on the equation, since it cancels itself out.\n\u00b7 The charge holding capacitor (CHOLD) is not discharged after each conversion.\n\u00b7 The maximum recommended impedance for analog sources is 10 k\u03a9. This is required to meet the pin leakage specification.",
    "Figure 40-4. Analog Input Model\nLegend:\nCPIN\n= Input Capacitance\nILEAKAGE\nRIC\nRS\nVA\nVT\nSS\nRSS\nCHOLD\n= Leakage Current at the pin due to various junctions\n= Interconnect Resistance\n= Source Impedance\n= Analog Voltage\n= Diode Forward Voltage\n= Sampling Switch\n= Resistance of the Sampling Switch\n= Sample/Hold Capacitance",
    "Note:\n- 1. Refer to the Electrical Specifications chapter.\nFigure 40-5. ADC Transfer Function\nRev. 30-000115B",
    "40.4 ADC Charge Pump\nThe ADC module has a dedicated charge pump which can be controlled through the ADCP register. The primary purpose of the charge pump is to supply a constant voltage to the gates of transistor devices in the Analog-to-Digital Converter, signal and reference input pass-gates, to prevent degradation of transistor performance at low operating voltage.\nThe charge pump can be enabled by setting the CPON bit. Once enabled, the pump will undergo a start-up time to stabilize the charge pump output. Once the output stabilizes and is ready for use, the CPRDY bit will be set.",
    "40.5 Computation Operation\nThe ADC module hardware is equipped with post-conversion computation features. These features provide post-processing functions such as digital filtering/averaging and threshold comparison. Based on computation results, the module can be configured to take additional samples or stop conversions, and an interrupt may be asserted.\nFigure 40-6. Computational Features Simplified Block Diagram\n\u4553\n\u4144\n\u4144\n\u4144\n\u5354\n\u5054\n\u5053\nThe operation of the ADC computational features is controlled by the MD bits.\nThe module can be operated in one of five modes:",
    "40.5 Computation Operation\n\u00b7 Basic: This is a Legacy mode. In this mode, ADC conversion occurs on single (DSEN = 0 ) or double (DSEN = 1 ) samples. ADIF is set after each conversion is complete. ADTIF is set according to the Calculation mode.\n\u00b7 Accumulate: With each trigger, the ADC conversion result is added to the accumulator and CNT increments. ADIF is set after each conversion. ADTIF is set according to the Calculation mode.\n\u00b7 Average: With each trigger, the ADC conversion result is added to the accumulator. When the RPT number of samples have been accumulated, a threshold test is performed. Upon the next trigger, the accumulator is cleared. For the subsequent tests, additional ADRPT samples are required to be accumulated.\n\u00b7 Burst Average: At the trigger, the accumulator is cleared. The ADC conversion results are then collected repetitively until ADRPT samples are accumulated and finally the threshold is tested.",
    "40.5 Computation Operation\n\u00b7 Low-Pass Filter (LPF): With each trigger, the ADC conversion result is sent through a filter. When ADRPT samples have occurred, a threshold test is performed. Every trigger after that the ADC conversion result is sent through the filter and another threshold test is performed.\nThe five modes are summarized in the following table.\n\u7261\n\u7665\n\u5052\n\u4556\n\u4144\n\u6375\n\u7272\n\u7368\n\u7265\n\u4144\n\u7272\n\u5365\nComputation Modes\nTable 40-2.",
    "40.5 Computation Operation\nInterrupt, 1 = ADCNT. Interrupt, 2 = count. Interrupt, 3 = count. Interrupt, 4 = count. Interrupt, 5 = ADRPT. Interrupt, 6 = count. Interrupt, 1 = ADFLTR. Interrupt, 2 = N/A. Interrupt, 3 = ADACC/2 CRS. Interrupt, 4 = ADACC/2 CRS. Interrupt, 5 = ADACC/2 CRS. Interrupt, 6 = ADACC/2 CRS (Filtered Value). Interrupt, 1 = AOV. Interrupt, 2 = N/A. Interrupt, 3 = ADACC Overflow. Interrupt, 4 = ADACC Overflow. Interrupt, 5 = ADACC Overflow. Interrupt, 6 = ADACC Overflow. Threshold Operations, 1 = Interrupt. Threshold Operations, 2 = If threshold = true. Threshold Operations, 3 = If threshold = true. Threshold Operations, 4 = If threshold = true. Threshold Operations, 5 = If threshold = true. Threshold Operations, 6 = If threshold = true. Threshold Operations, 1 = Threshold Test. Threshold Operations, 2 = Every Sample. Threshold Operations, 3 = Every Sample. Threshold Operations, 4 = If ADCNT \u2265 ADRPT. Threshold",
    "40.5 Computation Operation\nOperations, 5 = If ADCNT \u2265 ADRPT. Threshold Operations, 6 = If ADCNT \u2265 ADRPT. Threshold Operations, 1 = Retrigger. Threshold Operations, 2 = No. Threshold Operations, 3 = No. Threshold Operations, 4 = No. Threshold Operations, 5 = Repeat while ADCNT < ADRPT. Threshold Operations, 6 = No. Value after Cycle (1) Completion, 1 = ADCNT. Value after Cycle (1) Completion, 2 = Unchanged. Value after Cycle (1) Completion, 3 = If (ADCNT = 0xFF): ADCNT, otherwise: ADCNT+1. Value after Cycle (1) Completion, 4 = If (ADCNT = 0xFF): ADCNT, otherwise: ADCNT + 1. Value after Cycle (1) Completion, 5 = Each repetition: same as Average End with ADCNT = ADRPT. Value after Cycle (1) Completion, 6 = If (ADCNT = 0xFF): ADCNT, otherwise: ADCNT + 1. Value after Cycle (1) Completion, 1 = ADACC. Value after Cycle (1) Completion,",
    "40.5 Computation Operation\n2 = Unchanged. Value after Cycle (1) Completion, 3 = S1 + ADACC or (S2 - S1) + ADACC. Value after Cycle (1) Completion, 4 = S1 + ADACC or (S2 -S1) + ADACC. Value after Cycle (1) Completion, 5 = Each repetition: same as Average End with sum of all samples. Value after Cycle (1) Completion, 6 = S1 + ADACC-ADACC/ 2 CRS or (S2 - S1) + ADACC-ADACC/2 CRS. Register Clear Event, 1 = ADACC and CNT. Register Clear Event, 2 = ACLR = 1. Register Clear Event, 3 = ACLR = 1. Register Clear Event, 4 = ACLR = 1 or ADCNT \u2265 ADRPT at GO set or retrigger. Register Clear Event, 5 = ACLR = 1 or at GO set or retrigger. Register Clear Event, 6 = ACLR = 1. MD, 1 = MD. MD, 2 = 0. MD, 3 = 1. MD, 4 = 2. MD, 5 = 3. MD, 6 = 4. Mode rota",
    "40.5 Computation Operation\ne hisp g 90, 1 = Mode rota e hisp g 90. Mode rota e hisp g 90, 2 = Basic. Mode rota e hisp g 90, 3 = Accumulate. Mode rota e hisp g 90, 4 = Average. Mode rota e hisp g 90, 5 = Burst Average. Mode rota e hisp g 90, 6 = Low-pass Filter\n, Cycle means two conversions.\n1\n, Cycle means one conversion. When DSEN =\n0\nWhen DSEN =\n1.",
    "S1 and S2 are abbreviations for Sample 1 and Sample 2, respectively. When DSEN = 0 , S1 = ADRES; When DSEN = 1 , S1 = ADPREV and S2 = ADRES.\n2.",
    "40.5.1 Digital Filter/Average\nThe digital filter/average module consists of an accumulator with data feedback options and control logic to determine when threshold tests need to be applied. The accumulator can be accessed through the ADACC register.\nUpon each trigger event (the GO bit set or external event trigger), the ADC conversion result is added to or subtracted from the accumulator. If the accumulated value exceeds 2 (accumulator_width) -1 = 2 18 -1 = 262143, the AOV overflow bit is set.",
    "40.5.1 Digital Filter/Average\nThe number of samples to be accumulated is determined by the ADRPT (ADC Repeat Setting) register. Each time a sample is added to the accumulator, the ADCNT register is incremented. Once ADRPT samples are accumulated (ADCNT = ADRPT), the accumulator may be cleared automatically depending on ADC Operation mode. An accumulator clear command can be issued in software by setting the ACLR bit. Setting the ACLR bit will also clear the AOV (Accumulator Overflow) bit, as well as the ADCNT register. The ACLR bit is cleared by the hardware when accumulator clearing action is complete.\nImportant: When ADC is operating from ADCRC, up to five ADCRC clock cycles are required to execute the ADACC clearing operation.",
    "40.5.1 Digital Filter/Average\nThe CRS bits control the data shift on the accumulator result, which effectively divides the value in the accumulator registers. For the Accumulate mode of the digital filter, the shift provides a simple scaling operation. For the Average/Burst Average mode, the calculated average is only accurate when the number of samples agrees with the number of bits shifted. For the Low-Pass Filter mode, the shift is an integral part of the filter and determines the cutoff frequency of the filter. Table 40-3 shows the -3 dB cutoff frequency in \u03c9T (radians) and the highest signal attenuation obtained by this filter at Nyquist frequency (\u03c9T = \u03c0).\n\nTable 40-3. Low-Pass Filter -3 dB Cutoff Frequency",
    "40.5.1 Digital Filter/Average\n1, \u03c9T (radians) @-3 dB Frequency = 0.72. 1, dB @F Nyquist =1/(2T) = -9.5. 2, \u03c9T (radians) @-3 dB Frequency = 0.284. 2, dB @F Nyquist =1/(2T) = -16.9. 3, \u03c9T (radians) @-3 dB Frequency = 0.134. 3, dB @F Nyquist =1/(2T) = -23.5. 4, \u03c9T (radians) @-3 dB Frequency = 0.065. 4, dB @F Nyquist =1/(2T) = -29.8. 5, \u03c9T (radians) @-3 dB Frequency = 0.032. 5, dB @F Nyquist =1/(2T) = -36.0. 6, \u03c9T (radians) @-3 dB Frequency = 0.016. 6, dB @F Nyquist =1/(2T) = -42.0",
    "40.5.2 Basic Mode\nBasic mode (MD = 'b000 ) disables all additional computation features. In this mode, no accumulation occurs but threshold error comparison is performed. Double sampling, Continuous mode, and all CVD features are still available, but no digital filter/average calculations are performed.",
    "40.5.3 Accumulate Mode\nIn Accumulate mode (MD = 'b001 ), after every conversion, the ADC result is added to the ADACC register. The ADACC register is right-shifted by the value of the CRS bits. This right-shifted value is copied into the ADFLTR register. The Formatting mode does not affect the right-justification of the ADACC or ADFLTR values. Upon each sample, ADCNT is incremented, counting the number of samples accumulated. After each sample and accumulation, the ADFLTR value has a threshold comparison performed on it (see the Threshold Comparison section) and the ADTIF interrupt may trigger.",
    "40.5.4 Average Mode\nIn Average mode (MD = 'b010 ), the ADACC registers accumulate with each ADC sample, much as in Accumulate mode, and the ADCNT register increments with each sample. The ADFLTR register is also updated with the right-shifted value of the ADACC register. The value of the CRS bits governs the number of right shifts. However, in Average mode, the threshold comparison is performed upon ADCNT being greater than or equal to a user-defined ADRPT value. In this mode, when ADRPT = 2^CRS, the final accumulated value will be divided by the number of samples, allowing for a threshold comparison operation on the average of all gathered samples.",
    "40.5.5 Burst Average Mode\nThe Burst Average mode (MD = 'b011 ) acts the same as the Average mode in most respects. The one way it differs is that it continuously retriggers ADC sampling until the CNT value is equal to ADRPT, even if Continuous Sampling mode (see the Continuous Sampling Mode section) is not enabled. This provides a threshold comparison on the average of a short burst of ADC samples.",
    "40.5.6 Low-Pass Filter Mode\nThe Low-Pass Filter mode (MD = 'b100 ) acts similarly to the Average mode in how it handles samples (accumulates samples until the ADCNT value is greater than or equal to RPT, then triggers a threshold comparison), but instead of a simple average, it performs a low-pass filter operation on all of the samples, reducing the effect of high-frequency noise on the total, then performs a threshold comparison on the results. In this mode, the CRS bits determine the cutoff frequency of the low-pass filter (as demonstrated by Digital Filter/Average). Refer to the Computation Operation section for a more detailed description of the mathematical operation.\nFor more information about Low-Pass Filter mode, refer to the following Microchip application note, available at the corporate website (www.microchip.com):\n- \u00b7 AN2749, 'PIC18 12-bit ADCC in Low-Pass Filter Mode'",
    "40.5.7 Threshold Comparison\nAt the end of each computation:\n\u00b7 The conversion results are captured at the end-of-conversion.\n\u00b7 The error (ADERR) is calculated based on a difference calculation which is selected by the CALC bits. The value can be one of the following calculations:\n-The first derivative of single measurements\n-The CVD result when double sampling is enabled\n-The current result vs. setpoint value in the ADSTPT register\n-The current result vs. the filtered/average result\n-The first derivative of the filtered/average value\n-Filtered/average value vs. setpoint value in the ADSTPT register\n\u00b7 The result of the calculation (ADERR) is compared to the upper and lower thresholds, ADUTH and ADLTH registers, to set the UTHR and LTHR flag bits. The threshold logic is selected by the TMD bits. The threshold trigger option can be one of the following:\n-Never interrupt\n-Error is less than lower threshold\n-Error is greater than or equal to lower threshold\n-Error is between thresholds (inclusive)\n-Error is outside of thresholds\n-Error is less than or equal to upper threshold",
    "40.5.7 Threshold Comparison\n-Error is greater than upper threshold\n-Always interrupt regardless of threshold test results\n-If the Threshold condition is met, the threshold interrupt flag ADTIF is set.",
    "Important:\n\u00b7 The threshold tests are signed operations.\n\u00b7 If the AOV bit is set, a threshold interrupt is signaled. It is good practice for threshold interrupt handlers to verify the validity of the threshold by checking AOV bit.",
    "40.5.8.1 Continuous Sampling Mode\nSetting the CONT bit automatically retriggers a new conversion cycle after updating the ADACC register. That means the GO bit remains set to generate automatic retriggering. If SOI = 1 , a Threshold Interrupt condition will clear GO bit and the conversion will stop.",
    "40.5.8.2 Double Sample Conversion\nDouble sampling is enabled by setting the DSEN bit. When this bit is set, two conversions are required before the module calculates the threshold error. Each conversion must be triggered separately when CONT = 0 but will repeat automatically form a single trigger when CONT = 1 . The first conversion will set the MATH bit and update ADACC but will not calculate ADERR or trigger ADTIF. When the second conversion completes, the first value is transferred to ADPREV (depending on the setting of PSIS) and the value of the second conversion is placed into ADRES. Only upon the completion of the second conversion is ADERR calculated and ADTIF triggered (depending on the value of CALC).",
    "40.6 Capacitive Voltage Divider (CVD) Features\nThe ADC module contains several features that allow the user to perform a relative capacitance measurement on any ADC channel using the internal ADC Sample-and-Hold capacitance as a reference. This relative capacitance measurement can be used to implement capacitive touch or proximity sensing applications. The following figure shows the basic block diagram of the CVD portion of the ADC module.\nFigure 40-7. Hardware Capacitive Voltage Divider Block Diagram\n\u4444\n\u5050\n\u2620\n\u7267\n\u6368\n\u5072\n\u7469\n\u5361\n\u4164\n\u7273\nThis is an example on how to configure ADC for CVD operation:",
    "40.6 Capacitive Voltage Divider (CVD) Features\n1. Configure Port:\na. Disable pin output driver (refer to the TRISx register)\nb. Configure pin as analog (refer to the ANSELx register)\n2. Configure the ADC module:\na. Select ADC conversion clock\nb. Configure voltage reference\nc. Select ADC input channel\nd. Configure precharge (ADPRE) and acquisition (ADACQ) time period\ne. Select precharge polarity (PPOL)\nf. Enable Double Sampling (DSEN)\ng. Turn on ADC module\n3. Configure ADC interrupt (optional):\na. Clear ADC interrupt flag\nb. Enable ADC interrupt\nc. Enable global interrupt (GIE bit) (1)\n4. Start double sample conversion by setting the GO bit.\n5. Wait for ADC conversion to complete by one of the following: a. Polling the GO bit\nb. Waiting for the ADC interrupt (if interrupt is enabled)\n6. Second ADC conversion depends on the state of CONT:",
    "40.6 Capacitive Voltage Divider (CVD) Features\na. If CONT = 1 , both conversion will repeat automatically from a single trigger b. If CONT = 0 , each conversion must be triggered separately\n7. The ADERR register contains the CVD result.\n\u7220\n\u5365\n\u414e\n\u5050\n\u2620\n\u7267\n\u6368\n\u5072\n\u7267\n\u6368\n\u5072\n\u4444\n\u5050\n\u5050\n\u2620\n\u2620\n\u7267\n\u6368\n\u5072\n\u7267\n\u6368\n\u5072\n\u4150\n\u4144\n\u4144\n- 8. Clear the ADC interrupt flag (if interrupt is enabled).",
    "Note:\n- 1. With global interrupts disabled (GIE = 0 ), the device will wake from Sleep but will not enter an Interrupt Service Routine.",
    "40.6.1 CVD Operation\nA CVD operation begins with the ADC's internal Sample-and-Hold capacitor (CHOLD) being disconnected from the path which connects it to the external capacitive sensor node. While disconnected, CHOLD is precharged to VDD or discharged to VSS. The sensor node is either discharged or charged to VSS or V DD, respectively to the opposite level of C HOLD. When the precharge phase is complete, the V DD/VSS bias paths for the two nodes are disconnected and the paths between CHOLD and the external sensor node is reconnected, at which time the acquisition phase of the CVD operation begins. During acquisition, a capacitive voltage divider is formed between the precharged CHOLD and sensor nodes, which results in a final voltage level setting on C HOLD which is determined by the capacitances and precharge levels of the two nodes. After acquisition, the ADC converts the voltage level on C HOLD. This process is then repeated with the selected precharge levels inverted for both the CHOLD and the sensor nodes. The waveform for two CVD measurements, which is known as differential CVD measurement, is shown in the following figure.",
    "40.6.1 CVD Operation\nFigure 40-8. Differential CVD Measurement Waveform\n\u7267\n\u5072\n\u6368\n\u4163\n\u7265\n\u7274\n\u4444\n\u7267\n\u6368\n\u5072\n\u7265\n\u4163\n\u7274\n\u7273\n\u5361\n\u5365\n\u636f\n\u5361",
    "40.6.2 Precharge Control\nThe Precharge stage is the period of time that brings the external channel and internal Sample-andHold capacitor to known voltage levels. Precharge is enabled by writing a nonzero value to the ADPRE register. This stage is initiated when an ADC conversion begins, either from setting the GO\n\u5353\n\u566f\n\u7461\n\u4144\n\u5361\n\u6369\n\u4578\n\u6369\n\u7665\n\u5365\n\u736f\nbit, a Special Event Trigger, or a conversion restart from the computation functionality. If the ADPRE register is cleared when an ADC conversion begins, this stage is skipped.",
    "40.6.2 Precharge Control\nDuring the precharge time, CHOLD is disconnected from the outer portion of the sample path that leads to the external capacitive sensor and is connected to either V DD or V SS , depending on the value of the PPOL bit. At the same time, the PORT pin logic of the selected analog channel is overridden to drive a digital high or low out, to precharge the outer portion of the ADC's sample path, which includes the external sensor. The output polarity of this override is determined by the PPOL bit such that the external sensor cap is charged opposite of the internal C HOLD cap. The amount of time for precharge is controlled by the ADPRE register.\nImportant: The external charging overrides the TRIS/LAT/Guard outputs setting of the respective I/O pin. If there is a device attached to this pin, precharge will not be used.",
    "40.6.3 Acquisition Control for CVD (ADPRE > 0 )\nThe Acquisition stage allows time for the voltage on the internal Sample-and-Hold capacitor to charge or discharge from the selected analog channel. This acquisition time is controlled by the ADACQ register. The acquisition stage begins when precharge stage ends.\nAt the start of the acquisition stage, the PORT pin logic of the selected analog channel is overridden to turn off the digital high/low output drivers so they do not affect the final result of the charge averaging. Also, the selected ADC channel is connected to CHOLD. This allows charge averaging to proceed between the precharged channel and the CHOLD capacitor.\nImportant: When ADPRE > 0 setting ADACQ to ' 0 ' will set a maximum acquisition time. When precharge is disabled, setting ADACQ to ' 0 ' will disable hardware acquisition time control.",
    "40.6.4 Guard Ring Outputs\nFigure 40-9 shows a typical guard ring circuit. C GUARD represents the capacitance of the guard ring trace placed on the PCB. The user selects values for R A and RB that will create a voltage profile on CGUARD, which will match the selected acquisition channel.\nThe purpose of the guard ring is to generate a signal in phase with the CVD sensing signal to minimize the effects of the parasitic capacitance on sensing electrodes. It also can be used as a mutual drive for mutual capacitive sensing. For more information about active guard and mutual drive, refer to the following Microchip application note, available at the corporate website (www.microchip.com):\n- \u00b7 AN1478, 'mTouch TM  Sensing Solution Acquisition Methods Capacitive Voltage Divider'\nThe ADC has two guard ring drive outputs, ADGRDA and ADGRDB. These outputs are routed through PPS controls to I/O pins. Refer to the 'PPS - Peripheral Pin Select Module' chapter for more details. The polarity of these outputs is controlled by the GPOL and IPEN bits.",
    "40.6.4 Guard Ring Outputs\nAt the start of the first precharge stage, both outputs are set to match the GPOL bit. Once the acquisition stage begins, ADGRDA changes polarity, while ADGRDB remains unchanged. When performing a double sample conversion, setting the IPEN bit causes both guard ring outputs to transition to the opposite polarity of GPOL at the start of the second precharge stage, and ADGRDA toggles again for the second acquisition. For more information on the timing of the guard ring output, refer to Figure 40-10.",
    "Figure 40-9. Guard Ring Circuit\nFigure 40-10. Differential CVD with Guard Ring Output Waveform\n\u7267\n\u5072\n\u6368\n\u4163\n\u7265\n\u7274\n\u5072\n\u6368\n\u7267\n\u4444\n\u7265\n\u4163\n\u4144\n\u4144\n\u5353\n\u566f\n\u7461\n\u7264\n\u6369\n\u4578\n\u6369\n\u7665\n\u5365\n\u736f\n\u5361\n\u7273\n\u5361\n\u636f\n\u5365\n\u7274",
    "40.6.5 Additional Sample-and-Hold Capacitance\nAdditional capacitance can be added in parallel with the internal Sample-and-Hold capacitor (CHOLD) by using the ADCAP register. This register selects a digitally programmable capacitance that is added to the ADC conversion bus, increasing the effective internal capacitance of the Sample-and-Hold capacitor in the ADC module. This is used to improve the match between internal and external capacitance for a better sensing performance. The additional capacitance does not affect analog performance of the ADC because it is not connected during conversion.",
    "40.7 Register Definitions: ADC Control\nLong bit name prefixes for the ADC peripherals are shown in the following table. Refer to the 'Long Bit Names' section of the 'Register and Bit Naming Conventions' chapter for more information.\nTable 40-4. ADC Long Bit Name Prefixes\n\nADC, Bit Name Prefix = AD",
    "40.7.1 ADCON0\nName:\nADCON0\nAddress:\n0x3F3\nADC Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ON. , 2 = CONT. , 3 = . , 4 = CS. , 5 = . , 6 = FM. , 7 = . , 8 = GO. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = . Access, 8 = R/W/HC/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - ON ADC Enable\n1, Description = ADC is enabled. 0, Description = ADC is disabled",
    "Bit 6 - CONT ADC Continuous Operation Enable\n1, Description = GO is retriggered upon completion of each conversion trigger until ADTIF is set (if SOI is set) or until GO is cleared (regardless of the value of SOI). 0, Description = ADC is cleared upon completion of each conversion trigger",
    "Bit 4 - CS ADC Clock Selection\n1, Description = Clock supplied from ADCRC dedicated oscillator. 0, Description = Clock supplied by F OSC , divided according to ADCLK register",
    "Bit 2 - FM ADC Results Format/Alignment Selection\n1, Description = ADRES and ADPREV data are right justified. 0, Description = ADRES and ADPREV data are left justified, zero-filled",
    "Bit 0 - GO  ADC Conversion Status (1,2)\n1, Description = ADC conversion cycle in progress. Setting this bit starts an ADC conversion cycle. The bit is cleared by hardware as determined by the CONT bit. 0, Description = ADC conversion completed/not in progress",
    "Notes:\n1. This bit requires ON bit to be set.\n2. If cleared by software while a conversion is in progress, the results of the conversion up to this point will be transferred to ADRES and the state machine will be reset, but the ADIF Interrupt Flag bit will not be set; filter and threshold operations will not be performed.",
    "40.7.2 ADCON1\nName: Address:\nADCON1\n0x3F4\nADC Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PPOL. , 2 = IPEN. , 3 = GPOL. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = DSEN. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - PPOL Precharge Polarity\nAction During 1 st  Precharge Stage\nx, Condition = ADPRE = 0. x, Description = Bit has no effect. 1, Condition = ADPRE > 0. 1, Description = External analog I/O pin is connected to V DD . Internal AD sampling capacitor (C HOLD ) is connected. 0, Condition = ADPRE > 0. 0, Description = External analog I/O pin is connected to V SS . Internal AD sampling capacitor (C HOLD ) is connected to V DD .",
    "Bit 6 - IPEN A/D Inverted Precharge Enable\nx, Condition Description = DSEN = 0 Bit has no effect. 1, Condition Description = DSEN = 1 The precharge and guard signals in the second conversion cycle are the opposite polarity of the first cycle. 0, Condition Description = DSEN = 1 Both conversion cycles use the precharge and guards specified by PPOL and GPOL",
    "Bit 5 - GPOL Guard Ring Polarity Selection\n1, Description = ADC guard Ring outputs start as digital high during Precharge stage. 0, Description = ADC guard Ring outputs start as digital low during Precharge stage",
    "Bit 0 - DSEN Double-Sample Enable\n1, Description = Two conversions are processed as a pair. The selected computation is performed after every second conversion.. 0, Description = Selected computation is performed after every conversion",
    "40.7.3 ADCON2\nName: Address:\nADCON2 0x3F5",
    "ADC Control Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSIS. , 2 = CRS[2:0]. , 3 = CRS[2:0]. , 4 = CRS[2:0]. , 5 = ACLR. , 6 = MD[2:0]. , 7 = MD[2:0]. , 8 = MD[2:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W/HC. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PSIS ADC Previous Sample Input Select\n1, Description = ADFLTR is transferred to ADPREV at start-of-conversion. 0, Description = ADRES is transferred to ADPREV at start-of-conversion",
    "Bits 6:4 - CRS[2:0] ADC Accumulated Calculation Right Shift Select\n1 to 6, Condition = MD= 'b100. 1 to 6, Description = Low-pass filter time constant is 2 CRS , filter gain is 1:1 (2). 1 to 6, Condition = MD= 'b011 to 'b001. 1 to 6, Description = The accumulated value is right-shifted by CRS (divided by 2 CRS ) (1,2). x, Condition = MD= 'b000. x, Description = These bits are ignored",
    "Bit 3 - ACLR  A/D Accumulator Clear Command (3)\n1, Description = The ADACC and ADCNT registers and the AOV bit are cleared. 0, Description = Clearing action is complete (or not started)",
    "Bits 2:0 - MD[2:0]  ADC Operating Mode Selection (4)\n111-101, Description = Reserved. 100, Description = Low-Pass Filter mode. 011, Description = Burst Average mode. 010, Description = Average mode. 001, Description = Accumulate mode. 000, Description = Basic (Legacy) mode",
    "Notes:\n1. To correctly calculate an average, the number of samples (set in ADRPT) must be 2 CRS .\n2. CRS = 'b111 and 'b000 are reserved.\n3. This bit is cleared by hardware when the accumulator operation is complete; depending on oscillator selections, the delay may be many instructions.\n4. See the Computation Operation section for full mode descriptions.",
    "40.7.4 ADCON3\nName:\nADCON3\nAddress:\n0x3F6\nADC Control Register 3",
    "40.7.4 ADCON3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = CALC[2:0]. , 3 = CALC[2:0]. , 4 = CALC[2:0]. , 5 = SOI. , 6 = TMD[2:0]. , 7 = TMD[2:0]. , 8 = TMD[2:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W/HC. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 6:4 - CALC[2:0] ADC Error Calculation Mode Select\n111, ADERR.DSEN = 0 Single-Sample Mode = Reserved. 111, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = Reserved. 111, Application.Application = Reserved. 110, ADERR.DSEN = 0 Single-Sample Mode = Reserved. 110, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = Reserved. 110, Application.Application = Reserved. 101, ADERR.DSEN = 0 Single-Sample Mode = ADFLTR-ADSTPT. 101, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = ADFLTR-ADSTPT. 101, Application.Application = Average/filtered value vs. setpoint. 100, ADERR.DSEN = 0 Single-Sample Mode = ADPREV-ADFLTR. 100, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = ADPREV-ADFLTR. 100, Application.Application = First derivative of filtered value (3) (negative). 011, ADERR.DSEN",
    "Bits 6:4 - CALC[2:0] ADC Error Calculation Mode Select\n= 0 Single-Sample Mode = Reserved. 011, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = Reserved. 011, Application.Application = Reserved. 010, ADERR.DSEN = 0 Single-Sample Mode = ADRES-ADFLTR. 010, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = (ADRES-ADPREV)-ADFLTR. 010, Application.Application = Actual result vs. averaged/filtered value. 001, ADERR.DSEN = 0 Single-Sample Mode = ADRES-ADSTPT. 001, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = (ADRES-ADPREV)-ADSTPT. 001, Application.Application = Actual result vs. setpoint. 000, ADERR.DSEN = 0 Single-Sample Mode = ADRES-ADPREV. 000, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = ADRES-ADPREV. 000, Application.Application = First",
    "Bits 6:4 - CALC[2:0] ADC Error Calculation Mode Select\nderivative of single measurement (2) Actual CVD result (2)",
    "Notes:\n1. When DSEN = 1 and PSIS = 0 , ADERR is computed only after every second sample.\n2. When PSIS = 0 .\n3. When PSIS = 1 .",
    "Bit 3 - SOI ADC Stop-on-Interrupt\nx, Condition = CONT = 0. x, Description = This bit is not used. 1, Condition = CONT = 1. 1, Description = GO is cleared when the threshold conditions are met, otherwise the conversion is retriggered. 0, Condition = CONT = 1. 0, Description = GO is not cleared by hardware, must be cleared by software to stop retriggers",
    "Bits 2:0 - TMD[2:0] Threshold Interrupt Mode Select\n111, Description = Interrupt regardless of threshold test results. 110, Description = Interrupt if ADERR > ADUTH. 101, Description = Interrupt if ADERR \u2264 ADUTH. 100, Description = Interrupt if ADERR < ADLTH or ADERR > ADUTH. 011, Description = Interrupt if ADERR > ADLTH and ADERR < ADUTH. 010, Description = Interrupt if ADERR \u2265 ADLTH. 001, Description = Interrupt if ADERR < ADLTH. 000, Description = Never interrupt",
    "40.7.5 ADSTAT\nName: Address:\nADSTAT 0x3F7",
    "ADC Status Register\nAccess, 7.AOV = R/C/HS/HC. Access, 6.UTHR = R. Access, 5.LTHR = R. Access, 4.MATH = R/C/HS. Access, 3. = . Access, 2.STAT[2:0] = R. Access, 1.STAT[2:0] = R. Access, 0.STAT[2:0] = R. Reset, 7.AOV = 0. Reset, 6.UTHR = 0. Reset, 5.LTHR = 0. Reset, 4.MATH = 0. Reset, 3. = . Reset, 2.STAT[2:0] = 0. Reset, 1.STAT[2:0] = 0. Reset, 0.STAT[2:0] = 0",
    "Bit 7 - AOV ADC Accumulator Overflow\n1, Description = The ADACC or ADFLTR or ADERR registers have overflowed. 0, Description = The ADACC, ADFLTR and ADERR registers have not overflowed",
    "Bit 6 - UTHR ADC Module Greater-than Upper Threshold Flag\n1, Description = ADERR > ADUTH. 0, Description = ADERR \u2264 ADUTH",
    "Bit 5 - LTHR ADC Module Less-than Lower Threshold Flag\n1, Description = ADERR < ADLTH. 0, Description = ADERR \u2265 ADLTH",
    "Bit 4 - MATH ADC Module Computation Status\nADC Module Computation Status (1)\n1, Description = The ADACC, ADFLTR, ADUTH and ADLTH registers and the AOV bit are updating or have already updated. 0, Description = Associated registers/bits have not changed since this bit was last cleared",
    "Bits 2:0 - STAT[2:0] ADC Module Cycle Multi-Stage Status\n111, Description = ADC module is in 2 nd conversion stage. 110, Description = ADC module is in 2 nd acquisition stage. 101, Description = ADC module is in 2 nd precharge stage. 100, Description = ADC computation is suspended between 1 st and 2 nd sample; the computation results are incomplete and awaiting data from the 2 nd sample (2,3). 011, Description = ADC module is in 1 st conversion stage. 010, Description = ADC module is in 1 st acquisition stage. 001, Description = ADC module is in 1 st precharge stage. 000, Description = ADC module is not converting",
    "Notes:\n1. MATH bit cannot be cleared by software while STAT = 'b100 .\n2. If ADC clock source is ADCRC, and FOSC < ADCRC, the indicated status may not be valid.\n3. STAT = 'b100 appears between the two triggers when DSEN = 1 and CONT = 0 .",
    "40.7.6 ADCLK\nName:\nADCLK 0x3FA\nAddress:\nADC Clock divider Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = CS[5:0]. , 3 = CS[5:0]. , 4 = CS[5:0]. , 5 = CS[5:0]. , 6 = CS[5:0]. , 7 = CS[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - CS[5:0] ADC Clock divider Select\nn, Description = ADC Clock frequency = F OSC /(2*(n+1))\nNote: ADC Clock divider is only available if F OSC is selected as the ADC clock source (CS = 0 ).",
    "40.7.7 ADREF\nName:\nADREF\nAddress:\n0x3F8",
    "ADC Reference Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = NREF. , 5 = . , 6 = PREF[1:0]. , 7 = PREF[1:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0",
    "Bit 4 - NREF ADC Negative Voltage Reference Selection\n1, Description = V REF - is connected to external V REF -. 0, Description = V REF - is connected to AV SS",
    "Bits 1:0 - PREF[1:0] ADC Positive Voltage Reference Selection\n11, Description = V REF + is connected to internal Fixed Voltage Reference (FVR) module. 10, Description = V REF + is connected to external V REF +. 01, Description = Reserved. 00, Description = V REF + is connected to V DD",
    "40.7.8 ADPCH\nName: Address:\nADPCH\n0x3EC",
    "ADC Positive Channel Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PCH[7:0]. , 2 = PCH[7:0]. , 3 = PCH[7:0]. , 4 = PCH[7:0]. , 5 = PCH[7:0]. , 6 = PCH[7:0]. , 7 = PCH[7:0]. , 8 = PCH[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - PCH[7:0] ADC Positive Input Channel Selection\n11111111 - 10010100, ADC Positive Channel Input = Reserved. No channel connected.. 10010011, ADC Positive Channel Input = RC3 (OPA1IN1+) (6). 10010010 - 10010001, ADC Positive Channel Input = Reserved. No channel connected.. 10010000, ADC Positive Channel Input = RC0 (OPA1IN0+) (5,6). 10001111 - 10001110, ADC Positive Channel Input = Reserved. No channel connected.. 10001101, ADC Positive Channel Input = RB5 (OPA1IN0+) (4,6). 10001100 - 10000011, ADC Positive Channel Input = Reserved. No channel connected.. 10000010, ADC Positive Channel Input = RA2 (OPA1IN2+) (6). 10000001, ADC Positive Channel Input = Reserved. No channel connected.. 10000000, ADC Positive Channel Input = RA0 (OPA1IN3+) (6). 01111111 - 01000000, ADC Positive Channel Input =",
    "Bits 7:0 - PCH[7:0] ADC Positive Input Channel Selection\nReserved. No channel connected.. 00111111, ADC Positive Channel Input = Fixed Voltage Reference (FVR) Buffer 2 (1). 00111110, ADC Positive Channel Input = Fixed Voltage Reference (FVR) Buffer 1 (1). 00111101, ADC Positive Channel Input = DAC1 output (2). 00111100, ADC Positive Channel Input = Temperature Indicator (3). 00111011, ADC Positive Channel Input = V SS (Analog Ground). 00111010, ADC Positive Channel Input = DAC2 output (2). 00111001, ADC Positive Channel Input = OPA positive input source. 00111000 - 00011000, ADC Positive Channel Input = Reserved. No channel connected.. 00010111, ADC Positive Channel Input = RC7/ANC7 (4). 00010110, ADC Positive Channel Input = RC6/ANC6 (4). 00010101, ADC Positive Channel Input = RC5/ANC5. 00010100, ADC Positive Channel Input =",
    "Bits 7:0 - PCH[7:0] ADC Positive Input Channel Selection\nRC4/ANC4. 00010011, ADC Positive Channel Input = RC3/ANC3. 00010010, ADC Positive Channel Input = RC2/ANC2. 00010001, ADC Positive Channel Input = RC1/ANC1. 00010000, ADC Positive Channel Input = RC0/ANC0. 00001111, ADC Positive Channel Input = RB7/ANB7 (4). 00001110, ADC Positive Channel Input = RB6/ANB6 (4). 00001101, ADC Positive Channel Input = RB5/ANB5 (4). 00001100, ADC Positive Channel Input = RB4/ANB4 (4). 00001011 - 00000110, ADC Positive Channel Input = Reserved. No channel connected.. 00000101, ADC Positive Channel Input = RA5/ANA5. 00000100, ADC Positive Channel Input = RA4/ANA4. 00000011, ADC Positive Channel Input = RA3/ANA3. 00000010, ADC",
    "Bits 7:0 - PCH[7:0] ADC Positive Input Channel Selection\nPositive Channel Input = RA2/ANA2. 00000001, ADC Positive Channel Input = RA1/ANA1. 00000000, ADC Positive Channel Input = RA0/ANA0",
    "Bits 7:0 - PCH[7:0] ADC Positive Input Channel Selection\nNotes:, ...........continued.PCH = Notes:. Notes:,  = Notes:. 1., ...........continued.PCH = Refer to the 'Fixed Voltage Reference Module' chapter for more details.. 1.,  = Refer to the 'Fixed Voltage Reference Module' chapter for more details.. 2., ...........continued.PCH = Refer to the 'Digital-to-Analog Converter Module' chapter for more details.. 2.,  = Refer to the 'Digital-to-Analog Converter Module' chapter for more details.. 3., ...........continued.PCH = Refer to the 'Temperature Indicator Module' chapter for more details.. 3.,  = Refer to the 'Temperature Indicator Module' chapter for more details.. 4., ...........continued.PCH = 20-pin devices only.. 4.,",
    "Bits 7:0 - PCH[7:0] ADC Positive Input Channel Selection\n= 20-pin devices only.. 5., ...........continued.PCH = 14-pin devices only.. 5.,  = 14-pin devices only.. 6., ...........continued.PCH = This configuration routes the specified analog channel to the noninverting input of the OPA module (OPAxIN+), and connects the output of the OPA (OPAxOUT) to the input of the ADC for conversion. The OPA module must be configured accordingly to use this mode of operation. Refer to the \"OPA - Analog Signal Conditioning\" chapter for more details.. 6.,  = This configuration routes the specified analog channel to the noninverting input of the OPA module (OPAxIN+), and connects the output of the OPA (OPAxOUT) to the input of the ADC for conversion. The OPA module must be configured accordingly to use this mode of operation. Refer to the \"OPA - Analog Signal Conditioning\" chapter for more details.",
    "40.7.9 ADPRE\nName:\nADPRE\nAddress:\n0x3F1",
    "ADC Precharge Time Control Register\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12.PRE[12:8] = R/W. Access, 11.PRE[12:8] = R/W. Access, 10.PRE[12:8] = R/W. Access, 9.PRE[12:8] = R/W. Access, 8.PRE[12:8] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12.PRE[12:8] = 0. Reset, 11.PRE[12:8] = 0. Reset, 10.PRE[12:8] = 0. Reset, 9.PRE[12:8] = 0. Reset, 8.PRE[12:8] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12.PRE[12:8] = 4. Bit, 11.PRE[12:8] = 3. Bit, 10.PRE[12:8] = 2. Bit, 9.PRE[12:8] =",
    "ADC Precharge Time Control Register\n1. Bit, 8.PRE[12:8] = 0. , 15. = PRE[7:0]. , 14. = PRE[7:0]. , 13. = PRE[7:0]. , 12.PRE[12:8] = PRE[7:0]. , 11.PRE[12:8] = PRE[7:0]. , 10.PRE[12:8] = PRE[7:0]. , 9.PRE[12:8] = PRE[7:0]. , 8.PRE[12:8] = PRE[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12.PRE[12:8] = R/W. Access, 11.PRE[12:8] = R/W. Access, 10.PRE[12:8] = R/W. Access, 9.PRE[12:8] = R/W. Access, 8.PRE[12:8] = R/W. Reset, 15. = 0. Reset, 14. =",
    "ADC Precharge Time Control Register\n0. Reset, 13. = 0. Reset, 12.PRE[12:8] = 0. Reset, 11.PRE[12:8] = 0. Reset, 10.PRE[12:8] = 0. Reset, 9.PRE[12:8] = 0. Reset, 8.PRE[12:8] = 0",
    "Bits 12:0 - PRE[12:0] Precharge Time Select\n1 1111 1111 1111, Precharge Time.CS = 0 = 8191 clocks of F OSC. 1 1111 1111 1111, Precharge Time.CS = 1 = 8191 clocks of ADCRC. 1 1111 1111 1110, Precharge Time.CS = 0 = 8190 clocks of F OSC. 1 1111 1111 1110, Precharge Time.CS = 1 = 8190 clocks of ADCRC. 1 1111 1111 1101, Precharge Time.CS = 0 = 8189 clocks of F OSC. 1 1111 1111 1101, Precharge Time.CS = 1 = 8189 clocks of ADCRC. ..., Precharge Time.CS = 0 = .... ..., Precharge Time.CS = 1 = .... 0 0000 0000 0010, Precharge Time.CS = 0 = 2 clocks of F OSC. 0 0000 0000 0010, Precharge Time.CS = 1 = 2 clocks of ADCRC. 0 0000",
    "Bits 12:0 - PRE[12:0] Precharge Time Select\n0000 0001, Precharge Time.CS = 0 = 1 clocks of F OSC. 0 0000 0000 0001, Precharge Time.CS = 1 = 1 clocks of ADCRC. 0 0000 0000 0000, Precharge Time.CS = 0 = Not included in the data conversion cycle. 0 0000 0000 0000, Precharge Time.CS = 1 = Not included in the data conversion cycle\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n1. ADPREH: Accesses the high byte ADPRE[12:8].\n2. ADPREL: Accesses the low byte ADPRE[7:0].",
    "40.7.10  ADACQ\nName: Address:\nADACQ 0x3EE",
    "ADC Acquisition Time Control Register\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12.ACQ[12:8] = R/W. Access, 11.ACQ[12:8] = R/W. Access, 10.ACQ[12:8] = R/W. Access, 9.ACQ[12:8] = R/W. Access, 8.ACQ[12:8] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12.ACQ[12:8] = 0. Reset, 11.ACQ[12:8] = 0. Reset, 10.ACQ[12:8] = 0. Reset, 9.ACQ[12:8] = 0. Reset, 8.ACQ[12:8] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12.ACQ[12:8] = 4. Bit, 11.ACQ[12:8] = 3. Bit, 10.ACQ[12:8] = 2.",
    "ADC Acquisition Time Control Register\nBit, 9.ACQ[12:8] = 1. Bit, 8.ACQ[12:8] = 0. , 15. = ACQ[7:0]. , 14. = ACQ[7:0]. , 13. = ACQ[7:0]. , 12.ACQ[12:8] = ACQ[7:0]. , 11.ACQ[12:8] = ACQ[7:0]. , 10.ACQ[12:8] = ACQ[7:0]. , 9.ACQ[12:8] = ACQ[7:0]. , 8.ACQ[12:8] = ACQ[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12.ACQ[12:8] = R/W. Access, 11.ACQ[12:8] = R/W. Access, 10.ACQ[12:8] = R/W. Access, 9.ACQ[12:8] = R/W.",
    "ADC Acquisition Time Control Register\nAccess, 8.ACQ[12:8] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12.ACQ[12:8] = 0. Reset, 11.ACQ[12:8] = 0. Reset, 10.ACQ[12:8] = 0. Reset, 9.ACQ[12:8] = 0. Reset, 8.ACQ[12:8] = 0",
    "Bits 12:0 - ACQ[12:0] Acquisition (charge share time) Select\n1 1111 1111 1111, Acquisition Time.CS = 0 = 8191 clocks of F OSC. 1 1111 1111 1111, Acquisition Time.CS = 1 = 8191 clocks of ADCRC. 1 1111 1111 1110, Acquisition Time.CS = 0 = 8190 clocks of F OSC. 1 1111 1111 1110, Acquisition Time.CS = 1 = 8190 clocks of ADCRC. 1 1111 1111 1101, Acquisition Time.CS = 0 = 8189 clocks of F OSC. 1 1111 1111 1101, Acquisition Time.CS = 1 = 8189 clocks of ADCRC. ..., Acquisition Time.CS = 0 = .... ..., Acquisition Time.CS = 1 = .... 0 0000 0000 0010, Acquisition Time.CS = 0 = 2 clocks of F OSC. 0 0000 0000 0010, Acquisition Time.CS = 1 = 2 clocks of ADCRC. 0 0000 0000 0001, Acquisition Time.CS = 0 = 1 clocks of F",
    "Bits 12:0 - ACQ[12:0] Acquisition (charge share time) Select\nOSC. 0 0000 0000 0001, Acquisition Time.CS = 1 = 1 clocks of ADCRC. 0 0000 0000, Acquisition Time.CS = 0 = Not included in the data conversion cycle (1). 0 0000 0000, Acquisition Time.CS = 1 = Not included in the data conversion cycle (1). Note:, Acquisition Time.CS = 0 = . Note:, Acquisition Time.CS = 1 = \nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADACQH: Accesses the high byte ADACQ[12:8]\n\u00b7 ADACQL: Accesses the low byte ADACQ[7:0]",
    "40.7.11  ADCAP\nName:\nADCAP\nAddress:\n0x3F0",
    "ADC Additional Sample Capacitor Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - CAP[4:0] ADC Additional Sample Capacitor Selection\n1 to 31, Description = Number of pF in the additional capacitance. 0, Description = No additional capacitance",
    "40.7.12  ADRPT\nName: Address:\nADRPT 0x3E7",
    "ADC Repeat Setting Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RPT[7:0]. , 2 = RPT[7:0]. , 3 = RPT[7:0]. , 4 = RPT[7:0]. , 5 = RPT[7:0]. , 6 = RPT[7:0]. , 7 = RPT[7:0]. , 8 = RPT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - RPT[7:0] ADC Repeat Threshold\nDetermines the number of times the ADC is triggered for a threshold check. When CNT reaches this value, the error threshold is checked. Used when the computation mode is Low-Pass Filter, Burst Average, or Average. See the Computation Operation section for more details.",
    "40.7.13  ADCNT\nName: Address:\nADCNT\n0x3E6",
    "ADC Repeat Counter Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CNT[7:0]. , 2 = CNT[7:0]. , 3 = CNT[7:0]. , 4 = CNT[7:0]. , 5 = CNT[7:0]. , 6 = CNT[7:0]. , 7 = CNT[7:0]. , 8 = CNT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - CNT[7:0] ADC Repeat Count\nCounts the number of times the ADC is triggered before the threshold is checked. When this value reaches RPT, the threshold is checked. Used when the computation mode is Low-Pass Filter, Burst Average, or Average. See the Computation Operation section for more details.",
    "40.7.14  ADFLTR\nName: Address:\nADFLTR 0x3E1",
    "ADC Filter Register\nAccess, 15.FLTR[15:8] = R. Access, 14.FLTR[15:8] = R. Access, 13.FLTR[15:8] = R. Access, 12.FLTR[15:8] = R. Access, 11.FLTR[15:8] = R. Access, 10.FLTR[15:8] = R. Access, 9.FLTR[15:8] = R. Access, 8.FLTR[15:8] = R. Reset, 15.FLTR[15:8] = x. Reset, 14.FLTR[15:8] = x. Reset, 13.FLTR[15:8] = x. Reset, 12.FLTR[15:8] = x. Reset, 11.FLTR[15:8] = x. Reset, 10.FLTR[15:8] = x. Reset, 9.FLTR[15:8] = x. Reset, 8.FLTR[15:8] = x. Bit, 15.FLTR[15:8] = 7. Bit, 14.FLTR[15:8] = 6.",
    "ADC Filter Register\nBit, 13.FLTR[15:8] = 5. Bit, 12.FLTR[15:8] = 4. Bit, 11.FLTR[15:8] = 3. Bit, 10.FLTR[15:8] = 2. Bit, 9.FLTR[15:8] = 1. Bit, 8.FLTR[15:8] = 0. , 15.FLTR[15:8] = FLTR[7:0]. , 14.FLTR[15:8] = FLTR[7:0]. , 13.FLTR[15:8] = FLTR[7:0]. , 12.FLTR[15:8] = FLTR[7:0]. , 11.FLTR[15:8] = FLTR[7:0]. , 10.FLTR[15:8] = FLTR[7:0]. , 9.FLTR[15:8] = FLTR[7:0]. , 8.FLTR[15:8] = FLTR[7:0]. Access, 15.FLTR[15:8] = R. Access,",
    "ADC Filter Register\n14.FLTR[15:8] = R. Access, 13.FLTR[15:8] = R. Access, 12.FLTR[15:8] = R. Access, 11.FLTR[15:8] = R. Access, 10.FLTR[15:8] = R. Access, 9.FLTR[15:8] = R. Access, 8.FLTR[15:8] = R. Reset, 15.FLTR[15:8] = x. Reset, 14.FLTR[15:8] = x. Reset, 13.FLTR[15:8] = x. Reset, 12.FLTR[15:8] = x. Reset, 11.FLTR[15:8] = x. Reset, 10.FLTR[15:8] = x. Reset, 9.FLTR[15:8] = x. Reset, 8.FLTR[15:8] = x",
    "Bits 15:0 - FLTR[15:0] ADC Filter Output - Signed Two's Complement\nIn Accumulate, Average and Burst Average modes, this is equal to ACC right shifted by the CRS bits. In LPF mode, this is the output of the Low-Pass Filter.\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADFLTRH: Accesses the high byte ADFLTR[15:8]\n\u00b7 ADFLTRL: Accesses the low byte ADFLTR[7:0]",
    "40.7.15  ADRES\nName: Address:\nADRES 0x3EA",
    "ADC Result Register\nAccess, 15.RES[15:8] = R/W. Access, 14.RES[15:8] = R/W. Access, 13.RES[15:8] = R/W. Access, 12.RES[15:8] = R/W. Access, 11.RES[15:8] = R/W. Access, 10.RES[15:8] = R/W. Access, 9.RES[15:8] = R/W. Access, 8.RES[15:8] = R/W. Reset, 15.RES[15:8] = 0. Reset, 14.RES[15:8] = 0. Reset, 13.RES[15:8] = 0. Reset, 12.RES[15:8] = 0. Reset, 11.RES[15:8] = 0. Reset, 10.RES[15:8] = 0. Reset, 9.RES[15:8] = 0. Reset, 8.RES[15:8] = 0. Bit, 15.RES[15:8] = 7. Bit, 14.RES[15:8] = 6. Bit,",
    "ADC Result Register\n13.RES[15:8] = 5. Bit, 12.RES[15:8] = 4. Bit, 11.RES[15:8] = 3. Bit, 10.RES[15:8] = 2. Bit, 9.RES[15:8] = 1. Bit, 8.RES[15:8] = 0. , 15.RES[15:8] = RES[7:0]. , 14.RES[15:8] = RES[7:0]. , 13.RES[15:8] = RES[7:0]. , 12.RES[15:8] = RES[7:0]. , 11.RES[15:8] = RES[7:0]. , 10.RES[15:8] = RES[7:0]. , 9.RES[15:8] = RES[7:0]. , 8.RES[15:8] = RES[7:0]. Access, 15.RES[15:8] = R/W. Access, 14.RES[15:8] = R/W. Access, 13.RES[15:8]",
    "ADC Result Register\n= R/W. Access, 12.RES[15:8] = R/W. Access, 11.RES[15:8] = R/W. Access, 10.RES[15:8] = R/W. Access, 9.RES[15:8] = R/W. Access, 8.RES[15:8] = R/W. Reset, 15.RES[15:8] = 0. Reset, 14.RES[15:8] = 0. Reset, 13.RES[15:8] = 0. Reset, 12.RES[15:8] = 0. Reset, 11.RES[15:8] = 0. Reset, 10.RES[15:8] = 0. Reset, 9.RES[15:8] = 0. Reset, 8.RES[15:8] = 0",
    "Bits 15:0 - RES[15:0] ADC Sample Result\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADRESH: Accesses the high byte ADRES[15:18]\n\u00b7 ADRESL: Accesses the low byte ADRES[7:0]",
    "40.7.16  ADPREV\nName: Address:\nADPREV 0x3E8",
    "ADC Previous Result Register\nAccess, 15.PREV[15:8] = R. Access, 14.PREV[15:8] = R. Access, 13.PREV[15:8] = R. Access, 12.PREV[15:8] = R. Access, 11.PREV[15:8] = R. Access, 10.PREV[15:8] = R. Access, 9.PREV[15:8] = R. Access, 8.PREV[15:8] = R. Reset, 15.PREV[15:8] = 0. Reset, 14.PREV[15:8] = 0. Reset, 13.PREV[15:8] = 0. Reset, 12.PREV[15:8] = 0. Reset, 11.PREV[15:8] = 0. Reset, 10.PREV[15:8] = 0. Reset, 9.PREV[15:8] = 0. Reset, 8.PREV[15:8] = 0. Bit, 15.PREV[15:8] = 7. Bit, 14.PREV[15:8] =",
    "ADC Previous Result Register\n6. Bit, 13.PREV[15:8] = 5. Bit, 12.PREV[15:8] = 4. Bit, 11.PREV[15:8] = 3. Bit, 10.PREV[15:8] = 2. Bit, 9.PREV[15:8] = 1. Bit, 8.PREV[15:8] = 0. , 15.PREV[15:8] = PREV[7:0]. , 14.PREV[15:8] = PREV[7:0]. , 13.PREV[15:8] = PREV[7:0]. , 12.PREV[15:8] = PREV[7:0]. , 11.PREV[15:8] = PREV[7:0]. , 10.PREV[15:8] = PREV[7:0]. , 9.PREV[15:8] = PREV[7:0]. , 8.PREV[15:8] = PREV[7:0]. Access, 15.PREV[15:8] =",
    "ADC Previous Result Register\nR. Access, 14.PREV[15:8] = R. Access, 13.PREV[15:8] = R. Access, 12.PREV[15:8] = R. Access, 11.PREV[15:8] = R. Access, 10.PREV[15:8] = R. Access, 9.PREV[15:8] = R. Access, 8.PREV[15:8] = R. Reset, 15.PREV[15:8] = 0. Reset, 14.PREV[15:8] = 0. Reset, 13.PREV[15:8] = 0. Reset, 12.PREV[15:8] = 0. Reset, 11.PREV[15:8] = 0. Reset, 10.PREV[15:8] = 0. Reset, 9.PREV[15:8] = 0. Reset, 8.PREV[15:8] = 0",
    "Bits 15:0 - PREV[15:0] Previous ADC Result\nn, Condition = PSIS = 1. n, Description = n = ADFLTR value at the start of current ADC conversion. n, Condition = PSIS = 0. n, Description = n = ADRES at the start of current ADC conversion (1)",
    "Notes:\n1. If PSIS = 0 , ADPREV is formatted the same way as ADRES is, depending on the FM bit.\n2. The individual bytes in this multibyte register can be accessed with the following register names:\n-ADPREVH: Accesses ADPREV[15:8]\n-ADPREVL: Accesses ADPREV[7:0]",
    "40.7.17  ADACC\nName:\nADACC\nAddress:\n0x3E3\nADC Accumulator Register (1)\nSee the Computation Operation section for more details.\nImportant: This register contains signed two's complement accumulator value and the upper unused bits contain copies of the sign bit.",
    "40.7.17  ADACC\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20. = . Access, 19. = . Access, 18. = . Access, 17.ACC[17:16] = R/W. Access, 16.ACC[17:16] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20. = . Reset, 19. = . Reset, 18. = . Reset, 17.ACC[17:16] = x. Reset, 16.ACC[17:16] = x. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20. = 12. Bit, 19. = 11. Bit, 18. = 10. Bit, 17.ACC[17:16] = 9. Bit, 16.ACC[17:16] = 8. , 23. = ACC[15:8]. , 22. = ACC[15:8]. , 21. = ACC[15:8]. , 20. = ACC[15:8]. , 19. =",
    "40.7.17  ADACC\nACC[15:8]. , 18. = ACC[15:8]. , 17.ACC[17:16] = ACC[15:8]. , 16.ACC[17:16] = ACC[15:8]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20. = R/W. Access, 19. = R/W. Access, 18. = R/W. Access, 17.ACC[17:16] = R/W. Access, 16.ACC[17:16] = R/W. Reset, 23. = x. Reset, 22. = x. Reset, 21. = x. Reset, 20. = x. Reset, 19. = x. Reset, 18. = x. Reset, 17.ACC[17:16] = x. Reset, 16.ACC[17:16] = x. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20. = 4. Bit, 19. = 3. Bit, 18. = 2. Bit,",
    "40.7.17  ADACC\n17.ACC[17:16] = 1. Bit, 16.ACC[17:16] = 0. , 23. = ACC[7:0]. , 22. = ACC[7:0]. , 21. = ACC[7:0]. , 20. = ACC[7:0]. , 19. = ACC[7:0]. , 18. = ACC[7:0]. , 17.ACC[17:16] = ACC[7:0]. , 16.ACC[17:16] = ACC[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20. = R/W. Access, 19. = R/W. Access, 18. = R/W. Access, 17.ACC[17:16] = R/W. Access, 16.ACC[17:16] = R/W. Reset, 23. = x. Reset, 22. = x. Reset, 21. = x. Reset, 20. = x. Reset, 19. = x. Reset, 18. =",
    "40.7.17  ADACC\nx. Reset, 17.ACC[17:16] = x. Reset, 16.ACC[17:16] = x\nBits 17:0 - ACC[17:0] ADC Accumulator - Signed Two's Complement",
    "Notes:\n1. This register can only be written when GO = 0 .\n2. The individual bytes in this multibyte register can be accessed with the following register names:\n-ADACCU: Accesses the upper byte ADACC[17:16]\n-ADACCH: Accesses the high byte ADACC[15:8]\n-ADACCL: Accesses the low byte ADACC[7:0]",
    "40.7.18  ADSTPT\nName: Address:\nADSTPT 0x3DF\nADC Threshold Setpoint Register Depending on CALC, may be used to determine ADERR.",
    "40.7.18  ADSTPT\nAccess, 15.STPT[15:8] = R/W. Access, 14.STPT[15:8] = R/W. Access, 13.STPT[15:8] = R/W. Access, 12.STPT[15:8] = R/W. Access, 11.STPT[15:8] = R/W. Access, 10.STPT[15:8] = R/W. Access, 9.STPT[15:8] = R/W. Access, 8.STPT[15:8] = R/W. Reset, 15.STPT[15:8] = 0. Reset, 14.STPT[15:8] = 0. Reset, 13.STPT[15:8] = 0. Reset, 12.STPT[15:8] = 0. Reset, 11.STPT[15:8] = 0. Reset, 10.STPT[15:8] = 0. Reset, 9.STPT[15:8] = 0. Reset, 8.STPT[15:8] = 0. Bit,",
    "40.7.18  ADSTPT\n15.STPT[15:8] = 7. Bit, 14.STPT[15:8] = 6. Bit, 13.STPT[15:8] = 5. Bit, 12.STPT[15:8] = 4. Bit, 11.STPT[15:8] = 3. Bit, 10.STPT[15:8] = 2. Bit, 9.STPT[15:8] = 1. Bit, 8.STPT[15:8] = 0. , 15.STPT[15:8] = STPT[7:0]. , 14.STPT[15:8] = STPT[7:0]. , 13.STPT[15:8] = STPT[7:0]. , 12.STPT[15:8] = STPT[7:0]. , 11.STPT[15:8] = STPT[7:0]. , 10.STPT[15:8] = STPT[7:0]. , 9.STPT[15:8] = STPT[7:0]. ,",
    "40.7.18  ADSTPT\n8.STPT[15:8] = STPT[7:0]. Access, 15.STPT[15:8] = R/W. Access, 14.STPT[15:8] = R/W. Access, 13.STPT[15:8] = R/W. Access, 12.STPT[15:8] = R/W. Access, 11.STPT[15:8] = R/W. Access, 10.STPT[15:8] = R/W. Access, 9.STPT[15:8] = R/W. Access, 8.STPT[15:8] = R/W. Reset, 15.STPT[15:8] = 0. Reset, 14.STPT[15:8] = 0. Reset, 13.STPT[15:8] = 0. Reset, 12.STPT[15:8] = 0. Reset, 11.STPT[15:8] = 0. Reset, 10.STPT[15:8] = 0. Reset, 9.STPT[15:8] = 0. Reset,",
    "40.7.18  ADSTPT\n8.STPT[15:8] = 0\nBits 15:0 - STPT[15:0] ADC Threshold Setpoint - Signed Two's Complement\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADSTPTH: Accesses the high byte ADSTPT[15:8]\n\u00b7 ADSTPTH: Accesses the low byte ADSTPT[7:0]",
    "40.7.19  ADERR\nName: Address:\nADERR 0x3DD\nADC Setpoint Error Register\nADC Setpoint Error calculation is determined by the CALC bits.",
    "40.7.19  ADERR\nAccess, 15.ERR[15:8] = R. Access, 14.ERR[15:8] = R. Access, 13.ERR[15:8] = R. Access, 12.ERR[15:8] = R. Access, 11.ERR[15:8] = R. Access, 10.ERR[15:8] = R. Access, 9.ERR[15:8] = R. Access, 8.ERR[15:8] = R. Reset, 15.ERR[15:8] = x. Reset, 14.ERR[15:8] = x. Reset, 13.ERR[15:8] = x. Reset, 12.ERR[15:8] = x. Reset, 11.ERR[15:8] = x. Reset, 10.ERR[15:8] = x. Reset, 9.ERR[15:8] = x. Reset, 8.ERR[15:8] = x. Bit, 15.ERR[15:8] = 7. Bit,",
    "40.7.19  ADERR\n14.ERR[15:8] = 6. Bit, 13.ERR[15:8] = 5. Bit, 12.ERR[15:8] = 4. Bit, 11.ERR[15:8] = 3. Bit, 10.ERR[15:8] = 2. Bit, 9.ERR[15:8] = 1. Bit, 8.ERR[15:8] = 0. , 15.ERR[15:8] = ERR[7:0]. , 14.ERR[15:8] = ERR[7:0]. , 13.ERR[15:8] = ERR[7:0]. , 12.ERR[15:8] = ERR[7:0]. , 11.ERR[15:8] = ERR[7:0]. , 10.ERR[15:8] = ERR[7:0]. , 9.ERR[15:8] = ERR[7:0]. , 8.ERR[15:8] = ERR[7:0].",
    "40.7.19  ADERR\nAccess, 15.ERR[15:8] = R. Access, 14.ERR[15:8] = R. Access, 13.ERR[15:8] = R. Access, 12.ERR[15:8] = R. Access, 11.ERR[15:8] = R. Access, 10.ERR[15:8] = R. Access, 9.ERR[15:8] = R. Access, 8.ERR[15:8] = R. Reset, 15.ERR[15:8] = x. Reset, 14.ERR[15:8] = x. Reset, 13.ERR[15:8] = x. Reset, 12.ERR[15:8] = x. Reset, 11.ERR[15:8] = x. Reset, 10.ERR[15:8] = x. Reset, 9.ERR[15:8] = x. Reset, 8.ERR[15:8] = x\nBits 15:0 - ERR[15:0] ADC Setpoint Error - Signed Two's Complement",
    "40.7.19  ADERR\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADERRH: Accesses the high byte ADERR[15:8]\n\u00b7 ADERRL: Accesses the low byte ADERR[7:0]",
    "40.7.20  ADLTH\nName: Address:\nADLTH\n0x3D9\nADC Lower Threshold Register\nADLTH and ADUTH are compared with ADERR to set the UTHR and LTHR bits. Depending on the setting of TMD, an interrupt may be triggered by the results of this comparison.",
    "40.7.20  ADLTH\nAccess, 15.LTH[15:8] = R/W. Access, 14.LTH[15:8] = R/W. Access, 13.LTH[15:8] = R/W. Access, 12.LTH[15:8] = R/W. Access, 11.LTH[15:8] = R/W. Access, 10.LTH[15:8] = R/W. Access, 9.LTH[15:8] = R/W. Access, 8.LTH[15:8] = R/W. Reset, 15.LTH[15:8] = 0. Reset, 14.LTH[15:8] = 0. Reset, 13.LTH[15:8] = 0. Reset, 12.LTH[15:8] = 0. Reset, 11.LTH[15:8] = 0. Reset, 10.LTH[15:8] = 0. Reset, 9.LTH[15:8] = 0. Reset, 8.LTH[15:8] = 0. Bit,",
    "40.7.20  ADLTH\n15.LTH[15:8] = 7. Bit, 14.LTH[15:8] = 6. Bit, 13.LTH[15:8] = 5. Bit, 12.LTH[15:8] = 4. Bit, 11.LTH[15:8] = 3. Bit, 10.LTH[15:8] = 2. Bit, 9.LTH[15:8] = 1. Bit, 8.LTH[15:8] = 0. , 15.LTH[15:8] = LTH[7:0]. , 14.LTH[15:8] = LTH[7:0]. , 13.LTH[15:8] = LTH[7:0]. , 12.LTH[15:8] = LTH[7:0]. , 11.LTH[15:8] = LTH[7:0]. , 10.LTH[15:8] = LTH[7:0]. , 9.LTH[15:8] = LTH[7:0]. ,",
    "40.7.20  ADLTH\n8.LTH[15:8] = LTH[7:0]. Access, 15.LTH[15:8] = R/W. Access, 14.LTH[15:8] = R/W. Access, 13.LTH[15:8] = R/W. Access, 12.LTH[15:8] = R/W. Access, 11.LTH[15:8] = R/W. Access, 10.LTH[15:8] = R/W. Access, 9.LTH[15:8] = R/W. Access, 8.LTH[15:8] = R/W. Reset, 15.LTH[15:8] = 0. Reset, 14.LTH[15:8] = 0. Reset, 13.LTH[15:8] = 0. Reset, 12.LTH[15:8] = 0. Reset, 11.LTH[15:8] = 0. Reset, 10.LTH[15:8] = 0. Reset, 9.LTH[15:8] = 0. Reset,",
    "40.7.20  ADLTH\n8.LTH[15:8] = 0\nBits 15:0 - LTH[15:0] ADC Lower Threshold - Signed Two's Complement\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADLTHH: Accesses the high byte ADLTH[15:8]\n\u00b7 ADLTHL: Accesses the low byte ADLTH[7:0]",
    "40.7.21  ADUTH\nName: Address:\nADUTH 0x3DB\nADC Upper Threshold Register\nADLTH and ADUTH are compared with ADERR to set the UTHR and LTHR bits. Depending on the setting of TMD, an interrupt may be triggered by the results of this comparison.",
    "40.7.21  ADUTH\nAccess, 15.UTH[15:8] = R/W. Access, 14.UTH[15:8] = R/W. Access, 13.UTH[15:8] = R/W. Access, 12.UTH[15:8] = R/W. Access, 11.UTH[15:8] = R/W. Access, 10.UTH[15:8] = R/W. Access, 9.UTH[15:8] = R/W. Access, 8.UTH[15:8] = R/W. Reset, 15.UTH[15:8] = 0. Reset, 14.UTH[15:8] = 0. Reset, 13.UTH[15:8] = 0. Reset, 12.UTH[15:8] = 0. Reset, 11.UTH[15:8] = 0. Reset, 10.UTH[15:8] = 0. Reset, 9.UTH[15:8] = 0. Reset, 8.UTH[15:8] = 0. Bit,",
    "40.7.21  ADUTH\n15.UTH[15:8] = 7. Bit, 14.UTH[15:8] = 6. Bit, 13.UTH[15:8] = 5. Bit, 12.UTH[15:8] = 4. Bit, 11.UTH[15:8] = 3. Bit, 10.UTH[15:8] = 2. Bit, 9.UTH[15:8] = 1. Bit, 8.UTH[15:8] = 0. , 15.UTH[15:8] = UTH[7:0]. , 14.UTH[15:8] = UTH[7:0]. , 13.UTH[15:8] = UTH[7:0]. , 12.UTH[15:8] = UTH[7:0]. , 11.UTH[15:8] = UTH[7:0]. , 10.UTH[15:8] = UTH[7:0]. , 9.UTH[15:8] = UTH[7:0]. ,",
    "40.7.21  ADUTH\n8.UTH[15:8] = UTH[7:0]. Access, 15.UTH[15:8] = R/W. Access, 14.UTH[15:8] = R/W. Access, 13.UTH[15:8] = R/W. Access, 12.UTH[15:8] = R/W. Access, 11.UTH[15:8] = R/W. Access, 10.UTH[15:8] = R/W. Access, 9.UTH[15:8] = R/W. Access, 8.UTH[15:8] = R/W. Reset, 15.UTH[15:8] = 0. Reset, 14.UTH[15:8] = 0. Reset, 13.UTH[15:8] = 0. Reset, 12.UTH[15:8] = 0. Reset, 11.UTH[15:8] = 0. Reset, 10.UTH[15:8] = 0. Reset, 9.UTH[15:8] = 0. Reset,",
    "40.7.21  ADUTH\n8.UTH[15:8] = 0\nBits 15:0 - UTH[15:0] ADC Upper Threshold - Signed Two's Complement\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADUTHH: Accesses the high byte ADUTH[15:8]\n\u00b7 ADUTHL: Accesses the low byte ADUTH[7:0]",
    "40.7.22  ADACT\nName: Address:\nADACT 0x3F9\nADC Auto Conversion Trigger Source Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - ACT[4:0] Auto-Conversion Trigger Select\n11111 - 11010, Auto-Conversion Trigger Source = Reserved. 11001, Auto-Conversion Trigger Source = Software write to ADPCH. 11000, Auto-Conversion Trigger Source = Software read of ADRESH. 10111, Auto-Conversion Trigger Source = Software read of ADERRH. 10110, Auto-Conversion Trigger Source = CLC4_OUT. 10101, Auto-Conversion Trigger Source = CLC3_OUT. 10100, Auto-Conversion Trigger Source = CLC2_OUT. 10011, Auto-Conversion Trigger Source = CLC1_OUT. 10010, Auto-Conversion Trigger Source = Interrupt-on-change Interrupt Flag. 10001, Auto-Conversion Trigger Source = CMP2_OUT. 10000, Auto-Conversion Trigger Source = CMP1_OUT. 01111, Auto-Conversion Trigger Source = NCO1_OUT. 01110, Auto-Conversion Trigger Source = PWM3S1P2_OUT. 01101, Auto-Conversion Trigger Source = PWM3S1P1_OUT. 01100, Auto-Conversion Trigger Source =",
    "Bits 4:0 - ACT[4:0] Auto-Conversion Trigger Select\nPWM2S1P2_OUT. 01011, Auto-Conversion Trigger Source = PWM2S1P1_OUT. 01010, Auto-Conversion Trigger Source = PWM1S1P2_OUT. 01001, Auto-Conversion Trigger Source = PWM1S1P1_OUT. 01000, Auto-Conversion Trigger Source = CCP1_trigger. 00111, Auto-Conversion Trigger Source = SMT1_overflow. 00110, Auto-Conversion Trigger Source = TMR4_postscaled. 00101, Auto-Conversion Trigger Source = TMR3_overflow. 00100, Auto-Conversion Trigger Source = TMR2_postscaled. 00011, Auto-Conversion Trigger Source = TMR1_overflow. 00010, Auto-Conversion Trigger Source = TMR0_overflow. 00001, Auto-Conversion Trigger Source = Pin selected by ADACTPPS. 00000, Auto-Conversion Trigger Source = External Trigger Disabled",
    "40.7.23  ADCP\nName:\nADCP\nAddress:\n0x3D8",
    "ADC Charge Pump Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CPON. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 8 = CPRDY. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - CPON Charge Pump On Control\n1, Description = Charge Pump On when requested by the ADC. 0, Description = Charge Pump Off",
    "Bit 0 - CPRDY Charge Pump Ready Status\n1, Description = Charge Pump is ready. 0, Description = Charge Pump is not ready (or never started)",
    "40.8 Register Summary - ADC\n0x00 ... 0x03D7, Name = Reserved. 0x00 ... 0x03D7, Bit Pos. = . 0x00 ... 0x03D7, 7 = . 0x00 ... 0x03D7, 6 = . 0x00 ... 0x03D7, 5 = . 0x00 ... 0x03D7, 4 = . 0x00 ... 0x03D7, 2 = . 0x00 ... 0x03D7, 1 = . 0x00 ... 0x03D7, 0 = . 0x03D8, Name = ADCP. 0x03D8, Bit Pos. = 7:0. 0x03D8, 7 = CPON. 0x03D8, 6 = . 0x03D8, 5 = . 0x03D8, 4 = . 0x03D8, 2 = . 0x03D8, 1 = . 0x03D8, 0 = CPRDY. 0x03D9, Name = ADLTH.",
    "40.8 Register Summary - ADC\n0x03D9, Bit Pos. = 7:0. 0x03D9, 7 = . 0x03D9, 6 = . 0x03D9, 5 = . 0x03D9, 4 = LTH[7:0]. 0x03D9, 2 = . 0x03D9, 1 = . 0x03D9, 0 = . 0x03D9, Name = ADLTH. 0x03D9, Bit Pos. = 15:8. 0x03D9, 7 = . 0x03D9, 6 = . 0x03D9, 5 = . 0x03D9, 4 = LTH[15:8]. 0x03D9, 2 = . 0x03D9, 1 = . 0x03D9, 0 = . 0x03DB, Name = ADUTH. 0x03DB, Bit Pos. = 7:0. 0x03DB, 7 = . 0x03DB, 6 = . 0x03DB, 5 = . 0x03DB, 4 =",
    "40.8 Register Summary - ADC\nUTH[7:0]. 0x03DB, 2 = . 0x03DB, 1 = . 0x03DB, 0 = . 0x03DB, Name = ADUTH. 0x03DB, Bit Pos. = 15:8. 0x03DB, 7 = . 0x03DB, 6 = . 0x03DB, 5 = . 0x03DB, 4 = UTH[15:8]. 0x03DB, 2 = . 0x03DB, 1 = . 0x03DB, 0 = . 0x03DD, Name = ADERR. 0x03DD, Bit Pos. = 7:0. 0x03DD, 7 = . 0x03DD, 6 = . 0x03DD, 5 = . 0x03DD, 4 = ERR[7:0]. 0x03DD, 2 = . 0x03DD, 1 = . 0x03DD, 0 = . 0x03DD, Name = ADERR. 0x03DD, Bit",
    "40.8 Register Summary - ADC\nPos. = 15:8. 0x03DD, 7 = . 0x03DD, 6 = . 0x03DD, 5 = . 0x03DD, 4 = ERR[15:8]. 0x03DD, 2 = . 0x03DD, 1 = . 0x03DD, 0 = . 0x03DF, Name = ADSTPT. 0x03DF, Bit Pos. = 7:0. 0x03DF, 7 = . 0x03DF, 6 = . 0x03DF, 5 = . 0x03DF, 4 = STPT[7:0]. 0x03DF, 2 = . 0x03DF, 1 = . 0x03DF, 0 = . 0x03DF, Name = ADSTPT. 0x03DF, Bit Pos. = 15:8. 0x03DF, 7 = . 0x03DF, 6 = . 0x03DF, 5 = . 0x03DF, 4 = STPT[15:8].",
    "40.8 Register Summary - ADC\n0x03DF, 2 = . 0x03DF, 1 = . 0x03DF, 0 = . 0x03E1, Name = ADFLTR. 0x03E1, Bit Pos. = 7:0. 0x03E1, 7 = . 0x03E1, 6 = . 0x03E1, 5 = . 0x03E1, 4 = FLTR[7:0]. 0x03E1, 2 = . 0x03E1, 1 = . 0x03E1, 0 = . 0x03E1, Name = ADFLTR. 0x03E1, Bit Pos. = 15:8. 0x03E1, 7 = . 0x03E1, 6 = . 0x03E1, 5 = . 0x03E1, 4 = FLTR[15:8]. 0x03E1, 2 = . 0x03E1, 1 = . 0x03E1, 0 = . 0x03E3, Name =",
    "40.8 Register Summary - ADC\nADACC. 0x03E3, Bit Pos. = 7:0. 0x03E3, 7 = . 0x03E3, 6 = . 0x03E3, 5 = . 0x03E3, 4 = ACC[7:0]. 0x03E3, 2 = . 0x03E3, 1 = . 0x03E3, 0 = . 0x03E3, Name = ADACC. 0x03E3, Bit Pos. = 15:8. 0x03E3, 7 = . 0x03E3, 6 = . 0x03E3, 5 = . 0x03E3, 4 = ACC[15:8]. 0x03E3, 2 = . 0x03E3, 1 = . 0x03E3, 0 = . 0x03E3, Name = ADACC. 0x03E3, Bit Pos. = 23:16. 0x03E3, 7 = . 0x03E3, 6 = .",
    "40.8 Register Summary - ADC\n0x03E3, 5 = . 0x03E3, 4 = . 0x03E3, 2 = . 0x03E3, 1 = ACC[17:16]. 0x03E3, 0 = . 0x03E6, Name = ADCNT. 0x03E6, Bit Pos. = 7:0. 0x03E6, 7 = . 0x03E6, 6 = . 0x03E6, 5 = . 0x03E6, 4 = CNT[7:0]. 0x03E6, 2 = . 0x03E6, 1 = . 0x03E6, 0 = . 0x03E7, Name = ADRPT. 0x03E7, Bit Pos. = 7:0. 0x03E7, 7 = . 0x03E7, 6 = . 0x03E7, 5 = . 0x03E7, 4 = RPT[7:0]. 0x03E7, 2 = .",
    "40.8 Register Summary - ADC\n0x03E7, 1 = . 0x03E7, 0 = . 0x03E8, Name = ADPREV. 0x03E8, Bit Pos. = 7:0. 0x03E8, 7 = . 0x03E8, 6 = . 0x03E8, 5 = . 0x03E8, 4 = PREV[7:0]. 0x03E8, 2 = . 0x03E8, 1 = . 0x03E8, 0 = . 0x03E8, Name = ADPREV. 0x03E8, Bit Pos. = 15:8. 0x03E8, 7 = . 0x03E8, 6 = . 0x03E8, 5 = . 0x03E8, 4 = PREV[15:8]. 0x03E8, 2 = . 0x03E8, 1 = . 0x03E8, 0 = . 0x03EA, Name = ADRES.",
    "40.8 Register Summary - ADC\n0x03EA, Bit Pos. = 7:0. 0x03EA, 7 = . 0x03EA, 6 = . 0x03EA, 5 = . 0x03EA, 4 = RES[7:0]. 0x03EA, 2 = . 0x03EA, 1 = . 0x03EA, 0 = . 0x03EA, Name = ADRES. 0x03EA, Bit Pos. = 15:8. 0x03EA, 7 = . 0x03EA, 6 = . 0x03EA, 5 = . 0x03EA, 4 = RES[15:8]. 0x03EA, 2 = . 0x03EA, 1 = . 0x03EA, 0 = . 0x03EC, Name = ADPCH. 0x03EC, Bit Pos. = 7:0. 0x03EC, 7 = . 0x03EC, 6 = . 0x03EC, 5 = . 0x03EC, 4 =",
    "40.8 Register Summary - ADC\nPCH[7:0]. 0x03EC, 2 = . 0x03EC, 1 = . 0x03EC, 0 = . 0x03ED, Name = Reserved. 0x03ED, Bit Pos. = . 0x03ED, 7 = . 0x03ED, 6 = . 0x03ED, 5 = . 0x03ED, 4 = . 0x03ED, 2 = . 0x03ED, 1 = . 0x03ED, 0 = . 0x03EE, Name = ADACQ. 0x03EE, Bit Pos. = 7:0. 0x03EE, 7 = . 0x03EE, 6 = . 0x03EE, 5 = . 0x03EE, 4 = ACQ[7:0]. 0x03EE, 2 = . 0x03EE, 1 = . 0x03EE, 0 = . 0x03EE, Name = ADACQ. 0x03EE, Bit Pos. = 15:8.",
    "40.8 Register Summary - ADC\n0x03EE, 7 = . 0x03EE, 6 = . 0x03EE, 5 = . 0x03EE, 4 = . 0x03EE, 2 = ACQ[12:8]. 0x03EE, 1 = . 0x03EE, 0 = . 0x03F0, Name = ADCAP. 0x03F0, Bit Pos. = 7:0. 0x03F0, 7 = . 0x03F0, 6 = . 0x03F0, 5 = . 0x03F0, 4 = . 0x03F0, 2 = CAP[4:0]. 0x03F0, 1 = . 0x03F0, 0 = . 0x03F1, Name = ADPRE. 0x03F1, Bit Pos. = 7:0. 0x03F1, 7 = . 0x03F1, 6 = . 0x03F1, 5 = . 0x03F1, 4 = PRE[7:0].",
    "40.8 Register Summary - ADC\n0x03F1, 2 = . 0x03F1, 1 = . 0x03F1, 0 = . 0x03F1, Name = ADPRE. 0x03F1, Bit Pos. = 15:8. 0x03F1, 7 = . 0x03F1, 6 = . 0x03F1, 5 = . 0x03F1, 4 = . 0x03F1, 2 = PRE[12:8]. 0x03F1, 1 = . 0x03F1, 0 = . 0x03F3, Name = ADCON0. 0x03F3, Bit Pos. = 7:0. 0x03F3, 7 = ON. 0x03F3, 6 = CONT. 0x03F3, 5 = . 0x03F3, 4 = CS. 0x03F3, 2 = FM. 0x03F3, 1 = . 0x03F3, 0 = GO. 0x03F4, Name =",
    "40.8 Register Summary - ADC\nADCON1. 0x03F4, Bit Pos. = 7:0. 0x03F4, 7 = PPOL. 0x03F4, 6 = IPEN. 0x03F4, 5 = GPOL. 0x03F4, 4 = . 0x03F4, 2 = . 0x03F4, 1 = . 0x03F4, 0 = DSEN. 0x03F5, Name = ADCON2. 0x03F5, Bit Pos. = 7:0. 0x03F5, 7 = PSIS. 0x03F5, 6 = . 0x03F5, 5 = CRS[2:0]. 0x03F5, 4 = ACLR. 0x03F5, 2 = . 0x03F5, 1 = MD[2:0]. 0x03F5, 0 = . 0x03F6, Name = ADCON3. 0x03F6, Bit Pos. = 7:0.",
    "40.8 Register Summary - ADC\n0x03F6, 7 = . 0x03F6, 6 = . 0x03F6, 5 = CALC[2:0]. 0x03F6, 4 = SOI. 0x03F6, 2 = . 0x03F6, 1 = TMD[2:0]. 0x03F6, 0 = . 0x03F7, Name = ADSTAT. 0x03F7, Bit Pos. = 7:0. 0x03F7, 7 = AOV. 0x03F7, 6 = UTHR. 0x03F7, 5 = LTHR. 0x03F7, 4 = MATH. 0x03F7, 2 = . 0x03F7, 1 = STAT[2:0]. 0x03F7, 0 = . 0x03F8, Name = ADREF. 0x03F8, Bit Pos. = 7:0. 0x03F8, 7 = . 0x03F8, 6 = .",
    "40.8 Register Summary - ADC\n0x03F8, 5 = . 0x03F8, 4 = NREF. 0x03F8, 2 = . 0x03F8, 1 = PREF[1:0]. 0x03F8, 0 = PREF[1:0]. 0x03F9, Name = ADACT. 0x03F9, Bit Pos. = 7:0. 0x03F9, 7 = . 0x03F9, 6 = . 0x03F9, 5 = . 0x03F9, 4 = . 0x03F9, 2 = ACT[4:0]. 0x03F9, 1 = . 0x03F9, 0 = . 0x03FA, Name = ADCLK. 0x03FA, Bit Pos. = 7:0. 0x03FA, 7 = . 0x03FA, 6 = . 0x03FA, 5 = . 0x03FA, 4 = . 0x03FA, 2 = CS[5:0].",
    "40.8 Register Summary - ADC\n0x03FA, 1 = . 0x03FA, 0 = ",
    "41. DAC - Digital-to-Analog Converter Module\nThe Digital-to-Analog Converter (DAC) supplies a variable voltage reference, ratiometric with the input source, with programmable selectable output levels.\nThe positive and negative input references (V REF + and VREF-) can each be selected from several sources.\nThe output of the DAC (DACx_output) can be selected as a reference voltage to several other peripherals or routed to output pins.\nThe Digital-to-Analog Converter (DAC) is enabled by setting the EN bit.\nImportant: This family of devices has two DAC modules. The DAC1 module has a buffered output that can be connected to any of the designated DAC output pins. The DAC2 module has no output pins or buffer, and the output is only connected internally to the CMP and OPA modules.\nFigure 41-1. Digital-to-Analog Converter Block Diagram\nNotes:",
    "41. DAC - Digital-to-Analog Converter Module\n1   The output enable bits are configured so that they act as a 'one-hot' system, meaning only one DAC . output can be enabled at a time.\n2 . DAC2 has no output buffer; the output from DAC2 is only connected internally to the specified peripherals.",
    "41.1 Output Voltage Selection\nThe DAC has 2 n  voltage level ranges, where n is the number of bits in DACR. Each level is determined by the DACxR bits. The DAC output voltage can be determined by using Equation 41-1.\n<!-- formula-not-decoded -->",
    "41.2 Ratiometric Output Level\nThe DAC output value is derived using a resistor ladder with each end of the ladder tied to a positive and negative voltage reference input source. If the voltage of either input source fluctuates, a similar fluctuation will result in the DAC output value.\nThe value of the individual resistors within the ladder can be found in the 'Electrical Specifications' chapter for each respective device.",
    "41.3 Operation During Sleep\nWhen the device wakes from Sleep through an interrupt or a WWDT Time-out Reset, the contents of the DACxCON and DACxDATL registers are not affected. To minimize current consumption in Sleep mode, the voltage reference will be disabled.",
    "41.4 Effects of a Reset\nA device Reset affects the following:\n\u00b7 The DAC module is disabled\n\u00b7 The DAC output voltage is removed from the DACxOUTn pin(s)\n\u00b7 The DACxR bits are cleared",
    "41.5 Register Definitions: DAC Control\nLong bit name prefixes for the DAC are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 41-1. DAC Long Bit Name Prefixes\n\nDAC1, Bit Name Prefix = DAC1. DAC2, Bit Name Prefix = DAC2",
    "41.5.1 DACxCON\nName: Address:\nDACxCON\n0x7F",
    "Digital-to-Analog Converter Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 0. , 1 = EN. , 2 = . , 3 = OE[1:0]. , 4 = OE[1:0]. , 5 = PSS[1:0]. , 6 = PSS[1:0]. , 7 = NSS. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 7 - EN DAC Enable\n1, Description = DAC is enabled. 0, Description = DAC is disabled",
    "Bits 5:4 - OE[1:0] DAC Output Enable\n11, DAC1 = DACxOUT is disabled. 10, DAC1 = DACxOUT is enabled on pin RA2 only. 01, DAC1 = DACxOUT is enabled on pin RA0 only. 00, DAC1 = DACxOUT is disabled",
    "Bits 3:2 - PSS[1:0] DAC Positive Reference Selection\n11, DAC Positive Reference = Reserved, do not use. 10, DAC Positive Reference = FVR Buffer 2. 01, DAC Positive Reference = V REF +. 00, DAC Positive Reference = V DD",
    "Bit 0 - NSS DAC Negative Reference Selection\n1, DAC Negative Reference = V REF -. 0, DAC Negative Reference = V SS",
    "41.5.2 DACxCON\nName:\nDACxCON\nAddress:\n0xA2\nImportant: This instance of the DAC module has no output pins or buffer; the output of this DAC is only connected internally to be used with the Comparator and OPAMP modules.\nDigital-to-Analog Converter Control Register",
    "Bit 7 - EN DAC Enable\n1, Description = DAC is enabled. 0, Description = DAC is disabled",
    "Bits 3:2 - PSS[1:0] DAC Positive Reference Selection\n11, DAC Positive Reference = Reserved, do not use. 10, DAC Positive Reference = FVR Buffer 2. 01, DAC Positive Reference = V REF +. 00, DAC Positive Reference = V DD",
    "Bit 0 - NSS DAC Negative Reference Selection\n1, DAC Negative Reference = V REF -. 0, DAC Negative Reference = V SS",
    "41.5.3 DACxDATL\nName: Address:\nDACxDATL\n0x7D\nDigital-to-Analog Converter Data Register",
    "41.5.3 DACxDATL\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DACxR[7:0]. , 2 = DACxR[7:0]. , 3 = DACxR[7:0]. , 4 = DACxR[7:0]. , 5 = DACxR[7:0]. , 6 = DACxR[7:0]. , 7 = DACxR[7:0]. , 8 = DACxR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0.",
    "41.5.3 DACxDATL\nReset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 7:0 - DACxR[7:0] Data Input Bits for DAC Value",
    "41.5.4 DACxDATL\nName: Address:\nDACxDATL\n0xA0\nDigital-to-Analog Converter Data Register",
    "41.5.4 DACxDATL\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DACxR[7:0]. , 2 = DACxR[7:0]. , 3 = DACxR[7:0]. , 4 = DACxR[7:0]. , 5 = DACxR[7:0]. , 6 = DACxR[7:0]. , 7 = DACxR[7:0]. , 8 = DACxR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0.",
    "41.5.4 DACxDATL\nReset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 7:0 - DACxR[7:0] Data Input Bits for DAC Value",
    "41.6 Register Summary - DAC\n0x00 ... 0x7C, Name = Reserved. 0x00 ... 0x7C, Bit Pos. = . 0x00 ... 0x7C, 7 = . 0x00 ... 0x7C, 6 = . 0x00 ... 0x7C, 5 = . 0x00 ... 0x7C, 4 = . 0x00 ... 0x7C, 3 = . 0x00 ... 0x7C, 1 = . 0x00 ... 0x7C, 0 = . 0x7D, Name = DAC1DATL. 0x7D, Bit Pos. = 7:0. 0x7D, 7 = DAC1R[7:0]. 0x7D, 6 = DAC1R[7:0]. 0x7D, 5 = DAC1R[7:0]. 0x7D, 4 = DAC1R[7:0]. 0x7D, 3 = DAC1R[7:0]. 0x7D, 1",
    "41.6 Register Summary - DAC\n= DAC1R[7:0]. 0x7D, 0 = DAC1R[7:0]. 0x7E, Name = Reserved. 0x7E, Bit Pos. = . 0x7E, 7 = . 0x7E, 6 = . 0x7E, 5 = . 0x7E, 4 = . 0x7E, 3 = . 0x7E, 1 = . 0x7E, 0 = . 0x7F, Name = DAC1CON. 0x7F, Bit Pos. = 7:0. 0x7F, 7 = EN. 0x7F, 6 = . 0x7F, 5 = OE[1:0]. 0x7F, 4 = . 0x7F, 3 = PSS[1:0]. 0x7F, 1 = . 0x7F, 0 = NSS. 0x80 ... 0x9F, Name = Reserved. 0x80 ... 0x9F, Bit Pos. = . 0x80 ... 0x9F, 7 =",
    "41.6 Register Summary - DAC\n. 0x80 ... 0x9F, 6 = . 0x80 ... 0x9F, 5 = . 0x80 ... 0x9F, 4 = . 0x80 ... 0x9F, 3 = . 0x80 ... 0x9F, 1 = . 0x80 ... 0x9F, 0 = . 0xA0, Name = DAC2DATL. 0xA0, Bit Pos. = 7:0. 0xA0, 7 = DAC2R[7:0]. 0xA0, 6 = DAC2R[7:0]. 0xA0, 5 = DAC2R[7:0]. 0xA0, 4 = DAC2R[7:0]. 0xA0, 3 = DAC2R[7:0]. 0xA0, 1 = DAC2R[7:0]. 0xA0, 0 = DAC2R[7:0]. 0xA1, Name = Reserved. 0xA1, Bit Pos. = . 0xA1, 7 = .",
    "41.6 Register Summary - DAC\n0xA1, 6 = . 0xA1, 5 = . 0xA1, 4 = . 0xA1, 3 = . 0xA1, 1 = . 0xA1, 0 = . 0xA2, Name = DAC2CON. 0xA2, Bit Pos. = 7:0. 0xA2, 7 = EN. 0xA2, 6 = . 0xA2, 5 = . 0xA2, 4 = . 0xA2, 3 = PSS[1:0]. 0xA2, 1 = . 0xA2, 0 = NSS",
    "42. OPA - Operational Amplifier\nThe Operational Amplifier (OPA) module features a standard general purpose three-terminal device with programmable gain options, adjustable input offset voltage and hardware override control capabilities. The OPA module has the following features:\n\u00b7 5.5 MHz Gain Bandwidth\n-Dedicated external output (OPAxOUT)\n-Multiple noninverting input pins available (OPAxIN+)\n-Multiple inverting input pins available (OPAxIN-)\n\u00b7 Programmable Gain Options Using Built-in Internal Resistor Ladder\n\u00b7 Configurable Positive and Negative Source Selections\n\u00b7 Hardware Controlled Drive with Override Controls\n-Forced Unity Gain mode\n-Forced Rail Drive mode\n\u00b7 Programmable Input Offset Voltage Calibration\n\u00b7 Internal Connection to the ADC Module\n-Allows OPA to be used as programmable gain amplifier for the ADC Input\nFigure 42-1. Operational Amplifier Module Block Diagram\n\u5231\n\u5232\n\u4e43\n\u5353\n\u3030\n\u4f50\n\u2b20",
    "Note:\n- 1. Refer to the 'Pin Allocation Table' for details about OPAxIN- and OPAxIN+ availability per port.\n\u4e31\n\u4f50\n\u4f50\n\u4f50\n\u4f50\n\u5353\n\u2b20\n\u2b20\n\u4178\n\u4f50\n\u4f50\n\u3131\n\u3131\n\u3130\n\u3130\n\u3031\n\u3031\n\u3030\n\u3030\n\u3131\n\u3130\n\u3031\n\u3030\n\u5245\n\u4f4e\n\u203d\n\u2030\n\u4f4e\n\u203d\n\u5245\n\u696f\n\u4f55\n\u4143\n\u4f55\n\u4f55\n\u4444\n\u3131\n\u3131\n\u3130\n\u3130\n\u3031\n\u3031\n\u3030\n\u3131\n\u3131\n\u3130\n\u3130\n\u3031\n\u3031\n\u3030\n\u3030\n\u3030\n\u3031\n\u3130\n\u3131\n\u5547\n\u2020\n\u464d\n\u696f\n\u4444\n\u4178\n\u4f50\n\u4f50\n\u454e\n\u4f55\n\u4f50",
    "42.1 OPA Module Control\nThe OPA module is enabled by setting the EN bit of the corresponding operational amplifier Configuration register. Once enabled, the OPA module forces the output driver of the output pin (OPAxOUT) into tri-state. Forcing the output pin into tri-state prevents contention between the digital PORT driver of the pin and the output of the OPA during operation. The Software Output Control (SOC) bits are used to select the OPA mode of operation when hardware controlled override is not being used (OREN = 0 ).",
    "42.1.1 Programmable Source Selection\nThe noninverting input source of the OPA module is selected using the PCH bits and can be connected to multiple internal sources or to an external input pin (OPAxIN+). If an external pin is chosen as the noninverting input source, the PSS bits may then be used to select from the available OPA noninverting input pins for the device.\nThe inverting input source of the OPA module is selected using the NCH bits and can be connected to multiple internal sources or to an external input pin (OPAxIN-). If an external pin is chosen as the inverting input source, the NSS bits may then be used to select from the available inverting OPA input pins for the device.",
    "42.1.2 Programmable Gain Options\nThe gain of the OPA module can be controlled either using external components to provide feedback, or internally using a built-in resistor ladder. When using the built-in programmable gain options of the OPA module, the internal resistor ladder must be enabled by setting the RESON bit. Once enabled, the nominal gain of the amplifier can be selected using the GSEL bits.\nThe internal sources to the operational amplifier must be configured based on the OPA mode of operation, when using the built-in programmable gain options. The PCH and NCH bits can be used to connect the internal resistor ladder to the positive or negative input of the operational amplifier, respectively, creating the feedback network needed to control the gain of the circuit.",
    "42.1.3 Unity Gain Mode\nThe OPA module can be configured to operate in Unity Gain mode either in software or hardware, depending on the configuration of the Override Enable (OREN) bit. If the OREN bit has not been set, Unity Gain mode can be enabled in software by setting the Unity Gain Enable (UG) bit. Once Unity Gain mode has been enabled, the output of the OPA will be connected internally to the inverting input and the OPA will operate with unity gain feedback. If hardware-controlled override has been enabled by setting the OREN bit, the OPAxHWC register might be used to configure the OPA mode of operation, depending on the status of the override source. Refer to the Hardware Override Control section for more information.\nTip: Operating the OPA module in Unity Gain mode (software-controlled or hardware-controlled) relinquishes the need for an external inverting input pin (OPAxIN-), since it connects internally to the OPA output, which allows that pin to be used for general purpose I/O.",
    "42.2 Hardware Override Control\nThe OPA mode of operation can be switched core independently, using the hardware override control feature built into the peripheral. Hardware override control is enabled by setting the OREN bit and selecting an override source using the ORS bits. The OPA mode of operation is determined based on the level of the selected override signal. The Hardware Override Control Configuration bits (HWCH and HWCL) are used to select the OPA mode of operation, when the override source is high or low, respectively. The ORPOL bit can be used to invert the hardware controlled override input,\nmeaning that when ORPOL = 1 , the HWCH bits will determine the OPA mode of operation when the override source is low, and the HWCL bits will determine the OPA mode of operation when the override source is high. The hardware override control can be used to switch between the following OPA configurations:\n\u00b7 Basic Operation with User Defined Feedback (1)\n\u00b7 Unity Gain Mode\n\u00b7 Rail Drive Mode\n-Forces the operational amplifier output to be driven to V DD or V SS , depending on the status of the override source and the configured override polarity.",
    "Note:\n- 1. Feedback is based on the configuration of the internal gain options (GSEL) or external components, depending upon peripheral setup.",
    "42.3 Input Offset Voltage\nInput offset voltage is a measure of the voltage difference between the noninverting and inverting input sources in a closed loop circuit, with the operational amplifier operating in its linear region. The offset voltage will appear as a DC offset in the output equal to the input offset voltage, multiplied by the gain of the circuit. The input offset voltage is also affected by the Common-mode voltage. The OPA module is factory calibrated to minimize the input offset voltage.",
    "42.3.1 Offset Calibration\nThe OPAxOFFSET register can be used to recalibrate or adjust the input offset voltage from the factory calibration. This can be accomplished by using the DAC module or an external constant-voltage source, in conjunction with the ADC module. The OPA input offset voltage can be recalibrated using the following steps:",
    "42.3.1 Offset Calibration\n\u00b7 Configure the DAC module to be used as a constant voltage reference connected to the noninverting input (OPAxIN+) of the OPA module.\n-An external constant voltage reference can be used, instead of the DAC, by connecting it to one of the external noninverting input pins.\n\u00b7 Configure the OPA module to operate in Unity Gain mode by setting the UG bit.\n-Use the PCH bits to connect the calibration source (either the DAC module or an external voltage reference) to the noninverting input (OPAxIN+) of the OPA.\n-If using an external voltage reference, the PSS must also be used to select which OPAxIN+ pin will be connected to the noninverting input.\n\u00b7 Perform an ADC conversion to measure the voltage of the selected calibration source. The value read by the ADC during this conversion will serve as the calibration target.\n\u00b7 Use the ADC Positive Channel Selection (ADPCH) register to select the OPA output (OPAxOUT), and then measure the output voltage of the OPA module using the ADC.",
    "42.3.1 Offset Calibration\n\u00b7 The difference between the measured value of the calibration target and the measured value of the OPA output can be used to determine the value needed to calibrate the OPA input offset voltage using the OPAxOFFSET register.",
    "Important:\n1. The OPA input offset voltage is factory calibrated, and any data written to the OPAxOFFSET register will adjust the input offset voltage from the factory calibrated value. The factory calibrated input offset voltage will be restored on a Reset event, overwriting any previous data that may have been written to the register.\n2. The OPAxOFFSET register stores an unsigned value which can be use to optimize both positive and negative offset voltages.",
    "42.4 OPA Operation with ADC\nThe OPA module provides internal connections directly to the ADC, allowing it to be used for analog signal conditioning before a signal is converted by the ADC. In this mode of operation, the output of the OPA (OPAxOUT) will connect internally to the input of the ADC, and any ADC conversions will be performed on that signal. When using this mode of operation, the ADPCH register of the ADC module may be used to select one of the available noninverting OPA input pins (OPAxIN+) Both the ADC and the OPA module must be configured accordingly to use this mode of operation.",
    "Tip:\n1. When using the OPA module with the ADC in this mode of operation, the OPA input pin selection determined using the ADC input channel selection registers will take precedence over the input pin selection using the NSS and PSS bits.\n2. Although the output of the OPA (OPAxOUT) is connected internally to the ADC in this mode of operation, the OPAxOUT pin cannot be used as a general purpose I/O at this time.",
    "42.5 Register Definitions: Operational Amplifier\nLong bit name prefixes for the OPA peripherals are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 42-1. Operational Amplifier Long Bit Name Prefixes\n\nOPA1, Bit Name Prefix = OPA1",
    "42.5.1 OPAxCON0\nName:\nOPAxCON0\nAddress:\n0xA3",
    "Operational Amplifier Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 1. Bit, 7 = 0. , 1 = EN. , 2 = . , 3 = CPON. , 4 = . , 5 = UG. , 6 = SOC[1:0]. , 7 = . Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 7 - EN Operational Amplifier Enable\n1, Description = Operational amplifier is enabled. 0, Description = Operational amplifier is disabled and consumes no active power",
    "Bit 5 - CPON Charge Pump On Control\n1, Description = OPA Charge Pump on. 0, Description = OPA Charge Pump off (Low Power mode)",
    "Bit 3 - UG Operational Amplifier Unity Gain Select\n1, Description = Operational amplifier output is connected to inverting input, OPAxIN- input pins are available for general purpose I/O.. 0, Description = Inverting input is connected to designated OPAxIN- pin.",
    "Bits 1:0 - SOC[1:0] Software Output Control\n11, Description = Reserved. 10, Description = Drive output to V DD. 01, Description = Drive output to V SS. 00, Description = Basic Operation; Operational amplifier configuration with user-defined or unity-gain feedback",
    "42.5.2 OPAxCON1\nName:\nOPAxCON1\nAddress:\n0xA4\nOperational Amplifier Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = GSEL[2:0]. , 3 = GSEL[2:0]. , 4 = GSEL[2:0]. , 5 = RESON. , 6 = NSS[2:0]. , 7 = NSS[2:0]. , 8 = NSS[2:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 6:4 - GSEL[2:0] Operational Amplifier Gain Selection\n\nTable 42-2. Operational Amplifier Internal Resistor Ladder Selections",
    "Bits 6:4 - GSEL[2:0] Operational Amplifier Gain Selection\n111, R1 = 1R. 111, R2 = 15R. 111, Inverting (R2/R1) = 15. 111, Noninverting (1 + R2/R1) = 16. 110, R1 = 2R. 110, R2 = 14R. 110, Inverting (R2/R1) = 7. 110, Noninverting (1 + R2/R1) = 8. 101, R1 = 4R. 101, R2 = 12R. 101, Inverting (R2/R1) = 3. 101, Noninverting (1 + R2/R1) = 4. 100, R1 = 6R. 100, R2 = 10R. 100, Inverting (R2/R1) = 5/3. 100, Noninverting (1 + R2/R1) = 8/3. 011, R1 = 8R. 011, R2 = 8R. 011, Inverting (R2/R1) = 1. 011,",
    "Bits 6:4 - GSEL[2:0] Operational Amplifier Gain Selection\nNoninverting (1 + R2/R1) = 2. 010, R1 = 12R. 010, R2 = 4R. 010, Inverting (R2/R1) = 1/3. 010, Noninverting (1 + R2/R1) = 4/3. 001, R1 = 14R. 001, R2 = 2R. 001, Inverting (R2/R1) = 1/7. 001, Noninverting (1 + R2/R1) = 8/7. 000, R1 = 15R. 000, R2 = 1R. 000, Inverting (R2/R1) = 1/15. 000, Noninverting (1 + R2/R1) = 16/15. Note: R = 20 k\u03a9 nominal, R1 = Note: R = 20 k\u03a9 nominal. Note: R = 20 k\u03a9 nominal, R2 = . Note: R = 20 k\u03a9 nominal, Inverting (R2/R1) = . Note: R = 20",
    "Bits 6:4 - GSEL[2:0] Operational Amplifier Gain Selection\nk\u03a9 nominal, Noninverting (1 + R2/R1) = ",
    "Bit 3 - RESON Resistor Ladder Enable\n1, Description = Internal Resistor Ladder is enabled; OPA input is connected to the resistor ladder allowing GSEL to be used to control programmable gain.. 0, Description = Internal Resistor Ladder is disabled. External feedback to the OPA is required unless operating in Unity Gain mode.",
    "Bits 2:0 - NSS[2:0] Negative Source Selection\n111, Description = V SS. 110, Description = Reserved. 101, Description = Reserved. 100, Description = Reserved. 011, Description = OPAxIN3-. 010, Description = OPAxIN2-. 001, Description = OPAxIN1-. 000, Description = OPAxIN0-",
    "42.5.3 OPAxCON2\nName:\nOPAxCON2\nAddress:\n0xA5\nOperational Amplifier Control Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = NCH[2:0]. , 3 = NCH[2:0]. , 4 = NCH[2:0]. , 5 = . , 6 = PCH[2:0]. , 7 = PCH[2:0]. , 8 = PCH[2:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 6:4 - NCH[2:0] Operational Amplifier Inverting Input Channel Selection\n111, Description = Reserved. 110, Description = Reserved. 101, Description = DAC2_OUT. 100, Description = DAC1_OUT. 011, Description = Reserved. 010, Description = OPAxIN- (NSS). 001, Description = Internal Resistor Ladder (GSEL). 000, Description = No Connection",
    "Bits 2:0 - PCH[2:0] Operational Amplifier Noninverting Input Channel Selection\n111, Description = Reserved. 110, Description = Reserved. 101, Description = DAC2_OUT. 100, Description = DAC1_OUT. 011, Description = V DD /2. 010, Description = OPAxIN+ (PSS). 001, Description = Internal Resistor Ladder (GSEL). 000, Description = V SS",
    "42.5.4 OPAxCON3\nName:\nOPAxCON3\nAddress:\n0xA6",
    "Operational Amplifier Control Register 3\nBit, 1 = 7 6. Bit, 2 = 7 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = FMS[1:0]. , 2 = FMS[1:0]. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = PSS[1:0]. , 8 = PSS[1:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:6 - FMS[1:0] Feedback Mode Selection\n11, Description = Reserved. 10, Description = Operational Amplifier Output Pin (OPAxOUT). 01, Description = V DD. 00, Description = No Connection",
    "Bits 1:0 - PSS[1:0] Positive Source Selection\n11, Description = OPAxIN3+. 10, Description = OPAxIN2+. 01, Description = OPAxIN1+. 00, Description = OPAxIN0+",
    "42.5.5 OPAxHWC\nName: Address:\nOPAxHWC\n0xA7",
    "Operational Amplifier Hardware Control Options Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OREN. , 2 = HWCH[2:0]. , 3 = HWCH[2:0]. , 4 = HWCH[2:0]. , 5 = ORPOL. , 6 = HWCL[2:0]. , 7 = HWCL[2:0]. , 8 = HWCL[2:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - OREN Override Enable\n1, Description = Hardware Override Control is enabled. OPA mode of operation is configured using the HWCH / HWCL bits.. 0, Description = Hardware Override Control is disabled. OPA mode of operation must be configured in software.",
    "Bits 6:4 - HWCH[2:0] Hardware Control Configuration High\n111, Description = Rail Drive to V DD. 110, Description = Reserved. 101, Description = Reserved. 100, Description = Basic OPA configuration with unity gain feedback. 011, Description = Reserved. 010, Description = Reserved. 001, Description = Reserved. 000, Description = Basic OPA configuration with user-defined feedback",
    "Bit 3 - ORPOL Override Source Polarity\n1, Description = Hardware Control Input is Inverted (Active-Low). 0, Description = Hardware Control Input is not Inverted (Active-High)",
    "Bits 2:0 - HWCL[2:0] Hardware Control Configuration Low\n111, Description = Rail Drive to V SS. 110, Description = Reserved. 101, Description = Reserved. 100, Description = Basic OPA configuration with unity gain feedback. 011, Description = Reserved. 010, Description = Reserved. 001, Description = Reserved. 000, Description = Basic OPA configuration with user-defined feedback",
    "42.5.6 OPAxOFFSET\nName:\nOPAxOFFSET\nAddress:\n0xA8\nOperational Amplifier Input Offset Adjustment Register",
    "42.5.6 OPAxOFFSET\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OFFSET[7:0]. , 2 = OFFSET[7:0]. , 3 = OFFSET[7:0]. , 4 = OFFSET[7:0]. , 5 = OFFSET[7:0]. , 6 = OFFSET[7:0]. , 7 = OFFSET[7:0]. , 8 = OFFSET[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = m. Reset, 2 = m. Reset, 3 = m. Reset, 4 = m. Reset, 5 = m. Reset, 6 = m. Reset, 7 = m. Reset, 8 = m",
    "42.5.6 OPAxOFFSET\nBits 7:0 - OFFSET[7:0] Operational Amplifier Input Offset Calibration\nImportant: If written by the user, the factory calibrated value of this register will be replaced and can only be restored on a Reset.\nNote: The Reset value 'm' is determined by device default locations for that input.",
    "42.5.7 OPAxORS\nName: Address:\nOPAxORS\n0xA9\nOperational Amplifier Override Source Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = ORS[4:0]. , 5 = ORS[4:0]. , 6 = ORS[4:0]. , 7 = ORS[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - ORS[4:0] Operational Amplifier Output Override Source Selection\n10110 - 11111, Description = Reserved. 10101, Description = CLC4_OUT. 10100, Description = CLC3_OUT. 10011, Description = CLC2_OUT. 10010, Description = CLC1_OUT. 10001, Description = ZCD_OUT. 10000, Description = CM2_OUT. 01111, Description = CM1_OUT. 01110, Description = NCO1_OUT. 01101, Description = PWM3_S1P2. 01100, Description = PWM3_S1P1. 01011, Description = PWM2_S1P2. 01010, Description = PWM2_S1P1. 01001, Description = PWM1_S1P2. 01000, Description = PWM1_S1P1. 00111, Description = CCP1_OUT. 00110, Description = TMR4_OUT. 00101, Description = TMR3_OUT. 00100, Description =",
    "Bits 4:0 - ORS[4:0] Operational Amplifier Output Override Source Selection\nTMR2_OUT. 00011, Description = TMR1_OUT. 00010, Description = TMR0_OUT. 00001, Description = SOSC. 00000, Description = LFINTOSC",
    "42.6 Register Summary - Operational Amplifier\n0x00 ... 0xA2, Name = Reserved. 0x00 ... 0xA2, Bit Pos. = . 0x00 ... 0xA2, 7 = . 0x00 ... 0xA2, 6 = . 0x00 ... 0xA2, 5 = . 0x00 ... 0xA2, 4 3 = . 0x00 ... 0xA2, 2 1 = . 0x00 ... 0xA2, 0 = . 0xA3, Name = OPA1CON0. 0xA3, Bit Pos. = 7:0. 0xA3, 7 = EN. 0xA3, 6 = . 0xA3, 5 = CPON. 0xA3, 4 3 = UG. 0xA3, 2 1 = SOC[1:0]. 0xA3, 0 = . 0xA4, Name = OPA1CON1. 0xA4, Bit Pos. = 7:0. 0xA4, 7 = . 0xA4, 6 = . 0xA4, 5 = GSEL[2:0]. 0xA4, 4 3 =",
    "42.6 Register Summary - Operational Amplifier\nRESON. 0xA4, 2 1 = NSS[2:0]. 0xA4, 0 = . 0xA5, Name = OPA1CON2. 0xA5, Bit Pos. = 7:0. 0xA5, 7 = . 0xA5, 6 = . 0xA5, 5 = NCH[2:0]. 0xA5, 4 3 = . 0xA5, 2 1 = PCH[2:0]. 0xA5, 0 = . 0xA6, Name = OPA1CON3. 0xA6, Bit Pos. = 7:0. 0xA6, 7 = FMS[1:0]. 0xA6, 6 = . 0xA6, 5 = . 0xA6, 4 3 = . 0xA6, 2 1 = PSS[1:0]. 0xA6, 0 = . 0xA7, Name = OPA1HWC. 0xA7, Bit Pos. = 7:0. 0xA7, 7 = OREN. 0xA7, 6 = . 0xA7, 5 = HWCH[2:0]. 0xA7,",
    "42.6 Register Summary - Operational Amplifier\n4 3 = ORPOL. 0xA7, 2 1 = HWCL[2:0]. 0xA7, 0 = . 0xA8, Name = OPA1OFFSET. 0xA8, Bit Pos. = 7:0. 0xA8, 7 = OFFSET[7:0]. 0xA8, 6 = OFFSET[7:0]. 0xA8, 5 = OFFSET[7:0]. 0xA8, 4 3 = OFFSET[7:0]. 0xA8, 2 1 = OFFSET[7:0]. 0xA8, 0 = OFFSET[7:0]. 0xA9, Name = OPA1ORS. 0xA9, Bit Pos. = 7:0. 0xA9, 7 = . 0xA9, 6 = . 0xA9, 5 = . 0xA9, 4 3 = ORS[4:0]. 0xA9, 2 1 = . 0xA9, 0 = ",
    "43. CMP - Comparator Module\nComparators are used to interface analog circuits to a digital circuit by comparing two analog voltages and providing a digital indication of their relative magnitudes. Comparators are very useful mixed signal building blocks because they provide analog functionality independent of program execution.\nThe analog comparator module includes the following features:\n\u00b7 Programmable input selection\n\u00b7 Programmable output polarity\n\u00b7 Rising/falling output edge interrupts\n\u00b7 Wake-up from Sleep\n\u00b7 Selectable voltage reference\n\u00b7 ADC auto-trigger\n\u00b7 Inter-connections with other available modules (e.g., timer clocks)",
    "43.1 Comparator Overview\nA single comparator is shown in Figure 43-1 along with the relationship between the analog input levels and the digital output. When the analog voltage at V IN + is less than the analog voltage at V IN -, the output of the comparator is a digital low level. When the analog voltage at V IN + is greater than the analog voltage at V IN -, the output of the comparator is a digital high level.\nFigure 43-1. Single Comparator",
    "Note:\n- 1. The black areas of the output of the comparator represent the uncertainty due to input offsets and response time.",
    "Figure 43-2. Comparator Module Simplified Block Diagram\nNote 1: When EN = 0 , all multiplexer inputs are disconnected and the Comparator will produce a  ' 0 '  at the output.",
    "43.2 Comparator Control\nEach comparator has two control registers: CMxCON0 and CMxCON1.\nThe CMxCON0 register contains Control and Status bits for the following:\n\u00b7 Enable\n\u00b7 Output\n\u00b7 Output Polarity\n\u00b7 Hysteresis Enable\n\u00b7 Timer1 Output Synchronization\nThe CMxCON1 register contains Control bits for the following:\n- \u00b7 Interrupt on Positive/Negative Edge Enables\nThe CMxPCH and CMxNCH registers are used to select the positive and negative input channels, respectively.",
    "43.2.1 Comparator Enable\nSetting the EN bit enables the comparator for operation. Clearing the EN bit disables the comparator, resulting in minimum current consumption.",
    "43.2.2 Comparator Output\nThe output of the comparator can be monitored in two different registers. Each output can be read individually by reading the OUT bit. Outputs of all the comparators can be collectively accessed by reading the CMOUT register.\nThe comparator output can also be routed to an external pin through the RxyPPS register. Refer to the 'PPS - Peripheral Pin Select Module' chapter for more details. The corresponding TRIS bit must be clear to enable the pin as an output.\nImportant: The internal output of the comparator is latched with each instruction cycle. Unless otherwise specified, external outputs are not latched.",
    "43.2.3 Comparator Output Polarity\nInverting the output of the comparator is functionally equivalent to swapping the comparator inputs. The polarity of the comparator output can be inverted by setting the POL bit. Clearing the POL bit results in a noninverted output. Table 43-1 shows the Output state versus Input conditions, including polarity control.\nTable 43-1. Comparator Output State vs. Input Conditions\n\nCxVn > CxVp, POL = 0. CxVn > CxVp, OUT = 0. CxVn < CxVp, POL = 0. CxVn < CxVp, OUT = 1. CxVn > CxVp, POL = 1. CxVn > CxVp, OUT = 1. CxVn < CxVp, POL = 1. CxVn < CxVp, OUT = 0",
    "43.3 Comparator Output Synchronization\nThe output from a comparator can be synchronized with Timer1 by setting the SYNC bit.\nOnce enabled, the comparator output is latched on the falling edge of the Timer1 source clock. If a prescaler is used with Timer1, the comparator output is latched after the prescaling function. To prevent a Race condition, the comparator output is latched on the falling edge of the Timer1 clock source and Timer1 increments on the rising edge of its clock source. A simplified block diagram of the comparator module is shown in Figure 43-2. Refer to the 'TMR1 - Timer1 Module with Gate Control' chapter for more details.",
    "43.4 Comparator Hysteresis\nA selectable amount of separation voltage can be added to the input pins of each comparator to provide a hysteresis function to the overall operation. Hysteresis is enabled by setting the HYS bit.\nSee the 'Comparator Specifications' section for more information.",
    "43.5 Comparator Interrupt\nAn interrupt can be generated for every rising or falling edge of the comparator output.\nWhen either edge detector is triggered and its associated enable bit is set (INTP and/or INTN bits), the Corresponding Interrupt Flag bit (CxIF bit of the respective PIR register) will be set.\nTo enable the interrupt, the following bits must be set:\n\u00b7 EN bit\n\u00b7 INTP bit (for a rising edge detection)\n\u00b7 INTN bit (for a falling edge detection)\n\u00b7 CxIE bit of the respective PIE register\n\u00b7 GIE bit of the INTCON0 register\nThe associated interrupt flag bit, CxIF bit of the respective PIR register, must be cleared in software to successfully detect another edge.\nImportant: Although a comparator is disabled, an interrupt will be generated by changing the output polarity with the POL bit.",
    "43.6 Comparator Positive Input Selection\nConfiguring the PCH bits direct an internal voltage reference or an analog pin to the noninverting input of the comparator.\nAny time the comparator is disabled (EN = 0 ), all comparator inputs are disabled.",
    "43.7 Comparator Negative Input Selection\nThe NCH bits direct an analog input pin, internal reference voltage or analog ground to the inverting input of the comparator.\nImportant: To use CxINy+ and CxINy- pins as analog input, the appropriate bits must be set in the ANSEL register and the corresponding TRIS bits must also be set to disable the output drivers.",
    "43.8 Comparator Response Time\nThe comparator output is indeterminate for a period of time after the change of an input source or the selection of a new reference voltage. This period is referred to as the response time. The response time of the comparator differs from the settling time of the voltage reference. Therefore, both of these times must be considered when determining the total response time to a comparator input change. See the Comparator and Voltage Reference Specifications in the 'Comparator Specifications' and 'Fixed Voltage Reference (FVR) Specifications' sections for more details.",
    "43.9 Analog Input Connection Considerations\nA simplified circuit for an analog input is shown in Figure 43-3. Since the analog input pins share their connection with a digital input, they have reverse biased ESD protection diodes to V DD and VSS. The analog input, therefore, must be between VSS and VDD. If the input voltage deviates from this range by more than 0.6V in either direction, one of the diodes is forward biased and abnormal behavior may occur.\nA maximum source impedance of 10 k\u03a9 is recommended for the analog sources. Also, any external component connected to an analog input pin, such as a capacitor or a Zener diode, will have very little leakage current to minimize corrupting the result.",
    "Notes:\n1. When reading a PORT register, all pins configured as analog inputs will read as a ' 0 '. Pins configured as digital inputs will convert as an analog input, according to the input specification.\n2. Analog levels on any pin defined as a digital input may cause the input buffer to consume more current than specified.",
    "Figure 43-3. Analog Input Model\nLegend:\nCPIN\n= Input Capacitance\nILEAKAGE\n= Leakage Current at the pin due to various junctions\nRIC\n= Interconnect Resistance\nRS\n= Source Impedance\nVA\n= Analog Voltage\nVT\n= Diode Forward Voltage\nNote:\n- 1. See the \"Electrical Specifications\" chapter.",
    "43.10 Operation in Sleep Mode\nThe comparator module can operate during Sleep. A comparator interrupt will wake the device from Sleep. The CxIE bits of the respective PIE register must be set to enable comparator interrupts.\nThe comparator clock source is based on the Timer1 clock source. If the Timer1 clock source is either the system clock (F OSC) or the instruction clock (F OSC/4), Timer1 will not operate during Sleep, and synchronized comparator outputs will not operate.",
    "43.11 ADC Auto-Trigger Source\nThe output of the comparator module can be used to trigger an ADC conversion. When the ADACT register is set to trigger on a comparator output, an ADC conversion will trigger when the comparator output goes high.",
    "43.12 Register Definitions: Comparator Control\nLong bit name prefixes for the Comparator peripherals are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 43-2. Comparator Long Bit Name Prefixes\n\nC1, Bit Name Prefix = C1. C2, Bit Name Prefix = C2",
    "43.12.1  CMxCON0\nName: Address:\nCMxCON0 0x070,0x074",
    "Comparator Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = OUT. , 3 = . , 4 = POL. , 5 = . , 6 = . , 7 = HYS. , 8 = SYNC. Access, 1 = R/W. Access, 2 = R. Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN Comparator Enable\n1, Description = Comparator is enabled. 0, Description = Comparator is disabled and consumes no active power",
    "Bit 6 - OUT Comparator Output\n1, Condition = If POL = 0 (noninverted polarity):. 1, Description = CxVP > CxVN. 0, Condition = If POL = 0 (noninverted polarity):. 0, Description = CxVP < CxVN. 1, Condition = If POL = 1 (inverted polarity):. 1, Description = CxVP < CxVN. 0, Condition = If POL = 1 (inverted polarity):. 0, Description = CxVP > CxVN",
    "Bit 4 - POL Comparator Output Polarity Select\n1, Description = Comparator output is inverted. 0, Description = Comparator output is not inverted",
    "Bit 1 - HYS Comparator Hysteresis Enable\n1, Description = Comparator hysteresis enabled. 0, Description = Comparator hysteresis disabled",
    "Bit 0 - SYNC Comparator Output Synchronous Mode\n1, Description = Comparator output to Timer1 and I/O pin is synchronous to changes on Timer1 clock source. Output updated on the falling edge of Timer1 clock source.. 0, Description = Comparator output to Timer1 and I/O pin is asynchronous",
    "43.12.2  CMxCON1\nName:\nCMxCON1\nAddress:\n0x071,0x075\nComparator Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = INTP. , 8 = INTN. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 1 - INTP Comparator Interrupt on Positive-Going Edge Enable\n1, Description = The CxIF interrupt flag will be set upon a positive-going edge of the CxOUT bit. 0, Description = No interrupt flag will be set on a positive-going edge of the CxOUT bit",
    "Bit 0 - INTN Comparator Interrupt on Negative-Going Edge Enable\n1, Description = The CxIF interrupt flag will be set upon a negative-going edge of the CxOUT bit. 0, Description = No interrupt flag will be set on a negative-going edge of the CxOUT bit",
    "43.12.3  CMxNCH\nName: Address:\nCMxNCH 0x072,0x076\nComparator Inverting Channel Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = NCH[2:0]. , 7 = NCH[2:0]. , 8 = NCH[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 2:0 - NCH[2:0] Comparator Inverting Input Channel Select\n111, Negative Input Sources = V SS. 110, Negative Input Sources = FVR_Buffer2. 101, Negative Input Sources = NCH not connected. 100, Negative Input Sources = NCH not connected. 011, Negative Input Sources = CxIN3-. 010, Negative Input Sources = CxIN2-. 001, Negative Input Sources = CxIN1-. 000, Negative Input Sources = CxIN0-",
    "43.12.4  CMxPCH\nName: Address:\nCMxPCH 0x073,0x077\nComparator Noninverting Channel Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = PCH[2:0]. , 7 = PCH[2:0]. , 8 = PCH[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 2:0 - PCH[2:0] Comparator Noninverting Input Channel Select\n111, Positive Input Sources = V SS. 110, Positive Input Sources = FVR_Buffer2. 101, Positive Input Sources = DAC2_Output. 100, Positive Input Sources = PCH not connected. 011, Positive Input Sources = PCH not connected. 010, Positive Input Sources = PCH not connected. 001, Positive Input Sources = PCH not connected. 000, Positive Input Sources = CxIN0+",
    "43.12.5  CMOUT\nName: Address:\nCMOUT\n0x06F\nComparator Output Register\nBits 0, 1 - CxOUT Mirror copy of the CMxCON0.OUT",
    "43.13 Register Summary - Comparator\n0x00 ... 0x6E, Name = Reserved. 0x00 ... 0x6E, Bit Pos. = . 0x00 ... 0x6E, 7 = . 0x00 ... 0x6E, 6 = . 0x00 ... 0x6E, 5 = . 0x00 ... 0x6E, 4 = . 0x00 ... 0x6E, 3 = . 0x00 ... 0x6E, 2 = . 0x00 ... 0x6E, 1 = . 0x00 ... 0x6E, 0 = . 0x6F, Name = CMOUT. 0x6F, Bit Pos. = 7:0. 0x6F, 7 = . 0x6F, 6 = . 0x6F, 5 = . 0x6F, 4 = . 0x6F, 3 = . 0x6F, 2 = . 0x6F, 1 = C2OUT. 0x6F, 0 = C1OUT. 0x70, Name = CM1CON0.",
    "43.13 Register Summary - Comparator\n0x70, Bit Pos. = 7:0. 0x70, 7 = EN. 0x70, 6 = OUT. 0x70, 5 = . 0x70, 4 = POL. 0x70, 3 = . 0x70, 2 = . 0x70, 1 = HYS. 0x70, 0 = SYNC. 0x71, Name = CM1CON1. 0x71, Bit Pos. = 7:0. 0x71, 7 = . 0x71, 6 = . 0x71, 5 = . 0x71, 4 = . 0x71, 3 = . 0x71, 2 = . 0x71, 1 = INTP. 0x71, 0 = INTN. 0x72, Name = CM1NCH. 0x72, Bit Pos. = 7:0. 0x72, 7 = . 0x72, 6 = . 0x72, 5 = . 0x72, 4 = . 0x72, 3 = . 0x72, 2 = . 0x72,",
    "43.13 Register Summary - Comparator\n1 = NCH[2:0]. 0x72, 0 = . 0x73, Name = CM1PCH. 0x73, Bit Pos. = 7:0. 0x73, 7 = . 0x73, 6 = . 0x73, 5 = . 0x73, 4 = . 0x73, 3 = . 0x73, 2 = . 0x73, 1 = PCH[2:0]. 0x73, 0 = . 0x74, Name = CM2CON0. 0x74, Bit Pos. = 7:0. 0x74, 7 = EN. 0x74, 6 = OUT. 0x74, 5 = . 0x74, 4 = POL. 0x74, 3 = . 0x74, 2 = . 0x74, 1 = HYS. 0x74, 0 = SYNC. 0x75, Name = CM2CON1. 0x75, Bit Pos. = 7:0. 0x75, 7 = . 0x75, 6",
    "43.13 Register Summary - Comparator\n= . 0x75, 5 = . 0x75, 4 = . 0x75, 3 = . 0x75, 2 = . 0x75, 1 = INTP. 0x75, 0 = INTN. 0x76, Name = CM2NCH. 0x76, Bit Pos. = 7:0. 0x76, 7 = . 0x76, 6 = . 0x76, 5 = . 0x76, 4 = . 0x76, 3 = . 0x76, 2 = . 0x76, 1 = NCH[2:0]. 0x76, 0 = . 0x77, Name = CM2PCH. 0x77, Bit Pos. = 7:0. 0x77, 7 = . 0x77, 6 = . 0x77, 5 = . 0x77, 4 = . 0x77, 3 = . 0x77, 2 = . 0x77, 1 = PCH[2:0]. 0x77, 0 = ",
    "44. ZCD - Zero-Cross Detection Module\nThe ZCD module detects when an A/C signal crosses through the ground potential. The actual zero-crossing threshold is the zero-crossing reference voltage, Z CPINV , which is typically 0.75V above ground.\nThe connection to the signal to be detected is through a series current-limiting resistor. The module applies a current source or sink to the ZCD pin to maintain a constant voltage on the pin, thereby preventing the pin voltage from forward biasing the ESD protection diodes. When the applied voltage is greater than the reference voltage, the module sinks current. When the applied voltage is less than the reference voltage, the module sources current. The current source and sink action keeps the pin voltage constant over the full range of the applied voltage. The ZCD module is shown in the following simplified block diagram.\nFigure 44-1. Simplified ZCD Block Diagram\nThe ZCD module is useful when monitoring an A/C waveform for, but not limited to, the following purposes:\n\u00b7 A/C period measurement\n\u00b7 Accurate long term time measurement\n\u00b7 Dimmer phase delayed drive\n\u00b7 Low EMI cycle switching",
    "44.1 External Resistor Selection\nThe ZCD module requires a current-limiting resistor in series with the external voltage source. The impedance and rating of this resistor depends on the external source peak voltage. Select a resistor value that will drop all of the peak voltage when the current through the resistor is less than the maximum input current (ZC02). Refer to the 'Electrical Specifications' chapter for more details. Make sure that the ZCD I/O pin internal weak pull-up is disabled so it does not interfere with the current source and sink.\nEquation 44-1. External Resistor\nFigure 44-2. External Voltage Source\n<!-- formula-not-decoded -->",
    "44.2 ZCD Logic Output\nThe ZCD module includes a Status bit, which can be read to determine whether the current source or sink is active. The OUT bit is set when the current sink is active and is cleared when the current source is active. The OUT bit is affected by the polarity bit.\nThe OUT signal can also be used as input to other modules. This is controlled by the registers of the corresponding module.",
    "44.3 ZCD Logic Polarity\nThe POL bit inverts the OUT bit relative to the current source and sink output. When the POL bit is set, an OUT high indicates that the current source is active and a low output indicates that the current sink is active. The POL bit affects the ZCD interrupts.",
    "44.4 ZCD Interrupts\nAn interrupt will be generated upon a change in the ZCD logic output when the appropriate interrupt enables are set. The ZCD module has a rising edge detector and a falling edge detector.\nThe ZCDIF bit of the PIRx register will be set when either edge detector is triggered and its associated enable bit is set. The INTP enables rising edge interrupts and the INTN bit enables falling edge interrupts.\nTo fully enable the interrupt, the following bits must be set:\n\u00b7 ZCDIE bit of the PIEx register\n\u00b7 INTP bit for rising edge detection\n\u00b7 INTN bit for falling edge detection\n\u00b7 GIEL and GIE bits of the INTCON0 register\nChanging the POL bit will cause an interrupt, regardless of the level of the SEN bit.\nThe ZCDIF bit of the PIRx register must be cleared in software as part of the interrupt service. If another edge is detected while this flag is being cleared, the flag will still be set at the end of the sequence.",
    "44.5 Correction for Z CPINV Offset\nThe actual voltage at which the ZCD switches is the reference voltage at the noninverting input of the ZCD op amp. For external voltage source waveforms other than square waves, this voltage offset from zero causes the zero-cross event to occur either too early or too late.",
    "44.5.1 Correction by AC Coupling\nWhen the external voltage source is sinusoidal, the effects of the Z CPINV offset can be eliminated by isolating the external voltage source from the ZCD pin with a capacitor, in addition to the voltage reducing resistor. The capacitor will cause a phase shift resulting in the ZCD output switch in advance of the actual zero-crossing event. The phase shift will be the same for both rising and falling zero-crossings, which can be compensated for by either delaying the CPU response to the ZCD switch by a timer or other means or selecting a capacitor value large enough that the phase shift is negligible.\nTo determine the series resistor and capacitor values for this configuration, start by computing the impedance, Z, to obtain a peak current less than the maximum input current (ZC02). Refer to the \"Electrical Specifications\" chapter for more details. Next, arbitrarily select a suitably large nonpolar capacitor and compute its reactance, Xc, at the external voltage source frequency. Finally, compute the series resistor, capacitor peak voltage, and phase shift using the formulas shown below.",
    "44.5.1 Correction by AC Coupling\nWhen this technique is used and the input signal is not present, the ZCD will tend to oscillate. To avoid this oscillation, connect the ZCD pin to V DD or GND with a high-impedance resistor.\nNote: In this example, the impedance value is calculated for a peak current of 300 \u03bcA.\nEquation 44-2. R-C Equations\nVPEAK = external voltage source peak voltage f = external voltage source frequency\nC = series capacitor\nR = series resistor\nVC = peak capacitor voltage\n\u03a6 = capacitor induced zero-crossing phase advance in radians\nT\u03a6 = time ZC event occurs before actual zero-crossing\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nV C = X C 3 \u00d7 10 -4\n<!-- formula-not-decoded -->",
    "44.5.1 Correction by AC Coupling\n```\nEquation 44-3. R-C Calculation Example V rms = 120 V PEAK = V rms \u00d7 2 = 169.7 f = 60 Hz C = 0.1 \u03bcF Z = V PEAK 3 \u00d7 10 -4 = 169.7 3 \u00d7 10 -4 = 565.7 k\u03a9 X C = 2\u03c0fC 1 = 1 2\u03c0 \u00d7 60 \u00d7 10 -7 = 26.53 k\u03a9 R = Z 2 -X C 2 = 565.1 k\u03a9 computed R a = 560 k\u03a9 used Z R = R a 2 +X C 2 = 560.6 k\u03a9 I PEAK = V PEAK Z R = 302.7 \u00d7 10 -6 A V C = X C \u00d7I PEAK = 8.0 V \u03a6 = tan -1 X C R = 0.047 radians T \u03a6 = 2\u03c0f \u03a6 = 125.6 \u03bcs\n```",
    "44.5.2 Correction by Offset Current\nWhen the waveform is varying relative to VSS, the zero-cross is detected too early as the waveform falls and too late as the waveform rises. When the waveform is varying relative to V DD, the zero-cross is detected too late as the waveform rises and too early as the waveform falls. The actual offset time can be determined for sinusoidal waveforms with the corresponding equations shown below.\nEquation 44-4. ZCD Event Offset\nWhen External Voltage source is relative to V SS :\nWhen External Voltage source is relative to V DD:\n<!-- formula-not-decoded -->\nThis offset time can be compensated for by adding a pull-up or pull-down biasing resistor to the ZCD pin. A pull-up resistor is used when the external voltage source is varying relative to V SS . A pull-down resistor is used when the voltage is varying relative to V DD. The resistor adds a bias to the ZCD pin so that the target external voltage source must go to zero to pull the pin voltage to the Z CPINV switching voltage. The pull-up or pull-down value can be determined with the equations shown below.",
    "44.5.2 Correction by Offset Current\n<!-- formula-not-decoded -->\nEquation 44-5. ZCD Pull-up/Pull-down Resistor\nWhen External Voltage source is relative to V SS :\nWhen External Voltage source is relative to V DD:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "44.6 Handling VPEAK Variations\nIf the peak amplitude of the external voltage is expected to vary, the series resistor must be selected to keep the ZCD current source and to sink below the design maximum range specified by ZC02 and above a reasonable minimum range, depending on the application. The compensating pull-up for this series resistance can be determined with the equations shown in Equation 44-5 because the pull-up value is independent from the peak voltage.\nTip: It is recommended that the maximum peak voltage be no more than six times the minimum peak voltage.",
    "44.7 Operation During Sleep\nThe ZCD current sources and interrupts are unaffected by Sleep.",
    "44.8 Effects of a Reset\nThe ZCD circuit can be configured to default to the Active or Inactive state on Power-on Reset (POR). When the ZCD Configuration bit is cleared, the ZCD circuit will be active at POR. When the ZCD Configuration bit is set, the SEN bit must be set to enable the ZCD module.",
    "44.9 Disabling the ZCD Module\nThe ZCD module can be disabled in two ways:\n1. The ZCD Configuration bit disables the ZCD module when set. When this is the case, then the ZCD module will be enabled by setting the SEN bit. When the ZCD bit is clear, the ZCD is always enabled and the SEN bit has no effect.\n2. The ZCD can also be disabled using the ZCDMD bit of the PMDx register. This is subject to the status of the ZCD bit.",
    "44.10 Register Definitions: ZCD Control\nLong bit name prefixes for the ZCD peripherals are shown in the table below. Refer to the 'Long Bit Names' section of the 'Register and Bit Naming Conventions' chapter for more information.",
    "Table 44-1. ZCD Long Bit Name Prefixes\nZCD, Bit Name Prefix = ZCD",
    "44.10.1  ZCDCON\nName: Address:\nZCDCON 0x04C",
    "Zero-Cross Detect Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SEN. , 2 = . , 3 = OUT. , 4 = POL. , 5 = . , 6 = . , 7 = INTP. , 8 = INTN. Access, 1 = R/W. Access, 2 = . Access, 3 = R. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SEN Zero-Cross Detect Software Enable\nThis bit is ignored when the ZCD fuse is cleared.\nX, Condition = ZCD Config fuse = 0. X, Description = Zero-cross detect is always enabled. This bit is ignored.. 1, Condition = ZCD Config fuse = 1. 1, Description = Zero-cross detect is enabled. ZCD pin is forced to output to source and sink current.. 0, Condition = ZCD Config fuse = 1. 0, Description = Zero-cross detect is disabled. ZCD pin operates according to PPS and TRIS controls.",
    "Bit 5 - OUT Zero-Cross Detect Data Output\n1, Condition = POL = 0. 1, Description = ZCD pin is sinking current. 0, Condition = POL = 0. 0, Description = ZCD pin is sourcing current. 1, Condition = POL = 1. 1, Description = ZCD pin is sourcing current. 0, Condition = POL = 1. 0, Description = ZCD pin is sinking current",
    "Bit 4 - POL Zero-Cross Detect Polarity\n1, Description = ZCD logic output is inverted. 0, Description = ZCD logic output is not inverted",
    "Bit 1 - INTP Zero-Cross Detect Positive-Going Edge Interrupt Enable\n1, Description = The ZCDIF bit is set on low-to-high ZCD_output transition. 0, Description = The ZCDIF bit is unaffected by low-to-high ZCD_output transition",
    "Bit 0 - INTN Zero-Cross Detect Negative-Going Edge Interrupt Enable\n1, Description = The ZCDIF bit is set on high-to-low ZCD_output transition. 0, Description = The ZCDIF bit is unaffected by high-to-low ZCD_output transition",
    "44.11 Register Summary - ZCD\n0x00 ... 0x4B, Name = Reserved. 0x00 ... 0x4B, Bit Pos. = . 0x00 ... 0x4B, 7 = . 0x00 ... 0x4B, 6 = . 0x00 ... 0x4B, 5 = . 0x00 ... 0x4B, 4 = . 0x00 ... 0x4B, 3 = . 0x00 ... 0x4B, 2 = . 0x00 ... 0x4B, 1 = . 0x00 ... 0x4B, 0 = . 0x4C, Name = ZCDCON. 0x4C, Bit Pos. = 7:0. 0x4C, 7 = SEN. 0x4C, 6 = . 0x4C, 5 = OUT. 0x4C, 4 = POL. 0x4C, 3 = . 0x4C, 2 = . 0x4C, 1 = INTP. 0x4C, 0 = INTN",
    "45. Instruction Set Summary\nThe PIC18 devices incorporate the standard set of PIC18 core instructions, as well as an extended set of instructions to optimize code that is recursive or that utilizes a software stack. The extended set is discussed later in this section.",
    "45.1 Standard Instruction Set\nThe standard PIC18 instruction set adds many enhancements to the previous PIC  MCU instruction \u00ae sets while maintaining an easy migration from these PIC MCU instruction sets. Most instructions are a single program memory word (16 bits), but there are a few instructions that require two- or three-program memory locations.\nEach single-word instruction is a 16-bit word divided into an opcode that specifies the instruction type and one or more operands, which further specifies the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\n\u00b7 Byte-oriented operations\n\u00b7 Bit-oriented operations\n\u00b7 Literal operations\n\u00b7 Control operations\nThe PIC18 instruction set summary in Table 45-2 lists byte-oriented, bit-oriented, literal and control operations. Table 45-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n\u00b7 The file register (specified by 'f')\n\u00b7 The destination of the result (specified by 'd')\n\u00b7 The accessed memory (specified by 'a')",
    "45.1 Standard Instruction Set\nThe file register designator 'f' specifies which file register is to be used by the instruction. The destination designator 'd' specifies where the result of the operation is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result is placed in the file register specified in the instruction.\nAll bit-oriented instructions have three operands:\n\u00b7 The file register (specified by 'f')\n\u00b7 The bit in the file register (specified by 'b')\n\u00b7 The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\n\u00b7 A literal value to be loaded into a file register (specified by 'k')\n\u00b7 The desired FSR register to load the literal value into (specified by 'f')\n\u00b7 No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "45.1 Standard Instruction Set\n\u00b7 A program memory address (specified by 'n')\n\u00b7 The mode of the CALL or RETURN instructions (specified by 's')\n\u00b7 The mode of the table read and table write instructions (specified by 'm')\n\u00b7 No operand required (specified by '-')\nAll instructions are a single word, except for a few two- or three-word instructions. These instructions were made two- or three-words to contain the required information in 32 or 48 bits. In the second and third words, the four MSbs are ' 1 's. If this second or third word is executed as an instruction (by itself), it will execute as a NOP .\nAll single-word instructions are executed in a single instruction cycle, unless a conditional test is true or the Program Counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles, with the additional instruction cycle(s) executed as a NOP .\nThe two-word instructions execute in two instruction cycles and three-word instructions execute in three instruction cycles.",
    "45.1 Standard Instruction Set\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \u03bcs. If a conditional test is true or the Program Counter is changed as a result of an instruction, the instruction execution time is 2 \u03bcs. Two-word branch instructions (if true) take 3 \u03bcs.\nFigure 45-1, Figure 45-2 and Figure 45-3 show the general formats that the instructions can have. All examples use the convention ' nnh ' to represent a hexadecimal number.\nThe Instruction Set Summary, shown in Table 45-2, lists the standard instructions recognized by the Microchip MPASM TM  Assembler.\nThe Standard Instruction Set section provides a description of each instruction.\n\nTable 45-1. Opcode Field Descriptions",
    "45.1 Standard Instruction Set\na, Description = RAM access bit a = 0 : RAM location in Access RAM (BSR register is ignored) a = 1 : RAM bank is specified by BSR register (default). ACCESS, Description = ACCESS = 0 : RAM access bit symbol. BANKED, Description = BANKED = 1 : RAM access bit symbol. bbb, Description = Bit address within an 8-bit file register (0 to 7). BSR, Description = Bank Select Register (BSR). Used to select the current RAM bank.. d, Description = Destination select bit d = 0 : store result in WREG d = 1 : store result in file register f (default). dest, Description = Destination: either the WREG register or the specified register file location. f, Description = 8-bit register file address ( 00h to FFh ). f n, Description = FSR Number (0 to 2). f s, Description = 12-bit register file address ( 000h to FFFh ) or 14-bit register file address ( 0000h to 3FFFh ). This is the source address.. f d, Description = 12-bit register file address ( 000h to",
    "45.1 Standard Instruction Set\nFFFh ) or 14-bit register file address ( 0000h to 3FFFh ). This is the destination address.. z s, Description = 7-bit literal offset for FSR2 to used as register file address ( 000h to FFFh ). This is the source address.. z d, Description = 7-bit literal offset for FSR2 to used as register file address ( 000h to FFFh ). This is the destination address.. k, Description = Literal field, constant data or label (may be either a 6-bit, 8-bit, 12-bit or a 20-bit value). label, Description = Label name. mm, Description = The mode of the TBLPTR register for the table read and table write instructions. Only used with table read and table write instructions:. *, Description = No change to register (such as TBLPTR with table reads and writes). *+, Description = Post-Increment register (such as TBLPTR with table reads and writes). *-, Description = Post-Decrement register (such as TBLPTR with table reads and writes). +*, Description =",
    "45.1 Standard Instruction Set\nPre-Increment register (such as TBLPTR with table reads and writes)",
    "45.1 Standard Instruction Set\nn, ...........continued.Description = The relative address (two's complement number) for relative branch instructions or the direct address for call/branch and return instructions. PRODH, ...........continued.Description = Product of multiply high byte. PRODL, ...........continued.Description = Product of multiply low byte. s, ...........continued.Description = Fast Call/Return mode select bit s = 0 : do not update into/from shadow registers (default) s = 1 : certain registers loaded into/from shadow registers (Fast mode). u, ...........continued.Description = Unused or unchanged. W, ...........continued.Description = W= 0 : Destination select bit symbol. WREG, ...........continued.Description = Working register (accumulator). x, ...........continued.Description = Don't care (' 0 ' or ' 1",
    "45.1 Standard Instruction Set\n'). The assembler will generate code with x = 0 . It is the recommended form of use for compatibility with all Microchip software tools.. TBLPTR, ...........continued.Description = 21-bit Table Pointer (points to a program memory location). TABLAT, ...........continued.Description = 8-bit table latch. TOS, ...........continued.Description = Top-of-stack (TOS). PC, ...........continued.Description = Program Counter. PCL, ...........continued.Description = Program Counter low byte. PCH, ...........continued.Description = Program Counter high byte. PCLATH, ...........continued.Description = Program Counter high byte latch. PCLATU, ...........continued.Description = Program Counter upper byte Latch. GIE, ...........continued.Description",
    "45.1 Standard Instruction Set\n= Global Interrupt Enable bit. WDT, ...........continued.Description = Watchdog Timer. TO, ...........continued.Description = Time-Out bit. PD, ...........continued.Description = Power-Down bit. C, DC, Z, OV,, ...........continued.Description = ALU Status bits: Carry, Digit Carry, Zero, Overflow, Negative. { }, ...........continued.Description = Optional argument. [ ], ...........continued.Description = Indexed address. ( ), ...........continued.Description = Contents. < >, ...........continued.Description = Register bit field. [expr]<n>, ...........continued.Description = Specifies bit n of the register indicated by pointer expr. \u2192, ...........continued.Description =",
    "45.1 Standard Instruction Set\nAssigned to. \u2208, ...........continued.Description = In the set of. italics, ...........continued.Description = User defined term (font is Courier)",
    "Byte-oriented file register operations\nd = 0 for result destination to be WREG register\nd = 1 for result destination to be file register (f)\na = 0 to force Access Bank\na = 1 for BSR to select bank\nf  = 8-bit file register address",
    "Byte to Byte move operations ( two -word)\nOPCODE, 11 12 = f (Source FILE #). OPCODE, 0 = . 15 12, 11 12 = 11. 15 12, 0 = 0. 1111, 11 12 = f (Destination FILE #). 1111, 0 = ",
    "Byte to Byte move operations ( three -word)\nOPCODE,  = OPCODE. OPCODE, 3 = FILE #. OPCODE, 0 = FILE #. 15,  = 11. 15, 3 = . 15, 0 = 0. 1111,  = FILE #. 1111, 3 = . 1111, 0 = . 15,  = 11. 15, 3 = . 15, 0 = 0. 1111,  = FILE #. 1111, 3 = . 1111, 0 = ",
    "Example Instruction\nADDWF MYREG, W, B\nMOVFF MYREG1, MYREG2\nMOVFFL MYREG1, MYREG2",
    "Bit-oriented file register operations\nb = 3-bit position of bit in file register (f) a = 0 to force Access Bank a = 1 for BSR to select bank f  = 8-bit file register address",
    "Example Instruction\n15\n0\nOPCODE\nk (literal)\nMOVLW 7Fh\n7\n8\nBSF MYREG, bit, B\n15\n8 7\n0\nOPCODE\nk<7:0> (literal)\nGOTO Label\n15\n12 11\n0\nOPCODE\nk<19:8> (literal)",
    "k  = 20-bit immediate value\n15\n8 7 9\n0\nOPCODE\nk<7:0> (literal)\n15\n12 11\n0\nOPCODE\nk<19:8> (literal)\nk  = 20-bit immediate value s  = Fast bit\ns\nCALL MYFUNC\n15\n11 10\n0\nOPCODE\nn<10:0> (literal)\nBRA MYFUNC",
    "n  = 11-bit immediate value\n15\n8 7\n0\nOPCODE\nn<7:0> (literal)\nBC MYFUNC\nn  = 8-bit immediate value\nStandard Instruction Set\nTable 45-2.\nStatus Affected, 1 = C, DC, Z, OV, N. Status Affected,  = C, DC, Z, OV, N. Status Affected, 1 = Z, N. Status Affected, 1 = Z. Status Affected, 1 = Z, N. Status Affected, 1 = C, DC, Z, OV, N. Status Affected, 1 1 = C, DC, Z, OV, N Z, N. Status Affected, 1 = Z, N. Status Affected, 1, 3, 4 = None. Status Affected,  = . Status Affected, 1, 3 = None. Status Affected,  = None. Status Affected,  = None. Status Affected, 1 1 = C, DC, Z, OV, N. Status Affected, 1 = C, Z, N. Status Affected, 1 = Z, N C, Z, N. Status Affected, 1 = Z, N. Status Affected,",
    "n  = 11-bit immediate value\n= None. Status Affected, 1 = DC, Z, OV, N. Status Affected, 1 = C, DC, Z, OV, N C,. Status Affected, 1 = C, DC, Z, OV, N. Status Affected, 1 = None. Status Affected, 1 1 = . Status Affected,  = Z, N. Status Affected, 1, 2 = None. LSb, 1 = ffff. LSb,  = ffff. LSb, 1 = ffff. LSb, 1 = ffff. LSb, 1 = ffff ffff. LSb, 1 = ffff. LSb, 1 1 = ffff. LSb, 1 = ffff. LSb, 1, 3, 4 = f s f s f s f s. LSb,  = f d f d f d f d f f f f. LSb, 1, 3 = s s s s f s f s f d f d. LSb,  = f d f d f d f d. LSb,",
    "n  = 11-bit immediate value\n= ffff. LSb, 1 1 = ffff. LSb, 1 = ffff ffff. LSb, 1 = ffff. LSb, 1 = ffff. LSb,  = ffff. LSb, 1 = ffff ffff. LSb, 1 = ffff. LSb, 1 = ffff. LSb, 1 = ffff. LSb, 1 1 = . LSb,  = ffff. LSb, 1, 2 = ffff. Instruction Word, 1 = ffff. Instruction Word,  = ffff. Instruction Word, 1 = ffff. Instruction Word, 1 = ffff. Instruction Word, 1 = ffff ffff. Instruction Word, 1 = ffff. Instruction Word, 1 1 = . Instruction Word, 1 = ffff. Instruction Word, 1, 3, 4 = ffff. Instruction Word,  = f s f s f s f s. Instruction Word, 1, 3 = f d f d f d f d 0110. Instruction Word,  = f s f s f s f s f d f d f d f d. Instruction Word,",
    "n  = 11-bit immediate value\n= ffff. Instruction Word, 1 1 = ffff. Instruction Word, 1 = ffff. Instruction Word, 1 = ffff ffff. Instruction Word, 1 = ffff. Instruction Word,  = ffff. Instruction Word, 1 = ffff ffff. Instruction Word, 1 = ffff. Instruction Word, 1 = ffff. Instruction Word, 1 = ffff. Instruction Word, 1 1 = ffff. Instruction Word,  = . Instruction Word, 1, 2 = ffff. Instruction Word, 1 = REGISTER INSTRUCTIONS 01da. Instruction Word,  = 00da. Instruction Word, 1 = 01da. Instruction Word, 1 = 101a. Instruction Word, 1 = 11da 01da. Instruction Word, 1 = 10da. Instruction Word, 1 1 = 00da. Instruction Word, 1 = 00da. Instruction Word, 1, 3, 4 = . Instruction Word,  = f s f s f s f s f f f f. Instruction Word, 1, 3 = d d d d 0000. Instruction Word,  = f s f s f s f s f d f d f d f d. Instruction Word,",
    "n  = 11-bit immediate value\n= 111a. Instruction Word, 1 1 = 001a 110a. Instruction Word, 1 = 01da. Instruction Word, 1 = 01da. Instruction Word, 1 = 00da. Instruction Word,  = 00da. Instruction Word, 1 = 100a. Instruction Word, 1 = 01da 11da. Instruction Word, 1 = 10da. Instruction Word, 1 = 10da 10da. Instruction Word, 1 1 = . Instruction Word,  = INSTRUCTIONS. Instruction Word, 1, 2 = 001a. MSb FILE, 1 = 0010. MSb FILE,  = 0010. MSb FILE, 1 = 0001. MSb FILE, 1 = 0110. MSb FILE, 1 = 0001. MSb FILE, 1 = 0000 0010. MSb FILE, 1 1 = 0001. MSb FILE, 1 = 0101. MSb FILE, 1, 3, 4 = 1100. MSb FILE,  = 1111. MSb FILE, 1, 3 = 0000 1111. MSb FILE,  = 1111. MSb FILE,",
    "n  = 11-bit immediate value\n= 0110. MSb FILE, 1 1 = 0000. MSb FILE, 1 = 0110 0011. MSb FILE, 1 = 0100. MSb FILE, 1 = 0011. MSb FILE,  = 0100. MSb FILE, 1 = 0110. MSb FILE, 1 = 0101 0101. MSb FILE, 1 = 0101. MSb FILE, 1 = . MSb FILE, 1 1 = 0011. MSb FILE,  = 0001 BYTE-ORIENTED SKIP. MSb FILE, 1, 2 = 0110. MSb FILE, 1 = BYTE-ORIENTED 1. MSb FILE,  = 1. MSb FILE, 1 = 1. MSb FILE, 1 = 1. MSb FILE, 1 = 1. MSb FILE, 1 = 1. MSb FILE, 1 1 = 1 1. MSb FILE, 1 = 1. MSb FILE, 1, 3, 4 = 2. MSb FILE,  = . MSb FILE, 1, 3 = 3. MSb FILE,  = . MSb FILE,",
    "n  = 11-bit immediate value\n= 1. MSb FILE, 1 1 = 1. MSb FILE, 1 = 1 1. MSb FILE, 1 = 1. MSb FILE, 1 = 1. MSb FILE,  = 1. MSb FILE, 1 = 1 1. MSb FILE, 1 = 1. MSb FILE, 1 = 1. MSb FILE, 1 = 1. MSb FILE, 1 1 = 1. MSb FILE,  = . MSb FILE, 1, 2 = 1 - 4. Description, 1 = Add WREG and f. Description,  = Add WREG and Carry bit to f. Description, 1 = AND WREG with f. Description, 1 = Clear f. Description, 1 = Complement f Decrement f. Description, 1 = Increment f. Description, 1 1 = Inclusive OR WREG with f. Description, 1 = Move f to WREG or f. Description, 1, 3, 4 = Move f s (12-bit source) to f d (12-bit destination). Description,  = Move f s (14-bit source). Description, 1, 3 = to f d (14-bit destination). Description,",
    "n  = 11-bit immediate value\n= Move WREG to f. Description,  = Multiply WREG with f. Description, 1 1 = . Description, 1 = Negate f Rotate Left f through Carry. Description, 1 = Rotate Left f (No Carry). Description, 1 = Rotate Right f through Carry. Description,  = Rotate Right f (No Carry) Set f. Description, 1 = Subtract f from WREG with. Description, 1 = Borrow Subtract WREG from f. Description, 1 = Subtract WREG from f with. Description, 1 = Borrow. Description, 1 1 = Swap nibbles in f. Description,  = Exclusive OR WREG with f. Description, 1, 2 = Compare f with WREG, skip if =. Mnemonic, Operands, 1 = f, d, a. Mnemonic, Operands,",
    "n  = 11-bit immediate value\n= f, d, a. Mnemonic, Operands, 1 = f, d, a. Mnemonic, Operands, 1 = f, a. Mnemonic, Operands, 1 = f, d, a f, d, a. Mnemonic, Operands, 1 = f, d, a. Mnemonic, Operands, 1 1 = f, d, a. Mnemonic, Operands, 1 = f, d, a. Mnemonic, Operands, 1, 3, 4 = f s , f d. Mnemonic, Operands,  = f , f. Mnemonic, Operands, 1, 3 = s d. Mnemonic, Operands,  = f, a. Mnemonic, Operands,  = f, a. Mnemonic, Operands, 1 1 = f, a. Mnemonic, Operands, 1 = f, d, a. Mnemonic, Operands, 1 = f, d, a f, d, a. Mnemonic, Operands, 1 = . Mnemonic, Operands,",
    "n  = 11-bit immediate value\n= f, d, a. Mnemonic, Operands, 1 = f, a f, d, a. Mnemonic, Operands, 1 = f, d, a. Mnemonic, Operands, 1 = . Mnemonic, Operands, 1 = f, d, a. Mnemonic, Operands, 1 1 = f, d, a. Mnemonic, Operands,  = f, d, a. Mnemonic, Operands, 1, 2 = f, a. Mnemonic, Operands, 1 = ADDWF. Mnemonic, Operands,  = . Mnemonic, Operands, 1 = ADDWFC ANDWF. Mnemonic, Operands, 1 = CLRF. Mnemonic, Operands, 1 = COMF DECF. Mnemonic, Operands, 1 = INCF. Mnemonic, Operands, 1 1 = IORWF. Mnemonic, Operands, 1 = MOVF. Mnemonic, Operands, 1, 3, 4 = . Mnemonic, Operands,",
    "n  = 11-bit immediate value\n= MOVFF. Mnemonic, Operands, 1, 3 = MOVFFL. Mnemonic, Operands,  = . Mnemonic, Operands,  = MOVWF. Mnemonic, Operands, 1 1 = MULWF NEGF. Mnemonic, Operands, 1 = RLCF. Mnemonic, Operands, 1 = RLNCF. Mnemonic, Operands, 1 = RRCF. Mnemonic, Operands,  = RRNCF. Mnemonic, Operands, 1 = SETF. Mnemonic, Operands, 1 = SUBFWB. Mnemonic, Operands, 1 = SUBWF. Mnemonic, Operands, 1 = SUBWFB. Mnemonic, Operands, 1 1 = SWAPF. Mnemonic, Operands,  = XORWF. Mnemonic, Operands, 1, 2 = CPFSEQ",
    "n  = 11-bit immediate value\nStatus Affected, 1, 2 1, 2 = None None. Status Affected, 1, 2 1, 2 = None None None. Status Affected, 1, 2 = None. Status Affected, 1, 2 1, 2 = None. Status Affected, 1 = None None. Status Affected, 1 1 = None. Status Affected, 1, 2 1, 2 = None None. Status Affected,  = None. Status Affected, 2 = None. Status Affected, 2 = None. Status Affected, 2 = None. Status Affected, 2 = None. Status Affected, 2 2 = None. Status Affected,",
    "n  = 11-bit immediate value\n= None None. Status Affected, 2 = None. Status Affected, 2 2 = None. Status Affected, 2, 3 = None. Status Affected, 2 3 = None. Status Affected, 2 = None. LSb ffff, 1, 2 1, 2 = ffff. LSb ffff, 1, 2 1, 2 = ffff ffff ffff. LSb ffff, 1, 2 = ffff. LSb ffff, 1, 2 1, 2 = ffff. LSb ffff, 1 = ffff ffff. LSb ffff, 1 1 = ffff. LSb ffff, 1, 2 1, 2 = ffff ffff. LSb ffff,  = . LSb ffff, 2 = nnnn nnnn. LSb ffff, 2 = nnnn. LSb ffff, 2 = nnnn. LSb ffff, 2 = nnnn. LSb ffff, 2 2 = nnnn. LSb ffff,",
    "n  = 11-bit immediate value\n= nnnn. LSb ffff, 2 = nnnn nnnn. LSb ffff, 2 2 = kkkk kkkk. LSb ffff, 2, 3 = 0100. LSb ffff, 2 3 = kkkk kkkk. LSb ffff, 2 = nnnn. Instruction Word ffff, 1, 2 1, 2 = ffff. Instruction Word ffff, 1, 2 1, 2 = ffff ffff ffff. Instruction Word ffff, 1, 2 = ffff. Instruction Word ffff, 1, 2 1, 2 = ffff. Instruction Word ffff, 1 = ffff ffff. Instruction Word ffff, 1 1 = ffff. Instruction Word ffff, 1, 2 1, 2 = ffff ffff. Instruction Word ffff,  = . Instruction Word ffff, 2 = nnnn nnnn. Instruction Word ffff, 2 = . Instruction Word ffff, 2 = nnnn. Instruction Word ffff, 2 = nnnn nnnn. Instruction Word ffff, 2 2 = nnnn. Instruction Word ffff,",
    "n  = 11-bit immediate value\n= nnnn. Instruction Word ffff, 2 = nnnn nnnn. Instruction Word ffff, 2 2 = kkkk. Instruction Word ffff, 2, 3 = kkkk. Instruction Word ffff, 2 3 = 0001 kkkk. Instruction Word ffff, 2 = kkkk nnnn. 16-Bit 010a, 1, 2 1, 2 = 000a. 16-Bit 010a, 1, 2 1, 2 = 11da 11da 11da. 16-Bit 010a, 1, 2 = 10da. 16-Bit 010a, 1, 2 1, 2 = 011a REGISTER INSTRUCTIONS. 16-Bit 010a, 1 = bbba bbba. 16-Bit 010a, 1 1 = bbba INSTRUCTIONS. 16-Bit 010a, 1, 2 1, 2 = bbba bbba. 16-Bit 010a,",
    "n  = 11-bit immediate value\n= INSTRUCTIONS. 16-Bit 010a, 2 = 0010. 16-Bit 010a, 2 = 0110. 16-Bit 010a, 2 = 0011. 16-Bit 010a, 2 = 0111 0101. 16-Bit 010a, 2 2 = 0001. 16-Bit 010a,  = 0100. 16-Bit 010a, 2 = 0nnn 0000. 16-Bit 010a, 2 2 = 110s. 16-Bit 010a, 2, 3 = kkkk 0000. 16-Bit 010a, 2 3 = 1111 kkkk. 16-Bit 010a, 2 = 1nnn. MSb, 1, 2 1, 2 = 0110 0110. MSb, 1, 2 1, 2 = 0010 0100 0011. MSb, 1, 2 = 0100. MSb, 1, 2 1, 2 = 0110 FILE. MSb, 1 = 1001 1000. MSb, 1 1 = 0111 BIT-ORIENTED SKIP. MSb, 1, 2 1, 2 = 1011. MSb,",
    "n  = 11-bit immediate value\n= 1010 CONTROL. MSb, 2 = 1110. MSb, 2 = 1110. MSb, 2 = 1110. MSb, 2 = 1110 1110. MSb, 2 2 = 1110. MSb,  = 1110. MSb, 2 = 1101 1110. MSb, 2 2 = 1110 1111. MSb, 2, 3 = 0000. MSb, 2 3 = 1110 1111. MSb, 2 = 1101. Cycles, 1, 2 1, 2 = 1 - 4 1 - 4. Cycles, 1, 2 1, 2 = 1 - 4 1 - 4 1 - 4. Cycles, 1, 2 = 1 - 4. Cycles, 1, 2 1, 2 = 1 - 4 BIT-ORIENTED. Cycles, 1 = 1 1. Cycles, 1 1 = 1. Cycles, 1, 2 1, 2 = 1 - 4 1 - 4. Cycles,  = . Cycles, 2 = 1 - 2. Cycles, 2 = 1 - 2. Cycles, 2 = 1 - 2. Cycles, 2 = 1 - 2. Cycles, 2 2 = 1 - 2 1 - 2. Cycles,",
    "n  = 11-bit immediate value\n= 1 - 2. Cycles, 2 = 2 1 - 2. Cycles, 2 2 = . Cycles, 2, 3 = 2. Cycles, 2 3 = 2 2. Cycles, 2 = 2. Description, 1, 2 1, 2 = Compare f with WREG, skip if Compare f with WREG, skip if. Description, 1, 2 1, 2 = Decrement f, Skip if 0 Decrement f, Skip if Not 0 Increment f, Skip if 0. Description, 1, 2 = Increment f, Skip if Not 0. Description, 1, 2 1, 2 = Test f, skip if 0. Description, 1 = Bit Clear f Bit Set f. Description, 1 1 = Bit Toggle f. Description, 1, 2 1, 2 = Bit Test f, Skip if Clear Bit Test f, Skip if Set. Description,  = . Description, 2 = Branch if Carry. Description, 2 = Branch if Negative. Description, 2 = Branch if Not Carry. Description, 2 = Branch if Not Negative Branch if Not Overflow. Description, 2 2 = Branch if Not Zero. Description,",
    "n  = 11-bit immediate value\n= Branch if Overflow Branch Unconditionally. Description, 2 = Branch if Zero. Description, 2 2 = Call subroutine. Description, 2, 3 = Call subroutine using WREG. Description, 2 3 = Go to address. Description, 2 = Relative Call. , 1, 2 1, 2 = f, a f, a. , 1, 2 1, 2 = f, d, a f, d, a f, d, a. , 1, 2 = f, d, a. , 1, 2 1, 2 = f, a. , 1 = f, b, a f, b, a. , 1 1 = f, b, a. , 1, 2 1, 2 = f, b, a f, b, a. ,  = . , 2 = n. , 2 = n. , 2 = n. , 2 = n n. , 2 2 = n. ,",
    "n  = 11-bit immediate value\n= n. , 2 = n n. , 2 2 = k, s. , 2, 3 = -. , 2 3 = k. , 2 = n. ...........continued Mnemonic, Operands, 1, 2 1, 2 = CPFSGT CPFSLT. ...........continued Mnemonic, Operands, 1, 2 1, 2 = DECFSZ DCFSNZ INCFSZ. ...........continued Mnemonic, Operands, 1, 2 = INFSNZ. ...........continued Mnemonic, Operands, 1, 2 1, 2 = TSTFSZ. ...........continued Mnemonic, Operands, 1 = BCF BSF. ...........continued Mnemonic, Operands, 1 1 = BTG. ...........continued Mnemonic, Operands, 1, 2 1, 2 = BTFSC BTFSS.",
    "n  = 11-bit immediate value\n...........continued Mnemonic, Operands,\n= . ...........continued Mnemonic, Operands, 2 = BC. ...........continued Mnemonic, Operands, 2 = BN. ...........continued Mnemonic, Operands, 2 = BNC BNN. ...........continued Mnemonic, Operands, 2 = BNOV. ...........continued Mnemonic, Operands, 2 2 = BNZ. ...........continued Mnemonic, Operands,",
    "n  = 11-bit immediate value\n= BOV. ...........continued Mnemonic, Operands, 2 = BRA BZ. ...........continued Mnemonic, Operands, 2 2 = CALL. ...........continued Mnemonic, Operands, 2, 3 = CALLW. ...........continued Mnemonic, Operands, 2 3 = GOTO. ...........continued Mnemonic, Operands, 2 = RCALL\n...........continued",
    "n  = 11-bit immediate value\nINTCONx STAT bits,  = None. INTCONx STAT bits, 2 = None. INTCONx STAT bits, 2 = TO, PD. INTCONx STAT bits,  = C. INTCONx STAT bits,  = None None. INTCONx STAT bits, 3 = None. INTCONx STAT bits,  = None. INTCONx STAT bits,  = All. INTCONx STAT bits,  = TO, PD. INTCONx STAT bits,  = . INTCONx STAT bits,  = None C, DC, Z, OV, N. INTCONx STAT bits,  = Z, N. INTCONx STAT bits,  = Z, N. INTCONx STAT bits, 3 = None. INTCONx STAT bits,  = None. INTCONx STAT bits,  = None. INTCONx STAT bits,  = None None C, DC, Z, OV, N. INTCONx STAT bits,  = Z, N None. INTCONx STAT bits,  = . INTCONx STAT bits,  = None. INTCONx STAT bits,  = None. INTCONx STAT bits,  = None. 000s,",
    "n  = 11-bit immediate value\n= kkkk. 000s, 2 = 001s. 000s, 2 = 0100. 000s,  = 0111. 000s,  = 0000. 000s, 3 = xxxx. 000s,  = 0110 0101. 000s,  = 1111. 000s,  = 0011. 000s,  = . 000s,  = kkkk kkkk. 000s,  = kkkk. 000s,  = kkkk. 000s, 3 = kkkk kkkk. 000s,  = . 000s,  = kkkk kkkk. 000s,  = kkkk kkkk kkkk. 000s,  = kkkk. 000s,  = . 000s,  = 1000 1001. 000s,  = 1010. 000s,  = 1011. 0001,  = kkkk. 0001, 2 = 0001. 0001, 2 = 0000. 0001,  = 0000. 0001,  = 0000 xxxx. 0001, 3 = . 0001,  = 0000 0000. 0001,  = 1111. 0001,  = . 0001,",
    "n  = 11-bit immediate value\n= 0000. 0001,  = f n f n kk. 0001,  = kkkk. 0001,  = kkkk kkkk. 0001, 3 = 00f n f n. 0001,  = kkkk. 0001,  = 00kk kkkk. 0001,  = kkkk f n f n kk kkkk. 0001,  = kkkk. 0001,  = INSTRUCTIONS. 0001,  = 0000. 0001,  = 0000 0000. 0001,  = 0000. 0000,  = 1100. 0000, 2 = 0000 INSTRUCTIONS. 0000, 2 = 0000. 0000,  = 0000. 0000,  = 0000. 0000, 3 = xxxx. 0000,  = 0000 0000. 0000,  = 0000. 0000,  = 0000. 0000,  = INSTRUCTIONS. 0000,  = 1000. 0000,  = 1111. 0000,  = 1011. 0000, 3 = 1001 1110. 0000,  = 00kk. 0000,  = 0001 1110. 0000,  = 1100 1001. 0000,",
    "n  = 11-bit immediate value\n= 1000 1010. 0000,  = MEMORY. 0000,  = 0000 0000. 0000,  = 0000. 0000,  = 0000. 0000,  = 0000. 0000, 2 = 0000 INHERENT. 0000, 2 = 0000. 0000,  = 0000. 0000,  = 0000 1111. 0000, 3 = 0000. 0000,  = 0000. 0000,  = 0000. 0000,  = 0000. 0000,  = LITERAL. 0000,  = 1110. 0000,  = 0000. 0000,  = 0000 0000. 0000, 3 = 1110. 0000,  = 1111. 0000,  = 0000 0000. 0000,  = 0000 1110. 0000,  = 0000 0000. 0000,  = - PROGRAM. 0000,  = 0000 0000. 0000,  = 0000. 0000,  = 0000. 2,  = 2. 2, 2 = 2. 2, 2 = 1. 2,  = 1. 2,  = 1. 2, 3 = 1 1. 2,  = 1. 2,",
    "n  = 11-bit immediate value\n= 1. 2,  = 1. 2,  = . 2,  = 1 1. 2,  = . 2,  = 1 1. 2, 3 = 2. 2,  = . 2,  = 1 1. 2,  = 2 1. 2,  = 1 1. 2,  = DATA MEMORY. 2,  = 2 2. 2,  = 2. 2,  = 2. Return from interrupt enable,  = Return with literal in WREG. Return from interrupt enable, 2 = Return from Subroutine. Return from interrupt enable, 2 = Clear Watchdog Timer. Return from interrupt enable,  = Decimal Adjust WREG. Return from interrupt enable,  = No Operation No Operation. Return from interrupt enable, 3 = Pop top of return stack (TOS). Return from interrupt enable,  = Push top of return stack (TOS). Return from interrupt enable,  = Software device Reset. Return from interrupt enable,  = Go into Standby mode. Return from interrupt enable,  = . Return from interrupt enable,  = Add FSR (f n ) with literal (k) Add literal and WREG. Return from interrupt enable,  = . Return from interrupt enable,",
    "n  = 11-bit immediate value\n= AND literal with WREG Inclusive OR literal with WREG. Return from interrupt enable, 3 = Load FSR(f n ) with a 14-bit. Return from interrupt enable,  = literal (k). Return from interrupt enable,  = Move literal to BSR<5:0> Move literal to WREG. Return from interrupt enable,  = Return with literal in WREG Subtract literal (k) from FSR (f n ) Subtract WREG from literal. Return from interrupt enable,  = Exclusive OR literal with WREG. Return from interrupt enable,  = . Return from interrupt enable,  = Table Read Table Read with post-increment. Return from interrupt enable,  = Table Read with post-decrement. Return from interrupt enable,  = Table Read with pre-increment. s,  = k. s, 2 = s. s, 2 = -. s,  = -. s,  = - -. s, 3 = -. s,  = -. s,  = -. s,  = -. s,  = . s,  = f n , k k. s,  = k. s,",
    "n  = 11-bit immediate value\n= k. s, 3 = f n , k. s,  = k. s,  = k. s,  = k f n , k k. s,  = k. s,  = . s,  = - -. s,  = -. s,  = -. RETFIE,  = RETLW. RETFIE, 2 = RETURN. RETFIE, 2 = CLRWDT. RETFIE,  = DAW. RETFIE,  = NOP NOP. RETFIE, 3 = POP. RETFIE,  = PUSH. RETFIE,  = RESET. RETFIE,  = SLEEP. RETFIE,  = . RETFIE,  = ADDFSR. RETFIE,  = ADDLW. RETFIE,  = ANDLW IORLW. RETFIE, 3 = . RETFIE,  = LFSR. RETFIE,  = MOVLB MOVLW. RETFIE,  = RETLW SUBFSR SUBLW. RETFIE,  = XORLW. RETFIE,  = . RETFIE,  = TBLRD* TBLRD*+. RETFIE,",
    "n  = 11-bit immediate value\n= TBLRD*-. RETFIE,  = TBLRD+*\n...........continued",
    "n  = 11-bit immediate value\nStatus Affected None,  = None. Status Affected None,  = None. Status Affected None,  = None. Status Affected None, if the data = themselves. For example,. Status Affected None, the = the instruction retrieves. LSb 1100,  = 1101. LSb 1100,  = 1110. LSb 1100,  = 1111. LSb 1100, if the data = on the pins. LSb 1100, the = first word of. Instruction Word 0000,  = 0000. Instruction Word 0000,  = 0000. Instruction Word 0000,  = 0000. Instruction Word 0000, if the data = be that value present back with a ' 0 '.. Instruction Word 0000, the = as a NOP unless the instruction.. 16-Bit 0000,  = 0000. 16-Bit 0000,  = 0000. 16-Bit 0000,  = 0000. 16-Bit 0000, if the data = value used will will be written. 16-Bit 0000, the = be executed have a valid. MSb 0000,  = 0000. MSb 0000,  = 0000. MSb 0000,",
    "n  = 11-bit immediate value\n= 0000. MSb 0000, if the data = 1, 0 ), the device, the data. MSb 0000, the = instructions will memory locations. Cycles 2,  = 2. Cycles 2,  = 2. Cycles 2,  = 2. Cycles 2, if the data = MOVF PORTB, an external. Cycles 2, the = words of these program. Description Table Write,  = Table Write with post-increment. Description Table Write,  = Table Write with post- decrement. Description Table Write,  = Table Write with pre-increment. Description Table Write, if the data = is modified as a function of itself (e.g., configured as input and is driven low by. Description Table Write, the = multi-word instructions. The extra in these 16 bits. This ensures that all. -,  = -. -,  = -. -,  = -. -, if the data = PORT register for a pin. -, the = are embedded. Mnemonic, Operands rota e hisp g 90 TBLWT*,",
    "n  = 11-bit immediate value\n= TBLWT*+. Mnemonic, Operands rota e hisp g 90 TBLWT*,  = TBLWT*-. Mnemonic, Operands rota e hisp g 90 TBLWT*,  = TBLWT+*. Mnemonic, Operands rota e hisp g 90 TBLWT*, if the data = Notes: rota e hisp g 90 1. When a latch is ' 1 '. Mnemonic, Operands rota e hisp g 90 TBLWT*, the = 3. Some instructions information 4. f and f do",
    "45.1.1 Standard Instruction Set\n{label} instruction argument(s) .\nImportant: All PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction format then becomes:",
    "45.1.1 Standard Instruction Set\nOperands, Add Literal to FSR.ADDFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operands, Add Literal to FSR.ADDFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operands, Add Literal to FSR.ADDFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operands, Add Literal to FSR.ADDFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operation, Add Literal to FSR.ADDFSR f n , k = (FSRf n ) + k \u2192 FSRf n. Operation, Add Literal to FSR.ADDFSR f n , k = (FSRf n ) + k \u2192 FSRf n. Operation, Add Literal to FSR.ADDFSR f n , k = (FSRf n ) + k \u2192 FSRf n. Operation, Add Literal to FSR.ADDFSR f n , k = (FSRf n ) + k \u2192",
    "45.1.1 Standard Instruction Set\nFSRf n. Status Affected, Add Literal to FSR.ADDFSR f n , k = None. Status Affected, Add Literal to FSR.ADDFSR f n , k = None. Status Affected, Add Literal to FSR.ADDFSR f n , k = None. Status Affected, Add Literal to FSR.ADDFSR f n , k = None. Encoding, Add Literal to FSR.ADDFSR f n , k = 1110. Encoding, Add Literal to FSR.ADDFSR f n , k = 1000. Encoding, Add Literal to FSR.ADDFSR f n , k = f n f n kk. Encoding, Add Literal to FSR.ADDFSR f n , k = kkkk. Description, Add Literal to FSR.ADDFSR f n , k = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f n '. Description, Add Literal to FSR.ADDFSR f n , k = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f n '. Description, Add Literal to",
    "45.1.1 Standard Instruction Set\nFSR.ADDFSR f n , k = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f n '. Description, Add Literal to FSR.ADDFSR f n , k = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f n '. Words, Add Literal to FSR.ADDFSR f n , k = 1. Words, Add Literal to FSR.ADDFSR f n , k = 1. Words, Add Literal to FSR.ADDFSR f n , k = 1. Words, Add Literal to FSR.ADDFSR f n , k = 1. Cycles, Add Literal to FSR.ADDFSR f n , k = 1. Cycles, Add Literal to FSR.ADDFSR f n , k = 1. Cycles, Add Literal to FSR.ADDFSR f n , k = 1. Cycles, Add Literal to FSR.ADDFSR f n , k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to FSR\nExample: ADDFSR 2, 23h",
    "Before Instruction\nFSR2 = 03FFh",
    "After Instruction\nFSR2 = 0422h",
    "After Instruction\nSyntax, Add Literal to W = ADDLW k. Syntax, Add Literal to W = ADDLW k. Syntax, Add Literal to W = ADDLW k. Operands, Add Literal to W = 0 \u2264 k \u2264 255. Operands, Add Literal to W = 0 \u2264 k \u2264 255. Operands, Add Literal to W = 0 \u2264 k \u2264 255. Operation, Add Literal to W = (W) + k \u2192 W. Operation, Add Literal to W = (W) + k \u2192 W. Operation, Add Literal to W = (W) + k \u2192 W. Status Affected, Add Literal to W = N, OV, C, DC, Z. Status Affected, Add Literal to W = N, OV, C, DC, Z. Status Affected, Add Literal to W = N, OV, C, DC, Z. Encoding, Add Literal to W = 0000. Encoding, Add Literal to W = kkkk. Encoding, Add Literal to W = kkkk. Description, Add Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W. Description, Add Literal to W = The contents of Ware added to",
    "After Instruction\nthe 8-bit literal 'k' and the result is placed in W. Description, Add Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W. Words, Add Literal to W = 1. Words, Add Literal to W = 1. Words, Add Literal to W = 1. Cycles, Add Literal to W = 1. Cycles, Add Literal to W = 1. Cycles, Add Literal to W = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample: ADDLW 15h",
    "Before Instruction\nW = 10h",
    "After Instruction\nW = 25h",
    "After Instruction\nSyntax, Add Wto f = ADDWF f {,d {,a}}. Operands, Add Wto f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Add Wto f = (W) + (f) \u2192 dest. Status Affected, Add Wto f = N, OV, C, DC, Z. Encoding, Add Wto f = 0010. Description, Add Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Add Wto f = 1. Cycles, Add Wto f =",
    "After Instruction\n1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: ADDWF REG, 0, 0",
    "Before Instruction\nW = 17h\nREG = 0C2h",
    "After Instruction\nW = 0D9h\nREG = 0C2h",
    "After Instruction\nOperands, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = (W) + (f) + (C) \u2192 dest. Operation, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = (W) + (f) + (C) \u2192 dest. Operation, Add Wand Carry Bit to",
    "After Instruction\nf.ADDWFC f {,d {,a}} = (W) + (f) + (C) \u2192 dest. Operation, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = (W) + (f) + (C) \u2192 dest. Status Affected, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = N, OV, C, DC, Z. Encoding, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 0010. Encoding, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 00da.",
    "After Instruction\nEncoding, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = ffff. Encoding, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = ffff",
    "...........continued\nDescription, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = Add W, the Carry flag and data memory location 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 1. Cycles, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: ADDWFC REG, 0, 1",
    "Before Instruction\nREG = 02h\nCarry bit = 1\nW = 4Dh",
    "After Instruction\nREG = 02h\nCarry bit = 0\nW = 50h",
    "After Instruction\nOperands, AND Literal with W.ANDLW k = 0 \u2264 k \u2264 255. Operands, AND Literal with W.ANDLW k = 0 \u2264 k \u2264 255. Operands, AND Literal with W.ANDLW k = 0 \u2264 k \u2264 255. Operation, AND Literal with W.ANDLW k = (W) .AND. k \u2192 W. Operation, AND Literal with W.ANDLW k = (W) .AND. k \u2192 W. Operation, AND Literal with W.ANDLW k = (W) .AND. k \u2192 W. Status Affected, AND Literal with W.ANDLW k = N, Z. Status Affected, AND Literal with W.ANDLW k = N, Z. Status Affected, AND Literal with W.ANDLW k = N, Z. Encoding, AND Literal with W.ANDLW k = 0000. Encoding, AND Literal with W.ANDLW k = kkkk. Encoding, AND Literal with W.ANDLW k = kkkk. Description, AND Literal with W.ANDLW k = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in",
    "After Instruction\nW. Description, AND Literal with W.ANDLW k = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W. Description, AND Literal with W.ANDLW k = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W. Words, AND Literal with W.ANDLW k = 1. Words, AND Literal with W.ANDLW k = 1. Words, AND Literal with W.ANDLW k = 1. Cycles, AND Literal with W.ANDLW k = 1. Cycles, AND Literal with W.ANDLW k = 1. Cycles, AND Literal with W.ANDLW k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample: ANDLW 05Fh",
    "Before Instruction\nW = A3h",
    "After Instruction\nW = 03h",
    "After Instruction\nSyntax, AND Wwith f = ANDWF f {,d {,a}}. Syntax, AND Wwith f = ANDWF f {,d {,a}}. Syntax, AND Wwith f = ANDWF f {,d {,a}}. Syntax, AND Wwith f = ANDWF f {,d {,a}}. Operands, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation,",
    "After Instruction\nAND Wwith f = (W) .AND. (f) \u2192 dest. Status Affected, AND Wwith f = N, Z. Status Affected, AND Wwith f = N, Z. Status Affected, AND Wwith f = N, Z. Status Affected, AND Wwith f = N, Z. Encoding, AND Wwith f = 0001. Encoding, AND Wwith f = 01da. Encoding, AND Wwith f = ffff. Encoding, AND Wwith f = ffff. Description, AND Wwith f = The contents of Ware ANDed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details..",
    "After Instruction\nDescription, AND Wwith f = The contents of Ware ANDed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, AND Wwith f = The contents of Ware ANDed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set",
    "After Instruction\nis enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, AND Wwith f = The contents of Ware ANDed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, AND Wwith f = 1. Words, AND Wwith f = 1. Words, AND Wwith f = 1. Words, AND Wwith f = 1. Cycles, AND Wwith f = 1. Cycles, AND Wwith f = 1. Cycles, AND Wwith f = 1. Cycles, AND",
    "After Instruction\nWwith f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: ANDWF REG, 0, 0",
    "Before Instruction\nREG = C2h\nW = 17h",
    "After Instruction\nREG = C2h\nW = 02h",
    "After Instruction\nOperands, Branch if Carry.BC n = -128 \u2264 n \u2264 127. Operands, Branch if Carry.BC n = -128 \u2264 n \u2264 127. Operands, Branch if Carry.BC n = -128 \u2264 n \u2264 127. Operands, Branch if Carry.BC n = -128 \u2264 n \u2264 127. Operation, Branch if Carry.BC n = If the Carry bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Carry.BC n = If the Carry bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Carry.BC n = If the Carry bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Carry.BC n = If the Carry bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Carry.BC n = None. Status Affected, Branch if Carry.BC n = None. Status Affected, Branch if Carry.BC n = None. Status Affected, Branch if Carry.BC n = None. Encoding, Branch if Carry.BC n = 1110. Encoding, Branch if Carry.BC n = 0010. Encoding,",
    "After Instruction\nBranch if Carry.BC n = nnnn. Encoding, Branch if Carry.BC n = nnnn. Description, Branch if Carry.BC n = If the Carry bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Carry.BC n = If the Carry bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Carry.BC n = If the Carry bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle",
    "After Instruction\ninstruction.. Description, Branch if Carry.BC n = If the Carry bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Carry.BC n = 1. Words, Branch if Carry.BC n = 1. Words, Branch if Carry.BC n = 1. Words, Branch if Carry.BC n = 1. Cycles, Branch if Carry.BC n = 1 (2). Cycles, Branch if Carry.BC n = 1 (2). Cycles, Branch if Carry.BC n = 1 (2). Cycles, Branch if Carry.BC n = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BC 5",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf Carry = 1 ; PC = address (HERE + 12)\nIf Carry = 0 ; PC = address (HERE + 2)\nSyntax, Bit Clear f = BCF f, b {,a}. Operands, Bit Clear f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operation, Bit Clear f = 0 \u2192 f<b>. Status Affected, Bit Clear f = None. Encoding, Bit Clear f = 1001. Description, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Bit Clear f = 1. Cycles, Bit Clear f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: BCF FLAG_REG, 7, 0",
    "Before Instruction\nFLAG_REG = C7h",
    "After Instruction\nFLAG_REG = 47h",
    "After Instruction\nSyntax, Branch if Negative = BN n. Syntax, Branch if Negative = BN n. Syntax, Branch if Negative = BN n. Syntax, Branch if Negative = BN n. Operands, Branch if Negative = -128 \u2264 n \u2264 127. Operands, Branch if Negative = -128 \u2264 n \u2264 127. Operands, Branch if Negative = -128 \u2264 n \u2264 127. Operands, Branch if Negative = -128 \u2264 n \u2264 127. Operation, Branch if Negative = If NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Negative = If NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Negative = If NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Negative = If NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Negative = None. Status Affected, Branch if Negative = None. Status Affected, Branch if Negative = None. Status Affected, Branch if Negative = None. Encoding, Branch if Negative = 1110. Encoding, Branch if Negative = 0110. Encoding, Branch if Negative = nnnn. Encoding,",
    "After Instruction\nBranch if Negative = nnnn",
    "...........continued\nSyntax, Branch if Negative = BN n. Description, Branch if Negative = If the NEGATIVE bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Negative = 1. Cycles, Branch if Negative = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BN Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf NEGATIVE = 1 ; PC = address (Jump)\nIf NEGATIVE = 0 ; PC = address (HERE + 2)",
    "After Instruction\nOperands, Branch if Not Carry.BNC n = -128 \u2264 n \u2264 127. Operands, Branch if Not Carry.BNC n = -128 \u2264 n \u2264 127. Operands, Branch if Not Carry.BNC n = -128 \u2264 n \u2264 127. Operands, Branch if Not Carry.BNC n = -128 \u2264 n \u2264 127. Operation, Branch if Not Carry.BNC n = If the Carry bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Carry.BNC n = If the Carry bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Carry.BNC n = If the Carry bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Carry.BNC n = If the Carry bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Not Carry.BNC n = None. Status Affected, Branch if Not Carry.BNC n = None. Status Affected, Branch if Not Carry.BNC n = None. Status Affected, Branch if Not Carry.BNC n = None. Encoding,",
    "After Instruction\nBranch if Not Carry.BNC n = 1110. Encoding, Branch if Not Carry.BNC n = 0011. Encoding, Branch if Not Carry.BNC n = nnnn. Encoding, Branch if Not Carry.BNC n = nnnn. Description, Branch if Not Carry.BNC n = If the Carry bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Carry.BNC n = If the Carry bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Carry.BNC n = If the Carry bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the",
    "After Instruction\nPC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Carry.BNC n = If the Carry bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Not Carry.BNC n = 1. Words, Branch if Not Carry.BNC n = 1. Words, Branch if Not Carry.BNC n = 1. Words, Branch if Not Carry.BNC n = 1. Cycles, Branch if Not Carry.BNC n = 1 (2). Cycles, Branch if Not Carry.BNC n = 1 (2). Cycles, Branch if Not Carry.BNC n = 1 (2). Cycles, Branch if Not Carry.BNC n = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nIf No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BNC Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf Carry = 0 ; PC = address (Jump)\nIf Carry = 1 ; PC = address (HERE + 2)",
    "After Instruction\nSyntax, Branch if Not Negative = BNN n. Syntax, Branch if Not Negative = BNN n. Syntax, Branch if Not Negative = BNN n. Syntax, Branch if Not Negative = BNN n. Operands, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands, Branch if Not Negative = -128 \u2264 n \u2264 127. Operation, Branch if Not Negative = If NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Negative = If NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Negative = If NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Negative = If NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Not Negative = None. Status Affected, Branch if Not Negative = None. Status Affected, Branch if Not Negative = None. Status Affected, Branch if Not Negative = None. Encoding, Branch if Not Negative = 1110.",
    "After Instruction\nEncoding, Branch if Not Negative = 0111. Encoding, Branch if Not Negative = nnnn. Encoding, Branch if Not Negative = nnnn. Description, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle",
    "After Instruction\ninstruction.. Description, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Not Negative = 1. Words, Branch if Not Negative = 1. Words, Branch if Not Negative = 1. Words, Branch if Not Negative = 1. Cycles, Branch if Not Negative = 1 (2). Cycles, Branch if Not Negative = 1 (2). Cycles, Branch if Not Negative = 1 (2). Cycles, Branch if Not Negative = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BNN Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf NEGATIVE = 0 ; PC = address (Jump) If NEGATIVE = 1 ; PC = address (HERE + 2)\nSyntax, Branch if Not Overflow = BNOV n. Operands, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operation, Branch if Not Overflow = If OVERFLOW bit is ' 0 ' (PC) + 2 + 2n \u2192 PC",
    "...........continued\nStatus Affected, Branch if Not Overflow.BNOV n = None. Status Affected, Branch if Not Overflow.BNOV n = None. Status Affected, Branch if Not Overflow.BNOV n = None. Status Affected, Branch if Not Overflow.BNOV n = None. Encoding, Branch if Not Overflow.BNOV n = 1110. Encoding, Branch if Not Overflow.BNOV n = 0101. Encoding, Branch if Not Overflow.BNOV n = nnnn. Encoding, Branch if Not Overflow.BNOV n = nnnn. Description, Branch if Not Overflow.BNOV n = If the OVERFLOW bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Overflow.BNOV n = If the OVERFLOW bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to",
    "...........continued\nthe PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Overflow.BNOV n = If the OVERFLOW bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Overflow.BNOV n = If the OVERFLOW bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Not Overflow.BNOV n = 1. Words, Branch if Not Overflow.BNOV n = 1. Words, Branch if Not Overflow.BNOV n = 1.",
    "...........continued\nWords, Branch if Not Overflow.BNOV n = 1. Cycles, Branch if Not Overflow.BNOV n = 1 (2). Cycles, Branch if Not Overflow.BNOV n = 1 (2). Cycles, Branch if Not Overflow.BNOV n = 1 (2). Cycles, Branch if Not Overflow.BNOV n = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BNOV Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf OVERFLOW = 0 ; PC = address (Jump)\nIf OVERFLOW = 1 ; PC = address (HERE + 2)",
    "After Instruction\nOperands, Branch if Not Zero.BNZ n = -128 \u2264 n \u2264 127. Operands, Branch if Not Zero.BNZ n = -128 \u2264 n \u2264 127. Operands, Branch if Not Zero.BNZ n = -128 \u2264 n \u2264 127. Operands, Branch if Not Zero.BNZ n = -128 \u2264 n \u2264 127. Operation, Branch if Not Zero.BNZ n = If ZERO bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Zero.BNZ n = If ZERO bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Zero.BNZ n = If ZERO bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Zero.BNZ n = If ZERO bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Not Zero.BNZ n = None. Status Affected, Branch if Not Zero.BNZ n = None. Status Affected, Branch if Not Zero.BNZ n = None. Status Affected, Branch if Not Zero.BNZ n = None. Encoding, Branch if Not",
    "After Instruction\nZero.BNZ n = 1110. Encoding, Branch if Not Zero.BNZ n = 0001. Encoding, Branch if Not Zero.BNZ n = nnnn. Encoding, Branch if Not Zero.BNZ n = nnnn. Description, Branch if Not Zero.BNZ n = If the ZERO bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Zero.BNZ n = If the ZERO bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Zero.BNZ n = If the ZERO bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since",
    "After Instruction\nthe PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Zero.BNZ n = If the ZERO bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Not Zero.BNZ n = 1. Words, Branch if Not Zero.BNZ n = 1. Words, Branch if Not Zero.BNZ n = 1. Words, Branch if Not Zero.BNZ n = 1. Cycles, Branch if Not Zero.BNZ n = 1 (2). Cycles, Branch if Not Zero.BNZ n = 1 (2). Cycles, Branch if Not Zero.BNZ n = 1 (2). Cycles, Branch if Not Zero.BNZ n = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC\nNo operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BNZ Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf ZERO = 0 ; PC = address (Jump) If ZERO = 1 ; PC = address (HERE + 2)",
    "After Instruction\nOperands, Branch if Overflow.BOV n = -128 \u2264 n \u2264 127. Operands, Branch if Overflow.BOV n = -128 \u2264 n \u2264 127. Operands, Branch if Overflow.BOV n = -128 \u2264 n \u2264 127. Operands, Branch if Overflow.BOV n = -128 \u2264 n \u2264 127. Operation, Branch if Overflow.BOV n = If OVERFLOW bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Overflow.BOV n = If OVERFLOW bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Overflow.BOV n = If OVERFLOW bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Overflow.BOV n = If OVERFLOW bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Overflow.BOV n = None. Status Affected, Branch if Overflow.BOV n = None. Status Affected, Branch if Overflow.BOV n = None. Status Affected, Branch if Overflow.BOV n = None. Encoding,",
    "After Instruction\nBranch if Overflow.BOV n = 1110. Encoding, Branch if Overflow.BOV n = 0100. Encoding, Branch if Overflow.BOV n = nnnn. Encoding, Branch if Overflow.BOV n = nnnn. Description, Branch if Overflow.BOV n = If the OVERFLOW bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Overflow.BOV n = If the OVERFLOW bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Overflow.BOV n = If the OVERFLOW bit is ' 1 ', then the program will branch. The two's complement number '2n' is",
    "After Instruction\nadded to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Overflow.BOV n = If the OVERFLOW bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Overflow.BOV n = 1. Words, Branch if Overflow.BOV n = 1. Words, Branch if Overflow.BOV n = 1. Words, Branch if Overflow.BOV n = 1. Cycles, Branch if Overflow.BOV n = 1 (2). Cycles, Branch if Overflow.BOV n = 1 (2). Cycles, Branch if Overflow.BOV n = 1 (2). Cycles, Branch if Overflow.BOV n = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BOV Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf OVERFLOW = 1 ; PC = address (Jump) If OVERFLOW = 0 ; PC = address (HERE + 2)",
    "After Instruction\nSyntax, Unconditional Branch = BRA n. Syntax, Unconditional Branch = BRA n. Syntax, Unconditional Branch = BRA n. Syntax, Unconditional Branch = BRA n. Operands, Unconditional Branch = -1024 \u2264 n \u2264 1023. Operands, Unconditional Branch = -1024 \u2264 n \u2264 1023. Operands, Unconditional Branch = -1024 \u2264 n \u2264 1023. Operands, Unconditional Branch = -1024 \u2264 n \u2264 1023. Operation, Unconditional Branch = (PC) + 2 + 2n \u2192 PC. Operation, Unconditional Branch = (PC) + 2 + 2n \u2192 PC. Operation, Unconditional Branch = (PC) + 2 + 2n \u2192 PC. Operation, Unconditional Branch = (PC) + 2 + 2n \u2192 PC. Status Affected, Unconditional Branch = None. Status Affected, Unconditional Branch = None. Status Affected, Unconditional Branch = None. Status Affected, Unconditional Branch = None. Encoding, Unconditional Branch = 1101. Encoding, Unconditional Branch = 0nnn. Encoding, Unconditional Branch = nnnn. Encoding,",
    "After Instruction\nUnconditional Branch = nnnn. Description, Unconditional Branch = The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description, Unconditional Branch = The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description, Unconditional Branch = The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description, Unconditional Branch = The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Words, Unconditional Branch = 1.",
    "After Instruction\nWords, Unconditional Branch = 1. Words, Unconditional Branch = 1. Words, Unconditional Branch = 1. Cycles, Unconditional Branch = 2. Cycles, Unconditional Branch = 2. Cycles, Unconditional Branch = 2. Cycles, Unconditional Branch = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: HERE BRA Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nPC = address (Jump)",
    "After Instruction\nOperands, Bit Set f.BSF f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Set f.BSF f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Set f.BSF f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Set f.BSF f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operation, Bit Set f.BSF f, b {,a} = 1 \u2192 f<b>. Operation, Bit Set f.BSF f, b {,a} = 1 \u2192 f<b>. Operation, Bit Set f.BSF f, b {,a} = 1 \u2192 f<b>. Operation, Bit Set f.BSF f, b {,a} = 1 \u2192 f<b>. Status Affected, Bit Set f.BSF f, b {,a} = None. Status Affected,",
    "After Instruction\nBit Set f.BSF f, b {,a} = None. Status Affected, Bit Set f.BSF f, b {,a} = None. Status Affected, Bit Set f.BSF f, b {,a} = None. Encoding, Bit Set f.BSF f, b {,a} = 1000. Encoding, Bit Set f.BSF f, b {,a} = bbba. Encoding, Bit Set f.BSF f, b {,a} = ffff. Encoding, Bit Set f.BSF f, b {,a} = ffff. Description, Bit Set f.BSF f, b {,a} = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Set f.BSF",
    "After Instruction\nf, b {,a} = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Set f.BSF f, b {,a} = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Set f.BSF f, b {,a} = Bit 'b' in register 'f' is set.",
    "After Instruction\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Bit Set f.BSF f, b {,a} = 1. Words, Bit Set f.BSF f, b {,a} = 1. Words, Bit Set f.BSF f, b {,a} = 1. Words, Bit Set f.BSF f, b {,a} = 1. Cycles, Bit Set f.BSF f, b {,a} = 1. Cycles, Bit Set f.BSF f, b {,a} = 1. Cycles, Bit Set f.BSF f, b {,a} = 1. Cycles, Bit Set f.BSF f, b {,a} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: BSF FLAG_REG, 7, 1",
    "Before Instruction\nFLAG_REG = 0Ah",
    "Before Instruction\nOperands, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operation, Bit Test File, Skip if Clear.BTFSC f, b {,a} = Skip if (f<b>) = 0. Operation, Bit Test File, Skip if Clear.BTFSC f, b {,a} = Skip if (f<b>) = 0. Operation, Bit Test File, Skip if Clear.BTFSC f, b {,a} = Skip if (f<b>) =",
    "Before Instruction\n0. Operation, Bit Test File, Skip if Clear.BTFSC f, b {,a} = Skip if (f<b>) = 0. Status Affected, Bit Test File, Skip if Clear.BTFSC f, b {,a} = None. Status Affected, Bit Test File, Skip if Clear.BTFSC f, b {,a} = None. Status Affected, Bit Test File, Skip if Clear.BTFSC f, b {,a} = None. Status Affected, Bit Test File, Skip if Clear.BTFSC f, b {,a} = None. Encoding, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1011. Encoding, Bit Test File, Skip if Clear.BTFSC f, b {,a} = bbba. Encoding, Bit Test File, Skip if Clear.BTFSC f, b {,a} = ffff. Encoding, Bit Test File, Skip if Clear.BTFSC f, b {,a} = ffff. Description, Bit Test File, Skip if Clear.BTFSC f, b {,a} = If bit 'b' in register",
    "Before Instruction\n'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Test File, Skip if Clear.BTFSC f, b {,a} = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used",
    "Before Instruction\nto select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Test File, Skip if Clear.BTFSC f, b {,a} = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Test File, Skip if Clear.BTFSC f, b {,a} = If bit",
    "Before Instruction\n'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1. Words, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1. Words, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1. Words, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1. Cycles, Bit Test File, Skip if Clear.BTFSC",
    "Before Instruction\nf, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   BTFSC   FLAG, 1, 0 FALSE: TRUE:",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf FLAG<1> = 0 ; PC = address (TRUE) If FLAG<1> = 1 ; PC = address (FALSE)",
    "After Instruction\nOperands, Bit Test File, Skip if Set.BTFSS f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Test File, Skip if Set.BTFSS f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Test File, Skip if Set.BTFSS f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Test File, Skip if Set.BTFSS f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operation, Bit Test File, Skip if Set.BTFSS f, b {,a} = Skip if (f<b>) = 1. Operation, Bit Test File, Skip if Set.BTFSS f, b {,a} = Skip if (f<b>) = 1. Operation, Bit Test File, Skip if Set.BTFSS f, b {,a} = Skip if (f<b>) =",
    "After Instruction\n1. Operation, Bit Test File, Skip if Set.BTFSS f, b {,a} = Skip if (f<b>) = 1. Status Affected, Bit Test File, Skip if Set.BTFSS f, b {,a} = None. Status Affected, Bit Test File, Skip if Set.BTFSS f, b {,a} = None. Status Affected, Bit Test File, Skip if Set.BTFSS f, b {,a} = None. Status Affected, Bit Test File, Skip if Set.BTFSS f, b {,a} = None. Encoding, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1010. Encoding, Bit Test File, Skip if Set.BTFSS f, b {,a} = bbba. Encoding, Bit Test File, Skip if Set.BTFSS f, b {,a} = ffff. Encoding, Bit Test File, Skip if Set.BTFSS f, b {,a} = ffff. Description, Bit Test File, Skip if Set.BTFSS f, b {,a} = If bit 'b' in register",
    "After Instruction\n'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Test File, Skip if Set.BTFSS f, b {,a} = If bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used",
    "After Instruction\nto select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Test File, Skip if Set.BTFSS f, b {,a} = If bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Test File, Skip if Set.BTFSS f, b {,a} = If bit",
    "After Instruction\n'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1. Words, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1. Words, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1. Words, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1. Cycles, Bit Test File, Skip if Set.BTFSS",
    "After Instruction\nf, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nIf skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   BTFSS   FLAG, 1, 0\nFALSE:\nTRUE:",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf FLAG<1> = 0 ; PC = address (FALSE)\nIf FLAG<1> = 1 ; PC = address (TRUE)",
    "After Instruction\nSyntax, Bit Toggle f = BTG f, b {,a}. Syntax, Bit Toggle f = BTG f, b {,a}. Syntax, Bit Toggle f = BTG f, b {,a}. Syntax, Bit Toggle f = BTG f, b {,a}. Operands, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operation, Bit Toggle f = (f<b>) \u2192 f<b>. Operation, Bit Toggle f = (f<b>) \u2192 f<b>. Operation, Bit Toggle f = (f<b>) \u2192 f<b>. Operation, Bit Toggle f = (f<b>) \u2192 f<b>. Status Affected, Bit Toggle",
    "After Instruction\nf = None. Status Affected, Bit Toggle f = None. Status Affected, Bit Toggle f = None. Status Affected, Bit Toggle f = None. Encoding, Bit Toggle f = 0111. Encoding, Bit Toggle f = bbba. Encoding, Bit Toggle f = ffff. Encoding, Bit Toggle f = ffff. Description, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set",
    "After Instruction\nis enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal",
    "After Instruction\nOffset Mode for details.. Words, Bit Toggle f = 1. Words, Bit Toggle f = 1. Words, Bit Toggle f = 1. Words, Bit Toggle f = 1. Cycles, Bit Toggle f = 1. Cycles, Bit Toggle f = 1. Cycles, Bit Toggle f = 1. Cycles, Bit Toggle f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: BTG PORTC, 4, 0",
    "Before Instruction\nPORTC = 0111 0101 75h [ ]",
    "After Instruction\nPORTC = 0110 0101 65h [ ]\nSyntax, Branch if Zero = BZ n. Operands, Branch if Zero = -128 \u2264 n \u2264 127",
    "...........continued\nOperation, if Zero.BZ n = If ZERO bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, if Zero.BZ n = If ZERO bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, if Zero.BZ n = If ZERO bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, if Zero.BZ n = If ZERO bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected, if Zero.BZ n = None. Status Affected, if Zero.BZ n = None. Status Affected, if Zero.BZ n = None. Status Affected, if Zero.BZ n = None. Encoding, if Zero.BZ n = 1110. Encoding, if Zero.BZ n = 0000. Encoding, if Zero.BZ n = nnnn. Encoding, if Zero.BZ n = nnnn. Description, if Zero.BZ n = If the ZERO bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the",
    "...........continued\nPC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, if Zero.BZ n = If the ZERO bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, if Zero.BZ n = If the ZERO bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, if Zero.BZ n = If the ZERO bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the",
    "...........continued\nnext instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, if Zero.BZ n = 1. Words, if Zero.BZ n = 1. Words, if Zero.BZ n = 1. Words, if Zero.BZ n = 1. Cycles, if Zero.BZ n = 1 (2). Cycles, if Zero.BZ n = 1 (2). Cycles, if Zero.BZ n = 1 (2). Cycles, if Zero.BZ n = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BOV Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf ZERO = 1 ; PC = address (Jump)\nIf ZERO = 0 ; PC = address (HERE + 2)",
    "After Instruction\nSyntax, Subroutine Call = CALL k {,s}. Syntax, Subroutine Call = CALL k {,s}. Syntax, Subroutine Call = CALL k {,s}. Syntax, Subroutine Call = CALL k {,s}. Operands, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0, 1]. Operands, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0, 1]. Operands, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0, 1]. Operands, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0, 1]. Operation, Subroutine Call = (PC) + 4 \u2192 TOS k \u2192 PC<20:1> If s = 1 (W) \u2192 WREG_CSHAD (STATUS) \u2192 STATUS_CSHAD (BSR) \u2192 BSR_CSHAD. Operation, Subroutine Call = (PC) + 4 \u2192 TOS k \u2192 PC<20:1> If s = 1 (W) \u2192 WREG_CSHAD (STATUS) \u2192 STATUS_CSHAD (BSR) \u2192",
    "After Instruction\nBSR_CSHAD. Operation, Subroutine Call = (PC) + 4 \u2192 TOS k \u2192 PC<20:1> If s = 1 (W) \u2192 WREG_CSHAD (STATUS) \u2192 STATUS_CSHAD (BSR) \u2192 BSR_CSHAD. Operation, Subroutine Call = (PC) + 4 \u2192 TOS k \u2192 PC<20:1> If s = 1 (W) \u2192 WREG_CSHAD (STATUS) \u2192 STATUS_CSHAD (BSR) \u2192 BSR_CSHAD. Status Affected, Subroutine Call = None. Status Affected, Subroutine Call = None. Status Affected, Subroutine Call = None. Status Affected, Subroutine Call = None. Encoding 1st word (k<7:0>) 2nd word (k<19:8>), Subroutine Call = 1110. Encoding 1st word (k<7:0>) 2nd word (k<19:8>), Subroutine Call = 110s. Encoding 1st word (k<7:0>) 2nd word (k<19:8>), Subroutine Call = k 7 kkk. Encoding 1st word",
    "After Instruction\n(k<7:0>) 2nd word (k<19:8>), Subroutine Call = kkkk 0. , Subroutine Call = 1111. , Subroutine Call = k 19 kkk. , Subroutine Call = kkkk. , Subroutine Call = kkkk 8. Description, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the WREG, STATUS and BSR registers are also pushed into their respective shadow registers WREG_CSHAD, STATUS_CSHAD and BSR_CSHAD. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Description, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the WREG, STATUS and BSR registers are also pushed into their respective shadow registers",
    "After Instruction\nWREG_CSHAD, STATUS_CSHAD and BSR_CSHAD. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Description, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the WREG, STATUS and BSR registers are also pushed into their respective shadow registers WREG_CSHAD, STATUS_CSHAD and BSR_CSHAD. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Description, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the WREG, STATUS and BSR registers are also pushed into their respective shadow registers WREG_CSHAD, STATUS_CSHAD and",
    "After Instruction\nBSR_CSHAD. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Words, Subroutine Call = 2. Words, Subroutine Call = 2. Words, Subroutine Call = 2. Words, Subroutine Call = 2",
    "...........continued\nSyntax, Subroutine Call = CALL k {,s}. Cycles, Subroutine Call = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'<7:0>. Decode, 2 = PUSH PC to stack. Decode, 3 = Read literal 'k'<19:8> Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: HERE CALL THERE, 1",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nPC = address (THERE) TOS = address (HERE + 4) WREG_CSHAD = (WREG) BSR_CSHAD = (BSR) STATUS_CSHAD = (STATUS)",
    "After Instruction\nSyntax, Subroutine Call using WREG = CALLW. Operands, Subroutine Call using WREG = None. Operation, Subroutine Call using WREG = (PC) + 2 \u2192 TOS (W) \u2192 PCL (PCLATH) \u2192 PCH (PCLATU) \u2192 PCU. Status Affected, Subroutine Call using WREG = None. Encoding, Subroutine Call using WREG = 0000. Description, Subroutine Call using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched onto PCH and PCU respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL , there is no option to update W, STATUS or BSR.. Words, Subroutine Call using WREG = 1. Cycles, Subroutine Call using WREG = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read WREG. Decode, 2 = PUSH PC to stack. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: HERE CALLW",
    "Before Instruction\nPC = address (HERE) PCLATH = 10h\nPCLATU = 00h W = 06h",
    "After Instruction\nPC = address 001006h TOS = address (HERE + 2) PCLATH = 10h PCLATU = 00h W = 06h",
    "After Instruction\nOperands, Clear f.CLRF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Clear f.CLRF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Clear f.CLRF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Clear f.CLRF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Clear f.CLRF f {,a} = 000h \u2192 f 1 \u2192 Z. Operation, Clear f.CLRF f {,a} = 000h \u2192 f 1 \u2192 Z. Operation, Clear f.CLRF f {,a} = 000h \u2192 f 1 \u2192 Z. Operation, Clear f.CLRF f {,a} = 000h \u2192 f 1 \u2192 Z. Status Affected, Clear f.CLRF f {,a} = Z. Status Affected, Clear f.CLRF f {,a} = Z. Status Affected, Clear f.CLRF f {,a} = Z. Status Affected, Clear f.CLRF f {,a} =",
    "After Instruction\nZ. Encoding, Clear f.CLRF f {,a} = 0110. Encoding, Clear f.CLRF f {,a} = 101a. Encoding, Clear f.CLRF f {,a} = ffff. Encoding, Clear f.CLRF f {,a} = ffff. Description, Clear f.CLRF f {,a} = Clears the contents of the specified register 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Clear f.CLRF f {,a} = Clears the contents of the specified register 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is",
    "After Instruction\nenabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Clear f.CLRF f {,a} = Clears the contents of the specified register 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Clear f.CLRF f {,a} = Clears the contents of the specified register 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and",
    "After Instruction\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Clear f.CLRF f {,a} = 1. Words, Clear f.CLRF f {,a} = 1. Words, Clear f.CLRF f {,a} = 1. Words, Clear f.CLRF f {,a} = 1. Cycles, Clear f.CLRF f {,a} = 1. Cycles, Clear f.CLRF f {,a} = 1. Cycles, Clear f.CLRF f {,a} = 1. Cycles, Clear f.CLRF f {,a} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: CLRF FLAG_REG, 1",
    "Before Instruction\nFLAG_REG = 5Ah",
    "After Instruction\nFLAG_REG = 00h",
    "After Instruction\nSyntax, Clear Watchdog Timer = CLRWDT. Syntax, Clear Watchdog Timer = CLRWDT. Syntax, Clear Watchdog Timer = CLRWDT. Syntax, Clear Watchdog Timer = CLRWDT. Operands, Clear Watchdog Timer = None. Operands, Clear Watchdog Timer = None. Operands, Clear Watchdog Timer = None. Operands, Clear Watchdog Timer = None. Operation, Clear Watchdog Timer = 000h \u2192 WDT 1 \u2192 TO 1 \u2192 PD. Operation, Clear Watchdog Timer = 000h \u2192 WDT 1 \u2192 TO 1 \u2192 PD. Operation, Clear Watchdog Timer = 000h \u2192 WDT 1 \u2192 TO 1 \u2192 PD. Operation, Clear Watchdog Timer = 000h \u2192 WDT 1 \u2192 TO 1 \u2192 PD. Status Affected, Clear Watchdog Timer = TO, PD. Status Affected, Clear Watchdog Timer = TO, PD. Status Affected, Clear Watchdog Timer = TO, PD. Status Affected, Clear Watchdog Timer = TO, PD. Encoding, Clear Watchdog Timer = 0000. Encoding, Clear Watchdog Timer = 0000. Encoding, Clear Watchdog Timer = 0000. Encoding, Clear Watchdog Timer = 0100. Description,",
    "After Instruction\nClear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the STATUS bits, and TO and PD are set.. Description, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the STATUS bits, and TO and PD are set.. Description, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the STATUS bits, and TO and PD are set.. Description, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the STATUS bits, and TO and PD are set.. Words, Clear Watchdog Timer = 1. Words, Clear Watchdog Timer = 1. Words, Clear Watchdog Timer = 1. Words, Clear Watchdog Timer = 1",
    "...........continued\nSyntax, Clear Watchdog Timer = CLRWDT. Cycles, Clear Watchdog Timer = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: CLRWDT",
    "Before Instruction\nWDT Counter = ?",
    "After Instruction\nWDT Counter = 00h\nTO = 1\nPD = 1",
    "After Instruction\nOperands, Complement f.COMF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Complement f.COMF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Complement f.COMF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Complement f.COMF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Complement f.COMF f {,d {,a}} = (f) \u2192 dest. Operation, Complement f.COMF f {,d {,a}} = (f) \u2192 dest. Operation, Complement f.COMF f {,d {,a}} = (f) \u2192 dest. Operation, Complement f.COMF f {,d {,a}} = (f) \u2192 dest. Status Affected, Complement",
    "After Instruction\nf.COMF f {,d {,a}} = N, Z. Status Affected, Complement f.COMF f {,d {,a}} = N, Z. Status Affected, Complement f.COMF f {,d {,a}} = N, Z. Status Affected, Complement f.COMF f {,d {,a}} = N, Z. Encoding, Complement f.COMF f {,d {,a}} = 0001. Encoding, Complement f.COMF f {,d {,a}} = 11da. Encoding, Complement f.COMF f {,d {,a}} = ffff. Encoding, Complement f.COMF f {,d {,a}} = ffff. Description, Complement f.COMF f {,d {,a}} = The contents of register 'f' are complemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1",
    "After Instruction\n', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Complement f.COMF f {,d {,a}} = The contents of register 'f' are complemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Complement f.COMF f {,d {,a}} = The contents of register 'f' are complemented. If",
    "After Instruction\n'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Complement f.COMF f {,d {,a}} = The contents of register 'f' are complemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal",
    "After Instruction\nOffset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Complement f.COMF f {,d {,a}} = 1. Words, Complement f.COMF f {,d {,a}} = 1. Words, Complement f.COMF f {,d {,a}} = 1. Words, Complement f.COMF f {,d {,a}} = 1. Cycles, Complement f.COMF f {,d {,a}} = 1. Cycles, Complement f.COMF f {,d {,a}} = 1. Cycles, Complement f.COMF f {,d {,a}} = 1. Cycles, Complement f.COMF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: COMF REG0, 0, 0\nBefore Instruction\nREG = 13h\nAfter Instruction REG = 13h W = ECh",
    "Q Cycle Activity:\nOperands, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Compare f with W, Skip if f = W.CPFSEQ f {,a} = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation, Compare f with W, Skip if f = W.CPFSEQ f {,a} = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation, Compare f with W, Skip if f =",
    "Q Cycle Activity:\nW.CPFSEQ f {,a} = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation, Compare f with W, Skip if f = W.CPFSEQ f {,a} = (f) - (W), skip if (f) = (W) (unsigned comparison). Status Affected, Compare f with W, Skip if f = W.CPFSEQ f {,a} = None. Status Affected, Compare f with W, Skip if f = W.CPFSEQ f {,a} = None. Status Affected, Compare f with W, Skip if f = W.CPFSEQ f {,a} = None. Status Affected, Compare f with W, Skip if f = W.CPFSEQ f {,a} = None. Encoding, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 0110. Encoding, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 001a. Encoding, Compare f with W, Skip if f = W.CPFSEQ",
    "Q Cycle Activity:\nf {,a} = ffff. Encoding, Compare f with W, Skip if f = W.CPFSEQ f {,a} = ffff. Description, Compare f with W, Skip if f = W.CPFSEQ f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are equal to the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f = W.CPFSEQ f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned",
    "Q Cycle Activity:\nsubtraction. If the contents of 'f' are equal to the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f = W.CPFSEQ f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are equal to the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR",
    "Q Cycle Activity:\nbank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f = W.CPFSEQ f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are equal to the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Compare f with W, Skip if f = W.CPFSEQ f {,a} =",
    "Q Cycle Activity:\n1. Words, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 1. Words, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 1. Words, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 1. Cycles, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W,",
    "Q Cycle Activity:\nSkip if f = W.CPFSEQ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   CPFSEQ   REG, 0 NEQUAL: EQUAL:\nBefore Instruction PC = address (HERE) W = ? REG = ?",
    "After Instruction\nIf REG = W; PC = address (EQUAL) If REG \u2260 W; PC = address (NEQUAL)",
    "After Instruction\nOperands, Compare f with W, Skip if f > W.CPFSGT f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f > W.CPFSGT f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f > W.CPFSGT f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f > W.CPFSGT f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Compare f with W, Skip if f > W.CPFSGT f {,a} = (f) - (W), skip if (f) > (W) (unsigned comparison). Operation, Compare f with W, Skip if f > W.CPFSGT f {,a} = (f) - (W), skip if (f) > (W) (unsigned comparison). Operation, Compare f with W, Skip if f > W.CPFSGT f {,a} =",
    "After Instruction\n(f) - (W), skip if (f) > (W) (unsigned comparison). Operation, Compare f with W, Skip if f > W.CPFSGT f {,a} = (f) - (W), skip if (f) > (W) (unsigned comparison). Status Affected, Compare f with W, Skip if f > W.CPFSGT f {,a} = None. Status Affected, Compare f with W, Skip if f > W.CPFSGT f {,a} = None. Status Affected, Compare f with W, Skip if f > W.CPFSGT f {,a} = None. Status Affected, Compare f with W, Skip if f > W.CPFSGT f {,a} = None. Encoding, Compare f with W, Skip if f > W.CPFSGT f {,a} = 0110. Encoding, Compare f with W, Skip if f > W.CPFSGT f {,a} = 010a. Encoding, Compare f with W, Skip if f > W.CPFSGT f {,a} = ffff. Encoding, Compare f with W, Skip if f >",
    "After Instruction\nW.CPFSGT f {,a} = ffff. Description, Compare f with W, Skip if f > W.CPFSGT f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f > W.CPFSGT f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is",
    "After Instruction\ndiscarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f > W.CPFSGT f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264",
    "After Instruction\n95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f > W.CPFSGT f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1. Words, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1. Words, Compare f with W, Skip",
    "After Instruction\nif f > W.CPFSGT f {,a} = 1. Words, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1. Cycles, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a",
    "After Instruction\nthree-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation",
    "Example:\nHERE   CPFSGT   REG, 0\nNGREATER:\nGREATER:",
    "Before Instruction\nPC = address (HERE)\nW = ?\nREG = ?",
    "After Instruction\nIf REG > W; PC = address (GREATER)\nIf REG \u2264 W; PC = address (NGREATER)",
    "After Instruction\nOperands, Compare f with W, Skip if f < W.CPFSLT f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f < W.CPFSLT f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f < W.CPFSLT f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f < W.CPFSLT f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Compare f with W, Skip if f < W.CPFSLT f {,a} = (f) - (W), skip if (f) < (W) (unsigned comparison). Operation, Compare f with W, Skip if f < W.CPFSLT f {,a} = (f) - (W), skip if (f) < (W) (unsigned comparison). Operation, Compare f with W, Skip if f < W.CPFSLT f {,a} =",
    "After Instruction\n(f) - (W), skip if (f) < (W) (unsigned comparison). Operation, Compare f with W, Skip if f < W.CPFSLT f {,a} = (f) - (W), skip if (f) < (W) (unsigned comparison). Status Affected, Compare f with W, Skip if f < W.CPFSLT f {,a} = None. Status Affected, Compare f with W, Skip if f < W.CPFSLT f {,a} = None. Status Affected, Compare f with W, Skip if f < W.CPFSLT f {,a} = None. Status Affected, Compare f with W, Skip if f < W.CPFSLT f {,a} = None. Encoding, Compare f with W, Skip if f < W.CPFSLT f {,a} = 0110. Encoding, Compare f with W, Skip if f < W.CPFSLT f {,a} = 000a. Encoding, Compare f with W, Skip if f < W.CPFSLT f {,a} = ffff. Encoding, Compare f with W, Skip if f <",
    "After Instruction\nW.CPFSLT f {,a} = ffff. Description, Compare f with W, Skip if f < W.CPFSLT f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f < W.CPFSLT f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of WREG, then the fetched instruction is",
    "After Instruction\ndiscarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f < W.CPFSLT f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264",
    "After Instruction\n95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f < W.CPFSLT f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Compare f with W, Skip if f < W.CPFSLT f {,a} = 1. Words, Compare f with W, Skip if f < W.CPFSLT f {,a} = 1. Words, Compare f with W, Skip",
    "After Instruction\nif f < W.CPFSLT f {,a} = 1. Words, Compare f with W, Skip if f < W.CPFSLT f {,a} = 1. Cycles, Compare f with W, Skip if f < W.CPFSLT f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f < W.CPFSLT f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f < W.CPFSLT f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f < W.CPFSLT f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a",
    "After Instruction\nthree-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nIf skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE NLESS:, 1 = CPFSLT. HERE NLESS:, 2 = REG, 1",
    "Before Instruction\nPC = address (HERE)\nW = ?\nREG = ?",
    "After Instruction\nIf REG < W; PC = address (LESS)\nIf REG \u2265 W; PC = address (NLESS)",
    "After Instruction\nSyntax, Decimal Adjust WRegister = DAW. Syntax, Decimal Adjust WRegister = DAW. Syntax, Decimal Adjust WRegister = DAW. Syntax, Decimal Adjust WRegister = DAW. Operands, Decimal Adjust WRegister = None. Operands, Decimal Adjust WRegister = None. Operands, Decimal Adjust WRegister = None. Operands, Decimal Adjust WRegister = None. Operation, Decimal Adjust WRegister = If [(W<3:0>) > 9] or [DC = 1 ] then (W<3:0>) + 6 \u2192 W<3:0>; else (W<3:0>) \u2192 W<3:0>; If [(W<7:4>) + DC > 9] or [C = 1 ] then (W<7:4>) + 6 + DC \u2192 W<7:4>; else (W<7:4>) + DC \u2192 W<7:4>. Operation, Decimal Adjust WRegister = If [(W<3:0>) > 9] or [DC = 1 ] then (W<3:0>) + 6 \u2192",
    "After Instruction\nW<3:0>; else (W<3:0>) \u2192 W<3:0>; If [(W<7:4>) + DC > 9] or [C = 1 ] then (W<7:4>) + 6 + DC \u2192 W<7:4>; else (W<7:4>) + DC \u2192 W<7:4>. Operation, Decimal Adjust WRegister = If [(W<3:0>) > 9] or [DC = 1 ] then (W<3:0>) + 6 \u2192 W<3:0>; else (W<3:0>) \u2192 W<3:0>; If [(W<7:4>) + DC > 9] or [C = 1 ] then (W<7:4>) + 6 + DC \u2192 W<7:4>; else (W<7:4>) + DC \u2192 W<7:4>. Operation, Decimal Adjust WRegister = If [(W<3:0>) > 9] or [DC = 1 ] then (W<3:0>) + 6 \u2192",
    "After Instruction\nW<3:0>; else (W<3:0>) \u2192 W<3:0>; If [(W<7:4>) + DC > 9] or [C = 1 ] then (W<7:4>) + 6 + DC \u2192 W<7:4>; else (W<7:4>) + DC \u2192 W<7:4>. Status Affected, Decimal Adjust WRegister = C. Status Affected, Decimal Adjust WRegister = C. Status Affected, Decimal Adjust WRegister = C. Status Affected, Decimal Adjust WRegister = C. Encoding, Decimal Adjust WRegister = 0000. Encoding, Decimal Adjust WRegister = 0000. Encoding, Decimal Adjust WRegister = 0000. Encoding, Decimal Adjust WRegister = 0111. Description, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD",
    "After Instruction\nformat) and produces a correct packed BCD result.. Description, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Words, Decimal Adjust WRegister = 1. Words, Decimal Adjust WRegister = 1. Words, Decimal Adjust WRegister = 1. Words, Decimal Adjust WRegister = 1. Cycles, Decimal Adjust WRegister = 1. Cycles, Decimal Adjust WRegister = 1. Cycles, Decimal Adjust WRegister = 1. Cycles, Decimal Adjust WRegister = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register W. Decode, 2 = Process Data. Decode, 3 = Write register W\nExample 1: DAW",
    "Before Instruction\nC = 0\nW = A5h\nDC = 0",
    "After Instruction\nC = 1\nW = 05h\nDC = 0",
    "Before Instruction\nC = 0\nW = CEh\nDC = 0",
    "After Instruction\nC = 1\nW = 34h\nDC = 0",
    "After Instruction\nOperands, Decrement f.DECF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f.DECF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f.DECF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f.DECF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Decrement f.DECF f {,d {,a}} = (f) - 1 \u2192 dest. Operation, Decrement f.DECF f {,d {,a}} = (f) - 1 \u2192 dest. Operation, Decrement f.DECF f {,d {,a}} = (f) - 1 \u2192 dest. Operation, Decrement f.DECF f",
    "After Instruction\n{,d {,a}} = (f) - 1 \u2192 dest. Status Affected, Decrement f.DECF f {,d {,a}} = C, DC, N, OV, Z. Status Affected, Decrement f.DECF f {,d {,a}} = C, DC, N, OV, Z. Status Affected, Decrement f.DECF f {,d {,a}} = C, DC, N, OV, Z. Status Affected, Decrement f.DECF f {,d {,a}} = C, DC, N, OV, Z. Encoding, Decrement f.DECF f {,d {,a}} = 0000. Encoding, Decrement f.DECF f {,d {,a}} = 01da. Encoding, Decrement f.DECF f {,d {,a}} = ffff. Encoding, Decrement f.DECF f {,d {,a}} = ffff. Description, Decrement f.DECF f {,d {,a}} = Decrement register",
    "After Instruction\n'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f.DECF f {,d {,a}} = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction",
    "After Instruction\noperates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f.DECF f {,d {,a}} = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f.DECF f {,d {,a}} = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f'",
    "After Instruction\n(default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Decrement f.DECF f {,d {,a}} = 1. Words, Decrement f.DECF f {,d {,a}} = 1. Words, Decrement f.DECF f {,d {,a}} = 1. Words, Decrement f.DECF f {,d {,a}} = 1. Cycles, Decrement f.DECF f {,d {,a}} = 1. Cycles, Decrement f.DECF f {,d {,a}} = 1. Cycles, Decrement f.DECF f {,d {,a}} = 1. Cycles, Decrement f.DECF f {,d",
    "After Instruction\n{,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: DECF CNT, 1, 0",
    "Before Instruction\nCNT = 01h Z = 0",
    "After Instruction\nCNT = 00h\nZ = 1",
    "After Instruction\nOperands, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if result = 0. Operation, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if",
    "After Instruction\nresult = 0. Operation, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if result = 0. Operation, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if result = 0. Status Affected, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = None. Status Affected, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = None. Status Affected, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = None. Status Affected, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = None. Encoding, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 0010. Encoding, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 11da. Encoding, Decrement f, Skip if",
    "After Instruction\n0.DECFSZ f {,d {,a}} = ffff. Encoding, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = ffff. Description, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f, Skip if",
    "After Instruction\n0.DECFSZ f {,d {,a}} = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result",
    "After Instruction\nis placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is '",
    "After Instruction\n0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1. Words, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1. Words, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1. Words, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1. Cycles, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Decrement f, Skip if",
    "After Instruction\n0.DECFSZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   DECFSZ   CNT, 1, 1\nGOTO     LOOP\nCONTINUE",
    "Before Instruction\nCNT = ?\nPC = address (HERE)",
    "After Instruction\nCNT = CNT - 1\nIf CNT = 0 ; PC = address (CONTINUE)\nIf CNT \u2260 0 ; PC = address (HERE + 2)",
    "After Instruction\nOperands, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if result \u2260 0. Operation, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = (f) - 1",
    "After Instruction\n\u2192 dest, skip if result \u2260 0. Operation, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if result \u2260 0. Operation, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if result \u2260 0. Status Affected, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = None. Status Affected, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = None. Status Affected, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = None. Status Affected, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = None. Encoding, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 0100. Encoding, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}}",
    "After Instruction\n= 11da. Encoding, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = ffff. Encoding, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = ffff. Description, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in",
    "After Instruction\nIndexed Literal Offset Mode for details.. Description, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = The contents of register 'f' are decremented. If 'd' is ' 0",
    "After Instruction\n', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is",
    "After Instruction\ndiscarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1. Words, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1. Words, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1. Words, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1. Cycles, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a",
    "After Instruction\ntwo-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nNo operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   DCFSNZ   TEMP, 1, 0\nZERO:\nNZERO:",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nTEMP = TEMP - 1\nIf TEMP = 0 ; PC = address (ZER0)\nIf TEMP \u2260 0 ; PC = address (NZERO)\nTEMP = ?",
    "After Instruction\nSyntax, Unconditional Branch = GOTO k. Syntax, Unconditional Branch = GOTO k. Syntax, Unconditional Branch = GOTO k. Syntax, Unconditional Branch = GOTO k. Operands, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operands, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operands, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operands, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operation, Unconditional Branch = k \u2192 PC<20:1>. Operation, Unconditional Branch = k \u2192 PC<20:1>. Operation, Unconditional Branch = k \u2192 PC<20:1>. Operation, Unconditional Branch = k \u2192 PC<20:1>. Status Affected, Unconditional Branch = None. Status Affected, Unconditional Branch = None. Status Affected, Unconditional Branch = None. Status Affected, Unconditional Branch = None. Encoding, Unconditional Branch = 1110. Encoding, Unconditional Branch = 1111. Encoding, Unconditional Branch = k 7 kkk. Encoding, Unconditional Branch = kkkk",
    "After Instruction\n0. 1st word (k<7:0>) 2nd word (k<19:8>), Unconditional Branch = 1111. 1st word (k<7:0>) 2nd word (k<19:8>), Unconditional Branch = k 19 kkk. 1st word (k<7:0>) 2nd word (k<19:8>), Unconditional Branch = kkkk. 1st word (k<7:0>) 2nd word (k<19:8>), Unconditional Branch = kkkk 8. Description, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory",
    "After Instruction\nrange. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Words, Unconditional Branch = 2. Words, Unconditional Branch = 2. Words, Unconditional Branch = 2. Words, Unconditional Branch = 2. Cycles, Unconditional Branch = 2. Cycles, Unconditional Branch = 2. Cycles, Unconditional Branch = 2. Cycles, Unconditional Branch = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'<7:0>. Decode, 2 = No operation. Decode, 3 = Read literal 'k'<19:8> Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: HERE GOTO THERE",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nPC = address (THERE)",
    "After Instruction\nOperands, Increment f.INCF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f.INCF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f.INCF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f.INCF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Increment f.INCF f {,d {,a}} = (f) + 1 \u2192 dest. Operation, Increment f.INCF f {,d {,a}} = (f) + 1 \u2192 dest. Operation, Increment f.INCF f {,d {,a}} = (f) + 1 \u2192 dest. Operation, Increment f.INCF f",
    "After Instruction\n{,d {,a}} = (f) + 1 \u2192 dest. Status Affected, Increment f.INCF f {,d {,a}} = C, DC, N, OV, Z. Status Affected, Increment f.INCF f {,d {,a}} = C, DC, N, OV, Z. Status Affected, Increment f.INCF f {,d {,a}} = C, DC, N, OV, Z. Status Affected, Increment f.INCF f {,d {,a}} = C, DC, N, OV, Z. Encoding, Increment f.INCF f {,d {,a}} = 0010. Encoding, Increment f.INCF f {,d {,a}} = 10da. Encoding, Increment f.INCF f {,d {,a}} = ffff. Encoding, Increment f.INCF f {,d {,a}} = ffff. Description, Increment f.INCF f {,d {,a}} = The contents of register",
    "After Instruction\n'f' are incremented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Increment f.INCF f {,d {,a}} = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the",
    "After Instruction\nextended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Increment f.INCF f {,d {,a}} = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Increment f.INCF f {,d {,a}} = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is stored in W. If 'd'",
    "After Instruction\nis ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Increment f.INCF f {,d {,a}} = 1. Words, Increment f.INCF f {,d {,a}} = 1. Words, Increment f.INCF f {,d {,a}} = 1. Words, Increment f.INCF f {,d {,a}} = 1. Cycles, Increment f.INCF f {,d {,a}} = 1. Cycles, Increment f.INCF f {,d {,a}} = 1. Cycles, Increment f.INCF f {,d {,a}} =",
    "After Instruction\n1. Cycles, Increment f.INCF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: INCF CNT, 1, 0",
    "Before Instruction\nZ = 0\nCNT = FFh\nC = ?\nDC = ?",
    "After Instruction\nZ = 1\nCNT = 00h\nC = 1\nDC = 1",
    "After Instruction\nOperands, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Increment f, Skip if 0.INCFSZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if result = 0. Operation, Increment f, Skip if 0.INCFSZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if",
    "After Instruction\nresult = 0. Operation, Increment f, Skip if 0.INCFSZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if result = 0. Operation, Increment f, Skip if 0.INCFSZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if result = 0. Status Affected, Increment f, Skip if 0.INCFSZ f {,d {,a}} = None. Status Affected, Increment f, Skip if 0.INCFSZ f {,d {,a}} = None. Status Affected, Increment f, Skip if 0.INCFSZ f {,d {,a}} = None. Status Affected, Increment f, Skip if 0.INCFSZ f {,d {,a}} = None. Encoding, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 0011. Encoding, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 11da. Encoding, Increment f, Skip if",
    "After Instruction\n0.INCFSZ f {,d {,a}} = ffff. Encoding, Increment f, Skip if 0.INCFSZ f {,d {,a}} = ffff. Description, Increment f, Skip if 0.INCFSZ f {,d {,a}} = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in. Description, Increment f, Skip if 0.INCFSZ f",
    "After Instruction\n{,d {,a}} = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in. Description, Increment f, Skip if 0.INCFSZ f {,d {,a}} = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If",
    "After Instruction\nthe result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in. Description, Increment f, Skip if 0.INCFSZ f {,d {,a}} = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the",
    "After Instruction\nBSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in",
    "...........continued\nWords, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 1. Cycles, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   INCFSZ   CNT, 1, 0\nNZERO: ZERO:",
    "Before Instruction\nCNT = ?\nPC = address (HERE)",
    "After Instruction\nCNT = CNT + 1\nIf CNT = 0 ; PC = address (ZERO)\nIf CNT \u2260 0 ; PC = address (NZERO)",
    "After Instruction\nOperands, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if result \u2260 0. Operation, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = (f) + 1",
    "After Instruction\n\u2192 dest, skip if result \u2260 0. Operation, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if result \u2260 0. Operation, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if result \u2260 0. Status Affected, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = None. Status Affected, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = None. Status Affected, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = None. Status Affected, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = None. Encoding, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 0100. Encoding, Increment f, Skip if not 0.INFSNZ f {,d {,a}}",
    "After Instruction\n= 10da. Encoding, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = ffff. Encoding, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = ffff. Description, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in",
    "After Instruction\nIndexed Literal Offset Mode for details.. Description, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = The contents of register 'f' are incremented. If 'd' is ' 0",
    "After Instruction\n', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is",
    "After Instruction\ndiscarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1. Words, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1. Words, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1. Words, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1. Cycles, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a",
    "After Instruction\ntwo-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   INFSNZ   REG, 1, 0\nZERO: NZERO:\nBefore Instruction REG = ? PC = address (HERE)",
    "After Instruction\nREG = REG + 1\nIf REG = 0 ; PC = address (ZER0)\nIf REG \u2260 0 ; PC = address (NZERO)",
    "After Instruction\nOperands, Inclusive OR Literal with W.IORLW k = 0 \u2264 k \u2264 255. Operands, Inclusive OR Literal with W.IORLW k = 0 \u2264 k \u2264 255. Operands, Inclusive OR Literal with W.IORLW k = 0 \u2264 k \u2264 255. Operation, Inclusive OR Literal with W.IORLW k = (W) .OR. k \u2192 W. Operation, Inclusive OR Literal with W.IORLW k = (W) .OR. k \u2192 W. Operation, Inclusive OR Literal with W.IORLW k = (W) .OR. k \u2192 W. Status Affected, Inclusive OR Literal with W.IORLW k = N, Z. Status Affected, Inclusive OR Literal with W.IORLW k = N, Z. Status Affected, Inclusive OR Literal with W.IORLW k = N, Z. Encoding, Inclusive OR Literal with W.IORLW k = 0000. Encoding, Inclusive OR Literal with W.IORLW k = kkkk. Encoding, Inclusive OR Literal with W.IORLW k = kkkk. Description, Inclusive OR Literal with W.IORLW k = The contents of Ware ORed with the",
    "After Instruction\n8-bit literal 'k'. The result is placed in W.. Description, Inclusive OR Literal with W.IORLW k = The contents of Ware ORed with the 8-bit literal 'k'. The result is placed in W.. Description, Inclusive OR Literal with W.IORLW k = The contents of Ware ORed with the 8-bit literal 'k'. The result is placed in W.. Words, Inclusive OR Literal with W.IORLW k = 1. Words, Inclusive OR Literal with W.IORLW k = 1. Words, Inclusive OR Literal with W.IORLW k = 1. Cycles, Inclusive OR Literal with W.IORLW k = 1. Cycles, Inclusive OR Literal with W.IORLW k = 1. Cycles, Inclusive OR Literal with W.IORLW k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample: IORLW 35h",
    "Before Instruction\nW = 9Ah",
    "After Instruction\nW = BFh",
    "After Instruction\nOperands, Inclusive OR Wwith f.IORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Inclusive OR Wwith f.IORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Inclusive OR Wwith f.IORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Inclusive OR Wwith f.IORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Inclusive OR Wwith f.IORWF f {,d {,a}} = (W) .OR. (f) \u2192 dest. Operation, Inclusive OR Wwith f.IORWF f {,d {,a}} = (W) .OR. (f) \u2192 dest. Operation, Inclusive OR Wwith f.IORWF",
    "After Instruction\nf {,d {,a}} = (W) .OR. (f) \u2192 dest. Operation, Inclusive OR Wwith f.IORWF f {,d {,a}} = (W) .OR. (f) \u2192 dest. Status Affected, Inclusive OR Wwith f.IORWF f {,d {,a}} = N, Z. Status Affected, Inclusive OR Wwith f.IORWF f {,d {,a}} = N, Z. Status Affected, Inclusive OR Wwith f.IORWF f {,d {,a}} = N, Z. Status Affected, Inclusive OR Wwith f.IORWF f {,d {,a}} = N, Z. Encoding, Inclusive OR Wwith f.IORWF f {,d {,a}} = 0001. Encoding, Inclusive OR Wwith f.IORWF f {,d {,a}} = 00da. Encoding, Inclusive OR Wwith f.IORWF f {,d {,a}} = ffff. Encoding, Inclusive OR Wwith f.IORWF f",
    "After Instruction\n{,d {,a}} = ffff. Description, Inclusive OR Wwith f.IORWF f {,d {,a}} = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Inclusive OR Wwith f.IORWF f {,d {,a}} = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access",
    "After Instruction\nBank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Inclusive OR Wwith f.IORWF f {,d {,a}} = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Inclusive OR Wwith f.IORWF f {,d",
    "After Instruction\n{,a}} = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1. Words, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1. Words, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1. Words, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1. Cycles, Inclusive OR Wwith f.IORWF f",
    "After Instruction\n{,d {,a}} = 1. Cycles, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1. Cycles, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1. Cycles, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample:\nIORWF RESULT, 0, 1",
    "Before Instruction\nRESULT = 13h\nW = 91h",
    "After Instruction\nRESULT = 13h\nW = 93h",
    "After Instruction\nSyntax, Load FSR = LFSR f n , k. Syntax, Load FSR = LFSR f n , k. Syntax, Load FSR = LFSR f n , k. Syntax, Load FSR = LFSR f n , k. Operands, Load FSR = 0 \u2264 f n \u2264 2 0 \u2264 k \u2264 16383. Operands, Load FSR = 0 \u2264 f n \u2264 2 0 \u2264 k \u2264 16383. Operands, Load FSR = 0 \u2264 f n \u2264 2 0 \u2264 k \u2264 16383. Operands, Load FSR = 0 \u2264 f n \u2264 2 0 \u2264 k \u2264 16383. Operation, Load FSR = k \u2192 FSRf n. Operation, Load FSR = k \u2192 FSRf n. Operation, Load FSR = k \u2192 FSRf n. Operation, Load FSR = k \u2192 FSRf n. Status Affected, Load FSR = None. Status Affected, Load FSR = None. Status Affected, Load FSR = None. Status Affected, Load FSR = None. Encoding, Load FSR = 1110. Encoding, Load FSR = 1110. Encoding, Load FSR = 00f n f n.",
    "After Instruction\nEncoding, Load FSR = k 13 kkk 10. Encoding, Load FSR = 1111. Encoding, Load FSR = 00k 9 k. Encoding, Load FSR = kkkk. Encoding, Load FSR = kkkk 0. Description, Load FSR = The 14-bit literal 'k' is loaded into the File Select Register 'f n '. Description, Load FSR = The 14-bit literal 'k' is loaded into the File Select Register 'f n '. Description, Load FSR = The 14-bit literal 'k' is loaded into the File Select Register 'f n '. Description, Load FSR = The 14-bit literal 'k' is loaded into the File Select Register 'f n '. Words, Load FSR = 2. Words, Load FSR = 2. Words, Load FSR = 2. Words, Load FSR = 2. Cycles, Load FSR = 2. Cycles, Load FSR = 2. Cycles, Load FSR = 2. Cycles, Load FSR = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'<13:10>. Decode, 2 = Process Data. Decode, 3 = Write literal 'k'<13:10> to FSRf n <13:10>. No operation, 1 = Read literal 'k'<9:0>. No operation, 2 = No operation. No operation, 3 = Write literal 'k'<9:0> to FSRf n <9:0>\nExample: LFSR 2, 3ABh",
    "Before Instruction\nFSR2H = ?\nFSR2L = ?",
    "After Instruction\nFSR2H = 03h\nFSR2L = ABh",
    "After Instruction\nOperands, Move f.MOVF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Move f.MOVF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Move f.MOVF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Move f.MOVF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Move f.MOVF f {,d {,a}} = (f) \u2192 dest. Operation, Move f.MOVF f {,d {,a}} = (f) \u2192 dest. Operation, Move f.MOVF f {,d {,a}} = (f) \u2192 dest. Operation, Move f.MOVF f {,d {,a}} = (f) \u2192",
    "After Instruction\ndest. Status Affected, Move f.MOVF f {,d {,a}} = N, Z. Status Affected, Move f.MOVF f {,d {,a}} = N, Z. Status Affected, Move f.MOVF f {,d {,a}} = N, Z. Status Affected, Move f.MOVF f {,d {,a}} = N, Z. Encoding, Move f.MOVF f {,d {,a}} = 0101. Encoding, Move f.MOVF f {,d {,a}} = 00da. Encoding, Move f.MOVF f {,d {,a}} = ffff. Encoding, Move f.MOVF f {,d {,a}} = ffff",
    "...........continued\nDescription, Move f.MOVF f {,d {,a}} = The contents of register 'f' are moved to a destination. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Move f.MOVF f {,d {,a}} = 1. Cycles, Move f.MOVF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: MOVF REG, 0, 0",
    "Before Instruction\nREG = 22h\nW = FFh",
    "After Instruction\nREG = 22h\nW = 22h",
    "After Instruction\nOperands, Move f to f.MOVFF f s , f d = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands, Move f to f.MOVFF f s , f d = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands, Move f to f.MOVFF f s , f d = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands, Move f to f.MOVFF f s , f d = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operation, Move f to f.MOVFF f s , f d = (f s ) \u2192 f d. Operation, Move f to f.MOVFF f s , f d = (f s ) \u2192 f d. Operation, Move f to f.MOVFF f s , f d = (f s ) \u2192 f d. Operation, Move f to f.MOVFF f s , f d = (f s ) \u2192 f d. Status Affected, Move f to f.MOVFF f s , f d = None. Status Affected,",
    "After Instruction\nMove f to f.MOVFF f s , f d = None. Status Affected, Move f to f.MOVFF f s , f d = None. Status Affected, Move f to f.MOVFF f s , f d = None. Encoding, Move f to f.MOVFF f s , f d = 1100. Encoding, Move f to f.MOVFF f s , f d = f s f s f s f s. Encoding, Move f to f.MOVFF f s , f d = f s f s f s f s. Encoding, Move f to f.MOVFF f s , f d = f s f s f s f s. , Move f to f.MOVFF f s , f d = 1111. , Move f to f.MOVFF f s , f d = f d f d f d f d. , Move f to f.MOVFF f s , f d = f d f d f d f d. , Move f to f.MOVFF f s , f d = f d f d f d f d. Description, Move f to f.MOVFF f s , f d = The",
    "After Instruction\ncontents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space ( 000h to FFFh ) and location of destination 'f d ' can also be anywhere from 000h to FFFh . MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. Note: MOVFF has curtailed the source and destination range to the lower 4 Kbyte space of memory (Banks 1 through 15). For everything else, use MOVFFL .. Description, Move f to f.MOVFF f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space ( 000h to FFFh ) and location of destination 'f d ' can also be anywhere from 000h to FFFh . MOVFF is particularly useful for transferring a data memory location to",
    "After Instruction\na peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. Note: MOVFF has curtailed the source and destination range to the lower 4 Kbyte space of memory (Banks 1 through 15). For everything else, use MOVFFL .. Description, Move f to f.MOVFF f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space ( 000h to FFFh ) and location of destination 'f d ' can also be anywhere from 000h to FFFh . MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. Note: MOVFF has curtailed the source and destination range to the lower 4 Kbyte space of memory (Banks 1 through 15). For everything else, use",
    "After Instruction\nMOVFFL .. Description, Move f to f.MOVFF f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space ( 000h to FFFh ) and location of destination 'f d ' can also be anywhere from 000h to FFFh . MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. Note: MOVFF has curtailed the source and destination range to the lower 4 Kbyte space of memory (Banks 1 through 15). For everything else, use MOVFFL .. Words, Move f to f.MOVFF f s , f d = 2. Words, Move f to f.MOVFF f s , f d = 2. Words, Move f to f.MOVFF f s , f d = 2. Words, Move f to f.MOVFF f s , f d = 2.",
    "After Instruction\nCycles, Move f to f.MOVFF f s , f d = 2. Cycles, Move f to f.MOVFF f s , f d = 2. Cycles, Move f to f.MOVFF f s , f d = 2. Cycles, Move f to f.MOVFF f s , f d = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f s '. Decode, 2 = Process Data. Decode, 3 = No operation\nDecode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f d '\nExample: MOVFF REG1, REG2",
    "Before Instruction\nAddress of REG2 = 200h\nAddress of REG1 = 100h\nREG1 = 33h\nREG2 = 11h",
    "After Instruction\nAddress of REG1 = 100h\nAddress of REG2 = 200h\nREG1 = 33h\nREG2 = 33h",
    "After Instruction\nOperands, Move f to f (Long Range).MOVFFL f s , f d = 0 \u2264 f s \u2264 16383 0 \u2264 f d \u2264 16383. Operands, Move f to f (Long Range).MOVFFL f s , f d = 0 \u2264 f s \u2264 16383 0 \u2264 f d \u2264 16383. Operands, Move f to f (Long Range).MOVFFL f s , f d = 0 \u2264 f s \u2264 16383 0 \u2264 f d \u2264 16383. Operands, Move f to f (Long Range).MOVFFL f s , f d = 0 \u2264 f s \u2264 16383 0 \u2264 f d \u2264 16383. Operation, Move f to f (Long Range).MOVFFL f s , f d = (f s ) \u2192 f d. Operation, Move f to f (Long Range).MOVFFL f s , f d = (f s ) \u2192 f d. Operation, Move f to f (Long Range).MOVFFL f s , f d = (f s ) \u2192 f d. Operation, Move f to f (Long Range).MOVFFL f s , f",
    "After Instruction\nd = (f s ) \u2192 f d. Status Affected, Move f to f (Long Range).MOVFFL f s , f d = None. Status Affected, Move f to f (Long Range).MOVFFL f s , f d = None. Status Affected, Move f to f (Long Range).MOVFFL f s , f d = None. Status Affected, Move f to f (Long Range).MOVFFL f s , f d = None. Encoding, Move f to f (Long Range).MOVFFL f s , f d = 0000. Encoding, Move f to f (Long Range).MOVFFL f s , f d = 0000. Encoding, Move f to f (Long Range).MOVFFL f s , f d = 0110. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f s f s f s f s. Encoding, Move f to f (Long Range).MOVFFL f s , f d = 1111. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f",
    "After Instruction\ns f s f s f s. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f s f s f s f s. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f s f s f d f d. Encoding, Move f to f (Long Range).MOVFFL f s , f d = 1111. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f d f d f d f d. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f d f d f d f d. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f d f d f d f d. Description, Move f to f (Long Range).MOVFFL f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ) and location of destination",
    "After Instruction\n'f d ' can also be anywhere from 0000h to 3FFFh . Either source or destination can be W(a useful special situation). MOVFFL is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. Description, Move f to f (Long Range).MOVFFL f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ) and location of destination 'f d ' can also be anywhere from 0000h to 3FFFh . Either source or destination can be W(a useful special situation). MOVFFL is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. Description, Move f to",
    "After Instruction\nf (Long Range).MOVFFL f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ) and location of destination 'f d ' can also be anywhere from 0000h to 3FFFh . Either source or destination can be W(a useful special situation). MOVFFL is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. Description, Move f to f (Long Range).MOVFFL f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ) and location of destination 'f d ' can also be anywhere from 0000h to 3FFFh . Either source or destination can be W(a useful",
    "After Instruction\nspecial situation). MOVFFL is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. Words, Move f to f (Long Range).MOVFFL f s , f d = 3. Words, Move f to f (Long Range).MOVFFL f s , f d = 3. Words, Move f to f (Long Range).MOVFFL f s , f d = 3. Words, Move f to f (Long Range).MOVFFL f s , f d = 3. Cycles, Move f to f (Long Range).MOVFFL f s , f d = 3. Cycles, Move f to f (Long Range).MOVFFL f s , f d = 3. Cycles, Move f to f (Long Range).MOVFFL f s , f d = 3. Cycles, Move f to f (Long Range).MOVFFL f s , f d = 3",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation. Decode, 1 = Read register 'f s '. Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f d '\nExample: MOVFFL 2000h, 200Ah",
    "Before Instruction\nContents of 2000h = 33h\nContents of 200Ah = 11h",
    "After Instruction\nContents of 2000h = 33h\nContents of 200Ah = 33h",
    "After Instruction\nOperands, Move Literal to BSR.MOVLB k = 0 \u2264 k \u2264 63. Operands, Move Literal to BSR.MOVLB k = 0 \u2264 k \u2264 63. Operands, Move Literal to BSR.MOVLB k = 0 \u2264 k \u2264 63. Operands, Move Literal to BSR.MOVLB k = 0 \u2264 k \u2264 63. Operation, Move Literal to BSR.MOVLB k = k \u2192 BSR. Operation, Move Literal to BSR.MOVLB k = k \u2192 BSR. Operation, Move Literal to BSR.MOVLB k = k \u2192 BSR. Operation, Move Literal to BSR.MOVLB k = k \u2192 BSR. Status Affected, Move Literal to BSR.MOVLB k = None. Status Affected, Move Literal to BSR.MOVLB k = None. Status Affected, Move Literal to BSR.MOVLB k = None. Status Affected, Move Literal to BSR.MOVLB k = None. Encoding, Move Literal to BSR.MOVLB k = 0000. Encoding, Move Literal to BSR.MOVLB k = 0001. Encoding, Move Literal to",
    "After Instruction\nBSR.MOVLB k = 00kk. Encoding, Move Literal to BSR.MOVLB k = kkkk. Description, Move Literal to BSR.MOVLB k = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Description, Move Literal to BSR.MOVLB k = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Description, Move Literal to BSR.MOVLB k = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Description, Move Literal to BSR.MOVLB k = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Words, Move Literal to",
    "After Instruction\nBSR.MOVLB k = 1. Words, Move Literal to BSR.MOVLB k = 1. Words, Move Literal to BSR.MOVLB k = 1. Words, Move Literal to BSR.MOVLB k = 1. Cycles, Move Literal to BSR.MOVLB k = 1. Cycles, Move Literal to BSR.MOVLB k = 1. Cycles, Move Literal to BSR.MOVLB k = 1. Cycles, Move Literal to BSR.MOVLB k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to BSR\nExample: MOVLB 5",
    "Before Instruction\nBSR = 02h",
    "After Instruction\nBSR = 05h\nOperands, Move Literal to W.MOVLW k = 0 \u2264 k \u2264 255. Operands, Move Literal to W.MOVLW k = 0 \u2264 k \u2264 255. Operands, Move Literal to W.MOVLW k = 0 \u2264 k \u2264 255. Operands, Move Literal to W.MOVLW k = 0 \u2264 k \u2264 255. Operation, Move Literal to W.MOVLW k = k \u2192 W. Operation, Move Literal to W.MOVLW k = k \u2192 W. Operation, Move Literal to W.MOVLW k = k \u2192 W. Operation, Move Literal to W.MOVLW k = k \u2192 W. Status Affected, Move Literal to W.MOVLW k = None. Status Affected, Move Literal to W.MOVLW k = None. Status Affected, Move Literal to W.MOVLW k = None. Status Affected, Move Literal to W.MOVLW k = None. Encoding, Move Literal to W.MOVLW k = 0000. Encoding, Move Literal to W.MOVLW k = 1110. Encoding, Move Literal to",
    "After Instruction\nW.MOVLW k = kkkk. Encoding, Move Literal to W.MOVLW k = kkkk. Description, Move Literal to W.MOVLW k = The 8-bit literal 'k' is loaded into W. Description, Move Literal to W.MOVLW k = The 8-bit literal 'k' is loaded into W. Description, Move Literal to W.MOVLW k = The 8-bit literal 'k' is loaded into W. Description, Move Literal to W.MOVLW k = The 8-bit literal 'k' is loaded into W. Words, Move Literal to W.MOVLW k = 1. Words, Move Literal to W.MOVLW k = 1. Words, Move Literal to W.MOVLW k = 1. Words, Move Literal to W.MOVLW k = 1. Cycles, Move Literal to W.MOVLW k = 1. Cycles, Move Literal to W.MOVLW k = 1. Cycles, Move Literal to W.MOVLW k = 1. Cycles, Move Literal to W.MOVLW k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample: MOVLW 5Ah",
    "Before Instruction\nW = ?",
    "After Instruction\nW = 5Ah\nSyntax, Move Wto f = MOVWF f {,a}. Operands, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Move Wto f = (W) \u2192 f. Status Affected, Move Wto f = None. Encoding, Move Wto f = 0110. Description, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Move Wto f = 1. Cycles, Move Wto f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read W. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: MOVWF REG, 0",
    "Before Instruction\nREG = FFh\nW = 4Fh",
    "After Instruction\nW = 4Fh\nREG = 4Fh",
    "After Instruction\nOperands, Multiply literal with W.MULLW k = 0 \u2264 k \u2264 255. Operands, Multiply literal with W.MULLW k = 0 \u2264 k \u2264 255. Operands, Multiply literal with W.MULLW k = 0 \u2264 k \u2264 255. Operands, Multiply literal with W.MULLW k = 0 \u2264 k \u2264 255. Operation, Multiply literal with W.MULLW k = (W) x k \u2192 PRODH:PRODL. Operation, Multiply literal with W.MULLW k = (W) x k \u2192 PRODH:PRODL. Operation, Multiply literal with W.MULLW k = (W) x k \u2192 PRODH:PRODL. Operation, Multiply literal with W.MULLW k = (W) x k \u2192 PRODH:PRODL. Status Affected, Multiply literal with W.MULLW k = None. Status Affected, Multiply literal with W.MULLW k = None. Status Affected, Multiply literal with W.MULLW k = None. Status Affected, Multiply literal with W.MULLW k = None. Encoding, Multiply literal with",
    "After Instruction\nW.MULLW k = 0000. Encoding, Multiply literal with W.MULLW k = 1101. Encoding, Multiply literal with W.MULLW k = kkkk. Encoding, Multiply literal with W.MULLW k = kkkk. Description, Multiply literal with W.MULLW k = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description, Multiply literal with W.MULLW k = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description, Multiply literal with",
    "After Instruction\nW.MULLW k = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description, Multiply literal with W.MULLW k = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Words, Multiply literal with W.MULLW k = 1. Words, Multiply literal with W.MULLW k = 1. Words, Multiply literal with W.MULLW k = 1. Words, Multiply literal with W.MULLW k = 1. Cycles, Multiply literal with W.MULLW k = 1.",
    "After Instruction\nCycles, Multiply literal with W.MULLW k = 1. Cycles, Multiply literal with W.MULLW k = 1. Cycles, Multiply literal with W.MULLW k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write registers PRODH:PRODL\nExample: MULLW 0C4h",
    "Before Instruction\nW = E2h\nPRODH = ?\nPRODL = ?",
    "After Instruction\nW = E2h\nPRODH = ADh\nPRODL = 08h",
    "After Instruction\nOperands, Multiply Wwith f.MULWF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Multiply Wwith f.MULWF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Multiply Wwith f.MULWF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Multiply Wwith f.MULWF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Multiply Wwith f.MULWF f {,a} = (W) x (f) \u2192 PRODH:PRODL. Operation, Multiply Wwith f.MULWF f {,a} = (W) x (f) \u2192 PRODH:PRODL. Operation, Multiply Wwith f.MULWF f {,a} = (W) x (f) \u2192 PRODH:PRODL. Operation, Multiply Wwith f.MULWF f {,a} = (W) x (f) \u2192",
    "After Instruction\nPRODH:PRODL. Status Affected, Multiply Wwith f.MULWF f {,a} = None. Status Affected, Multiply Wwith f.MULWF f {,a} = None. Status Affected, Multiply Wwith f.MULWF f {,a} = None. Status Affected, Multiply Wwith f.MULWF f {,a} = None. Encoding, Multiply Wwith f.MULWF f {,a} = 0000. Encoding, Multiply Wwith f.MULWF f {,a} = 001a. Encoding, Multiply Wwith f.MULWF f {,a} = ffff. Encoding, Multiply Wwith f.MULWF f {,a} = ffff. Description, Multiply Wwith f.MULWF f {,a} = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither",
    "After Instruction\noverflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Multiply Wwith f.MULWF f {,a} = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended",
    "After Instruction\ninstruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Multiply Wwith f.MULWF f {,a} = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Multiply Wwith f.MULWF f {,a} = An unsigned multiplication is carried out",
    "After Instruction\nbetween the contents of Wand the register file location 'f'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Multiply Wwith f.MULWF f {,a} = 1. Words, Multiply Wwith f.MULWF f {,a} = 1. Words, Multiply Wwith f.MULWF f {,a} = 1. Words, Multiply Wwith f.MULWF f {,a} = 1. Cycles, Multiply Wwith",
    "After Instruction\nf.MULWF f {,a} = 1. Cycles, Multiply Wwith f.MULWF f {,a} = 1. Cycles, Multiply Wwith f.MULWF f {,a} = 1. Cycles, Multiply Wwith f.MULWF f {,a} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write registers PRODH:PRODL\nExample: MULWF REG, 1",
    "Before Instruction\nW = C4h\nREG = B5h\nPRODH = ?\nPRODL = ?",
    "After Instruction\nW = C4h REG = B5h PRODH = 8Ah PRODL = 94h\nOperands, Negate f.NEGF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]",
    "...........continued\nOperation, Negate f.NEGF f {,a} = (f) + 1 \u2192 f. Operation, Negate f.NEGF f {,a} = (f) + 1 \u2192 f. Operation, Negate f.NEGF f {,a} = (f) + 1 \u2192 f. Operation, Negate f.NEGF f {,a} = (f) + 1 \u2192 f. Status Affected, Negate f.NEGF f {,a} = N, OV, C, DC, Z. Status Affected, Negate f.NEGF f {,a} = N, OV, C, DC, Z. Status Affected, Negate f.NEGF f {,a} = N, OV, C, DC, Z. Status Affected, Negate f.NEGF f {,a} = N, OV, C, DC, Z. Encoding, Negate f.NEGF f {,a} = 0110. Encoding, Negate f.NEGF f {,a} = 110a. Encoding, Negate f.NEGF f {,a} = ffff.",
    "...........continued\nEncoding, Negate f.NEGF f {,a} = ffff. Description, Negate f.NEGF f {,a} = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Negate f.NEGF f {,a} = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal",
    "...........continued\nOffset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Negate f.NEGF f {,a} = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Negate f.NEGF f {,a} = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 '",
    "...........continued\nand the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Negate f.NEGF f {,a} = 1. Words, Negate f.NEGF f {,a} = 1. Words, Negate f.NEGF f {,a} = 1. Words, Negate f.NEGF f {,a} = 1. Cycles, Negate f.NEGF f {,a} = 1. Cycles, Negate f.NEGF f {,a} = 1. Cycles, Negate f.NEGF f {,a} = 1. Cycles, Negate f.NEGF f {,a} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: NEGF REG, 1\nBefore Instruction REG = 0011 1010 3Ah [ ]",
    "After Instruction\nREG = 1100 0110 C6h [ ]",
    "After Instruction\nSyntax, No Operation = NOP. Syntax, No Operation = NOP. Syntax, No Operation = NOP. Syntax, No Operation = NOP. Operands, No Operation = None. Operands, No Operation = None. Operands, No Operation = None. Operands, No Operation = None. Operation, No Operation = No operation. Operation, No Operation = No operation. Operation, No Operation = No operation. Operation, No Operation = No operation. Status Affected, No Operation = None. Status Affected, No Operation = None. Status Affected, No Operation = None. Status Affected, No Operation = None. Encoding, No Operation = 0000. Encoding, No Operation = 0000. Encoding, No Operation = 0000. Encoding, No Operation = 0000. , No Operation = 1111. , No Operation = xxxx. , No Operation = xxxx. , No Operation = xxxx. Description, No Operation = No operation. Description, No Operation = No operation. Description, No Operation = No operation. Description, No Operation = No operation. Words, No Operation = 1. Words, No Operation = 1. Words, No Operation = 1. Words, No Operation = 1. Cycles, No Operation =",
    "After Instruction\n1. Cycles, No Operation = 1. Cycles, No Operation = 1. Cycles, No Operation = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation\nExample: None.\nSyntax, Pop Top of Return Stack = POP. Operands, Pop Top of Return Stack = None. Operation, Pop Top of Return Stack = (TOS) \u2192 bit bucket",
    "...........continued\nDescription, Pop.Syntax POP.None. = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack (see the PUSH instruction description).. Words, Pop.Syntax POP.None. = 1. Cycles, Pop.Syntax POP.None. = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = POP TOS value. Decode, 3 = No operation",
    "Example:\nPOP\nGOTO    NEW",
    "Before Instruction\nStack (1 level down) = 014332h",
    "After Instruction\nTOS = 014332h\nPC = address ( NEW )\nTOS = 0031A2h",
    "After Instruction\nSyntax, Push Top of Return Stack = PUSH. Syntax, Push Top of Return Stack = PUSH. Syntax, Push Top of Return Stack = PUSH. Syntax, Push Top of Return Stack = PUSH. Operands, Push Top of Return Stack = None. Operands, Push Top of Return Stack = None. Operands, Push Top of Return Stack = None. Operands, Push Top of Return Stack = None. Operation, Push Top of Return Stack = (PC) + 2 \u2192 TOS. Operation, Push Top of Return Stack = (PC) + 2 \u2192 TOS. Operation, Push Top of Return Stack = (PC) + 2 \u2192 TOS. Operation, Push Top of Return Stack = (PC) + 2 \u2192 TOS. Status Affected, Push Top of Return Stack = None. Status Affected, Push Top of Return Stack = None. Status Affected, Push Top of Return Stack = None. Status Affected, Push Top of Return Stack = None. Encoding, Push Top of Return Stack = 0000. Encoding, Push Top of Return Stack = 0000. Encoding, Push Top of Return Stack = 0000. Encoding, Push Top of Return Stack = 0101. Description, Push Top of Return Stack = The PC + 2 is pushed",
    "After Instruction\nonto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack (see the POP instruction description).. Description, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack (see the POP instruction description).. Description, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack (see the POP instruction description).. Description, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack (see the POP instruction description).. Words, Push Top of Return Stack = 1. Words, Push Top of Return Stack = 1.",
    "After Instruction\nWords, Push Top of Return Stack = 1. Words, Push Top of Return Stack = 1. Cycles, Push Top of Return Stack = 1. Cycles, Push Top of Return Stack = 1. Cycles, Push Top of Return Stack = 1. Cycles, Push Top of Return Stack = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = PUSH PC + 2 onto return stack. Decode, 2 = No operation. Decode, 3 = No operation\nExample: PUSH",
    "Before Instruction\nTOS =\n00345Ah\nPC =\n000124h",
    "After Instruction\nTOS =\n000126h\nPC =\n000126h\nStack (1 level down) = 00345Ah",
    "After Instruction\nOperands, Relative Call.RCALL n = -1024 \u2264 n \u2264 1023. Operands, Relative Call.RCALL n = -1024 \u2264 n \u2264 1023. Operands, Relative Call.RCALL n = -1024 \u2264 n \u2264 1023. Operands, Relative Call.RCALL n = -1024 \u2264 n \u2264 1023. Operation, Relative Call.RCALL n = (PC) + 2 \u2192 TOS (PC) + 2 + 2n \u2192 PC. Operation, Relative Call.RCALL n = (PC) + 2 \u2192 TOS (PC) + 2 + 2n \u2192 PC. Operation, Relative Call.RCALL n = (PC) + 2 \u2192 TOS (PC) + 2 + 2n \u2192 PC. Operation, Relative Call.RCALL n = (PC) + 2 \u2192 TOS (PC) + 2 + 2n \u2192 PC. Status Affected, Relative Call.RCALL n = None. Status Affected, Relative Call.RCALL n = None. Status Affected, Relative Call.RCALL n = None. Status Affected, Relative Call.RCALL n = None. Encoding, Relative Call.RCALL n = 1101. Encoding, Relative",
    "After Instruction\nCall.RCALL n = 1nnn. Encoding, Relative Call.RCALL n = nnnn. Encoding, Relative Call.RCALL n = nnnn. Description, Relative Call.RCALL n = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description, Relative Call.RCALL n = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description, Relative Call.RCALL n = Subroutine call with a jump up to 1K from the current location. First, return address (PC +",
    "After Instruction\n2) is pushed onto the stack. Then, add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description, Relative Call.RCALL n = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Words, Relative Call.RCALL n = 1. Words, Relative Call.RCALL n = 1. Words, Relative Call.RCALL n = 1. Words, Relative Call.RCALL n = 1. Cycles, Relative Call.RCALL n = 2. Cycles, Relative Call.RCALL n = 2. Cycles, Relative Call.RCALL n = 2. Cycles, Relative Call.RCALL n = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n' PUSH PC to stack. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: HERE RCALL Jump",
    "Before Instruction\nPC = address ( HERE )",
    "After Instruction\nPC = address ( Jump )\nTOS = address ( HERE + 2 )\nSyntax, Reset = RESET. Syntax, Reset = RESET. Syntax, Reset = RESET. Operands, Reset = None. Operands, Reset = None. Operands, Reset = None. Operation, Reset = Reset all registers and flags that are affected by a MCLR Reset. Operation, Reset = Reset all registers and flags that are affected by a MCLR Reset. Operation, Reset = Reset all registers and flags that are affected by a MCLR Reset. Status Affected, Reset = All. Status Affected, Reset = All. Status Affected, Reset = All. Encoding, Reset = 0000. Encoding, Reset = 1111. Encoding, Reset = 1111. Description, Reset = This instruction provides a way to execute a MCLR Reset by software. Description, Reset = This instruction provides a way to execute a MCLR Reset by software. Description, Reset = This instruction provides a way to execute a MCLR Reset by software. Words, Reset = 1. Words, Reset = 1. Words, Reset = 1. Cycles, Reset = 1. Cycles, Reset = 1. Cycles, Reset = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Start Reset. Decode, 2 = No operation. Decode, 3 = No operation\nExample:\nRESET\nBefore Instruction All Registers = ? All Flags = ?",
    "After Instruction\nAll Registers = Reset Value\nAll Flags = Reset Value",
    "After Instruction\nSyntax, Return from Interrupt = RETFIE {s}. Syntax, Return from Interrupt = RETFIE {s}. Syntax, Return from Interrupt = RETFIE {s}. Syntax, Return from Interrupt = RETFIE {s}. Operands, Return from Interrupt = s \u2208 [0, 1]. Operands, Return from Interrupt = s \u2208 [0, 1]. Operands, Return from Interrupt = s \u2208 [0, 1]. Operands, Return from Interrupt = s \u2208 [0, 1]. Operation, Return from Interrupt = (TOS) \u2192 PC If s = 1 , context is restored into WREG, STATUS, BSR, FSR0H, FSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU registers from the corresponding shadow registers. If s = 0 , there is no change in status of any register. PCLATU, PCLATH are unchanged.. Operation, Return from Interrupt = (TOS) \u2192 PC If s = 1 , context is restored into WREG, STATUS, BSR, FSR0H,",
    "After Instruction\nFSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU registers from the corresponding shadow registers. If s = 0 , there is no change in status of any register. PCLATU, PCLATH are unchanged.. Operation, Return from Interrupt = (TOS) \u2192 PC If s = 1 , context is restored into WREG, STATUS, BSR, FSR0H, FSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU registers from the corresponding shadow registers. If s = 0 , there is no change in status of any register. PCLATU, PCLATH are unchanged.. Operation, Return from Interrupt = (TOS) \u2192 PC If s = 1 , context is restored into WREG, STATUS, BSR, FSR0H, FSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU registers from the corresponding shadow",
    "After Instruction\nregisters. If s = 0 , there is no change in status of any register. PCLATU, PCLATH are unchanged.. Status Affected, Return from Interrupt = STAT bits in INTCONx register. Status Affected, Return from Interrupt = STAT bits in INTCONx register. Status Affected, Return from Interrupt = STAT bits in INTCONx register. Status Affected, Return from Interrupt = STAT bits in INTCONx register. Encoding, Return from Interrupt = 0000. Encoding, Return from Interrupt = 0000. Encoding, Return from Interrupt = 0001. Encoding, Return from Interrupt = 000s. Description, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high- or low-priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers WREG_SHAD, STATUS_SHAD, BSR_SHAD, FSR0H_SHAD, FSR0L_SHAD, FSR1H_SHAD, FSR1L_SHAD, FSR2H_SHAD, FSR2L_SHAD,",
    "After Instruction\nPRODH_SHAD, PRODL_SHAD, PCLATH_SHAD and PCLATU_SHAD are loaded into corresponding registers. There are two sets of shadow registers, main context and low context. The set retrieved on RETFIE instruction execution depends on what the state of operation of the CPU was when RETFIE was executed. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high- or low-priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers WREG_SHAD, STATUS_SHAD, BSR_SHAD, FSR0H_SHAD, FSR0L_SHAD, FSR1H_SHAD, FSR1L_SHAD, FSR2H_SHAD, FSR2L_SHAD, PRODH_SHAD, PRODL_SHAD, PCLATH_SHAD and",
    "After Instruction\nPCLATU_SHAD are loaded into corresponding registers. There are two sets of shadow registers, main context and low context. The set retrieved on RETFIE instruction execution depends on what the state of operation of the CPU was when RETFIE was executed. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high- or low-priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers WREG_SHAD, STATUS_SHAD, BSR_SHAD, FSR0H_SHAD, FSR0L_SHAD, FSR1H_SHAD, FSR1L_SHAD, FSR2H_SHAD, FSR2L_SHAD, PRODH_SHAD, PRODL_SHAD, PCLATH_SHAD and PCLATU_SHAD are loaded into corresponding registers. There are two sets of shadow registers, main",
    "After Instruction\ncontext and low context. The set retrieved on RETFIE instruction execution depends on what the state of operation of the CPU was when RETFIE was executed. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high- or low-priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers WREG_SHAD, STATUS_SHAD, BSR_SHAD, FSR0H_SHAD, FSR0L_SHAD, FSR1H_SHAD, FSR1L_SHAD, FSR2H_SHAD, FSR2L_SHAD, PRODH_SHAD, PRODL_SHAD, PCLATH_SHAD and PCLATU_SHAD are loaded into corresponding registers. There are two sets of shadow registers, main context and low context. The set retrieved on RETFIE instruction execution depends on what the state of operation",
    "After Instruction\nof the CPU was when RETFIE was executed. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Words, Return from Interrupt = 1. Words, Return from Interrupt = 1. Words, Return from Interrupt = 1. Words, Return from Interrupt = 1. Cycles, Return from Interrupt = 2. Cycles, Return from Interrupt = 2. Cycles, Return from Interrupt = 2. Cycles, Return from Interrupt = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = Process Data. Decode, 3 = POP PC from stack. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: RETFIE 1",
    "After Instruction\nPC = (TOS) WREG = (WREG_SHAD) BSR = (BSR_SHAD) STATUS = (STATUS_SHAD) FSR0H/L = (FSR0H/L_SHAD) FSR1H/L = (FSR1H/L_SHAD) FSR2H/L = (FSR2H/L_SHAD) PRODH/L = (PRODH/L_SHAD) PCLATH/U = (PCLATH/U_SHAD)",
    "After Instruction\nSyntax, Return Literal to W = RETLW k. Syntax, Return Literal to W = RETLW k. Syntax, Return Literal to W = RETLW k. Syntax, Return Literal to W = RETLW k. Operands, Return Literal to W = 0 \u2264 k \u2264 255. Operands, Return Literal to W = 0 \u2264 k \u2264 255. Operands, Return Literal to W = 0 \u2264 k \u2264 255. Operands, Return Literal to W = 0 \u2264 k \u2264 255. Operation, Return Literal to W = k \u2192 W (TOS) \u2192 PC PCLATU, PCLATH are unchanged. Operation, Return Literal to W = k \u2192 W (TOS) \u2192 PC PCLATU, PCLATH are unchanged. Operation, Return Literal to W = k \u2192 W (TOS) \u2192 PC PCLATU, PCLATH are unchanged. Operation, Return Literal to W = k \u2192 W (TOS) \u2192 PC PCLATU, PCLATH are unchanged. Status Affected, Return Literal to W = None. Status Affected, Return Literal to W = None. Status Affected, Return Literal to W = None. Status Affected, Return Literal to W = None. Encoding, Return Literal to W",
    "After Instruction\n= 0000. Encoding, Return Literal to W = 1100. Encoding, Return Literal to W = kkkk. Encoding, Return Literal to W = kkkk. Description, Return Literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return Literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return Literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return Literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The upper and high address latches (PCLATU/H) remain",
    "After Instruction\nunchanged.. Words, Return Literal to W = 1. Words, Return Literal to W = 1. Words, Return Literal to W = 1. Words, Return Literal to W = 1. Cycles, Return Literal to W = 2. Cycles, Return Literal to W = 2. Cycles, Return Literal to W = 2. Cycles, Return Literal to W = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = POP PC from stack Write to W. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nCALL, 1 = TABLE. CALL, 2 = ;. CALL, 3 = W contains table offset value. BACK, 1 = . BACK, 2 = ;. BACK, 3 = W now has table value (after RETLW). :, 1 = . :, 2 = . :, 3 = . :, 1 = . :, 2 = . :, 3 = . TABLE, 1 = . TABLE, 2 = . TABLE, 3 = . ADDWF, 1 = PCL. ADDWF, 2 = ;. ADDWF, 3 = W = offset. RETLW, 1 = k0. RETLW, 2 = ;. RETLW, 3 = Begin table. RETLW, 1 = k1. RETLW, 2 = ;. RETLW, 3 = . :, 1 = . :, 2 = . :, 3 = . :, 1 = . :, 2 = . :, 3 = . RETLW, 1 = kn. RETLW, 2 = ;. RETLW, 3 = End of table",
    "Before Instruction\nW = 07h",
    "After Instruction\nW = value of kn",
    "After Instruction\nOperands, Return from Subroutine.RETURN {s} = s \u2208 [0, 1]. Operands, Return from Subroutine.RETURN {s} = s \u2208 [0, 1]. Operands, Return from Subroutine.RETURN {s} = s \u2208 [0, 1]. Operands, Return from Subroutine.RETURN {s} = s \u2208 [0, 1]. Operation, Return from Subroutine.RETURN {s} = (TOS) \u2192 PC If s = 1 (WREG_CSHAD) \u2192 WREG (STATUS_CSHAD) \u2192 STATUS (BSR_CSHAD) \u2192 BSR PCLATU, PCLATH are unchanged. Operation, Return from Subroutine.RETURN {s} = (TOS) \u2192 PC If s = 1 (WREG_CSHAD) \u2192 WREG (STATUS_CSHAD) \u2192 STATUS (BSR_CSHAD) \u2192 BSR PCLATU, PCLATH are unchanged. Operation, Return from Subroutine.RETURN {s} = (TOS) \u2192 PC If s = 1 (WREG_CSHAD) \u2192 WREG (STATUS_CSHAD) \u2192 STATUS",
    "After Instruction\n(BSR_CSHAD) \u2192 BSR PCLATU, PCLATH are unchanged. Operation, Return from Subroutine.RETURN {s} = (TOS) \u2192 PC If s = 1 (WREG_CSHAD) \u2192 WREG (STATUS_CSHAD) \u2192 STATUS (BSR_CSHAD) \u2192 BSR PCLATU, PCLATH are unchanged. Status Affected, Return from Subroutine.RETURN {s} = None. Status Affected, Return from Subroutine.RETURN {s} = None. Status Affected, Return from Subroutine.RETURN {s} = None. Status Affected, Return from Subroutine.RETURN {s} = None. Encoding, Return from Subroutine.RETURN {s} = 0000. Encoding, Return from Subroutine.RETURN {s} = 0000. Encoding, Return from Subroutine.RETURN {s} = 0001. Encoding, Return from Subroutine.RETURN {s} = 001s. Description, Return from Subroutine.RETURN {s} = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's' =",
    "After Instruction\n1 , the contents of the shadow registers WREG_CSHAD, STATUS_CSHAD and BSR_CSHAD, are loaded into their corresponding registers. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return from Subroutine.RETURN {s} = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's' = 1 , the contents of the shadow registers WREG_CSHAD, STATUS_CSHAD and BSR_CSHAD, are loaded into their corresponding registers. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return from Subroutine.RETURN {s} = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's' = 1 , the contents of the shadow registers WREG_CSHAD, STATUS_CSHAD and BSR_CSHAD, are loaded into their corresponding",
    "After Instruction\nregisters. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return from Subroutine.RETURN {s} = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's' = 1 , the contents of the shadow registers WREG_CSHAD, STATUS_CSHAD and BSR_CSHAD, are loaded into their corresponding registers. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Words, Return from Subroutine.RETURN {s} = 1. Words, Return from Subroutine.RETURN {s} = 1. Words, Return from Subroutine.RETURN {s} = 1. Words, Return from Subroutine.RETURN {s} = 1",
    "...........continued\nCycles, Return from Subroutine.RETURN {s} = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = Process Data. Decode, 3 = POP PC from stack. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: RETURN 1\nAfter Instruction PC = (TOS) WREG = (WREG_CSHAD) BSR = (BSR_CSHAD) STATUS = (STATUS_CSHAD)",
    "Q Cycle Activity:\nSyntax, Rotate Left f through Carry = RLCF f {,d {,a}}. Operands, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Rotate Left f through Carry = (f<n>) \u2192 dest<n+1> (f<7>) \u2192 C (C) \u2192 dest<0>. Status Affected, Rotate Left f through Carry = C, N, Z. Encoding, Rotate Left f through Carry = 0011. Description, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh",
    "Q Cycle Activity:\n). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. C register f. Words, Rotate Left f through Carry = 1. Cycles, Rotate Left f through Carry = 1\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: RLCF REG, 0, 0\nBefore Instruction REG = 1110 0110 E6h [ ] W = ? C = 0\nAfter Instruction REG = 1110 0110 E6h [ ] W = 1100 1100 CCh [ ] C = 1",
    "Q Cycle Activity:\nSyntax, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Operands, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Rotate Left f (No Carry) = (f<n>) \u2192 dest<n+1> (f<7>) \u2192 dest<0>. Status Affected, Rotate Left f (No Carry) = N, Z. Encoding, Rotate Left f (No Carry) = 0100. Description, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (",
    "Q Cycle Activity:\n5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Words, Rotate Left f (No Carry) = 1. Cycles, Rotate Left f (No Carry) = 1\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: RLNCF REG, 1, 0",
    "Before Instruction\nREG = 1010 1011 ABh [ ]",
    "After Instruction\nREG = 0101 0111 57h [ ]",
    "After Instruction\nOperands, Rotate Right f through Carry.RRCF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Rotate Right f through Carry.RRCF f {,d {,a}} = . Operands, Rotate Right f through Carry.RRCF f {,d {,a}} = . Operands, Rotate Right f through Carry.RRCF f {,d {,a}} = . Operation, Rotate Right f through Carry.RRCF f {,d {,a}} = (f<n>) \u2192 dest<n-1> (f<0>) \u2192 C (C) \u2192 dest<7>. Operation, Rotate Right f through Carry.RRCF f {,d {,a}} = . Operation, Rotate Right f through Carry.RRCF f {,d {,a}} = . Operation, Rotate Right f through Carry.RRCF f {,d {,a}} = . Status Affected, Rotate Right f through Carry.RRCF f {,d {,a}} = C,",
    "After Instruction\nN, Z. Status Affected, Rotate Right f through Carry.RRCF f {,d {,a}} = . Status Affected, Rotate Right f through Carry.RRCF f {,d {,a}} = . Status Affected, Rotate Right f through Carry.RRCF f {,d {,a}} = . Encoding, Rotate Right f through Carry.RRCF f {,d {,a}} = 0011. Encoding, Rotate Right f through Carry.RRCF f {,d {,a}} = 00da. Encoding, Rotate Right f through Carry.RRCF f {,d {,a}} = ffff. Encoding, Rotate Right f through Carry.RRCF f {,d {,a}} = ffff",
    "...........continued\nDescription, Rotate Right f through Carry.RRCF f {,d {,a}} = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. C register f. Words, Rotate Right f through Carry.RRCF f {,d {,a}} = 1. Cycles, Rotate Right f through Carry.RRCF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: RRCF REG, 0, 0",
    "Before Instruction\nREG = 1110 0110 E6h [ ]\nW = ?\nC = 0",
    "After Instruction\nW = 0111 0011 73h [ ]\nREG = 1110 0110 E6h [ ]\nC = 0",
    "After Instruction\nSyntax, Rotate Right f (No Carry) = RRNCF f {,d {,a}}. Operands, Rotate Right f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Rotate Right f (No Carry) = (f<n>) \u2192 dest<n-1> (f<0>) \u2192 dest<7>. Status Affected, Rotate Right f (No Carry) = N, Z. Encoding, Rotate Right f (No Carry) = 0100. Description, Rotate Right f (No Carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh",
    "After Instruction\n). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Words, Rotate Right f (No Carry) = 1. Cycles, Rotate Right f (No Carry) = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample 1: RRNCF REG, 1, 0",
    "Before Instruction\nREG = 1101 0111 D7h [ ]",
    "After Instruction\nREG = 1110 1011 EBh [ ]\nExample 2: RRNCF REG, 0, 0",
    "Before Instruction\nREG = 1101 0111 D7h [ ] W = ?",
    "After Instruction\nREG = 1101 0111 D7h [ ]\nW = 1110 1011 EBh [ ]\nSyntax, Set f = SETF f {,a}. Operands, Set f = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Set f = FFh \u2192 f. Status Affected, Set f = None. Encoding, Set f = 0110. Description, Set f = The contents of the specified register 'f' are set to FFh . If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Set f = 1. Cycles, Set f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: SETF REG, 1",
    "Before Instruction\nREG = 5Ah\nAfter Instruction REG = FFh",
    "Before Instruction\nSyntax, Enter Sleep Mode = SLEEP. Syntax, Enter Sleep Mode = SLEEP. Syntax, Enter Sleep Mode = SLEEP. Syntax, Enter Sleep Mode = SLEEP. Operands, Enter Sleep Mode = None. Operands, Enter Sleep Mode = None. Operands, Enter Sleep Mode = None. Operands, Enter Sleep Mode = None. Operation, Enter Sleep Mode = 00h \u2192 WDT 1 \u2192 TO 0 \u2192 PD. Operation, Enter Sleep Mode = 00h \u2192 WDT 1 \u2192 TO 0 \u2192 PD. Operation, Enter Sleep Mode = 00h \u2192 WDT 1 \u2192 TO 0 \u2192 PD. Operation, Enter Sleep Mode = 00h \u2192 WDT 1 \u2192 TO 0 \u2192 PD. Status Affected, Enter Sleep Mode = TO, PD. Status Affected, Enter Sleep Mode = TO, PD. Status Affected, Enter Sleep Mode = TO, PD. Status Affected, Enter Sleep Mode = TO, PD. Encoding, Enter Sleep Mode = 0000. Encoding, Enter Sleep Mode = 0000. Encoding, Enter Sleep Mode = 0000. Encoding, Enter Sleep Mode = 0011. Description, Enter Sleep Mode = The Power-down Status (PD) bit is cleared. The Time-Out Status TO) bit is set. Watchdog Timer is",
    "Before Instruction\ncleared. The processor is put into Sleep mode with the oscillator stopped.. Description, Enter Sleep Mode = The Power-down Status (PD) bit is cleared. The Time-Out Status TO) bit is set. Watchdog Timer is cleared. The processor is put into Sleep mode with the oscillator stopped.. Description, Enter Sleep Mode = The Power-down Status (PD) bit is cleared. The Time-Out Status TO) bit is set. Watchdog Timer is cleared. The processor is put into Sleep mode with the oscillator stopped.. Description, Enter Sleep Mode = The Power-down Status (PD) bit is cleared. The Time-Out Status TO) bit is set. Watchdog Timer is cleared. The processor is put into Sleep mode with the oscillator stopped.. Words, Enter Sleep Mode = 1. Words, Enter Sleep Mode = 1. Words, Enter Sleep Mode = 1. Words, Enter Sleep Mode = 1. Cycles, Enter Sleep Mode = 1. Cycles, Enter Sleep Mode = 1. Cycles, Enter Sleep Mode = 1. Cycles, Enter Sleep Mode = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = Process Data. Decode, 3 = Go to Sleep\nExample: SLEEP",
    "Before Instruction\nTO = ?\nPD = ?",
    "After Instruction\nTO = 1 \u2020\nPD = 0\n\u2020 If WDT causes wake-up, this bit is cleared.",
    "After Instruction\nOperands, Subtract Literal from FSR.SUBFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operands, Subtract Literal from FSR.SUBFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operands, Subtract Literal from FSR.SUBFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operands, Subtract Literal from FSR.SUBFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operation, Subtract Literal from FSR.SUBFSR f n , k = (FSRf n ) - k \u2192 FSRf n. Operation, Subtract Literal from FSR.SUBFSR f n , k = (FSRf n ) - k \u2192 FSRf n. Operation, Subtract Literal from FSR.SUBFSR f n , k = (FSRf n ) - k \u2192 FSRf n. Operation, Subtract Literal from FSR.SUBFSR f n , k =",
    "After Instruction\n(FSRf n ) - k \u2192 FSRf n. Status Affected, Subtract Literal from FSR.SUBFSR f n , k = None. Status Affected, Subtract Literal from FSR.SUBFSR f n , k = None. Status Affected, Subtract Literal from FSR.SUBFSR f n , k = None. Status Affected, Subtract Literal from FSR.SUBFSR f n , k = None. Encoding, Subtract Literal from FSR.SUBFSR f n , k = 1110. Encoding, Subtract Literal from FSR.SUBFSR f n , k = 1001. Encoding, Subtract Literal from FSR.SUBFSR f n , k = f n f n kk. Encoding, Subtract Literal from FSR.SUBFSR f n , k = kkkk. Description, Subtract Literal from FSR.SUBFSR f n , k = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f n '. Description, Subtract Literal from FSR.SUBFSR f n , k = The 6-bit literal",
    "After Instruction\n'k' is subtracted from the contents of the FSR specified by 'f n '. Description, Subtract Literal from FSR.SUBFSR f n , k = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f n '. Description, Subtract Literal from FSR.SUBFSR f n , k = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f n '. Words, Subtract Literal from FSR.SUBFSR f n , k = 1. Words, Subtract Literal from FSR.SUBFSR f n , k = 1. Words, Subtract Literal from FSR.SUBFSR f n , k = 1. Words, Subtract Literal from FSR.SUBFSR f n , k = 1. Cycles, Subtract Literal from FSR.SUBFSR f n , k = 1. Cycles, Subtract Literal from FSR.SUBFSR f n , k = 1. Cycles, Subtract Literal from FSR.SUBFSR f n , k = 1. Cycles, Subtract Literal from",
    "After Instruction\nFSR.SUBFSR f n , k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to FSR\nExample: SUBFSR 2, 23h\nBefore Instruction FSR2 = 03FFh",
    "After Instruction\nFSR2 = 03DCh",
    "After Instruction\nSyntax, Subtract f from Wwith Borrow = SUBFWB f {,d {,a}}. Operands, Subtract f from Wwith Borrow = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Subtract f from Wwith Borrow = (W) - (f) - (C) \u2192 dest. Status Affected, Subtract f from Wwith Borrow = N, OV, C, DC, Z. Encoding, Subtract f from Wwith Borrow = 0101. Description, Subtract f from Wwith Borrow = Subtract register 'f' and Carry flag (Borrow) from W(two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing",
    "After Instruction\nmode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Subtract f from Wwith Borrow = 1. Cycles, Subtract f from Wwith Borrow = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample 1: SUBFWB REG, 1, 0",
    "Before Instruction\nREG =\n03h\nW = 02h\nC = 1",
    "After Instruction\nREG = FFh (two's complement)\nW = 02h\nC = 0\nZ = 0\nN = 1 (result is negative)\nExample 2: SUBFWB REG, 0, 0",
    "Before Instruction\nC = 1\nREG = 02h\nW = 05h",
    "After Instruction\nREG = 02h\nW = 03h\nC = 1\nZ = 0\nN = 0 (result is positive)\nExample 3: SUBFWB REG, 1, 0",
    "Before Instruction\nREG =\n01h\nW = 02h\nC = 0",
    "After Instruction\nREG = 00h\nW = 02h\nC = 1\nZ = 1 (result is zero)\nN = 0",
    "After Instruction\nSyntax, Subtract Wfrom Literal = SUBLW k. Syntax, Subtract Wfrom Literal = SUBLW k. Syntax, Subtract Wfrom Literal = SUBLW k. Operands, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operands, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operands, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operation, Subtract Wfrom Literal = k - (W) \u2192 W. Operation, Subtract Wfrom Literal = k - (W) \u2192 W. Operation, Subtract Wfrom Literal = k - (W) \u2192 W. Status Affected, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected, Subtract Wfrom Literal = N, OV, C, DC, Z. Encoding, Subtract Wfrom Literal = 0000. Encoding, Subtract Wfrom Literal = kkkk. Encoding, Subtract Wfrom Literal =",
    "After Instruction\nkkkk. Description, Subtract Wfrom Literal = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, Subtract Wfrom Literal = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, Subtract Wfrom Literal = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Words, Subtract Wfrom Literal = 1. Words, Subtract Wfrom Literal = 1. Words, Subtract Wfrom Literal = 1. Cycles, Subtract Wfrom Literal = 1. Cycles, Subtract Wfrom Literal = 1. Cycles, Subtract Wfrom Literal = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample 1: SUBLW 02h",
    "Before Instruction\nC = ?\nW = 01h",
    "After Instruction\nC =\n1\n(result is positive)\nZ = 0\nN = 0\nW = 01h\nExample 2: SUBLW 02h",
    "Before Instruction\nC = ?\nW = 02h",
    "After Instruction\nW = 00h\nC = 1\nZ = 1 (result is zero)\nN = 0\nExample 3: SUBLW 02h",
    "Before Instruction\nW = 03h\nC = ?",
    "After Instruction\nW = FFh (two's complement)\nC = 0\nZ = 0\nN = 1 (result is negative)",
    "After Instruction\nOperands, Subtract Wfrom f.SUBWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract Wfrom f.SUBWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract Wfrom f.SUBWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract Wfrom f.SUBWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Subtract Wfrom f.SUBWF f {,d {,a}} = (f) - (W) \u2192 dest. Operation, Subtract Wfrom f.SUBWF f {,d {,a}} = (f) - (W) \u2192 dest. Operation, Subtract Wfrom",
    "After Instruction\nf.SUBWF f {,d {,a}} = (f) - (W) \u2192 dest. Operation, Subtract Wfrom f.SUBWF f {,d {,a}} = (f) - (W) \u2192 dest. Status Affected, Subtract Wfrom f.SUBWF f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract Wfrom f.SUBWF f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract Wfrom f.SUBWF f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract Wfrom f.SUBWF f {,d {,a}} = N, OV, C, DC, Z. Encoding, Subtract Wfrom f.SUBWF f {,d {,a}} = 0101. Encoding, Subtract Wfrom f.SUBWF f {,d {,a}} = 11da. Encoding,",
    "After Instruction\nSubtract Wfrom f.SUBWF f {,d {,a}} = ffff. Encoding, Subtract Wfrom f.SUBWF f {,d {,a}} = ffff. Description, Subtract Wfrom f.SUBWF f {,d {,a}} = Subtract Wfrom register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract Wfrom f.SUBWF f {,d {,a}} = Subtract Wfrom register 'f'",
    "After Instruction\n(two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract Wfrom f.SUBWF f {,d {,a}} = Subtract Wfrom register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.",
    "After Instruction\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract Wfrom f.SUBWF f {,d {,a}} = Subtract Wfrom register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Subtract Wfrom f.SUBWF f {,d {,a}} = 1. Words, Subtract",
    "After Instruction\nWfrom f.SUBWF f {,d {,a}} = 1. Words, Subtract Wfrom f.SUBWF f {,d {,a}} = 1. Words, Subtract Wfrom f.SUBWF f {,d {,a}} = 1. Cycles, Subtract Wfrom f.SUBWF f {,d {,a}} = 1. Cycles, Subtract Wfrom f.SUBWF f {,d {,a}} = 1. Cycles, Subtract Wfrom f.SUBWF f {,d {,a}} = 1. Cycles, Subtract Wfrom f.SUBWF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample 1: SUBWF REG, 1, 0",
    "Before Instruction\nREG = 03h\nW = 02h\nC = ?",
    "After Instruction\nREG = 01h (two's complement)\nW = 02h\nC = 1 (result is positive)\nZ = 0\nN = 0\nExample 2: SUBWF REG, 0, 0",
    "Before Instruction\nW = 02h\nREG = 02h\nC = ?",
    "After Instruction\nN = 0\nREG =\n02h\nW = 00h\nC = 1\nZ = 1 (result is zero)\nExample 3: SUBWF REG, 1, 0",
    "Before Instruction\nREG = 01h\nW = 02h\nC = ?",
    "After Instruction\nREG = FFh (two's complement)\nW = 02h\nC = 0\nZ = 0\nN = 1 (result is negative)",
    "After Instruction\nOperands, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = (f) - (W) - (C) \u2192 dest. Operation, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = (f) -",
    "After Instruction\n(W) - (C) \u2192 dest. Operation, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = (f) - (W) - (C) \u2192 dest. Operation, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = (f) - (W) - (C) \u2192 dest. Status Affected, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = N, OV, C, DC, Z. Encoding, Subtract Wfrom f with Borrow.SUBWFB",
    "After Instruction\nf {,d {,a}} = 0101. Encoding, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 10da. Encoding, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = ffff. Encoding, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = ffff. Description, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = Subtract Wand the Carry flag (Borrow) from register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh",
    "After Instruction\n). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = Subtract Wand the Carry flag (Borrow) from register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = Subtract Wand the Carry flag (Borrow) from register 'f' (two's complement method). If 'd' is ' 0 ',",
    "After Instruction\nthe result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = Subtract Wand the Carry flag (Borrow) from register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the",
    "After Instruction\nextended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Words, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Words, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Words, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Cycles, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Cycles, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Cycles, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Cycles, Subtract Wfrom f with Borrow.SUBWFB f {,d",
    "After Instruction\n{,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample 1: SUBWFB REG, 1, 0",
    "Before Instruction\nREG = 19h 0001 1001 ( ) W = 0Dh 0000 1101 ( ) C = 1",
    "After Instruction\nREG = 0Ch 0000 1100 ( )\nW = 0Dh 0000 1101 ( )",
    "C = 1 (result is positive)\nZ = 0\nN = 0\nExample 2: SUBWFB REG, 0, 0",
    "Before Instruction\nW = 1Ah 0001 1010 ( )\nC = 0\nREG = 1Bh 0001 1011 ( )",
    "After Instruction\nW = 00h\nREG = 1Bh 0001 1011 ( )\nC = 1\nN = 0\nZ = 1 (result is zero)\nExample 3: SUBWFB REG, 1, 0",
    "Before Instruction\nREG = 03h 0000 0011 ( )\nW = 0Eh 0000 1110 ( )\nC = 1",
    "After Instruction\nC = 0\nREG = F5h 1111 0101 ( ) (two's complement) W = 0Eh 0000 1110 ( )\nZ = 0\nN = 1 (result is negative)",
    "After Instruction\nSyntax, Swap f = SWAPF f {,d {,a}}. Operands, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Swap f = (f<3:0>) \u2192 dest<7:4> (f<7:4>) \u2192 dest<3:0>. Status Affected, Swap f = None. Encoding, Swap f = 0011. Description, Swap f = The upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Swap f = 1.",
    "After Instruction\nCycles, Swap f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4\nDecode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample:\nSWAPF REG, 1, 0",
    "Before Instruction\nREG = 53h",
    "After Instruction\nREG = 35h\nSyntax, Table Read = TBLRD * TBLRD *+ TBLRD *- TBLRD +*. Syntax,  = TBLRD * TBLRD *+ TBLRD *- TBLRD +*. Syntax,  = TBLRD * TBLRD *+ TBLRD *- TBLRD +*. Syntax,  = TBLRD * TBLRD *+ TBLRD *- TBLRD +*. Operands, Table Read = None. Operands,  = None. Operands,  = None. Operands,  = None. Operation, Table Read = If TBLRD * (Prog Mem(TBLPTR)) \u2192 TABLAT TBLPTR - No Change If TBLRD *+ (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) + 1 \u2192 TBLPTR If TBLRD *- (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) - 1 \u2192 TBLPTR If TBLRD +* (TBLPTR) + 1 \u2192 TBLPTR (Prog Mem(TBLPTR)) \u2192 TABLAT. Operation,",
    "After Instruction\n= If TBLRD * (Prog Mem(TBLPTR)) \u2192 TABLAT TBLPTR - No Change If TBLRD *+ (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) + 1 \u2192 TBLPTR If TBLRD *- (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) - 1 \u2192 TBLPTR If TBLRD +* (TBLPTR) + 1 \u2192 TBLPTR (Prog Mem(TBLPTR)) \u2192 TABLAT. Operation,  = If TBLRD * (Prog Mem(TBLPTR)) \u2192 TABLAT TBLPTR - No Change If TBLRD *+ (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) + 1 \u2192 TBLPTR If TBLRD *- (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) - 1 \u2192 TBLPTR If TBLRD +* (TBLPTR) + 1 \u2192 TBLPTR (Prog Mem(TBLPTR)) \u2192 TABLAT. Operation,",
    "After Instruction\n= If TBLRD * (Prog Mem(TBLPTR)) \u2192 TABLAT TBLPTR - No Change If TBLRD *+ (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) + 1 \u2192 TBLPTR If TBLRD *- (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) - 1 \u2192 TBLPTR If TBLRD +* (TBLPTR) + 1 \u2192 TBLPTR (Prog Mem(TBLPTR)) \u2192 TABLAT. Status Affected, Table Read = None. Status Affected,  = None. Status Affected,  = None. Status Affected,  = None. Encoding, Table Read = 0000. Encoding,  = 0000. Encoding,  = 0000. Encoding,",
    "After Instruction\n= 10mm mm=0 * mm=1 *+ mm=2 *- mm=3 +*. Description, Table Read = This instruction is used to read the contents of Program Memory. To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range.. Description,  = This instruction is used to read the contents of Program Memory. To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range.. Description,  = This instruction is used to read the contents of Program Memory. To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range.. Description,",
    "After Instruction\n= This instruction is used to read the contents of Program Memory. To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range.. Words, Table Read = 1. Words,  = 1. Words,  = 1. Words,  = 1. Cycles, Table Read = 2. Cycles,  = 2. Cycles,  = 2. Cycles,  = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation\nNo operation, 1 = No operation (Read Program Memory). No operation, 2 = No operation. No operation, 3 = No operation (Write TABLAT)\nExample 1:\nTBLRD *+",
    "Before Instruction\nTABLAT = 55h TBLPTR = 00A356h MEMORY ( 00A356h ) = 34h",
    "After Instruction\nTBLPTR = 00A357h\nTABLAT = 34h",
    "Before Instruction\nTABLAT = AAh\nTBLPTR = 01A357h\nMEMORY ( 01A357h ) = 12h\nMEMORY ( 01A358h ) = 34h",
    "After Instruction\nTABLAT = 34h\nTBLPTR = 01A358h",
    "After Instruction\nSyntax, Table Write = TBLWT * TBLWT *+ TBLWT *- TBLWT +*. Syntax, Table Write = TBLWT * TBLWT *+ TBLWT *- TBLWT +*. Syntax, Table Write = TBLWT * TBLWT *+ TBLWT *- TBLWT +*. Operands, Table Write = None. Operands, Table Write = None. Operands, Table Write = None. Operation, Table Write = If TBLWT * (TABLAT) \u2192 Holding Register TBLPTR - No Change If TBLWT *+ (TABLAT) \u2192 Holding Register (TBLPTR) + 1 \u2192 TBLPTR If TBLWT *- (TABLAT) \u2192 Holding Register (TBLPTR) - 1 \u2192 TBLPTR If TBLWT +* (TBLPTR) + 1 \u2192 TBLPTR (TABLAT) \u2192 Holding Register. Operation, Table Write = If TBLWT * (TABLAT) \u2192 Holding Register TBLPTR - No Change If TBLWT *+ (TABLAT) \u2192 Holding Register (TBLPTR) + 1 \u2192 TBLPTR If TBLWT *- (TABLAT) \u2192 Holding",
    "After Instruction\nRegister (TBLPTR) - 1 \u2192 TBLPTR If TBLWT +* (TBLPTR) + 1 \u2192 TBLPTR (TABLAT) \u2192 Holding Register. Operation, Table Write = If TBLWT * (TABLAT) \u2192 Holding Register TBLPTR - No Change If TBLWT *+ (TABLAT) \u2192 Holding Register (TBLPTR) + 1 \u2192 TBLPTR If TBLWT *- (TABLAT) \u2192 Holding Register (TBLPTR) - 1 \u2192 TBLPTR If TBLWT +* (TBLPTR) + 1 \u2192 TBLPTR (TABLAT) \u2192 Holding Register. Status Affected, Table Write = None. Status Affected, Table Write = None. Status Affected, Table Write = None. Encoding, Table Write = 0000. Encoding, Table Write = 0000. Encoding, Table Write = 11mm mm=0 * mm=1 *+ mm=2 *-",
    "...........continued\nSyntax, Table Write = TBLWT * TBLWT *+ TBLWT *- TBLWT +*. Description, Table Write = This instruction uses the three LSBs of TBLPTR to determine which of the eight holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (refer to the 'Program Flash Memory' section for additional details on programming Flash memory). The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLWT instruction can modify the value of TBLPTR as follows: \u2022 no change ( TBLWT * ) \u2022 post-increment ( TBLWT *+ ) \u2022 post-decrement ( TBLWT *- ) \u2022 pre-increment ( TBLWT +* ). Words, Table Write = 1.",
    "...........continued\nCycles, Table Write = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation. No operation, 1 = No operation (Read TABLAT). No operation, 2 = No operation. No operation, 3 = No operation (Write to Holding Register)\nExample 1: TBLWT *+",
    "Before Instruction\nTABLAT = 55h\nTBLPTR =\n00A356h\nHOLDING REGISTER ( 00A356h ) = FFh",
    "After Instruction (table write completion)\nTABLAT =\n55h\nTBLPTR = 00A357h\nHOLDING REGISTER ( 00A356h ) = 55h\nExample 2: TBLWT +*",
    "Before Instruction\nTABLAT = 34h TBLPTR = 01389Ah HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = FFh\nAfter Instruction (table write completion) TABLAT = 34h TBLPTR = 01389Bh",
    "HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = 34h\nOperands, Test f, Skip if 0.TSTFSZ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Test f, Skip if 0.TSTFSZ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Test f, Skip if 0.TSTFSZ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Test f, Skip if 0.TSTFSZ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Test f, Skip if 0.TSTFSZ f {,a} = Skip if f = 0. Operation, Test f, Skip if 0.TSTFSZ f {,a} = Skip if f = 0. Operation, Test f, Skip if 0.TSTFSZ f {,a} = Skip if f = 0. Operation, Test f, Skip if 0.TSTFSZ f {,a} = Skip if f = 0. Status Affected, Test f, Skip if",
    "HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = 34h\n0.TSTFSZ f {,a} = None. Status Affected, Test f, Skip if 0.TSTFSZ f {,a} = None. Status Affected, Test f, Skip if 0.TSTFSZ f {,a} = None. Status Affected, Test f, Skip if 0.TSTFSZ f {,a} = None. Encoding, Test f, Skip if 0.TSTFSZ f {,a} = 0110. Encoding, Test f, Skip if 0.TSTFSZ f {,a} = 011a. Encoding, Test f, Skip if 0.TSTFSZ f {,a} = ffff. Encoding, Test f, Skip if 0.TSTFSZ f {,a} = ffff. Description, Test f, Skip if 0.TSTFSZ f {,a} = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is '",
    "HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = 34h\n1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Test f, Skip if 0.TSTFSZ f {,a} = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Test f, Skip if 0.TSTFSZ f {,a} = If 'f' = 0 ,",
    "HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = 34h\nthe next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Test f, Skip if 0.TSTFSZ f {,a} = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (",
    "HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = 34h\n5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Test f, Skip if 0.TSTFSZ f {,a} = 1. Words, Test f, Skip if 0.TSTFSZ f {,a} = 1. Words, Test f, Skip if 0.TSTFSZ f {,a} = 1. Words, Test f, Skip if 0.TSTFSZ f {,a} = 1. Cycles, Test f, Skip if 0.TSTFSZ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Test f, Skip if 0.TSTFSZ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Test f, Skip if 0.TSTFSZ f {,a} = 1 (2) Note: Three cycles if skip and",
    "HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = 34h\nfollowed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Test f, Skip if 0.TSTFSZ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   TSTFSZ   CNT, 1\nNZERO:\nZERO:",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf CNT = 0 ; PC = address (ZERO) If CNT \u2260 0 ; PC = address (NZERO)",
    "After Instruction\nSyntax, Exclusive OR Literal with W = XORLW k. Syntax, Exclusive OR Literal with W = XORLW k. Syntax, Exclusive OR Literal with W = XORLW k. Operands, Exclusive OR Literal with W = 0 \u2264 k \u2264 255. Operands, Exclusive OR Literal with W = 0 \u2264 k \u2264 255. Operands, Exclusive OR Literal with W = 0 \u2264 k \u2264 255. Operation, Exclusive OR Literal with W = (W) .XOR. k \u2192 W. Operation, Exclusive OR Literal with W = (W) .XOR. k \u2192 W. Operation, Exclusive OR Literal with W = (W) .XOR. k \u2192 W. Status Affected, Exclusive OR Literal with W = N, Z. Status Affected, Exclusive OR Literal with W = N, Z. Status Affected, Exclusive OR Literal with W = N, Z. Encoding, Exclusive OR Literal with W = 0000. Encoding, Exclusive OR Literal with W = kkkk. Encoding, Exclusive OR Literal with W = kkkk. Description, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description, Exclusive OR",
    "After Instruction\nLiteral with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Words, Exclusive OR Literal with W = 1. Words, Exclusive OR Literal with W = 1. Words, Exclusive OR Literal with W = 1. Cycles, Exclusive OR Literal with W = 1. Cycles, Exclusive OR Literal with W = 1. Cycles, Exclusive OR Literal with W = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample: XORLW 0AFh",
    "Before Instruction\nW = B5h",
    "After Instruction\nW = 1Ah\nOperands, Exclusive OR Wwith f.XORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Exclusive OR Wwith f.XORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Exclusive OR Wwith f.XORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Exclusive OR Wwith f.XORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Exclusive OR Wwith f.XORWF f {,d {,a}} = (W) .XOR. (f) \u2192 dest. Operation, Exclusive OR Wwith f.XORWF f {,d {,a}} = (W) .XOR. (f) \u2192 dest. Operation, Exclusive OR Wwith",
    "After Instruction\nf.XORWF f {,d {,a}} = (W) .XOR. (f) \u2192 dest. Operation, Exclusive OR Wwith f.XORWF f {,d {,a}} = (W) .XOR. (f) \u2192 dest. Status Affected, Exclusive OR Wwith f.XORWF f {,d {,a}} = N, Z. Status Affected, Exclusive OR Wwith f.XORWF f {,d {,a}} = N, Z. Status Affected, Exclusive OR Wwith f.XORWF f {,d {,a}} = N, Z. Status Affected, Exclusive OR Wwith f.XORWF f {,d {,a}} = N, Z. Encoding, Exclusive OR Wwith f.XORWF f {,d {,a}} = 0001. Encoding, Exclusive OR Wwith f.XORWF f {,d {,a}} = 10da. Encoding, Exclusive OR Wwith f.XORWF f {,d {,a}} = ffff. Encoding, Exclusive OR",
    "After Instruction\nWwith f.XORWF f {,d {,a}} = ffff. Description, Exclusive OR Wwith f.XORWF f {,d {,a}} = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Exclusive OR Wwith f.XORWF f {,d {,a}} = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f'",
    "After Instruction\n(default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Exclusive OR Wwith f.XORWF f {,d {,a}} = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for",
    "After Instruction\ndetails.. Description, Exclusive OR Wwith f.XORWF f {,d {,a}} = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1. Words, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1. Words, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1. Words, Exclusive OR Wwith f.XORWF f {,d",
    "After Instruction\n{,a}} = 1. Cycles, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1. Cycles, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1. Cycles, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1. Cycles, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: XORWF REG, 1, 0",
    "Before Instruction\nREG = AFh\nW = B5h",
    "After Instruction\nREG = 1Ah\nW = B5h",
    "45.2 Extended Instruction Set\nIn addition to the standard instruction set, PIC18 devices also provide an optional extension to the core CPU functionality. The added features include additional instructions that augment Indirect and Indexed Addressing operations and the implementation of Indexed Literal Offset Addressing mode for many of the standard PIC18 instructions.\nThe additional features of the extended instruction set are disabled by default. To enable them, users must set the XINST Configuration bit.\nThe instructions in the extended set can all be classified as literal operations, which either manipulate the File Select registers or use them for Indexed Addressing. Two of the standard instructions, ADDFSR and SUBFSR , each have an additional special instantiation for using FSR2 as extended instructions. These versions ( ADDULNK and SUBULNK ) allow for automatic return after execution.\nThe extended instructions are specifically implemented to optimize re-entrant program code (that is, code that is recursive or that uses a software stack) written in high-level languages, particularly C. Among other things, they allow users working in high-level languages to perform certain operations on data structures more efficiently. These include:",
    "45.2 Extended Instruction Set\n\u00b7 Dynamic allocation and deallocation of software stack space when entering and leaving subroutines\n\u00b7 Function pointer invocation\n\u00b7 Software Stack Pointer manipulation\n\u00b7 Manipulation of variables located in a software stack\nA summary of the instructions in the extended instruction set is provided in Extended Instruction Syntax. Detailed descriptions are provided in Extended Instruction Set. The opcode field descriptions in Table 45-1 apply to both the standard and extended PIC18 instruction sets.",
    "Important:\n\u00b7 The instruction set extension and the Indexed Literal Offset Addressing mode were designed for optimizing applications written in C; the user may likely never use these instructions directly in assembler. The syntax for these commands is provided as a reference for users who may be reviewing code that has been generated by a compiler.\n\u00b7 Enabling the PIC18 instruction set extension may cause legacy applications to behave erratically or fail entirely. Refer to Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.",
    "45.2.1 Extended Instruction Syntax\nMost of the extended instructions use indexed arguments, using one of the File Select registers and some offset to specify a source or destination register. When an argument for an instruction serves as part of Indexed Addressing, it is enclosed in square brackets (' [ ] '). This is done to indicate that the argument is used as an index or offset. MPASM  Assembler will flag an error if it determines that \u2122 an index or offset value is not bracketed.\nWhen the extended instruction set is enabled, brackets are also used to indicate index arguments in byte-oriented and bit-oriented instructions. This is in addition to other changes in their syntax. For more details, see Extended Instruction Syntax with Standard PIC18 Commands.",
    "Table 45-3. Extensions to the PIC18 Instruction Set\nStatus Affected, 1, 3 = None. Status Affected, 2, 3, 4 = None. Status Affected,  = None. Status Affected, 2, 3 = . Status Affected,  = . Status Affected,  = None. Status Affected, 2, 3 = . Status Affected, 3 = None None. Status Affected, 1, 3 = NOP .. Status Affected, the = instruction retrieves 4k addressing space.. LSb, 1, 3 = kkkk z z z z. LSb, 2, 3, 4 = s s s s f d f d f d f d. LSb,  = 0010. LSb, 2, 3 = z s z s f d f d. LSb,  = f d f d f d f d. LSb,",
    "Table 45-3. Extensions to the PIC18 Instruction Set\n= z s z s z s z s. LSb, 2, 3 = z d z d z d z d. LSb, 3 = kkkk. LSb, 1, 3 = kkkk. LSb, the = is executed as first word of the instructions to lower. Instruction Word 11kk, 1, 3 = 0z s z s z s. Instruction Word 11kk, 2, 3, 4 = f d f d f d f d. Instruction Word 11kk,  = 0000. Instruction Word 11kk, 2, 3 = z s z s z s z s. Instruction Word 11kk,  = f d f d f d f d. Instruction Word 11kk,",
    "Table 45-3. Extensions to the PIC18 Instruction Set\n= 1z s z s z s. Instruction Word 11kk, 2, 3 = xz d z d z d. Instruction Word 11kk, 3 = kkkk. Instruction Word 11kk, 1, 3 = 11kk. Instruction Word 11kk, the = The extra cycle NOP , unless the instruction. of these. 16-Bit 1000, 1, 3 = 1011. 16-Bit 1000, 2, 3, 4 = f d f d f d f d. 16-Bit 1000,  = 0000. 16-Bit 1000, 2, 3 = xxxz s. 16-Bit 1000,  = f d f d f d f d. 16-Bit 1000,  = 1011. 16-Bit 1000, 2, 3 = xxxx. 16-Bit 1000, 3 = 1010. 16-Bit 1000, 1, 3 = 1001. 16-Bit 1000, the = additional cycle. be decoded as have a valid to limit the range. MSb, 1, 3 = 1110 1110. MSb, 2, 3, 4 = 1111. MSb,",
    "Table 45-3. Extensions to the PIC18 Instruction Set\n= 0000. MSb, 2, 3 = 1111. MSb,  = 1111. MSb,  = 1110. MSb, 2, 3 = 1111. MSb, 3 = 1110. MSb, 1, 3 = 1110. MSb, the = instruction requires instructions will memory locations forced to 0b00. Cycles 2, 1, 3 = Cycles 2. Cycles 2, 2, 3, 4 = 2. Cycles 2,  = 2. Cycles 2, 2, 3 = 3. Cycles 2,  = 3. Cycles 2,  = 2. Cycles 2, 2, 3 = 2. Cycles 2, 3 = 1. Cycles 2, 1, 3 = 2. Cycles 2, the = true, the of these program selection. Description Add literal to FSR2 and return, 1, 3 = Description Add literal to FSR2 and return. Description Add literal to FSR2 and return, 2, 3, 4 = Move z s (12-bit source) to f d (12-bit destination). Description Add literal to FSR2 and return,",
    "Table 45-3. Extensions to the PIC18 Instruction Set\n= Move z s (12-bit source) to f d (12-bit destination). Description Add literal to FSR2 and return, 2, 3 = Move z s (14-bit source) to f (14-bit destination). Description Add literal to FSR2 and return,  = d. Description Add literal to FSR2 and return,  = Move z s (source) d (destination). Description Add literal to FSR2 and return, 2, 3 = to z. Description Add literal to FSR2 and return, 3 = Store literal at FSR2, decrement FSR2. Description Add literal to FSR2 and return, 1, 3 = Subtract literal from FSR2 and return. Description Add literal to FSR2 and return, the = modified or a conditional test is multi-word instructions. The extra words these 16 bits. This ensures that all extended instruction set is enabled. full memory range. 2 MSbs of bank. k, 1, 3 = k. k, 2, 3, 4 = z s , f d. k,",
    "Table 45-3. Extensions to the PIC18 Instruction Set\n= z s , f d. k, 2, 3 = z s , f d. k,  = z s , f d. k,  = z s , z d. k, 2, 3 = z s , z d. k, 3 = k. k, 1, 3 = k. k, the = Counter (PC) is are embedded in when not cover the. Mnemonic, Operands rota e hisp g 90, 1, 3 = ADDULNK. Mnemonic, Operands rota e hisp g 90, 2, 3, 4 = MOVSF. Mnemonic, Operands rota e hisp g 90,  = MOVSF. Mnemonic, Operands rota e hisp g 90, 2, 3 = MOVSFL. Mnemonic, Operands rota e hisp g 90,  = MOVSFL. Mnemonic, Operands rota e hisp g 90,",
    "Table 45-3. Extensions to the PIC18 Instruction Set\n= MOVSS. Mnemonic, Operands rota e hisp g 90, 2, 3 = MOVSS. Mnemonic, Operands rota e hisp g 90, 3 = PUSHL. Mnemonic, Operands rota e hisp g 90, 1, 3 = SUBULNK. Mnemonic, Operands rota e hisp g 90, the = Notes: rota e hisp g 90 1. If Program 2. Some instructions information 3. Only available 4. f and f do",
    "45.2.2 Extended Instruction Set\nImportant: All PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction format then becomes:\n{label} instruction argument(s)",
    "45.2.2 Extended Instruction Set\nOperands, Add Literal to FSR2 and Return.ADDULNK k = 0 \u2264 k \u2264 63. Operands, Add Literal to FSR2 and Return.ADDULNK k = 0 \u2264 k \u2264 63. Operands, Add Literal to FSR2 and Return.ADDULNK k = 0 \u2264 k \u2264 63. Operands, Add Literal to FSR2 and Return.ADDULNK k = 0 \u2264 k \u2264 63. Operation, Add Literal to FSR2 and Return.ADDULNK k = (FSR2) + k \u2192 FSR2 (TOS) \u2192 PC. Operation, Add Literal to FSR2 and Return.ADDULNK k = (FSR2) + k \u2192 FSR2 (TOS) \u2192 PC. Operation, Add Literal to FSR2 and Return.ADDULNK k = (FSR2) + k \u2192 FSR2 (TOS) \u2192 PC. Operation, Add Literal to FSR2 and Return.ADDULNK k = (FSR2) + k \u2192 FSR2 (TOS) \u2192 PC. Status Affected, Add Literal to FSR2 and Return.ADDULNK k = None. Status",
    "45.2.2 Extended Instruction Set\nAffected, Add Literal to FSR2 and Return.ADDULNK k = None. Status Affected, Add Literal to FSR2 and Return.ADDULNK k = None. Status Affected, Add Literal to FSR2 and Return.ADDULNK k = None. Encoding, Add Literal to FSR2 and Return.ADDULNK k = 1110. Encoding, Add Literal to FSR2 and Return.ADDULNK k = 1000. Encoding, Add Literal to FSR2 and Return.ADDULNK k = 11kk. Encoding, Add Literal to FSR2 and Return.ADDULNK k = kkkk. Description, Add Literal to FSR2 and Return.ADDULNK k = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Description, Add Literal to FSR2 and",
    "45.2.2 Extended Instruction Set\nReturn.ADDULNK k = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Description, Add Literal to FSR2 and Return.ADDULNK k = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Description, Add Literal to FSR2 and Return.ADDULNK k = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes",
    "45.2.2 Extended Instruction Set\ntwo cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Words, Add Literal to FSR2 and Return.ADDULNK k = 1. Words, Add Literal to FSR2 and Return.ADDULNK k = 1. Words, Add Literal to FSR2 and Return.ADDULNK k = 1. Words, Add Literal to FSR2 and Return.ADDULNK k = 1. Cycles, Add Literal to FSR2 and Return.ADDULNK k = 2. Cycles, Add Literal to FSR2 and Return.ADDULNK k = 2. Cycles, Add Literal to FSR2 and Return.ADDULNK k = 2. Cycles, Add Literal to FSR2 and Return.ADDULNK k = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: ADDULNK 23h",
    "Before Instruction\nFSR2 = 03FFh\nPC = 0100h",
    "After Instruction\nFSR2 = 0422h\nPC = (TOS)",
    "After Instruction\nOperands, Move Indexed to f.MOVSF [z s ], f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands, Move Indexed to f. = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands, Move Indexed to f. = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands, Move Indexed to f. = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operation, Move Indexed to f.MOVSF [z s ], f = ((FSR2) + z s ) \u2192 f d. Operation, Move Indexed to f. = ((FSR2) + z s ) \u2192 f d. Operation, Move Indexed to f. = ((FSR2) + z s ) \u2192 f d. Operation, Move Indexed to f. = ((FSR2) + z s ) \u2192 f d. Status Affected, Move Indexed to f.MOVSF [z s ], f = None. Status Affected, Move Indexed to f. = None. Status Affected, Move Indexed to f. = None. Status Affected, Move Indexed to f. =",
    "After Instruction\nNone. Encoding, Move Indexed to f.MOVSF [z s ], f = 1110. Encoding, Move Indexed to f. = 1011. Encoding, Move Indexed to f. = 0z s z s z s. Encoding, Move Indexed to f. = z s z s z s z s. , Move Indexed to f.MOVSF [z s ], f = 1111. , Move Indexed to f. = f d f d f d f d. , Move Indexed to f. = f d f d f d f d. , Move Indexed to f. = f d f d f d f d",
    "...........continued\nDescription, Move Indexed to f.MOVSF [z s ], f = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096-byte data space ( 000h to FFFh ). Note: MOVSF has curtailed the destination range to the lower 4 Kbyte space in memory (Banks 1 through 15). For everything else, use MOVSFL .. Words, Move Indexed to f.MOVSF [z s ], f = 2. Cycles, Move Indexed to f.MOVSF [z s ], f = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Determine source address. Decode, 2 = Determine source address. Decode, 3 = Read source register. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f d '\nExample: MOVSF [05h], REG2",
    "Before Instruction\nFSR2 = 80h Contents of 85h = 33h REG2 = 11h Address of REG2 = 100h",
    "After Instruction\nFSR2 = 80h\nContents of 85h = 33h\nREG2 = 33h\nAddress of REG2 = 100h",
    "After Instruction\nOperands, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 16383. Operands, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 16383. Operands, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 16383. Operands, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 16383. Operation, Move Indexed to f (Long Range).MOVSFL [z s ], f d = ((FSR2) + z s ) \u2192 f d. Operation, Move Indexed to f (Long Range).MOVSFL [z s ], f d = ((FSR2) + z s ) \u2192 f d. Operation, Move Indexed to f (Long Range).MOVSFL [z s ], f d = ((FSR2) + z s ) \u2192 f",
    "After Instruction\nd. Operation, Move Indexed to f (Long Range).MOVSFL [z s ], f d = ((FSR2) + z s ) \u2192 f d. Status Affected, Move Indexed to f (Long Range).MOVSFL [z s ], f d = None. Status Affected, Move Indexed to f (Long Range).MOVSFL [z s ], f d = None. Status Affected, Move Indexed to f (Long Range).MOVSFL [z s ], f d = None. Status Affected, Move Indexed to f (Long Range).MOVSFL [z s ], f d = None. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0000. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0000. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0110. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0010. Encoding, Move Indexed to f (Long Range).MOVSFL [z",
    "After Instruction\ns ], f d = 1111. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = xxxz s. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = z s z s z s z s. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = z s z s f d f d. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 1111. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = f d f d f d f d. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = f d f d f d f d. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = f d f d f d f d. Description, Move Indexed to f (Long Range).MOVSFL [z s ], f d = The contents of the source register are moved to destination register 'f d '.",
    "After Instruction\nThe actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2 (14 bits). The address of the destination register is specified by the 14-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ). The MOVSFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h .. Description, Move Indexed to f (Long Range).MOVSFL [z s ], f d = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2 (14 bits). The address of the destination register is specified by the 14-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ). The MOVSFL instruction",
    "After Instruction\ncannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h .. Description, Move Indexed to f (Long Range).MOVSFL [z s ], f d = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2 (14 bits). The address of the destination register is specified by the 14-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ). The MOVSFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h .. Description, Move Indexed to f (Long Range).MOVSFL [z s ], f d = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by",
    "After Instruction\nadding the 7-bit literal offset 'z s ' in the first word to the value of FSR2 (14 bits). The address of the destination register is specified by the 14-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ). The MOVSFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h .. Words, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3. Words, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3. Words, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3. Words, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3. Cycles, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3. Cycles, Move Indexed to f (Long Range).MOVSFL [z",
    "After Instruction\ns ], f d = 3. Cycles, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3. Cycles, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation. Decode, 1 = Read source register. Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f d '\nExample: MOVSFL [05h], REG2",
    "Before Instruction\nFSR2 = 2080h Contents of 2085h = 33h REG2 = 11h Address of REG2 = 2000h",
    "After Instruction\nFSR2 = 2080h\nContents of 2085h = 33h\nREG2 = 33h\nAddress of REG2 = 2000h",
    "After Instruction\nOperands, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operation, Move Indexed to Indexed.MOVSS [z s ], [z d ] = ((FSR2) + z s ) \u2192 ((FSR2) + z d ). Operation, Move Indexed to Indexed.MOVSS [z s ], [z d ] = ((FSR2) + z s ) \u2192 ((FSR2) + z d ). Operation, Move Indexed to Indexed.MOVSS [z s ], [z d ] = ((FSR2) + z s ) \u2192",
    "After Instruction\n((FSR2) + z d ). Operation, Move Indexed to Indexed.MOVSS [z s ], [z d ] = ((FSR2) + z s ) \u2192 ((FSR2) + z d ). Status Affected, Move Indexed to Indexed.MOVSS [z s ], [z d ] = None. Status Affected, Move Indexed to Indexed.MOVSS [z s ], [z d ] = None. Status Affected, Move Indexed to Indexed.MOVSS [z s ], [z d ] = None. Status Affected, Move Indexed to Indexed.MOVSS [z s ], [z d ] = None. Encoding, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 1110. Encoding, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 1011. Encoding, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 1z s z s z s. Encoding, Move Indexed to Indexed.MOVSS [z s ], [z d ] = z s z s z s z s. , Move Indexed to",
    "After Instruction\nIndexed.MOVSS [z s ], [z d ] = 1111. , Move Indexed to Indexed.MOVSS [z s ], [z d ] = xxxx. , Move Indexed to Indexed.MOVSS [z s ], [z d ] = xz d z d z d. , Move Indexed to Indexed.MOVSS [z s ], [z d ] = z d z d z d z d. Description, Move Indexed to Indexed.MOVSS [z s ], [z d ] = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ' respectively to the value of FSR2. Both registers can be located anywhere in the 16 Kbyte data memory space ( 0000h to 3FFFh ). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h . If the resultant destination address points to an indirect addressing register, the instruction will execute as a NOP",
    "After Instruction\n.. Description, Move Indexed to Indexed.MOVSS [z s ], [z d ] = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ' respectively to the value of FSR2. Both registers can be located anywhere in the 16 Kbyte data memory space ( 0000h to 3FFFh ). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h . If the resultant destination address points to an indirect addressing register, the instruction will execute as a NOP .. Description, Move Indexed to Indexed.MOVSS [z s ], [z d ] = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ' respectively to the value of FSR2. Both registers can be located anywhere in the 16 Kbyte data memory space ( 0000h to",
    "After Instruction\n3FFFh ). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h . If the resultant destination address points to an indirect addressing register, the instruction will execute as a NOP .. Description, Move Indexed to Indexed.MOVSS [z s ], [z d ] = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ' respectively to the value of FSR2. Both registers can be located anywhere in the 16 Kbyte data memory space ( 0000h to 3FFFh ). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h . If the resultant destination address points to an indirect addressing register, the instruction will execute as a NOP .. Words, Move Indexed to Indexed.MOVSS [z s ], [z d ] =",
    "After Instruction\n2. Words, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2. Words, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2. Words, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2. Cycles, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2. Cycles, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2. Cycles, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2. Cycles, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Determine source address. Decode, 2 = Determine source address. Decode, 3 = Read source register. Decode, 1 = Determine destination address. Decode, 2 = Determine destination address. Decode, 3 = Write to destination register\nExample: MOVSS [05h], [06h]\nBefore Instruction FSR2 = 80h\nContents of 85h = 33h Contents of 86h = 11h",
    "After Instruction\nFSR2 = 80h\nContents of 85h = 33h\nContents of 86h = 33h",
    "After Instruction\nOperands, Store Literal at FSR2, Decrement FSR2.PUSHL k = 0 \u2264 k \u2264 255. Operands, Store Literal at FSR2, Decrement FSR2.PUSHL k = 0 \u2264 k \u2264 255. Operands, Store Literal at FSR2, Decrement FSR2.PUSHL k = 0 \u2264 k \u2264 255. Operands, Store Literal at FSR2, Decrement FSR2.PUSHL k = 0 \u2264 k \u2264 255. Operation, Store Literal at FSR2, Decrement FSR2.PUSHL k = k \u2192 FSR2 (FSR2) - 1 \u2192 FSR2. Operation, Store Literal at FSR2, Decrement FSR2.PUSHL k = k \u2192 FSR2 (FSR2) - 1 \u2192 FSR2. Operation, Store Literal at FSR2, Decrement FSR2.PUSHL k = k \u2192 FSR2 (FSR2) - 1 \u2192 FSR2. Operation, Store Literal at FSR2, Decrement FSR2.PUSHL k = k \u2192 FSR2 (FSR2) - 1 \u2192",
    "After Instruction\nFSR2. Status Affected, Store Literal at FSR2, Decrement FSR2.PUSHL k = None. Status Affected, Store Literal at FSR2, Decrement FSR2.PUSHL k = None. Status Affected, Store Literal at FSR2, Decrement FSR2.PUSHL k = None. Status Affected, Store Literal at FSR2, Decrement FSR2.PUSHL k = None. Encoding, Store Literal at FSR2, Decrement FSR2.PUSHL k = 1111. Encoding, Store Literal at FSR2, Decrement FSR2.PUSHL k = 1010. Encoding, Store Literal at FSR2, Decrement FSR2.PUSHL k = kkkk. Encoding, Store Literal at FSR2, Decrement FSR2.PUSHL k = kkkk. Description, Store Literal at FSR2, Decrement FSR2.PUSHL k = The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation. This instruction allows users to push values onto a software",
    "After Instruction\nstack.. Description, Store Literal at FSR2, Decrement FSR2.PUSHL k = The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation. This instruction allows users to push values onto a software stack.. Description, Store Literal at FSR2, Decrement FSR2.PUSHL k = The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation. This instruction allows users to push values onto a software stack.. Description, Store Literal at FSR2, Decrement FSR2.PUSHL k = The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation. This instruction allows users to push values onto a software stack.. Words, Store Literal at FSR2, Decrement FSR2.PUSHL k = 1. Words, Store Literal at FSR2, Decrement FSR2.PUSHL k = 1. Words, Store Literal at",
    "After Instruction\nFSR2, Decrement FSR2.PUSHL k = 1. Words, Store Literal at FSR2, Decrement FSR2.PUSHL k = 1. Cycles, Store Literal at FSR2, Decrement FSR2.PUSHL k = 1. Cycles, Store Literal at FSR2, Decrement FSR2.PUSHL k = 1. Cycles, Store Literal at FSR2, Decrement FSR2.PUSHL k = 1. Cycles, Store Literal at FSR2, Decrement FSR2.PUSHL k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: PUSHL 08h\nBefore Instruction FSR2 = 01ECh Contents of 01ECh = 00h",
    "After Instruction\nFSR2 = 01EBh\nContents of 01ECh = 08h",
    "After Instruction\nOperands, Subtract Literal from FSR2 and Return.SUBULNK k = 0 \u2264 k \u2264 63. Operands, Subtract Literal from FSR2 and Return.SUBULNK k = 0 \u2264 k \u2264 63. Operands, Subtract Literal from FSR2 and Return.SUBULNK k = 0 \u2264 k \u2264 63. Operands, Subtract Literal from FSR2 and Return.SUBULNK k = 0 \u2264 k \u2264 63. Operation, Subtract Literal from FSR2 and Return.SUBULNK k = (FSR2) - k \u2192 FSR2 (TOS) \u2192 PC. Operation, Subtract Literal from FSR2 and Return.SUBULNK k = (FSR2) - k \u2192 FSR2 (TOS) \u2192 PC. Operation, Subtract Literal from FSR2 and Return.SUBULNK k = (FSR2) - k \u2192 FSR2 (TOS) \u2192 PC. Operation, Subtract Literal from FSR2 and Return.SUBULNK k = (FSR2) - k \u2192 FSR2 (TOS) \u2192 PC. Status Affected, Subtract Literal from",
    "After Instruction\nFSR2 and Return.SUBULNK k = None. Status Affected, Subtract Literal from FSR2 and Return.SUBULNK k = None. Status Affected, Subtract Literal from FSR2 and Return.SUBULNK k = None. Status Affected, Subtract Literal from FSR2 and Return.SUBULNK k = None. Encoding, Subtract Literal from FSR2 and Return.SUBULNK k = 1110. Encoding, Subtract Literal from FSR2 and Return.SUBULNK k = 1001. Encoding, Subtract Literal from FSR2 and Return.SUBULNK k = 11kk. Encoding, Subtract Literal from FSR2 and Return.SUBULNK k = kkkk. Description, Subtract Literal from FSR2 and Return.SUBULNK k = The 6-bit literal 'k' is subtracted from the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f n = 3 (binary '",
    "After Instruction\n11 '); it operates only on FSR2.. Description, Subtract Literal from FSR2 and Return.SUBULNK k = The 6-bit literal 'k' is subtracted from the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Description, Subtract Literal from FSR2 and Return.SUBULNK k = The 6-bit literal 'k' is subtracted from the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Description, Subtract Literal from FSR2 and Return.SUBULNK k = The 6-bit literal 'k' is subtracted",
    "After Instruction\nfrom the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Words, Subtract Literal from FSR2 and Return.SUBULNK k = 1. Words, Subtract Literal from FSR2 and Return.SUBULNK k = 1. Words, Subtract Literal from FSR2 and Return.SUBULNK k = 1. Words, Subtract Literal from FSR2 and Return.SUBULNK k = 1. Cycles, Subtract Literal from FSR2 and Return.SUBULNK k = 2. Cycles, Subtract Literal from FSR2 and Return.SUBULNK k = 2. Cycles, Subtract Literal from FSR2 and Return.SUBULNK k = 2. Cycles, Subtract Literal from FSR2 and Return.SUBULNK k = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: SUBULNK 23h",
    "Before Instruction\nFSR2 =\n03FFh\nPC = 0100h\nAfter Instruction FSR2 = 03DCh PC = (TOS)",
    "45.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode\nImportant: Enabling the PIC18 instruction set extension may cause legacy applications to behave erratically or fail entirely.\nIn addition to the new commands in the extended set, enabling the extended instruction set also enables Indexed Literal Offset Addressing mode (see the 'Indexed Addressing with Literal Offset' section in the 'Memory Organization' chapter). This has a significant impact on the way many commands of the standard PIC18 instruction set are interpreted.\nWhen the extended set is disabled, addresses embedded in opcodes are treated as literal memory locations, either as a location in the Access Bank ('a' = 0 ) or in a GPR bank designated by the BSR ('a' = 1 ). When the extended instruction set is enabled and 'a' = 0 , however, a file register argument of 5Fh or less is interpreted as an offset from the pointer value in FSR2 and not as a literal address. For practical purposes, this means that all instructions using the Access RAM bit as an argument - that is, all byte-oriented and bit-oriented instructions, or almost half of the core PIC18 instructions - may behave differently when the extended instruction set is enabled.",
    "45.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode\nWhen the content of FSR2 is 00h , the boundaries of the Access RAM are essentially remapped to their original values. This may be useful in creating backward compatible code. If this technique is used, it may be necessary to save the value of FSR2 and restore it when moving back and forth between C and assembly routines to preserve the Stack Pointer. Users must also keep in mind the syntax requirements of the extended instruction set (see Extended Instruction Syntax with Standard PIC18 Commands).\nAlthough the Indexed Literal Offset Addressing mode can be very useful for dynamic stack and pointer manipulation, it can also be very annoying if a simple arithmetic operation is carried out on the wrong register. Users who are accustomed to the PIC18 programming must keep in mind that, when the extended instruction set is enabled, register addresses of 5Fh or less are used for Indexed Literal Offset Addressing.\nRepresentative examples of typical byte-oriented and bit-oriented instructions in the Indexed Literal Offset Addressing mode are provided in the Considerations when Enabling the Extended Instruction Set section to show how execution is affected. The operand conditions shown in the examples are applicable to all instructions of these types.",
    "Related Links\n9.6.\u00a0 Data Memory and the Extended Instruction Set",
    "45.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nWhen the extended instruction set is enabled, the file register argument, 'f', in the standard byteoriented and bit-oriented commands is replaced with the literal offset value, 'k'. As already noted, this occurs only when 'f' is less than or equal to 5Fh . When an offset value is used, it must be indicated by square brackets (' [ ] '). As with the extended instructions, the use of brackets indicates to the compiler that the value is to be interpreted as an index or an offset. Omitting the brackets or using a value greater than 5Fh within brackets will generate an error in the MPASM Assembler.\nIf the index argument is properly bracketed for Indexed Literal Offset Addressing, the Access RAM argument is never specified; it will automatically be assumed to be ' 0 '. This is in contrast to standard operation (extended instruction set disabled) when 'a' is set on the basis of the target address. Declaring the Access RAM bit in this mode will also generate an error in the MPASM Assembler.\nThe destination argument, 'd', functions as before.",
    "45.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nIn the latest versions of the MPASM Assembler, language support for the extended instruction set must be explicitly invoked. This is done with either the command-line option /y or the PE directive in the source listing.",
    "Related Links\n9.6.\u00a0 Data Memory and the Extended Instruction Set",
    "45.2.4 Considerations when Enabling the Extended Instruction Set\nIt is important to note that the extensions to the instruction set may not be beneficial to all users. In particular, users who are not writing code that uses a software stack may not benefit from using the extensions to the instruction set.\nAdditionally, the Indexed Literal Offset Addressing mode may create issues with legacy applications written to the PIC18 assembler. This is because instructions in the legacy code may attempt to address registers in the Access Bank below 5Fh . Since these addresses are interpreted as literal offsets to FSR2 when the instruction set extension is enabled, the application may read or write to the wrong data addresses.\nWhen porting an application to a PIC18 device supporting extensions to the instruction set, it is very important to consider the type of code. A large, re-entrant application that is written in 'C' and benefits from efficient compilation will do well when using the instruction set extensions. Legacy applications that heavily use the Access Bank will most likely not benefit from using the extended instruction set.",
    "45.2.4 Considerations when Enabling the Extended Instruction Set\nOperands, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = 0 \u2264 k \u2264 95 d \u2208 [0, 1]. Operands, Add Wto Indexed (Indexed Literal Offset Mode). = 0 \u2264 k \u2264 95 d \u2208 [0, 1]. Operands, Add Wto Indexed (Indexed Literal Offset Mode). = 0 \u2264 k \u2264 95 d \u2208 [0, 1]. Operands, Add Wto Indexed (Indexed Literal Offset Mode). = 0 \u2264 k \u2264 95 d \u2208 [0, 1]. Operation, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = (W) + ((FSR2) + k) \u2192 dest. Operation, Add Wto Indexed (Indexed Literal Offset Mode). = (W) + ((FSR2) + k) \u2192 dest. Operation, Add Wto Indexed (Indexed Literal Offset Mode). = (W) + ((FSR2) + k) \u2192 dest. Operation, Add Wto Indexed (Indexed Literal Offset Mode). = (W) +",
    "45.2.4 Considerations when Enabling the Extended Instruction Set\n((FSR2) + k) \u2192 dest. Status Affected, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = N, OV, C, DC, Z. Status Affected, Add Wto Indexed (Indexed Literal Offset Mode). = N, OV, C, DC, Z. Status Affected, Add Wto Indexed (Indexed Literal Offset Mode). = N, OV, C, DC, Z. Status Affected, Add Wto Indexed (Indexed Literal Offset Mode). = N, OV, C, DC, Z. Encoding, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = 0010. Encoding, Add Wto Indexed (Indexed Literal Offset Mode). = 01d0. Encoding, Add Wto Indexed (Indexed Literal Offset Mode). = kkkk. Encoding, Add Wto Indexed (Indexed Literal Offset Mode). = kkkk. Description, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = The contents of Ware added to the contents of the register indicated",
    "45.2.4 Considerations when Enabling the Extended Instruction Set\nby FSR2, offset by the value 'k'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default).. Description, Add Wto Indexed (Indexed Literal Offset Mode). = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value 'k'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default).. Description, Add Wto Indexed (Indexed Literal Offset Mode). = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value 'k'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default).. Description, Add Wto Indexed (Indexed Literal Offset Mode). = The contents of Ware added to the contents of the register indicated by",
    "45.2.4 Considerations when Enabling the Extended Instruction Set\nFSR2, offset by the value 'k'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default).. Words, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = 1. Words, Add Wto Indexed (Indexed Literal Offset Mode). = 1. Words, Add Wto Indexed (Indexed Literal Offset Mode). = 1. Words, Add Wto Indexed (Indexed Literal Offset Mode). = 1. Cycles, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = 1. Cycles, Add Wto Indexed (Indexed Literal Offset Mode). = 1. Cycles, Add Wto Indexed (Indexed Literal Offset Mode). = 1. Cycles, Add Wto Indexed (Indexed Literal Offset Mode). = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample:\nADDWF [OFST], 0",
    "Before Instruction\nW = 17h OFST = 2Ch FSR2 = 0A00h Contents of 0A2Ch = 20h",
    "After Instruction\nW = 37h\nContents of 0A2Ch = 20h",
    "After Instruction\nOperands, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 0 \u2264 k \u2264 95 0 \u2264 b \u2264 7. Operands, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 0 \u2264 k \u2264 95 0 \u2264 b \u2264 7. Operands, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 0 \u2264 k \u2264 95 0 \u2264 b \u2264 7. Operation, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1 \u2192 ((FSR2) + k)<b>. Operation, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1 \u2192 ((FSR2) + k)<b>. Operation, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1 \u2192 ((FSR2) + k)<b>. Status Affected, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = None. Status Affected, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = None. Status Affected, Bit Set Indexed",
    "After Instruction\n(Indexed Literal Offset Mode).BSF [k], b = None. Encoding, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1000. Encoding, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = kkkk. Encoding, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = kkkk. Description, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set. Description, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set. Description, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set. Words, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1. Words, Bit Set Indexed (Indexed Literal Offset",
    "After Instruction\nMode).BSF [k], b = 1. Words, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1. Cycles, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1. Cycles, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1. Cycles, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: BSF [FLAG_OFST], 7",
    "Before Instruction\n0A0Ah 55h\nFLAG_OFST = 0Ah FSR2 = 0A00h Contents of =",
    "After Instruction\nContents of 0A0Ah = D5h",
    "After Instruction\nOperands, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 0 \u2264 k \u2264 95. Operands, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 0 \u2264 k \u2264 95. Operands, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 0 \u2264 k \u2264 95. Operation, Set Indexed (Indexed Literal Offset Mode).SETF [k] = FFh \u2192 ((FSR2) + k). Operation, Set Indexed (Indexed Literal Offset Mode).SETF [k] = FFh \u2192 ((FSR2) + k). Operation, Set Indexed (Indexed Literal Offset Mode).SETF [k] = FFh \u2192 ((FSR2) + k). Status Affected, Set Indexed (Indexed Literal Offset Mode).SETF [k] = None. Status Affected, Set Indexed (Indexed Literal Offset Mode).SETF [k] = None. Status Affected, Set Indexed (Indexed Literal Offset Mode).SETF [k] = None. Encoding, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 0110. Encoding, Set Indexed (Indexed Literal Offset",
    "After Instruction\nMode).SETF [k] = kkkk. Encoding, Set Indexed (Indexed Literal Offset Mode).SETF [k] = kkkk. Description, Set Indexed (Indexed Literal Offset Mode).SETF [k] = The contents of the register indicated by FSR2, offset by the value 'k', are set to FFh. Description, Set Indexed (Indexed Literal Offset Mode).SETF [k] = The contents of the register indicated by FSR2, offset by the value 'k', are set to FFh. Description, Set Indexed (Indexed Literal Offset Mode).SETF [k] = The contents of the register indicated by FSR2, offset by the value 'k', are set to FFh. Words, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 1. Words, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 1. Words, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 1. Cycles, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 1. Cycles, Set Indexed (Indexed Literal Offset Mode).SETF [k] =",
    "After Instruction\n1. Cycles, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample:\nSETF [OFST]\nBefore Instruction OFST = 2Ch FSR2 = 0A00h Contents of 0A2Ch = 00h",
    "After Instruction\nContents of 0A2Ch = FFh",
    "45.2.5 Special Considerations with Microchip MPLAB  IDE Tools \u00ae\nThe latest versions of Microchip's software tools have been designed to fully support the extended instruction set on the PIC18 devices. This includes the MPLAB XC8 C compiler, MPASM Assembler and MPLAB X Integrated Development Environment (IDE).\nWhen selecting a target device for software development, MPLAB X IDE will automatically set default Configuration bits for that device. The default setting for the XINST Configuration bit is ' 0 ', disabling the extended instruction set and Indexed Literal Offset Addressing mode. For proper execution of applications developed to take advantage of the extended instruction set, XINST must be set during programming.\nTo develop software for the extended instruction set, the user must enable support for the instructions and the Indexed Addressing mode in their language tool(s). Depending on the environment being used, this may be done in several ways:\n\u00b7 A menu option, or dialog box within the environment, that allows the user to configure the language tool and its settings for the project\n\u00b7 A command-line option\n\u00b7 A directive in the source code",
    "45.2.5 Special Considerations with Microchip MPLAB  IDE Tools \u00ae\nThese options vary between different compilers, assemblers and development environments. Users are encouraged to review the documentation accompanying their development systems for the appropriate information.",
    "46. ICSP \u2122  - In-Circuit Serial Programming \u2122\nICSP programming allows customers to manufacture circuit boards with unprogrammed devices. Programming can be done after the assembly process, allowing the device to be programmed with the most recent firmware or a custom firmware. Five pins are needed for ICSP programming:\n\u00b7 ICSPCLK\n\u00b7 ICSPDAT\n\u00b7 MCLR/VPP\n\u00b7 VDD\n\u00b7 VSS\nIn Program/Verify mode, the program memory, User IDs and the Configuration bits are programmed through serial communications. The ICSPDAT pin is a bidirectional I/O used for transferring the serial data and the ICSPCLK pin is the clock input. For more information on ICSP, refer to the appropriate Family Programming Specification.",
    "46.1 High-Voltage Programming Entry Mode\nThe device is placed into High-Voltage Programming Entry mode by holding the ICSPCLK and ICSPDAT pins low, then raising the voltage on MCLR/VPP to VIH.",
    "46.2 Low-Voltage Programming Entry Mode\nThe Low-Voltage Programming Entry mode allows the PIC  Flash MCUs to be programmed using \u00ae VDD only, without high voltage. When the LVP Configuration bit is set to ' 1 ', the low-voltage ICSP programming entry is enabled. To disable the Low-Voltage ICSP mode, the LVP bit must be programmed to ' 0 '.\nEntry into the Low-Voltage Programming Entry mode requires the following steps:\n1. MCLR is brought to VIL.\n2. A 32-bit key sequence is presented on ICSPDAT, while clocking ICSPCLK.\nOnce the key sequence is complete, MCLR must be held at VIL for as long as Program/Verify mode is to be maintained.\nIf low-voltage programming is enabled (LVP = 1 ), the MCLR Reset function is automatically enabled and cannot be disabled. See the MCLR section for more information.\nThe LVP bit can only be reprogrammed to ' 0 ' by using the High-Voltage Programming mode.",
    "46.3 Common Programming Interfaces\nConnection to a target device is typically done through an ICSP header. A commonly found connector on development tools is the RJ-11 in the 6P6C (6-pin, 6-connector) configuration. See Figure 46-1.\nFigure 46-1. ICD RJ-11 Style Connector Interface\nPin Description\n1 = V PP /MCLR\n2 = V DD Target\n3 = V SS (ground)\n4 = ICSPDAT\n5 = ICSPCLK\n6 = No Connect\nAnother connector often found in use with the PICkit \u2122 programmers is a standard 6-pin header with 0.1 inch spacing. Refer to Figure 46-2.\nFor additional interface recommendations, refer to the specific device programming manual prior to PCB design.\nIt is recommended that isolation devices be used to separate the programming pins from other circuitry. The type of isolation is highly dependent on the specific application and may include devices such as resistors, diodes, or even jumpers. See Figure 46-3 for more information.\nFigure 46-2. PICkit \u2122  Programmer Style Connector Interface",
    "Pin Description (1) :\n1 = V PP /MCLR\n2 = V DD Target\n3 = V SS (ground)\n4 = ICSPDAT\n5 = ICSPCLK\n6 = No Connect",
    "Note:\n1. The 6-pin header (0.100\" spacing) accepts 0.025\" square pins.\n* Isolation devices (as required).\nFigure 46-3. Typical Connection for ICSP \u2122  Programming",
    "47. Register Summary\n0x00, Name = . 0x00, Bit Pos. = . 0x00, 7 = . 0x00, 6 = . 0x00, 5 = . 0x00, 4 = . 0x00, 3 = . 0x00, 2 = . 0x00, 1 = . 0x00, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x39, Name = CLKRCON. 0x39, Bit Pos. = 7:0. 0x39, 7 = EN. 0x39, 6 = . 0x39, 5 = . 0x39, 4 = DC[1:0]. 0x39, 3 = . 0x39, 2 = . 0x39, 1 = DIV[2:0]. 0x39, 0 = . 0x3A, Name = CLKRCLK.",
    "47. Register Summary\n0x3A, Bit Pos. = 7:0. 0x3A, 7 = . 0x3A, 6 = . 0x3A, 5 = . 0x3A, 4 = . 0x3A, 3 = . 0x3A, 2 = . 0x3A, 1 = CLK[3:0]. 0x3A, 0 = . 0x3B, Name = . 0x3B, Bit Pos. = . 0x3B, 7 = . 0x3B, 6 = . 0x3B, 5 = . 0x3B, 4 = . 0x3B, 3 = . 0x3B, 2 = . 0x3B, 1 = . 0x3B, 0 = . ... 0x3F, Name = Reserved. ... 0x3F, Bit Pos. = . ... 0x3F, 7 = . ... 0x3F, 6 = . ... 0x3F, 5 = . ... 0x3F, 4 = . ... 0x3F, 3 = . ...",
    "47. Register Summary\n0x3F, 2 = . ... 0x3F, 1 = . ... 0x3F, 0 = . NVMCON0, Name = 7:0. NVMCON0, Bit Pos. = . NVMCON0, 7 = . NVMCON0, 6 = . NVMCON0, 5 = . NVMCON0, 4 = . NVMCON0, 3 = . NVMCON0, 2 = . NVMCON0, 1 = . NVMCON0, 0 = . 0x40, Name = . 0x40, Bit Pos. = . 0x40, 7 = . 0x40, 6 = . 0x40, 5 = . 0x40, 4 = . 0x40, 3 = . 0x40, 2 = . 0x40, 1 = . 0x40, 0 = GO. 0x41 NVMCON1, Name = 7:0. 0x41 NVMCON1, Bit Pos. = WRERR. 0x41 NVMCON1, 7 = . 0x41",
    "47. Register Summary\nNVMCON1, 6 = . 0x41 NVMCON1, 5 = . 0x41 NVMCON1, 4 = . 0x41 NVMCON1, 3 = . 0x41 NVMCON1, 2 = . 0x41 NVMCON1, 1 = NVMCMD[2:0]. 0x41 NVMCON1, 0 = . 0x42, Name = NVMLOCK. 0x42, Bit Pos. = 7:0. 0x42, 7 = . 0x42, 6 = . 0x42, 5 = . 0x42, 4 = NVMLOCK[7:0]. 0x42, 3 = . 0x42, 2 = . 0x42, 1 = . 0x42, 0 = . 0x43, Name = NVMADR. 0x43, Bit Pos. = 15:8. 0x43, 7 = . 0x43, 6 = . 0x43, 5 = . 0x43, 4 = NVMADR[7:0] NVMADR[15:8]",
    "47. Register Summary\nNVMADR[21:16]. 0x43, 3 = NVMADR[7:0] NVMADR[15:8] NVMADR[21:16]. 0x43, 2 = . 0x43, 1 = . 0x43, 0 = . 0x46, Name = NVMDAT. 0x46, Bit Pos. = 23:16 7:0. 0x46, 7 = . 0x46, 6 = . 0x46, 5 = . 0x46, 4 = NVMDAT[7:0]. 0x46, 3 = . 0x46, 2 = . 0x46, 1 = . 0x46, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = NVMDAT[15:8]. , 3 = . , 2 = . , 1 = . , 0 = . 0x48, Name = VREGCON. 0x48, Bit Pos. = 7:0. 0x48, 7 = . 0x48, 6 = .",
    "47. Register Summary\n0x48, 5 = PMSYS[1:0]. 0x48, 4 = PMSYS[1:0]. 0x48, 3 = . 0x48, 2 = . 0x48, 1 = VREGPM[1:0]. 0x48, 0 = VREGPM[1:0]. 0x49, Name = BORCON. 0x49, Bit Pos. = 7:0. 0x49, 7 = SBOREN. 0x49, 6 = . 0x49, 5 = . 0x49, 4 = . 0x49, 3 = . 0x49, 2 = . 0x49, 1 = . 0x49, 0 = BORRDY. 0x4A, Name = HLVDCON0. 0x4A, Bit Pos. = EN. 0x4A, 7 = . 0x4A, 6 = . 0x4A, 5 = OUT. 0x4A, 4 = RDY. 0x4A, 3 = . 0x4A, 2 = . 0x4A, 1 = INTH. 0x4A, 0 =",
    "47. Register Summary\nINTL. 0x4B, Name = HLVDCON1. 0x4B, Bit Pos. = 7:0 7:0. 0x4B, 7 = . 0x4B, 6 = . 0x4B, 5 = . 0x4B, 4 = . 0x4B, 3 = . 0x4B, 2 = SEL[3:0]. 0x4B, 1 = . 0x4B, 0 = . 0x4C, Name = ZCDCON. 0x4C, Bit Pos. = 7:0. 0x4C, 7 = SEN. 0x4C, 6 = . 0x4C, 5 = OUT. 0x4C, 4 = POL. 0x4C, 3 = . 0x4C, 2 = . 0x4C, 1 = INTP. 0x4C, 0 = INTN. 0x4D, Name = . 0x4D, Bit Pos. = . 0x4D, 7 = . 0x4D, 6 = . 0x4D, 5 = . 0x4D, 4 = .",
    "47. Register Summary\n0x4D, 3 = . 0x4D, 2 = . 0x4D, 1 = . 0x4D, 0 = . ... 0x62, Name = Reserved. ... 0x62, Bit Pos. = . ... 0x62, 7 = . ... 0x62, 6 = . ... 0x62, 5 = . ... 0x62, 4 = . ... 0x62, 3 = . ... 0x62, 2 = . ... 0x62, 1 = . ... 0x62, 0 = . 0x63, Name = PMD0. 0x63, Bit Pos. = 7:0 SYSCMD. 0x63, 7 = FVRMD. 0x63, 6 = . 0x63, 5 = HLVDMD. 0x63, 4 = CRCMD. 0x63, 3 = SCANMD. 0x63, 2 = . 0x63, 1 = CLKRMD. 0x63, 0 =",
    "47. Register Summary\nIOCMD. 0x64, Name = PMD1. 0x64, Bit Pos. = 7:0 C1MD. 0x64, 7 = . 0x64, 6 = ZCDMD. 0x64, 5 = SMT1MD. 0x64, 4 = TMR4MD. 0x64, 3 = TMR3MD. 0x64, 2 = TMR2MD. 0x64, 1 = TMR1MD. 0x64, 0 = TMR0MD. 0x65, Name = PMD2. 0x65, Bit Pos. = 7:0. 0x65, 7 = CCP1MD. 0x65, 6 = CWG1MD. 0x65, 5 = DSM1MD. 0x65, 4 = NCO1MD. 0x65, 3 = ACTMD. 0x65, 2 = DAC1MD. 0x65, 1 = ADCMD. 0x65, 0 = C2MD. 0x66, Name = PMD3. 0x66, Bit Pos. = 7:0. 0x66, 7 =",
    "47. Register Summary\nU2MD. 0x66, 6 = U1MD. 0x66, 5 = SPI2MD. 0x66, 4 = SPI1MD. 0x66, 3 = I2C1MD. 0x66, 2 = PWM3MD. 0x66, 1 = PWM2MD. 0x66, 0 = PWM1MD. 0x67, Name = PMD4. 0x67, Bit Pos. = 7:0. 0x67, 7 = DMA3MD. 0x67, 6 = DMA2MD. 0x67, 5 = DMA1MD. 0x67, 4 = CLC4MD. 0x67, 3 = CLC3MD. 0x67, 2 = CLC2MD. 0x67, 1 = CLC1MD. 0x67, 0 = U3MD. 0x68, Name = PMD5. 0x68, Bit Pos. = 7:0. 0x68, 7 = . 0x68, 6 = . 0x68, 5 = .",
    "47. Register Summary\n0x68, 4 = . 0x68, 3 = . 0x68, 2 = OPA1MD. 0x68, 1 = DAC2MD. 0x68, 0 = DMA4MD. 0x69, Name = Reserved. 0x69, Bit Pos. = . 0x69, 7 = . 0x69, 6 = . 0x69, 5 = . 0x69, 4 = . 0x69, 3 = . 0x69, 2 = . 0x69, 1 = . 0x69, 0 = . 0x6A, Name = MD1CON0. 0x6A, Bit Pos. = 7:0. 0x6A, 7 = EN. 0x6A, 6 = . 0x6A, 5 = OUT. 0x6A, 4 = OPOL. 0x6A, 3 = . 0x6A, 2 = . 0x6A, 1 = . 0x6A, 0 = BIT. 0x6B, Name = . 0x6B, Bit Pos. = 7:0.",
    "47. Register Summary\n0x6B, 7 = . 0x6B, 6 = . 0x6B, 5 = CHPOL. 0x6B, 4 = CHSYNC. 0x6B, 3 = . 0x6B, 2 = . 0x6B, 1 = CLPOL. 0x6B, 0 = CLSYNC. 0x6C, Name = MD1CON1 MD1SRC. 0x6C, Bit Pos. = 7:0. 0x6C, 7 = . 0x6C, 6 = . 0x6C, 5 = . 0x6C, 4 = . 0x6C, 3 = . 0x6C, 2 = MS[4:0]. 0x6C, 1 = . 0x6C, 0 = . 0x6D, Name = MD1CARL. 0x6D, Bit Pos. = 7:0. 0x6D, 7 = . 0x6D, 6 = . 0x6D, 5 = . 0x6D, 4 = . 0x6D, 3 = . 0x6D, 2 =",
    "47. Register Summary\nCL[3:0]. 0x6D, 1 = . 0x6D, 0 = . 0x6E, Name = MD1CARH. 0x6E, Bit Pos. = 7:0. 0x6E, 7 = . 0x6E, 6 = . 0x6E, 5 = . 0x6E, 4 = . 0x6E, 3 = . 0x6E, 2 = CH[3:0]. 0x6E, 1 = . 0x6E, 0 = . 0x6F, Name = CMOUT. 0x6F, Bit Pos. = 7:0. 0x6F, 7 = . 0x6F, 6 = . 0x6F, 5 = . 0x6F, 4 = . 0x6F, 3 = . 0x6F, 2 = . 0x6F, 1 = C2OUT. 0x6F, 0 = C1OUT. 0x70, Name = CM1CON0. 0x70, Bit Pos. = . 0x70, 7 = EN. 0x70, 6 = OUT. 0x70,",
    "47. Register Summary\n5 = . 0x70, 4 = POL. 0x70, 3 = . 0x70, 2 = . 0x70, 1 = HYS. 0x70, 0 = SYNC. 0x71, Name = CM1CON1. 0x71, Bit Pos. = 7:0 7:0. 0x71, 7 = . 0x71, 6 = . 0x71, 5 = . 0x71, 4 = . 0x71, 3 = . 0x71, 2 = . 0x71, 1 = INTP. 0x71, 0 = INTN. 0x72, Name = CM1NCH. 0x72, Bit Pos. = 7:0. 0x72, 7 = . 0x72, 6 = . 0x72, 5 = . 0x72, 4 = . 0x72, 3 = . 0x72, 2 = . 0x72, 1 = NCH[2:0]. 0x72, 0 = . 0x73, Name = CM1PCH. 0x73,",
    "47. Register Summary\nBit Pos. = 7:0. 0x73, 7 = . 0x73, 6 = . 0x73, 5 = . 0x73, 4 = . 0x73, 3 = . 0x73, 2 = . 0x73, 1 = PCH[2:0]. 0x73, 0 = . 0x74, Name = CM2CON0. 0x74, Bit Pos. = 7:0. 0x74, 7 = EN. 0x74, 6 = OUT. 0x74, 5 = . 0x74, 4 = POL. 0x74, 3 = . 0x74, 2 = . 0x74, 1 = HYS. 0x74, 0 = SYNC. 0x75, Name = CM2CON1. 0x75, Bit Pos. = 7:0. 0x75, 7 = . 0x75, 6 = . 0x75, 5 = . 0x75, 4 = . 0x75, 3 = . 0x75, 2 = . 0x75, 1 = INTP.",
    "47. Register Summary\n0x75, 0 = INTN. 0x76, Name = CM2NCH. 0x76, Bit Pos. = 7:0. 0x76, 7 = . 0x76, 6 = . 0x76, 5 = . 0x76, 4 = . 0x76, 3 = . 0x76, 2 = . 0x76, 1 = NCH[2:0]. 0x76, 0 = . 0x77, Name = CM2PCH. 0x77, Bit Pos. = 7:0. 0x77, 7 = . 0x77, 6 = . 0x77, 5 = . 0x77, 4 = . 0x77, 3 = . 0x77, 2 = . 0x77, 1 = PCH[2:0]. 0x77, 0 = . 0x78, Name = WDTCON0. 0x78, Bit Pos. = 7:0. 0x78, 7 = . 0x78, 6 = . 0x78, 5 = .",
    "47. Register Summary\n0x78, 4 = PS[4:0]. 0x78, 3 = . 0x78, 2 = . 0x78, 1 = . 0x78, 0 = SEN. 0x79, Name = WDTCON1 7:0. 0x79, Bit Pos. = . 0x79, 7 = . 0x79, 6 = . 0x79, 5 = CS[2:0]. 0x79, 4 = . 0x79, 3 = . 0x79, 2 = . 0x79, 1 = WINDOW[2:0]. 0x79, 0 = . 0x7A, Name = WDTPSL. 0x7A, Bit Pos. = 7:0. 0x7A, 7 = . 0x7A, 6 = . 0x7A, 5 = . 0x7A, 4 = PSCNTL[7:0]. 0x7A, 3 = . 0x7A, 2 = . 0x7A, 1 = . 0x7A, 0 = .",
    "47. Register Summary\n0x7B, Name = WDTPSH 7:0. 0x7B, Bit Pos. = . 0x7B, 7 = . 0x7B, 6 = . 0x7B, 5 = . 0x7B, 4 = PSCNTH[7:0]. 0x7B, 3 = . 0x7B, 2 = . 0x7B, 1 = . 0x7B, 0 = . 0x7C, Name = WDTTMR 7:0. 0x7C, Bit Pos. = . 0x7C, 7 = . 0x7C, 6 = . 0x7C, 5 = TMR[4:0]. 0x7C, 4 = . 0x7C, 3 = . 0x7C, 2 = STATE. 0x7C, 1 = PSCNT[17:16]. 0x7C, 0 = PSCNT[17:16]. 0x7D, Name = DAC1DATL. 0x7D, Bit Pos. = 7:0. 0x7D, 7 = .",
    "47. Register Summary\n0x7D, 6 = . 0x7D, 5 = . 0x7D, 4 = DAC1R[7:0]. 0x7D, 3 = . 0x7D, 2 = . 0x7D, 1 = . 0x7D, 0 = . 0x7E, Name = . 0x7E, Bit Pos. = . 0x7E, 7 = . 0x7E, 6 = . 0x7E, 5 = . 0x7E, 4 = . 0x7E, 3 = . 0x7E, 2 = . 0x7E, 1 = . 0x7E, 0 = . 0x7F, Name = Reserved. 0x7F, Bit Pos. = . 0x7F, 7 = . 0x7F, 6 = . 0x7F, 5 = OE[1:0]. 0x7F, 4 = . 0x7F, 3 = . 0x7F, 2 = . 0x7F, 1 = . 0x7F, 0 = . , Name = DAC1CON. , Bit Pos.",
    "47. Register Summary\n= 7:0. , 7 = EN. , 6 = . , 5 = . , 4 = . , 3 = . , 2 = PSS[1:0]. , 1 = . , 0 = NSS. 0x80, Name = SPI1RXB. 0x80, Bit Pos. = 7:0 7:0. 0x80, 7 = . 0x80, 6 = . 0x80, 5 = . 0x80, 4 = RXB[7:0]. 0x80, 3 = . 0x80, 2 = . 0x80, 1 = . 0x80, 0 = . 0x81, Name = SPI1TXB. 0x81, Bit Pos. = 7:0. 0x81, 7 = . 0x81, 6 = . 0x81, 5 = . 0x81, 4 = . 0x81, 3 = TXB[7:0]. 0x81, 2 = . 0x81, 1 = . 0x81, 0 = . , Name = . , Bit Pos. = . , 7",
    "47. Register Summary\n= . , 6 = . , 5 = . , 4 = TCNTL[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x82, Name = SPI1TCNT. 0x82, Bit Pos. = 15:8. 0x82, 7 = . 0x82, 6 = . 0x82, 5 = . 0x82, 4 = . 0x82, 3 = . 0x82, 2 = . 0x82, 1 = TCNTH[2:0]. 0x82, 0 = ",
    "47. Register Summary\nAddress 0x84,  = Name SPI1CON0. Address 0x84, Bit Pos. = 7:0. Address 0x84, 7 = . Address 0x84, 6 = . Address 0x84, 5 = . Address 0x84, 4 = . Address 0x84, 3 = . Address 0x84, 2 = LSBF. Address 0x84, 1 = MST. Address 0x84, 0 = BMODE. 0x85,  = SPI1CON1. 0x85, Bit Pos. = 7:0. 0x85, 7 = EN SMP. 0x85, 6 = CKE. 0x85, 5 = CKP. 0x85, 4 = FST. 0x85, 3 = . 0x85, 2 = SSP. 0x85, 1 = SDIP. 0x85, 0 = SDOP. 0x86,",
    "47. Register Summary\n= SPI1CON2. 0x86, Bit Pos. = 7:0. 0x86, 7 = BUSY. 0x86, 6 = SSFLT. 0x86, 5 = . 0x86, 4 = . 0x86, 3 = . 0x86, 2 = SSET. 0x86, 1 = TXR. 0x86, 0 = RXR. 0x87,  = SPI1STATUS. 0x87, Bit Pos. = 7:0. 0x87, 7 = TXWE. 0x87, 6 = . 0x87, 5 = TXBE. 0x87, 4 = . 0x87, 3 = RXRE. 0x87, 2 = CLB. 0x87, 1 = . 0x87, 0 = RXBF. 0x88,",
    "47. Register Summary\n= SPI1TWIDTH. 0x88, Bit Pos. = 7:0. 0x88, 7 = . 0x88, 6 = . 0x88, 5 = . 0x88, 4 = . 0x88, 3 = . 0x88, 2 = . 0x88, 1 = TWIDTH[2:0]. 0x88, 0 = . 0x89,  = SPI1BAUD. 0x89, Bit Pos. = 7:0. 0x89, 7 = . 0x89, 6 = . 0x89, 5 = . 0x89, 4 = BAUD[7:0]. 0x89, 3 = . 0x89, 2 = . 0x89, 1 = . 0x89, 0 = . 0x8A,",
    "47. Register Summary\n= SPI1INTF. 0x8A, Bit Pos. = 7:0. 0x8A, 7 = SRMTIF. 0x8A, 6 = TCZIF. 0x8A, 5 = SOSIF. 0x8A, 4 = EOSIF. 0x8A, 3 = . 0x8A, 2 = RXOIF. 0x8A, 1 = TXUIF. 0x8A, 0 = . 0x8B,  = SPI1INTE. 0x8B, Bit Pos. = 7:0. 0x8B, 7 = SRMTIE. 0x8B, 6 = TCZIE. 0x8B, 5 = SOSIE. 0x8B, 4 = EOSIE. 0x8B, 3 = . 0x8B, 2 = RXOIE. 0x8B, 1 = TXUIE. 0x8B, 0 = . 0x8C,",
    "47. Register Summary\n= SPI1CLK. 0x8C, Bit Pos. = 7:0. 0x8C, 7 = . 0x8C, 6 = . 0x8C, 5 = . 0x8C, 4 = . 0x8C, 3 = . 0x8C, 2 = CLKSEL[3:0]. 0x8C, 1 = . 0x8C, 0 = . 0x8D,  = SPI2RXB. 0x8D, Bit Pos. = 7:0. 0x8D, 7 = . 0x8D, 6 = . 0x8D, 5 = . 0x8D, 4 = RXB[7:0]. 0x8D, 3 = . 0x8D, 2 = . 0x8D, 1 = . 0x8D, 0 = . 0x8E,",
    "47. Register Summary\n= SPI2TXB. 0x8E, Bit Pos. = 7:0. 0x8E, 7 = . 0x8E, 6 = . 0x8E, 5 = . 0x8E, 4 = TXB[7:0]. 0x8E, 3 = . 0x8E, 2 = . 0x8E, 1 = . 0x8E, 0 = . 0x8F,  = SPI2TCNT. 0x8F, Bit Pos. = 7:0 15:8. 0x8F, 7 = . 0x8F, 6 = . 0x8F, 5 = . 0x8F, 4 = TCNTL[7:0]. 0x8F, 3 = . 0x8F, 2 = . 0x8F, 1 = TCNTH[2:0]. 0x8F, 0 = . 0x91,",
    "47. Register Summary\n= SPI2CON0. 0x91, Bit Pos. = 7:0. 0x91, 7 = EN. 0x91, 6 = . 0x91, 5 = . 0x91, 4 = . 0x91, 3 = . 0x91, 2 = LSBF. 0x91, 1 = . 0x91, 0 = . ,  = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = MST. , 0 = BMODE. 0x92,  = SPI2CON1. 0x92, Bit Pos. = 7:0. 0x92, 7 = SMP. 0x92, 6 = CKE. 0x92, 5 = CKP. 0x92, 4 = FST. 0x92, 3 = . 0x92, 2 = SSP. 0x92, 1 = SDIP. 0x92, 0 = SDOP. 0x93,",
    "47. Register Summary\n= SPI2CON2. 0x93, Bit Pos. = 7:0. 0x93, 7 = BUSY. 0x93, 6 = SSFLT. 0x93, 5 = . 0x93, 4 = . 0x93, 3 = . 0x93, 2 = SSET. 0x93, 1 = TXR. 0x93, 0 = RXR. 0x95,  = SPI2TWIDTH. 0x95, Bit Pos. = 7:0. 0x95, 7 = . 0x95, 6 = . 0x95, 5 = . 0x95, 4 = . 0x95, 3 = . 0x95, 2 = . 0x95, 1 = TWIDTH[2:0]. 0x95, 0 = . 0x96,",
    "47. Register Summary\n= SPI2BAUD. 0x96, Bit Pos. = 7:0. 0x96, 7 = . 0x96, 6 = . 0x96, 5 = . 0x96, 4 = BAUD[7:0]. 0x96, 3 = . 0x96, 2 = . 0x96, 1 = . 0x96, 0 = . 0x97,  = SPI2INTF. 0x97, Bit Pos. = 7:0. 0x97, 7 = SRMTIF. 0x97, 6 = TCZIF. 0x97, 5 = SOSIF. 0x97, 4 = EOSIF. 0x97, 3 = . 0x97, 2 = RXOIF. 0x97, 1 = TXUIF. 0x97, 0 = . 0x98,",
    "47. Register Summary\n= SPI2INTE. 0x98, Bit Pos. = 7:0. 0x98, 7 = SRMTIE. 0x98, 6 = TCZIE. 0x98, 5 = SOSIE. 0x98, 4 = EOSIE. 0x98, 3 = . 0x98, 2 = RXOIE. 0x98, 1 = TXUIE. 0x98, 0 = . 0x99,  = SPI2CLK. 0x99, Bit Pos. = 7:0. 0x99, 7 = . 0x99, 6 = . 0x99, 5 = . 0x99, 4 = . 0x99, 3 = . 0x99, 2 = CLKSEL[3:0]. 0x99, 1 = . 0x99, 0 = . 0x9A ...,",
    "47. Register Summary\n= Reserved. 0x9A ..., Bit Pos. = . 0x9A ..., 7 = . 0x9A ..., 6 = . 0x9A ..., 5 = . 0x9A ..., 4 = . 0x9A ..., 3 = . 0x9A ..., 2 = . 0x9A ..., 1 = . 0x9A ..., 0 = . 0x9F,  = . 0x9F, Bit Pos. = . 0x9F, 7 = . 0x9F, 6 = . 0x9F, 5 = . 0x9F, 4 = . 0x9F, 3 = . 0x9F, 2 = . 0x9F, 1 = . 0x9F, 0 = . 0xA0,",
    "47. Register Summary\n= DAC2DATL. 0xA0, Bit Pos. = 7:0. 0xA0, 7 = . 0xA0, 6 = . 0xA0, 5 = . 0xA0, 4 = DAC2R[7:0]. 0xA0, 3 = . 0xA0, 2 = . 0xA0, 1 = . 0xA0, 0 = . 0xA1,  = Reserved. 0xA1, Bit Pos. = . 0xA1, 7 = . 0xA1, 6 = . 0xA1, 5 = . 0xA1, 4 = . 0xA1, 3 = . 0xA1, 2 = . 0xA1, 1 = . 0xA1, 0 = . 0xA2,  = DAC2CON. 0xA2, Bit Pos. = 7:0. 0xA2, 7 = EN. 0xA2, 6 = . 0xA2, 5 = . 0xA2, 4 = PSS[1:0]. 0xA2, 3 = . 0xA2, 2 = . 0xA2, 1 = . 0xA2, 0 = NSS. 0xA3,",
    "47. Register Summary\n= OPA1CON0. 0xA3, Bit Pos. = 7:0. 0xA3, 7 = EN. 0xA3, 6 = . 0xA3, 5 = CPON. 0xA3, 4 = . 0xA3, 3 = UG. 0xA3, 2 = . 0xA3, 1 = . 0xA3, 0 = SOC[1:0]. 0xA4,  = OPA1CON1. 0xA4, Bit Pos. = 7:0. 0xA4, 7 = . 0xA4, 6 = . 0xA4, 5 = GSEL[2:0]. 0xA4, 4 = . 0xA4, 3 = RESON. 0xA4, 2 = . 0xA4, 1 = NSS[2:0]. 0xA4, 0 = . 0xA5,",
    "47. Register Summary\n= OPA1CON2. 0xA5, Bit Pos. = 7:0. 0xA5, 7 = . 0xA5, 6 = . 0xA5, 5 = NCH[2:0]. 0xA5, 4 = . 0xA5, 3 = . 0xA5, 2 = . 0xA5, 1 = PCH[2:0]. 0xA5, 0 = . 0xA6,  = OPA1CON3. 0xA6, Bit Pos. = 7:0. 0xA6, 7 = FMS[1:0]. 0xA6, 6 = . 0xA6, 5 = . 0xA6, 4 = . 0xA6, 3 = . 0xA6, 2 = . 0xA6, 1 = PSS[1:0]. 0xA6, 0 = . 0xA7,",
    "47. Register Summary\n= OPA1HWC. 0xA7, Bit Pos. = 7:0. 0xA7, 7 = OREN. 0xA7, 6 = . 0xA7, 5 = HWCH[2:0]. 0xA7, 4 = . 0xA7, 3 = ORPOL. 0xA7, 2 = . 0xA7, 1 = HWCL[2:0]. 0xA7, 0 = . 0xA8,  = OPA1OFFSET. 0xA8, Bit Pos. = 7:0. 0xA8, 7 = . 0xA8, 6 = . 0xA8, 5 = . 0xA8, 4 = OFFSET[7:0]. 0xA8, 3 = . 0xA8, 2 = . 0xA8, 1 = . 0xA8, 0 = . 0xA9,",
    "47. Register Summary\n= OPA1ORS. 0xA9, Bit Pos. = 7:0. 0xA9, 7 = . 0xA9, 6 = . 0xA9, 5 = . 0xA9, 4 = . 0xA9, 3 = ORS[4:0]. 0xA9, 2 = . 0xA9, 1 = . 0xA9, 0 = . 0xAA,  = Reserved. 0xAA, Bit Pos. = . 0xAA, 7 = . 0xAA, 6 = . 0xAA, 5 = . 0xAA, 4 = . 0xAA, 3 = . 0xAA, 2 = . 0xAA, 1 = . 0xAA, 0 = . ... 0xAB 0xAC,",
    "47. Register Summary\n= ACTCON. ... 0xAB 0xAC, Bit Pos. = 7:0. ... 0xAB 0xAC, 7 = ACTEN. ... 0xAB 0xAC, 6 = ACTUD. ... 0xAB 0xAC, 5 = . ... 0xAB 0xAC, 4 = . ... 0xAB 0xAC, 3 = ACTLOCK. ... 0xAB 0xAC, 2 = . ... 0xAB 0xAC, 1 = ACTORS. ... 0xAB 0xAC, 0 = . 0xAD,  = OSCCON1. 0xAD, Bit Pos. = 7:0. 0xAD, 7 = . 0xAD, 6 = . 0xAD, 5 = NOSC[2:0]. 0xAD, 4 = . 0xAD, 3 = . 0xAD, 2 = NDIV[3:0]. 0xAD, 1 = . 0xAD, 0 = . 0xAE,",
    "47. Register Summary\n= OSCCON2. 0xAE, Bit Pos. = 7:0. 0xAE, 7 = . 0xAE, 6 = . 0xAE, 5 = COSC[2:0]. 0xAE, 4 = . 0xAE, 3 = . 0xAE, 2 = . 0xAE, 1 = CDIV[3:0]. 0xAE, 0 = . 0xAF,  = OSCCON3. 0xAF, Bit Pos. = 7:0. 0xAF, 7 = CSWHOLD. 0xAF, 6 = SOSCPWR. 0xAF, 5 = . 0xAF, 4 = ORDY. 0xAF, 3 = NOSCR. 0xAF, 2 = . 0xAF, 1 = . 0xAF, 0 = . 0xB0,",
    "47. Register Summary\n= OSCTUNE. 0xB0, Bit Pos. = 7:0. 0xB0, 7 = . 0xB0, 6 = . 0xB0, 5 = . 0xB0, 4 = . 0xB0, 3 = TUN[5:0]. 0xB0, 2 = . 0xB0, 1 = . 0xB0, 0 = . 0xB1,  = OSCFRQ. 0xB1, Bit Pos. = 7:0. 0xB1, 7 = . 0xB1, 6 = . 0xB1, 5 = . 0xB1, 4 = . 0xB1, 3 = . 0xB1, 2 = . 0xB1, 1 = FRQ[3:0]. 0xB1, 0 = . 0xB2,",
    "47. Register Summary\n= OSCSTAT. 0xB2, Bit Pos. = 7:0. 0xB2, 7 = EXTOR. 0xB2, 6 = HFOR. 0xB2, 5 = MFOR. 0xB2, 4 = LFOR. 0xB2, 3 = SOR. 0xB2, 2 = ADOR. 0xB2, 1 = SFOR. 0xB2, 0 = PLLR. 0xB3,  = OSCEN. 0xB3, Bit Pos. = 7:0. 0xB3, 7 = EXTOEN. 0xB3, 6 = HFOEN. 0xB3, 5 = MFOEN. 0xB3, 4 = LFOEN. 0xB3, 3 = SOSCEN. 0xB3, 2 = ADOEN. 0xB3, 1 = . 0xB3, 0 = PLLEN. 0xB4,",
    "47. Register Summary\n= PRLOCK. 0xB4, Bit Pos. = 7:0. 0xB4, 7 = . 0xB4, 6 = . 0xB4, 5 = . 0xB4, 4 = . 0xB4, 3 = . 0xB4, 2 = . 0xB4, 1 = . 0xB4, 0 = PRLOCKED. 0xB5,  = SCANPR. 0xB5, Bit Pos. = 7:0. 0xB5, 7 = . 0xB5, 6 = . 0xB5, 5 = . 0xB5, 4 = . 0xB5, 3 = . 0xB5, 2 = . 0xB5, 1 = PR[2:0]. 0xB5, 0 = . 0xB6,",
    "47. Register Summary\n= DMA1PR DMA2PR. 0xB6, Bit Pos. = 7:0 7:0. 0xB6, 7 = . 0xB6, 6 = . 0xB6, 5 = . 0xB6, 4 = . 0xB6, 3 = . 0xB6, 2 = . 0xB6, 1 = PR[2:0] PR[2:0]. 0xB6, 0 = . 0xB7,  = DMA3PR. 0xB7, Bit Pos. = 7:0. 0xB7, 7 = . 0xB7, 6 = . 0xB7, 5 = . 0xB7, 4 = . 0xB7, 3 = . 0xB7, 2 = . 0xB7, 1 = PR[2:0]. 0xB7, 0 = . 0xB8 0xB9,",
    "47. Register Summary\n= . 0xB8 0xB9, Bit Pos. = . 0xB8 0xB9, 7 = . 0xB8 0xB9, 6 = . 0xB8 0xB9, 5 = . 0xB8 0xB9, 4 = . 0xB8 0xB9, 3 = . 0xB8 0xB9, 2 = . 0xB8 0xB9, 1 = . 0xB8 0xB9, 0 = . ,  = DMA4PR. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = PR[2:0]. , 0 = . 0xBA,  = . 0xBA, Bit Pos. = . 0xBA, 7 = . 0xBA, 6 = . 0xBA, 5 = . 0xBA, 4 = . 0xBA, 3 = . 0xBA, 2 = . 0xBA, 1 = . 0xBA, 0 = . ... 0xBD,",
    "47. Register Summary\n= Reserved. ... 0xBD, Bit Pos. = . ... 0xBD, 7 = . ... 0xBD, 6 = . ... 0xBD, 5 = . ... 0xBD, 4 = . ... 0xBD, 3 = . ... 0xBD, 2 = . ... 0xBD, 1 = . ... 0xBD, 0 = . 0xBE,  = MAINPR. 0xBE, Bit Pos. = 7:0. 0xBE, 7 = . 0xBE, 6 = . 0xBE, 5 = . 0xBE, 4 = . 0xBE, 3 = . 0xBE, 2 = . 0xBE, 1 = PR[2:0]. 0xBE, 0 = . ,  = Reserved. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0xC0,",
    "47. Register Summary\n= . 0xC0, Bit Pos. = . 0xC0, 7 = . 0xC0, 6 = . 0xC0, 5 = . 0xC0, 4 = . 0xC0, 3 = . 0xC0, 2 = . 0xC0, 1 = . 0xC0, 0 = . ... 0xD3,  = CLCDATA. ... 0xD3, Bit Pos. = . ... 0xD3, 7 = . ... 0xD3, 6 = . ... 0xD3, 5 = . ... 0xD3, 4 = . ... 0xD3, 3 = . ... 0xD3, 2 = . ... 0xD3, 1 = . ... 0xD3, 0 = . 0xD4,",
    "47. Register Summary\n= . 0xD4, Bit Pos. = 7:0. 0xD4, 7 = . 0xD4, 6 = . 0xD4, 5 = . 0xD4, 4 = . 0xD4, 3 = CLC4OUT. 0xD4, 2 = CLC3OUT. 0xD4, 1 = CLC2OUT. 0xD4, 0 = CLC1OUT",
    "47. Register Summary\n0xD5, Name = CLCSELECT. 0xD5, Bit Pos. = 7:0. 0xD5, 7 = . 0xD5, 6 = . 0xD5, 5 = . 0xD5, 3 = . 0xD5, 2 = . 0xD5, 1 = SLCT[1:0]. 0xD5, 0 = . 0xD6, Name = CLCnCON. 0xD6, Bit Pos. = 7:0. 0xD6, 7 = EN. 0xD6, 6 = . 0xD6, 5 = OUT. 0xD6, 3 = INTN. 0xD6, 2 = . 0xD6, 1 = MODE[2:0]. 0xD6, 0 = . 0xD7, Name = CLCnPOL. 0xD7, Bit Pos. = 7:0. 0xD7, 7 = POL. 0xD7, 6 = . 0xD7, 5 = . 0xD7, 3 = G4POL. 0xD7, 2 =",
    "47. Register Summary\nG3POL. 0xD7, 1 = G2POL. 0xD7, 0 = G1POL. 0xD8, Name = CLCnSEL0. 0xD8, Bit Pos. = 7:0. 0xD8, 7 = . 0xD8, 6 = . 0xD8, 5 = . 0xD8, 3 = D1S[6:0]. 0xD8, 2 = . 0xD8, 1 = . 0xD8, 0 = . 0xD9, Name = CLCnSEL1. 0xD9, Bit Pos. = 7:0. 0xD9, 7 = . 0xD9, 6 = . 0xD9, 5 = . 0xD9, 3 = D2S[6:0]. 0xD9, 2 = . 0xD9, 1 = . 0xD9, 0 = . 0xDA, Name = CLCnSEL2. 0xDA, Bit Pos. = 7:0. 0xDA, 7 = . 0xDA, 6 = . 0xDA, 5",
    "47. Register Summary\n= . 0xDA, 3 = D3S[6:0]. 0xDA, 2 = . 0xDA, 1 = . 0xDA, 0 = . 0xDB, Name = CLCnSEL3. 0xDB, Bit Pos. = 7:0. 0xDB, 7 = . 0xDB, 6 = . 0xDB, 5 = . 0xDB, 3 = D4S[6:0]. 0xDB, 2 = . 0xDB, 1 = . 0xDB, 0 = . 0xDC, Name = CLCnGLS0. 0xDC, Bit Pos. = 7:0. 0xDC, 7 = G1D4T. 0xDC, 6 = G1D4N. 0xDC, 5 = G1D3T. 0xDC, 3 = G1D2T. 0xDC, 2 = G1D2N. 0xDC, 1 = G1D1T. 0xDC, 0 = G1D1N. 0xDD, Name = CLCnGLS1. 0xDD, Bit Pos. =",
    "47. Register Summary\n7:0. 0xDD, 7 = G2D4T. 0xDD, 6 = G2D4N. 0xDD, 5 = G2D3T. 0xDD, 3 = G2D2T. 0xDD, 2 = G2D2N. 0xDD, 1 = G2D1T. 0xDD, 0 = G2D1N. 0xDE, Name = CLCnGLS2. 0xDE, Bit Pos. = 7:0. 0xDE, 7 = G3D4T. 0xDE, 6 = G3D4N. 0xDE, 5 = G3D3T. 0xDE, 3 = G3D2T. 0xDE, 2 = G3D2N. 0xDE, 1 = G3D1T. 0xDE, 0 = G3D1N. 0xDF, Name = CLCnGLS3. 0xDF, Bit Pos. = 7:0. 0xDF, 7 = G4D4T. 0xDF, 6 = G4D4N. 0xDF, 5 = G4D3T.",
    "47. Register Summary\n0xDF, 3 = G4D2T. 0xDF, 2 = G4D2N. 0xDF, 1 = G4D1T. 0xDF, 0 = G4D1N. 0xE0, Name = . 0xE0, Bit Pos. = . 0xE0, 7 = . 0xE0, 6 = . 0xE0, 5 = . 0xE0, 3 = . 0xE0, 2 = . 0xE0, 1 = . 0xE0, 0 = . ... 0xE7, Name = Reserved. ... 0xE7, Bit Pos. = . ... 0xE7, 7 = . ... 0xE7, 6 = . ... 0xE7, 5 = . ... 0xE7, 3 = . ... 0xE7, 2 = . ... 0xE7, 1 = . ... 0xE7, 0 = . 0xE8, Name = DMASELECT. 0xE8, Bit Pos. = 7:0.",
    "47. Register Summary\n0xE8, 7 = . 0xE8, 6 = . 0xE8, 5 = . 0xE8, 3 = . 0xE8, 2 = . 0xE8, 1 = SLCT[2:0]. 0xE8, 0 = . 0xE9, Name = DMAnBUF. 0xE9, Bit Pos. = 7:0. 0xE9, 7 = . 0xE9, 6 = . 0xE9, 5 = . 0xE9, 3 = BUF[7:0]. 0xE9, 2 = . 0xE9, 1 = . 0xE9, 0 = . 0xEA, Name = DMAnDCNT. 0xEA, Bit Pos. = 7:0. 0xEA, 7 = . 0xEA, 6 = . 0xEA, 5 = . 0xEA, 3 = DCNT[7:0]. 0xEA, 2 = . 0xEA, 1 = . 0xEA, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6",
    "47. Register Summary\n= . , 5 = . , 3 = . , 2 = DCNT[11:8]. , 1 = DCNT[11:8]. , 0 = . 0xEC, Name = DMAnDPTR. 0xEC, Bit Pos. = 7:0. 0xEC, 7 = . 0xEC, 6 = . 0xEC, 5 = . 0xEC, 3 = DPTR[7:0] DPTR[15:8]. 0xEC, 2 = . 0xEC, 1 = . 0xEC, 0 = . 0xEE, Name = DMAnDSZ. 0xEE, Bit Pos. = 15:8. 0xEE, 7 = . 0xEE, 6 = . 0xEE, 5 = . 0xEE, 3 = DSZ[7:0]. 0xEE, 2 = . 0xEE, 1 = . 0xEE, 0 = . , Name = . , Bit Pos. = 7:0 15:8. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 =",
    "47. Register Summary\nDSZ[11:8]. , 0 = . 0xF0, Name = . 0xF0, Bit Pos. = 7:0. 0xF0, 7 = . 0xF0, 6 = . 0xF0, 5 = . 0xF0, 3 = DSA[7:0] DSA[15:8]. 0xF0, 2 = . 0xF0, 1 = . 0xF0, 0 = . , Name = DMAnDSA. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . 0xF2, Name = DMAnSCNT. 0xF2, Bit Pos. = 7:0. 0xF2, 7 = . 0xF2, 6 = . 0xF2, 5 = . 0xF2, 3 = SCNT[7:0]. 0xF2, 2 = . 0xF2, 1 = . 0xF2, 0 = . , Name = . , Bit Pos. =",
    "47. Register Summary\n15:8. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = SCNT[11:8]. , 1 = SCNT[11:8]. , 0 = . 0xF4, Name = DMAnSPTR. 0xF4, Bit Pos. = 7:0 15:8. 0xF4, 7 = . 0xF4, 6 = . 0xF4, 5 = . 0xF4, 3 = SPTR[15:8]. 0xF4, 2 = . 0xF4, 1 = . 0xF4, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 3 = SPTR[21:16]. , 2 = . , 1 = . , 0 = . 0xF7, Name = DMAnSSZ 15:8. 0xF7, Bit Pos. = 7:0. 0xF7, 7 = . 0xF7, 6 = . 0xF7, 5 = . 0xF7, 3 =",
    "47. Register Summary\nSSZ[7:0]. 0xF7, 2 = . 0xF7, 1 = . 0xF7, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 3 = SSA[7:0]. , 2 = SSZ[11:8]. , 1 = . , 0 = . , Name = DMAnSSA. , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 3 = SSA[15:8]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . 0xF9, Name = . 0xF9, Bit Pos. = 23:16. 0xF9, 7 = . 0xF9, 6 = . 0xF9, 5 = . 0xF9, 3 = SSA[21:16]. 0xF9, 2 = .",
    "47. Register Summary\n0xF9, 1 = . 0xF9, 0 = . 0xFC, Name = DMAnCON0 7:0. 0xFC, Bit Pos. = . 0xFC, 7 = EN. 0xFC, 6 = SIRQEN. 0xFC, 5 = DGO. 0xFC, 3 = . 0xFC, 2 = AIRQEN. 0xFC, 1 = . 0xFC, 0 = XIP. 0xFD, Name = DMAnCON1. 0xFD, Bit Pos. = 7:0. 0xFD, 7 = . 0xFD, 6 = DMODE[1:0]. 0xFD, 5 = DSTP. 0xFD, 3 = SMR[1:0]. 0xFD, 2 = SMODE[1:0]. 0xFD, 1 = . 0xFD, 0 = SSTP. 0xFE, Name = DMAnAIRQ. 0xFE, Bit Pos. = 7:0. 0xFE, 7 = . 0xFE, 6 = . 0xFE, 5 =",
    "47. Register Summary\n. 0xFE, 3 = AIRQ[7:0]. 0xFE, 2 = . 0xFE, 1 = . 0xFE, 0 = . 0xFF, Name = DMAnSIRQ. 0xFF, Bit Pos. = 7:0. 0xFF, 7 = . 0xFF, 6 = . 0xFF, 5 = . 0xFF, 3 = SIRQ[7:0]. 0xFF, 2 = . 0xFF, 1 = . 0xFF, 0 = . 0x0100 ..., Name = Reserved. 0x0100 ..., Bit Pos. = . 0x0100 ..., 7 = . 0x0100 ..., 6 = . 0x0100 ..., 5 = . 0x0100 ..., 3 = . 0x0100 ..., 2 = . 0x0100 ..., 1 = . 0x0100 ..., 0 = . 0x01FF, Name = . 0x01FF, Bit Pos. = . 0x01FF, 7 = . 0x01FF, 6",
    "47. Register Summary\n= . 0x01FF, 5 = . 0x01FF, 3 = . 0x01FF, 2 = . 0x01FF, 1 = . 0x01FF, 0 = . 0x0200, Name = PPSLOCK 7:0. 0x0200, Bit Pos. = . 0x0200, 7 = . 0x0200, 6 = . 0x0200, 5 = . 0x0200, 3 = . 0x0200, 2 = . 0x0200, 1 = . 0x0200, 0 = PPSLOCKED. 0x0201, Name = RA0PPS 7:0. 0x0201, Bit Pos. = . 0x0201, 7 = . 0x0201, 6 = . 0x0201, 5 = . 0x0201, 3 = RA0PPS[5:0]. 0x0201, 2 = . 0x0201, 1 = . 0x0201, 0 = . 0x0202, Name = RA1PPS. 0x0202, Bit Pos. = 7:0.",
    "47. Register Summary\n0x0202, 7 = . 0x0202, 6 = . 0x0202, 5 = . 0x0202, 3 = RA1PPS[5:0]. 0x0202, 2 = . 0x0202, 1 = . 0x0202, 0 = . 0x0203, Name = 7:0. 0x0203, Bit Pos. = . 0x0203, 7 = . 0x0203, 6 = . 0x0203, 5 = . 0x0203, 3 = RA2PPS[5:0]. 0x0203, 2 = . 0x0203, 1 = . 0x0203, 0 = . 0x0204, Name = RA2PPS Reserved. 0x0204, Bit Pos. = . 0x0204, 7 = . 0x0204, 6 = . 0x0204, 5 = . 0x0204, 3 = . 0x0204, 2 = . 0x0204, 1 = . 0x0204, 0",
    "47. Register Summary\n= . 0x0205, Name = RA4PPS. 0x0205, Bit Pos. = 7:0. 0x0205, 7 = . 0x0205, 6 = . 0x0205, 5 = . 0x0205, 3 = RA4PPS[5:0]. 0x0205, 2 = . 0x0205, 1 = . 0x0205, 0 = . 0x0206, Name = RA5PPS. 0x0206, Bit Pos. = 7:0. 0x0206, 7 = . 0x0206, 6 = . 0x0206, 5 = . 0x0206, 3 = RA5PPS[5:0]. 0x0206, 2 = . 0x0206, 1 = . 0x0206, 0 = . 0x0207 ..., Name = . 0x0207 ..., Bit Pos. = . 0x0207 ..., 7 = . 0x0207 ..., 6 = .",
    "47. Register Summary\n0x0207 ..., 5 = . 0x0207 ..., 3 = . 0x0207 ..., 2 = . 0x0207 ..., 1 = . 0x0207 ..., 0 = . 0x020C, Name = Reserved. 0x020C, Bit Pos. = . 0x020C, 7 = . 0x020C, 6 = . 0x020C, 5 = . 0x020C, 3 = . 0x020C, 2 = . 0x020C, 1 = . 0x020C, 0 = . 0x020D, Name = RB4PPS 7:0. 0x020D, Bit Pos. = . 0x020D, 7 = . 0x020D, 6 = . 0x020D, 5 = . 0x020D, 3 = RB4PPS[5:0]. 0x020D, 2 = . 0x020D, 1 = . 0x020D, 0 = . 0x020E, Name =",
    "47. Register Summary\nRB5PPS. 0x020E, Bit Pos. = 7:0. 0x020E, 7 = . 0x020E, 6 = . 0x020E, 5 = . 0x020E, 3 = RB5PPS[5:0]. 0x020E, 2 = . 0x020E, 1 = . 0x020E, 0 = . 0x020F, Name = RB6PPS. 0x020F, Bit Pos. = 7:0. 0x020F, 7 = . 0x020F, 6 = . 0x020F, 5 = . 0x020F, 3 = RB6PPS[5:0]. 0x020F, 2 = . 0x020F, 1 = . 0x020F, 0 = . 0x0210 0x0211, Name = RB7PPS RC0PPS 7:0. 0x0210 0x0211, Bit Pos. = 7:0. 0x0210 0x0211, 7 = . 0x0210",
    "47. Register Summary\n0x0211, 6 = . 0x0210 0x0211, 5 = . 0x0210 0x0211, 3 = RB7PPS[5:0] RC0PPS[5:0]. 0x0210 0x0211, 2 = . 0x0210 0x0211, 1 = . 0x0210 0x0211, 0 = . 0x0212, Name = RC1PPS. 0x0212, Bit Pos. = 7:0. 0x0212, 7 = . 0x0212, 6 = . 0x0212, 5 = . 0x0212, 3 = RC1PPS[5:0]. 0x0212, 2 = . 0x0212, 1 = . 0x0212, 0 = . 0x0213, Name = RC2PPS. 0x0213, Bit Pos. = 7:0. 0x0213, 7 = . 0x0213, 6 = . 0x0213, 5 = .",
    "47. Register Summary\n0x0213, 3 = RC2PPS[5:0]. 0x0213, 2 = . 0x0213, 1 = . 0x0213, 0 = . 0x0214, Name = RC3PPS RC4PPS. 0x0214, Bit Pos. = 7:0. 0x0214, 7 = . 0x0214, 6 = . 0x0214, 5 = . 0x0214, 3 = RC3PPS[5:0]. 0x0214, 2 = . 0x0214, 1 = . 0x0214, 0 = . 0x0215, Name = . 0x0215, Bit Pos. = 7:0. 0x0215, 7 = . 0x0215, 6 = . 0x0215, 5 = . 0x0215, 3 = RC4PPS[5:0]. 0x0215, 2 = . 0x0215, 1 = . 0x0215, 0 = . 0x0216, Name = RC5PPS.",
    "47. Register Summary\n0x0216, Bit Pos. = 7:0. 0x0216, 7 = . 0x0216, 6 = . 0x0216, 5 = . 0x0216, 3 = RC5PPS[5:0]. 0x0216, 2 = . 0x0216, 1 = . 0x0216, 0 = ",
    "47. Register Summary\n0x0218, Name.RC6PPS = RC7PPS. 0x0218, Bit Pos..7:0 = 7:0. 0x0218, 7. = . 0x0218, 6. = . 0x0218, 4. = . 0x0218, 2 1. = . 0x0218, 0. = . 0x0219 ..., Name.RC6PPS = Reserved. 0x0219 ..., Bit Pos..7:0 = . 0x0219 ..., 7. = . 0x0219 ..., 6. = . 0x0219 ..., 4. = . 0x0219 ..., 2 1. = . 0x0219 ..., 0. = . 0x023D 0x023E, Name.RC6PPS = INT0PPS. 0x023D 0x023E, Bit Pos..7:0 = 7:0. 0x023D 0x023E, 7. = .",
    "47. Register Summary\n0x023D 0x023E, 6. = . 0x023D 0x023E, 4. = . 0x023D 0x023E, 2 1. = PIN[2:0]. 0x023D 0x023E, 0. = . 0x023F, Name.RC6PPS = INT1PPS. 0x023F, Bit Pos..7:0 = 7:0. 0x023F, 7. = . 0x023F, 6. = . 0x023F, 4. = PORT[1:0]. 0x023F, 2 1. = PIN[2:0]. 0x023F, 0. = . 0x0240, Name.RC6PPS = INT2PPS. 0x0240, Bit Pos..7:0 = 7:0. 0x0240, 7. = . 0x0240, 6. = . 0x0240, 4. = PORT[2:0]. 0x0240, 2 1. =",
    "47. Register Summary\nPIN[2:0]. 0x0240, 0. = . 0x0241, Name.RC6PPS = T0CKIPPS. 0x0241, Bit Pos..7:0 = 7:0. 0x0241, 7. = . 0x0241, 6. = . 0x0241, 4. = PORT[2:0]. 0x0241, 2 1. = PIN[2:0]. 0x0241, 0. = . 0x0242, Name.RC6PPS = T1CKIPPS. 0x0242, Bit Pos..7:0 = 7:0. 0x0242, 7. = . 0x0242, 6. = . 0x0242, 4. = PORT[2:0]. 0x0242, 2 1. = PIN[2:0]. 0x0242, 0. = . 0x0243, Name.RC6PPS = T1GPPS. 0x0243, Bit Pos..7:0 = 7:0.",
    "47. Register Summary\n0x0243, 7. = . 0x0243, 6. = . 0x0243, 4. = PORT[2:0]. 0x0243, 2 1. = PIN[2:0]. 0x0243, 0. = . 0x0244, Name.RC6PPS = T3CKIPPS. 0x0244, Bit Pos..7:0 = 7:0. 0x0244, 7. = . 0x0244, 6. = . 0x0244, 4. = PORT[2:0]. 0x0244, 2 1. = PIN[2:0]. 0x0244, 0. = . 0x0245, Name.RC6PPS = T3GPPS. 0x0245, Bit Pos..7:0 = 7:0. 0x0245, 7. = . 0x0245, 6. = . 0x0245, 4. = PORT[2:0]. 0x0245, 2 1. = PIN[2:0].",
    "47. Register Summary\n0x0245, 0. = . 0x0246, Name.RC6PPS = . 0x0246, Bit Pos..7:0 = . 0x0246, 7. = . 0x0246, 6. = . 0x0246, 4. = . 0x0246, 2 1. = . 0x0246, 0. = . ... 0x0247, Name.RC6PPS = Reserved. ... 0x0247, Bit Pos..7:0 = . ... 0x0247, 7. = . ... 0x0247, 6. = . ... 0x0247, 4. = . ... 0x0247, 2 1. = . ... 0x0247, 0. = . 0x0248, Name.RC6PPS = T2INPPS. 0x0248, Bit Pos..7:0 = 7:0. 0x0248, 7. = . 0x0248, 6. = .",
    "47. Register Summary\n0x0248, 4. = PORT[2:0]. 0x0248, 2 1. = PIN[2:0]. 0x0248, 0. = . 0x0249, Name.RC6PPS = T4INPPS. 0x0249, Bit Pos..7:0 = 7:0. 0x0249, 7. = . 0x0249, 6. = . 0x0249, 4. = PORT[2:0]. 0x0249, 2 1. = PIN[2:0]. 0x0249, 0. = . 0x024A ..., Name.RC6PPS = . 0x024A ..., Bit Pos..7:0 = . 0x024A ..., 7. = . 0x024A ..., 6. = . 0x024A ..., 4. = . 0x024A ..., 2 1. = . 0x024A ..., 0. = . 0x024E",
    "47. Register Summary\n0x024F, Name.RC6PPS = . 0x024E 0x024F, Bit Pos..7:0 = . 0x024E 0x024F, 7. = . 0x024E 0x024F, 6. = . 0x024E 0x024F, 4. = . 0x024E 0x024F, 2 1. = . 0x024E 0x024F, 0. = . , Name.RC6PPS = CCP1PPS. , Bit Pos..7:0 = 7:0. , 7. = . , 6. = . , 4. = PORT[2:0]. , 2 1. = PIN[2:0]. , 0. = . 0x0250, Name.RC6PPS = Reserved. 0x0250, Bit Pos..7:0 = . 0x0250, 7. = . 0x0250, 6. = . 0x0250, 4. = . 0x0250, 2 1. = . 0x0250,",
    "47. Register Summary\n0. = . 0x0251, Name.RC6PPS = PWM1ERSPPS. 0x0251, Bit Pos..7:0 = 7:0. 0x0251, 7. = . 0x0251, 6. = . 0x0251, 4. = PORT[1:0]. 0x0251, 2 1. = PIN[2:0]. 0x0251, 0. = . 0x0252, Name.RC6PPS = PWM2ERSPPS. 0x0252, Bit Pos..7:0 = 7:0. 0x0252, 7. = . 0x0252, 6. = . 0x0252, 4. = PORT[2:0]. 0x0252, 2 1. = PIN[2:0]. 0x0252, 0. = . 0x0253, Name.RC6PPS = PWM3ERSPPS. 0x0253, Bit Pos..7:0 = 7:0. 0x0253, 7.",
    "47. Register Summary\n= . 0x0253, 6. = . 0x0253, 4. = PORT[1:0]. 0x0253, 2 1. = PIN[2:0]. 0x0253, 0. = . 0x0254, Name.RC6PPS = . 0x0254, Bit Pos..7:0 = . 0x0254, 7. = . 0x0254, 6. = . 0x0254, 4. = . 0x0254, 2 1. = . 0x0254, 0. = . ... 0x0256, Name.RC6PPS = Reserved. ... 0x0256, Bit Pos..7:0 = . ... 0x0256, 7. = . ... 0x0256, 6. = . ... 0x0256, 4. = . ... 0x0256, 2 1. = . ... 0x0256, 0. = . 0x0257, Name.RC6PPS =",
    "47. Register Summary\nPWMIN0PPS. 0x0257, Bit Pos..7:0 = 7:0. 0x0257, 7. = . 0x0257, 6. = . 0x0257, 4. = PORT[2:0]. 0x0257, 2 1. = PIN[2:0]. 0x0257, 0. = . 0x0258, Name.RC6PPS = PWMIN1PPS. 0x0258, Bit Pos..7:0 = 7:0. 0x0258, 7. = . 0x0258, 6. = . 0x0258, 4. = PORT[2:0]. 0x0258, 2 1. = PIN[2:0]. 0x0258, 0. = . 0x0259, Name.RC6PPS = SMT1WINPPS. 0x0259, Bit Pos..7:0 = 7:0. 0x0259, 7. = . 0x0259, 6. = . 0x0259,",
    "47. Register Summary\n4. = PORT[2:0]. 0x0259, 2 1. = PIN[2:0]. 0x0259, 0. = . 0x025A, Name.RC6PPS = SMT1SIGPPS. 0x025A, Bit Pos..7:0 = 7:0. 0x025A, 7. = . 0x025A, 6. = . 0x025A, 4. = PORT[2:0]. 0x025A, 2 1. = PIN[2:0]. 0x025A, 0. = . 0x025B, Name.RC6PPS = CWG1PPS. 0x025B, Bit Pos..7:0 = 7:0. 0x025B, 7. = . 0x025B, 6. = . 0x025B, 4. = PORT[2:0]. 0x025B, 2 1. = PIN[2:0]. 0x025B, 0. = . 0x025C ..., Name.RC6PPS =",
    "47. Register Summary\nReserved. 0x025C ..., Bit Pos..7:0 = . 0x025C ..., 7. = . 0x025C ..., 6. = . 0x025C ..., 4. = . 0x025C ..., 2 1. = . 0x025C ..., 0. = . 0x025D, Name.RC6PPS = . 0x025D, Bit Pos..7:0 = . 0x025D, 7. = . 0x025D, 6. = . 0x025D, 4. = . 0x025D, 2 1. = . 0x025D, 0. = . 0x025E, Name.RC6PPS = MD1CARLPPS. 0x025E, Bit Pos..7:0 = 7:0. 0x025E, 7. = . 0x025E, 6. = . 0x025E, 4. = PORT[2:0]. 0x025E, 2 1. =",
    "47. Register Summary\nPIN[2:0]. 0x025E, 0. = . 0x025F, Name.RC6PPS = MD1CARHPPS. 0x025F, Bit Pos..7:0 = 7:0. 0x025F, 7. = . 0x025F, 6. = . 0x025F, 4. = PORT[2:0]. 0x025F, 2 1. = PIN[2:0]. 0x025F, 0. = . 0x0260, Name.RC6PPS = MD1SRCPPS. 0x0260, Bit Pos..7:0 = 7:0. 0x0260, 7. = . 0x0260, 6. = . 0x0260, 4. = PORT[2:0]. 0x0260, 2 1. = PIN[2:0]. 0x0260, 0. = . 0x0261, Name.RC6PPS = CLCIN0PPS. 0x0261, Bit Pos..7:0 =",
    "47. Register Summary\n7:0. 0x0261, 7. = . 0x0261, 6. = . 0x0261, 4. = PORT[2:0]. 0x0261, 2 1. = PIN[2:0]. 0x0261, 0. = . 0x0262, Name.RC6PPS = CLCIN1PPS. 0x0262, Bit Pos..7:0 = 7:0. 0x0262, 7. = . 0x0262, 6. = . 0x0262, 4. = PORT[2:0]. 0x0262, 2 1. = PIN[2:0]. 0x0262, 0. = . 0x0263, Name.RC6PPS = CLCIN2PPS. 0x0263, Bit Pos..7:0 = 7:0. 0x0263, 7. = . 0x0263, 6. = . 0x0263, 4. = PORT[2:0]. 0x0263, 2 1. =",
    "47. Register Summary\nPIN[2:0]. 0x0263, 0. = . 0x0264, Name.RC6PPS = CLCIN3PPS. 0x0264, Bit Pos..7:0 = 7:0. 0x0264, 7. = . 0x0264, 6. = . 0x0264, 4. = PORT[2:0]. 0x0264, 2 1. = PIN[2:0]. 0x0264, 0. = . 0x0265, Name.RC6PPS = Reserved. 0x0265, Bit Pos..7:0 = . 0x0265, 7. = . 0x0265, 6. = . 0x0265, 4. = . 0x0265, 2 1. = . 0x0265, 0. = . 0x0268, Name.RC6PPS = . 0x0268, Bit Pos..7:0 = . 0x0268, 7. = . 0x0268, 6. = . 0x0268,",
    "47. Register Summary\n4. = . 0x0268, 2 1. = . 0x0268, 0. = . 0x0269, Name.RC6PPS = ADACTPPS. 0x0269, Bit Pos..7:0 = 7:0. 0x0269, 7. = . 0x0269, 6. = . 0x0269, 4. = PORT[2:0]. 0x0269, 2 1. = PIN[2:0]. 0x0269, 0. = . 0x026A, Name.RC6PPS = SPI1SCKPPS. 0x026A, Bit Pos..7:0 = 7:0. 0x026A, 7. = . 0x026A, 6. = . 0x026A, 4. = PORT[2:0]. 0x026A, 2 1. = PIN[2:0]. 0x026A, 0. = . 0x026B, Name.RC6PPS = SPI1SDIPPS. 0x026B, Bit",
    "47. Register Summary\nPos..7:0 = 7:0. 0x026B, 7. = . 0x026B, 6. = . 0x026B, 4. = PORT[2:0]. 0x026B, 2 1. = PIN[2:0]. 0x026B, 0. = . 0x026C, Name.RC6PPS = SPI1SSPPS. 0x026C, Bit Pos..7:0 = 7:0. 0x026C, 7. = . 0x026C, 6. = . 0x026C, 4. = PORT[2:0]. 0x026C, 2 1. = PIN[2:0]. 0x026C, 0. = . 0x026D, Name.RC6PPS = SPI2SCKPPS. 0x026D, Bit Pos..7:0 = 7:0. 0x026D, 7. = . 0x026D, 6. = . 0x026D, 4. = . 0x026D, 2 1.",
    "47. Register Summary\n= PIN[2:0]. 0x026D, 0. = . 0x026E, Name.RC6PPS = SPI2SDIPPS. 0x026E, Bit Pos..7:0 = 7:0. 0x026E, 7. = . 0x026E, 6. = . 0x026E, 4. = PORT[2:0]. 0x026E, 2 1. = PIN[2:0]. 0x026E, 0. = . 0x026F, Name.RC6PPS = SPI2SSPPS. 0x026F, Bit Pos..7:0 = . 0x026F, 7. = . 0x026F, 6. = . 0x026F, 4. = PORT[2:0] PORT[2:0]. 0x026F, 2 1. = PIN[2:0]. 0x026F, 0. = . , Name.RC6PPS = . , Bit Pos..7:0 = 7:0 7:0. , 7. = .",
    "47. Register Summary\n, 6. = . , 4. = . , 2 1. = PIN[2:0]. , 0. = . 0x0270, Name.RC6PPS = I2C1SDAPPS. 0x0270, Bit Pos..7:0 = 7:0. 0x0270, 7. = . 0x0270, 6. = . 0x0270, 4. = PORT[2:0]. 0x0270, 2 1. = PIN[2:0]. 0x0270, 0. = . 0x0271, Name.RC6PPS = I2C1SCLPPS U1RXPPS. 0x0271, Bit Pos..7:0 = 7:0. 0x0271, 7. = . 0x0271, 6. = . 0x0271, 4. = PORT[2:0]. 0x0271, 2 1. = PIN[2:0]. 0x0271, 0. = . 0x0272 0x0273, Name.RC6PPS",
    "47. Register Summary\n= U1CTSPPS. 0x0272 0x0273, Bit Pos..7:0 = 7:0. 0x0272 0x0273, 7. = . 0x0272 0x0273, 6. = . 0x0272 0x0273, 4. = PORT[1:0] PORT[1:0]. 0x0272 0x0273, 2 1. = PIN[2:0]. 0x0272 0x0273, 0. = . 0x0274, Name.RC6PPS = UxRXPPS. 0x0274, Bit Pos..7:0 = 7:0. 0x0274, 7. = . 0x0274, 6. = . 0x0274, 4. = . 0x0274, 2 1. = PIN[2:0]. 0x0274, 0. = . 0x0275, Name.RC6PPS = UxCTSPPS. 0x0275, Bit Pos..7:0 =",
    "47. Register Summary\n7:0. 0x0275, 7. = . 0x0275, 6. = . 0x0275, 4. = PORT[1:0]. 0x0275, 2 1. = PIN[2:0] PIN[2:0]. 0x0275, 0. = \n...........continued\n0x0278, Name.U3CTSPPS = . 0x0278, Bit Pos..7:0 = . 0x0278, 7. = . 0x0278, 6. = . 0x0278, 5 = . 0x0278, 4.3 PORT[1:0] = . 0x0278, 2.3 PORT[1:0] = . 0x0278, 1.PIN[2:0] = . 0x0278, 0. = . 0x0278,",
    "47. Register Summary\n= . ... 0x0285, Name.U3CTSPPS = Reserved. ... 0x0285, Bit Pos..7:0 = . ... 0x0285, 7. = . ... 0x0285, 6. = . ... 0x0285, 5 = . ... 0x0285, 4.3 PORT[1:0] = . ... 0x0285, 2.3 PORT[1:0] = . ... 0x0285, 1.PIN[2:0] = . ... 0x0285, 0. = . ... 0x0285,",
    "47. Register Summary\n= . 0x0286, Name.U3CTSPPS = RB6I2C. 0x0286, Bit Pos..7:0 = 7:0. 0x0286, 7. = SLEW[1:0]. 0x0286, 6. = . 0x0286, 5 = PU[1:0]. 0x0286, 4.3 PORT[1:0] = . 0x0286, 2.3 PORT[1:0] = . 0x0286, 1.PIN[2:0] = TH[1:0]. 0x0286, 0. = . 0x0286,",
    "47. Register Summary\n= . 0x0287, Name.U3CTSPPS = RB4I2C. 0x0287, Bit Pos..7:0 = 7:0. 0x0287, 7. = SLEW[1:0]. 0x0287, 6. = . 0x0287, 5 = PU[1:0]. 0x0287, 4.3 PORT[1:0] = . 0x0287, 2.3 PORT[1:0] = . 0x0287, 1.PIN[2:0] = TH[1:0]. 0x0287, 0. = . 0x0287,",
    "47. Register Summary\n= . 0x0288, Name.U3CTSPPS = RC1I2C. 0x0288, Bit Pos..7:0 = 7:0. 0x0288, 7. = SLEW[1:0]. 0x0288, 6. = . 0x0288, 5 = PU[1:0]. 0x0288, 4.3 PORT[1:0] = . 0x0288, 2.3 PORT[1:0] = . 0x0288, 1.PIN[2:0] = TH[1:0]. 0x0288, 0. = . 0x0288,",
    "47. Register Summary\n= . 0x0289, Name.U3CTSPPS = RC0I2C. 0x0289, Bit Pos..7:0 = 7:0. 0x0289, 7. = SLEW[1:0]. 0x0289, 6. = . 0x0289, 5 = PU[1:0]. 0x0289, 4.3 PORT[1:0] = . 0x0289, 2.3 PORT[1:0] = . 0x0289, 1.PIN[2:0] = TH[1:0]. 0x0289, 0. = . 0x0289,",
    "47. Register Summary\n= . 0x028A, Name.U3CTSPPS = I2C1RXB. 0x028A, Bit Pos..7:0 = 7:0. 0x028A, 7. = . 0x028A, 6. = . 0x028A, 5 = . 0x028A, 4.3 PORT[1:0] = RXB[7:0]. 0x028A, 2.3 PORT[1:0] = . 0x028A, 1.PIN[2:0] = . 0x028A, 0. = . 0x028A,",
    "47. Register Summary\n= . 0x028B, Name.U3CTSPPS = I2C1TXB. 0x028B, Bit Pos..7:0 = 7:0. 0x028B, 7. = . 0x028B, 6. = . 0x028B, 5 = . 0x028B, 4.3 PORT[1:0] = TXB[7:0]. 0x028B, 2.3 PORT[1:0] = . 0x028B, 1.PIN[2:0] = . 0x028B, 0. = . 0x028B,",
    "47. Register Summary\n= . 0x028C, Name.U3CTSPPS = I2C1CNT. 0x028C, Bit Pos..7:0 = 7:0. 0x028C, 7. = . 0x028C, 6. = . 0x028C, 5 = . 0x028C, 4.3 PORT[1:0] = CNT[7:0]. 0x028C, 2.3 PORT[1:0] = . 0x028C, 1.PIN[2:0] = . 0x028C, 0. = . 0x028C,",
    "47. Register Summary\n= . 0x028E, Name.U3CTSPPS = I2C1ADB0. 0x028E, Bit Pos..7:0 = 15:8 7:0. 0x028E, 7. = . 0x028E, 6. = . 0x028E, 5 = . 0x028E, 4.3 PORT[1:0] = CNT[15:8] ADB[7:0]. 0x028E, 2.3 PORT[1:0] = . 0x028E, 1.PIN[2:0] = . 0x028E, 0. = . 0x028E,",
    "47. Register Summary\n= . 0x028F, Name.U3CTSPPS = I2C1ADB1. 0x028F, Bit Pos..7:0 = 7:0. 0x028F, 7. = . 0x028F, 6. = . 0x028F, 5 = . 0x028F, 4.3 PORT[1:0] = ADB[7:0]. 0x028F, 2.3 PORT[1:0] = . 0x028F, 1.PIN[2:0] = . 0x028F, 0. = . 0x028F,",
    "47. Register Summary\n= . 0x0290, Name.U3CTSPPS = I2C1ADR0. 0x0290, Bit Pos..7:0 = 7:0. 0x0290, 7. = . 0x0290, 6. = . 0x0290, 5 = . 0x0290, 4.3 PORT[1:0] = ADR[7:0]. 0x0290, 2.3 PORT[1:0] = . 0x0290, 1.PIN[2:0] = . 0x0290, 0. = . 0x0290,",
    "47. Register Summary\n= . 0x0291, Name.U3CTSPPS = I2C1ADR1. 0x0291, Bit Pos..7:0 = 7:0. 0x0291, 7. = . 0x0291, 6. = . 0x0291, 5 = . 0x0291, 4.3 PORT[1:0] = ADR[6:0]. 0x0291, 2.3 PORT[1:0] = . 0x0291, 1.PIN[2:0] = . 0x0291, 0. = . 0x0291,",
    "47. Register Summary\n= . 0x0292, Name.U3CTSPPS = I2C1ADR2. 0x0292, Bit Pos..7:0 = 7:0. 0x0292, 7. = . 0x0292, 6. = . 0x0292, 5 = . 0x0292, 4.3 PORT[1:0] = . 0x0292, 2.3 PORT[1:0] = . 0x0292, 1.PIN[2:0] = . 0x0292, 0. = . 0x0292,  = . , Name.U3CTSPPS = . , Bit Pos..7:0 = . , 7. = . , 6. = . , 5 = . , 4.3 PORT[1:0] = ADR[7:0]. , 2.3 PORT[1:0] = . , 1.PIN[2:0] = . , 0. = . ,",
    "47. Register Summary\n= . 0x0293, Name.U3CTSPPS = I2C1ADR3. 0x0293, Bit Pos..7:0 = 7:0. 0x0293, 7. = . 0x0293, 6. = . 0x0293, 5 = . 0x0293, 4.3 PORT[1:0] = ADR[6:0]. 0x0293, 2.3 PORT[1:0] = . 0x0293, 1.PIN[2:0] = . 0x0293, 0. = . 0x0293,",
    "47. Register Summary\n= . 0x0294, Name.U3CTSPPS = I2C1CON0. 0x0294, Bit Pos..7:0 = 7:0. 0x0294, 7. = EN. 0x0294, 6. = RSEN. 0x0294, 5 = S. 0x0294, 4.3 PORT[1:0] = CSTR MDR. 0x0294, 2.3 PORT[1:0] = . 0x0294, 1.PIN[2:0] = MODE[2:0]. 0x0294, 0. = . 0x0294,",
    "47. Register Summary\n= . 0x0295, Name.U3CTSPPS = I2C1CON1. 0x0295, Bit Pos..7:0 = 7:0. 0x0295, 7. = ACKCNT. 0x0295, 6. = ACKDT. 0x0295, 5 = ACKSTAT ACKT. 0x0295, 4.3 PORT[1:0] = P. 0x0295, 2.3 PORT[1:0] = RXO. 0x0295, 1.PIN[2:0] = TXU. 0x0295, 0. = CSD. 0x0295,",
    "47. Register Summary\n= . 0x0296, Name.U3CTSPPS = I2C1CON2. 0x0296, Bit Pos..7:0 = 7:0. 0x0296, 7. = ACNT. 0x0296, 6. = GCEN. 0x0296, 5 = FME ABD. 0x0296, 4.3 PORT[1:0] = SDAHT[1:0]. 0x0296, 2.3 PORT[1:0] = . 0x0296, 1.PIN[2:0] = BFRET[1:0]. 0x0296, 0. = . 0x0296,",
    "47. Register Summary\n= . 0x0297, Name.U3CTSPPS = I2C1ERR. 0x0297, Bit Pos..7:0 = 7:0. 0x0297, 7. = . 0x0297, 6. = BTOIF. 0x0297, 5 = BCLIF NACKIF. 0x0297, 4.3 PORT[1:0] = . 0x0297, 2.3 PORT[1:0] = BTOIE. 0x0297, 1.PIN[2:0] = BLCIE. 0x0297, 0. = NACKIE. 0x0297,",
    "47. Register Summary\n= . 0x0298, Name.U3CTSPPS = I2C1STAT0. 0x0298, Bit Pos..7:0 = 7:0. 0x0298, 7. = BFRE. 0x0298, 6. = SMA. 0x0298, 5 = MMA. 0x0298, 4.3 PORT[1:0] = D. 0x0298, 2.3 PORT[1:0] = . 0x0298, 1.PIN[2:0] = . 0x0298, 0. = . 0x0298,",
    "47. Register Summary\n= . 0x0299, Name.U3CTSPPS = I2C1STAT1. 0x0299, Bit Pos..7:0 = 7:0. 0x0299, 7. = TXWE. 0x0299, 6. = . 0x0299, 5 = TXBE. 0x0299, 4.3 PORT[1:0] = R RXRE. 0x0299, 2.3 PORT[1:0] = CLRBF. 0x0299, 1.PIN[2:0] = . 0x0299, 0. = RXBF. 0x0299,",
    "47. Register Summary\n= . 0x029A, Name.U3CTSPPS = I2C1PIR. 0x029A, Bit Pos..7:0 = 7:0. 0x029A, 7. = CNTIF. 0x029A, 6. = ACKTIF. 0x029A, 5 = WRIF. 0x029A, 4.3 PORT[1:0] = ADRIF ADRIE. 0x029A, 2.3 PORT[1:0] = PCIF RSCIF. 0x029A, 1.PIN[2:0] = . 0x029A, 0. = SCIF SCIE. 0x029A,",
    "47. Register Summary\n= . 0x029B 0x029C, Name.U3CTSPPS = I2C1PIE I2C1BTO. 0x029B 0x029C, Bit Pos..7:0 = 7:0 7:0. 0x029B 0x029C, 7. = CNTIE TOREC. 0x029B 0x029C, 6. = ACKTIE. 0x029B 0x029C, 5 = . 0x029B 0x029C, 4.3 PORT[1:0] = WRIE. 0x029B 0x029C, 2.3 PORT[1:0] = PCIE TOTIME[5:0]. 0x029B 0x029C, 1.PIN[2:0] = RSCIE. 0x029B 0x029C, 0. = . 0x029B 0x029C,",
    "47. Register Summary\n= . 0x029D, Name.U3CTSPPS = I2C1BAUD. 0x029D, Bit Pos..7:0 = 7:0. 0x029D, 7. = . 0x029D, 6. = TOBY32. 0x029D, 5 = . 0x029D, 4.3 PORT[1:0] = BAUD[7:0]. 0x029D, 2.3 PORT[1:0] = . 0x029D, 1.PIN[2:0] = . 0x029D, 0. = . 0x029D,",
    "47. Register Summary\n= . 0x029E, Name.U3CTSPPS = I2C1CLK. 0x029E, Bit Pos..7:0 = 7:0. 0x029E, 7. = . 0x029E, 6. = . 0x029E, 5 = . 0x029E, 4.3 PORT[1:0] = . 0x029E, 2.3 PORT[1:0] = CLK[3:0]. 0x029E, 1.PIN[2:0] = . 0x029E, 0. = . 0x029E,",
    "47. Register Summary\n= . 0x029F, Name.U3CTSPPS = I2C1BTOC. 0x029F, Bit Pos..7:0 = 7:0. 0x029F, 7. = . 0x029F, 6. = . 0x029F, 5 = . 0x029F, 4.3 PORT[1:0] = . 0x029F, 2.3 PORT[1:0] = . 0x029F, 1.PIN[2:0] = BTOC[2:0]. 0x029F, 0. = . 0x029F,",
    "47. Register Summary\n= . 0x02A0, Name.U3CTSPPS = Reserved. 0x02A0, Bit Pos..7:0 = . 0x02A0, 7. = . 0x02A0, 6. = . 0x02A0, 5 = . 0x02A0, 4.3 PORT[1:0] = . 0x02A0, 2.3 PORT[1:0] = . 0x02A0, 1.PIN[2:0] = . 0x02A0, 0. = . 0x02A0,",
    "47. Register Summary\n= . 0x02A1, Name.U3CTSPPS = U1RXB. 0x02A1, Bit Pos..7:0 = 7:0. 0x02A1, 7. = . 0x02A1, 6. = . 0x02A1, 5 = . 0x02A1, 4.3 PORT[1:0] = RXB[7:0]. 0x02A1, 2.3 PORT[1:0] = . 0x02A1, 1.PIN[2:0] = . 0x02A1, 0. = . 0x02A1,",
    "47. Register Summary\n= . 0x02A2, Name.U3CTSPPS = U1RXCHK. 0x02A2, Bit Pos..7:0 = 7:0. 0x02A2, 7. = . 0x02A2, 6. = . 0x02A2, 5 = . 0x02A2, 4.3 PORT[1:0] = RXCHK[7:0]. 0x02A2, 2.3 PORT[1:0] = . 0x02A2, 1.PIN[2:0] = . 0x02A2, 0. = . 0x02A2,",
    "47. Register Summary\n= . 0x02A3, Name.U3CTSPPS = U1TXB. 0x02A3, Bit Pos..7:0 = 7:0. 0x02A3, 7. = . 0x02A3, 6. = . 0x02A3, 5 = . 0x02A3, 4.3 PORT[1:0] = TXB[7:0]. 0x02A3, 2.3 PORT[1:0] = . 0x02A3, 1.PIN[2:0] = . 0x02A3, 0. = . 0x02A3,",
    "47. Register Summary\n= . 0x02A4, Name.U3CTSPPS = U1TXCHK. 0x02A4, Bit Pos..7:0 = 7:0. 0x02A4, 7. = . 0x02A4, 6. = . 0x02A4, 5 = . 0x02A4, 4.3 PORT[1:0] = TXCHK[7:0]. 0x02A4, 2.3 PORT[1:0] = . 0x02A4, 1.PIN[2:0] = . 0x02A4, 0. = . 0x02A4,",
    "47. Register Summary\n= . 0x02A5, Name.U3CTSPPS = U1P1. 0x02A5, Bit Pos..7:0 = 7:0. 0x02A5, 7. = . 0x02A5, 6. = . 0x02A5, 5 = . 0x02A5, 4.3 PORT[1:0] = P1[7:0]. 0x02A5, 2.3 PORT[1:0] = . 0x02A5, 1.PIN[2:0] = . 0x02A5, 0. = . 0x02A5,  = . , Name.U3CTSPPS = . , Bit Pos..7:0 = 15:8. , 7. = . , 6. = . , 5 = . , 4.3 PORT[1:0] = P2[7:0]. , 2.3 PORT[1:0] = . , 1.PIN[2:0] = . , 0. = P1[8]. ,",
    "47. Register Summary\n= . 0x02A7, Name.U3CTSPPS = U1P2. 0x02A7, Bit Pos..7:0 = 7:0 15:8. 0x02A7, 7. = . 0x02A7, 6. = . 0x02A7, 5 = . 0x02A7, 4.3 PORT[1:0] = . 0x02A7, 2.3 PORT[1:0] = . 0x02A7, 1.PIN[2:0] = . 0x02A7, 0. = P2[8]. 0x02A7,",
    "47. Register Summary\n= . 0x02A9, Name.U3CTSPPS = U1P3. 0x02A9, Bit Pos..7:0 = 7:0 15:8. 0x02A9, 7. = . 0x02A9, 6. = . 0x02A9, 5 = . 0x02A9, 4.3 PORT[1:0] = P3[7:0]. 0x02A9, 2.3 PORT[1:0] = . 0x02A9, 1.PIN[2:0] = . 0x02A9, 0. = P3[8]. 0x02A9,",
    "47. Register Summary\n= . 0x02AB, Name.U3CTSPPS = U1CON0. 0x02AB, Bit Pos..7:0 = 7:0. 0x02AB, 7. = BRGS. 0x02AB, 6. = ABDEN. 0x02AB, 5 = TXEN. 0x02AB, 4.3 PORT[1:0] = RXEN. 0x02AB, 2.3 PORT[1:0] = MODE[3:0]. 0x02AB, 1.PIN[2:0] = MODE[3:0]. 0x02AB, 0. = . 0x02AB,",
    "47. Register Summary\n= . 0x02AC, Name.U3CTSPPS = U1CON1. 0x02AC, Bit Pos..7:0 = 7:0. 0x02AC, 7. = ON. 0x02AC, 6. = . 0x02AC, 5 = . 0x02AC, 4.3 PORT[1:0] = WUE RXBIMD. 0x02AC, 2.3 PORT[1:0] = . 0x02AC, 1.PIN[2:0] = BRKOVR SENDB. 0x02AC, 0. = BRKOVR SENDB. 0x02AC,",
    "47. Register Summary\n= . 0x02AD, Name.U3CTSPPS = U1CON2. 0x02AD, Bit Pos..7:0 = 7:0. 0x02AD, 7. = RUNOVF. 0x02AD, 6. = RXPOL. 0x02AD, 5 = STP[1:0]. 0x02AD, 4.3 PORT[1:0] = C0EN. 0x02AD, 2.3 PORT[1:0] = TXPOL. 0x02AD, 1.PIN[2:0] = FLO[1:0]. 0x02AD, 0. = FLO[1:0]. 0x02AD,",
    "47. Register Summary\n= . , Name.U3CTSPPS = . , Bit Pos..7:0 = 7:0. , 7. = . , 6. = . , 5 = . , 4.3 PORT[1:0] = BRG[7:0]. , 2.3 PORT[1:0] = . , 1.PIN[2:0] = . , 0. = . ,  = . 0x02AE, Name.U3CTSPPS = U1BRG. 0x02AE, Bit Pos..7:0 = 15:8. 0x02AE, 7. = . 0x02AE, 6. = . 0x02AE, 5 = . 0x02AE, 4.3 PORT[1:0] = BRG[15:8]. 0x02AE, 2.3 PORT[1:0] = . 0x02AE, 1.PIN[2:0] = . 0x02AE, 0. = . 0x02AE,",
    "47. Register Summary\n= . 0x02B0, Name.U3CTSPPS = U1FIFO. 0x02B0, Bit Pos..7:0 = 7:0. 0x02B0, 7. = TXWRE. 0x02B0, 6. = STPMD. 0x02B0, 5 = TXBE. 0x02B0, 4.3 PORT[1:0] = TXBF RXIDL. 0x02B0, 2.3 PORT[1:0] = XON. 0x02B0, 1.PIN[2:0] = RXBE. 0x02B0, 0. = RXBF. 0x02B0,",
    "47. Register Summary\n= . 0x02B1, Name.U3CTSPPS = U1UIR. 0x02B1, Bit Pos..7:0 = 7:0. 0x02B1, 7. = WUIF. 0x02B1, 6. = ABDIF. 0x02B1, 5 = . 0x02B1, 4.3 PORT[1:0] = . 0x02B1, 2.3 PORT[1:0] = ABDIE. 0x02B1, 1.PIN[2:0] = . 0x02B1, 0. = . 0x02B1,",
    "47. Register Summary\n= . 0x02B2, Name.U3CTSPPS = U1ERRIR. 0x02B2, Bit Pos..7:0 = 7:0. 0x02B2, 7. = TXMTIF. 0x02B2, 6. = PERIF. 0x02B2, 5 = ABDOVF. 0x02B2, 4.3 PORT[1:0] = CERIF FERIF. 0x02B2, 2.3 PORT[1:0] = RXBKIF. 0x02B2, 1.PIN[2:0] = RXFOIF. 0x02B2, 0. = TXCIF. 0x02B2,",
    "47. Register Summary\n= . 0x02B3, Name.U3CTSPPS = U1ERRIE. 0x02B3, Bit Pos..7:0 = 7:0. 0x02B3, 7. = TXMTIE. 0x02B3, 6. = PERIE. 0x02B3, 5 = ABDOVE. 0x02B3, 4.3 PORT[1:0] = CERIE FERIE. 0x02B3, 2.3 PORT[1:0] = RXBKIE. 0x02B3, 1.PIN[2:0] = RXFOIE. 0x02B3, 0. = TXCIE. 0x02B3,",
    "47. Register Summary\n= . 0x02B4, Name.U3CTSPPS = U2RXB. 0x02B4, Bit Pos..7:0 = 7:0. 0x02B4, 7. = . 0x02B4, 6. = . 0x02B4, 5 = . 0x02B4, 4.3 PORT[1:0] = RXB[7:0]. 0x02B4, 2.3 PORT[1:0] = . 0x02B4, 1.PIN[2:0] = . 0x02B4, 0. = . 0x02B4,",
    "47. Register Summary\n= . 0x02B5, Name.U3CTSPPS = Reserved. 0x02B5, Bit Pos..7:0 = . 0x02B5, 7. = . 0x02B5, 6. = . 0x02B5, 5 = . 0x02B5, 4.3 PORT[1:0] = . 0x02B5, 2.3 PORT[1:0] = . 0x02B5, 1.PIN[2:0] = . 0x02B5, 0. = . 0x02B5,",
    "47. Register Summary\n= . 0x02B6, Name.U3CTSPPS = U2TXB. 0x02B6, Bit Pos..7:0 = 7:0. 0x02B6, 7. = . 0x02B6, 6. = . 0x02B6, 5 = . 0x02B6, 4.3 PORT[1:0] = TXB[7:0]. 0x02B6, 2.3 PORT[1:0] = . 0x02B6, 1.PIN[2:0] = . 0x02B6, 0. = . 0x02B6,",
    "47. Register Summary\n= . 0x02B7, Name.U3CTSPPS = Reserved. 0x02B7, Bit Pos..7:0 = 7:0. 0x02B7, 7. = . 0x02B7, 6. = . 0x02B7, 5 = . 0x02B7, 4.3 PORT[1:0] = . 0x02B7, 2.3 PORT[1:0] = . 0x02B7, 1.PIN[2:0] = . 0x02B7, 0. = . 0x02B7,",
    "47. Register Summary\n= . 0x02B8, Name.U3CTSPPS = U2P1. 0x02B8, Bit Pos..7:0 = 15:8. 0x02B8, 7. = . 0x02B8, 6. = . 0x02B8, 5 = . 0x02B8, 4.3 PORT[1:0] = P1[7:0]. 0x02B8, 2.3 PORT[1:0] = . 0x02B8, 1.PIN[2:0] = . 0x02B8, 0. = . 0x02B8,",
    "47. Register Summary\n= . 0x02BA, Name.U3CTSPPS = U2P2. 0x02BA, Bit Pos..7:0 = 7:0. 0x02BA, 7. = . 0x02BA, 6. = . 0x02BA, 5 = . 0x02BA, 4.3 PORT[1:0] = P2[7:0]. 0x02BA, 2.3 PORT[1:0] = . 0x02BA, 1.PIN[2:0] = . 0x02BA, 0. = . 0x02BA,  = . , Name.U3CTSPPS = . , Bit Pos..7:0 = 15:8 7:0. , 7. = . , 6. = . , 5 = . , 4.3 PORT[1:0] = . , 2.3 PORT[1:0] = . , 1.PIN[2:0] = . , 0. = . ,",
    "47. Register Summary\n= . 0x02BC, Name.U3CTSPPS = U2P3. 0x02BC, Bit Pos..7:0 = 15:8. 0x02BC, 7. = . 0x02BC, 6. = . 0x02BC, 5 = . 0x02BC, 4.3 PORT[1:0] = P3[7:0]. 0x02BC, 2.3 PORT[1:0] = . 0x02BC, 1.PIN[2:0] = . 0x02BC, 0. = . 0x02BC,  = ",
    "47. Register Summary\n0x02BE, Name = U2CON0. 0x02BE, Bit Pos. = 7:0. 0x02BE, 7 = BRGS. 0x02BE, 6 = ABDEN. 0x02BE, 5 = TXEN. 0x02BE, 4 = RXEN. 0x02BE, 2 = MODE[3:0]. 0x02BE, 1 = . 0x02BE, 0 = . 0x02BF, Name = U2CON1. 0x02BF, Bit Pos. = 7:0. 0x02BF, 7 = ON. 0x02BF, 6 = . 0x02BF, 5 = . 0x02BF, 4 = WUE RXBIMD. 0x02BF, 2 = . 0x02BF, 1 = BRKOVR. 0x02BF, 0 = SENDB. 0x02C0, Name = U2CON2. 0x02C0, Bit Pos. = 7:0. 0x02C0, 7 = RUNOVF.",
    "47. Register Summary\n0x02C0, 6 = RXPOL. 0x02C0, 5 = STP[1:0]. 0x02C0, 4 = . 0x02C0, 2 = TXPOL. 0x02C0, 1 = FLO[1:0]. 0x02C0, 0 = . 0x02C1, Name = U2BRG. 0x02C1, Bit Pos. = 7:0. 0x02C1, 7 = . 0x02C1, 6 = . 0x02C1, 5 = . 0x02C1, 4 = BRG[7:0] BRG[15:8]. 0x02C1, 2 = . 0x02C1, 1 = . 0x02C1, 0 = . 0x02C3, Name = U2FIFO. 0x02C3, Bit Pos. = 15:8 7:0. 0x02C3, 7 = TXWRE. 0x02C3, 6 = STPMD.",
    "47. Register Summary\n0x02C3, 5 = TXBE. 0x02C3, 4 = TXBF RXIDL. 0x02C3, 2 = XON. 0x02C3, 1 = RXBE. 0x02C3, 0 = RXBF. 0x02C4, Name = U2UIR. 0x02C4, Bit Pos. = 7:0. 0x02C4, 7 = WUIF. 0x02C4, 6 = ABDIF. 0x02C4, 5 = . 0x02C4, 4 = . 0x02C4, 2 = ABDIE. 0x02C4, 1 = . 0x02C4, 0 = . 0x02C5, Name = U2ERRIR. 0x02C5, Bit Pos. = 7:0. 0x02C5, 7 = TXMTIF. 0x02C5, 6 = PERIF. 0x02C5, 5 = ABDOVF. 0x02C5, 4 = CERIF",
    "47. Register Summary\nFERIF. 0x02C5, 2 = RXBKIF. 0x02C5, 1 = RXFOIF. 0x02C5, 0 = . 0x02C6, Name = U2ERRIE. 0x02C6, Bit Pos. = 7:0. 0x02C6, 7 = TXMTIE. 0x02C6, 6 = PERIE. 0x02C6, 5 = ABDOVE. 0x02C6, 4 = CERIE FERIE. 0x02C6, 2 = RXBKIE. 0x02C6, 1 = RXFOIE. 0x02C6, 0 = . 0x02C7, Name = U3RXB. 0x02C7, Bit Pos. = 7:0. 0x02C7, 7 = . 0x02C7, 6 = . 0x02C7, 5 = . 0x02C7, 4 = RXB[7:0]. 0x02C7, 2 = .",
    "47. Register Summary\n0x02C7, 1 = . 0x02C7, 0 = . 0x02C8, Name = Reserved. 0x02C8, Bit Pos. = . 0x02C8, 7 = . 0x02C8, 6 = . 0x02C8, 5 = . 0x02C8, 4 = . 0x02C8, 2 = . 0x02C8, 1 = . 0x02C8, 0 = . 0x02C9, Name = U3TXB. 0x02C9, Bit Pos. = 7:0. 0x02C9, 7 = . 0x02C9, 6 = . 0x02C9, 5 = . 0x02C9, 4 = TXB[7:0]. 0x02C9, 2 = . 0x02C9, 1 = . 0x02C9, 0 = . 0x02CA, Name = Reserved. 0x02CA, Bit Pos. = . 0x02CA, 7 =",
    "47. Register Summary\n. 0x02CA, 6 = . 0x02CA, 5 = . 0x02CA, 4 = . 0x02CA, 2 = . 0x02CA, 1 = . 0x02CA, 0 = . 0x02CB, Name = U3P1. 0x02CB, Bit Pos. = 7:0 15:8. 0x02CB, 7 = . 0x02CB, 6 = . 0x02CB, 5 = . 0x02CB, 4 = P1[7:0]. 0x02CB, 2 = . 0x02CB, 1 = . 0x02CB, 0 = . 0x02CD, Name = U3P2. 0x02CD, Bit Pos. = 7:0 15:8. 0x02CD, 7 = . 0x02CD, 6 = . 0x02CD, 5 = . 0x02CD, 4 = P2[7:0]. 0x02CD, 2 = . 0x02CD, 1 = .",
    "47. Register Summary\n0x02CD, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = . 0x02CF, Name = U3P3. 0x02CF, Bit Pos. = . 0x02CF, 7 = . 0x02CF, 6 = . 0x02CF, 5 = . 0x02CF, 4 = P3[7:0]. 0x02CF, 2 = . 0x02CF, 1 = . 0x02CF, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = . 0x02D1, Name = U3CON0. 0x02D1, Bit Pos. = 7:0. 0x02D1, 7 = BRGS. 0x02D1, 6 = ABDEN.",
    "47. Register Summary\n0x02D1, 5 = TXEN. 0x02D1, 4 = RXEN. 0x02D1, 2 = MODE[3:0]. 0x02D1, 1 = MODE[3:0]. 0x02D1, 0 = MODE[3:0]. 0x02D2, Name = U3CON1. 0x02D2, Bit Pos. = 7:0. 0x02D2, 7 = ON. 0x02D2, 6 = . 0x02D2, 5 = . 0x02D2, 4 = WUE RXBIMD. 0x02D2, 2 = . 0x02D2, 1 = BRKOVR. 0x02D2, 0 = SENDB. 0x02D3, Name = U3CON2. 0x02D3, Bit Pos. = 7:0. 0x02D3, 7 = RUNOVF. 0x02D3, 6 = RXPOL. 0x02D3, 5 =",
    "47. Register Summary\nSTP[1:0]. 0x02D3, 4 = STP[1:0]. 0x02D3, 2 = TXPOL. 0x02D3, 1 = FLO[1:0]. 0x02D3, 0 = . 0x02D4, Name = U3BRG. 0x02D4, Bit Pos. = 7:0 15:8. 0x02D4, 7 = . 0x02D4, 6 = . 0x02D4, 5 = . 0x02D4, 4 = BRG[7:0] BRG[15:8]. 0x02D4, 2 = . 0x02D4, 1 = . 0x02D4, 0 = . 0x02D6, Name = U3FIFO. 0x02D6, Bit Pos. = 7:0. 0x02D6, 7 = TXWRE. 0x02D6, 6 = STPMD. 0x02D6, 5 = TXBE.",
    "47. Register Summary\n0x02D6, 4 = TXBF RXIDL. 0x02D6, 2 = XON. 0x02D6, 1 = RXBE. 0x02D6, 0 = RXBF. 0x02D7, Name = U3UIR. 0x02D7, Bit Pos. = 7:0. 0x02D7, 7 = WUIF. 0x02D7, 6 = ABDIF. 0x02D7, 5 = . 0x02D7, 4 = . 0x02D7, 2 = ABDIE. 0x02D7, 1 = . 0x02D7, 0 = . 0x02D8, Name = U3ERRIR. 0x02D8, Bit Pos. = 7:0. 0x02D8, 7 = TXMTIF. 0x02D8, 6 = PERIF. 0x02D8, 5 = ABDOVF. 0x02D8, 4 = CERIF FERIF. 0x02D8, 2",
    "47. Register Summary\n= RXBKIF. 0x02D8, 1 = RXFOIF. 0x02D8, 0 = . 0x02D9, Name = U3ERRIE. 0x02D9, Bit Pos. = 7:0. 0x02D9, 7 = TXMTIE. 0x02D9, 6 = PERIE. 0x02D9, 5 = ABDOVE. 0x02D9, 4 = CERIE FERIE. 0x02D9, 2 = RXBKIE. 0x02D9, 1 = RXFOIE. 0x02D9, 0 = . 0x02DA, Name = . 0x02DA, Bit Pos. = . 0x02DA, 7 = . 0x02DA, 6 = . 0x02DA, 5 = . 0x02DA, 4 = . 0x02DA, 2 = . 0x02DA, 1 = . 0x02DA, 0 = . ... 0x02FF, Name = Reserved. ...",
    "47. Register Summary\n0x02FF, Bit Pos. = . ... 0x02FF, 7 = . ... 0x02FF, 6 = . ... 0x02FF, 5 = . ... 0x02FF, 4 = . ... 0x02FF, 2 = . ... 0x02FF, 1 = . ... 0x02FF, 0 = . 0x0300, Name = SMT1TMR. 0x0300, Bit Pos. = 7:0. 0x0300, 7 = . 0x0300, 6 = . 0x0300, 5 = . 0x0300, 4 = TMR[7:0] TMR[15:8]. 0x0300, 2 = . 0x0300, 1 = . 0x0300, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit",
    "47. Register Summary\nPos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = TMR[23:16]. , 2 = . , 1 = . , 0 = . 0x0303, Name = SMT1CPR. 0x0303, Bit Pos. = 7:0. 0x0303, 7 = . 0x0303, 6 = . 0x0303, 5 = . 0x0303, 4 = CPR[7:0]. 0x0303, 2 = . 0x0303, 1 = . 0x0303, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = CPR[23:16]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = CPR[15:8]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. =",
    "47. Register Summary\n7:0. , 7 = . , 6 = . , 5 = . , 4 = CPW[7:0]. , 2 = . , 1 = . , 0 = . 0x0306, Name = SMT1CPW. 0x0306, Bit Pos. = 15:8. 0x0306, 7 = . 0x0306, 6 = . 0x0306, 5 = . 0x0306, 4 = CPW[15:8]. 0x0306, 2 = . 0x0306, 1 = . 0x0306, 0 = . , Name = . , Bit Pos. = 23:16 7:0. , 7 = . , 6 = . , 5 = . , 4 = CPW[23:16]. , 2 = . , 1 = . , 0 = . 0x0309, Name = SMT1PR. 0x0309, Bit Pos. = 15:8. 0x0309, 7 = . 0x0309, 6 = . 0x0309, 5 = . 0x0309, 4",
    "47. Register Summary\n= PR[7:0] PR[15:8]. 0x0309, 2 = . 0x0309, 1 = . 0x0309, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = PR[23:16]. , 2 = . , 1 = . , 0 = . 0x030C, Name = SMT1CON0. 0x030C, Bit Pos. = 7:0. 0x030C, 7 = EN. 0x030C, 6 = . 0x030C, 5 = STP. 0x030C, 4 = WPOL SPOL. 0x030C, 2 = CPOL. 0x030C, 1 = PS[1:0]. 0x030C, 0 = PS[1:0]. 0x030D, Name = SMT1CON1. 0x030D, Bit Pos. = 7:0. 0x030D, 7 = GO. 0x030D, 6 = REPEAT.",
    "47. Register Summary\n0x030D, 5 = . 0x030D, 4 = . 0x030D, 2 = MODE[3:0]. 0x030D, 1 = . 0x030D, 0 = . 0x030E, Name = SMT1STAT. 0x030E, Bit Pos. = 7:0. 0x030E, 7 = CPRUP. 0x030E, 6 = CPWUP. 0x030E, 5 = RST. 0x030E, 4 = . 0x030E, 2 = TS. 0x030E, 1 = WS. 0x030E, 0 = AS. 0x030F, Name = SMT1CLK. 0x030F, Bit Pos. = 7:0. 0x030F, 7 = . 0x030F, 6 = . 0x030F, 5 = . 0x030F, 4 = . 0x030F, 2 = CSEL[3:0]. 0x030F, 1 = . 0x030F, 0 =",
    "47. Register Summary\n. 0x0310, Name = SMT1SIG. 0x0310, Bit Pos. = 7:0. 0x0310, 7 = . 0x0310, 6 = . 0x0310, 5 = . 0x0310, 4 = . 0x0310, 2 = SSEL[4:0]. 0x0310, 1 = . 0x0310, 0 = . 0x0311, Name = SMT1WIN. 0x0311, Bit Pos. = 7:0. 0x0311, 7 = . 0x0311, 6 = . 0x0311, 5 = . 0x0311, 4 = . 0x0311, 2 = WSEL[4:0]. 0x0311, 1 = . 0x0311, 0 = . 0x0312, Name = TMR1. 0x0312, Bit Pos. = 7:0. 0x0312, 7 = . 0x0312, 6 = . 0x0312, 5 =",
    "47. Register Summary\n. 0x0312, 4 = TMR1[7:0]. 0x0312, 2 = . 0x0312, 1 = . 0x0312, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = TMR1[15:8]. , 2 = . , 1 = . , 0 = . 0x0314, Name = T1CON. 0x0314, Bit Pos. = 7:0. 0x0314, 7 = . 0x0314, 6 = . 0x0314, 5 = GTM. 0x0314, 4 = CKPS[1:0] GSPM. 0x0314, 2 = SYNC. 0x0314, 1 = RD16. 0x0314, 0 = ON. 0x0315, Name = T1GCON. 0x0315, Bit Pos. = 7:0. 0x0315, 7 = GE. 0x0315, 6 = GPOL.",
    "47. Register Summary\n0x0315, 5 = . 0x0315, 4 = GGO/DONE. 0x0315, 2 = GVAL GSS[4:0]. 0x0315, 1 = . 0x0315, 0 = . 0x0316 0x0317, Name = T1GATE T1CLK. 0x0316 0x0317, Bit Pos. = 7:0 7:0. 0x0316 0x0317, 7 = . 0x0316 0x0317, 6 = . 0x0316 0x0317, 5 = . 0x0316 0x0317, 4 = . 0x0316 0x0317, 2 = CS[4:0]. 0x0316 0x0317, 1 = . 0x0316 0x0317, 0 = . 0x0318, Name = TMR0L. 0x0318, Bit Pos. = 7:0. 0x0318, 7 = . 0x0318, 6 =",
    "47. Register Summary\n. 0x0318, 5 = . 0x0318, 4 = TMR0L[7:0]. 0x0318, 2 = . 0x0318, 1 = . 0x0318, 0 = . 0x0319, Name = TMR0H. 0x0319, Bit Pos. = . 0x0319, 7 = . 0x0319, 6 = . 0x0319, 5 = . 0x0319, 4 = TMR0H[7:0]. 0x0319, 2 = . 0x0319, 1 = . 0x0319, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = . 0x031A, Name = T0CON0. 0x031A, Bit Pos. = 7:0. 0x031A, 7 = EN. 0x031A, 6 = . 0x031A, 5 =",
    "47. Register Summary\nOUT. 0x031A, 4 = MD16. 0x031A, 2 = OUTPS[3:0]. 0x031A, 1 = . 0x031A, 0 = . 0x031B, Name = T0CON1. 0x031B, Bit Pos. = 7:0. 0x031B, 7 = . 0x031B, 6 = CS[2:0]. 0x031B, 5 = . 0x031B, 4 = ASYNC. 0x031B, 2 = CKPS[3:0]. 0x031B, 1 = . 0x031B, 0 = ",
    "47. Register Summary\nAddress 0x031D, Name = T2PR. Address 0x031D, Bit Pos. = 7:0. Address 0x031D, 7 = . Address 0x031D, 6 = . Address 0x031D, 5 = . Address 0x031D,  = 4 T2PR[7:0]. Address 0x031D, 2 = . Address 0x031D, 1 = . Address 0x031D, 0 = . 0x031E, Name = T2CON. 0x031E, Bit Pos. = 7:0. 0x031E, 7 = ON. 0x031E, 6 = . 0x031E, 5 = CKPS[2:0]. 0x031E,",
    "47. Register Summary\n= . 0x031E, 2 = OUTPS[3:0]. 0x031E, 1 = . 0x031E, 0 = . 0x031F, Name = T2HLT. 0x031F, Bit Pos. = 7:0. 0x031F, 7 = PSYNC. 0x031F, 6 = CPOL. 0x031F, 5 = CSYNC. 0x031F,  = . 0x031F, 2 = MODE[4:0]. 0x031F, 1 = . 0x031F, 0 = . 0x0320, Name = T2CLKCON. 0x0320, Bit Pos. = 7:0. 0x0320, 7 = . 0x0320, 6 = . 0x0320, 5 = . 0x0320,",
    "47. Register Summary\n= . 0x0320, 2 = CS[3:0]. 0x0320, 1 = . 0x0320, 0 = . 0x0321, Name = T2RST. 0x0321, Bit Pos. = 7:0. 0x0321, 7 = . 0x0321, 6 = . 0x0321, 5 = . 0x0321,  = . 0x0321, 2 = RSEL[4:0]. 0x0321, 1 = . 0x0321, 0 = . 0x0322, Name = Reserved. 0x0322, Bit Pos. = . 0x0322, 7 = . 0x0322, 6 = . 0x0322, 5 = . 0x0322,  = . 0x0322, 2 = . 0x0322, 1 = . 0x0322, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . ,",
    "47. Register Summary\n= TMR3[7:0]. , 2 = . , 1 = . , 0 = . 0x0323, Name = TMR3. 0x0323, Bit Pos. = 15:8. 0x0323, 7 = . 0x0323, 6 = . 0x0323, 5 = . 0x0323,  = TMR3[15:8]. 0x0323, 2 = . 0x0323, 1 = . 0x0323, 0 = . 0x0325, Name = T3CON. 0x0325, Bit Pos. = 7:0. 0x0325, 7 = . 0x0325, 6 = . 0x0325, 5 = CKPS[1:0]. 0x0325,",
    "47. Register Summary\n= . 0x0325, 2 = SYNC. 0x0325, 1 = RD16. 0x0325, 0 = ON. 0x0326, Name = T3GCON. 0x0326, Bit Pos. = 7:0. 0x0326, 7 = GE. 0x0326, 6 = GPOL. 0x0326, 5 = GTM. 0x0326,  = GSPM GGO/DONE. 0x0326, 2 = GVAL. 0x0326, 1 = . 0x0326, 0 = . 0x0327, Name = T3GATE. 0x0327, Bit Pos. = 7:0 7:0. 0x0327, 7 = . 0x0327, 6 = . 0x0327, 5 = . 0x0327,",
    "47. Register Summary\n= . 0x0327, 2 = GSS[4:0]. 0x0327, 1 = . 0x0327, 0 = . 0x0328 0x0329, Name = T3CLK. 0x0328 0x0329, Bit Pos. = . 0x0328 0x0329, 7 = . 0x0328 0x0329, 6 = . 0x0328 0x0329, 5 = . 0x0328 0x0329,  = T4TMR[7:0]. 0x0328 0x0329, 2 = CS[4:0]. 0x0328 0x0329, 1 = . 0x0328 0x0329, 0 = . 0x032A, Name = T4TMR T4PR. 0x032A, Bit Pos. = 7:0 7:0. 0x032A, 7 = . 0x032A, 6 = . 0x032A, 5 = . 0x032A,",
    "47. Register Summary\n= T4PR[7:0]. 0x032A, 2 = . 0x032A, 1 = . 0x032A, 0 = . 0x032B, Name = T4CON. 0x032B, Bit Pos. = 7:0. 0x032B, 7 = ON. 0x032B, 6 = . 0x032B, 5 = CKPS[2:0]. 0x032B,  = . 0x032B, 2 = OUTPS[3:0]. 0x032B, 1 = . 0x032B, 0 = . 0x032C, Name = T4HLT. 0x032C, Bit Pos. = 7:0. 0x032C, 7 = PSYNC. 0x032C, 6 = CPOL. 0x032C, 5 = CSYNC. 0x032C,",
    "47. Register Summary\n= . 0x032C, 2 = MODE[4:0]. 0x032C, 1 = . 0x032C, 0 = . 0x032D, Name = T4CLKCON. 0x032D, Bit Pos. = 7:0. 0x032D, 7 = . 0x032D, 6 = . 0x032D, 5 = . 0x032D,  = . 0x032D, 2 = CS[3:0]. 0x032D, 1 = . 0x032D, 0 = . 0x032E, Name = T4RST. 0x032E, Bit Pos. = 7:0. 0x032E, 7 = . 0x032E, 6 = . 0x032E, 5 = . 0x032E,",
    "47. Register Summary\n= . 0x032E, 2 = RSEL[4:0]. 0x032E, 1 = . 0x032E, 0 = . 0x032F, Name = . 0x032F, Bit Pos. = . 0x032F, 7 = . 0x032F, 6 = . 0x032F, 5 = . 0x032F,  = . 0x032F, 2 = . 0x032F, 1 = . 0x032F, 0 = . ... 0x033F, Name = Reserved. ... 0x033F, Bit Pos. = . ... 0x033F, 7 = . ... 0x033F, 6 = . ... 0x033F, 5 = . ... 0x033F,",
    "47. Register Summary\n= . ... 0x033F, 2 = . ... 0x033F, 1 = . ... 0x033F, 0 = . 0x0340, Name = CCPR1. 0x0340, Bit Pos. = 7:0. 0x0340, 7 = . 0x0340, 6 = . 0x0340, 5 = . 0x0340,  = CCPR[7:0]. 0x0340, 2 = . 0x0340, 1 = . 0x0340, 0 = . 0x0342, Name = CCP1CON. 0x0342, Bit Pos. = 15:8 7:0. 0x0342, 7 = EN. 0x0342, 6 = . 0x0342, 5 = OUT. 0x0342,",
    "47. Register Summary\n= CCPR[15:8] FMT. 0x0342, 2 = . 0x0342, 1 = . 0x0342, 0 = . 0x0343, Name = CCP1CAP. 0x0343, Bit Pos. = 7:0. 0x0343, 7 = . 0x0343, 6 = . 0x0343, 5 = . 0x0343,  = . 0x0343, 2 = MODE[3:0]. 0x0343, 1 = CTS[2:0]. 0x0343, 0 = . 0x0344, Name = . 0x0344, Bit Pos. = . 0x0344, 7 = . 0x0344, 6 = . 0x0344, 5 = . 0x0344,",
    "47. Register Summary\n= . 0x0344, 2 = . 0x0344, 1 = . 0x0344, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ...,  = . ..., 2 = . ..., 1 = . ..., 0 = . 0x034B 0x034C, Name = CCPTMRS0. 0x034B 0x034C, Bit Pos. = 7:0. 0x034B 0x034C, 7 = . 0x034B 0x034C, 6 = . 0x034B 0x034C, 5 = C3TSEL[1:0]. 0x034B 0x034C,",
    "47. Register Summary\n= . 0x034B 0x034C, 2 = C2TSEL[1:0]. 0x034B 0x034C, 1 = C1TSEL[1:0]. 0x034B 0x034C, 0 = . 0x034D, Name = Reserved. 0x034D, Bit Pos. = . 0x034D, 7 = . 0x034D, 6 = . 0x034D, 5 = . 0x034D,  = . 0x034D, 2 = . 0x034D, 1 = . 0x034D, 0 = . 0x034E, Name = CRCDATA. 0x034E, Bit Pos. = 15:8. 0x034E, 7 = . 0x034E, 6 = . 0x034E, 5 = . 0x034E,",
    "47. Register Summary\n= CRCDATAH[7:0]. 0x034E, 2 = . 0x034E, 1 = . 0x034E, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . ,  = CRCDATAU[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . ,  = CRCDATAT[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . ,  = CRCOUTL[7:0]. , 2 = . , 1 = . , 0 = . 0x0352, Name = CRCOUT. 0x0352, Bit Pos. = 15:8. 0x0352, 7 = . 0x0352, 6 = . 0x0352, 5 = . 0x0352,",
    "47. Register Summary\n= CRCOUTH[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . ,  = CRCOUTU[7:0]. , 2 = . , 1 = . , 0 = . 0x0352, Name = . 0x0352, Bit Pos. = 7:0. 0x0352, 7 = . 0x0352, 6 = . 0x0352, 5 = . 0x0352,  = CRCOUTT[7:0] CRCSHIFTL[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = . , Name = CRCSHIFT. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . ,",
    "47. Register Summary\n= CRCSHIFTH[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . ,  = CRCSHIFTU[7:0] CRCSHIFTT[7:0]. , 2 = . , 1 = . , 0 = . 0x0352, Name = CRCXOR. 0x0352, Bit Pos. = 7:0 15:8. 0x0352, 7 = . 0x0352, 6 = . 0x0352, 5 = . 0x0352,",
    "47. Register Summary\n= CRCXORL[7:0]. 0x0352, 2 = . 0x0352, 1 = . 0x0352, 0 = . 0x0356, Name = CRCCON0. 0x0356, Bit Pos. = 23:16 31:24 7:0. 0x0356, 7 = . 0x0356, 6 = . 0x0356, 5 = . 0x0356,  = CRCXORH[7:0] CRCXORU[7:0] CRCXORT[7:0]. 0x0356, 2 = . 0x0356, 1 = . 0x0356, 0 = . 0x0358, Name = CRCCON2. 0x0358, Bit Pos. = 7:0. 0x0358, 7 = EN. 0x0358, 6 = . 0x0358, 5 = . 0x0358,",
    "47. Register Summary\n= . 0x0358, 2 = . 0x0358, 1 = . 0x0358, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . ,  = . , 2 = . , 1 = . , 0 = . 0x0359, Name = Reserved. 0x0359, Bit Pos. = . 0x0359, 7 = . 0x0359, 6 = . 0x0359, 5 = . 0x0359,  = . 0x0359, 2 = . 0x0359, 1 = . 0x0359, 0 = . 0x035A, Name = SCANLADR. 0x035A, Bit Pos. = 15:8. 0x035A, 7 = . 0x035A, 6 = GO. 0x035A, 5 = BUSY. 0x035A,",
    "47. Register Summary\n= ACCM. 0x035A, 2 = SETUP[1:0]. 0x035A, 1 = SHIFTM. 0x035A, 0 = FULL. 0x0357, Name = CRCCON1. 0x0357, Bit Pos. = 7:0. 0x0357, 7 = . 0x0357, 6 = . 0x0357, 5 = . 0x0357,  = . 0x0357, 2 = PLEN[4:0]. 0x0357, 1 = . 0x0357, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . ,  = . , 2 = DLEN[4:0]. , 1 = . , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . ,  = SCANLADRL[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . ,",
    "47. Register Summary\n= SCANLADRH[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 23:16 7:0. , 7 = . , 6 = . , 5 = . ,  = . , 2 = SCANLADRU[5:0]. , 1 = . , 0 = . 0x035D, Name = SCANHADR. 0x035D, Bit Pos. = 15:8. 0x035D, 7 = . 0x035D, 6 = . 0x035D, 5 = . 0x035D,  = SCANHADRL[7:0] SCANHADRH[7:0]. 0x035D, 2 = . 0x035D, 1 = . 0x035D, 0 = . 0x0360, Name = SCANCON0. 0x0360, Bit Pos. = 23:16 7:0. 0x0360, 7 = EN. 0x0360, 6 = TRIGEN. 0x0360, 5 = SGO. 0x0360,",
    "47. Register Summary\n= . 0x0360, 2 = SCANHADRU[5:0] MREG. 0x0360, 1 = BURSTMD. 0x0360, 0 = BUSY. 0x0361, Name = SCANTRIG. 0x0361, Bit Pos. = 7:0. 0x0361, 7 = . 0x0361, 6 = . 0x0361, 5 = . 0x0361,  = . 0x0361, 2 = TSEL[3:0]. 0x0361, 1 = . 0x0361, 0 = . 0x0362, Name = . 0x0362, Bit Pos. = . 0x0362, 7 = . 0x0362, 6 = . 0x0362, 5 = . 0x0362,",
    "47. Register Summary\n= . 0x0362, 2 = . 0x0362, 1 = . 0x0362, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ...,  = . ..., 2 = . ..., 1 = . ..., 0 = . 0x0366, Name = . 0x0366, Bit Pos. = . 0x0366, 7 = . 0x0366, 6 = . 0x0366, 5 = . 0x0366,  = . 0x0366, 2 = . 0x0366, 1 = . 0x0366, 0 = ",
    "47. Register Summary\n0x0367, Name = IPR0. 0x0367, Bit Pos. = 7:0. 0x0367, 7 = IOCIP. 0x0367, 6 = CRCIP. 0x0367, 5 = CLC1IP. 0x0367, 4 = NVMIP. 0x0367, 3 = CSWIP. 0x0367, 2 = OSFIP. 0x0367, 1 = HLVDIP. 0x0367, 0 = SWIP. 0x0368, Name = IPR1. 0x0368, Bit Pos. = 7:0. 0x0368, 7 = SMT1PWAIP. 0x0368, 6 = SMT1PRAIP. 0x0368, 5 = SMT1IP. 0x0368, 4 = CM1IP. 0x0368, 3 = ACTIP. 0x0368, 2 = ADIP. 0x0368, 1 = ZCDIP. 0x0368, 0 = INT0IP.",
    "47. Register Summary\n0x0369, Name = IPR2. 0x0369, Bit Pos. = 7:0. 0x0369, 7 = DMA1AIP. 0x0369, 6 = DMA1ORIP. 0x0369, 5 = DMA1DCNTIP. 0x0369, 4 = DMA1SCNTIP. 0x0369, 3 = . 0x0369, 2 = . 0x0369, 1 = . 0x0369, 0 = ADTIP. 0x036A, Name = IPR3. 0x036A, Bit Pos. = 7:0. 0x036A, 7 = TMR0IP. 0x036A, 6 = CCP1IP. 0x036A, 5 = TMR1GIP. 0x036A, 4 = TMR1IP. 0x036A, 3 = TMR2IP. 0x036A, 2 = SPI1IP. 0x036A, 1 = SPI1TXIP.",
    "47. Register Summary\n0x036A, 0 = SPI1RXIP. 0x036B, Name = IPR4. 0x036B, Bit Pos. = 7:0. 0x036B, 7 = PWM1IP. 0x036B, 6 = PWM1PIP. 0x036B, 5 = TMR3GIP. 0x036B, 4 = TMR3IP. 0x036B, 3 = U1IP. 0x036B, 2 = U1EIP. 0x036B, 1 = U1TXIP. 0x036B, 0 = U1RXIP. 0x036C, Name = IPR5. 0x036C, Bit Pos. = 7:0. 0x036C, 7 = PWM2IP. 0x036C, 6 = PWM2PIP. 0x036C, 5 = CLC2IP. 0x036C, 4 = CMIP. 0x036C, 3 = . 0x036C, 2 =",
    "47. Register Summary\nSPI2IP. 0x036C, 1 = SPI2TXIP. 0x036C, 0 = SPI2RXIP. 0x036D, Name = IPR6. 0x036D, Bit Pos. = 7:0. 0x036D, 7 = DMA2AIP. 0x036D, 6 = DMA2ORIP. 0x036D, 5 = DMA2DCNTIP. 0x036D, 4 = DMA2SCNTIP. 0x036D, 3 = NCO1IP. 0x036D, 2 = CWG1IP. 0x036D, 1 = . 0x036D, 0 = INT1IP. 0x036E, Name = IPR7. 0x036E, Bit Pos. = 7:0. 0x036E, 7 = PWM3IP. 0x036E, 6 = PWM3PIP. 0x036E, 5 = CLC3IP. 0x036E, 4 = . 0x036E, 3",
    "47. Register Summary\n= I2C1EIP. 0x036E, 2 = I2C1IP. 0x036E, 1 = I2C1TXIP. 0x036E, 0 = I2C1RXIP. 0x036F, Name = IPR8. 0x036F, Bit Pos. = 7:0. 0x036F, 7 = SCANIP. 0x036F, 6 = . 0x036F, 5 = CLC4IP. 0x036F, 4 = . 0x036F, 3 = U2IP. 0x036F, 2 = U2EIP. 0x036F, 1 = U2TXIP. 0x036F, 0 = U2RXIP. 0x0370, Name = IPR9. 0x0370, Bit Pos. = 7:0. 0x0370, 7 = DMA3AIP. 0x0370, 6 = DMA3ORIP. 0x0370, 5 = DMA3DCNTIP. 0x0370, 4 =",
    "47. Register Summary\nDMA3SCNTIP. 0x0370, 3 = U3IP. 0x0370, 2 = U3EIP. 0x0370, 1 = U3TXIP. 0x0370, 0 = U3RXIP. 0x0371, Name = IPR10. 0x0371, Bit Pos. = 7:0. 0x0371, 7 = DMA4AIP. 0x0371, 6 = DMA4ORIP. 0x0371, 5 = DMA4DCNTIP. 0x0371, 4 = DMA4SCNTIP. 0x0371, 3 = TMR4IP. 0x0371, 2 = . 0x0371, 1 = . 0x0371, 0 = INT2IP. 0x0372, Name = Reserved. 0x0372, Bit Pos. = . 0x0372, 7 = . 0x0372, 6 = . 0x0372, 5 = . 0x0372, 4 = .",
    "47. Register Summary\n0x0372, 3 = . 0x0372, 2 = . 0x0372, 1 = . 0x0372, 0 = . 0x0373, Name = STATUS_CSHAD. 0x0373, Bit Pos. = 7:0. 0x0373, 7 = . 0x0373, 6 = TO. 0x0373, 5 = PD. 0x0373, 4 = N. 0x0373, 3 = OV. 0x0373, 2 = Z. 0x0373, 1 = DC. 0x0373, 0 = C. 0x0374, Name = WREG_CSHAD. 0x0374, Bit Pos. = 7:0. 0x0374, 7 = . 0x0374, 6 = . 0x0374, 5 = . 0x0374, 4 = WREG[7:0]. 0x0374, 3 = . 0x0374, 2 = . 0x0374, 1 = . 0x0374, 0 = .",
    "47. Register Summary\n0x0375, Name = BSR_CSHAD. 0x0375, Bit Pos. = 7:0. 0x0375, 7 = . 0x0375, 6 = . 0x0375, 5 = . 0x0375, 4 = . 0x0375, 3 = BSR[5:0]. 0x0375, 2 = . 0x0375, 1 = . 0x0375, 0 = . 0x0376, Name = SHADCON. 0x0376, Bit Pos. = 7:0. 0x0376, 7 = . 0x0376, 6 = . 0x0376, 5 = . 0x0376, 4 = . 0x0376, 3 = . 0x0376, 2 = . 0x0376, 1 = . 0x0376, 0 = SHADLO. 0x0377, Name = STATUS_SHAD. 0x0377, Bit Pos. = 7:0. 0x0377, 7 = .",
    "47. Register Summary\n0x0377, 6 = TO. 0x0377, 5 = PD. 0x0377, 4 = N. 0x0377, 3 = OV. 0x0377, 2 = Z. 0x0377, 1 = DC. 0x0377, 0 = C. 0x0378, Name = WREG_SHAD. 0x0378, Bit Pos. = 7:0. 0x0378, 7 = . 0x0378, 6 = . 0x0378, 5 = . 0x0378, 4 = WREG[7:0]. 0x0378, 3 = . 0x0378, 2 = . 0x0378, 1 = . 0x0378, 0 = . 0x0379, Name = BSR_SHAD. 0x0379, Bit Pos. = 7:0. 0x0379, 7 = . 0x0379, 6 = . 0x0379, 5 = . 0x0379, 4 = . 0x0379, 3 =",
    "47. Register Summary\nBSR[5:0]. 0x0379, 2 = . 0x0379, 1 = . 0x0379, 0 = . 0x037A, Name = PCLAT_SHAD. 0x037A, Bit Pos. = 7:0 15:8. 0x037A, 7 = . 0x037A, 6 = . 0x037A, 5 = . 0x037A, 4 = PCLATH[7:0]. 0x037A, 3 = . 0x037A, 2 = PCLATU[4:0]. 0x037A, 1 = . 0x037A, 0 = . 0x037C, Name = FSR0_SHAD. 0x037C, Bit Pos. = 7:0 15:8. 0x037C, 7 = . 0x037C, 6 = . 0x037C, 5 = . 0x037C, 4 = FSRL[7:0]. 0x037C, 3 = . 0x037C, 2 =",
    "47. Register Summary\nFSRH[5:0]. 0x037C, 1 = . 0x037C, 0 = . 0x037E, Name = FSR1_SHAD. 0x037E, Bit Pos. = 7:0 15:8. 0x037E, 7 = . 0x037E, 6 = . 0x037E, 5 = . 0x037E, 4 = FSRL[7:0]. 0x037E, 3 = FSRH[5:0]. 0x037E, 2 = . 0x037E, 1 = . 0x037E, 0 = . 0x0380, Name = FSR2_SHAD. 0x0380, Bit Pos. = 7:0. 0x0380, 7 = . 0x0380, 6 = . 0x0380, 5 = . 0x0380, 4 = FSRL[7:0]. 0x0380, 3 = . 0x0380, 2 = FSRH[5:0].",
    "47. Register Summary\n0x0380, 1 = . 0x0380, 0 = . , Name = PROD_SHAD. , Bit Pos. = 15:8 7:0. , 7 = . , 6 = . , 5 = . , 4 = PROD[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x0382, Name = . 0x0382, Bit Pos. = 15:8. 0x0382, 7 = . 0x0382, 6 = . 0x0382, 5 = . 0x0382, 4 = . 0x0382, 3 = . 0x0382, 2 = . 0x0382, 1 = . 0x0382, 0 = . 0x0384, Name = . 0x0384, Bit Pos. = . 0x0384, 7 = . 0x0384, 6 = . 0x0384, 5 = . 0x0384, 4 = PROD[15:8]. 0x0384, 3 = .",
    "47. Register Summary\n0x0384, 2 = . 0x0384, 1 = . 0x0384, 0 = . ... 0x03BB, Name = Reserved. ... 0x03BB, Bit Pos. = . ... 0x03BB, 7 = . ... 0x03BB, 6 = . ... 0x03BB, 5 = . ... 0x03BB, 4 = . ... 0x03BB, 3 = . ... 0x03BB, 2 = . ... 0x03BB, 1 = . ... 0x03BB, 0 = . 0x03BC, Name = CWG1CLK. 0x03BC, Bit Pos. = 7:0. 0x03BC, 7 = . 0x03BC, 6 = . 0x03BC, 5 = . 0x03BC, 4 = . 0x03BC, 3 = . 0x03BC, 2 = . 0x03BC, 1 = . 0x03BC, 0 =",
    "47. Register Summary\nCS. 0x03BD, Name = CWG1ISM. 0x03BD, Bit Pos. = 7:0. 0x03BD, 7 = . 0x03BD, 6 = . 0x03BD, 5 = . 0x03BD, 4 = . 0x03BD, 3 = . 0x03BD, 2 = . 0x03BD, 1 = ISM[3:0]. 0x03BD, 0 = . 0x03BE, Name = CWG1DBR. 0x03BE, Bit Pos. = 7:0. 0x03BE, 7 = . 0x03BE, 6 = . 0x03BE, 5 = . 0x03BE, 4 = . 0x03BE, 3 = . 0x03BE, 2 = DBR[5:0]. 0x03BE, 1 = . 0x03BE, 0 = . 0x03BF 0x03C0, Name = CWG1DBF CWG1CON0.",
    "47. Register Summary\n0x03BF 0x03C0, Bit Pos. = 7:0 7:0. 0x03BF 0x03C0, 7 = EN. 0x03BF 0x03C0, 6 = . 0x03BF 0x03C0, 5 = . 0x03BF 0x03C0, 4 = . 0x03BF 0x03C0, 3 = . 0x03BF 0x03C0, 2 = . 0x03BF 0x03C0, 1 = MODE[2:0]. 0x03BF 0x03C0, 0 = . 0x03C1, Name = CWG1CON1. 0x03C1, Bit Pos. = 7:0. 0x03C1, 7 = . 0x03C1, 6 = LD. 0x03C1, 5 = IN. 0x03C1, 4 = . 0x03C1, 3 = . 0x03C1, 2 = DBF[5:0].",
    "47. Register Summary\n0x03C1, 1 = POLB. 0x03C1, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = POLD. , 2 = POLC. , 1 = . , 0 = POLA. 0x03C2, Name = CWG1AS0. 0x03C2, Bit Pos. = 7:0. 0x03C2, 7 = SHUTDOWN. 0x03C2, 6 = REN. 0x03C2, 5 = . 0x03C2, 4 = LSBD[1:0]. 0x03C2, 3 = . 0x03C2, 2 = LSAC[1:0]. 0x03C2, 1 = . 0x03C2, 0 = . 0x03C3, Name = CWG1AS1. 0x03C3, Bit Pos. = 7:0. 0x03C3, 7 = AS7E. 0x03C3,",
    "47. Register Summary\n6 = AS6E. 0x03C3, 5 = AS5E. 0x03C3, 4 = AS4E. 0x03C3, 3 = AS3E. 0x03C3, 2 = AS2E. 0x03C3, 1 = AS1E. 0x03C3, 0 = AS0E. 0x03C4, Name = CWG1STR. 0x03C4, Bit Pos. = 7:0. 0x03C4, 7 = OVRD. 0x03C4, 6 = OVRC. 0x03C4, 5 = OVRB. 0x03C4, 4 = OVRA. 0x03C4, 3 = STRD. 0x03C4, 2 = STRC. 0x03C4, 1 = STRB. 0x03C4, 0 = STRA. 0x03C5, Name = . 0x03C5, Bit Pos. = . 0x03C5, 7 = .",
    "47. Register Summary\n0x03C5, 6 = . 0x03C5, 5 = . 0x03C5, 4 = . 0x03C5, 3 = . 0x03C5, 2 = . 0x03C5, 1 = . 0x03C5, 0 = . ... 0x03D6, Name = Reserved. ... 0x03D6, Bit Pos. = . ... 0x03D6, 7 = . ... 0x03D6, 6 = . ... 0x03D6, 5 = . ... 0x03D6, 4 = . ... 0x03D6, 3 = . ... 0x03D6, 2 = . ... 0x03D6, 1 = . ... 0x03D6, 0 = . 0x03D7, Name = FVRCON. 0x03D7, Bit Pos. = 7:0. 0x03D7, 7 = EN. 0x03D7, 6 = RDY. 0x03D7, 5 =",
    "47. Register Summary\nTSEN. 0x03D7, 4 = TSRNG. 0x03D7, 3 = CDAFVR[1:0]. 0x03D7, 2 = . 0x03D7, 1 = ADFVR[1:0]. 0x03D7, 0 = . 0x03D8, Name = ADCP. 0x03D8, Bit Pos. = 7:0. 0x03D8, 7 = CPON. 0x03D8, 6 = . 0x03D8, 5 = . 0x03D8, 4 = . 0x03D8, 3 = . 0x03D8, 2 = . 0x03D8, 1 = . 0x03D8, 0 = CPRDY. 0x03D9, Name = ADLTH. 0x03D9, Bit Pos. = 7:0 15:8. 0x03D9, 7 = . 0x03D9, 6 = . 0x03D9, 5 = . 0x03D9, 4 = LTH[7:0]. 0x03D9, 3 =",
    "47. Register Summary\nLTH[15:8]. 0x03D9, 2 = . 0x03D9, 1 = . 0x03D9, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = UTH[7:0]. , 2 = . , 1 = . , 0 = . 0x03DB, Name = ADUTH. 0x03DB, Bit Pos. = 7:0. 0x03DB, 7 = . 0x03DB, 6 = . 0x03DB, 5 = . 0x03DB, 4 = . 0x03DB, 3 = . 0x03DB, 2 = . 0x03DB, 1 = . 0x03DB, 0 = . , Name = . , Bit Pos. = 15:8 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = UTH[15:8]. , 2 = . , 1 = . , 0 = . 0x03DD, Name = ADERR.",
    "47. Register Summary\n0x03DD, Bit Pos. = 15:8. 0x03DD, 7 = . 0x03DD, 6 = . 0x03DD, 5 = . 0x03DD, 4 = . 0x03DD, 3 = ERR[7:0] ERR[15:8]. 0x03DD, 2 = . 0x03DD, 1 = . 0x03DD, 0 = . 0x03DF, Name = ADSTPT. 0x03DF, Bit Pos. = 7:0. 0x03DF, 7 = . 0x03DF, 6 = . 0x03DF, 5 = . 0x03DF, 4 = . 0x03DF, 3 = STPT[7:0]. 0x03DF, 2 = . 0x03DF, 1 = . 0x03DF, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = STPT[15:8]. , 2 = .",
    "47. Register Summary\n, 1 = . , 0 = . 0x03E1, Name = ADFLTR. 0x03E1, Bit Pos. = 7:0. 0x03E1, 7 = . 0x03E1, 6 = . 0x03E1, 5 = . 0x03E1, 4 = . 0x03E1, 3 = FLTR[7:0]. 0x03E1, 2 = . 0x03E1, 1 = . 0x03E1, 0 = . , Name = . , Bit Pos. = 15:8 7:0. , 7 = . , 6 = . , 5 = . , 4 = ACC[7:0]. , 3 = FLTR[15:8]. , 2 = . , 1 = . , 0 = . 0x03E3, Name = ADACC. 0x03E3, Bit Pos. = 15:8. 0x03E3, 7 = . 0x03E3, 6 = . 0x03E3, 5 = . 0x03E3, 4",
    "47. Register Summary\n= . 0x03E3, 3 = ACC[15:8]. 0x03E3, 2 = . 0x03E3, 1 = . 0x03E3, 0 = . 0x03E6, Name = ADCNT. 0x03E6, Bit Pos. = 23:16 7:0. 0x03E6, 7 = . 0x03E6, 6 = . 0x03E6, 5 = . 0x03E6, 4 = . 0x03E6, 3 = CNT[7:0]. 0x03E6, 2 = . 0x03E6, 1 = ACC[17:16]. 0x03E6, 0 = ",
    "47. Register Summary\n0x03E7, ...........continued.Name = ADRPT. 0x03E7, Bit Pos. = 7:0 7:0. 0x03E7, 7. = . 0x03E7, 6 = . 0x03E7, 5. = . 0x03E7, 4. = RPT[7:0] PREV[7:0]. 0x03E7, 3. = . 0x03E7, 2 = . 0x03E7, 1. = . 0x03E7,",
    "47. Register Summary\n= . 0x03E8, ...........continued.Name = ADPREV. 0x03E8, Bit Pos. = 15:8. 0x03E8, 7. = . 0x03E8, 6 = . 0x03E8, 5. = . 0x03E8, 4. = PREV[15:8]. 0x03E8, 3. = . 0x03E8, 2 = . 0x03E8, 1. = . 0x03E8,",
    "47. Register Summary\n= . 0x03EA, ...........continued.Name = ADRES. 0x03EA, Bit Pos. = 7:0. 0x03EA, 7. = . 0x03EA, 6 = . 0x03EA, 5. = . 0x03EA, 4. = RES[7:0]. 0x03EA, 3. = . 0x03EA, 2 = . 0x03EA, 1. = . 0x03EA,  = . , ...........continued.Name = . , Bit Pos. = 15:8. , 7. = . , 6 = . , 5. = . , 4. = RES[15:8]. , 3. = . , 2 = . , 1. = . ,",
    "47. Register Summary\n= . 0x03EC, ...........continued.Name = ADPCH. 0x03EC, Bit Pos. = 7:0. 0x03EC, 7. = . 0x03EC, 6 = . 0x03EC, 5. = . 0x03EC, 4. = PCH[7:0]. 0x03EC, 3. = . 0x03EC, 2 = . 0x03EC, 1. = . 0x03EC,  = . 0x03ED, ...........continued.Name = Reserved. 0x03ED, Bit Pos. = 7:0. 0x03ED, 7. = . 0x03ED, 6 = . 0x03ED, 5. = . 0x03ED, 4. = ACQ[7:0]. 0x03ED, 3. = . 0x03ED, 2 = . 0x03ED, 1. = . 0x03ED,",
    "47. Register Summary\n= . 0x03EE, ...........continued.Name = ADACQ. 0x03EE, Bit Pos. = 15:8. 0x03EE, 7. = . 0x03EE, 6 = . 0x03EE, 5. = . 0x03EE, 4. = . 0x03EE, 3. = . 0x03EE, 2 = ACQ[12:8]. 0x03EE, 1. = . 0x03EE,",
    "47. Register Summary\n= . 0x03F0, ...........continued.Name = ADCAP. 0x03F0, Bit Pos. = 7:0. 0x03F0, 7. = . 0x03F0, 6 = . 0x03F0, 5. = . 0x03F0, 4. = . 0x03F0, 3. = . 0x03F0, 2 = CAP[4:0]. 0x03F0, 1. = . 0x03F0,",
    "47. Register Summary\n= . 0x03F1, ...........continued.Name = ADPRE. 0x03F1, Bit Pos. = 7:0. 0x03F1, 7. = . 0x03F1, 6 = . 0x03F1, 5. = . 0x03F1, 4. = PRE[7:0]. 0x03F1, 3. = . 0x03F1, 2 = . 0x03F1, 1. = . 0x03F1,",
    "47. Register Summary\n= . 0x03F3, ...........continued.Name = ADCON0. 0x03F3, Bit Pos. = 15:8 7:0. 0x03F3, 7. = ON. 0x03F3, 6 = CONT. 0x03F3, 5. = . 0x03F3, 4. = CS. 0x03F3, 3. = . 0x03F3, 2 = PRE[12:8] FM. 0x03F3, 1. = . 0x03F3,",
    "47. Register Summary\n= GO. 0x03F4, ...........continued.Name = ADCON1. 0x03F4, Bit Pos. = 7:0. 0x03F4, 7. = PPOL. 0x03F4, 6 = IPEN. 0x03F4, 5. = GPOL. 0x03F4, 4. = . 0x03F4, 3. = . 0x03F4, 2 = . 0x03F4, 1. = . 0x03F4,",
    "47. Register Summary\n= DSEN. 0x03F5, ...........continued.Name = ADCON2. 0x03F5, Bit Pos. = 7:0. 0x03F5, 7. = PSIS. 0x03F5, 6 = . 0x03F5, 5. = CRS[2:0]. 0x03F5, 4. = . 0x03F5, 3. = ACLR. 0x03F5, 2 = . 0x03F5, 1. = MD[2:0]. 0x03F5,",
    "47. Register Summary\n= . 0x03F6, ...........continued.Name = ADCON3. 0x03F6, Bit Pos. = 7:0. 0x03F6, 7. = . 0x03F6, 6 = . 0x03F6, 5. = CALC[2:0]. 0x03F6, 4. = . 0x03F6, 3. = SOI. 0x03F6, 2 = . 0x03F6, 1. = TMD[2:0]. 0x03F6,",
    "47. Register Summary\n= . 0x03F7, ...........continued.Name = ADSTAT. 0x03F7, Bit Pos. = 7:0. 0x03F7, 7. = AOV. 0x03F7, 6 = UTHR. 0x03F7, 5. = LTHR. 0x03F7, 4. = MATH NREF. 0x03F7, 3. = . 0x03F7, 2 = . 0x03F7, 1. = STAT[2:0]. 0x03F7,",
    "47. Register Summary\n= . 0x03F8, ...........continued.Name = ADREF. 0x03F8, Bit Pos. = 7:0. 0x03F8, 7. = . 0x03F8, 6 = . 0x03F8, 5. = . 0x03F8, 4. = . 0x03F8, 3. = . 0x03F8, 2 = . 0x03F8, 1. = PREF[1:0]. 0x03F8,",
    "47. Register Summary\n= . 0x03F9, ...........continued.Name = ADACT. 0x03F9, Bit Pos. = 7:0. 0x03F9, 7. = . 0x03F9, 6 = . 0x03F9, 5. = . 0x03F9, 4. = . 0x03F9, 3. = . 0x03F9, 2 = ACT[4:0]. 0x03F9, 1. = . 0x03F9,  = . , ...........continued.Name = ADCLK. , Bit Pos. = 7:0. , 7. = . , 6 = . , 5. = . , 4. = . , 3. = CS[5:0]. , 2 = . , 1. = . ,",
    "47. Register Summary\n= . 0x03FA, ...........continued.Name = . 0x03FA, Bit Pos. = . 0x03FA, 7. = . 0x03FA, 6 = . 0x03FA, 5. = . 0x03FA, 4. = . 0x03FA, 3. = . 0x03FA, 2 = . 0x03FA, 1. = . 0x03FA,  = . ... 0x03FF, ...........continued.Name = Reserved. ... 0x03FF, Bit Pos. = . ... 0x03FF, 7. = . ... 0x03FF, 6 = . ... 0x03FF, 5. = . ... 0x03FF, 4. = . ... 0x03FF, 3. = . ... 0x03FF, 2 = . ... 0x03FF, 1. = . ... 0x03FF,",
    "47. Register Summary\n= . 0x0400, ...........continued.Name = ANSELA. 0x0400, Bit Pos. = 7:0. 0x0400, 7. = . 0x0400, 6 = . 0x0400, 5. = ANSELA5. 0x0400, 4. = ANSELA4. 0x0400, 3. = . 0x0400, 2 = ANSELA2. 0x0400, 1. = ANSELA1. 0x0400,",
    "47. Register Summary\n= ANSELA0. 0x0401, ...........continued.Name = WPUA. 0x0401, Bit Pos. = 7:0. 0x0401, 7. = . 0x0401, 6 = . 0x0401, 5. = WPUA5. 0x0401, 4. = WPUA4. 0x0401, 3. = WPUA3. 0x0401, 2 = WPUA2. 0x0401, 1. = WPUA1. 0x0401,",
    "47. Register Summary\n= WPUA0. 0x0402, ...........continued.Name = ODCONA. 0x0402, Bit Pos. = 7:0. 0x0402, 7. = . 0x0402, 6 = . 0x0402, 5. = ODCA5. 0x0402, 4. = ODCA4. 0x0402, 3. = . 0x0402, 2 = ODCA2. 0x0402, 1. = ODCA1. 0x0402,",
    "47. Register Summary\n= ODCA0. 0x0403, ...........continued.Name = SLRCONA. 0x0403, Bit Pos. = 7:0. 0x0403, 7. = . 0x0403, 6 = . 0x0403, 5. = SLRA5. 0x0403, 4. = SLRA4. 0x0403, 3. = . 0x0403, 2 = SLRA2. 0x0403, 1. = SLRA1. 0x0403,",
    "47. Register Summary\n= SLRA0. 0x0404, ...........continued.Name = INLVLA. 0x0404, Bit Pos. = 7:0. 0x0404, 7. = . 0x0404, 6 = . 0x0404, 5. = INLVLA5. 0x0404, 4. = INLVLA4. 0x0404, 3. = INLVLA3. 0x0404, 2 = INLVLA2. 0x0404, 1. = INLVLA1. 0x0404,",
    "47. Register Summary\n= INLVLA0. 0x0405, ...........continued.Name = IOCAP. 0x0405, Bit Pos. = 7:0. 0x0405, 7. = . 0x0405, 6 = . 0x0405, 5. = IOCAP5. 0x0405, 4. = IOCAP4. 0x0405, 3. = IOCAP3. 0x0405, 2 = IOCAP2. 0x0405, 1. = IOCAP1. 0x0405,  = IOCAP0. 0x0406, ...........continued.Name = . 0x0406, Bit Pos. = . 0x0406, 7. = . 0x0406, 6 = . 0x0406, 5. = . 0x0406, 4. = . 0x0406, 3. = . 0x0406, 2 = IOCAN2. 0x0406, 1. = . 0x0406,",
    "47. Register Summary\n= . , ...........continued.Name = IOCAN. , Bit Pos. = 7:0. , 7. = . , 6 = . , 5. = IOCAN5 IOCAF5. , 4. = IOCAN4. , 3. = IOCAN3. , 2 = . , 1. = IOCAN1. ,",
    "47. Register Summary\n= IOCAN0. 0x0407 0x0408, ...........continued.Name = IOCAF ANSELB. 0x0407 0x0408, Bit Pos. = 7:0 7:0. 0x0407 0x0408, 7. = ANSELB7. 0x0407 0x0408, 6 = ANSELB6. 0x0407 0x0408, 5. = ANSELB5. 0x0407 0x0408, 4. = IOCAF4 ANSELB4. 0x0407 0x0408, 3. = IOCAF3. 0x0407 0x0408, 2 = IOCAF2. 0x0407 0x0408, 1. = IOCAF1. 0x0407 0x0408,",
    "47. Register Summary\n= . 0x0409, ...........continued.Name = WPUB. 0x0409, Bit Pos. = 7:0. 0x0409, 7. = WPUB7. 0x0409, 6 = WPUB6. 0x0409, 5. = WPUB5. 0x0409, 4. = WPUB4. 0x0409, 3. = . 0x0409, 2 = . 0x0409, 1. = . 0x0409,",
    "47. Register Summary\n= . 0x040A, ...........continued.Name = ODCONB. 0x040A, Bit Pos. = 7:0. 0x040A, 7. = ODCB7. 0x040A, 6 = ODCB6. 0x040A, 5. = ODCB5. 0x040A, 4. = ODCB4. 0x040A, 3. = . 0x040A, 2 = . 0x040A, 1. = . 0x040A,",
    "47. Register Summary\n= . 0x040B, ...........continued.Name = SLRCONB. 0x040B, Bit Pos. = 7:0. 0x040B, 7. = SLRB7. 0x040B, 6 = SLRB6. 0x040B, 5. = SLRB5. 0x040B, 4. = SLRB4. 0x040B, 3. = . 0x040B, 2 = . 0x040B, 1. = . 0x040B,",
    "47. Register Summary\n= . 0x040C, ...........continued.Name = INLVLB. 0x040C, Bit Pos. = 7:0. 0x040C, 7. = INLVLB7. 0x040C, 6 = INLVLB6. 0x040C, 5. = INLVLB5. 0x040C, 4. = INLVLB4. 0x040C, 3. = . 0x040C, 2 = . 0x040C, 1. = . 0x040C,",
    "47. Register Summary\n= . 0x040D, ...........continued.Name = IOCBP. 0x040D, Bit Pos. = 7:0. 0x040D, 7. = IOCBP7. 0x040D, 6 = IOCBP6. 0x040D, 5. = IOCBP5. 0x040D, 4. = IOCBP4. 0x040D, 3. = . 0x040D, 2 = . 0x040D, 1. = . 0x040D,",
    "47. Register Summary\n= . 0x040E, ...........continued.Name = IOCBN. 0x040E, Bit Pos. = 7:0. 0x040E, 7. = IOCBN7. 0x040E, 6 = IOCBN6. 0x040E, 5. = IOCBN5. 0x040E, 4. = IOCBN4. 0x040E, 3. = . 0x040E, 2 = . 0x040E, 1. = . 0x040E,",
    "47. Register Summary\n= . 0x040F, ...........continued.Name = IOCBF. 0x040F, Bit Pos. = 7:0. 0x040F, 7. = IOCBF7. 0x040F, 6 = IOCBF6. 0x040F, 5. = IOCBF5. 0x040F, 4. = IOCBF4. 0x040F, 3. = . 0x040F, 2 = . 0x040F, 1. = . 0x040F,",
    "47. Register Summary\n= . 0x0410, ...........continued.Name = ANSELC. 0x0410, Bit Pos. = 7:0. 0x0410, 7. = ANSELC7. 0x0410, 6 = ANSELC6. 0x0410, 5. = ANSELC5. 0x0410, 4. = ANSELC4. 0x0410, 3. = ANSELC3. 0x0410, 2 = ANSELC2. 0x0410, 1. = ANSELC1. 0x0410,",
    "47. Register Summary\n= ANSELC0. 0x0411, ...........continued.Name = WPUC. 0x0411, Bit Pos. = 7:0. 0x0411, 7. = WPUC7. 0x0411, 6 = WPUC6. 0x0411, 5. = WPUC5. 0x0411, 4. = WPUC4. 0x0411, 3. = WPUC3. 0x0411, 2 = WPUC2. 0x0411, 1. = WPUC1. 0x0411,",
    "47. Register Summary\n= WPUC0. 0x0412, ...........continued.Name = ODCONC. 0x0412, Bit Pos. = 7:0. 0x0412, 7. = ODCC7. 0x0412, 6 = ODCC6. 0x0412, 5. = ODCC5. 0x0412, 4. = ODCC4. 0x0412, 3. = ODCC3. 0x0412, 2 = ODCC2. 0x0412, 1. = ODCC1. 0x0412,",
    "47. Register Summary\n= ODCC0. 0x0413, ...........continued.Name = SLRCONC. 0x0413, Bit Pos. = 7:0. 0x0413, 7. = SLRC7. 0x0413, 6 = SLRC6. 0x0413, 5. = SLRC5. 0x0413, 4. = SLRC4. 0x0413, 3. = SLRC3. 0x0413, 2 = SLRC2. 0x0413, 1. = SLRC1. 0x0413,  = SLRC0. , ...........continued.Name = . , Bit Pos. = . , 7. = . , 6 = INLVLC6. , 5. = INLVLC5. , 4. = INLVLC4. , 3. = INLVLC3. , 2 = INLVLC2. , 1. = INLVLC1. ,",
    "47. Register Summary\n= INLVLC0. 0x0414, ...........continued.Name = INLVLC. 0x0414, Bit Pos. = 7:0. 0x0414, 7. = INLVLC7. 0x0414, 6 = . 0x0414, 5. = . 0x0414, 4. = . 0x0414, 3. = IOCCP3. 0x0414, 2 = IOCCP2. 0x0414, 1. = . 0x0414,",
    "47. Register Summary\n= . 0x0415 0x0416, ...........continued.Name = IOCCP IOCCN. 0x0415 0x0416, Bit Pos. = 7:0 7:0. 0x0415 0x0416, 7. = IOCCP7 IOCCN7. 0x0415 0x0416, 6 = IOCCP6 IOCCN6. 0x0415 0x0416, 5. = IOCCP5 IOCCN5. 0x0415 0x0416, 4. = IOCCP4 IOCCN4. 0x0415 0x0416, 3. = IOCCN3. 0x0415 0x0416, 2 = IOCCN2. 0x0415 0x0416, 1. = IOCCP1 IOCCN1. 0x0415 0x0416,",
    "47. Register Summary\n= IOCCP0 IOCCN0. 0x0417, ...........continued.Name = . 0x0417, Bit Pos. = . 0x0417, 7. = . 0x0417, 6 = . 0x0417, 5. = . 0x0417, 4. = . 0x0417, 3. = . 0x0417, 2 = . 0x0417, 1. = . 0x0417,  = . , ...........continued.Name = IOCCF. , Bit Pos. = . , 7. = . , 6 = . , 5. = . , 4. = . , 3. = . , 2 = IOCCF2. , 1. = . ,",
    "47. Register Summary\n= . , ...........continued.Name = . , Bit Pos. = 7:0. , 7. = IOCCF7. , 6 = IOCCF6. , 5. = IOCCF5. , 4. = . , 3. = . , 2 = . , 1. = IOCCF1. ,  = . 0x0418 ..., ...........continued.Name = Reserved. 0x0418 ..., Bit Pos. = . 0x0418 ..., 7. = . 0x0418 ..., 6 = . 0x0418 ..., 5. = . 0x0418 ..., 4. = . 0x0418 ..., 3. = IOCCF3. 0x0418 ..., 2 = . 0x0418 ..., 1. = . 0x0418 ...,",
    "47. Register Summary\n= . , ...........continued.Name = . , Bit Pos. = . , 7. = . , 6 = . , 5. = . , 4. = IOCCF4. , 3. = . , 2 = . , 1. = . ,  = . 0x043F, ...........continued.Name = NCO1ACC. 0x043F, Bit Pos. = 7:0. 0x043F, 7. = . 0x043F, 6 = . 0x043F, 5. = . 0x043F, 4. = . 0x043F, 3. = . 0x043F, 2 = . 0x043F, 1. = . 0x043F,",
    "47. Register Summary\n= IOCCF0. 0x0440 0x0443, ...........continued.Name = NCO1INC. 0x0440 0x0443, Bit Pos. = 15:8 23:16 7:0 15:8. 0x0440 0x0443, 7. = EN. 0x0440 0x0443, 6 = . 0x0440 0x0443, 5. = . 0x0440 0x0443, 4. = INC[15:8] POL. 0x0440 0x0443, 3. = ACC[7:0] ACC[15:8] INC[7:0]. 0x0440 0x0443, 2 = ACC[19:16]. 0x0440 0x0443, 1. = . 0x0440 0x0443,",
    "47. Register Summary\n= . 0x0446 0x0447 0x0448 ..., ...........continued.Name = NCO1CON NCO1CLK. 0x0446 0x0447 0x0448 ..., Bit Pos. = 23:16 7:0 7:0. 0x0446 0x0447 0x0448 ..., 7. = . 0x0446 0x0447 0x0448 ..., 6 = PWS[2:0]. 0x0446 0x0447 0x0448 ..., 5. = OUT. 0x0446 0x0447 0x0448 ..., 4. = . 0x0446 0x0447 0x0448 ..., 3. = . 0x0446 0x0447 0x0448 ..., 2 = INC[19:16]. 0x0446 0x0447 0x0448 ..., 1. =",
    "47. Register Summary\n. 0x0446 0x0447 0x0448 ...,\n= . , ...........continued.Name = Reserved. , Bit Pos. = . , 7. = . , 6 = . , 5. = . , 4. = . , 3. = . , 2 = . , 1. = . ,  = . , ...........continued.Name = . , Bit Pos. = . , 7. = . , 6 = . , 5. = . , 4. = . , 3. = . , 2 = . , 1. = . ,  = . , ...........continued.Name = . , Bit Pos. = . , 7. = . , 6 = . , 5. = . , 4. = . , 3. = . , 2 = CKS[3:0]. , 1. = . ,",
    "47. Register Summary\n= . 0x0457, ...........continued.Name = . 0x0457, Bit Pos. = . 0x0457, 7. = . 0x0457, 6 = . 0x0457, 5. = . 0x0457, 4. = . 0x0457, 3. = . 0x0457, 2 = . 0x0457, 1. = . 0x0457,  = ",
    "47. Register Summary\n0x0458, Name = FSCMCON. 0x0458, Bit Pos. = 7:0. 0x0458, 7 = . 0x0458, 6 = . 0x0458, 5 = FSCMSFI. 0x0458, 4 3 = FSCMSEV FSCMPFI. 0x0458, 2 = FSCMPEV. 0x0458, 1 = FSCMFFI. 0x0458, 0 = FSCMFEV. 0x0459, Name = IVTLOCK. 0x0459, Bit Pos. = 7:0. 0x0459, 7 = . 0x0459, 6 = . 0x0459, 5 = . 0x0459, 4 3 = . 0x0459, 2 = . 0x0459, 1 = . 0x0459, 0 = IVTLOCKED. , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = IVTADL[7:0]. ,",
    "47. Register Summary\n2 = . , 1 = . , 0 = . 0x045A, Name = IVTAD. 0x045A, Bit Pos. = 15:8. 0x045A, 7 = . 0x045A, 6 = . 0x045A, 5 = . 0x045A, 4 3 = IVTADH[7:0]. 0x045A, 2 = . 0x045A, 1 = . 0x045A, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = IVTADU[4:0]. , 1 = . , 0 = . 0x045D, Name = IVTBASE. 0x045D, Bit Pos. = 7:0 15:8. 0x045D, 7 = . 0x045D, 6 = . 0x045D, 5 = . 0x045D, 4 3 = IVTBASEL[7:0] IVTBASEH[7:0]. 0x045D, 2",
    "47. Register Summary\n= . 0x045D, 1 = . 0x045D, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = IVTBASEU[4:0]. , 1 = . , 0 = . 0x0460, Name = PWM1ERS. 0x0460, Bit Pos. = 7:0. 0x0460, 7 = . 0x0460, 6 = . 0x0460, 5 = . 0x0460, 4 3 = . 0x0460, 2 = . 0x0460, 1 = ERS[3:0]. 0x0460, 0 = . 0x0461, Name = PWM1CLK. 0x0461, Bit Pos. = 7:0. 0x0461, 7 = . 0x0461, 6 = . 0x0461, 5 = . 0x0461, 4 3 = . 0x0461, 2 =",
    "47. Register Summary\nCLK[3:0]. 0x0461, 1 = . 0x0461, 0 = . 0x0462, Name = PWM1LDS. 0x0462, Bit Pos. = 7:0. 0x0462, 7 = . 0x0462, 6 = . 0x0462, 5 = . 0x0462, 4 3 = . 0x0462, 2 = LDS[3:0]. 0x0462, 1 = . 0x0462, 0 = . 0x0463, Name = PWM1PR. 0x0463, Bit Pos. = 7:0. 0x0463, 7 = . 0x0463, 6 = . 0x0463, 5 = . 0x0463, 4 3 = PR[7:0] PR[15:8]. 0x0463, 2 = . 0x0463, 1 = . 0x0463, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 =",
    "47. Register Summary\n. , 5 = . , 4 3 = . , 2 = . , 1 = . , 0 = . 0x0465, Name = PWM1CPRE. 0x0465, Bit Pos. = 7:0. 0x0465, 7 = . 0x0465, 6 = . 0x0465, 5 = . 0x0465, 4 3 = CPRE[7:0]. 0x0465, 2 = . 0x0465, 1 = . 0x0465, 0 = . 0x0466, Name = PWM1PIPOS. 0x0466, Bit Pos. = 7:0. 0x0466, 7 = . 0x0466, 6 = . 0x0466, 5 = . 0x0466, 4 3 = PIPOS[7:0]. 0x0466, 2 = . 0x0466, 1 = . 0x0466, 0 = . 0x0467, Name = PWM1GIR. 0x0467, Bit Pos. =",
    "47. Register Summary\n7:0. 0x0467, 7 = . 0x0467, 6 = . 0x0467, 5 = . 0x0467, 4 3 = . 0x0467, 2 = . 0x0467, 1 = S1P2. 0x0467, 0 = S1P1. 0x0468, Name = PWM1GIE. 0x0468, Bit Pos. = 7:0. 0x0468, 7 = . 0x0468, 6 = . 0x0468, 5 = . 0x0468, 4 3 = . 0x0468, 2 = . 0x0468, 1 = S1P2. 0x0468, 0 = S1P1. 0x0469, Name = PWM1CON. 0x0469, Bit Pos. = 7:0. 0x0469, 7 = EN. 0x0469, 6 = . 0x0469, 5 = . 0x0469, 4 3 = . 0x0469, 2 =",
    "47. Register Summary\nLD. 0x0469, 1 = ERSPOL. 0x0469, 0 = ERSNOW. 0x046A, Name = PWM1S1CFG. 0x046A, Bit Pos. = 7:0. 0x046A, 7 = POL2. 0x046A, 6 = POL1. 0x046A, 5 = . 0x046A, 4 3 = PPEN. 0x046A, 2 = . 0x046A, 1 = MODE[2:0]. 0x046A, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = P1[7:0]. , 2 = . , 1 = . , 0 = . 0x046B, Name = PWM1S1P1. 0x046B, Bit Pos. = 15:8. 0x046B, 7 = . 0x046B, 6 = . 0x046B, 5 = . 0x046B, 4 3",
    "47. Register Summary\n= P1[15:8]. 0x046B, 2 = . 0x046B, 1 = . 0x046B, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = P2[7:0]. , 2 = . , 1 = . , 0 = . 0x046D, Name = PWM1S1P2. 0x046D, Bit Pos. = 15:8. 0x046D, 7 = . 0x046D, 6 = . 0x046D, 5 = . 0x046D, 4 3 = P2[15:8]. 0x046D, 2 = . 0x046D, 1 = . 0x046D, 0 = . 0x046F, Name = PWM2ERS. 0x046F, Bit Pos. = 7:0. 0x046F, 7 = . 0x046F, 6 = . 0x046F, 5 = . 0x046F, 4",
    "47. Register Summary\n3 = . 0x046F, 2 = . 0x046F, 1 = ERS[3:0]. 0x046F, 0 = . 0x0470, Name = PWM2CLK. 0x0470, Bit Pos. = 7:0. 0x0470, 7 = . 0x0470, 6 = . 0x0470, 5 = . 0x0470, 4 3 = . 0x0470, 2 = CLK[3:0]. 0x0470, 1 = . 0x0470, 0 = . 0x0471, Name = PWM2LDS. 0x0471, Bit Pos. = 7:0. 0x0471, 7 = . 0x0471, 6 = . 0x0471, 5 = . 0x0471, 4 3 = . 0x0471, 2 = . 0x0471, 1 = LDS[3:0]. 0x0471, 0 = . 0x0472, Name = PWM2PR.",
    "47. Register Summary\n0x0472, Bit Pos. = 7:0. 0x0472, 7 = . 0x0472, 6 = . 0x0472, 5 = . 0x0472, 4 3 = PR[7:0]. 0x0472, 2 = . 0x0472, 1 = . 0x0472, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = PR[15:8]. , 2 = . , 1 = . , 0 = . 0x0474, Name = PWM2CPRE. 0x0474, Bit Pos. = 7:0. 0x0474, 7 = . 0x0474, 6 = . 0x0474, 5 = . 0x0474, 4 3 = CPRE[7:0]. 0x0474, 2 = . 0x0474, 1 = . 0x0474, 0 = . 0x0475, Name = PWM2PIPOS.",
    "47. Register Summary\n0x0475, Bit Pos. = . 0x0475, 7 = . 0x0475, 6 = . 0x0475, 5 = . 0x0475, 4 3 = . 0x0475, 2 = . 0x0475, 1 = . 0x0475, 0 = . 0x0476, Name = PWM2GIR. 0x0476, Bit Pos. = 7:0 7:0. 0x0476, 7 = . 0x0476, 6 = . 0x0476, 5 = . 0x0476, 4 3 = PIPOS[7:0]. 0x0476, 2 = . 0x0476, 1 = S1P2. 0x0476, 0 = S1P1. 0x0478, Name = PWM2CON. 0x0478, Bit Pos. = 7:0. 0x0478, 7 = EN. 0x0478, 6 = . 0x0478, 5 = . 0x0478, 4",
    "47. Register Summary\n3 = . 0x0478, 2 = LD. 0x0478, 1 = ERSPOL. 0x0478, 0 = ERSNOW. 0x0479, Name = PWM2S1CFG. 0x0479, Bit Pos. = 7:0. 0x0479, 7 = POL2. 0x0479, 6 = POL1. 0x0479, 5 = . 0x0479, 4 3 = PPEN. 0x0479, 2 = . 0x0479, 1 = MODE[2:0]. 0x0479, 0 = . 0x047A, Name = PWM2S1P1. 0x047A, Bit Pos. = 7:0. 0x047A, 7 = . 0x047A, 6 = . 0x047A, 5 = . 0x047A, 4 3 = P1[7:0]. 0x047A, 2 = . 0x047A, 1 = . 0x047A, 0 = . , Name =",
    "47. Register Summary\n. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = P1[15:8]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = P2[7:0]. , 2 = . , 1 = . , 0 = . 0x047C, Name = PWM2S1P2. 0x047C, Bit Pos. = 15:8. 0x047C, 7 = . 0x047C, 6 = . 0x047C, 5 = . 0x047C, 4 3 = P2[15:8]. 0x047C, 2 = . 0x047C, 1 = . 0x047C, 0 = . 0x047E, Name = PWM3ERS. 0x047E, Bit Pos. = 7:0. 0x047E, 7 = . 0x047E, 6 = .",
    "47. Register Summary\n0x047E, 5 = . 0x047E, 4 3 = . 0x047E, 2 = ERS[3:0]. 0x047E, 1 = . 0x047E, 0 = . 0x047F, Name = PWM3CLK. 0x047F, Bit Pos. = 7:0. 0x047F, 7 = . 0x047F, 6 = . 0x047F, 5 = . 0x047F, 4 3 = . 0x047F, 2 = CLK[3:0]. 0x047F, 1 = . 0x047F, 0 = . 0x0480, Name = PWM3LDS. 0x0480, Bit Pos. = 7:0. 0x0480, 7 = . 0x0480, 6 = . 0x0480, 5 = . 0x0480, 4 3 = . 0x0480, 2 = LDS[3:0]. 0x0480, 1 = . 0x0480, 0",
    "47. Register Summary\n= . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = PR[7:0]. , 2 = . , 1 = . , 0 = . 0x0481, Name = PWM3PR. 0x0481, Bit Pos. = 15:8. 0x0481, 7 = . 0x0481, 6 = . 0x0481, 5 = . 0x0481, 4 3 = PR[15:8]. 0x0481, 2 = . 0x0481, 1 = . 0x0481, 0 = . 0x0483, Name = PWM3CPRE. 0x0483, Bit Pos. = 7:0. 0x0483, 7 = . 0x0483, 6 = . 0x0483, 5 = . 0x0483, 4 3 = CPRE[7:0]. 0x0483, 2 = . 0x0483, 1 = . 0x0483, 0 = .",
    "47. Register Summary\n0x0484, Name = PWM3PIPOS. 0x0484, Bit Pos. = 7:0. 0x0484, 7 = . 0x0484, 6 = . 0x0484, 5 = . 0x0484, 4 3 = PIPOS[7:0]. 0x0484, 2 = . 0x0484, 1 = . 0x0484, 0 = . 0x0485, Name = PWM3GIR. 0x0485, Bit Pos. = 7:0. 0x0485, 7 = . 0x0485, 6 = . 0x0485, 5 = . 0x0485, 4 3 = . 0x0485, 2 = . 0x0485, 1 = S1P2. 0x0485, 0 = . 0x0486, Name = PWM3GIE. 0x0486, Bit Pos. = 7:0. 0x0486, 7 = . 0x0486, 6 = .",
    "47. Register Summary\n0x0486, 5 = . 0x0486, 4 3 = . 0x0486, 2 = . 0x0486, 1 = S1P2. 0x0486, 0 = S1P1. 0x0487, Name = PWM3CON. 0x0487, Bit Pos. = 7:0. 0x0487, 7 = EN. 0x0487, 6 = . 0x0487, 5 = . 0x0487, 4 3 = . 0x0487, 2 = LD. 0x0487, 1 = ERSPOL. 0x0487, 0 = S1P1 ERSNOW. 0x0488, Name = PWM3S1CFG. 0x0488, Bit Pos. = 7:0. 0x0488, 7 = POL2. 0x0488, 6 = POL1. 0x0488, 5 = . 0x0488, 4 3 = PPEN. 0x0488, 2 = . 0x0488, 1 =",
    "47. Register Summary\nMODE[2:0]. 0x0488, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = P1[7:0]. , 2 = . , 1 = . , 0 = . 0x0489, Name = PWM3S1P1. 0x0489, Bit Pos. = 15:8. 0x0489, 7 = . 0x0489, 6 = . 0x0489, 5 = . 0x0489, 4 3 = P1[15:8]. 0x0489, 2 = . 0x0489, 1 = . 0x0489, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = P2[7:0]. , 2 = . , 1 = . , 0 = . 0x048B, Name = PWM3S1P2. 0x048B, Bit Pos. = 15:8.",
    "47. Register Summary\n0x048B, 7 = . 0x048B, 6 = . 0x048B, 5 = . 0x048B, 4 3 = P2[15:8]. 0x048B, 2 = . 0x048B, 1 = . 0x048B, 0 = . 0x048D, Name = . 0x048D, Bit Pos. = . 0x048D, 7 = . 0x048D, 6 = . 0x048D, 5 = . 0x048D, 4 3 = . 0x048D, 2 = . 0x048D, 1 = . 0x048D, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x049B, Name = . 0x049B, Bit Pos. = . 0x049B, 7",
    "47. Register Summary\n= . 0x049B, 6 = . 0x049B, 5 = . 0x049B, 4 3 = . 0x049B, 2 = . 0x049B, 1 = . 0x049B, 0 = . 0x049C, Name = PWMLOAD. 0x049C, Bit Pos. = 7:0. 0x049C, 7 = . 0x049C, 6 = . 0x049C, 5 = . 0x049C, 4 3 = . 0x049C, 2 = MPWM3LD. 0x049C, 1 = MPWM2LD. 0x049C, 0 = MPWM1LD. 0x049D, Name = PWMEN. 0x049D, Bit Pos. = 7:0. 0x049D, 7 = . 0x049D, 6 = . 0x049D, 5 = . 0x049D, 4 3 = . 0x049D, 2 = MPWM3EN. 0x049D, 1 =",
    "47. Register Summary\nMPWM2EN. 0x049D, 0 = MPWM1EN",
    "47. Register Summary\n0x049E ..., Name = Reserved. 0x049E ..., Bit Pos. = . 0x049E ..., 7 = . 0x049E ..., 6 = . 0x049E ..., 5 = . 0x049E ..., 4 = . 0x049E ..., 3 = . 0x049E ..., 2 = . 0x049E ..., 1 = . 0x049E ..., 0 = . 0x04A7 0x04A8, Name = PIE0. 0x04A7 0x04A8, Bit Pos. = 7:0. 0x04A7 0x04A8, 7 = IOCIE. 0x04A7 0x04A8, 6 = CRCIE. 0x04A7 0x04A8, 5 = CLC1IE. 0x04A7 0x04A8, 4 = NVMIE. 0x04A7 0x04A8,",
    "47. Register Summary\n3 = CSWIE. 0x04A7 0x04A8, 2 = OSFIE. 0x04A7 0x04A8, 1 = HLVDIE. 0x04A7 0x04A8, 0 = SWIE. 0x04A9, Name = PIE1. 0x04A9, Bit Pos. = 7:0. 0x04A9, 7 = SMT1PWAIE. 0x04A9, 6 = SMT1PRAIE. 0x04A9, 5 = SMT1IE. 0x04A9, 4 = CM1IE. 0x04A9, 3 = ACTIE. 0x04A9, 2 = ADIE. 0x04A9, 1 = ZCDIE. 0x04A9, 0 = INT0IE. 0x04AA, Name = PIE2. 0x04AA, Bit Pos. = 7:0. 0x04AA, 7 = DMA1AIE. 0x04AA, 6 =",
    "47. Register Summary\nDMA1ORIE. 0x04AA, 5 = DMA1DCNTIE. 0x04AA, 4 = DMA1SCNTIE. 0x04AA, 3 = . 0x04AA, 2 = . 0x04AA, 1 = . 0x04AA, 0 = ADTIE. 0x04AB, Name = PIE3. 0x04AB, Bit Pos. = 7:0. 0x04AB, 7 = TMR0IE. 0x04AB, 6 = CCP1IE. 0x04AB, 5 = TMR1GIE. 0x04AB, 4 = TMR1IE. 0x04AB, 3 = TMR2IE. 0x04AB, 2 = SPI1IE. 0x04AB, 1 = SPI1TXIE. 0x04AB, 0 = SPI1RXIE. 0x04AC, Name = PIE4. 0x04AC, Bit Pos. = 7:0. 0x04AC, 7 = PWM1IE.",
    "47. Register Summary\n0x04AC, 6 = PWM1PIE. 0x04AC, 5 = TMR3GIE. 0x04AC, 4 = TMR3IE. 0x04AC, 3 = U1IE. 0x04AC, 2 = U1EIE. 0x04AC, 1 = U1TXIE. 0x04AC, 0 = U1RXIE. 0x04AD, Name = PIE5. 0x04AD, Bit Pos. = 7:0. 0x04AD, 7 = PWM2IE. 0x04AD, 6 = PWM2PIE. 0x04AD, 5 = CLC2IE. 0x04AD, 4 = CM2IE. 0x04AD, 3 = . 0x04AD, 2 = SPI2IE. 0x04AD, 1 = SPI2TXIE. 0x04AD, 0 = SPI2RXIE. 0x04AE, Name = PIE6. 0x04AE, Bit Pos. = 7:0.",
    "47. Register Summary\n0x04AE, 7 = DMA2AIE. 0x04AE, 6 = DMA2ORIE. 0x04AE, 5 = DMA2DCNTIE. 0x04AE, 4 = DMA2SCNTIE. 0x04AE, 3 = NCO1IE. 0x04AE, 2 = CWG1IE. 0x04AE, 1 = . 0x04AE, 0 = INT1IE. 0x04AF, Name = PIE7. 0x04AF, Bit Pos. = 7:0. 0x04AF, 7 = PWM3IE. 0x04AF, 6 = PWM3PIE. 0x04AF, 5 = CLC3IE. 0x04AF, 4 = . 0x04AF, 3 = I2C1EIE. 0x04AF, 2 = I2C1IE. 0x04AF, 1 = I2C1TXIE. 0x04AF, 0 = I2C1RXIE. 0x04B0, Name = PIE8.",
    "47. Register Summary\n0x04B0, Bit Pos. = 7:0. 0x04B0, 7 = SCANIE. 0x04B0, 6 = . 0x04B0, 5 = CLC4IE. 0x04B0, 4 = . 0x04B0, 3 = U2IE. 0x04B0, 2 = U2EIE. 0x04B0, 1 = U2TXIE. 0x04B0, 0 = U2RXIE. 0x04B1, Name = PIE9. 0x04B1, Bit Pos. = 7:0. 0x04B1, 7 = DMA3AIE. 0x04B1, 6 = DMA3ORIE. 0x04B1, 5 = DMA3DCNTIE. 0x04B1, 4 = DMA3SCNTIE. 0x04B1, 3 = U3IE. 0x04B1, 2 = U3EIE. 0x04B1, 1 = U3TXIE. 0x04B1, 0",
    "47. Register Summary\n= U3RXIE. 0x04B2, Name = PIE10. 0x04B2, Bit Pos. = 7:0. 0x04B2, 7 = DMA4AIE. 0x04B2, 6 = DMA4ORIE. 0x04B2, 5 = DMA4DCNTIE. 0x04B2, 4 = DMA4SCNTIE. 0x04B2, 3 = TMR4IE. 0x04B2, 2 = . 0x04B2, 1 = . 0x04B2, 0 = INT2IE. 0x04B3, Name = PIR0. 0x04B3, Bit Pos. = 7:0. 0x04B3, 7 = IOCIF. 0x04B3, 6 = CRCIF. 0x04B3, 5 = CLC1IF. 0x04B3, 4 = NVMIF. 0x04B3, 3 = CSWIF. 0x04B3, 2 = OSFIF.",
    "47. Register Summary\n0x04B3, 1 = HLVDIF. 0x04B3, 0 = SWIF. 0x04B4, Name = PIR1. 0x04B4, Bit Pos. = 7:0. 0x04B4, 7 = SMT1PWAIF. 0x04B4, 6 = SMT1PRAIF. 0x04B4, 5 = SMT1IF. 0x04B4, 4 = CM1IF. 0x04B4, 3 = ACTIF. 0x04B4, 2 = ADIF. 0x04B4, 1 = ZCDIF. 0x04B4, 0 = INT0IF. 0x04B5, Name = PIR2. 0x04B5, Bit Pos. = 7:0. 0x04B5, 7 = DMA1AIF. 0x04B5, 6 = DMA1ORIF. 0x04B5, 5 = DMA1DCNTIF. 0x04B5, 4 =",
    "47. Register Summary\nDMA1SCNTIF. 0x04B5, 3 = . 0x04B5, 2 = . 0x04B5, 1 = . 0x04B5, 0 = ADTIF. 0x04B6, Name = PIR3. 0x04B6, Bit Pos. = 7:0. 0x04B6, 7 = TMR0IF. 0x04B6, 6 = CCP1IF. 0x04B6, 5 = TMR1GIF. 0x04B6, 4 = TMR1IF. 0x04B6, 3 = TMR2IF. 0x04B6, 2 = SPI1IF. 0x04B6, 1 = SPI1TXIF. 0x04B6, 0 = SPI1RXIF. 0x04B7, Name = PIR4. 0x04B7, Bit Pos. = 7:0. 0x04B7, 7 = PWM1IF. 0x04B7, 6",
    "47. Register Summary\n= PWM1PIF. 0x04B7, 5 = TMR3GIF. 0x04B7, 4 = TMR3IF. 0x04B7, 3 = U1IF. 0x04B7, 2 = U1EIF. 0x04B7, 1 = U1TXIF. 0x04B7, 0 = U1RXIF. 0x04B8, Name = PIR5. 0x04B8, Bit Pos. = 7:0. 0x04B8, 7 = PWM2IF. 0x04B8, 6 = PWM2PIF. 0x04B8, 5 = CLC2IF. 0x04B8, 4 = CM2IF. 0x04B8, 3 = . 0x04B8, 2 = SPI2IF. 0x04B8, 1 = SPI2TXIF. 0x04B8, 0 = SPI2RXIF. 0x04B9, Name = PIR6.",
    "47. Register Summary\n0x04B9, Bit Pos. = 7:0. 0x04B9, 7 = DMA2AIF. 0x04B9, 6 = DMA2ORIF. 0x04B9, 5 = DMA2DCNTIF. 0x04B9, 4 = DMA2SCNTIF. 0x04B9, 3 = NCO1IF. 0x04B9, 2 = CWG1IF. 0x04B9, 1 = . 0x04B9, 0 = INT1IF. 0x04BA, Name = PIR7. 0x04BA, Bit Pos. = 7:0. 0x04BA, 7 = PWM3IF. 0x04BA, 6 = PWM3PIF. 0x04BA, 5 = CLC3IF. 0x04BA, 4 = . 0x04BA, 3 = I2C1EIF. 0x04BA, 2 = I2C1IF. 0x04BA, 1 = I2C1TXIF.",
    "47. Register Summary\n0x04BA, 0 = I2C1RXIF. 0x04BB, Name = PIR8. 0x04BB, Bit Pos. = 7:0. 0x04BB, 7 = SCANIF. 0x04BB, 6 = . 0x04BB, 5 = CLC4IF. 0x04BB, 4 = . 0x04BB, 3 = U2IF. 0x04BB, 2 = U2EIF. 0x04BB, 1 = U2TXIF. 0x04BB, 0 = U2RXIF. 0x04BC, Name = PIR9. 0x04BC, Bit Pos. = 7:0. 0x04BC, 7 = DMA3AIF. 0x04BC, 6 = DMA3ORIF. 0x04BC, 5 = DMA3DCNTIF. 0x04BC, 4 = DMA3SCNTIF. 0x04BC, 3 = U3IF. 0x04BC, 2 = U3EIF. 0x04BC, 1 =",
    "47. Register Summary\nU3TXIF. 0x04BC, 0 = U3RXIF. 0x04BD, Name = PIR10. 0x04BD, Bit Pos. = 7:0. 0x04BD, 7 = DMA4AIF. 0x04BD, 6 = DMA4ORIF. 0x04BD, 5 = DMA4DCNTIF. 0x04BD, 4 = DMA4SCNTIF. 0x04BD, 3 = TMR4IF. 0x04BD, 2 = . 0x04BD, 1 = . 0x04BD, 0 = INT2IF. 0x04BE, Name = LATA. 0x04BE, Bit Pos. = 7:0. 0x04BE, 7 = . 0x04BE, 6 = . 0x04BE, 5 = LATA5. 0x04BE, 4 = LATA4. 0x04BE, 3 = . 0x04BE, 2 = LATA2.",
    "47. Register Summary\n0x04BE, 1 = LATA1. 0x04BE, 0 = LATA0. 0x04BF, Name = LATB. 0x04BF, Bit Pos. = 7:0. 0x04BF, 7 = LATB7. 0x04BF, 6 = LATB6. 0x04BF, 5 = LATB5. 0x04BF, 4 = LATB4. 0x04BF, 3 = . 0x04BF, 2 = . 0x04BF, 1 = . 0x04BF, 0 = . 0x04C0, Name = LATC. 0x04C0, Bit Pos. = 7:0. 0x04C0, 7 = LATC7. 0x04C0, 6 = LATC6. 0x04C0, 5 = LATC5. 0x04C0, 4 = LATC4. 0x04C0, 3 = LATC3. 0x04C0, 2 = LATC2. 0x04C0,",
    "47. Register Summary\n1 = LATC1. 0x04C0, 0 = LATC0. 0x04C1 ..., Name = Reserved. 0x04C1 ..., Bit Pos. = . 0x04C1 ..., 7 = . 0x04C1 ..., 6 = . 0x04C1 ..., 5 = . 0x04C1 ..., 4 = . 0x04C1 ..., 3 = . 0x04C1 ..., 2 = . 0x04C1 ..., 1 = . 0x04C1 ..., 0 = . 0x04C5, Name = TRISA. 0x04C5, Bit Pos. = 7:0. 0x04C5, 7 = . 0x04C5, 6 = . 0x04C5, 5 = . 0x04C5, 4 = . 0x04C5, 3 = . 0x04C5, 2 = . 0x04C5, 1 = .",
    "47. Register Summary\n0x04C5, 0 = . 0x04C6, Name = . 0x04C6, Bit Pos. = . 0x04C6, 7 = . 0x04C6, 6 = . 0x04C6, 5 = TRISA5. 0x04C6, 4 = TRISA4. 0x04C6, 3 = Reserved. 0x04C6, 2 = TRISA2. 0x04C6, 1 = TRISA1. 0x04C6, 0 = TRISA0. 0x04C7, Name = TRISB. 0x04C7, Bit Pos. = 7:0. 0x04C7, 7 = TRISB7. 0x04C7, 6 = TRISB6. 0x04C7, 5 = TRISB5. 0x04C7, 4 = TRISB4. 0x04C7, 3 = . 0x04C7, 2 = . 0x04C7, 1 = . 0x04C7, 0 = .",
    "47. Register Summary\n0x04C8, Name = TRISC. 0x04C8, Bit Pos. = 7:0. 0x04C8, 7 = TRISC7. 0x04C8, 6 = TRISC6. 0x04C8, 5 = TRISC5. 0x04C8, 4 = TRISC4. 0x04C8, 3 = TRISC3. 0x04C8, 2 = TRISC2. 0x04C8, 1 = TRISC1. 0x04C8, 0 = TRISC0. 0x04C9, Name = . 0x04C9, Bit Pos. = . 0x04C9, 7 = . 0x04C9, 6 = . 0x04C9, 5 = . 0x04C9, 4 = . 0x04C9, 3 = . 0x04C9, 2 = . 0x04C9, 1 = . 0x04C9, 0 = . ... 0x04CD, Name = Reserved. ...",
    "47. Register Summary\n0x04CD, Bit Pos. = . ... 0x04CD, 7 = . ... 0x04CD, 6 = . ... 0x04CD, 5 = . ... 0x04CD, 4 = . ... 0x04CD, 3 = . ... 0x04CD, 2 = . ... 0x04CD, 1 = . ... 0x04CD, 0 = . 0x04CE, Name = PORTA. 0x04CE, Bit Pos. = 7:0. 0x04CE, 7 = . 0x04CE, 6 = . 0x04CE, 5 = RA5. 0x04CE, 4 = RA4. 0x04CE, 3 = RA3. 0x04CE, 2 = RA2. 0x04CE, 1 = RA1. 0x04CE, 0 = RA0. 0x04CF, Name = PORTB. 0x04CF, Bit Pos. = 7:0.",
    "47. Register Summary\n0x04CF, 7 = RB7. 0x04CF, 6 = RB6. 0x04CF, 5 = RB5. 0x04CF, 4 = RB4. 0x04CF, 3 = . 0x04CF, 2 = . 0x04CF, 1 = . 0x04CF, 0 = . 0x04D0, Name = PORTC. 0x04D0, Bit Pos. = 7:0. 0x04D0, 7 = RC7. 0x04D0, 6 = RC6. 0x04D0, 5 = RC5. 0x04D0, 4 = RC4. 0x04D0, 3 = RC3. 0x04D0, 2 = RC2. 0x04D0, 1 = RC1. 0x04D0, 0 = RC0. 0x04D1, Name = . 0x04D1, Bit Pos. = . 0x04D1, 7 = . 0x04D1,",
    "47. Register Summary\n6 = . 0x04D1, 5 = . 0x04D1, 4 = . 0x04D1, 3 = . 0x04D1, 2 = . 0x04D1, 1 = . 0x04D1, 0 = . ... 0x04D5, Name = Reserved. ... 0x04D5, Bit Pos. = . ... 0x04D5, 7 = . ... 0x04D5, 6 = . ... 0x04D5, 5 = . ... 0x04D5, 4 = . ... 0x04D5, 3 = . ... 0x04D5, 2 = . ... 0x04D5, 1 = . ... 0x04D5, 0 = . 0x04D6, Name = INTCON0. 0x04D6, Bit Pos. = 7:0. 0x04D6, 7 = GIE/GIEH. 0x04D6, 6 =",
    "47. Register Summary\nGIEL. 0x04D6, 5 = IPEN. 0x04D6, 4 = . 0x04D6, 3 = . 0x04D6, 2 = INT2EDG. 0x04D6, 1 = INT1EDG. 0x04D6, 0 = INT0EDG. 0x04D7, Name = INTCON1. 0x04D7, Bit Pos. = 7:0. 0x04D7, 7 = STAT[1:0]. 0x04D7, 6 = . 0x04D7, 5 = . 0x04D7, 4 = . 0x04D7, 3 = . 0x04D7, 2 = . 0x04D7, 1 = . 0x04D7, 0 = . 0x04D8, Name = STATUS. 0x04D8, Bit Pos. = 7:0. 0x04D8, 7 = . 0x04D8, 6 = TO. 0x04D8, 5 = PD.",
    "47. Register Summary\n0x04D8, 4 = N. 0x04D8, 3 = OV. 0x04D8, 2 = Z. 0x04D8, 1 = DC. 0x04D8, 0 = C. , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = FSRL[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x04D9, Name = FSR2. 0x04D9, Bit Pos. = 15:8. 0x04D9, 7 = . 0x04D9, 6 = . 0x04D9, 5 = . 0x04D9, 4 = . 0x04D9, 3 = . 0x04D9, 2 = FSRH[5:0]. 0x04D9, 1 = . 0x04D9, 0 = . 0x04DB, Name = PLUSW2. 0x04DB, Bit Pos. =",
    "47. Register Summary\n7:0. 0x04DB, 7 = . 0x04DB, 6 = . 0x04DB, 5 = . 0x04DB, 4 = PLUSW[7:0]. 0x04DB, 3 = . 0x04DB, 2 = . 0x04DB, 1 = . 0x04DB, 0 = . 0x04DC, Name = PREINC2. 0x04DC, Bit Pos. = 7:0. 0x04DC, 7 = . 0x04DC, 6 = . 0x04DC, 5 = . 0x04DC, 4 = PREINC[7:0]. 0x04DC, 3 = . 0x04DC, 2 = . 0x04DC, 1 = . 0x04DC, 0 = . 0x04DD, Name = POSTDEC2. 0x04DD, Bit Pos. = 7:0. 0x04DD, 7 = . 0x04DD, 6 = . 0x04DD, 5 = . 0x04DD,",
    "47. Register Summary\n4 = . 0x04DD, 3 = POSTDEC[7:0]. 0x04DD, 2 = . 0x04DD, 1 = . 0x04DD, 0 = . 0x04DE, Name = POSTINC2. 0x04DE, Bit Pos. = 7:0. 0x04DE, 7 = . 0x04DE, 6 = . 0x04DE, 5 = . 0x04DE, 4 = POSTINC[7:0]. 0x04DE, 3 = . 0x04DE, 2 = . 0x04DE, 1 = . 0x04DE, 0 = . 0x04DF, Name = INDF2. 0x04DF, Bit Pos. = 7:0. 0x04DF, 7 = . 0x04DF, 6 = . 0x04DF, 5 = . 0x04DF, 4 = INDF[7:0]. 0x04DF, 3 = . 0x04DF, 2 = . 0x04DF, 1 = .",
    "47. Register Summary\n0x04DF, 0 = . 0x04E0, Name = BSR. 0x04E0, Bit Pos. = 7:0. 0x04E0, 7 = . 0x04E0, 6 = . 0x04E0, 5 = . 0x04E0, 4 = FSRL[7:0]. 0x04E0, 3 = . 0x04E0, 2 = BSR[5:0]. 0x04E0, 1 = . 0x04E0, 0 = . 0x04E1, Name = FSR1. 0x04E1, Bit Pos. = 7:0 15:8. 0x04E1, 7 = . 0x04E1, 6 = . 0x04E1, 5 = . 0x04E1, 4 = . 0x04E1, 3 = FSRH[5:0]. 0x04E1, 2 = . 0x04E1, 1 = . 0x04E1, 0 = .",
    "47. Register Summary\n0x04E3, Name = PLUSW1. 0x04E3, Bit Pos. = 7:0. 0x04E3, 7 = . 0x04E3, 6 = . 0x04E3, 5 = . 0x04E3, 4 = PLUSW[7:0]. 0x04E3, 3 = . 0x04E3, 2 = . 0x04E3, 1 = . 0x04E3, 0 = . 0x04E4, Name = PREINC1. 0x04E4, Bit Pos. = 7:0. 0x04E4, 7 = . 0x04E4, 6 = . 0x04E4, 5 = . 0x04E4, 4 = PREINC[7:0]. 0x04E4, 3 = . 0x04E4, 2 = . 0x04E4, 1 = . 0x04E4, 0 = . 0x04E5, Name = POSTDEC1.",
    "47. Register Summary\n0x04E5, Bit Pos. = 7:0. 0x04E5, 7 = . 0x04E5, 6 = . 0x04E5, 5 = . 0x04E5, 4 = POSTDEC[7:0]. 0x04E5, 3 = . 0x04E5, 2 = . 0x04E5, 1 = . 0x04E5, 0 = . 0x04E6, Name = POSTINC1. 0x04E6, Bit Pos. = 7:0. 0x04E6, 7 = . 0x04E6, 6 = . 0x04E6, 5 = . 0x04E6, 4 = POSTINC[7:0]. 0x04E6, 3 = INDF[7:0]. 0x04E6, 2 = . 0x04E6, 1 = . 0x04E6, 0 = ",
    "47. Register Summary\n0x04E8, Name = WREG. 0x04E8, Bit Pos. = 7:0. 0x04E8, 7 = . 0x04E8, 6 = . 0x04E8, 5 = . 0x04E8, 4 3 = WREG[7:0]. 0x04E8, 2 = . 0x04E8, 1 = . 0x04E8, 0 = . 0x04E8,  = . 0x04E9, Name = FSR0. 0x04E9, Bit Pos. = 7:0. 0x04E9, 7 = . 0x04E9, 6 = . 0x04E9, 5 = . 0x04E9, 4 3 = FSRL[7:0]. 0x04E9, 2 = . 0x04E9, 1 = . 0x04E9, 0 = . 0x04E9,",
    "47. Register Summary\n= . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = FSRH[5:0]. , 2 = FSRH[5:0]. , 1 = . , 0 = . ,  = . 0x04EB, Name = PLUSW0. 0x04EB, Bit Pos. = 7:0. 0x04EB, 7 = . 0x04EB, 6 = . 0x04EB, 5 = . 0x04EB, 4 3 = PLUSW[7:0]. 0x04EB, 2 = . 0x04EB, 1 = . 0x04EB, 0 = . 0x04EB,",
    "47. Register Summary\n= . 0x04EC, Name = PREINC0. 0x04EC, Bit Pos. = 7:0. 0x04EC, 7 = . 0x04EC, 6 = . 0x04EC, 5 = . 0x04EC, 4 3 = PREINC[7:0]. 0x04EC, 2 = . 0x04EC, 1 = . 0x04EC, 0 = . 0x04EC,  = . 0x04ED, Name = POSTDEC0. 0x04ED, Bit Pos. = 7:0. 0x04ED, 7 = . 0x04ED, 6 = . 0x04ED, 5 = . 0x04ED, 4 3 = POSTDEC[7:0]. 0x04ED, 2 = . 0x04ED, 1 = . 0x04ED, 0 = . 0x04ED,",
    "47. Register Summary\n= . 0x04EE, Name = POSTINC0. 0x04EE, Bit Pos. = 7:0. 0x04EE, 7 = . 0x04EE, 6 = . 0x04EE, 5 = . 0x04EE, 4 3 = POSTINC[7:0]. 0x04EE, 2 = . 0x04EE, 1 = . 0x04EE, 0 = . 0x04EE,  = . 0x04EF, Name = INDF0. 0x04EF, Bit Pos. = 7:0. 0x04EF, 7 = . 0x04EF, 6 = . 0x04EF, 5 = . 0x04EF, 4 3 = INDF[7:0]. 0x04EF, 2 = . 0x04EF, 1 = . 0x04EF, 0 = . 0x04EF,",
    "47. Register Summary\n= . 0x04F0, Name = PCON0. 0x04F0, Bit Pos. = 7:0. 0x04F0, 7 = STKOVF. 0x04F0, 6 = STKUNF. 0x04F0, 5 = WDTWV. 0x04F0, 4 3 = RWDT RMCLR. 0x04F0, 2 = RI. 0x04F0, 1 = POR. 0x04F0, 0 = BOR. 0x04F0,  = . 0x04F1, Name = PCON1. 0x04F1, Bit Pos. = 7:0. 0x04F1, 7 = . 0x04F1, 6 = . 0x04F1, 5 = . 0x04F1, 4 3 = . 0x04F1, 2 = RVREG. 0x04F1, 1 = MEMV. 0x04F1, 0 = RCM. 0x04F1,",
    "47. Register Summary\n= . 0x04F2, Name = CPUDOZE. 0x04F2, Bit Pos. = 7:0. 0x04F2, 7 = IDLEN. 0x04F2, 6 = DOZEN. 0x04F2, 5 = ROI. 0x04F2, 4 3 = DOE. 0x04F2, 2 = . 0x04F2, 1 = DOZE[2:0]. 0x04F2, 0 = . 0x04F2,  = . 0x04F3, Name = PROD. 0x04F3, Bit Pos. = 7:0. 0x04F3, 7 = . 0x04F3, 6 = . 0x04F3, 5 = . 0x04F3, 4 3 = PROD[7:0]. 0x04F3, 2 = . 0x04F3, 1 = . 0x04F3, 0 = . 0x04F3,",
    "47. Register Summary\n= . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = PROD[15:8]. , 2 = . , 1 = . , 0 = . ,  = . 0x04F5, Name = TABLAT. 0x04F5, Bit Pos. = 7:0. 0x04F5, 7 = . 0x04F5, 6 = . 0x04F5, 5 = . 0x04F5, 4 3 = TABLAT[7:0]. 0x04F5, 2 = . 0x04F5, 1 = . 0x04F5, 0 = . 0x04F5,  = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = TBLPTR[7:0]. , 2 = . , 1 = . , 0 = . ,",
    "47. Register Summary\n= . 0x04F6, Name = TBLPTR. 0x04F6, Bit Pos. = 15:8. 0x04F6, 7 = . 0x04F6, 6 = . 0x04F6, 5 = . 0x04F6, 4 3 = TBLPTR[15:8]. 0x04F6, 2 = . 0x04F6, 1 = . 0x04F6, 0 = . 0x04F6,  = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = TBLPTR21. , 4 3 = . , 2 = TBLPTR[20:16]. , 1 = . , 0 = . ,",
    "47. Register Summary\n= . 0x04F9, Name = PCL. 0x04F9, Bit Pos. = 7:0. 0x04F9, 7 = . 0x04F9, 6 = . 0x04F9, 5 = . 0x04F9, 4 3 = PCL[7:0]. 0x04F9, 2 = . 0x04F9, 1 = . 0x04F9, 0 = . 0x04F9,  = . 0x04FA, Name = . 0x04FA, Bit Pos. = 7:0. 0x04FA, 7 = . 0x04FA, 6 = . 0x04FA, 5 = . 0x04FA, 4 3 = PCLATH[7:0]. 0x04FA, 2 = . 0x04FA, 1 = . 0x04FA, 0 = . 0x04FA,",
    "47. Register Summary\n= . , Name = PCLAT. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = PCLATU[4:0]. , 1 = . , 0 = . ,  = . 0x04FC, Name = STKPTR. 0x04FC, Bit Pos. = 7:0. 0x04FC, 7 = . 0x04FC, 6 = . 0x04FC, 5 = . 0x04FC, 4 3 = STKPTR[6:0]. 0x04FC, 2 = . 0x04FC, 1 = . 0x04FC, 0 = . 0x04FC,  = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = TOS[7:0]. , 2 = . , 1 = . , 0 = . ,",
    "47. Register Summary\n= . 0x04FD, Name = TOS. 0x04FD, Bit Pos. = 15:8. 0x04FD, 7 = . 0x04FD, 6 = . 0x04FD, 5 = . 0x04FD, 4 3 = TOS[15:8]. 0x04FD, 2 = . 0x04FD, 1 = . 0x04FD, 0 = . 0x04FD,  = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = TOS[20:16]. , 1 = . , 0 = . ,",
    "47. Register Summary\n= . 0x0500 ... 0x2FFFFF, Name = Reserved. 0x0500 ... 0x2FFFFF, Bit Pos. = . 0x0500 ... 0x2FFFFF, 7 = . 0x0500 ... 0x2FFFFF, 6 = . 0x0500 ... 0x2FFFFF, 5 = . 0x0500 ... 0x2FFFFF, 4 3 = . 0x0500 ... 0x2FFFFF, 2 = . 0x0500 ... 0x2FFFFF, 1 = . 0x0500 ... 0x2FFFFF, 0 = . 0x0500 ... 0x2FFFFF,",
    "47. Register Summary\n= . 0x300000, Name = CONFIG1. 0x300000, Bit Pos. = 7:0. 0x300000, 7 = . 0x300000, 6 = . 0x300000, 5 = RSTOSC[2:0]. 0x300000, 4 3 = . 0x300000, 2 = FEXTOSC[2:0]. 0x300000, 1 = FEXTOSC[2:0]. 0x300000, 0 = FEXTOSC[2:0]. 0x300000,  = . 0x300001, Name = CONFIG2. 0x300001, Bit Pos. = 7:0. 0x300001, 7 = FCMENS. 0x300001, 6 = FCMENP. 0x300001, 5 = FCMEN. 0x300001, 4 3 = CSWEN. 0x300001, 2 = . 0x300001, 1 = PR1WAY. 0x300001, 0 = CLKOUTEN. 0x300001,",
    "47. Register Summary\n= . 0x300002, Name = CONFIG3. 0x300002, Bit Pos. = 7:0. 0x300002, 7 = . 0x300002, 6 = BOREN[1:0]. 0x300002, 5 = LPBOREN. 0x300002, 4 3 = IVT1WAY MVECEN. 0x300002, 2 = PWRTS[1:0]. 0x300002, 1 = . 0x300002, 0 = MCLRE. 0x300002,",
    "47. Register Summary\n= . 0x300003, Name = CONFIG4. 0x300003, Bit Pos. = 7:0. 0x300003, 7 = XINST. 0x300003, 6 = . 0x300003, 5 = LVP. 0x300003, 4 3 = STVREN PPS1WAY. 0x300003, 2 = ZCD. 0x300003, 1 = BORV[1:0]. 0x300003, 0 = BORV[1:0]. 0x300003,",
    "47. Register Summary\n= . 0x300004, Name = CONFIG5. 0x300004, Bit Pos. = 7:0. 0x300004, 7 = . 0x300004, 6 = . 0x300004, 5 = WDTE[1:0]. 0x300004, 4 3 = . 0x300004, 2 = WDTCPS[4:0]. 0x300004, 1 = . 0x300004, 0 = . 0x300004,",
    "47. Register Summary\n= . 0x300005, Name = CONFIG6. 0x300005, Bit Pos. = 7:0. 0x300005, 7 = . 0x300005, 6 = . 0x300005, 5 = . 0x300005, 4 3 = WDTCCS[2:0]. 0x300005, 2 = . 0x300005, 1 = WDTCWS[2:0]. 0x300005, 0 = . 0x300005,  = . 0x300006, Name = CONFIG7. 0x300006, Bit Pos. = 7:0. 0x300006, 7 = . 0x300006, 6 = . 0x300006, 5 = DEBUG. 0x300006, 4 3 = SAFEN. 0x300006, 2 = BBSIZE[2:0]. 0x300006, 1 = . 0x300006, 0 = . 0x300006,",
    "47. Register Summary\n= . 0x300007, Name = CONFIG8. 0x300007, Bit Pos. = 7:0. 0x300007, 7 = WRTAPP. 0x300007, 6 = . 0x300007, 5 = . 0x300007, 4 3 = BBEN WRTSAF. 0x300007, 2 = WRTD. 0x300007, 1 = WRTC. 0x300007, 0 = WRTB. 0x300007,  = . 0x300008, Name = CONFIG9. 0x300008, Bit Pos. = 7:0. 0x300008, 7 = . 0x300008, 6 = . 0x300008, 5 = . 0x300008, 4 3 = . 0x300008, 2 = . 0x300008, 1 = . 0x300008, 0 = CP. 0x300008,",
    "47. Register Summary\n= . 0x300009, Name = . 0x300009, Bit Pos. = . 0x300009, 7 = . 0x300009, 6 = . 0x300009, 5 = . 0x300009, 4 3 = . 0x300009, 2 = . 0x300009, 1 = . 0x300009, 0 = . 0x300009,  = . ... 0x3FFFFB, Name = Reserved. ... 0x3FFFFB, Bit Pos. = . ... 0x3FFFFB, 7 = . ... 0x3FFFFB, 6 = . ... 0x3FFFFB, 5 = . ... 0x3FFFFB, 4 3 = . ... 0x3FFFFB, 2 = . ... 0x3FFFFB, 1 = . ... 0x3FFFFB, 0 = . ... 0x3FFFFB,",
    "47. Register Summary\n= . , Name = . , Bit Pos. = 7:0. , 7 = MJRREV[1:0]. , 6 = MJRREV[1:0]. , 5 = . , 4 3 = MNRREV[5:0]. , 2 = . , 1 = . , 0 = . ,  = . 0x3FFFFC, Name = REVISIONID. 0x3FFFFC, Bit Pos. = 15:8. 0x3FFFFC, 7 = 1010[3:0]. 0x3FFFFC, 6 = 1010[3:0]. 0x3FFFFC, 5 = . 0x3FFFFC, 4 3 = . 0x3FFFFC, 2 = MJRREV[5:2]. 0x3FFFFC, 1 = . 0x3FFFFC, 0 = . 0x3FFFFC,",
    "47. Register Summary\n= . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = DEV[7:0]. , 2 = . , 1 = . , 0 = . ,  = . 0x3FFFFE, Name = DEVICEID. 0x3FFFFE, Bit Pos. = 15:8. 0x3FFFFE, 7 = . 0x3FFFFE, 6 = . 0x3FFFFE, 5 = . 0x3FFFFE, 4 3 = DEV[15:8]. 0x3FFFFE, 2 = . 0x3FFFFE, 1 = . 0x3FFFFE, 0 = . 0x3FFFFE,  = ",
    "48.1 Absolute Maximum Ratings (\u2020)\nAmbient temperature under bias,  = . Ambient temperature under bias, Rating = -40\u00b0C to +125\u00b0C. Storage temperature,  = . Storage temperature, Rating = -65\u00b0C to +150\u00b0C. Voltage on pins with respect to V SS,  = . Voltage on pins with respect to V SS, Rating = . \u2022 on V DD pin:,  = . \u2022 on V DD pin:, Rating = -0.3V to +6.5V. \u2022 on MCLR pin:,  = . \u2022 on MCLR pin:, Rating = -0.3V to +9.0V. \u2022 on all other pins:,  = . \u2022 on all other pins:, Rating = -0.3V to (V DD + 0.3V). Maximum current (1),  = . Maximum current (1), Rating = . \u2022 on V SS pin,  = -40\u00b0C \u2264 T A \u2264 +85\u00b0C 85\u00b0C <. \u2022 on V SS pin, Rating = 350 mA 120 mA. \u2022 on V DD pin (14-pin devices),",
    "48.1 Absolute Maximum Ratings (\u2020)\n= -40\u00b0C \u2264 T A \u2264 +85\u00b0C 85\u00b0C < T A \u2264 +125\u00b0C. \u2022 on V DD pin (14-pin devices), Rating = 140 mA 50 mA 190 mA. \u2022 on V DD pin (20-pin devices),  = -40\u00b0C \u2264 T A \u2264 +85\u00b0C 85\u00b0C < T A \u2264 +125\u00b0C. \u2022 on V DD pin (20-pin devices), Rating = 65 mA \u00b150 mA. Clamp current, I K (V PIN < 0 or V PIN > V DD ),  = . Clamp current, I K (V PIN < 0 or V PIN > V DD ), Rating = \u00b120 mA. ,  = . , Rating = 800 mW. Total power dissipation (2),  = . Total power dissipation (2), Rating = ",
    "Notes:\n1. Maximum current rating requires even load distribution across I/O pins. Maximum current rating may be limited by the device package power dissipation characterizations. See the Thermal Characteristics section to calculate device specifications.\n2. Power dissipation is calculated as follows: PDIS = V DD x {I DD - \u03a3 I OH} + \u03a3 {(V DD - V OH) x I OH} + \u03a3 (V OI x I OL)\n3. Internal Power Dissipation is calculated as follows: PINTERNAL = I DD x V DD\nwhere IDD is current to run the chip alone without driving any load on the output pins.\n4. I/O Power Dissipation is calculated as follows: PI/O = \u03a3(I OL*VOL)+\u03a3(I OH*(VDD-VOH))\n5. Derated Power is calculated as follows: PDER = PDMAX(TJ-TA)/\u03b8 JA\nwhere TA = Ambient Temperature, TJ = Junction Temperature.",
    "Notes:\nStresses above those listed under the 'Absolute Maximum Ratings' section may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure above maximum rating conditions for extended periods may affect device reliability.",
    "48.2 Standard Operating Conditions\nThe standard operating conditions for any device are defined as:\nOperating Voltage:\nVDDMIN \u2264 VDD \u2264 VDDMAX\nOperating\nTemperature:\nTA_MIN \u2264 T A \u2264 T A_MAX\nV DD -Operating Supply Voltage (1),  = V DDMIN V DDMAX. V DD -Operating Supply Voltage (1), Ratings = +1.8V +5.5V. T A -Operating Ambient Temperature Range,  = . T A -Operating Ambient Temperature Range, Ratings = . Industrial Temperature,  = T A_MIN T A_MAX. Industrial Temperature, Ratings = -40\u00b0C +85\u00b0C. Extended Temperature,  = T A_MIN T A_MAX. Extended Temperature, Ratings = -40\u00b0C +125\u00b0C",
    "Note:\n- 1. See the Parameter Supply Voltage for more details.\nFigure 48-1. Voltage Frequency Graph, -40\u00b0C \u2264 T A \u2264 +125\u00b0C",
    "Notes:\n\u00b7 The shaded region indicates the permissible combinations of voltage and frequency.\n\u00b7 Refer to the 'External Clock/Oscillator Timing Requirements' table for each Oscillator mode's supported frequencies.",
    "48.3.1 Supply Voltage\n\nTable 48-1.",
    "48.3.1 Supply Voltage\nSupply Voltage, Standard Operating Conditions (unless otherwise stated).Sym. = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Characteristic = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Min. = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Max. = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Units = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Conditions = Supply Voltage. D002, Standard Operating Conditions (unless otherwise stated).Sym. = V DD. D002, Standard Operating Conditions (unless otherwise stated).Characteristic = . D002, Standard Operating Conditions (unless otherwise stated).Min. = 1.8. D002, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D002, Standard Operating Conditions (unless otherwise stated).Max. = 5.5. D002, Standard Operating Conditions (unless otherwise stated).Units = V. D002, Standard Operating Conditions (unless otherwise",
    "48.3.1 Supply Voltage\nstated).Conditions = . RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Sym. = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Characteristic = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Min. = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Max. = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Units = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Conditions = RAM Data Retention (1). D003, Standard Operating Conditions (unless otherwise stated).Sym. = V DR. D003, Standard Operating Conditions (unless otherwise stated).Characteristic = . D003, Standard Operating Conditions (unless otherwise stated).Min. = 1.7. D003, Standard",
    "48.3.1 Supply Voltage\nOperating Conditions (unless otherwise stated).Typ.\u2020 = -. D003, Standard Operating Conditions (unless otherwise stated).Max. = -. D003, Standard Operating Conditions (unless otherwise stated).Units = V. D003, Standard Operating Conditions (unless otherwise stated).Conditions = Device in Sleep mode. Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Sym. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Characteristic = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Min. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Max. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise",
    "48.3.1 Supply Voltage\nstated).Units = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Conditions = Power-on Reset Release Voltage (2). D004, Standard Operating Conditions (unless otherwise stated).Sym. = V POR. D004, Standard Operating Conditions (unless otherwise stated).Characteristic = . D004, Standard Operating Conditions (unless otherwise stated).Min. = -. D004, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 1.6. D004, Standard Operating Conditions (unless otherwise stated).Max. = -. D004, Standard Operating Conditions (unless otherwise stated).Units = V. D004, Standard Operating Conditions (unless otherwise stated).Conditions = BOR and LPBOR disabled (3). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Sym. = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Characteristic = Power-on Reset Rearm Voltage",
    "48.3.1 Supply Voltage\n(2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Min. = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Max. = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Units = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Conditions = Power-on Reset Rearm Voltage (2). D005, Standard Operating Conditions (unless otherwise stated).Sym. = V PORR. D005, Standard Operating Conditions (unless otherwise stated).Characteristic = . D005, Standard Operating Conditions (unless otherwise stated).Min. = -. D005, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 1.",
    "48.3.1 Supply Voltage\nD005, Standard Operating Conditions (unless otherwise stated).Max. = -. D005, Standard Operating Conditions (unless otherwise stated).Units = V. D005, Standard Operating Conditions (unless otherwise stated).Conditions = BOR and LPBOR disabled (3). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Sym. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Characteristic = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Min. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset",
    "48.3.1 Supply Voltage\nsignal (2), Standard Operating Conditions (unless otherwise stated).Max. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Units = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Conditions = V DD Rise Rate to ensure internal Power-on Reset signal (2). D006, Standard Operating Conditions (unless otherwise stated).Sym. = S VDD. D006, Standard Operating Conditions (unless otherwise stated).Characteristic = . D006, Standard Operating Conditions (unless otherwise stated).Min. = 0.05. D006, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D006, Standard Operating Conditions (unless otherwise stated).Max. = -. D006, Standard Operating Conditions (unless otherwise stated).Units = V/ms. D006, Standard Operating Conditions (unless otherwise stated).Conditions =",
    "48.3.1 Supply Voltage\nBOR and LPBOR disabled (3)\n- \u2020 Data in 'Typ.' column is at 3.0V, 25 \u2103 unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. This is the limit to which V DD can be lowered in Sleep mode without losing RAM data.\n2. See the following figure, POR and POR REARM with Slow Rising VDD.\n3. See Reset, WDT, Oscillator Start-up Timer, Brown-Out Reset and Low-Power Brown-Out Reset Specifications for BOR and LPBOR trip point information.\nFigure 48-2. POR and POR Rearm with Slow Rising VDD\n1. When NPOR is low, the device is held in Reset.\n2. TPOR 1 \u03bcs typical.\n3. TVLOW 2.7 \u03bcs typical.",
    "Standard Operating Conditions (unless otherwise stated)\nD100, Sym.. = I DD XT4. D100, Device Characteristics. = XT = 4 MHz. D100, Min.. = -. D100, Typ.\u2020. = 640. D100, Max.. = 870. D100, Units. = \u03bcA. D100, Conditions.V DD = 3.0V. D100, Conditions.Note = . D100A, Sym.. = I DD XT4. D100A, Device Characteristics. = XT = 4 MHz. D100A, Min.. = -. D100A, Typ.\u2020. = 490. D100A, Max.. = 700. D100A, Units. = \u03bcA. D100A, Conditions.V DD = 3.0V. D100A, Conditions.Note = All PMD bits are '1'. D101, Sym.. = I DD HFO16. D101, Device Characteristics. = HFINTOSC = 16 MHz. D101, Min.. = -. D101, Typ.\u2020. = 2. D101, Max..",
    "Standard Operating Conditions (unless otherwise stated)\n= 2.5. D101, Units. = mA. D101, Conditions.V DD = 3.0V. D101, Conditions.Note = . D101A, Sym.. = I DD HFO16. D101A, Device Characteristics. = HFINTOSC = 16 MHz. D101A, Min.. = -. D101A, Typ.\u2020. = 1.5. D101A, Max.. = 1.9. D101A, Units. = mA. D101A, Conditions.V DD = 3.0V. D101A, Conditions.Note = All PMD bits are '1'. D102, Sym.. = I DD HFOPLL. D102, Device Characteristics. = HFINTOSC = 64 MHz. D102, Min.. = -. D102, Typ.\u2020. = 6.7. D102, Max.. = 8.2. D102, Units. = mA. D102, Conditions.V DD = 3.0V. D102,",
    "Standard Operating Conditions (unless otherwise stated)\nConditions.Note = . D102A, Sym.. = I DD HFOPLL. D102A, Device Characteristics. = HFINTOSC = 64 MHz. D102A, Min.. = -. D102A, Typ.\u2020. = 4.5. D102A, Max.. = 5.4. D102A, Units. = mA. D102A, Conditions.V DD = 3.0V. D102A, Conditions.Note = All PMD bits are '1'. D103, Sym.. = I DD HSPLL64. D103, Device Characteristics. = HS+PLL = 64 MHz. D103, Min.. = -. D103, Typ.\u2020. = 5.6. D103, Max.. = 13.8. D103, Units. = mA. D103, Conditions.V DD = 3.0V. D103, Conditions.Note = . D103A, Sym.. = I DD HSPLL64. D103A, Device Characteristics. =",
    "Standard Operating Conditions (unless otherwise stated)\nHS+PLL = 64 MHz. D103A, Min.. = -. D103A, Typ.\u2020. = 3.8. D103A, Max.. = 11.5. D103A, Units. = mA. D103A, Conditions.V DD = 3.0V. D103A, Conditions.Note = All PMD bits are '1'. D104, Sym.. = I DD IDLE. D104, Device Characteristics. = Idle mode, HFINTOSC = 16 MHz. D104, Min.. = -. D104, Typ.\u2020. = 1.4. D104, Max.. = 1.8. D104, Units. = mA. D104, Conditions.V DD = 3.0V. D104, Conditions.Note = . D105, Sym.. = I DD DOZE (3). D105, Device Characteristics. = Doze mode, HFINTOSC = 16 MHz, Doze Ratio = 16. D105, Min.. = -. D105,",
    "Standard Operating Conditions (unless otherwise stated)\nTyp.\u2020. = 1.5. D105, Max.. = 1.9. D105, Units. = mA. D105, Conditions.V DD = 3.0V. D105, Conditions.Note = \n- \u2020 Data in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. The test conditions for all I DD measurements in Active Operation mode are: OSC1 = external square wave, from rail-to-rail; all I/O pins are outputs driven low; MCLR = V DD; WDT disabled.\n2. The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\n3. I DDDOZE = [I DDIDLE *(N-1)/N] + I DDHFO 16/N where N = Doze Ratio (see the CPUDOZE register).\n4. PMD bits are all in the Default state, no modules are disabled.",
    "Standard Operating Conditions (unless otherwise stated)\nD200, Sym..Sym. = I PD. D200, Device Characteristics.Device Characteristics = I PD Base. D200, Min..Min. = -. D200, Typ.\u2020.Typ.\u2020 = 1. D200, Max. +85\u00b0C.Max. +85\u00b0C = 3. D200, Max. +125\u00b0C.Max. +125\u00b0C = 4.3. D200, Units.Units = \u03bcA. D200, Conditions.V DD = 3.0V. D200, Conditions.VREGPM = 'b11. D200, Conditions.Note = . , Sym..Sym. = . , Device Characteristics.Device Characteristics = . , Min..Min. = -. , Typ.\u2020.Typ.\u2020 = 0.5. , Max. +85\u00b0C.Max. +85\u00b0C = 4.0. , Max. +125\u00b0C.Max. +125\u00b0C = 9.0. , Units.Units = \u03bcA. , Conditions.V DD = 3.0V. , Conditions.VREGPM = 'b10. ,",
    "Standard Operating Conditions (unless otherwise stated)\nConditions.Note = . , Sym..Sym. = . , Device Characteristics.Device Characteristics = . , Min..Min. = -. , Typ.\u2020.Typ.\u2020 = 38.0. , Max. +85\u00b0C.Max. +85\u00b0C = 53.0. , Max. +125\u00b0C.Max. +125\u00b0C = 68.9. , Units.Units = \u03bcA. , Conditions.V DD = 3.0V. , Conditions.VREGPM = 'b01. , Conditions.Note = . , Sym..Sym. = . , Device Characteristics.Device Characteristics = . , Min..Min. = -. , Typ.\u2020.Typ.\u2020 = 171. , Max. +85\u00b0C.Max. +85\u00b0C = 215. , Max. +125\u00b0C.Max. +125\u00b0C = 292. , Units.Units = \u03bcA. , Conditions.V DD = 3.0V. , Conditions.VREGPM = 'b00. , Conditions.Note = . D201, Sym..Sym. = I",
    "Standard Operating Conditions (unless otherwise stated)\nPD_WDT. D201, Device Characteristics.Device Characteristics = Low-Frequency Internal Oscillator/WDT. D201, Min..Min. = -. D201, Typ.\u2020.Typ.\u2020 = 1.41. D201, Max. +85\u00b0C.Max. +85\u00b0C = 3.50. D201, Max. +125\u00b0C.Max. +125\u00b0C = 5.00. D201, Units.Units = \u03bcA. D201, Conditions.V DD = 3.0V. D201, Conditions.VREGPM = 'b11. D201, Conditions.Note = . D202, Sym..Sym. = I PD_SOSC. D202, Device Characteristics.Device Characteristics = Secondary Oscillator (S OSC ). D202, Min..Min. = -. D202, Typ.\u2020.Typ.\u2020 = 2.1. D202, Max. +85\u00b0C.Max. +85\u00b0C = 4.6. D202, Max.",
    "Standard Operating Conditions (unless otherwise stated)\n+125\u00b0C.Max. +125\u00b0C = 7.9. D202, Units.Units = \u03bcA. D202, Conditions.V DD = 3.0V. D202, Conditions.VREGPM = 'b11. D202, Conditions.Note = ",
    "Standard Operating Conditions (unless otherwise stated)\nD203, Sym..Sym. = I PD_LPBOR. D203, Device Characteristics.Device Characteristics = Low-Power Brown-out Reset (LPBOR). D203, Min..Min. = -. D203, Typ.\u2020.Typ.\u2020 = 1.2. D203, Max. +85\u00b0C.Max. +85\u00b0C = 3.2. D203, Max. +125\u00b0C.Max. +125\u00b0C = 4.5. D203, Units.Units = \u03bcA. D203, Conditions.V DD = 3.0V. D203, Conditions.VREGPM = 'b11. D203, Conditions.Note = . D204, Sym..Sym. = I PD_FVR_BUF1. D204, Device Characteristics.Device Characteristics = FVR Buffer 1 (ADC). D204, Min..Min. = -. D204, Typ.\u2020.Typ.\u2020 = 183. D204, Max. +85\u00b0C.Max. +85\u00b0C",
    "Standard Operating Conditions (unless otherwise stated)\n= 265. D204, Max. +125\u00b0C.Max. +125\u00b0C = 270. D204, Units.Units = \u03bcA. D204, Conditions.V DD = 3.0V. D204, Conditions.VREGPM = 'b11. D204, Conditions.Note = . D204A, Sym..Sym. = I PD_FVR_BUF2. D204A, Device Characteristics.Device Characteristics = FVR Buffer 2 (DAC/CMP). D204A, Min..Min. = -. D204A, Typ.\u2020.Typ.\u2020 = 59.0. D204A, Max. +85\u00b0C.Max. +85\u00b0C = 84.0. D204A, Max. +125\u00b0C.Max. +125\u00b0C = 90.7. D204A, Units.Units = \u03bcA. D204A, Conditions.V DD = 3.0V. D204A, Conditions.VREGPM = 'bx1 or 'b10. D204A,",
    "Standard Operating Conditions (unless otherwise stated)\nConditions.Note = . D205, Sym..Sym. = I PD_BOR. D205, Device Characteristics.Device Characteristics = Brown-out Reset (BOR). D205, Min..Min. = -. D205, Typ.\u2020.Typ.\u2020 = 16.6. D205, Max. +85\u00b0C.Max. +85\u00b0C = 21.0. D205, Max. +125\u00b0C.Max. +125\u00b0C = 22.0. D205, Units.Units = \u03bcA. D205, Conditions.V DD = 3.0V. D205, Conditions.VREGPM = 'b11. D205, Conditions.Note = . D206, Sym..Sym. = I PD_HLVD. D206, Device Characteristics.Device Characteristics = High/Low- Voltage Detect (HLVD). D206, Min..Min. = -. D206, Typ.\u2020.Typ.\u2020 = 16.6. D206, Max. +85\u00b0C.Max.",
    "Standard Operating Conditions (unless otherwise stated)\n+85\u00b0C = 21.5. D206, Max. +125\u00b0C.Max. +125\u00b0C = 22.5. D206, Units.Units = \u03bcA. D206, Conditions.V DD = 3.0V. D206, Conditions.VREGPM = 'b11. D206, Conditions.Note = . D207, Sym..Sym. = I PD_ADCA. D207, Device Characteristics.Device Characteristics = ADC - Active. D207, Min..Min. = -. D207, Typ.\u2020.Typ.\u2020 = 485. D207, Max. +85\u00b0C.Max. +85\u00b0C = 789. D207, Max. +125\u00b0C.Max. +125\u00b0C = 790. D207, Units.Units = \u03bcA. D207, Conditions.V DD = 3.0V. D207, Conditions.VREGPM = 'bx1 or 'b10. D207, Conditions.Note = ADC is converting (Note 4). D208,",
    "Standard Operating Conditions (unless otherwise stated)\nSym..Sym. = I PD_CMP. D208, Device Characteristics.Device Characteristics = Comparator. D208, Min..Min. = -. D208, Typ.\u2020.Typ.\u2020 = 60. D208, Max. +85\u00b0C.Max. +85\u00b0C = 95. D208, Max. +125\u00b0C.Max. +125\u00b0C = 105. D208, Units.Units = \u03bcA. D208, Conditions.V DD = 3.0V. D208, Conditions.VREGPM = 'b11. D208, Conditions.Note = . D209, Sym..Sym. = I PD_OPA. D209, Device Characteristics.Device Characteristics = Operational Amplifier. D209, Min..Min. = -. D209, Typ.\u2020.Typ.\u2020 = 0.959. D209, Max. +85\u00b0C.Max. +85\u00b0C = 1.67. D209, Max. +125\u00b0C.Max. +125\u00b0C =",
    "Standard Operating Conditions (unless otherwise stated)\n1.73. D209, Units.Units = mA. D209, Conditions.V DD = 3.0V. D209, Conditions.VREGPM = 'b01. D209, Conditions.Note = Charge Pump On; V ICM = V DD /2. , Sym..Sym. = . , Device Characteristics.Device Characteristics = . , Min..Min. = -. , Typ.\u2020.Typ.\u2020 = 0.68. , Max. +85\u00b0C.Max. +85\u00b0C = 1.2. , Max. +125\u00b0C.Max. +125\u00b0C = 1.4. , Units.Units = \u03bcA. , Conditions.V DD = 3.0V. , Conditions.VREGPM = 'b01. , Conditions.Note = Charge Pump Off; V ICM = V DD /2\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. The peripheral current is the sum of the base I DD and the additional current consumed when this peripheral is enabled. The peripheral \u2206 current can be determined by subtracting the base IDD or I PD current from this limit. Max. values may be used when calculating total current consumption.\n2. The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode with all I/O pins in high-impedance state and tied to V SS .\n3. All peripheral currents listed are on a per-peripheral basis if more than one instance of a peripheral is available.\n4. ADC clock source is ADCRC.",
    "48.3.4 I/O Ports\n\nTable 48-4.",
    "48.3.4 I/O Ports\nInput Low-Voltage, Standard Operating Conditions (unless otherwise stated).Sym. = Input Low-Voltage. Input Low-Voltage, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Input Low-Voltage. Input Low-Voltage, Standard Operating Conditions (unless otherwise stated).Min. = Input Low-Voltage. Input Low-Voltage, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Input Low-Voltage. Input Low-Voltage, Standard Operating Conditions (unless otherwise stated).Max. = Input Low-Voltage. Input Low-Voltage, Standard Operating Conditions (unless otherwise stated).Units = Input Low-Voltage. Input Low-Voltage, Standard Operating Conditions (unless otherwise stated).Conditions = Input Low-Voltage. , Standard Operating Conditions (unless otherwise stated).Sym. = V IL. , Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Min. = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Max. = I/O",
    "48.3.4 I/O Ports\nPORT:. , Standard Operating Conditions (unless otherwise stated).Units = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Conditions = I/O PORT:. D300, Standard Operating Conditions (unless otherwise stated).Sym. = . D300, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with TTL buffer. D300, Standard Operating Conditions (unless otherwise stated).Min. = -. D300, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D300, Standard Operating Conditions (unless otherwise stated).Max. = 0.8. D300, Standard Operating Conditions (unless otherwise stated).Units = V. D300, Standard Operating Conditions (unless otherwise stated).Conditions = 4.5V \u2264 V DD \u2264 5.5V. D301, Standard Operating Conditions (unless otherwise stated).Sym. = . D301, Standard Operating Conditions (unless otherwise stated).Device Characteristics = . D301, Standard Operating Conditions (unless otherwise stated).Min. = -. D301, Standard Operating Conditions (unless otherwise",
    "48.3.4 I/O Ports\nstated).Typ.\u2020 = -. D301, Standard Operating Conditions (unless otherwise stated).Max. = 0.15 V DD. D301, Standard Operating Conditions (unless otherwise stated).Units = V. D301, Standard Operating Conditions (unless otherwise stated).Conditions = 1.8V \u2264 V DD < 4.5V. D302, Standard Operating Conditions (unless otherwise stated).Sym. = . D302, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with Schmitt Trigger buffer. D302, Standard Operating Conditions (unless otherwise stated).Min. = -. D302, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D302, Standard Operating Conditions (unless otherwise stated).Max. = 0.2 V DD. D302, Standard Operating Conditions (unless otherwise stated).Units = V. D302, Standard Operating Conditions (unless otherwise stated).Conditions = 2.0V \u2264 V DD \u2264 5.5V. D303, Standard Operating Conditions (unless otherwise stated).Sym. = . D303, Standard",
    "48.3.4 I/O Ports\nOperating Conditions (unless otherwise stated).Device Characteristics = \u2022 with I 2 C levels. D303, Standard Operating Conditions (unless otherwise stated).Min. = -. D303, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D303, Standard Operating Conditions (unless otherwise stated).Max. = 0.3 V DD. D303, Standard Operating Conditions (unless otherwise stated).Units = V. D303, Standard Operating Conditions (unless otherwise stated).Conditions = 2.0V \u2264 V DD \u2264 5.5V. D304, Standard Operating Conditions (unless otherwise stated).Sym. = . D304, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with SMBus 2.0. D304, Standard Operating Conditions (unless otherwise stated).Min. = -. D304, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D304, Standard Operating Conditions (unless otherwise stated).Max. = 0.8. D304, Standard Operating Conditions (unless otherwise stated).Units = V. D304, Standard Operating Conditions",
    "48.3.4 I/O Ports\n(unless otherwise stated).Conditions = 2.7V \u2264 V DD \u2264 5.5V. D305, Standard Operating Conditions (unless otherwise stated).Sym. = . D305, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with SMBus 3.0. D305, Standard Operating Conditions (unless otherwise stated).Min. = -. D305, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D305, Standard Operating Conditions (unless otherwise stated).Max. = 0.8. D305, Standard Operating Conditions (unless otherwise stated).Units = V. D305, Standard Operating Conditions (unless otherwise stated).Conditions = . D306, Standard Operating Conditions (unless otherwise stated).Sym. = . D306, Standard Operating Conditions (unless otherwise stated).Device Characteristics = MCLR. D306, Standard Operating Conditions (unless otherwise stated).Min. = -. D306, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D306, Standard Operating Conditions (unless otherwise stated).Max. =",
    "48.3.4 I/O Ports\n0.2 V DD. D306, Standard Operating Conditions (unless otherwise stated).Units = V. D306, Standard Operating Conditions (unless otherwise stated).Conditions = ",
    "48.3.4 I/O Ports\nHigh/Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = High/Low-Voltage. High/Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = High/Low-Voltage. High/Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = High/Low-Voltage. High/Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = High/Low-Voltage. High/Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Max. = High/Low-Voltage. High/Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Units = High/Low-Voltage. High/Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions =",
    "48.3.4 I/O Ports\nHigh/Low-Voltage. , ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = V IH. , ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORT:. , ...........continued Standard Operating Conditions (unless otherwise stated).Min. = . , ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = . , ...........continued Standard Operating Conditions (unless otherwise stated).Max. = . , ...........continued Standard Operating Conditions (unless otherwise stated).Units = . , ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = . D320, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = V IH. D320, ...........continued Standard",
    "48.3.4 I/O Ports\nOperating Conditions (unless otherwise stated).Device Characteristics = \u2022 with TTL buffer. D320, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = 2.0. D320, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D320, ...........continued Standard Operating Conditions (unless otherwise stated).Max. = -. D320, ...........continued Standard Operating Conditions (unless otherwise stated).Units = V. D320, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = 4.5V \u2264 V DD \u2264 5.5V. D321, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = V IH. D321, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with TTL buffer.",
    "48.3.4 I/O Ports\nD321, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = 0.25 V DD + 0.8. D321, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D321, ...........continued Standard Operating Conditions (unless otherwise stated).Max. = -. D321, ...........continued Standard Operating Conditions (unless otherwise stated).Units = V. D321, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = 1.8V \u2264 V DD < 4.5V. D322, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = V IH. D322, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with Schmitt Trigger buffer. D322,",
    "48.3.4 I/O Ports\n...........continued Standard Operating Conditions (unless otherwise stated).Min. = 0.8 V DD. D322, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D322, ...........continued Standard Operating Conditions (unless otherwise stated).Max. = -. D322, ...........continued Standard Operating Conditions (unless otherwise stated).Units = V. D322, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = 2.0V \u2264 V DD \u2264 5.5V. D323, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = V IH. D323, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with I 2 C levels. D323, ...........continued Standard Operating",
    "48.3.4 I/O Ports\nConditions (unless otherwise stated).Min. = 0.7 V DD. D323, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D323, ...........continued Standard Operating Conditions (unless otherwise stated).Max. = -. D323, ...........continued Standard Operating Conditions (unless otherwise stated).Units = V. D323, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = . D324, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = V IH. D324, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with SMBus 2.0. D324, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = 2.1. D324,",
    "48.3.4 I/O Ports\n...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D324, ...........continued Standard Operating Conditions (unless otherwise stated).Max. = -. D324, ...........continued Standard Operating Conditions (unless otherwise stated).Units = V. D324, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = 2.7V \u2264 V DD \u2264 5.5V. D325, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = V IH. D325, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with SMBus 3.0. D325, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = 1.35. D325, ...........continued Standard Operating Conditions",
    "48.3.4 I/O Ports\n(unless otherwise stated).Typ.\u2020 = -. D325, ...........continued Standard Operating Conditions (unless otherwise stated).Max. = -. D325, ...........continued Standard Operating Conditions (unless otherwise stated).Units = V. D325, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = . D326, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = V IH. D326, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = MCLR. D326, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = 0.7 V DD. D326, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D326, ...........continued Standard",
    "48.3.4 I/O Ports\nOperating Conditions (unless otherwise stated).Max. = -. D326, ...........continued Standard Operating Conditions (unless otherwise stated).Units = V. D326, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = . Input Leakage Current (1), ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = Input Leakage Current (1). Input Leakage Current (1), ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = Input Leakage Current (1). Input Leakage Current (1), ...........continued Standard Operating Conditions (unless otherwise stated).Min. = Input Leakage Current (1). Input Leakage Current (1), ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Input Leakage Current (1). Input Leakage Current (1),",
    "48.3.4 I/O Ports\n...........continued Standard Operating Conditions (unless otherwise stated).Max. = Input Leakage Current (1). Input Leakage Current (1), ...........continued Standard Operating Conditions (unless otherwise stated).Units = Input Leakage Current (1). Input Leakage Current (1), ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = Input Leakage Current (1). D340, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = I IL. D340, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORTS. D340, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = -. D340, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = \u00b15. D340,",
    "48.3.4 I/O Ports\n...........continued Standard Operating Conditions (unless otherwise stated).Max. = \u00b1125. D340, ...........continued Standard Operating Conditions (unless otherwise stated).Units = nA. D340, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = V SS \u2264 V PIN \u2264 V DD , Pin at high-impedance, 85\u00b0C. D341, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = I IL. D341, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORTS. D341, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = -. D341, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = \u00b15. D341,",
    "48.3.4 I/O Ports\n...........continued Standard Operating Conditions (unless otherwise stated).Max. = \u00b11000. D341, ...........continued Standard Operating Conditions (unless otherwise stated).Units = nA. D341, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = V SS \u2264 V PIN \u2264 V DD , Pin at high-impedance, 125\u00b0C. D342, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = I IL. D342, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = MCLR (2). D342, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = -. D342, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = \u00b150. D342,",
    "48.3.4 I/O Ports\n...........continued Standard Operating Conditions (unless otherwise stated).Max. = \u00b1200. D342, ...........continued Standard Operating Conditions (unless otherwise stated).Units = nA. D342, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = V SS \u2264 V PIN \u2264 V DD , Pin at high-impedance, 85\u00b0C. Weak Pull-up Current, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = Weak Pull-up Current. Weak Pull-up Current, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = Weak Pull-up Current. Weak Pull-up Current, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = Weak Pull-up Current. Weak Pull-up Current, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Weak",
    "48.3.4 I/O Ports\nPull-up Current. Weak Pull-up Current, ...........continued Standard Operating Conditions (unless otherwise stated).Max. = Weak Pull-up Current. Weak Pull-up Current, ...........continued Standard Operating Conditions (unless otherwise stated).Units = Weak Pull-up Current. Weak Pull-up Current, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = Weak Pull-up Current. D350, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = I PUR. D350, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = . D350, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = 80. D350, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 140. D350,",
    "48.3.4 I/O Ports\n...........continued Standard Operating Conditions (unless otherwise stated).Max. = 200. D350, ...........continued Standard Operating Conditions (unless otherwise stated).Units = \u03bcA. D350, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = V DD = 3.0V, V PIN = V SS. Output Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = Output Low-Voltage. Output Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = Output Low-Voltage. Output Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = Output Low-Voltage. Output Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Output Low-Voltage. Output Low-Voltage,",
    "48.3.4 I/O Ports\n...........continued Standard Operating Conditions (unless otherwise stated).Max. = Output Low-Voltage. Output Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Units = Output Low-Voltage. Output Low-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = Output Low-Voltage. D360, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = V OL. D360, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORTS. D360, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = -. D360, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D360, ...........continued Standard Operating Conditions (unless otherwise",
    "48.3.4 I/O Ports\nstated).Max. = 0.6. D360, ...........continued Standard Operating Conditions (unless otherwise stated).Units = V. D360, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = I OL = 10.0 mA, V PIN = 3.0V. Output High-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = Output High-Voltage. Output High-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = Output High-Voltage. Output High-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = Output High-Voltage. Output High-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Output High-Voltage. Output High-Voltage, ...........continued Standard Operating Conditions (unless otherwise",
    "48.3.4 I/O Ports\nstated).Max. = Output High-Voltage. Output High-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Units = Output High-Voltage. Output High-Voltage, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = Output High-Voltage. D370, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = V OH. D370, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORTS. D370, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = V DD - 0.7. D370, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D370, ...........continued Standard Operating Conditions (unless otherwise stated).Max. = -. D370,",
    "48.3.4 I/O Ports\n...........continued Standard Operating Conditions (unless otherwise stated).Units = V. D370, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = I OH = 6.0 mA, V PIN = 3.0V. All I/O Pins, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = All I/O Pins. All I/O Pins, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = All I/O Pins. All I/O Pins, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = All I/O Pins. All I/O Pins, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = All I/O Pins. All I/O Pins, ...........continued Standard Operating Conditions (unless otherwise stated).Max. = All",
    "48.3.4 I/O Ports\nI/O Pins. All I/O Pins, ...........continued Standard Operating Conditions (unless otherwise stated).Units = All I/O Pins. All I/O Pins, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = All I/O Pins. D380, ...........continued Standard Operating Conditions (unless otherwise stated).Sym. = C IO. D380, ...........continued Standard Operating Conditions (unless otherwise stated).Device Characteristics = . D380, ...........continued Standard Operating Conditions (unless otherwise stated).Min. = -. D380, ...........continued Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 5. D380, ...........continued Standard Operating Conditions (unless otherwise stated).Max. = 50. D380, ...........continued Standard Operating Conditions",
    "48.3.4 I/O Ports\n(unless otherwise stated).Units = pF. D380, ...........continued Standard Operating Conditions (unless otherwise stated).Conditions = \n- \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. Negative current is defined as current sourced by the pin.\n2. The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.",
    "Table 48-5.\nData EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Sym. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Min. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Max. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Units = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Conditions = Data EEPROM Memory Specifications. MEM20, Standard Operating Conditions (unless otherwise stated).Sym. = E D. MEM20, Standard Operating Conditions (unless otherwise stated).Device Characteristics = DataEE Byte Endurance. MEM20, Standard Operating Conditions (unless otherwise stated).Min. = 100k. MEM20, Standard Operating Conditions (unless",
    "Table 48-5.\notherwise stated).Typ\u2020 = -. MEM20, Standard Operating Conditions (unless otherwise stated).Max. = -. MEM20, Standard Operating Conditions (unless otherwise stated).Units = E/W. MEM20, Standard Operating Conditions (unless otherwise stated).Conditions = -40\u00b0C \u2264 T A \u2264 +85\u00b0C. MEM21, Standard Operating Conditions (unless otherwise stated).Sym. = T D_RET. MEM21, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Characteristic Retention. MEM21, Standard Operating Conditions (unless otherwise stated).Min. = -. MEM21, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = 40. MEM21, Standard Operating Conditions (unless otherwise stated).Max. = -. MEM21, Standard Operating Conditions (unless otherwise stated).Units = Year. MEM21, Standard Operating Conditions (unless otherwise stated).Conditions = Provided no other specifications are violated. MEM23, Standard Operating Conditions (unless otherwise stated).Sym. = V D_RW. MEM23, Standard Operating Conditions (unless otherwise stated).Device Characteristics = V",
    "Table 48-5.\nDD for Read or Erase/Write operation. MEM23, Standard Operating Conditions (unless otherwise stated).Min. = V DDMIN. MEM23, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = -. MEM23, Standard Operating Conditions (unless otherwise stated).Max. = V DDMAX. MEM23, Standard Operating Conditions (unless otherwise stated).Units = V. MEM23, Standard Operating Conditions (unless otherwise stated).Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\nMEM24, Sym. = T D_BEW. MEM24, Device Characteristics = Byte Erase and Write Cycle Time. MEM24, Min. = -. MEM24, Typ\u2020 = -. MEM24, Max. = 11. MEM24, Units = ms. MEM24, Conditions = . Program Flash Memory Specifications, Sym. = Program Flash Memory Specifications. Program Flash Memory Specifications, Device Characteristics = Program Flash Memory Specifications. Program Flash Memory Specifications, Min. = Program Flash Memory Specifications. Program Flash Memory Specifications, Typ\u2020 = Program Flash Memory Specifications. Program Flash Memory Specifications, Max. = Program Flash Memory Specifications. Program Flash Memory Specifications, Units = Program Flash Memory Specifications. Program Flash Memory Specifications, Conditions = Program Flash Memory Specifications. MEM30, Sym. = E P. MEM30, Device Characteristics = Flash Memory Cell Endurance. MEM30, Min. = 1k. MEM30, Typ\u2020 = -. MEM30, Max. = -. MEM30, Units = E/W. MEM30, Conditions = -40\u00b0C \u2264 T A \u2264 +85\u00b0C (Note 1).",
    "Standard Operating Conditions (unless otherwise stated)\nMEM32, Sym. = T P_RET. MEM32, Device Characteristics = Characteristic Retention. MEM32, Min. = -. MEM32, Typ\u2020 = 40. MEM32, Max. = -. MEM32, Units = Year. MEM32, Conditions = Provided no other specifications are violated. MEM33, Sym. = V P_RD. MEM33, Device Characteristics = V DD for Read operation. MEM33, Min. = V DDMIN. MEM33, Typ\u2020 = -. MEM33, Max. = V DDMAX. MEM33, Units = V. MEM33, Conditions = . MEM34, Sym. = V P_REW. MEM34, Device Characteristics = V DD for Row Erase or Write operation. MEM34, Min. = V DDMIN. MEM34, Typ\u2020 = -. MEM34, Max. = V DDMAX. MEM34, Units = V. MEM34, Conditions = . MEM35, Sym. = T P_REW. MEM35, Device Characteristics = Self-Timed Page",
    "Standard Operating Conditions (unless otherwise stated)\nWrite. MEM35, Min. = -. MEM35, Typ\u2020 = -. MEM35, Max. = 10. MEM35, Units = ms. MEM35, Conditions = . MEM36, Sym. = T SE. MEM36, Device Characteristics = Self-Timed Page Erase. MEM36, Min. = -. MEM36, Typ\u2020 = -. MEM36, Max. = 11. MEM36, Units = ms. MEM36, Conditions = . MEM37, Sym. = T P_WRD. MEM37, Device Characteristics = Self-Timed Word Write. MEM37, Min. = -. MEM37, Typ\u2020 = -. MEM37, Max. = 75. MEM37, Units = \u03bcs. MEM37, Conditions = \n- \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Flash Memory Cell Endurance for the Flash memory is defined as: One Row Erase operation and one Self-Timed Write.",
    "48.3.6 Thermal Characteristics\nTable 48-6.",
    "Standard Operating Conditions (unless otherwise stated)\nTH01, Sym. = \u03b8 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 95.3. TH01, Units = \u00b0C/W. TH01, Conditions = 14-pin SOIC package. , Sym. = . , Characteristic = . , Typ. = 100. , Units = \u00b0C/W. , Conditions = 14-pin TSSOP package. , Sym. = . , Characteristic = . , Typ. = 62.2. , Units = \u00b0C/W. , Conditions = 20-pin PDIP package. , Sym. = . , Characteristic = . , Typ. = 77.7. , Units = \u00b0C/W. , Conditions = 20-pin SOIC package. , Sym. = . , Characteristic = . , Typ. = 87.3. , Units = \u00b0C/W. , Conditions = 20-pin SSOP package. , Sym. = . , Characteristic = . , Typ. = 79.7. , Units = \u00b0C/W. , Conditions = 20-pin VQFN package. TH02, Sym. = T JMAX.",
    "Standard Operating Conditions (unless otherwise stated)\nTH02, Characteristic = Maximum Junction Temperature. TH02, Typ. = 150. TH02, Units = \u00b0C. TH02, Conditions = ",
    "Note:\n- 1. See 'Absolute Maximum Ratings' for total power dissipation.",
    "48.4 AC Characteristics\nFigure 48-3. Load Conditions\nLegend: CL = 50 pF for all pins",
    "48.4.1 External Clock/Oscillator Timing Requirements\nFigure 48-4. Clock Timing\nNote: See the table below.\n\nTable 48-7.",
    "48.4.1 External Clock/Oscillator Timing Requirements\nECL Oscillator, Sym. = ECL Oscillator. ECL Oscillator, Characteristic = ECL Oscillator. ECL Oscillator, Min. = ECL Oscillator. ECL Oscillator, Typ. \u2020 = ECL Oscillator. ECL Oscillator, Max. = ECL Oscillator. ECL Oscillator, Units = ECL Oscillator. ECL Oscillator, Conditions = ECL Oscillator. OS1, Sym. = F ECL. OS1, Characteristic = Clock Frequency. OS1, Min. = -. OS1, Typ. \u2020 = -. OS1, Max. = 1. OS1, Units = MHz. OS1, Conditions = . OS2, Sym. = T ECL_DC. OS2, Characteristic = Clock Duty Cycle. OS2, Min. = 40. OS2, Typ. \u2020 = -. OS2, Max. = 60. OS2, Units = %. OS2, Conditions = . ECM",
    "48.4.1 External Clock/Oscillator Timing Requirements\nOscillator, Sym. = ECM Oscillator. ECM Oscillator, Characteristic = ECM Oscillator. ECM Oscillator, Min. = ECM Oscillator. ECM Oscillator, Typ. \u2020 = ECM Oscillator. ECM Oscillator, Max. = ECM Oscillator. ECM Oscillator, Units = ECM Oscillator. ECM Oscillator, Conditions = ECM Oscillator. OS3, Sym. = F ECM. OS3, Characteristic = Clock Frequency. OS3, Min. = -. OS3, Typ. \u2020 = -. OS3, Max. = 16. OS3, Units = MHz. OS3, Conditions = . OS4, Sym. = T ECM_DC. OS4, Characteristic = Clock Duty Cycle. OS4, Min. = 40. OS4, Typ. \u2020 = -. OS4, Max. = 60. OS4, Units = %. OS4, Conditions = . ECH",
    "48.4.1 External Clock/Oscillator Timing Requirements\nOscillator, Sym. = ECH Oscillator. ECH Oscillator, Characteristic = ECH Oscillator. ECH Oscillator, Min. = ECH Oscillator. ECH Oscillator, Typ. \u2020 = ECH Oscillator. ECH Oscillator, Max. = ECH Oscillator. ECH Oscillator, Units = ECH Oscillator. ECH Oscillator, Conditions = ECH Oscillator. OS5, Sym. = F ECH. OS5, Characteristic = Clock Frequency. OS5, Min. = -. OS5, Typ. \u2020 = -. OS5, Max. = 64. OS5, Units = MHz. OS5, Conditions = V DD \u2265 2.7V. OS5, Sym. = F ECH. OS5, Characteristic = Clock Frequency. OS5, Min. = -. OS5, Typ. \u2020 = -. OS5, Max. = 32. OS5, Units = MHz. OS5, Conditions = V DD <",
    "48.4.1 External Clock/Oscillator Timing Requirements\n2.7V. OS6, Sym. = T ECH_DC. OS6, Characteristic = Clock Duty Cycle. OS6, Min. = 40. OS6, Typ. \u2020 = -. OS6, Max. = 60. OS6, Units = %. OS6, Conditions = . LP Oscillator, Sym. = LP Oscillator. LP Oscillator, Characteristic = LP Oscillator. LP Oscillator, Min. = LP Oscillator. LP Oscillator, Typ. \u2020 = LP Oscillator. LP Oscillator, Max. = LP Oscillator. LP Oscillator, Units = LP Oscillator. LP Oscillator, Conditions = LP Oscillator. OS7, Sym. = F LP. OS7, Characteristic = Clock Frequency. OS7, Min. = -. OS7, Typ. \u2020 = 32. OS7, Max. = -. OS7, Units = kHz. OS7, Conditions = (Note 4). XT Oscillator, Sym.",
    "48.4.1 External Clock/Oscillator Timing Requirements\n= XT Oscillator. XT Oscillator, Characteristic = XT Oscillator. XT Oscillator, Min. = XT Oscillator. XT Oscillator, Typ. \u2020 = XT Oscillator. XT Oscillator, Max. = XT Oscillator. XT Oscillator, Units = XT Oscillator. XT Oscillator, Conditions = XT Oscillator. OS8, Sym. = F XT. OS8, Characteristic = Clock Frequency. OS8, Min. = -. OS8, Typ. \u2020 = -. OS8, Max. = 4. OS8, Units = MHz. OS8, Conditions = (Note 4). HS Oscillator, Sym. = HS Oscillator. HS Oscillator, Characteristic = HS Oscillator. HS Oscillator, Min. = HS Oscillator. HS Oscillator, Typ. \u2020 = HS Oscillator. HS Oscillator, Max. =",
    "48.4.1 External Clock/Oscillator Timing Requirements\nHS Oscillator. HS Oscillator, Units = HS Oscillator. HS Oscillator, Conditions = HS Oscillator. OS9, Sym. = F HS. OS9, Characteristic = Clock Frequency. OS9, Min. = -. OS9, Typ. \u2020 = -. OS9, Max. = 20. OS9, Units = MHz. OS9, Conditions = V DD > 2.5V (Note 4). Secondary Oscillator, Sym. = Secondary Oscillator. Secondary Oscillator, Characteristic = Secondary Oscillator. Secondary Oscillator, Min. = Secondary Oscillator. Secondary Oscillator, Typ. \u2020 = Secondary Oscillator. Secondary Oscillator, Max. = Secondary Oscillator. Secondary Oscillator, Units = Secondary Oscillator. Secondary Oscillator, Conditions = Secondary Oscillator. OS10, Sym. = F SEC. OS10, Characteristic = Clock Frequency. OS10, Min. = 32.4. OS10, Typ. \u2020",
    "48.4.1 External Clock/Oscillator Timing Requirements\n= 32.768. OS10, Max. = 33.1. OS10, Units = kHz. OS10, Conditions = (Note 4). System Oscillator, Sym. = System Oscillator. System Oscillator, Characteristic = System Oscillator. System Oscillator, Min. = System Oscillator. System Oscillator, Typ. \u2020 = System Oscillator. System Oscillator, Max. = System Oscillator. System Oscillator, Units = System Oscillator. System Oscillator, Conditions = System Oscillator",
    "Standard Operating Conditions (unless otherwise stated)\nOS20, Sym. = F OSC. OS20, Characteristic = System Clock Frequency. OS20, Min. = -. OS20, Typ. \u2020 = -. OS20, Max. = 64. OS20, Units = MHz. OS20, Conditions = (Note 2, Note 3). OS21, Sym. = F CY. OS21, Characteristic = Instruction Frequency. OS21, Min. = -. OS21, Typ. \u2020 = F OSC /4. OS21, Max. = -. OS21, Units = MHz. OS21, Conditions = . OS22, Sym. = T CY. OS22, Characteristic = Instruction Period. OS22, Min. = 62.5. OS22, Typ. \u2020 = 1/F CY. OS22, Max. = -. OS22, Units = ns. OS22, Conditions = ",
    "Notes:\n1. Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min' values with an external clock applied to OSC1 pin. When an external clock input is used, the 'max' cycle time limit is 'DC' (no clock) for all devices.\n2. The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power Saving Operation Modes' section.\n3. The system clock frequency (FOSC) must meet the voltage requirements defined in the 'Standard Operating Conditions' section.\n4. LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.",
    "Standard Operating Conditions (unless otherwise stated)\nOS50, Sym. = F HFOSC. OS50, Characteristic = Precision Calibrated HFINTOSC Frequency. OS50, Min. = -. OS50, Typ. \u2020 = 4 8 12 16 32 48 64. OS50, Max. = -. OS50, Units = MHz. OS50, Conditions = ( Note 2 ). OS51, Sym. = F HFOSCLP. OS51, Characteristic = Low-Power Optimized HFINTOSC Frequency. OS51, Min. = 0.92 1.84 0.88 1.76. OS51, Typ. \u2020 = 1 2 1 2. OS51, Max. = 1.08 2.16 1.12 2.24. OS51, Units = MHz MHz MHz MHz. OS51, Conditions = -40\u00b0C \u2264 T A \u2264 85\u00b0C -40\u00b0C \u2264 T A \u2264 85\u00b0C 85\u00b0C \u2264 T A \u2264 125\u00b0C. OS52, Sym. = F MFOSC. OS52, Characteristic = Internal Calibrated MFINTOSC Frequency. OS52, Min. = -. OS52, Typ. \u2020 =",
    "Standard Operating Conditions (unless otherwise stated)\n500. OS52, Max. = -. OS52, Units = kHz. OS52, Conditions = . OS53, Sym. = F LFOSC. OS53, Characteristic = Internal LFINTOSC Frequency. OS53, Min. = 24.8. OS53, Typ. \u2020 = 31. OS53, Max. = 37.2. OS53, Units = kHz. OS53, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\nOS54, Sym. = T HFOSCST. OS54, Characteristic = HFINTOSC Wake-up from Sleep Start-up Time. OS54, Min. = -. OS54, Typ. \u2020 = 13. OS54, Max. = 20. OS54, Units = \u03bcs. OS54, Conditions = VREGPM = 00 System Clock at 4 MHz V DD = 3.0V. , Sym. = . , Characteristic = . , Min. = -. , Typ. \u2020 = 30. , Max. = 48. , Units = \u03bcs. , Conditions = VREGPM = 01 System Clock at 4 MHz V DD = 3.0V. , Sym. = . , Characteristic = . , Min. = -. , Typ. \u2020 = 115. , Max. = 210. , Units = \u03bcs. , Conditions = VREGPM = 10 System Clock at 4 MHz V DD = 3.0V. , Sym. = . , Characteristic = . , Min. = -. , Typ. \u2020 = 120. , Max. = 220. , Units = \u03bcs. , Conditions = VREGPM = 11 System",
    "Standard Operating Conditions (unless otherwise stated)\nClock at 4 MHz V DD = 3.0V. OS56, Sym. = T LFOSCST. OS56, Characteristic = LFINTOSC Wake-up from Sleep Start-up Time. OS56, Min. = -. OS56, Typ. \u2020 = 292. OS56, Max. = 420. OS56, Units = \u03bcs. OS56, Conditions = 25\u00baC \u2264 T A \u2264 125\u00baC V DD = 3.0V VREGPM = xx\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. To ensure these oscillator frequency tolerances, V DD and VSS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended.\n2. See the figure below.\nFigure 48-5. Precision Calibrated HFINTOSC Frequency Accuracy Over Device V DD and Temperature\n125",
    "48.4.3 PLL Specifications\nTable 48-9.",
    "Standard Operating Conditions (unless otherwise stated)\nPLL01, Sym. = F PLLIN. PLL01, Characteristic = PLL Input Frequency Range. PLL01, Min. = 4. PLL01, Typ. \u2020 = -. PLL01, Max. = 16. PLL01, Units = MHz. PLL01, Conditions = . PLL02, Sym. = F PLLOUT. PLL02, Characteristic = PLL Output Frequency Range. PLL02, Min. = 16. PLL02, Typ. \u2020 = -. PLL02, Max. = 64. PLL02, Units = MHz. PLL02, Conditions = ( Note 1 ). PLL03*, Sym. = F PLLST. PLL03*, Characteristic = PLL Lock Time. PLL03*, Min. = -. PLL03*, Typ. \u2020 = 200. PLL03*, Max. = -. PLL03*, Units = \u03bcs. PLL03*, Conditions = . PLL04*, Sym. = F PLLJIT.",
    "Standard Operating Conditions (unless otherwise stated)\nPLL04*, Characteristic = PLL Output Frequency Stability. PLL04*, Min. = -0.25. PLL04*, Typ. \u2020 = -. PLL04*, Max. = 0.25. PLL04*, Units = %. PLL04*, Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. The output frequency of the PLL must meet the FOSC requirements listed in Parameter D002.",
    "Figure 48-6. CLKOUT and I/O Timing\nTable 48-10. I/O and CLKOUT Timing Specifications",
    "Figure 48-6. CLKOUT and I/O Timing\nIO1*, Standard Operating Conditions (unless otherwise stated).Sym. = T CLKOUTH. IO1*, Standard Operating Conditions (unless otherwise stated).Characteristic = CLKOUT rising edge delay (rising edge F OSC (Q1 cycle) to falling edge CLKOUT. IO1*, Standard Operating Conditions (unless otherwise stated).Min. = -. IO1*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. IO1*, Standard Operating Conditions (unless otherwise stated).Max. = 70. IO1*, Standard Operating Conditions (unless otherwise stated).Units = ns. IO1*, Standard Operating Conditions (unless otherwise stated).Conditions = . IO2*, Standard Operating Conditions (unless otherwise stated).Sym. = T CLKOUTL. IO2*, Standard Operating Conditions (unless otherwise stated).Characteristic = CLKOUT falling edge delay (rising edge F OSC (Q3 cycle) to rising edge CLKOUT. IO2*, Standard Operating Conditions (unless otherwise stated).Min. = -. IO2*, Standard Operating Conditions (unless otherwise",
    "Figure 48-6. CLKOUT and I/O Timing\nstated).Typ. \u2020 = -. IO2*, Standard Operating Conditions (unless otherwise stated).Max. = 72. IO2*, Standard Operating Conditions (unless otherwise stated).Units = ns. IO2*, Standard Operating Conditions (unless otherwise stated).Conditions = . IO3*, Standard Operating Conditions (unless otherwise stated).Sym. = T IO_VALID. IO3*, Standard Operating Conditions (unless otherwise stated).Characteristic = Port output valid time (rising edge F OSC (Q1 cycle) to port valid). IO3*, Standard Operating Conditions (unless otherwise stated).Min. = -. IO3*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 50. IO3*, Standard Operating Conditions (unless otherwise stated).Max. = 70. IO3*, Standard Operating Conditions (unless otherwise stated).Units = ns. IO3*, Standard Operating Conditions (unless otherwise stated).Conditions = . IO4*, Standard Operating Conditions (unless otherwise stated).Sym. = T IO_SETUP. IO4*, Standard Operating Conditions (unless otherwise stated).Characteristic",
    "Figure 48-6. CLKOUT and I/O Timing\n= Port input setup time (Setup time before rising edge F OSC - Q2 cycle). IO4*, Standard Operating Conditions (unless otherwise stated).Min. = 20. IO4*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. IO4*, Standard Operating Conditions (unless otherwise stated).Max. = -. IO4*, Standard Operating Conditions (unless otherwise stated).Units = ns. IO4*, Standard Operating Conditions (unless otherwise stated).Conditions = . IO5*, Standard Operating Conditions (unless otherwise stated).Sym. = T IO_HOLD. IO5*, Standard Operating Conditions (unless otherwise stated).Characteristic = Port input hold time (Hold time after rising edge F OSC - Q2 cycle). IO5*, Standard Operating Conditions (unless otherwise stated).Min. = 50. IO5*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. IO5*, Standard Operating Conditions (unless otherwise stated).Max. = -. IO5*, Standard Operating Conditions (unless otherwise stated).Units = ns. IO5*, Standard",
    "Figure 48-6. CLKOUT and I/O Timing\nOperating Conditions (unless otherwise stated).Conditions = . IO6*, Standard Operating Conditions (unless otherwise stated).Sym. = T IOR_SLREN. IO6*, Standard Operating Conditions (unless otherwise stated).Characteristic = Port I/O rise time, slew rate enabled. IO6*, Standard Operating Conditions (unless otherwise stated).Min. = -. IO6*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 25. IO6*, Standard Operating Conditions (unless otherwise stated).Max. = -. IO6*, Standard Operating Conditions (unless otherwise stated).Units = ns. IO6*, Standard Operating Conditions (unless otherwise stated).Conditions = V DD = 3.0V. IO7*, Standard Operating Conditions (unless otherwise stated).Sym. = T IOR_SLRDIS. IO7*, Standard Operating Conditions (unless otherwise stated).Characteristic = Port I/O rise time, slew rate disabled. IO7*, Standard Operating Conditions (unless otherwise stated).Min. = -. IO7*, Standard Operating Conditions (unless otherwise",
    "Figure 48-6. CLKOUT and I/O Timing\nstated).Typ. \u2020 = 5. IO7*, Standard Operating Conditions (unless otherwise stated).Max. = -. IO7*, Standard Operating Conditions (unless otherwise stated).Units = ns. IO7*, Standard Operating Conditions (unless otherwise stated).Conditions = V DD = 3.0V. IO8*, Standard Operating Conditions (unless otherwise stated).Sym. = T IOF_SLREN. IO8*, Standard Operating Conditions (unless otherwise stated).Characteristic = Port I/O fall time, slew rate enabled. IO8*, Standard Operating Conditions (unless otherwise stated).Min. = -. IO8*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 25. IO8*, Standard Operating Conditions (unless otherwise stated).Max. = -. IO8*, Standard Operating Conditions (unless otherwise stated).Units = ns. IO8*, Standard Operating Conditions (unless otherwise stated).Conditions = V DD = 3.0V. IO9*, Standard Operating Conditions (unless otherwise stated).Sym. = T IOF_SLRDIS.",
    "Figure 48-6. CLKOUT and I/O Timing\nIO9*, Standard Operating Conditions (unless otherwise stated).Characteristic = Port I/O fall time, slew rate disabled. IO9*, Standard Operating Conditions (unless otherwise stated).Min. = -. IO9*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 5. IO9*, Standard Operating Conditions (unless otherwise stated).Max. = -. IO9*, Standard Operating Conditions (unless otherwise stated).Units = ns. IO9*, Standard Operating Conditions (unless otherwise stated).Conditions = V DD = 3.0V. IO10*, Standard Operating Conditions (unless otherwise stated).Sym. = T INT. IO10*, Standard Operating Conditions (unless otherwise stated).Characteristic = INT pin high or low time to trigger an interrupt. IO10*, Standard Operating Conditions (unless otherwise stated).Min. = 25. IO10*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. IO10*, Standard Operating Conditions (unless otherwise stated).Max. = -. IO10*, Standard Operating Conditions (unless otherwise stated).Units = ns.",
    "Figure 48-6. CLKOUT and I/O Timing\nIO10*, Standard Operating Conditions (unless otherwise stated).Conditions = ",
    "Figure 48-6. CLKOUT and I/O Timing\nIO11*, ...........continued.Standard Operating Conditions Param = T IOC. IO11*, ...........continued.Characteristic = Interrupt-on-Change minimum high or low time to trigger interrupt. IO11*, ...........continued.Min. = 25. IO11*, ...........continued.Typ. \u2020 = -. IO11*, ...........continued.Max. = -. IO11*, ...........continued.Units = ns. IO11*, ...........continued.Conditions = . * These parameters are characterized but not tested., ...........continued.Standard Operating Conditions Param = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Characteristic = * These parameters are characterized but not tested.. *",
    "Figure 48-6. CLKOUT and I/O Timing\nThese parameters are characterized but not tested., ...........continued.Min. = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Typ. \u2020 = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Max. = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Units = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Conditions = * These parameters are characterized but not tested.",
    "48.4.5 Reset, WDT, Oscillator Start-Up Timer, Power-Up Timer, Brown-Out Reset and Low-Power Brown-Out Reset Specifications\nFigure 48-7. Reset, Watchdog Timer, Oscillator Start-Up Timer and Power-Up Timer Timing",
    "Note:\n- 1. Asserted low.\nFigure 48-8. Brown-out Reset Timing and Characteristics\n- 1. Only if the PWRTE Configuration bit is programmed to ' 1 '; 2 ms delay if PWRTE = 0 .\nTable 48-11.",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Standard Operating Conditions (unless otherwise stated)\nRST01*, Sym. = T MCLR. RST01*, Characteristic = MCLR Pulse Width Low to ensure Reset. RST01*, Min. = -. RST01*, Typ. \u2020 = -. RST01*, Max. = -. RST01*, Units = \u03bcs. RST01*, Conditions = . RST02*, Sym. = T IOZ. RST02*, Characteristic = I/O high-impedance from Reset detection. RST02*, Min. = -. RST02*, Typ. \u2020 = -. RST02*, Max. = 2. RST02*, Units = \u03bcs. RST02*, Conditions = . RST03, Sym. = T WDT. RST03, Characteristic = Watchdog Timer Time- out Period. RST03, Min. = -. RST03, Typ. \u2020 = 16. RST03, Max. = -. RST03, Units = ms. RST03, Conditions = WDTCPS =",
    "Standard Operating Conditions (unless otherwise stated)\n00100. RST04*, Sym. = T PWRT. RST04*, Characteristic = Power-up Timer Period. RST04*, Min. = -. RST04*, Typ. \u2020 = 65. RST04*, Max. = -. RST04*, Units = ms. RST04*, Conditions = . RST05, Sym. = T OST. RST05, Characteristic = Oscillator Start-up Timer Period (1,2). RST05, Min. = -. RST05, Typ. \u2020 = 1024. RST05, Max. = -. RST05, Units = T OSC. RST05, Conditions = . RST06, Sym. = V BOR. RST06, Characteristic = Brown-out Reset Voltage. RST06, Min. = 2.7. RST06, Typ. \u2020 = 2.85. RST06, Max. = 3.0. RST06, Units = V.",
    "Standard Operating Conditions (unless otherwise stated)\nRST06, Conditions = BORV = 00. , Sym. = . , Characteristic = . , Min. = 2.55. , Typ. \u2020 = 2.7. , Max. = 2.85. , Units = V. , Conditions = BORV = 01. , Sym. = . , Characteristic = . , Min. = 2.3. , Typ. \u2020 = 2.45. , Max. = 2.6. , Units = V. , Conditions = BORV = 10. , Sym. = . , Characteristic = . , Min. = 1.8. , Typ. \u2020 = 1.9. , Max. = 2.1. , Units = V. , Conditions = BORV = 11. RST07, Sym. = V BORHYS. RST07, Characteristic = Brown-out Reset Hysteresis. RST07, Min. = -. RST07, Typ. \u2020 = 60. RST07, Max. = -. RST07, Units = mV. RST07, Conditions = BORV = 00.",
    "Standard Operating Conditions (unless otherwise stated)\nRST08, Sym. = T BORDC. RST08, Characteristic = Brown-out Reset Response Time. RST08, Min. = -. RST08, Typ. \u2020 = 3. RST08, Max. = -. RST08, Units = \u03bcs. RST08, Conditions = . RST09, Sym. = V LPBOR. RST09, Characteristic = Low-Power Brown-out Reset Voltage. RST09, Min. = 1.8. RST09, Typ. \u2020 = 1.9. RST09, Max. = 2.2. RST09, Units = V. RST09, Conditions = ",
    "Notes:\n1. By design, the Oscillator Start-up Timer (OST) counts the first 1024 cycles, independent of frequency.\n2. To ensure these voltage tolerances, VDD and VSS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended.",
    "48.4.6 High/Low-Voltage Detect Characteristics\nTable 48-12.",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Standard Operating Conditions (unless otherwise stated)\nHLVD01, Sym. = V DET. HLVD01, Characteristic = Voltage Detect. HLVD01, Min. = 1.73 (1). HLVD01, Typ. = 1.90. HLVD01, Max. = 2.07. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL = 0000. , Sym. = . , Characteristic = . , Min. = 1.91. , Typ. = 2.10. , Max. = 2.29. , Units = V. , Conditions = HLVDSEL = 0001. , Sym. = . , Characteristic = . , Min. = 2.05. , Typ. = 2.25. , Max. = 2.45. , Units = V. , Conditions = HLVDSEL = 0010. , Sym. = . , Characteristic = . , Min. = 2.28. , Typ. = 2.50. , Max. = 2.73. , Units = V. , Conditions = HLVDSEL = 0011. , Sym. = . , Characteristic =",
    "Standard Operating Conditions (unless otherwise stated)\n. , Min. = 2.37. , Typ. = 2.60. , Max. = 2.83. , Units = V. , Conditions = HLVDSEL = 0100. , Sym. = . , Characteristic = . , Min. = 2.5. , Typ. = 2.75. , Max. = 3.00. , Units = V. , Conditions = HLVDSEL = 0101. , Sym. = . , Characteristic = . , Min. = 2.64. , Typ. = 2.90. , Max. = 3.16. , Units = V. , Conditions = HLVDSEL = 0110. , Sym. = . , Characteristic = . , Min. = 2.87. , Typ. = 3.15. , Max. = 3.43. , Units = V. , Conditions = HLVDSEL = 0111. , Sym. = . , Characteristic = . , Min. = 3.05. , Typ. = 3.35. , Max. = 3.65. , Units = V. , Conditions = HLVDSEL = 1000. ,",
    "Standard Operating Conditions (unless otherwise stated)\nSym. = . , Characteristic = . , Min. = 3.28. , Typ. = 3.60. , Max. = 3.92. , Units = V. , Conditions = HLVDSEL = 1001. , Sym. = . , Characteristic = . , Min. = 3.41. , Typ. = 3.75. , Max. = 4.09. , Units = V. , Conditions = HLVDSEL = 1010. , Sym. = . , Characteristic = . , Min. = 3.64. , Typ. = 4.00. , Max. = 4.36. , Units = V. , Conditions = HLVDSEL = 1011. , Sym. = . , Characteristic = . , Min. = 3.82. , Typ. = 4.20. , Max. = 4.58. , Units = V. , Conditions = HLVDSEL = 1100. , Sym. = . , Characteristic = . , Min. = 3.96. , Typ. = 4.35. , Max. = 4.74. , Units = V. , Conditions =",
    "Standard Operating Conditions (unless otherwise stated)\nHLVDSEL = 1101. , Sym. = . , Characteristic = . , Min. = 4.23. , Typ. = 4.65. , Max. = 5.07. , Units = V. , Conditions = HLVDSEL = 1110",
    "Note:\n- 1. Device operation below VDD = 1.8 V is not recommended.",
    "48.4.7 Analog-to-Digital Converter (ADC) Accuracy Specifications (1,2)\nTable 48-13.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 500ns\nAD01, Sym. = N R. AD01, Characteristic = Resolution. AD01, Min. = -. AD01, Typ. \u2020 = -. AD01, Max. = 12. AD01, Units = bit. AD01, Conditions = . AD02, Sym. = E IL. AD02, Characteristic = Integral Nonlinearity Error. AD02, Min. = -. AD02, Typ. \u2020 = \u00b10.1. AD02, Max. = \u00b12.0. AD02, Units = LSb. AD02, Conditions = ADC REF + = 3.0V, ADC REF - = 0V. AD03, Sym. = E DL. AD03, Characteristic = Differential Nonlinearity Error. AD03, Min. = -. AD03, Typ. \u2020 = \u00b10.1. AD03, Max. = \u00b11.0. AD03, Units = LSb. AD03, Conditions = ADC REF + = 3.0V,",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 500ns\nADC REF - = 0V. AD04, Sym. = E OFF. AD04, Characteristic = Offset Error. AD04, Min. = -. AD04, Typ. \u2020 = 0.5. AD04, Max. = 6.0. AD04, Units = LSb. AD04, Conditions = ADC REF + = 3.0V, ADC REF - = 0V. AD05, Sym. = E GN. AD05, Characteristic = Gain Error. AD05, Min. = -. AD05, Typ. \u2020 = \u00b10.2. AD05, Max. = \u00b16.0. AD05, Units = LSb. AD05, Conditions = ADC REF + = 3.0V, ADC REF - = 0V. AD06, Sym. = V ADREF. AD06, Characteristic = ADC Reference Voltage (AD REF + - AD REF -). AD06, Min. = 1.8.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 500ns\nAD06, Typ. \u2020 = -. AD06, Max. = V DD. AD06, Units = V. AD06, Conditions = . AD07, Sym. = V AIN. AD07, Characteristic = Full-Scale Range. AD07, Min. = AD REF -. AD07, Typ. \u2020 = -. AD07, Max. = AD REF +. AD07, Units = V. AD07, Conditions = . AD08, Sym. = Z AIN. AD08, Characteristic = Recommended Impedance of Analog Voltage Source. AD08, Min. = -. AD08, Typ. \u2020 = 1. AD08, Max. = -. AD08, Units = k\u03a9. AD08, Conditions = . AD09, Sym. = R VREF. AD09, Characteristic = ADC Voltage Reference Ladder Impedance. AD09, Min. = -. AD09, Typ. \u2020 = 50. AD09, Max.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 500ns\n= -. AD09, Units = k\u03a9. AD09, Conditions = (Note 3)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. Total Absolute Error is the sum of the offset, gain and integral nonlinearity (INL) errors.\n2. The ADC conversion result never decreases with an increase in the input and has no missing codes.\n3. This is the impedance seen by the VREF pads when the external reference pads are selected.",
    "48.4.8 Analog-to-Digital Converter (ADC) Conversion Timing Specifications\nAD20, Standard Operating Conditions (unless otherwise stated).Sym. = T AD. AD20, Standard Operating Conditions (unless otherwise stated).Characteristic = ADC Clock Period. AD20, Standard Operating Conditions (unless otherwise stated).Min. = 0.5. AD20, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. AD20, Standard Operating Conditions (unless otherwise stated).Max. = 9. AD20, Standard Operating Conditions (unless otherwise stated).Units = \u03bcs. AD20, Standard Operating Conditions (unless otherwise stated).Conditions = Using F OSC as the ADC clock source ADOCS = 0. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Min. = -. , Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 2. , Standard Operating Conditions (unless otherwise stated).Max. = -. , Standard Operating Conditions (unless otherwise stated).Units = \u03bcs. , Standard Operating Conditions (unless otherwise",
    "48.4.8 Analog-to-Digital Converter (ADC) Conversion Timing Specifications\nstated).Conditions = Using ADCRC as the ADC clock source ADOCS = 1. AD21, Standard Operating Conditions (unless otherwise stated).Sym. = T CNV. AD21, Standard Operating Conditions (unless otherwise stated).Characteristic = Conversion Time. AD21, Standard Operating Conditions (unless otherwise stated).Min. = -. AD21, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 14 T AD +2T CY. AD21, Standard Operating Conditions (unless otherwise stated).Max. = -. AD21, Standard Operating Conditions (unless otherwise stated).Units = -. AD21, Standard Operating Conditions (unless otherwise stated).Conditions = Using F OSC as the ADC clock source ADOCS = 0. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Min. = -. , Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 16 T AD +2T CY. , Standard Operating Conditions (unless otherwise",
    "48.4.8 Analog-to-Digital Converter (ADC) Conversion Timing Specifications\nstated).Max. = -. , Standard Operating Conditions (unless otherwise stated).Units = -. , Standard Operating Conditions (unless otherwise stated).Conditions = Using ADCRC as the ADC clock source ADOCS = 1. AD22, Standard Operating Conditions (unless otherwise stated).Sym. = T HCD. AD22, Standard Operating Conditions (unless otherwise stated).Characteristic = Sample-and-Hold Capacitor Disconnect Time. AD22, Standard Operating Conditions (unless otherwise stated).Min. = -. AD22, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 2 T AD +1T CY. AD22, Standard Operating Conditions (unless otherwise stated).Max. = -. AD22, Standard Operating Conditions (unless otherwise stated).Units = -. AD22, Standard Operating Conditions (unless otherwise stated).Conditions = Using F OSC as the ADC clock source ADOCS = 0. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise",
    "48.4.8 Analog-to-Digital Converter (ADC) Conversion Timing Specifications\nstated).Min. = -. , Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 3 T AD +2T CY. , Standard Operating Conditions (unless otherwise stated).Max. = -. , Standard Operating Conditions (unless otherwise stated).Units = -. , Standard Operating Conditions (unless otherwise stated).Conditions = Using ADCRC as the ADC clock source ADOCS = 1\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFigure 48-9. ADC Conversion Timing (ADC Clock F OSC -Based)\nFigure 48-10. ADC Conversion Timing (ADC Clock from ADCRC)\nNote 1: If the ADC clock source is selected as ADCRC, a time of 1 TCY is added before the ADC clock starts. This allows the SLEEP instruction to be executed, if any.",
    "48.4.9 Comparator Specifications\nTable 48-14.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nCM01, Sym. = V IOFF. CM01, Characteristic = Input Offset Voltage. CM01, Min. = -. CM01, Typ. \u2020 = -. CM01, Max. = \u00b150. CM01, Units = mV. CM01, Conditions = V ICM = V DD /2. CM02, Sym. = V ICM. CM02, Characteristic = Input Common Mode Range. CM02, Min. = GND. CM02, Typ. \u2020 = -. CM02, Max. = V DD. CM02, Units = V. CM02, Conditions = . CM03, Sym. = CMRR. CM03, Characteristic = Common Mode Input Rejection Ratio. CM03, Min. = -. CM03, Typ. \u2020 = 50. CM03, Max. = -. CM03, Units = dB. CM03, Conditions = . CM04, Sym. = V HYST. CM04, Characteristic = Comparator Hysteresis. CM04,",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nMin. = 10. CM04, Typ. \u2020 = 25. CM04, Max. = 40. CM04, Units = mV. CM04, Conditions = \n...........continued\nCM05, Sym. = T RESP (1). CM05, Characteristic = Response Time, Rising Edge. CM05, Min. = -. CM05, Typ. \u2020 = 300. CM05, Max. = 600. CM05, Units = ns. CM05, Conditions = . , Sym. = . , Characteristic = Response Time, Falling Edge. , Min. = -. , Typ. \u2020 = 220. , Max. = 500. , Units = ns. , Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Response time measured with one comparator input at VDD/2, while the other input transitions from VSS to VDD.",
    "48.4.10  8-Bit DAC Specifications\nTable 48-15.",
    "Standard Operating Conditions (unless otherwise stated)VDD = 3.0V, TA = 25\u00b0C\nDSB01, Sym. = V LSB. DSB01, Characteristic = Step Size. DSB01, Min. = -. DSB01, Typ. \u2020 = (V DACREF + -V DACREF - )/256. DSB01, Max. = -. DSB01, Units = V. DSB01, Conditions = . DSB02, Sym. = V ACC. DSB02, Characteristic = Absolute Accuracy. DSB02, Min. = -2.5. DSB02, Typ. \u2020 = 1.9. DSB02, Max. = 7.0. DSB02, Units = LSb. DSB02, Conditions = . DSB03*, Sym. = R UNIT. DSB03*, Characteristic = Unit Resistor Value. DSB03*, Min. = -. DSB03*, Typ. \u2020 = 20. DSB03*, Max. = -. DSB03*, Units = k\u03a9.",
    "Standard Operating Conditions (unless otherwise stated)VDD = 3.0V, TA = 25\u00b0C\nDSB03*, Conditions = . DSB04*, Sym. = T ST. DSB04*, Characteristic = Settling Time (1). DSB04*, Min. = -. DSB04*, Typ. \u2020 = 10. DSB04*, Max. = -. DSB04*, Units = \u03bcs. DSB04*, Conditions = . DSB05*, Sym. = V DBO. DSB05*, Characteristic = DAC Buffer Offset (2). DSB05*, Min. = -. DSB05*, Typ. \u2020 = 20. DSB05*, Max. = 45. DSB05*, Units = mV. DSB05*, Conditions = . DSB06*, Sym. = INL. DSB06*, Characteristic = Intergral Nonlinerarity. DSB06*, Min. = -1.7. DSB06*, Typ. \u2020 = 1.",
    "Standard Operating Conditions (unless otherwise stated)VDD = 3.0V, TA = 25\u00b0C\nDSB06*, Max. = 1.9. DSB06*, Units = LSb. DSB06*, Conditions = 0x09 \u2264 DAC.DATA < 0x246. DSB07*, Sym. = DNL. DSB07*, Characteristic = Differential Nonlinearity. DSB07*, Min. = -0.5. DSB07*, Typ. \u2020 = 0.4. DSB07*, Max. = 1.2. DSB07*, Units = LSb. DSB07*, Conditions = 0x09 \u2264 DAC.DATA < 0x246. DSB08*, Sym. = E OFF. DSB08*, Characteristic = Offset Error. DSB08*, Min. = -0.8. DSB08*, Typ. \u2020 = 1.4. DSB08*, Max. = 2.5. DSB08*, Units = LSb. DSB08*, Conditions =",
    "Standard Operating Conditions (unless otherwise stated)VDD = 3.0V, TA = 25\u00b0C\n0x09 \u2264 DAC.DATA < 0x246. DSB09*, Sym. = E GN. DSB09*, Characteristic = Gain Error. DSB09*, Min. = -1.7. DSB09*, Typ. \u2020 = -1.2. DSB09*, Max. = 0.8. DSB09*, Units = LSb. DSB09*, Conditions = 0x09 \u2264 DAC.DATA < 0x246\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. Settling time measured while DACR[7:0] transitions from 'b00000000 to 'b11111111 .\n2. This parameter only applies to the buffered DAC1 module, and does not apply to the unbuffered DAC2.",
    "48.4.11  Operational Amplifier Specifications\n\nTable 48-16.",
    "48.4.11  Operational Amplifier Specifications\nOPA01*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Sym. = GBWP. OPA01*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Characteristic = Gain Bandwidth Product. OPA01*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Min. = -. OPA01*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Typ. \u2020 = -. OPA01*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Max. = 5.5. OPA01*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Units = MHz. OPA01*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Conditions = . OPA02, Standard Operating Conditions (unless otherwise",
    "48.4.11  Operational Amplifier Specifications\nstated) V DD = 3.0V, T A = 25\u00b0C.Sym. = T ON. OPA02, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Characteristic = Turn-On Time. OPA02, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Min. = -. OPA02, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Typ. \u2020 = 0.9. OPA02, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Max. = -. OPA02, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Units = \u03bcs. OPA02, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Conditions = . OPA03*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V,",
    "48.4.11  Operational Amplifier Specifications\nT A = 25\u00b0C.Sym. = P M. OPA03*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Characteristic = Phase Margin. OPA03*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Min. = -. OPA03*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Typ. \u2020 = 80. OPA03*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Max. = -. OPA03*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Units = Degrees. OPA03*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Conditions = . OPA04*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A =",
    "48.4.11  Operational Amplifier Specifications\n25\u00b0C.Sym. = S R. OPA04*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Characteristic = Slew Rate. OPA04*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Min. = -. OPA04*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Typ. \u2020 = 8. OPA04*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Max. = -. OPA04*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Units = V/\u03bcs. OPA04*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Conditions = . OPA05, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A =",
    "48.4.11  Operational Amplifier Specifications\n25\u00b0C.Sym. = O FF. OPA05, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Characteristic = Offset. OPA05, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Min. = -4. OPA05, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Typ. \u2020 = -. OPA05, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Max. = +4. OPA05, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Units = mV. OPA05, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Conditions = . OPA06*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Sym. = .",
    "48.4.11  Operational Amplifier Specifications\nOPA06*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Characteristic = Input Offset Drift With Temperature. OPA06*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Min. = -120. OPA06*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Typ. \u2020 = \u00b130. OPA06*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Max. = +120. OPA06*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Units = \u00b5V/\u00baC. OPA06*, Standard Operating Conditions (unless otherwise stated) V DD = 3.0V, T A = 25\u00b0C.Conditions = \n...........continued",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nOPA07, Sym. = . OPA07, Characteristic = Input Offset Calibration Step Size. OPA07, Min. = -. OPA07, Typ. \u2020 = 0.5. OPA07, Max. = -. OPA07, Units = mV. OPA07, Conditions = . OPA06, Sym. = CMRR. OPA06, Characteristic = Common-Mode Rejection Ratio. OPA06, Min. = 45. OPA06, Typ. \u2020 = 60. OPA06, Max. = -. OPA06, Units = dB. OPA06, Conditions = 0.9V dd -0.1V dd. OPA11*, Sym. = PSRR. OPA11*, Characteristic = Power Supply Rejection Ratio. OPA11*, Min. = -. OPA11*, Typ. \u2020 = 67. OPA11*, Max. = -. OPA11*, Units = dB. OPA11*, Conditions = .",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nOPA12*, Sym. = A OL. OPA12*, Characteristic = Open-Loop Gain. OPA12*, Min. = -. OPA12*, Typ. \u2020 = 80. OPA12*, Max. = -. OPA12*, Units = dB. OPA12*, Conditions = Open-Loop Gain (Phase). OPA13*, Sym. = V ICM. OPA13*, Characteristic = Input Common-Mode Voltage. OPA13*, Min. = -0.3. OPA13*, Typ. \u2020 = -. OPA13*, Max. = V DD + 0.3. OPA13*, Units = V. OPA13*, Conditions = Charge Pump On; V DD>2.5V. OPA13*, Sym. = V ICM. OPA13*, Characteristic = Input Common-Mode Voltage. OPA13*, Min. = -0.3. OPA13*, Typ. \u2020 = -. OPA13*, Max. = V",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nDD - 0.7. OPA13*, Units = . OPA13*, Conditions = Charge Pump Off; V DD>2.5V. OPA14*, Sym. = E ni. OPA14*, Characteristic = Input Noise Voltage. OPA14*, Min. = -. OPA14*, Typ. \u2020 = 160. OPA14*, Max. = -. OPA14*, Units = \u03bcV PP. OPA14*, Conditions = . OPA15*, Sym. = e ni. OPA15*, Characteristic = Input Noise Voltage Density. OPA15*, Min. = -. OPA15*, Typ. \u2020 = 70. OPA15*, Max. = -. OPA15*, Units = nV/\u221a(Hz). OPA15*, Conditions = \u0192= 10 kHz. OPA16A*, Sym. = I SC. OPA16A*, Characteristic = Short-Circuit Current (Sourcing). OPA16A*, Min. = -.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nOPA16A*, Typ. \u2020 = -. OPA16A*, Max. = -. OPA16A*, Units = mA. OPA16A*, Conditions = . OPA16B*, Sym. = . OPA16B*, Characteristic = Short-Circuit Current (Sinking). OPA16B*, Min. = -. OPA16B*, Typ. \u2020 = -. OPA16B*, Max. = . OPA16B*, Units = mA. OPA16B*, Conditions = . OPA17, Sym. = V OS. OPA17, Characteristic = Voltage Output Swing. OPA17, Min. = (0.15)*V DD. OPA17, Typ. \u2020 = -. OPA17, Max. = (0.85)*V DD. OPA17, Units = V. OPA17, Conditions = . OPA19, Sym. = R LAD. OPA19, Characteristic = Internal Resistor Ladder Unit Resistance. OPA19, Min. =",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\n-. OPA19, Typ. \u2020 = 4. OPA19, Max. = -. OPA19, Units = k\u03a9. OPA19, Conditions = . OPA20, Sym. = . OPA20, Characteristic = System Gain Accuracy using Internal Resistor Ladder. OPA20, Min. = -10. OPA20, Typ. \u2020 = < \u00b13. OPA20, Max. = +10. OPA20, Units = %. OPA20, Conditions = Inverting/Non-inverting PGA\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "48.4.12  Fixed Voltage Reference (FVR) Specifications\nTable 48-17.",
    "Standard Operating Conditions (unless otherwise stated)\nFVR01, Sym. = V FVR 1. FVR01, Characteristic = 1x Gain (1.024V). FVR01, Min. = -4. FVR01, Typ. \u2020 = -. FVR01, Max. = +4. FVR01, Units = %. FVR01, Conditions = V DD \u2265 2.5V, -40\u00b0C to 85\u00b0C. FVR02, Sym. = V FVR 2. FVR02, Characteristic = 2x Gain (2.048V). FVR02, Min. = -4. FVR02, Typ. \u2020 = -. FVR02, Max. = +4. FVR02, Units = %. FVR02, Conditions = V DD \u2265 2.5V, -40\u00b0C to 85\u00b0C. FVR03, Sym. = V FVR 4. FVR03, Characteristic = 4x Gain (4.096V). FVR03, Min. = -5. FVR03, Typ. \u2020 = -.",
    "Standard Operating Conditions (unless otherwise stated)\nFVR03, Max. = +5. FVR03, Units = %. FVR03, Conditions = V DD \u2265 4.75V, -40\u00b0C to 85\u00b0C. FVR04, Sym. = T FVRST. FVR04, Characteristic = FVR Start-up Time. FVR04, Min. = -. FVR04, Typ. \u2020 = 25. FVR04, Max. = -. FVR04, Units = \u03bcs. FVR04, Conditions = ",
    "48.4.13  Zero-Cross Detect (ZCD) Specifications\nTable 48-18.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nZC01, Sym. = V PINZC. ZC01, Characteristic = Voltage on Zero-Cross Pin. ZC01, Min. = -. ZC01, Typ. \u2020 = 0.9. ZC01, Max. = -. ZC01, Units = V. ZC01, Conditions = . ZC02, Sym. = I ZCD_MAX. ZC02, Characteristic = Maximum source or sink current. ZC02, Min. = -. ZC02, Typ. \u2020 = -. ZC02, Max. = 600. ZC02, Units = \u03bcA. ZC02, Conditions = . ZC03, Sym. = T RESPH. ZC03, Characteristic = Response Time, Rising Edge. ZC03, Min. = -. ZC03, Typ. \u2020 = 1. ZC03, Max. = -. ZC03, Units = \u03bcs. ZC03, Conditions = . , Sym. = T",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nRESPL. , Characteristic = Response Time, Falling Edge. , Min. = -. , Typ. \u2020 = 1. , Max. = -. , Units = \u03bcs. , Conditions = \n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "48.4.14  Timer0 and Timer1 External Clock Requirements\nTable 48-19.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n40*, Sym. = T T 0H. 40*, Characteristic = T0CKI High Pulse Width. 40*, Characteristic = No Prescaler. 40*, Min. = 0.5T CY +20. 40*, Typ. \u2020 = -. 40*, Max. = -. 40*, Conditions = ns. 40*, Sym. = T T 0H. 40*, Characteristic = T0CKI High Pulse Width. 40*, Characteristic = With Prescaler. 40*, Min. = 10. 40*, Typ. \u2020 = -. 40*, Max. = -. 40*, Conditions = ns. 41*, Sym. = T T 0L. 41*, Characteristic = T0CKI Low Pulse Width. 41*, Characteristic = No Prescaler. 41*, Min. = 0.5T CY +20. 41*, Typ. \u2020 = -. 41*, Max. = -. 41*, Conditions = ns. 41*, Sym. = T T 0L. 41*, Characteristic = T0CKI Low",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nPulse Width. 41*, Characteristic = With Prescaler. 41*, Min. = 10. 41*, Typ. \u2020 = -. 41*, Max. = -. 41*, Conditions = ns. 42*, Sym. = T T 0P. 42*, Characteristic = T0CKI Period. 42*, Characteristic = T0CKI Period. 42*, Min. = Greater of: 20 or (T CY +40)/N. 42*, Typ. \u2020 = -. 42*, Max. = -. 42*, Conditions = N = Prescale value. 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Synchronous, No Prescaler. 45*, Min. = 0.5T CY +20. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Conditions = ns. 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic =",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nSynchronous, with Prescaler. 45*, Min. = 15. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Conditions = ns. 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Asynchronous. 45*, Min. = 30. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Conditions = ns. 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Synchronous, No Prescaler. 46*, Min. = 0.5T CY +20. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Conditions = ns. 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Synchronous, with Prescaler. 46*, Min. = 15.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Conditions = ns. 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Asynchronous. 46*, Min. = 30. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Conditions = ns. 47*, Sym. = T T 1P. 47*, Characteristic = T1CKI Input Period. 47*, Characteristic = Synchronous. 47*, Min. = Greater of: 30 or (T CY +40)/N. 47*, Typ. \u2020 = -. 47*, Max. = -. 47*, Conditions = N = Prescale value. 47*, Sym. = T T 1P. 47*, Characteristic = T1CKI Input Period. 47*, Characteristic = Asynchronous. 47*, Min. = 60. 47*, Typ. \u2020 = -. 47*, Max. =",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n-. 47*, Conditions = ns. 49*, Sym. = TCKEZ TMR 1. 49*, Characteristic = Delay from External Clock Edge to Timer Increment. 49*, Characteristic = Delay from External Clock Edge to Timer Increment. 49*, Min. = 2 T OSC. 49*, Typ. \u2020 = -. 49*, Max. = 7 T OSC. 49*, Conditions = Timers in Sync mode\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFigure 48-11. Timer0 and Timing1 External Clock Timings",
    "48.4.15  Capture/Compare/PWM Requirements (CCP)\nTable 48-20.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C \u2264 TA \u2264 +125\u00b0C\nCC01*, Sym. = T CC L. CC01*, Characteristic = CCPx Input Low Time. CC01*, Characteristic = No Prescaler. CC01*, Min. = 0.5T CY +20. CC01*, Typ. \u2020 = -. CC01*, Max. = -. CC01*, Units = ns. CC01*, Conditions = . , Sym. = . , Characteristic = . , Characteristic = With Prescaler. , Min. = 20. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = . CC02*, Sym. = T CC H. CC02*, Characteristic = CCPx Input High. CC02*, Characteristic = No Prescaler. CC02*, Min. = 0.5T CY +20. CC02*, Typ. \u2020 = -. CC02*, Max. = -. CC02*, Units = ns. CC02*, Conditions = . , Sym. = . , Characteristic",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C \u2264 TA \u2264 +125\u00b0C\n= Time. , Characteristic = With Prescaler. , Min. = 20. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = . CC03*, Sym. = T CC P. CC03*, Characteristic = CCPx Input Period. CC03*, Characteristic = . CC03*, Min. = (3T CY +40)/N. CC03*, Typ. \u2020 = -. CC03*, Max. = -. CC03*, Units = ns. CC03*, Conditions = N = Prescale value\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFigure 48-12. Capture/Compare/PWM Timings (CCP)\nNote: Refer to the Load Conditions figure for more details.",
    "48.4.16  SPI Mode Requirements\nTable 48-21. SPI Host Mode",
    "Standard Operating Conditions (unless otherwise stated)\n, Sym. = T SCK. , Characteristic = SCK Cycle Time (2x Prescaled). , Min. = 61. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = Transmit only mode. , Sym. = T SCK. , Characteristic = SCK Cycle Time (2x Prescaled). , Min. = -. , Typ. \u2020 = 16 (1). , Max. = -. , Units = MHz. , Conditions = Transmit only mode. , Sym. = T SCK. , Characteristic = SCK Cycle Time (2x Prescaled). , Min. = 95. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = Full Duplex mode. , Sym. = T SCK. , Characteristic = SCK Cycle Time (2x Prescaled). , Min. = -. , Typ. \u2020 = 10 (1). , Max. = -. , Units = MHz. , Conditions = Full Duplex mode. SP70*, Sym. = T SS L2 SC H, T",
    "Standard Operating Conditions (unless otherwise stated)\nL2 L. SP70*, Characteristic = SDO to SCK \u2193 or SCK \u2191 input. SP70*, Min. = T SCK. SP70*, Typ. \u2020 = -. SP70*, Max. = -. SP70*, Units = ns. SP70*, Conditions = FST = 0. SP70*, Sym. = SS SC. SP70*, Characteristic = SDO to SCK \u2193 or SCK \u2191 input. SP70*, Min. = 0. SP70*, Typ. \u2020 = -. SP70*, Max. = -. SP70*, Units = ns. SP70*, Conditions = FST = 1. SP71*, Sym. = T SC H. SP71*, Characteristic = SCK output high time. SP71*, Min. = 0.5 T SCK - 12. SP71*, Typ. \u2020 = -. SP71*, Max. = 0.5 T SCK + 12. SP71*, Units = ns. SP71*, Conditions = . SP72*, Sym. = T",
    "Standard Operating Conditions (unless otherwise stated)\nSC L. SP72*, Characteristic = SCK output low time. SP72*, Min. = 0.5 T SCK - 12. SP72*, Typ. \u2020 = -. SP72*, Max. = 0.5 T SCK + 12. SP72*, Units = ns. SP72*, Conditions = . SP73*, Sym. = T DI V2 SC H, T DI V2 SC L. SP73*, Characteristic = Setup time of SDI data input to SCK edge. SP73*, Min. = 85. SP73*, Typ. \u2020 = -. SP73*, Max. = -. SP73*, Units = ns. SP73*, Conditions = . SP74*, Sym. = T SC H2 DI L, T SC L2 DI L. SP74*, Characteristic = Hold time of SDI data input to SCK edge. SP74*, Min. = 0. SP74*, Typ. \u2020 = -. SP74*, Max. = -.",
    "Standard Operating Conditions (unless otherwise stated)\nSP74*, Units = ns. SP74*, Conditions = . SP74*, Sym. = T SC H2 DI L, T SC L2 DI L. SP74*, Characteristic = Hold time of SDI data input to final SCK. SP74*, Min. = 0.5 T SCK. SP74*, Typ. \u2020 = . SP74*, Max. = . SP74*, Units = ns. SP74*, Conditions = CKE = 0 , SMP = 1. SP75*, Sym. = T DO R. SP75*, Characteristic = SDO data output rise time. SP75*, Min. = -. SP75*, Typ. \u2020 = 10. SP75*, Max. = 25. SP75*, Units = ns. SP75*, Conditions = C L = 50 pF. SP76*, Sym. = T DO F. SP76*, Characteristic = SDO data output fall time. SP76*, Min. = -. SP76*, Typ. \u2020 = 10.",
    "Standard Operating Conditions (unless otherwise stated)\nSP76*, Max. = 25. SP76*, Units = ns. SP76*, Conditions = C L = 50 pF. SP78*, Sym. = T SC R. SP78*, Characteristic = SCK output rise time. SP78*, Min. = -. SP78*, Typ. \u2020 = 10. SP78*, Max. = 25. SP78*, Units = ns. SP78*, Conditions = C L = 50 pF",
    "Standard Operating Conditions (unless otherwise stated)\nSP79*, Sym. = T SC F. SP79*, Characteristic = SCK output fall time. SP79*, Min. = -. SP79*, Typ. \u2020 = 10. SP79*, Max. = 25. SP79*, Units = ns. SP79*, Conditions = C L = 50 pF. SP80*, Sym. = T SC H2 DO V, T SC L2 DO V. SP80*, Characteristic = SDO data output valid after SCK edge. SP80*, Min. = -15. SP80*, Typ. \u2020 = -. SP80*, Max. = 15. SP80*, Units = ns. SP80*, Conditions = C L = 50 pF. SP81*, Sym. = T DO V2 SC H, T DO V2 SC L. SP81*, Characteristic = SDO data output valid to first SCK edge. SP81*, Min. = T SCK - 10. SP81*, Typ. \u2020 = -. SP81*, Max. = -.",
    "Standard Operating Conditions (unless otherwise stated)\nSP81*, Units = ns. SP81*, Conditions = C L = 50 pF CKE = 1. SP82*, Sym. = T SS L2 DO V. SP82*, Characteristic = SDO data output valid after SS \u2193 edge. SP82*, Min. = -. SP82*, Typ. \u2020 = -. SP82*, Max. = 50. SP82*, Units = ns. SP82*, Conditions = C L = 20 pF. SP83*, Sym. = T SC H2 SS H, T SC L2 SS H. SP83*, Characteristic = SS \u2191 after last SCK edge. SP83*, Min. = T SCK - 10. SP83*, Typ. \u2020 = -. SP83*, Max. = -. SP83*, Units = ns. SP83*, Conditions = . SP84*, Sym. = T SS H2 SSL. SP84*, Characteristic = SS \u2191 to SS \u2193 edge. SP84*, Min. = T SCK -",
    "Standard Operating Conditions (unless otherwise stated)\n10. SP84*, Typ. \u2020 = -. SP84*, Max. = -. SP84*, Units = ns. SP84*, Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. SMP bit in the SPIxCON1 register must be set and the slew rate control must be disabled on the clock and data pins (clear the corresponding bits in SLRCONx register) for SPI to operate over 4 MHz.\nTable 48-22. SPI Client Mode",
    "Standard Operating Conditions (unless otherwise stated)\n, Sym. = T SCK. , Characteristic = SCK Total Cycle Time. , Min. = 47. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = Receive Only mode. , Sym. = T SCK. , Characteristic = SCK Total Cycle Time. , Min. = -. , Typ. \u2020 = 20 (1). , Max. = -. , Units = MHz. , Conditions = Receive Only mode. , Sym. = T SCK. , Characteristic = SCK Total Cycle Time. , Min. = 95. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = Full Duplex mode. , Sym. = T SCK. , Characteristic = SCK Total Cycle Time. , Min. = -. , Typ. \u2020 = 10 (1). , Max. = -. , Units = MHz. , Conditions = Full Duplex mode. SP70*, Sym. = T SS L2 SC H, T SS L2 SC L. SP70*, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 input.",
    "Standard Operating Conditions (unless otherwise stated)\nSP70*, Min. = 0. SP70*, Typ. \u2020 = -. SP70*, Max. = -. SP70*, Units = ns. SP70*, Conditions = CKE = 0. SP70*, Sym. = T SS L2 SC H, T SS L2 SC L. SP70*, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 input. SP70*, Min. = 25. SP70*, Typ. \u2020 = -. SP70*, Max. = -. SP70*, Units = ns. SP70*, Conditions = CKE = 1. SP71*, Sym. = T SC H. SP71*, Characteristic = SCK input high time. SP71*, Min. = 20. SP71*, Typ. \u2020 = -. SP71*, Max. = -. SP71*, Units = ns. SP71*, Conditions = . SP72*, Sym. = T SC L. SP72*, Characteristic = SCK input low time. SP72*, Min. = 20.",
    "Standard Operating Conditions (unless otherwise stated)\nSP72*, Typ. \u2020 = -. SP72*, Max. = -. SP72*, Units = ns. SP72*, Conditions = . SP73*, Sym. = T DI V2 SC H, T DI V2 SC L. SP73*, Characteristic = Setup time of SDI data input to SCK edge. SP73*, Min. = 10. SP73*, Typ. \u2020 = -. SP73*, Max. = -. SP73*, Units = ns. SP73*, Conditions = . SP74*, Sym. = T SC H2 DI L, T SC L2 DI L. SP74*, Characteristic = Hold time of SDI data input to SCK edge. SP74*, Min. = 0. SP74*, Typ. \u2020 = -. SP74*, Max. = -. SP74*, Units = ns. SP74*, Conditions = . SP75*, Sym. = T DO R. SP75*, Characteristic = SDO data output rise time.",
    "Standard Operating Conditions (unless otherwise stated)\nSP75*, Min. = -. SP75*, Typ. \u2020 = 10. SP75*, Max. = 25. SP75*, Units = ns. SP75*, Conditions = C L = 50 pF. SP76*, Sym. = T DO F. SP76*, Characteristic = SDO data output fall time. SP76*, Min. = -. SP76*, Typ. \u2020 = 10. SP76*, Max. = 25. SP76*, Units = ns. SP76*, Conditions = C L = 50 pF. SP77*, Sym. = T SS H2 DO Z. SP77*, Characteristic = SS \u2191 to SDO output high-impedance. SP77*, Min. = -. SP77*, Typ. \u2020 = -. SP77*, Max. = 85. SP77*, Units = ns. SP77*, Conditions = . SP80*, Sym. = T SC H2 DO V, T SC L2 DO V. SP80*, Characteristic = SDO data output valid",
    "Standard Operating Conditions (unless otherwise stated)\nafter SCK edge. SP80*, Min. = -. SP80*, Typ. \u2020 = -. SP80*, Max. = 85. SP80*, Units = ns. SP80*, Conditions = . SP82*, Sym. = T SS L2 DO V. SP82*, Characteristic = SDO data output valid after SS \u2193 edge. SP82*, Min. = -. SP82*, Typ. \u2020 = -. SP82*, Max. = 85. SP82*, Units = ns. SP82*, Conditions = . SP83*, Sym. = T SC H2 SS H, T SC L2 SS H. SP83*, Characteristic = SS \u2191 after SCK edge. SP83*, Min. = 20. SP83*, Typ. \u2020 = -. SP83*, Max. = -. SP83*, Units = ns. SP83*, Conditions = . SP84*, Sym. = T SS H2 SSL. SP84*, Characteristic = SS \u2191 to SS \u2193 edge.",
    "Standard Operating Conditions (unless otherwise stated)\nSP84*, Min. = 47. SP84*, Typ. \u2020 = -. SP84*, Max. = -. SP84*, Units = ns. SP84*, Conditions = \n...........continued\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. SMP bit in the SPIxCON1 register must be set and the slew rate control must be disabled on the clock and data pins (clear the corresponding bits in SLRCONx register) for SPI to operate over 4 MHz.\nFigure 48-13. SPI Host Mode Timing (CKE = 0 , SMP = 0 )\nNote: Refer to the Load Conditions figure for more details.\nFigure 48-14. SPI Host Mode Timing (CKE = 1 , SMP = 1 )\nNote: Refer to the Load Conditions figure for more details.\nSP74\nFigure 48-15. SPI Client Mode Timing (CKE = 0 )\nNote: Refer to the Load Conditions figure for more details.\nFigure 48-16. SPI Client Mode Timing (CKE = 1 )\nNote: Refer to the Load Conditions figure for more details.",
    "48.4.17  I C Bus Start/Stop Bits Requirements 2\n\nTable 48-23.",
    "48.4.17  I C Bus Start/Stop Bits Requirements 2\nSP90*,  = T SU:STA. SP90*, Sym. Characteristic = Start condition. SP90*, Sym. Characteristic = 100 kHz mode. SP90*, Min. = 4700. SP90*, Typ. \u2020 = -. SP90*, Max. Units = - -. SP90*,  = ns. SP90*,  = Only relevant for Repeated Start condition. SP90*,  = T SU:STA. SP90*, Sym. Characteristic = Setup time. SP90*, Sym. Characteristic = 400 kHz mode. SP90*, Min. = 600. SP90*, Typ. \u2020 = -. SP90*, Max. Units = . SP90*,  = ns. SP90*,  = Only relevant for Repeated Start condition. SP90*,  = T SU:STA. SP90*, Sym. Characteristic = Setup time. SP90*, Sym. Characteristic = 1 MHz mode. SP90*, Min. = 260. SP90*, Typ. \u2020 = -. SP90*, Max. Units = -. SP90*,",
    "48.4.17  I C Bus Start/Stop Bits Requirements 2\n= ns. SP90*,  = Only relevant for Repeated Start condition. SP91*,  = T HD:STA. SP91*, Sym. Characteristic = Start condition Hold time. SP91*, Sym. Characteristic = 100 kHz mode. SP91*, Min. = 4000. SP91*, Typ. \u2020 = -. SP91*, Max. Units = - -. SP91*,  = ns. SP91*,  = After this period, the first clock pulse is generated. SP91*,  = T HD:STA. SP91*, Sym. Characteristic = Start condition Hold time. SP91*, Sym. Characteristic = 400 kHz mode. SP91*, Min. = 600. SP91*, Typ. \u2020 = -. SP91*, Max. Units = . SP91*,  = ns. SP91*,  = After this period, the first clock pulse is generated. SP91*,",
    "48.4.17  I C Bus Start/Stop Bits Requirements 2\n= T HD:STA. SP91*, Sym. Characteristic = Start condition Hold time. SP91*, Sym. Characteristic = 1 MHz mode. SP91*, Min. = 260. SP91*, Typ. \u2020 = -. SP91*, Max. Units = -. SP91*,  = ns. SP91*,  = After this period, the first clock pulse is generated. SP92*,  = T SU:STO. SP92*, Sym. Characteristic = Stop condition. SP92*, Sym. Characteristic = 100 kHz mode. SP92*, Min. = 4000. SP92*, Typ. \u2020 = -. SP92*, Max. Units = -. SP92*,  = ns. SP92*,  = . SP92*,",
    "48.4.17  I C Bus Start/Stop Bits Requirements 2\n= T SU:STO. SP92*, Sym. Characteristic = Setup time. SP92*, Sym. Characteristic = 400 kHz mode. SP92*, Min. = 600. SP92*, Typ. \u2020 = -. SP92*, Max. Units = -. SP92*,  = ns. SP92*,  = . SP92*,  = T SU:STO. SP92*, Sym. Characteristic = Setup time. SP92*, Sym. Characteristic = 1 MHz mode. SP92*, Min. = 260. SP92*, Typ. \u2020 = -. SP92*, Max. Units = -. SP92*,  = ns. SP92*,  = . SP93*,",
    "48.4.17  I C Bus Start/Stop Bits Requirements 2\n= T HD:STO. SP93*, Sym. Characteristic = Stop condition. SP93*, Sym. Characteristic = 100 kHz mode. SP93*, Min. = 4700. SP93*, Typ. \u2020 = -. SP93*, Max. Units = - -. SP93*,  = ns. SP93*,  = . SP93*,  = T HD:STO. SP93*, Sym. Characteristic = Hold time. SP93*, Sym. Characteristic = 400 kHz mode. SP93*, Min. = 1300. SP93*, Typ. \u2020 = -. SP93*, Max. Units = . SP93*,  = ns. SP93*,  = . SP93*,",
    "48.4.17  I C Bus Start/Stop Bits Requirements 2\n= T HD:STO. SP93*, Sym. Characteristic = Hold time. SP93*, Sym. Characteristic = 1 MHz mode. SP93*, Min. = 500. SP93*, Typ. \u2020 = -. SP93*, Max. Units = -. SP93*,  = ns. SP93*,  = \nFigure 48-17. I 2 C Bus Start/Stop Bits Timing\nNote: Refer to the Load Conditions figure for more details.",
    "48.4.18  I C Bus Data Requirements 2\nTable 48-24.",
    "Standard Operating Conditions (unless otherwise stated)\nSP100*, Sym. = T HIGH. SP100*, Characteristic = Clock high time. SP100*, Characteristic = 100 kHz mode. SP100*, Min. = 4000. SP100*, Max. = -. SP100*, Units = ns. SP100*, Conditions = Device must operate at a minimum of 1.5 MHz. SP100*, Sym. = T HIGH. SP100*, Characteristic = Clock high time. SP100*, Characteristic = 400 kHz mode. SP100*, Min. = 600. SP100*, Max. = -. SP100*, Units = ns. SP100*, Conditions = Device must operate at a minimum of 10 MHz. SP100*, Sym. = T HIGH. SP100*, Characteristic = Clock high time. SP100*, Characteristic = 1 MHz mode. SP100*, Min. = 260. SP100*, Max. = -. SP100*, Units = ns. SP100*, Conditions = Device must operate at a minimum of 10 MHz. SP101*, Sym. = T LOW. SP101*, Characteristic = Clock low time.",
    "Standard Operating Conditions (unless otherwise stated)\nSP101*, Characteristic = 100 kHz mode. SP101*, Min. = 4700. SP101*, Max. = -. SP101*, Units = ns. SP101*, Conditions = Device must operate at a minimum of 1.5 MHz. SP101*, Sym. = T LOW. SP101*, Characteristic = Clock low time. SP101*, Characteristic = 400 kHz mode. SP101*, Min. = 1300. SP101*, Max. = -. SP101*, Units = ns. SP101*, Conditions = Device must operate at a minimum of 10 MHz. SP101*, Sym. = T LOW. SP101*, Characteristic = Clock low time. SP101*, Characteristic = 1 MHz mode. SP101*, Min. = 500. SP101*, Max. = -. SP101*, Units = ns. SP101*, Conditions = Device must operate at a minimum of 10 MHz. SP102*, Sym. = T R. SP102*, Characteristic = SDA and SCL rise time.",
    "Standard Operating Conditions (unless otherwise stated)\nSP102*, Characteristic = 100 kHz mode. SP102*, Min. = -. SP102*, Max. = 1000. SP102*, Units = ns. SP102*, Conditions = . SP102*, Sym. = T R. SP102*, Characteristic = SDA and SCL rise time. SP102*, Characteristic = 400 kHz mode. SP102*, Min. = 20. SP102*, Max. = 300. SP102*, Units = ns. SP102*, Conditions = C B is specified to be from 10-400 pF. SP102*, Sym. = T R. SP102*, Characteristic = SDA and SCL rise time. SP102*, Characteristic = 1 MHz mode. SP102*, Min. = -. SP102*, Max. = 120. SP102*, Units = . SP102*, Conditions = . SP103*, Sym. = T F. SP103*, Characteristic = SDA and SCL fall time. SP103*, Characteristic = 100 kHz mode.",
    "Standard Operating Conditions (unless otherwise stated)\nSP103*, Min. = -. SP103*, Max. = 250. SP103*, Units = ns. SP103*, Conditions = . SP103*, Sym. = T F. SP103*, Characteristic = SDA and SCL fall time. SP103*, Characteristic = 400 kHz mode. SP103*, Min. = 20 \u00d7 (V DD / 5.5V). SP103*, Max. = 250. SP103*, Units = ns. SP103*, Conditions = C B is specified to be from 10-400 pF. SP103*, Sym. = T F. SP103*, Characteristic = SDA and SCL fall time. SP103*, Characteristic = 1 MHz mode. SP103*, Min. = 20 \u00d7 (V DD / 5.5V). SP103*, Max. = 120. SP103*, Units = ns. SP103*, Conditions = . SP106*, Sym. = T HD:DAT. SP106*, Characteristic = Data input hold time.",
    "Standard Operating Conditions (unless otherwise stated)\nSP106*, Characteristic = 100 kHz mode. SP106*, Min. = 0. SP106*, Max. = -. SP106*, Units = ns. SP106*, Conditions = . SP106*, Sym. = T HD:DAT. SP106*, Characteristic = Data input hold time. SP106*, Characteristic = 400 kHz mode. SP106*, Min. = 0. SP106*, Max. = -. SP106*, Units = ns. SP106*, Conditions = . SP106*, Sym. = T HD:DAT. SP106*, Characteristic = Data input hold time. SP106*, Characteristic = 1 MHz mode. SP106*, Min. = 0. SP106*, Max. = -. SP106*, Units = ns. SP106*, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\nSP107*, Sym. = T SU:DAT. SP107*, Characteristic = Data input setup time. SP107*, Characteristic = 100 kHz mode. SP107*, Min. = 250. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = (Note 2). SP107*, Sym. = T SU:DAT. SP107*, Characteristic = Data input setup time. SP107*, Characteristic = 400 kHz mode. SP107*, Min. = 100. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = (Note 2). SP107*, Sym. = T SU:DAT. SP107*, Characteristic = Data input setup time. SP107*, Characteristic = 1 MHz mode. SP107*, Min. = 50. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = (Note 2). SP109*, Sym. = T AA.",
    "Standard Operating Conditions (unless otherwise stated)\nSP109*, Characteristic = Output valid from clock. SP109*, Characteristic = 100 kHz mode. SP109*, Min. = -. SP109*, Max. = 3450. SP109*, Units = ns. SP109*, Conditions = (Note 1). SP109*, Sym. = T AA. SP109*, Characteristic = Output valid from clock. SP109*, Characteristic = 400 kHz mode. SP109*, Min. = -. SP109*, Max. = 900. SP109*, Units = ns. SP109*, Conditions = (Note 1). SP109*, Sym. = T AA. SP109*, Characteristic = Output valid from clock. SP109*, Characteristic = 1 MHz mode. SP109*, Min. = . SP109*, Max. = 450. SP109*, Units = ns. SP109*, Conditions = (Note 1). SP110*, Sym. = T BUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 100",
    "Standard Operating Conditions (unless otherwise stated)\nkHz mode. SP110*, Min. = 4700. SP110*, Max. = -. SP110*, Units = ns. SP110*, Conditions = Time the bus must be free before a new transmission can start. SP110*, Sym. = T BUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 400 kHz mode. SP110*, Min. = 1300. SP110*, Max. = -. SP110*, Units = ns. SP110*, Conditions = Time the bus must be free before a new transmission can start. SP110*, Sym. = T BUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 1 MHz mode. SP110*, Min. = 500. SP110*, Max. = -. SP110*, Units = ns. SP110*, Conditions = Time the bus must be free before a new transmission can start. SP111, Sym. = C B. SP111, Characteristic = Bus capacitive loading. SP111,",
    "Standard Operating Conditions (unless otherwise stated)\nCharacteristic = 100 kHz mode. SP111, Min. = -. SP111, Max. = 400. SP111, Units = pF. SP111, Conditions = . SP111, Sym. = C B. SP111, Characteristic = Bus capacitive loading. SP111, Characteristic = 400 kHz mode. SP111, Min. = -. SP111, Max. = 400. SP111, Units = pF. SP111, Conditions = . SP111, Sym. = C B. SP111, Characteristic = Bus capacitive loading. SP111, Characteristic = 1 MHz mode. SP111, Min. = -. SP111, Max. = 26. SP111, Units = pF. SP111, Conditions = (Note 3)\n- * These parameters are characterized but not tested.",
    "Notes:\n1. As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of Start or Stop conditions.\n2. A Fast mode (400 kHz) I 2 C bus device can be used in a Standard mode (100 kHz) I 2 C bus system, but the requirement TSU:DAT \u2265 250 ns must then be met. This will automatically be the case if the device does not stretch the low period of the SCL signal. If such a device does stretch the low period of the SCL signal, it must output the next data bit to the SDA line TR max. + T SU:DAT = 1000 + 250 = 1250 ns (according to the Standard mode I 2 C bus specification), before the SCL line is released.\n3. Using internal I 2 C pull-ups. For greater bus capacitance use external pull-ups.",
    "Figure 48-18. I 2 C Bus Data Timing\nNote: Refer to the Load Conditions figure for more details.",
    "48.4.19  Configurable Logic Cell (CLC) Characteristics\nTable 48-25.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nCLC01*, Sym. = T CLCIN. CLC01*, Characteristic = CLC input time. CLC01*, Characteristic = CLC input time. CLC01*, Min. = -. CLC01*, Typ. \u2020 = 7. CLC01*, Max. = IO5. CLC01*, Units = ns. CLC01*, Conditions = (Note 1). CLC02*, Sym. = T CLC. CLC02*, Characteristic = CLC module input to output propagation time. CLC02*, Characteristic = CLC module input to output propagation time. CLC02*, Min. = -. CLC02*, Typ. \u2020 = 24. CLC02*, Max. = -. CLC02*, Units = ns. CLC02*, Conditions = V DD = 1.8V. , Sym. = . , Characteristic = . , Characteristic = . , Min. = -. , Typ. \u2020 = 12. , Max. = -.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n, Units = ns. , Conditions = V DD > 3.6V. CLC03*, Sym. = T CLCOUT. CLC03*, Characteristic = CLC output time. CLC03*, Characteristic = Rise Time. CLC03*, Min. = -. CLC03*, Typ. \u2020 = IO6. CLC03*, Max. = -. CLC03*, Units = -. CLC03*, Conditions = (Note 1). , Sym. = . , Characteristic = . , Characteristic = Fall Time. , Min. = -. , Typ. \u2020 = IO8. , Max. = -. , Units = -. , Conditions = (Note 1). CLC04*, Sym. = F CLCMAX. CLC04*, Characteristic = CLC maximum switching frequency. CLC04*, Characteristic = CLC maximum switching frequency. CLC04*, Min. = -. CLC04*, Typ. \u2020 = -.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nCLC04*, Max. = OS20. CLC04*, Units = -. CLC04*, Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. See the 'I/O and CLKOUT Timing Specifications' section for OS7, OS8 and OS9 rise and fall times.\nFigure 48-19. CLC Propagation Timing",
    "Standard Operating Conditions (unless otherwise stated)\nTS01*, Sym. = T ACQMIN. TS01*, Characteristic = Minimum ADC Acquisition Time Delay. TS01*, Characteristic = Minimum ADC Acquisition Time Delay. TS01*, Min. = -. TS01*, Typ. \u2020 = 25. TS01*, Max. = -. TS01*, Units = \u00b5s. TS01*, Conditions = . TS02*, Sym. = M V. TS02*, Characteristic = Voltage Sensitivity. TS02*, Characteristic = High Range. TS02*, Min. = -. TS02*, Typ. \u2020 = -3.75. TS02*, Max. = -. TS02*, Units = mV/\u00b0C. TS02*, Conditions = TSRNG = 1. , Sym. = . , Characteristic = . , Characteristic = Low Range. , Min. = -. , Typ. \u2020 = -2.75. , Max. = -. , Units = mV/\u00b0C. , Conditions = TSRNG = 0",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "49. DC and AC Characteristics Graphs and Tables\nThe graphs and tables provided in this section are for design guidance and are not tested. In some graphs or tables, the data presented are outside specified operating range (i.e., outside specified VDD range). This is for information only and devices are ensured to operate properly only within the specified range. Unless otherwise noted, all graphs apply to both the L and LF devices.\nNote: The graphs and tables provided following this note are a statistical summary based on a limited number of samples and are provided for informational purposes only. The performance characteristics listed herein are not tested or guaranteed. In some graphs or tables, the data presented may be outside the specified operating range (e.g., outside specified power supply range) and therefore, outside the warranted range.\nNote: 'Typical' represents the mean of the distribution at 25\u00b0C. 'Maximum' (Max.) and 'Minimum' (Min.) represent (mean + 3\u03c3) or (mean - 3\u03c3), respectively, where \u03c3 is a standard deviation over each temperature range.",
    "49.15 Operational Amplifier Graphs\nFigure 49-103. PSRR at 3V V DD and V CM = V DD/2 over Frequency and Temperature\n0\n-10\n-20\n-30\n-40\n-50\n-60\n-70\n-80\nTemperature [\u00b0C]\n-40\n25\n85\n125\nPSRR [dB]\n100\n200\n300\n500\n1k\n2k\n3k\n5k\n10k\n20k\n30k\n50k\n100k\n200k\n400k\n1M\n2M\n3M\n5M\n10M\n20M 30M\nFrequency [Hz]\nFigure 49-104. PSRR at DC and VCM = V DD/2 over V DD and Temperature\nFigure 49-105. Open Loop Gain and Phase Bode Plot at 3V and 25\u00b0C\n0\n-10\n-20\n-30\n-40\n-50\n-60\n-70\n-80\nTemperature [\u00b0C]\n-40\n25\n85\n125\nPSRR [dB]\nOpen Loop Gain [dB]\n1.5\n2.0\n2.5\n3.0\n3.5\n4.0\n4.5\n5.0\n5.5\n6.0\nVDD [V]\nFigure 49-106. Open Loop Gain at 25\u00b0C over V DD and VCM\n120\n110\n100\n90\n80\n70\n60\n50\n40\n30\n20\n10\n0\n-0.5",
    "49.15 Operational Amplifier Graphs\n0.0\n0.5\n1.0\n1.5\n2.0\n2.5\n3.0\nInput common mode [V]\n3.5\n4.0\n4.5\n5.0\n5.5\n6.0\nVDD [V]\n1.8\n2.4\n3\n4\n5.5\nFigure 49-111. VOH at 5V over Temperature and Load Current\n0.00\nTemperature [\u00b0C]\n-40\n25\n85\n125\nVDD-VOH [V]\n-0.02\n-0.04\n-0.06\n-0.08\n-0.10\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0\n1.2\n1.4\n1.6\n1.8\n2.0\n2.2\n2.4\n2.6\n2.8\n3.0\n3.2\n3.4\n3.6\n3.8\n4.0\nOutput current [mA]\nFigure 49-112. VOL at 3V over Temperature and Load Current\nFigure 49-113. VOL at 5V over Temperature and Load Current\n0.10\nTemperature [\u00b0C]\n-40\n25\n85\n125\nVOL [V]\nVOL [V]\n0.08\n0.06\n0.04\n0.02\n0.00\n0.08",
    "49.15 Operational Amplifier Graphs\n0.06\n0.04\n0.02\n0.00\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0\n1.2\n1.4\n1.6\n1.8\n2.0\n2.2\n2.4\n2.6\n2.8\n3.0\n3.2\n3.4\n3.6\n3.8\n4.0\nOutput current [mA]\nFigure 49-114. Output Short Circuit Current Over V DD and Temperature\n0.10\nTemperature [\u00b0C]\n-40\n25\n85\n125\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0\n1.2\n1.4\n1.6\n1.8\n2.0\n2.2\nOutput current [mA]\n2.4\n2.6\n2.8\n3.0\n3.2\n3.4\n3.6\n3.8\n4.0",
    "50. Packaging Information\nPackage Marking Information\nLegend:\nXX...X\nCustomer-specific information or Microchip part number\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week '01')\nNNN\nAlphanumeric traceability code\n\u00ae  designator for Matte Tin (Sn) Pb-free JEDEC\nNote :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.\n3 e\nRev. 30-009014B\n09/21/2017\nExample",
    "14-Lead SOIC (3.90 mm)\n20-Lead SSOP (5.30 mm)\n20-Lead SOIC (7.50 mm)\nRev. 30-009020A\n09/21/2017",
    "Example\nRev. 30-009020B\n09/21/2017\nExample\n20-Lead VQFN (3x3x0.9 mm)\n20-Lead VQFN (3x3x0.9 mm)\nPIC18F15Q41 Example\nPIC18F14Q41 Example",
    "50.1 Package Details\nThe following sections give the technical details of the packages.",
    "14-Lead Plastic Small Outline (SL) - Narrow, 3.90 mm Body [SOIC]\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nMicrochip Technology Drawing No. C04-065-SL Rev D Sheet 1 of 2\n\u00a9 2017 Microchip Technology Inc.\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "14-Lead Plastic Small Outline (SL) - Narrow, 3.90 mm Body [SOIC]\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, MILLIMETERS.MIN = 14. Number of Pins, MILLIMETERS.NOM = 14. Number of Pins, MILLIMETERS.MAX = 14. Pitch, Units.Dimension Limits = e. Pitch, MILLIMETERS.MIN = 1.27 BSC. Pitch, MILLIMETERS.NOM = 1.27 BSC. Pitch, MILLIMETERS.MAX = 1.27 BSC. Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = -. Overall Height, MILLIMETERS.NOM = -. Overall Height, MILLIMETERS.MAX = 1.75. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, MILLIMETERS.MIN = 1.25. Molded Package Thickness, MILLIMETERS.NOM = -. Molded Package Thickness, MILLIMETERS.MAX = -. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.10. Standoff, MILLIMETERS.NOM = -. Standoff, MILLIMETERS.MAX = 0.25. Overall Width, Units.Dimension Limits =",
    "14-Lead Plastic Small Outline (SL) - Narrow, 3.90 mm Body [SOIC]\nE. Overall Width, MILLIMETERS.MIN = 6.00 BSC. Overall Width, MILLIMETERS.NOM = 6.00 BSC. Overall Width, MILLIMETERS.MAX = 6.00 BSC. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, MILLIMETERS.MIN = 3.90 BSC. Molded Package Width, MILLIMETERS.NOM = 3.90 BSC. Molded Package Width, MILLIMETERS.MAX = 3.90 BSC. Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = 8.65 BSC. Overall Length, MILLIMETERS.NOM = 8.65 BSC. Overall Length, MILLIMETERS.MAX = 8.65 BSC. Chamfer (Optional), Units.Dimension Limits = h. Chamfer (Optional), MILLIMETERS.MIN = 0.25. Chamfer (Optional), MILLIMETERS.NOM = -. Chamfer (Optional), MILLIMETERS.MAX = 0.50. Foot Length, Units.Dimension Limits = L. Foot Length, MILLIMETERS.MIN = 0.40. Foot Length,",
    "14-Lead Plastic Small Outline (SL) - Narrow, 3.90 mm Body [SOIC]\nMILLIMETERS.NOM = -. Foot Length, MILLIMETERS.MAX = 1.27. Footprint, Units.Dimension Limits = L1. Footprint, MILLIMETERS.MIN = 1.04 REF. Footprint, MILLIMETERS.NOM = 1.04 REF. Footprint, MILLIMETERS.MAX = 1.04 REF. Lead Angle, Units.Dimension Limits = . Lead Angle, MILLIMETERS.MIN = 0\u00b0. Lead Angle, MILLIMETERS.NOM = -. Lead Angle, MILLIMETERS.MAX = -. Foot Angle, Units.Dimension Limits = . Foot Angle, MILLIMETERS.MIN = 0\u00b0. Foot Angle, MILLIMETERS.NOM = -. Foot Angle, MILLIMETERS.MAX = 8\u00b0. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, MILLIMETERS.MIN = 0.10. Lead Thickness, MILLIMETERS.NOM = -. Lead Thickness, MILLIMETERS.MAX = 0.25. Lead Width, Units.Dimension Limits = b. Lead Width, MILLIMETERS.MIN = 0.31. Lead Width, MILLIMETERS.NOM = -. Lead Width, MILLIMETERS.MAX",
    "14-Lead Plastic Small Outline (SL) - Narrow, 3.90 mm Body [SOIC]\n= 0.51. Mold Draft Angle Top, Units.Dimension Limits = . Mold Draft Angle Top, MILLIMETERS.MIN = 5\u00b0. Mold Draft Angle Top, MILLIMETERS.NOM = -. Mold Draft Angle Top, MILLIMETERS.MAX = 15\u00b0. Mold Draft Angle Bottom, Units.Dimension Limits = . Mold Draft Angle Bottom, MILLIMETERS.MIN = 5\u00b0. Mold Draft Angle Bottom, MILLIMETERS.NOM = -. Mold Draft Angle Bottom, MILLIMETERS.MAX = 15\u00b0",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic\nor protrusion, which shall not exceed 0.25 mm per side. 3. Dimension D does not include mold flash, protrusions or gate burrs, which shall not exceed 0.15 mm per end.  Dimension E1 does not include interlead flash\n4. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\n5. Datums A & B to be determined at Datum H.\nMicrochip Technology Drawing No. C04-065-SL Rev D Sheet 2 of 2\n\u00a9 2017 Microchip Technology Inc.",
    "Note:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 1.27 BSC. Contact Pitch, MILLIMETERS.MAX = . Contact Pad Spacing, Dimension Limits = C. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.40. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X14), Dimension Limits = X. Contact Pad Width (X14), MILLIMETERS.MIN = . Contact Pad Width (X14), MILLIMETERS.NOM = . Contact Pad Width (X14), MILLIMETERS.MAX = 0.60. Contact Pad Length (X14), Dimension Limits = Y. Contact Pad Length (X14), MILLIMETERS.MIN = . Contact Pad Length (X14), MILLIMETERS.NOM = . Contact Pad Length (X14), MILLIMETERS.MAX = 1.55",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nMicrochip Technology Drawing No. C04-2065-SL Rev D\n\u00a9 2017 Microchip Technology Inc.",
    "14-Lead Plastic Thin Shrink Small Outline Package [ST] - 4.4 mm Body [TSSOP]\nNote: http://www.microchip.com/packaging For the most current package drawings, please see the Microchip Packaging Specification located at\nSheet 1 of 2 Microchip Technology Drawing C04-087-ST Rev F\n\u00a9 2023 Microchip Technology Inc.\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "Notes:\nNumber of Terminals, Units.Limits = N. Number of Terminals, MILLIMETERS.MIN = 14. Number of Terminals, MILLIMETERS.NOM = 14. Number of Terminals, MILLIMETERS.MAX = 14. Pitch, Units.Limits = e. Pitch, MILLIMETERS.MIN = 0.65 BSC. Pitch, MILLIMETERS.NOM = 0.65 BSC. Pitch, MILLIMETERS.MAX = 0.65 BSC. Overall Height, Units.Limits = A. Overall Height, MILLIMETERS.MIN = -. Overall Height, MILLIMETERS.NOM = -. Overall Height, MILLIMETERS.MAX = 1.20. Standoff, Units.Limits = A1. Standoff, MILLIMETERS.MIN = 0.05. Standoff, MILLIMETERS.NOM = -. Standoff, MILLIMETERS.MAX = 0.15. Molded Package Thickness, Units.Limits = A2. Molded Package Thickness, MILLIMETERS.MIN = 0.80. Molded Package Thickness, MILLIMETERS.NOM = 1.00. Molded Package Thickness, MILLIMETERS.MAX = 1.05. Overall Length, Units.Limits = D. Overall Length, MILLIMETERS.MIN = 4.90. Overall Length, MILLIMETERS.NOM",
    "Notes:\n= 5.00. Overall Length, MILLIMETERS.MAX = 5.10. Overall Width, Units.Limits = E. Overall Width, MILLIMETERS.MIN = 6.40 BSC. Overall Width, MILLIMETERS.NOM = 6.40 BSC. Overall Width, MILLIMETERS.MAX = 6.40 BSC. Molded Package Width, Units.Limits = E1. Molded Package Width, MILLIMETERS.MIN = 4.30. Molded Package Width, MILLIMETERS.NOM = 4.40. Molded Package Width, MILLIMETERS.MAX = 4.50. Terminal Width, Units.Limits = b. Terminal Width, MILLIMETERS.MIN = 0.19. Terminal Width, MILLIMETERS.NOM = -. Terminal Width, MILLIMETERS.MAX = 0.30. Terminal Thickness, Units.Limits = c. Terminal Thickness, MILLIMETERS.MIN = 0.09. Terminal Thickness, MILLIMETERS.NOM = -. Terminal Thickness, MILLIMETERS.MAX = 0.20. Terminal Length, Units.Limits = L. Terminal Length, MILLIMETERS.MIN = 0.45. Terminal Length, MILLIMETERS.NOM = 0.60. Terminal Length, MILLIMETERS.MAX = 0.75. Footprint,",
    "Notes:\nUnits.Limits = L1. Footprint, MILLIMETERS.MIN = 1.00 REF. Footprint, MILLIMETERS.NOM = 1.00 REF. Footprint, MILLIMETERS.MAX = 1.00 REF. Lead Bend Radius, Units.Limits = R1. Lead Bend Radius, MILLIMETERS.MIN = 0.09. Lead Bend Radius, MILLIMETERS.NOM = -. Lead Bend Radius, MILLIMETERS.MAX = -. Lead Bend Radius, Units.Limits = R2. Lead Bend Radius, MILLIMETERS.MIN = 0.09. Lead Bend Radius, MILLIMETERS.NOM = -. Lead Bend Radius, MILLIMETERS.MAX = -. Foot Angle, Units.Limits = \u03b8 1. Foot Angle, MILLIMETERS.MIN = 0\u00b0. Foot Angle, MILLIMETERS.NOM = -. Foot Angle, MILLIMETERS.MAX = 8\u00b0. Mold Draft Angle, Units.Limits = \u03b8 2. Mold Draft Angle, MILLIMETERS.MIN = -. Mold Draft Angle, MILLIMETERS.NOM = 12\u00b0 REF. Mold Draft Angle, MILLIMETERS.MAX = -. Mold Draft Angle, Units.Limits = \u03b8 3. Mold Draft Angle, MILLIMETERS.MIN = -. Mold Draft Angle,",
    "Notes:\nMILLIMETERS.NOM = 12\u00b0 REF. Mold Draft Angle, MILLIMETERS.MAX = -\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nSheet 2 of 2 Microchip Technology Drawing C04-087-ST Rev F\n\u00a9 2023 Microchip Technology Inc.",
    "Note:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.65 BSC. Contact Pitch, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.90. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X14), Units.Dimension Limits = X. Contact Pad Width (X14), MILLIMETERS.MIN = . Contact Pad Width (X14), MILLIMETERS.NOM = . Contact Pad Width (X14), MILLIMETERS.MAX = 0.45. Contact Pad Length (X14), Units.Dimension Limits = Y. Contact Pad Length (X14), MILLIMETERS.MIN = . Contact Pad Length (X14), MILLIMETERS.NOM = . Contact Pad Length (X14), MILLIMETERS.MAX = 1.45. Contact Pad to Contact Pad (X12), Units.Dimension Limits = G. Contact Pad to Contact Pad (X12), MILLIMETERS.MIN = 0.20. Contact Pad to Contact",
    "RECOMMENDED LAND PATTERN\nPad (X12), MILLIMETERS.NOM = . Contact Pad to Contact Pad (X12), MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nMicrochip Technology Drawing C04-2087-ST Rev F\n\u00a9 2023 Microchip Technology Inc.\nPackaging Diagrams and Parameters",
    "20-Lead Plastic Dual In-Line (P) - 300 mil Body [PDIP]\nNote:, 1 = For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "20-Lead Plastic Dual In-Line (P) - 300 mil Body [PDIP]\nNumber of Pins, Units.Limits = N. Number of Pins, INCHES.MIN = 20. Number of Pins, INCHES.NOM = 20. Number of Pins, INCHES.MAX = 20. Pitch, Units.Limits = e. Pitch, INCHES.MIN = .100 BSC. Pitch, INCHES.NOM = .100 BSC. Pitch, INCHES.MAX = .100 BSC. Top to Seating Plane, Units.Limits = A. Top to Seating Plane, INCHES.MIN = -. Top to Seating Plane, INCHES.NOM = -. Top to Seating Plane, INCHES.MAX = .210. Molded Package Thickness, Units.Limits = A2. Molded Package Thickness, INCHES.MIN = .115. Molded Package Thickness, INCHES.NOM = .130. Molded Package Thickness, INCHES.MAX = .195. Base to Seating Plane, Units.Limits = A1. Base to Seating Plane, INCHES.MIN = .015. Base to Seating Plane, INCHES.NOM = -. Base to Seating Plane, INCHES.MAX = -. Shoulder to Shoulder Width, Units.Limits = E. Shoulder to Shoulder Width, INCHES.MIN =",
    "20-Lead Plastic Dual In-Line (P) - 300 mil Body [PDIP]\n.300. Shoulder to Shoulder Width, INCHES.NOM = .310. Shoulder to Shoulder Width, INCHES.MAX = .325. Molded Package Width, Units.Limits = E1. Molded Package Width, INCHES.MIN = .240. Molded Package Width, INCHES.NOM = .250. Molded Package Width, INCHES.MAX = .280. Overall Length, Units.Limits = D. Overall Length, INCHES.MIN = .980. Overall Length, INCHES.NOM = 1.030. Overall Length, INCHES.MAX = 1.060. Tip to Seating Plane, Units.Limits = L. Tip to Seating Plane, INCHES.MIN = .115. Tip to Seating Plane, INCHES.NOM = .130. Tip to Seating Plane, INCHES.MAX = .150. Lead Thickness, Units.Limits = c. Lead Thickness, INCHES.MIN = .008. Lead Thickness, INCHES.NOM = .010. Lead Thickness, INCHES.MAX = .015. Upper Lead Width, Units.Limits = b1. Upper Lead Width, INCHES.MIN = .045. Upper Lead Width,",
    "20-Lead Plastic Dual In-Line (P) - 300 mil Body [PDIP]\nINCHES.NOM = .060. Upper Lead Width, INCHES.MAX = .070. Lower Lead Width, Units.Limits = b. Lower Lead Width, INCHES.MIN = .014. Lower Lead Width, INCHES.NOM = .018. Lower Lead Width, INCHES.MAX = .022. Overall Row Spacing \u00a7, Units.Limits = eB. Overall Row Spacing \u00a7, INCHES.MIN = -. Overall Row Spacing \u00a7, INCHES.NOM = -. Overall Row Spacing \u00a7, INCHES.MAX = .430",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic.\n3. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010\" per side.\n4. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nDS00049AR-page 52\nMicrochip Technology Drawing C04-019B\n\u00a9\n2007 Microchip Technology Inc.",
    "20-Lead Plastic Small Outline (SO) Wide, 7.50 mm Body [SOIC]\nNote: For the most current package drawings; please see the Microchip Packaging Specification located at http:llwww.microchip comlpackaging\nMicrochip Technology Drawing C04-094-S0 Rev G Sheet of 2\nNote: For the most current package drawings; please see the Microchip Packaging Specification located at",
    "Notes:\nNumber of Terminals, Units.Dimension Limits MIN = N. Number of Terminals, MILLIMETERS.Dimension Limits MIN = 20. Number of Terminals, MILLIMETERS.NOM = 20. Number of Terminals, MILLIMETERS.MAX = 20. Pitch, Units.Dimension Limits MIN = . Pitch, MILLIMETERS.Dimension Limits MIN = 1.27 BSC. Pitch, MILLIMETERS.NOM = 1.27 BSC. Pitch, MILLIMETERS.MAX = 1.27 BSC. Overall Height, Units.Dimension Limits MIN = . Overall Height, MILLIMETERS.Dimension Limits MIN = . Overall Height, MILLIMETERS.NOM = . Overall Height, MILLIMETERS.MAX = 2.65. Standoff, Units.Dimension Limits MIN = A1. Standoff, MILLIMETERS.Dimension Limits MIN = 0.10. Standoff, MILLIMETERS.NOM = . Standoff, MILLIMETERS.MAX = 0.30. Molded Package Thickness, Units.Dimension Limits MIN = A2. Molded Package Thickness, MILLIMETERS.Dimension Limits MIN = 2.05. Molded Package Thickness, MILLIMETERS.NOM = . Molded Package Thickness, MILLIMETERS.MAX = . Overall Length, Units.Dimension Limits MIN = . Overall Length, MILLIMETERS.Dimension Limits MIN =",
    "Notes:\n12.78 BSC. Overall Length, MILLIMETERS.NOM = 12.78 BSC. Overall Length, MILLIMETERS.MAX = 12.78 BSC. Overall Width, Units.Dimension Limits MIN = . Overall Width, MILLIMETERS.Dimension Limits MIN = 10.33 BSC. Overall Width, MILLIMETERS.NOM = 10.33 BSC. Overall Width, MILLIMETERS.MAX = 10.33 BSC. Molded Package Width, Units.Dimension Limits MIN = . Molded Package Width, MILLIMETERS.Dimension Limits MIN = 7.49 BSC. Molded Package Width, MILLIMETERS.NOM = 7.49 BSC. Molded Package Width, MILLIMETERS.MAX = 7.49 BSC. Terminal Width, Units.Dimension Limits MIN = . Terminal Width, MILLIMETERS.Dimension Limits MIN = 0.31. Terminal Width, MILLIMETERS.NOM = . Terminal Width, MILLIMETERS.MAX = 0.51. Terminal Thickness, Units.Dimension Limits MIN = . Terminal Thickness, MILLIMETERS.Dimension Limits MIN = 0.25. Terminal Thickness, MILLIMETERS.NOM = . Terminal Thickness, MILLIMETERS.MAX = 0.75. Corner Chamfer, Units.Dimension Limits MIN = h. Corner Chamfer, MILLIMETERS.Dimension",
    "Notes:\nLimits MIN = 0.25. Corner Chamfer, MILLIMETERS.NOM = . Corner Chamfer, MILLIMETERS.MAX = 0.75. Terminal Length, Units.Dimension Limits MIN = . Terminal Length, MILLIMETERS.Dimension Limits MIN = 0.40. Terminal Length, MILLIMETERS.NOM = 0.65. Terminal Length, MILLIMETERS.MAX = 1.27. Footprint, Units.Dimension Limits MIN = . Footprint, MILLIMETERS.Dimension Limits MIN = 1.40 REF. Footprint, MILLIMETERS.NOM = 1.40 REF. Footprint, MILLIMETERS.MAX = 1.40 REF. Lead Bend Radius, Units.Dimension Limits MIN = 4. Lead Bend Radius, MILLIMETERS.Dimension Limits MIN = 0.07. Lead Bend Radius, MILLIMETERS.NOM = . Lead Bend Radius, MILLIMETERS.MAX = . Lead Bend Radius, Units.Dimension Limits MIN = R2. Lead Bend Radius, MILLIMETERS.Dimension Limits MIN = 0.07. Lead Bend Radius, MILLIMETERS.NOM = . Lead Bend Radius, MILLIMETERS.MAX = . Foot Angle, Units.Dimension Limits MIN = . Foot Angle, MILLIMETERS.Dimension Limits MIN = . Foot Angle,",
    "Notes:\nMILLIMETERS.NOM = . Foot Angle, MILLIMETERS.MAX = . Lead Angle, Units.Dimension Limits MIN = . Lead Angle, MILLIMETERS.Dimension Limits MIN = . Lead Angle, MILLIMETERS.NOM = . Lead Angle, MILLIMETERS.MAX = . Mold Draft Angle, Units.Dimension Limits MIN = . Mold Draft Angle, MILLIMETERS.Dimension Limits MIN = . Mold Draft Angle, MILLIMETERS.NOM = . Mold Draft Angle, MILLIMETERS.MAX = . Mold Draft Angle, Units.Dimension Limits MIN = 83. Mold Draft Angle, MILLIMETERS.Dimension Limits MIN = . Mold Draft Angle, MILLIMETERS.NOM = . Mold Draft Angle, MILLIMETERS.MAX = 15'\nPin 1 visual index feature vary, but must be located within the hatched area_ may\n2 Dimensioning and tolerancing per ASME Y14.5M\nREF Reference Dimension; usually without tolerance, for information purposes only.\n3 Dimension D does not include mold flash; protrusions or burrs, which shall not exceed 0.15 mm per end_ Dimension E1 does not include interlead flash or protrusion, which shall not exceed 0.25 mm per side gate\n4. $ Significant Characteristic",
    "Notes:\nMicrochip Technology Drawing C04-094-S0 Rev G Sheet 2 of 2",
    "20-Lead Plastic Small Outline (SO) Wide, 7.50 mm Body [SOIC]\nFor the most current package drawings; please see the Microchip Packaging Specification located at\nRECOMMENDED LAND PATTERN",
    "Notes:\nContact Pitch, Units.Dimension Limits = . Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 1.27 BSC. Contact Pitch, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = . Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 9.40. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X2O), Units.Dimension Limits = X. Contact Pad Width (X2O), MILLIMETERS.MIN = . Contact Pad Width (X2O), MILLIMETERS.NOM = . Contact Pad Width (X2O), MILLIMETERS.MAX = 0.60. Contact Pad Length (X2O), Units.Dimension Limits = Y. Contact Pad Length (X2O), MILLIMETERS.MIN = . Contact Pad Length (X2O), MILLIMETERS.NOM = . Contact Pad Length (X2O), MILLIMETERS.MAX = 1.95. Contact Pad to Contact Pad (X18), Units.Dimension Limits = G1. Contact Pad to Contact Pad (X18), MILLIMETERS.MIN =",
    "Notes:\n0.67. Contact Pad to Contact Pad (X18), MILLIMETERS.NOM = . Contact Pad to Contact Pad (X18), MILLIMETERS.MAX = . Contact Pad to Contact Pad, Units.Dimension Limits = G2. Contact Pad to Contact Pad, MILLIMETERS.MIN = 7.45. Contact Pad to Contact Pad, MILLIMETERS.NOM = . Contact Pad to Contact Pad, MILLIMETERS.MAX = \nDimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances_\n2 For best soldering results; thermal vias, if used, should be filled or tented to avoid solder loss during reflow process\nMicrochip Technology Drawing C04-2094-S0 Rev G",
    "20-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\nFor the most current package drawings, please see the Microchip Packaging Specification located at Note:\nhttp://www.microchip.com/packaging\nMicrochip Technology Drawing  C04-072 Rev C Sheet 1 of 2\n\u00a9 2017 Microchip Technology Inc.\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "20-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\nMolded Package Thickness, Units.Limits.N.e.A = A2. Molded Package Thickness, MILLIMETERS.MIN.20.0.65 BSC.- = 1.65. Molded Package Thickness, MILLIMETERS.NOM.20.0.65 BSC.- = 1.75. Molded Package Thickness, MILLIMETERS.MAX.20.0.65 BSC.2.00 = 1.85. Standoff, Units.Limits.N.e.A = A1. Standoff, MILLIMETERS.MIN.20.0.65 BSC.- = 0.05. Standoff, MILLIMETERS.NOM.20.0.65 BSC.- = -. Standoff, MILLIMETERS.MAX.20.0.65 BSC.2.00 = -. Overall Width, Units.Limits.N.e.A = E. Overall Width, MILLIMETERS.MIN.20.0.65 BSC.- = 7.40. Overall Width, MILLIMETERS.NOM.20.0.65 BSC.- = 7.80. Overall Width, MILLIMETERS.MAX.20.0.65",
    "20-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\nBSC.2.00 = 8.20. Molded Package Width, Units.Limits.N.e.A = E1. Molded Package Width, MILLIMETERS.MIN.20.0.65 BSC.- = 5.00. Molded Package Width, MILLIMETERS.NOM.20.0.65 BSC.- = 5.30. Molded Package Width, MILLIMETERS.MAX.20.0.65 BSC.2.00 = 5.60. Overall Length, Units.Limits.N.e.A = D. Overall Length, MILLIMETERS.MIN.20.0.65 BSC.- = 6.90. Overall Length, MILLIMETERS.NOM.20.0.65 BSC.- = 7.20. Overall Length, MILLIMETERS.MAX.20.0.65 BSC.2.00 = 7.50. Foot Length, Units.Limits.N.e.A = L. Foot Length, MILLIMETERS.MIN.20.0.65 BSC.- = 0.55. Foot Length, MILLIMETERS.NOM.20.0.65 BSC.- = 0.75. Foot",
    "20-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\nLength, MILLIMETERS.MAX.20.0.65 BSC.2.00 = 0.95. Footprint, Units.Limits.N.e.A = L1. Footprint, MILLIMETERS.MIN.20.0.65 BSC.- = 1.25 REF. Footprint, MILLIMETERS.NOM.20.0.65 BSC.- = 1.25 REF. Footprint, MILLIMETERS.MAX.20.0.65 BSC.2.00 = 1.25 REF. Lead Thickness, Units.Limits.N.e.A = c. Lead Thickness, MILLIMETERS.MIN.20.0.65 BSC.- = 0.09. Lead Thickness, MILLIMETERS.NOM.20.0.65 BSC.- = -. Lead Thickness, MILLIMETERS.MAX.20.0.65 BSC.2.00 = 0.25. Foot Angle, Units.Limits.N.e.A = . Foot Angle, MILLIMETERS.MIN.20.0.65 BSC.- = 0\u00b0. Foot Angle, MILLIMETERS.NOM.20.0.65 BSC.- =",
    "20-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\n4\u00b0. Foot Angle, MILLIMETERS.MAX.20.0.65 BSC.2.00 = 8\u00b0. Lead Width, Units.Limits.N.e.A = b. Lead Width, MILLIMETERS.MIN.20.0.65 BSC.- = 0.22. Lead Width, MILLIMETERS.NOM.20.0.65 BSC.- = -. Lead Width, MILLIMETERS.MAX.20.0.65 BSC.2.00 = 0.38",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed 0.20mm per side.\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\n- REF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-072 Rev C Sheet 2 of 2\n\u00a9 2017 Microchip Technology Inc.",
    "Note:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.65 BSC. Contact Pitch, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 7.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X20), Units.Dimension Limits = X1. Contact Pad Width (X20), MILLIMETERS.MIN = . Contact Pad Width (X20), MILLIMETERS.NOM = . Contact Pad Width (X20), MILLIMETERS.MAX = 0.45. Contact Pad Length (X20), Units.Dimension Limits = Y1. Contact Pad Length (X20), MILLIMETERS.MIN = . Contact Pad Length (X20), MILLIMETERS.NOM = . Contact Pad Length (X20), MILLIMETERS.MAX = 1.85. Contact Pad to Center Pad (X18), Units.Dimension Limits = G1. Contact Pad to Center Pad (X18), MILLIMETERS.MIN = 0.20. Contact",
    "RECOMMENDED LAND PATTERN\nPad to Center Pad (X18), MILLIMETERS.NOM = . Contact Pad to Center Pad (X18), MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing C04-2072 Rev C\n\u00a9 2017 Microchip Technology Inc.",
    "20-Lead Very Thin Plastic Quad Flat, No Lead Package (REB) - 3x3 mm Body [VQFN] With 1.7 mm Exposed Pad; Atmel Legacy Global Package Code ZCL\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nMicrochip Technology Drawing  C04-21380 Rev A Sheet 1 of 2\n\u00a9 2018 Microchip Technology Inc.\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "Notes:\nNumber of Terminals, Units.Limits = N. Number of Terminals, MILLIMETERS.MIN = 20. Number of Terminals, MILLIMETERS.NOM = 20. Number of Terminals, MILLIMETERS.MAX = 20. Pitch, Units.Limits = e. Pitch, MILLIMETERS.MIN = 0.40 BSC. Pitch, MILLIMETERS.NOM = 0.40 BSC. Pitch, MILLIMETERS.MAX = 0.40 BSC. Overall Height, Units.Limits = A. Overall Height, MILLIMETERS.MIN = 0.80. Overall Height, MILLIMETERS.NOM = 0.85. Overall Height, MILLIMETERS.MAX = 0.90. Standoff, Units.Limits = A1. Standoff, MILLIMETERS.MIN = 0.00. Standoff, MILLIMETERS.NOM = 0.035. Standoff, MILLIMETERS.MAX = 0.05. Terminal Thickness, Units.Limits = A3. Terminal Thickness, MILLIMETERS.MIN = 0.203 REF. Terminal Thickness, MILLIMETERS.NOM = 0.203 REF. Terminal Thickness, MILLIMETERS.MAX = 0.203 REF. Overall Length, Units.Limits = D. Overall Length, MILLIMETERS.MIN = 3.00 BSC.",
    "Notes:\nOverall Length, MILLIMETERS.NOM = 3.00 BSC. Overall Length, MILLIMETERS.MAX = 3.00 BSC. Exposed Pad Length, Units.Limits = D2. Exposed Pad Length, MILLIMETERS.MIN = 1.60. Exposed Pad Length, MILLIMETERS.NOM = 1.70. Exposed Pad Length, MILLIMETERS.MAX = 1.80. Overall Width, Units.Limits = E. Overall Width, MILLIMETERS.MIN = 3.00 BSC. Overall Width, MILLIMETERS.NOM = 3.00 BSC. Overall Width, MILLIMETERS.MAX = 3.00 BSC. Exposed Pad Width, Units.Limits = E2. Exposed Pad Width, MILLIMETERS.MIN = 1.60. Exposed Pad Width, MILLIMETERS.NOM = 1.70. Exposed Pad Width, MILLIMETERS.MAX = 1.80. Terminal Width, Units.Limits = b. Terminal Width, MILLIMETERS.MIN = 0.15. Terminal Width, MILLIMETERS.NOM = 0.20. Terminal Width, MILLIMETERS.MAX = 0.25. Terminal Length, Units.Limits = L. Terminal Length, MILLIMETERS.MIN = 0.35. Terminal Length, MILLIMETERS.NOM =",
    "Notes:\n0.40. Terminal Length, MILLIMETERS.MAX = 0.45. Terminal-to-Exposed-Pad, Units.Limits = K. Terminal-to-Exposed-Pad, MILLIMETERS.MIN = 0.20. Terminal-to-Exposed-Pad, MILLIMETERS.NOM = -. Terminal-to-Exposed-Pad, MILLIMETERS.MAX = -. Pin 1 Index Chamfer, Units.Limits = CH. Pin 1 Index Chamfer, MILLIMETERS.MIN = 0.35 REF. Pin 1 Index Chamfer, MILLIMETERS.NOM = 0.35 REF. Pin 1 Index Chamfer, MILLIMETERS.MAX = 0.35 REF\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Package is saw singulated\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-21380 Rev A Sheet 2 of 2\n\u00a9 2018 Microchip Technology Inc.",
    "20-Lead Very Thin Plastic Quad Flat, No Lead Package (REB) - 3x3 mm Body [VQFN] With 1.7 mm Exposed Pad; Atmel Legacy Global Package Code ZCL\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.40 BSC. Contact Pitch, MILLIMETERS.MAX = . Optional Center Pad Width, Units.Dimension Limits = X2. Optional Center Pad Width, MILLIMETERS.MIN = . Optional Center Pad Width, MILLIMETERS.NOM = . Optional Center Pad Width, MILLIMETERS.MAX = 1.80. Optional Center Pad Length, Units.Dimension Limits = Y2. Optional Center Pad Length, MILLIMETERS.MIN = . Optional Center Pad Length, MILLIMETERS.NOM = . Optional Center Pad Length, MILLIMETERS.MAX = 1.80. Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 3.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 3.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X20), Units.Dimension Limits =",
    "RECOMMENDED LAND PATTERN\nX1. Contact Pad Width (X20), MILLIMETERS.MIN = . Contact Pad Width (X20), MILLIMETERS.NOM = . Contact Pad Width (X20), MILLIMETERS.MAX = 0.20. Contact Pad Length (X20), Units.Dimension Limits = Y1. Contact Pad Length (X20), MILLIMETERS.MIN = . Contact Pad Length (X20), MILLIMETERS.NOM = . Contact Pad Length (X20), MILLIMETERS.MAX = 0.80. Contact Pad to Center Pad (X20), Units.Dimension Limits = G1. Contact Pad to Center Pad (X20), MILLIMETERS.MIN = 0.20. Contact Pad to Center Pad (X20), MILLIMETERS.NOM = . Contact Pad to Center Pad (X20), MILLIMETERS.MAX = . Contact Pad to Contact Pad (X16), Units.Dimension Limits = G2. Contact Pad to Contact Pad (X16), MILLIMETERS.MIN = 0.20. Contact Pad to Contact Pad (X16), MILLIMETERS.NOM = . Contact Pad to Contact Pad (X16), MILLIMETERS.MAX = . Thermal Via",
    "RECOMMENDED LAND PATTERN\nDiameter, Units.Dimension Limits = V. Thermal Via Diameter, MILLIMETERS.MIN = . Thermal Via Diameter, MILLIMETERS.NOM = 0.30. Thermal Via Diameter, MILLIMETERS.MAX = . Thermal Via Pitch, Units.Dimension Limits = EV. Thermal Via Pitch, MILLIMETERS.MIN = . Thermal Via Pitch, MILLIMETERS.NOM = 1.00. Thermal Via Pitch, MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing  C04-23380 Rev A\n\u00a9 2018 Microchip Technology Inc.",
    "20-Lead Very Thin Plastic Quad Flat, No Lead Package (2LX) - 3x3 mm Body [VQFN] With 1.7 mm Exposed Pad and Stepped Wettable Flanks\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:\nMicrochip Technology Drawing  C04-476-2LX Rev C Sheet 1 of 2\n\u00a9 2018 Microchip Technology Inc.\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "DETAIL 1 ALTERNATE TERMINAL CONFIGURATIONS\nExposed Pad Length, Units.Limits.N.e.A.A1.A3.D = D2. Exposed Pad Length, MILLIMETERS.MIN.20.0.40 BSC.0.80.0.00.0.203 REF.3.00 BSC = 1.60. Exposed Pad Length, MILLIMETERS.NOM.20.0.40 BSC.0.90.0.02.0.203 REF.3.00 BSC = 1.70. Exposed Pad Length, MILLIMETERS.MAX.20.0.40 BSC.1.00.0.05.0.203 REF.3.00 BSC = 1.80. Overall Width, Units.Limits.N.e.A.A1.A3.D = E. Overall Width, MILLIMETERS.MIN.20.0.40 BSC.0.80.0.00.0.203 REF.3.00 BSC = 3.00 BSC. Overall Width, MILLIMETERS.NOM.20.0.40 BSC.0.90.0.02.0.203 REF.3.00 BSC = 3.00 BSC. Overall Width, MILLIMETERS.MAX.20.0.40",
    "DETAIL 1 ALTERNATE TERMINAL CONFIGURATIONS\nBSC.1.00.0.05.0.203 REF.3.00 BSC = 3.00 BSC. Exposed Pad Width, Units.Limits.N.e.A.A1.A3.D = E2. Exposed Pad Width, MILLIMETERS.MIN.20.0.40 BSC.0.80.0.00.0.203 REF.3.00 BSC = 1.60. Exposed Pad Width, MILLIMETERS.NOM.20.0.40 BSC.0.90.0.02.0.203 REF.3.00 BSC = 1.70. Exposed Pad Width, MILLIMETERS.MAX.20.0.40 BSC.1.00.0.05.0.203 REF.3.00 BSC = 1.80. Terminal Width, Units.Limits.N.e.A.A1.A3.D = b. Terminal Width, MILLIMETERS.MIN.20.0.40 BSC.0.80.0.00.0.203 REF.3.00 BSC = 0.15. Terminal Width, MILLIMETERS.NOM.20.0.40 BSC.0.90.0.02.0.203",
    "DETAIL 1 ALTERNATE TERMINAL CONFIGURATIONS\nREF.3.00 BSC = 0.20. Terminal Width, MILLIMETERS.MAX.20.0.40 BSC.1.00.0.05.0.203 REF.3.00 BSC = 0.25. Terminal Length, Units.Limits.N.e.A.A1.A3.D = L. Terminal Length, MILLIMETERS.MIN.20.0.40 BSC.0.80.0.00.0.203 REF.3.00 BSC = 0.35. Terminal Length, MILLIMETERS.NOM.20.0.40 BSC.0.90.0.02.0.203 REF.3.00 BSC = 0.40. Terminal Length, MILLIMETERS.MAX.20.0.40 BSC.1.00.0.05.0.203 REF.3.00 BSC = 0.45. Terminal-to-Exposed-Pad, Units.Limits.N.e.A.A1.A3.D = K. Terminal-to-Exposed-Pad, MILLIMETERS.MIN.20.0.40 BSC.0.80.0.00.0.203 REF.3.00 BSC = 0.20.",
    "DETAIL 1 ALTERNATE TERMINAL CONFIGURATIONS\nTerminal-to-Exposed-Pad, MILLIMETERS.NOM.20.0.40 BSC.0.90.0.02.0.203 REF.3.00 BSC = -. Terminal-to-Exposed-Pad, MILLIMETERS.MAX.20.0.40 BSC.1.00.0.05.0.203 REF.3.00 BSC = -. Wettable Flank Step Length, Units.Limits.N.e.A.A1.A3.D = D3. Wettable Flank Step Length, MILLIMETERS.MIN.20.0.40 BSC.0.80.0.00.0.203 REF.3.00 BSC = -. Wettable Flank Step Length, MILLIMETERS.NOM.20.0.40 BSC.0.90.0.02.0.203 REF.3.00 BSC = -. Wettable Flank Step Length, MILLIMETERS.MAX.20.0.40 BSC.1.00.0.05.0.203 REF.3.00 BSC = 0.085. Wettable Flank Step Height, Units.Limits.N.e.A.A1.A3.D = A4.",
    "DETAIL 1 ALTERNATE TERMINAL CONFIGURATIONS\nWettable Flank Step Height, MILLIMETERS.MIN.20.0.40 BSC.0.80.0.00.0.203 REF.3.00 BSC = 0.10. Wettable Flank Step Height, MILLIMETERS.NOM.20.0.40 BSC.0.90.0.02.0.203 REF.3.00 BSC = -. Wettable Flank Step Height, MILLIMETERS.MAX.20.0.40 BSC.1.00.0.05.0.203 REF.3.00 BSC = 0.19\nDimensions D3 and A4 above apply to all new products released after November 1, and all products shipped after January 1, 2019, and supersede dimensions D3 and A4 below.\nNo physical changes are being made to any package; this update is to align cosmetic and tolerance variations from existing suppliers.",
    "Notes:\nWettable Flank Step Length, 1 = D3. Wettable Flank Step Length, 2 = 0.035. Wettable Flank Step Length, 3 = 0.06. Wettable Flank Step Length, 4 = 0.085. Wettable Flank Step Height, 1 = A4. Wettable Flank Step Height, 2 = 0.10. Wettable Flank Step Height, 3 = -. Wettable Flank Step Height, 4 = 0.19\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Package is saw singulated\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-476-2LX Rev C Sheet 2 of 2\n\u00a9 2018 Microchip Technology Inc.",
    "20-Lead Very Thin Plastic Quad Flat, No Lead Package (2LX) - 3x3 mm Body [VQFN] With 1.7 mm Exposed Pad and Stepped Wettable Flanks\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.40 BSC. Contact Pitch, MILLIMETERS.MAX = . Optional Center Pad Width, Units.Dimension Limits = X2. Optional Center Pad Width, MILLIMETERS.MIN = . Optional Center Pad Width, MILLIMETERS.NOM = . Optional Center Pad Width, MILLIMETERS.MAX = 1.80. Optional Center Pad Length, Units.Dimension Limits = Y2. Optional Center Pad Length, MILLIMETERS.MIN = . Optional Center Pad Length, MILLIMETERS.NOM = . Optional Center Pad Length, MILLIMETERS.MAX = 1.80. Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 3.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 3.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X20), Units.Dimension Limits =",
    "RECOMMENDED LAND PATTERN\nX1. Contact Pad Width (X20), MILLIMETERS.MIN = . Contact Pad Width (X20), MILLIMETERS.NOM = . Contact Pad Width (X20), MILLIMETERS.MAX = 0.20. Contact Pad Length (X20), Units.Dimension Limits = Y1. Contact Pad Length (X20), MILLIMETERS.MIN = . Contact Pad Length (X20), MILLIMETERS.NOM = . Contact Pad Length (X20), MILLIMETERS.MAX = 0.80. Contact Pad to Center Pad (X20), Units.Dimension Limits = G1. Contact Pad to Center Pad (X20), MILLIMETERS.MIN = 0.20. Contact Pad to Center Pad (X20), MILLIMETERS.NOM = . Contact Pad to Center Pad (X20), MILLIMETERS.MAX = . Contact Pad to Contact Pad (X16), Units.Dimension Limits = G2. Contact Pad to Contact Pad (X16), MILLIMETERS.MIN = 0.20. Contact Pad to Contact Pad (X16), MILLIMETERS.NOM = . Contact Pad to Contact Pad (X16), MILLIMETERS.MAX = . Thermal Via",
    "RECOMMENDED LAND PATTERN\nDiameter, Units.Dimension Limits = V. Thermal Via Diameter, MILLIMETERS.MIN = . Thermal Via Diameter, MILLIMETERS.NOM = 0.30. Thermal Via Diameter, MILLIMETERS.MAX = . Thermal Via Pitch, Units.Dimension Limits = EV. Thermal Via Pitch, MILLIMETERS.MIN = . Thermal Via Pitch, MILLIMETERS.NOM = 1.00. Thermal Via Pitch, MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing  C04-2476-2LX Rev C\n\u00a9 2018 Microchip Technology Inc.",
    "51. Appendix A: Revision History\nF, Date = 08/2024. F, Comments = Updated Op Amp electrical specifications table, added 2LX package and minor editorial updates.. E, Date = 09/2023. E, Comments = Final data sheet; adds Characterization graphs.. D, Date = 09/2021. D, Comments = Updated Interrupts chapter, Ports chapter, and the 20-lead VQFN marking examples. C, Date = 06/2021. C, Comments = Updated the ZCD chapter, OPA chapter with structural changes, and the DMA Special Function Register tables. B, Date = 10/2020. B, Comments = Updated the NVM chapter, I 2 C chapter, and UART chapter with grammatical edits and features. A, Date = 04/2020. A, Comments = Initial document release",
    "The Microchip Website\nMicrochip provides online support via our website at www.microchip.com/. This website is used to make files and information easily available to customers. Some of the content available includes:\n\u00b7 Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\n\u00b7 General Technical Support - Frequently Asked Questions (FAQs), technical support requests, online discussion groups, Microchip design partner program member listing\n\u00b7 Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "Product Change Notification Service\nMicrochip's product change notification service helps keep customers current on Microchip products. Subscribers will receive email notification whenever there are changes, updates, revisions or errata related to a specified product family or development tool of interest.\nTo register, go to www.microchip.com/pcn and follow the registration instructions.",
    "Customer Support\nUsers of Microchip products can receive assistance through several channels:\n\u00b7 Distributor or Representative\n\u00b7 Local Sales Office\n\u00b7 Embedded Solutions Engineer (ESE)\n\u00b7 Technical Support\nCustomers should contact their distributor, representative or ESE for support. Local sales offices are also available to help customers. A listing of sales offices and locations is included in this document.\nTechnical support is available through the website at: www.microchip.com/support",
    "Product Identification System\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.\nPART NO.\n-X\n/XX\nPackage\n[X] (1)\nTape\nand Reel\nDevice\nTemperature\nRange",
    "Product Identification System\nDevice:, 1 = PIC18F04Q41, PIC18F14Q41, PIC18F05Q41, PIC18F15Q41, PIC18F06Q41, PIC18F16Q41. Device:, 2 = PIC18F04Q41, PIC18F14Q41, PIC18F05Q41, PIC18F15Q41, PIC18F06Q41, PIC18F16Q41. Tape & Reel Option:, 1 = Blank. Tape & Reel Option:, 2 = = Standard Packaging (tube or tray). , 1 = T. , 2 = = Tape & Reel. Temperature Range:, 1 = I. Temperature Range:, 2 = = -40\u00b0C to +85\u00b0C (Industrial). , 1 = E. , 2 = = -40\u00b0C to +125\u00b0C (Extended). Package:, 1 = SL. Package:, 2 = = 14-lead SOIC. , 1 = ST. , 2 = = 14-lead TSSOP. , 1 = P. , 2 = = 20-lead PDIP. , 1 = SO. , 2 = = 20-lead",
    "Product Identification System\nSOIC. , 1 = SS. , 2 = = 20-lead SSOP. , 1 = REB. , 2 = = 20-lead VQFN. , 1 = 2LX. , 2 = = 20-lead VQFN",
    "Examples:\n\u00b7 PIC18F04Q41 T-E/ST: Tape and Reel, Extended temperature, 14-lead TSSOP\n\u00b7 PIC18F15Q41 T-I/REB: Tape and Reel, Industrial temperature, 20-lead VQFN\n\u00b7 PIC18F16Q41 T-I/SO: Tape and Reel, Industrial temperature, 20-lead SOIC",
    "Notes:\n1. Tape and Reel identifier only appears in the catalog part number description. This identifier is used for ordering purposes and is not printed on the device package. Check with your Microchip Sales Office for package availability with the Tape and Reel option.\n2. Small form-factor packaging options may be available. Please check www.microchip.com/ packaging for small-form factor package availability, or contact your local Sales Office.",
    "Microchip Devices Code Protection Feature\nNote the following details of the code protection feature on Microchip products:\n\u00b7 Microchip products meet the specifications contained in their particular Microchip Data Sheet.\n\u00b7 Microchip believes that its family of products is secure when used in the intended manner, within operating specifications, and under normal conditions.\n\u00b7 Microchip values and aggressively protects its intellectual property rights. Attempts to breach the code protection features of Microchip product is strictly prohibited and may violate the Digital Millennium Copyright Act.\n\u00b7 Neither Microchip nor any other semiconductor manufacturer can guarantee the security of its code. Code protection does not mean that we are guaranteeing the product is 'unbreakable'. Code protection is constantly evolving. Microchip is committed to continuously improving the code protection features of our products.",
    "Legal Notice\nThis publication and the information herein may be used only with Microchip products, including to design, test, and integrate Microchip products with your application. Use of this information\nin any other manner violates these terms. Information regarding device applications is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure that your application meets with your specifications. Contact your local Microchip sales office for additional support or, obtain additional support at www.microchip.com/en-us/support/design-help/ client-support-services.\nTHIS INFORMATION IS PROVIDED BY MICROCHIP 'AS IS'. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND WHETHER EXPRESS OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE, OR WARRANTIES RELATED TO ITS CONDITION, QUALITY, OR PERFORMANCE.",
    "Legal Notice\nIN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, INCIDENTAL, OR CONSEQUENTIAL LOSS, DAMAGE, COST, OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE INFORMATION OR ITS USE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THE INFORMATION OR ITS USE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THE INFORMATION.\nUse of Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold harmless Microchip from any and all damages, claims, suits, or expenses resulting from such use. No licenses are conveyed, implicitly or otherwise, under any Microchip intellectual property rights unless otherwise stated.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, Adaptec, AVR, AVR logo, AVR Freaks, BesTime, BitCloud, CryptoMemory, CryptoRF, dsPIC, flexPWR, HELDO, IGLOO, JukeBlox, KeeLoq, Kleer, LANCheck, LinkMD, maXStylus, maXTouch, MediaLB, megaAVR, Microsemi, Microsemi logo, MOST, MOST logo, MPLAB, OptoLyzer, PIC, picoPower, PICSTART, PIC32 logo, PolarFire, Prochip Designer, QTouch, SAM-BA, SenGenuity, SpyNIC, SST, SST Logo, SuperFlash, Symmetricom, SyncServer, Tachyon, TimeSource, tinyAVR, UNI/O, Vectron, and XMEGA are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.",
    "Trademarks\nAgileSwitch, ClockWorks, The Embedded Control Solutions Company, EtherSynch, Flashtec, Hyper Speed Control, HyperLight Load, Libero, motorBench, mTouch, Powermite 3, Precision Edge, ProASIC, ProASIC Plus, ProASIC Plus logo, Quiet-Wire, SmartFusion, SyncWorld, TimeCesium, TimeHub, TimePictra, TimeProvider, and ZL are registered trademarks of Microchip Technology Incorporated in the U.S.A.",
    "Trademarks\nAdjacent Key Suppression, AKS, Analog-for-the-Digital Age, Any Capacitor, AnyIn, AnyOut, Augmented Switching, BlueSky, BodyCom, Clockstudio, CodeGuard, CryptoAuthentication, CryptoAutomotive, CryptoCompanion, CryptoController, dsPICDEM, dsPICDEM.net, Dynamic Average Matching, DAM, ECAN, Espresso T1S, EtherGREEN, EyeOpen, GridTime, IdealBridge, IGaT, In-Circuit Serial Programming, ICSP, INICnet, Intelligent Paralleling, IntelliMOS, Inter-Chip Connectivity, JitterBlocker, Knob-on-Display, MarginLink, maxCrypto, maxView, memBrain, Mindi, MiWi, MPASM, MPF, MPLAB Certified logo, MPLIB, MPLINK, mSiC, MultiTRAK, NetDetach, Omniscient Code Generation, PICDEM, PICDEM.net, PICkit, PICtail, Power MOS IV, Power MOS 7, PowerSmart, PureSilicon, QMatrix, REAL ICE, Ripple Blocker, RTAX,",
    "Trademarks\nRTG4, SAM-ICE, Serial Quad I/O, simpleMAP, SimpliPHY, SmartBuffer, SmartHLS, SMART-I.S., storClad, SQI, SuperSwitcher, SuperSwitcher II, Switchtec, SynchroPHY, Total Endurance, Trusted Time, TSHARC, Turing, USBCheck, VariSense, VectorBlox, VeriPHY, ViewSpan, WiperLock, XpressConnect, and ZENA are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nThe Adaptec logo, Frequency on Demand, Silicon Storage Technology, and Symmcom are registered trademarks of Microchip Technology Inc. in other countries.\nGestIC is a registered trademark of Microchip Technology Germany II GmbH & Co. KG, a subsidiary of Microchip Technology Inc., in other countries.\nAll other trademarks mentioned herein are property of their respective companies.\n- \u00a9 2020-2024, Microchip Technology Incorporated and its subsidiaries. All Rights Reserved.",
    "Trademarks\nISBN: 978-1-6683-0021-3",
    "Quality Management System\nFor information regarding Microchip's Quality Management Systems, please visit www.microchip.com/quality.",
    "Worldwide Sales and Service\nCorporate Office, ASIA/PACIFIC = Australia - Sydney. Corporate Office, ASIA/PACIFIC = India - Bangalore. Corporate Office, EUROPE = Austria - Wels. 2355 West Chandler Blvd., ASIA/PACIFIC = Tel: 61-2-9868-6733. 2355 West Chandler Blvd., ASIA/PACIFIC = Tel: 91-80-3090-4444. 2355 West Chandler Blvd., EUROPE = Tel: 43-7242-2244-39. Chandler, AZ 85224-6199, ASIA/PACIFIC = China - Beijing. Chandler, AZ 85224-6199, ASIA/PACIFIC = India - New Delhi. Chandler, AZ 85224-6199, EUROPE = Fax: 43-7242-2244-393. Tel: 480-792-7200, ASIA/PACIFIC = Tel: 86-10-8569-7000. Tel: 480-792-7200, ASIA/PACIFIC = Tel: 91-11-4160-8631. Tel: 480-792-7200, EUROPE = Denmark - Copenhagen. Fax:",
    "Worldwide Sales and Service\n480-792-7277, ASIA/PACIFIC = China - Chengdu. Fax: 480-792-7277, ASIA/PACIFIC = India - Pune. Fax: 480-792-7277, EUROPE = Tel: 45-4485-5910. Technical Support: www.microchip.com/support, ASIA/PACIFIC = Tel: 86-28-8665-5511. Technical Support: www.microchip.com/support, ASIA/PACIFIC = Tel: 91-20-4121-0141. Technical Support: www.microchip.com/support, EUROPE = Fax: 45-4485-2829. Web Address:, ASIA/PACIFIC = China - Chongqing. Web Address:, ASIA/PACIFIC = Japan - Osaka. Web Address:, EUROPE = Finland - Espoo. www.microchip.com, ASIA/PACIFIC = Tel: 86-23-8980-9588. www.microchip.com, ASIA/PACIFIC = Tel: 81-6-6152-7160. www.microchip.com, EUROPE = Tel:",
    "Worldwide Sales and Service\n358-9-4520-820. Atlanta, ASIA/PACIFIC = China - Dongguan. Atlanta, ASIA/PACIFIC = Japan - Tokyo. Atlanta, EUROPE = France - Paris. Duluth, GA, ASIA/PACIFIC = Tel: 86-769-8702-9880. Duluth, GA, ASIA/PACIFIC = Tel: 81-3-6880- 3770. Duluth, GA, EUROPE = Tel: 33-1-69-53-63-20 Fax: 33-1-69-30-90-79. Tel: 678-957-9614, ASIA/PACIFIC = China - Guangzhou. Tel: 678-957-9614, ASIA/PACIFIC = Korea - Daegu. Tel: 678-957-9614, EUROPE = . Fax: 678-957-1455, ASIA/PACIFIC = Tel: 86-20-8755-8029. Fax: 678-957-1455, ASIA/PACIFIC = Tel: 82-53-744-4301. Fax: 678-957-1455, EUROPE = Germany - Garching. Austin, TX, ASIA/PACIFIC",
    "Worldwide Sales and Service\n= China - Hangzhou. Austin, TX, ASIA/PACIFIC = Korea - Seoul. Austin, TX, EUROPE = Tel: 49-8931-9700. Tel: 512-257-3370, ASIA/PACIFIC = Tel: 86-571-8792-8115. Tel: 512-257-3370, ASIA/PACIFIC = Tel: 82-2-554-7200. Tel: 512-257-3370, EUROPE = Germany - Haan. Boston, ASIA/PACIFIC = China - Hong Kong SAR. Boston, ASIA/PACIFIC = Malaysia - Kuala Lumpur. Boston, EUROPE = Tel: 49-2129-3766400. Westborough, MA, ASIA/PACIFIC = Tel: 852-2943-5100. Westborough, MA, ASIA/PACIFIC = Tel: 60-3-7651-7906. Westborough, MA, EUROPE = Germany - Heilbronn. Tel: 774-760-0087 774-760-0088, ASIA/PACIFIC = China - Nanjing. Tel: 774-760-0087 774-760-0088, ASIA/PACIFIC = Malaysia - Penang. Tel:",
    "Worldwide Sales and Service\n774-760-0087 774-760-0088, EUROPE = Tel: 49-7131-72400. Fax:, ASIA/PACIFIC = Tel: 86-25-8473-2460. Fax:, ASIA/PACIFIC = Tel: 60-4-227-8870. Fax:, EUROPE = Germany - Karlsruhe. Chicago Itasca,, ASIA/PACIFIC = China - Qingdao. Chicago Itasca,, ASIA/PACIFIC = Philippines - Manila. Chicago Itasca,, EUROPE = Tel: 49-721-625370 Germany - Munich. IL Tel: 630-285-0071, ASIA/PACIFIC = Tel: 86-532-8502-7355. IL Tel: 630-285-0071, ASIA/PACIFIC = Tel: 63-2-634-9065. IL Tel: 630-285-0071, EUROPE = Tel: 49-89-627-144-0. Fax: 630-285-0075, ASIA/PACIFIC = China - Shanghai. Fax: 630-285-0075, ASIA/PACIFIC = Singapore. Fax:",
    "Worldwide Sales and Service\n630-285-0075, EUROPE = Fax: 49-89-627-144-44. Dallas, ASIA/PACIFIC = Tel: 86-21-3326-8000. Dallas, ASIA/PACIFIC = Tel: 65-6334-8870. Dallas, EUROPE = Germany - Rosenheim. Addison, TX, ASIA/PACIFIC = China - Shenyang. Addison, TX, ASIA/PACIFIC = Taiwan - Hsin Chu. Addison, TX, EUROPE = Tel: 49-8031-354-560. Tel: 972-818-7423, ASIA/PACIFIC = Tel: 86-24-2334-2829. Tel: 972-818-7423, ASIA/PACIFIC = Tel: 886-3-577-8366. Tel: 972-818-7423, EUROPE = Israel - Hod Hasharon. Fax: 972-818-2924, ASIA/PACIFIC = China - Shenzhen. Fax: 972-818-2924, ASIA/PACIFIC = Taiwan - Kaohsiung. Fax: 972-818-2924, EUROPE = Tel:",
    "Worldwide Sales and Service\n972-9-775-5100. Detroit, ASIA/PACIFIC = Tel: 86-755-8864-2200. Detroit, ASIA/PACIFIC = Tel: 886-7-213-7830. Detroit, EUROPE = Italy - Milan. Novi, MI, ASIA/PACIFIC = China - Suzhou. Novi, MI, ASIA/PACIFIC = Taiwan - Taipei. Novi, MI, EUROPE = Tel: 39-0331-742611. Tel: 248-848-4000, ASIA/PACIFIC = Tel: 86-186-6233-1526. Tel: 248-848-4000, ASIA/PACIFIC = Tel: 886-2-2508-8600. Tel: 248-848-4000, EUROPE = Fax: 39-0331-466781. Houston, TX, ASIA/PACIFIC = China - Wuhan. Houston, TX, ASIA/PACIFIC = Thailand - Bangkok. Houston, TX, EUROPE = Italy - Padova. Tel: 281-894-5983, ASIA/PACIFIC = Tel: 86-27-5980-5300. Tel: 281-894-5983, ASIA/PACIFIC =",
    "Worldwide Sales and Service\nTel: 66-2-694-1351. Tel: 281-894-5983, EUROPE = Tel: 39-049-7625286. Indianapolis, ASIA/PACIFIC = China - Xian. Indianapolis, ASIA/PACIFIC = Vietnam - Ho Chi Minh. Indianapolis, EUROPE = Netherlands - Drunen. Noblesville, IN Tel: 317-773-8323, ASIA/PACIFIC = Tel: 86-29-8833-7252. Noblesville, IN Tel: 317-773-8323, ASIA/PACIFIC = Tel: 84-28-5448-2100. Noblesville, IN Tel: 317-773-8323, EUROPE = Tel: 31-416-690399. Fax: 317-773-5453, ASIA/PACIFIC = China - Xiamen. Fax: 317-773-5453, ASIA/PACIFIC = . Fax: 317-773-5453, EUROPE = Fax: 31-416-690340. Tel: 317-536-2380, ASIA/PACIFIC = Tel: 86-592-2388138. Tel:",
    "Worldwide Sales and Service\n317-536-2380, ASIA/PACIFIC = . Tel: 317-536-2380, EUROPE = Norway - Trondheim. Los Angeles, ASIA/PACIFIC = China - Zhuhai. Los Angeles, ASIA/PACIFIC = . Los Angeles, EUROPE = Tel: 47-72884388. Mission Viejo, CA, ASIA/PACIFIC = Tel: 86-756-3210040. Mission Viejo, CA, ASIA/PACIFIC = . Mission Viejo, CA, EUROPE = Poland - Warsaw. Fax: 949-462-9608, ASIA/PACIFIC = . Fax: 949-462-9608, ASIA/PACIFIC = . Fax: 949-462-9608, EUROPE = Romania - Bucharest. Tel: 951-273-7800, ASIA/PACIFIC = . Tel: 951-273-7800, ASIA/PACIFIC = . Tel: 951-273-7800, EUROPE = Tel: 40-21-407-87-50. Raleigh, NC, ASIA/PACIFIC = . Raleigh, NC, ASIA/PACIFIC = . Raleigh, NC, EUROPE = Spain - Madrid. Tel:",
    "Worldwide Sales and Service\n919-844-7510 New York, NY, ASIA/PACIFIC = . Tel: 919-844-7510 New York, NY, ASIA/PACIFIC = . Tel: 919-844-7510 New York, NY, EUROPE = Tel: 34-91-708-08-90. , ASIA/PACIFIC = . , ASIA/PACIFIC = . , EUROPE = Fax: 34-91-708-08-91. Tel: 631-435-6000, ASIA/PACIFIC = . Tel: 631-435-6000, ASIA/PACIFIC = . Tel: 631-435-6000, EUROPE = Sweden - Gothenberg. San Jose, CA, ASIA/PACIFIC = . San Jose, CA, ASIA/PACIFIC = . San Jose, CA, EUROPE = Tel: 46-31-704-60-40. Tel: 408-735-9110 Tel: 408-436-4270, ASIA/PACIFIC = . Tel: 408-735-9110 Tel: 408-436-4270, ASIA/PACIFIC = . Tel: 408-735-9110 Tel:",
    "Worldwide Sales and Service\n408-436-4270, EUROPE = Sweden - Stockholm Tel: 46-8-5090-4654. Canada - Toronto, ASIA/PACIFIC = . Canada - Toronto, ASIA/PACIFIC = . Canada - Toronto, EUROPE = UK - Wokingham. Tel: 905-695-1980, ASIA/PACIFIC = . Tel: 905-695-1980, ASIA/PACIFIC = . Tel: 905-695-1980, EUROPE = . Fax: 905-695-2078, ASIA/PACIFIC = . Fax: 905-695-2078, ASIA/PACIFIC = . Fax: 905-695-2078, EUROPE = Tel: 44-118-921-5800 Fax: 44-118-921-5820"
]
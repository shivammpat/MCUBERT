[
    "Analog Features:\n\u00b7 Source code compatible with the PIC16 and PIC17 instruction sets\n\u00b7 Linear program memory addressing to 2 Mbytes\n\u00b7 Linear data memory addressing to 4096 bytes\n\u00b7 1 Kbyte of data EEPROM\n\u00b7 Up to 10 MIPs operation:\n-DC - 40 MHz osc./clock input\n-4 MHz-10 MHz osc./clock input with PLL active\n\u00b7 16-bit wide instructions, 8-bit wide data path\n\u00b7 Priority levels for interrupts\n\u00b7 31-level, software accessible hardware stack\n\u00b7 8 x 8 Single-Cycle Hardware Multiplier",
    "External Memory Interface (PIC18F8X8X Devices Only):\n\u00b7 Address capability of up to 2 Mbytes\n\u00b7 16-bit interface",
    "Peripheral Features:\n\u00b7 High current sink/source 25 mA/25 mA\n\u00b7 Four external interrupt pins\n\u00b7 Timer0 module: 8-bit/16-bit timer/counter\n\u00b7 Timer1 module: 16-bit timer/counter\n\u00b7 Timer2 module: 8-bit timer/counter\n\u00b7 Timer3 module: 16-bit timer/counter\n\u00b7 Secondary oscillator clock option - Timer1/Timer3\n\u00b7 One Capture/Compare/PWM (CCP) module:\n-Capture is 16-bit, max. resolution 6.25 ns (TCY/16)\n-Compare is 16-bit, max. resolution 100 ns (TCY)\n-PWM output: PWM resolution is 1 to 10-bit\n\u00b7 Enhanced Capture/Compare/PWM (ECCP) module:\n-Same Capture/Compare features as CCP\n-One, two or four PWM outputs\n-Selectable polarity\n-Programmable dead time\n-Auto-shutdown on external event\n-Auto-restart\n\u00b7 Master Synchronous Serial Port (MSSP) module with two modes of operation:\n-3-wire SPI (supports all 4 SPI modes)\n-I 2 C\u2122 Master and Slave mode\n\u00b7 Enhanced Addressable USART module:",
    "Peripheral Features:\n-Supports RS-232, RS-485 and LIN 1.2\n-Programmable wake-up on Start bit\n-Auto-baud detect\n\u00b7 Parallel Slave Port (PSP) module\n\u00b7 Up to 16-channel, 10-bit Analog-to-Digital Converter module (A/D) with:\n-Fast sampling rate\n-Programmable acquisition time\n-Conversion available during Sleep\n\u00b7 Programmable 16-level Low-Voltage Detection (LVD) module:\n-Supports interrupt on Low-Voltage Detection\n\u00b7 Programmable Brown-out Reset (BOR)\n\u00b7 Dual analog comparators:\n-Programmable input/output configuration",
    "ECAN Module Features:\n\u00b7 Message bit rates up to 1 Mbps\n\u00b7 Conforms to CAN 2.0B ACTIVE Specification\n\u00b7 Fully backward compatible with PIC18XXX8 CAN modules\n\u00b7 Three modes of operation:\n-Legacy, Enhanced Legacy, FIFO\n\u00b7 Three dedicated transmit buffers with prioritization\n\u00b7 Two dedicated receive buffers\n\u00b7 Six programmable receive/transmit buffers\n\u00b7 Three full 29-bit acceptance masks\n\u00b7 16 full 29-bit acceptance filters with dynamic association\n\u00b7 DeviceNet\u2122 data byte filter support\n\u00b7 Automatic remote frame handling\n\u00b7 Advanced Error Management features",
    "Special Microcontroller Features:\n\u00b7 100,000 erase/write cycle Enhanced Flash program memory typical\n\u00b7 1,000,000 erase/write cycle Data EEPROM memory typical\n\u00b7 1-second programming time\n\u00b7 Flash/Data EEPROM Retention: > 40 years\n\u00b7 Self-reprogrammable under software control\n\u00b7 Power-on Reset (POR), Power-up Timer (PWRT) and Oscillator Start-up Timer (OST)\n\u00b7 Watchdog Timer (WDT) with its own On-Chip RC Oscillator\n\u00b7 Programmable code protection\n\u00b7 Power saving Sleep mode\n\u00b7 Selectable oscillator options including:\n-Software enabled 4x Phase Lock Loop (of primary oscillator)\n-Secondary Oscillator (32 kHz) clock input\n\u00b7 In-Circuit Serial Programming\u2122 (ICSP\u2122) via two pins\n\u00b7 MPLAB \u00ae  In-Circuit Debug (ICD) via two pins",
    "CMOS Technology:\n\u00b7 Low-power, high-speed Flash technology\n\u00b7 Fully static design\n\u00b7 Wide operating voltage range (2.0V to 5.5V)\n\u00b7 Industrial and Extended temperature ranges",
    "CMOS Technology:\nPIC18F6585, Program Memory.Bytes = 48K. PIC18F6585, Program Memory.# Single-Word Instructions = 24576. PIC18F6585, Data Memory.SRAM (bytes) = 3328. PIC18F6585, Data Memory.EEPROM (bytes) = 1024. PIC18F6585, I/O.I/O = 53. PIC18F6585, 10-bit A/D (ch).10-bit A/D (ch) = 12. PIC18F6585, CCP/ ECCP (PWM).CCP/ ECCP (PWM) = 1/1. PIC18F6585, MSSP.SPI = Y. PIC18F6585, MSSP.Master I 2 C = Y. PIC18F6585, ECAN/ AUSART.ECAN/ AUSART = Y/Y. PIC18F6585, Timers.8-bit/16-bit = 2/3. PIC18F6585, EMA = N. PIC18F6680, Program Memory.Bytes = 64K. PIC18F6680, Program",
    "CMOS Technology:\nMemory.# Single-Word Instructions = 32768. PIC18F6680, Data Memory.SRAM (bytes) = 3328. PIC18F6680, Data Memory.EEPROM (bytes) = 1024. PIC18F6680, I/O.I/O = 53. PIC18F6680, 10-bit A/D (ch).10-bit A/D (ch) = 12. PIC18F6680, CCP/ ECCP (PWM).CCP/ ECCP (PWM) = 1/1. PIC18F6680, MSSP.SPI = Y. PIC18F6680, MSSP.Master I 2 C = Y. PIC18F6680, ECAN/ AUSART.ECAN/ AUSART = Y/Y. PIC18F6680, Timers.8-bit/16-bit = 2/3. PIC18F6680, EMA = N. PIC18F8585, Program Memory.Bytes = 48K. PIC18F8585, Program Memory.# Single-Word Instructions = 24576. PIC18F8585, Data",
    "CMOS Technology:\nMemory.SRAM (bytes) = 3328. PIC18F8585, Data Memory.EEPROM (bytes) = 1024. PIC18F8585, I/O.I/O = 69. PIC18F8585, 10-bit A/D (ch).10-bit A/D (ch) = 16. PIC18F8585, CCP/ ECCP (PWM).CCP/ ECCP (PWM) = 1/1. PIC18F8585, MSSP.SPI = Y. PIC18F8585, MSSP.Master I 2 C = Y. PIC18F8585, ECAN/ AUSART.ECAN/ AUSART = Y/Y. PIC18F8585, Timers.8-bit/16-bit = 2/3. PIC18F8585, EMA = Y. PIC18F8680, Program Memory.Bytes = 64K. PIC18F8680, Program Memory.# Single-Word Instructions = 32768. PIC18F8680, Data Memory.SRAM (bytes) = 3328. PIC18F8680, Data",
    "CMOS Technology:\nMemory.EEPROM (bytes) = 1024. PIC18F8680, I/O.I/O = 69. PIC18F8680, 10-bit A/D (ch).10-bit A/D (ch) = 16. PIC18F8680, CCP/ ECCP (PWM).CCP/ ECCP (PWM) = 1/1. PIC18F8680, MSSP.SPI = Y. PIC18F8680, MSSP.Master I 2 C = Y. PIC18F8680, ECAN/ AUSART.ECAN/ AUSART = Y/Y. PIC18F8680, Timers.8-bit/16-bit = 2/3. PIC18F8680, EMA = Y",
    "Pin Diagrams (Continued)\nNote 1: PSP is available only in Microcontroller mode.\n2: CCP2 pin placement depends on CCP2MX and Processor mode settings.\n3: P1B and P1C pin placement depends on ECCPMX setting.",
    "Table of Contents\n1.0, 1 = Device Overview ........................................................................................................................................................................... 1.0, 2 = 9. 2.0, 1 = Oscillator Configurations",
    "Table of Contents\n............................................................................................................................................................. 2.0, 2 = 23. 3.0, 1 =",
    "Table of Contents\nReset........................................................................................................................................................................................... 3.0, 2 = 33. 4.0, 1 = Memory Organization",
    "Table of Contents\n.................................................................................................................................................................. 4.0, 2 = 51. 5.0, 1 = Flash Program",
    "Table of Contents\nMemory............................................................................................................................................................... 5.0, 2 = 83. 6.0, 1 = External Memory Interface",
    "Table of Contents\n.......................................................................................................................................................... 6.0, 2 = 93. 7.0, 1 = Data EEPROM Memory",
    "Table of Contents\n............................................................................................................................................................ 7.0, 2 = 101. 8.0, 1 = 8 x 8 Hardware",
    "Table of Contents\nMultiplier........................................................................................................................................................... 8.0, 2 = 107. 9.0, 1 = Interrupts",
    "Table of Contents\n................................................................................................................................................................................... 9.0, 2 = 109. 10.0, 1 = I/O Ports",
    "Table of Contents\n.................................................................................................................................................................................... 10.0, 2 = 125. 11.0, 1 = Timer0 Module",
    "Table of Contents\n.......................................................................................................................................................................... 11.0, 2 = 155. 12.0, 1 = Timer1 Module",
    "Table of Contents\n.......................................................................................................................................................................... 12.0, 2 = 159. 13.0, 1 = Timer2 Module",
    "Table of Contents\n.......................................................................................................................................................................... 13.0, 2 = 162. 14.0, 1 = Timer3 Module",
    "Table of Contents\n.......................................................................................................................................................................... 14.0, 2 = 164. 15.0, 1 = Capture/Compare/PWM (CCP) Modules",
    "Table of Contents\n.................................................................................................................................. 15.0, 2 = 167. 16.0, 1 = Enhanced Capture/Compare/PWM (ECCP)",
    "Table of Contents\nModule................................................................................................................. 16.0, 2 = 175. 17.0, 1 = Master Synchronous Serial Port (MSSP) Module",
    "Table of Contents\n..................................................................................................................... 17.0, 2 = 189. 18.0, 1 = Enhanced Universal Synchronous Asynchronous Receiver Transmitter (USART)................................................................... 18.0, 2 = 229. 19.0, 1 = 10-bit Analog-to-Digital Converter (A/D)",
    "Table of Contents\nModule....................................................................................................................... 19.0, 2 = 249. 20.0, 1 = Comparator",
    "Table of Contents\nModule................................................................................................................................................................... 20.0, 2 = 259. 21.0, 1 = Comparator Voltage Reference",
    "Table of Contents\nModule.................................................................................................................................... 21.0, 2 = 265. 22.0, 1 = Low-Voltage Detect",
    "Table of Contents\n................................................................................................................................................................... 22.0, 2 = 269. 23.0, 1 = ECAN",
    "Table of Contents\nModule............................................................................................................................................................................ 23.0, 2 = 275. 24.0, 1 = Special Features of the",
    "Table of Contents\nCPU..................................................................................................................................................... 24.0, 2 = 345. 25.0, 1 = Instruction Set",
    "Table of Contents\nSummary........................................................................................................................................................... 25.0, 2 = 365. 26.0, 1 = Development",
    "Table of Contents\nSupport................................................................................................................................................................ 26.0, 2 = 407. 27.0, 1 = Electrical Characteristics",
    "Table of Contents\n........................................................................................................................................................... 27.0, 2 = 413. 28.0, 1 = DC and AC Characteristics Graphs and",
    "Table of Contents\nTables........................................................................................................................ 28.0, 2 = 449. 29.0, 1 = Packaging",
    "Table of Contents\nInformation............................................................................................................................................................... 29.0, 2 = 465. Appendix, 1 = A: Revision",
    "Table of Contents\nHistory.............................................................................................................................................................. Appendix, 2 = 469. Appendix B: Device",
    "Table of Contents\nDifferences........................................................................................................................................................., 1 = Appendix B: Device",
    "Table of Contents\nDifferences.......................................................................................................................................................... Appendix B: Device",
    "Table of Contents\nDifferences........................................................................................................................................................., 2 = 469. Appendix C: Conversion Considerations",
    "Table of Contents\n..........................................................................................................................................., 1 = Appendix C: Conversion Considerations",
    "Table of Contents\n............................................................................................................................................ Appendix C: Conversion Considerations",
    "Table of Contents\n..........................................................................................................................................., 2 = 470. Appendix D: Migration from Mid-Range to Enhanced",
    "Table of Contents\nDevices.........................................................................................................., 1 = Appendix D: Migration from Mid-Range to Enhanced Devices........................................................................................................... Appendix D: Migration from Mid-Range to Enhanced",
    "Table of Contents\nDevices.........................................................................................................., 2 = 470. Appendix E: Migration from High-End to Enhanced Devices............................................................................................................., 1 = Appendix E: Migration from High-End to Enhanced",
    "Table of Contents\nDevices.............................................................................................................. Appendix E: Migration from High-End to Enhanced Devices............................................................................................................., 2 = 471. Index",
    "Table of Contents\n.................................................................................................................................................................................................., 1 = Index",
    "Table of Contents\n................................................................................................................................................................................................... Index",
    "Table of Contents\n.................................................................................................................................................................................................., 2 = 473. On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................., 1 = On-Line",
    "Table of Contents\nSupport.................................................................................................................................................................................. On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................., 2 = 487. Systems Information and Upgrade Hot Line",
    "Table of Contents\n......................................................................................................................................, 1 = Systems Information and Upgrade Hot Line",
    "Table of Contents\n....................................................................................................................................... Systems Information and Upgrade Hot Line",
    "Table of Contents\n......................................................................................................................................, 2 = 487. Reader Response",
    "Table of Contents\n.............................................................................................................................................................................., 1 = Reader Response",
    "Table of Contents\n............................................................................................................................................................................... Reader Response",
    "Table of Contents\n.............................................................................................................................................................................., 2 = 488. PIC18F6585/8585/6680/8680 Product Identification System",
    "Table of Contents\n............................................................................................................, 1 = PIC18F6585/8585/6680/8680 Product Identification System ............................................................................................................. PIC18F6585/8585/6680/8680 Product Identification",
    "Table of Contents\nSystem ............................................................................................................, 2 = 489",
    "TO OUR VALUED CUSTOMERS\nIt is our intention to provide our valued customers with the best documentation possible to ensure successful use of your Microchip products. To this end, we will continue to improve our publications to better suit your needs. Our publications will be refined and enhanced as new volumes and updates are introduced.\nIf you have any questions or comments regarding this publication, please contact the Marketing Communications Department via E-mail at docerrors@mail.microchip.com or fax the Reader Response Form in the back of this data sheet to (480) 792-4150. We welcome your feedback.",
    "Most Current Data Sheet\nTo obtain the most up-to-date version of this data sheet, please register at our Worldwide Web site at:\nhttp://www.microchip.com\nYou can determine the version of a data sheet by examining its literature number found on the bottom outside corner of any page. The last character of the literature number is the version number, (e.g., DS30000A is version A of document DS30000).",
    "Errata\nAn errata sheet, describing minor operational differences from the data sheet and recommended workarounds, may exist for current devices. As device/documentation issues become known to us, we will publish an errata sheet. The errata will specify the revision of silicon and revision of document to which it applies.\nTo determine if an errata sheet exists for a particular device, please check with one of the following:\n\u00b7 Microchip's Worldwide Web site; http://www.microchip.com\n\u00b7 Your local Microchip sales office (see last page)\n\u00b7 The Microchip Corporate Literature Center; U.S. FAX: (480) 792-7277\nWhen contacting a sales office or the literature center, please specify which device, revision of silicon and data sheet (include literature number) you are using.",
    "Customer Notification System\nRegister on our Web site at www.microchip.com/cn to receive the most current information on all of our products.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "1.0 DEVICE OVERVIEW\nThis document contains device specific information for the following devices:\nAll other features for devices in the PIC18F6585/8585/6680/8680 family are identical. These are summarized in Table 1-1.\n\u2022 PIC18F6585\n\u2022 PIC18F8585\n\u2022 PIC18F6680\n\u2022 PIC18F8680\nPIC18F6X8X devices are available in 64-pin TQFP and 68-pin  PLCC  packages.  PIC18F8X8X  devices  are available  in the  80-pin  TQFP  package.  They  are differentiated from each other in four ways:\n1. Flash program memory (48 Kbytes for PIC18FX585 devices, 64 Kbytes for PIC18FX680)\n2. A/D channels (12 for PIC18F6X8X devices, 16 for PIC18F8X8X)\n3. I/O  ports  (7  on  PIC18F6X8X  devices,  9  on PIC18F8X8X)\n4. External  program  memory  interface  (present only on PIC18F8X8X devices)",
    "TABLE 1-1: PIC18F6585/8585/6680/8680 DEVICE FEATURES\n\nNote 1: PSP is only available in Microcontroller mode.",
    "TABLE 1-1: PIC18F6585/8585/6680/8680 DEVICE FEATURES\nOperating Frequency, PIC18F6585 = DC - 40 MHz. Operating Frequency, PIC18F6680 = DC - 40 MHz. Operating Frequency, PIC18F8585 = DC - 40 MHz DC - 25 MHz w/EMA. Operating Frequency, PIC18F8680 = DC - 40 MHz DC - 25 MHz w/EMA. Program Memory (Bytes), PIC18F6585 = 48K. Program Memory (Bytes), PIC18F6680 = 64K. Program Memory (Bytes), PIC18F8585 = 48K (2 MB EMA). Program Memory (Bytes), PIC18F8680 = 64K (2 MB EMA). Program Memory (Instructions), PIC18F6585 = 24576. Program Memory (Instructions), PIC18F6680 = 32768. Program Memory (Instructions), PIC18F8585 = 24576. Program Memory (Instructions), PIC18F8680 = 32768. Data Memory (Bytes), PIC18F6585 = 3328. Data Memory (Bytes), PIC18F6680 =",
    "TABLE 1-1: PIC18F6585/8585/6680/8680 DEVICE FEATURES\n3328. Data Memory (Bytes), PIC18F8585 = 3328. Data Memory (Bytes), PIC18F8680 = 3328. Data EEPROM Memory (Bytes), PIC18F6585 = 1024. Data EEPROM Memory (Bytes), PIC18F6680 = 1024. Data EEPROM Memory (Bytes), PIC18F8585 = 1024. Data EEPROM Memory (Bytes), PIC18F8680 = 1024. External Memory Interface, PIC18F6585 = No. External Memory Interface, PIC18F6680 = No. External Memory Interface, PIC18F8585 = Yes. External Memory Interface, PIC18F8680 = Yes. Interrupt Sources, PIC18F6585 = 29. Interrupt Sources, PIC18F6680 = 29. Interrupt Sources, PIC18F8585 = 29. Interrupt Sources, PIC18F8680 = 29. I/O Ports, PIC18F6585 = Ports A-G. I/O Ports, PIC18F6680 = Ports A-G. I/O Ports,",
    "TABLE 1-1: PIC18F6585/8585/6680/8680 DEVICE FEATURES\nPIC18F8585 = Ports A-H, J. I/O Ports, PIC18F8680 = Ports A-H, J. Timers, PIC18F6585 = 4. Timers, PIC18F6680 = 4. Timers, PIC18F8585 = 4. Timers, PIC18F8680 = 4. Capture/Compare/PWM Module, PIC18F6585 = 1. Capture/Compare/PWM Module, PIC18F6680 = 1. Capture/Compare/PWM Module, PIC18F8585 = 1. Capture/Compare/PWM Module, PIC18F8680 = 1. EnhancedCapture/Compare/PWM Module, PIC18F6585 = 1. EnhancedCapture/Compare/PWM Module, PIC18F6680 = 1. EnhancedCapture/Compare/PWM Module, PIC18F8585 = 1. EnhancedCapture/Compare/PWM Module, PIC18F8680 = 1. Serial Communications, PIC18F6585 = MSSP, Enhanced AUSART,",
    "TABLE 1-1: PIC18F6585/8585/6680/8680 DEVICE FEATURES\nECAN. Serial Communications, PIC18F6680 = MSSP, Enhanced AUSART, ECAN. Serial Communications, PIC18F8585 = MSSP, Enhanced AUSART, ECAN. Serial Communications, PIC18F8680 = MSSP, Enhanced AUSART, ECAN. Parallel Communications, PIC18F6585 = PSP. Parallel Communications, PIC18F6680 = PSP. Parallel Communications, PIC18F8585 = PSP (1). Parallel Communications, PIC18F8680 = PSP (1). 10-bit Analog-to-Digital Module, PIC18F6585 = 12 input channels. 10-bit Analog-to-Digital Module, PIC18F6680 = 12 input channels. 10-bit Analog-to-Digital Module, PIC18F8585 = 16 input channels. 10-bit Analog-to-Digital Module, PIC18F8680 = 16 input channels. Resets (and Delays), PIC18F6585 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Resets (and",
    "TABLE 1-1: PIC18F6585/8585/6680/8680 DEVICE FEATURES\nDelays), PIC18F6680 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Resets (and Delays), PIC18F8585 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Resets (and Delays), PIC18F8680 = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Programmable Low-Voltage Detect, PIC18F6585 = Yes. Programmable Low-Voltage Detect, PIC18F6680 = Yes. Programmable Low-Voltage Detect, PIC18F8585 = Yes. Programmable Low-Voltage Detect, PIC18F8680 = Yes. Programmable Brown-out Reset, PIC18F6585 = Yes. Programmable Brown-out Reset, PIC18F6680 = Yes. Programmable Brown-out Reset, PIC18F8585 = Yes. Programmable Brown-out Reset, PIC18F8680 = Yes. Instruction Set, PIC18F6585 = 75",
    "TABLE 1-1: PIC18F6585/8585/6680/8680 DEVICE FEATURES\nInstructions. Instruction Set, PIC18F6680 = 75 Instructions. Instruction Set, PIC18F8585 = 75 Instructions. Instruction Set, PIC18F8680 = 75 Instructions. Package, PIC18F6585 = 64-pin TQFP, 68-pin PLCC. Package, PIC18F6680 = 64-pin TQFP, 68-pin PLCC. Package, PIC18F8585 = 80-pin TQFP. Package, PIC18F8680 = 80-pin TQFP\nBlock diagrams of the PIC18F6X8X and PIC18F8X8X devices  are  provided  in  Figure 1-1  and  Figure 1-2, respectively. The pinouts for these device families are listed in Table 1-2.",
    "PIC18F6585/8585/6680/8680\nFIGURE 1-1:\nPIC18F6X8X BLOCK DIAGRAM\nFIGURE 1-2:\nPIC18F8X8X BLOCK DIAGRAM",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS\nRG5/MCLR/VPP, Pin Number.PIC18F6X8X.TQFP = 7. RG5/MCLR/VPP, Pin Number.PIC18F6X8X.PLCC = 16. RG5/MCLR/VPP, Pin Number.PIC18F8X8X.TQFP = 9. RG5/MCLR/VPP, Pin Type. = . RG5/MCLR/VPP, Buffer Type. = . RG5/MCLR/VPP, Description. = Master Clear (input) or programming voltage (input).. RG5 MCLR, Pin Number.PIC18F6X8X.TQFP = . RG5 MCLR, Pin Number.PIC18F6X8X.PLCC = . RG5 MCLR, Pin Number.PIC18F8X8X.TQFP = . RG5 MCLR, Pin Type. = I I. RG5 MCLR, Buffer Type. = ST ST. RG5 MCLR, Description.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS\n= General purpose input pin. Master Clear (Reset) input. This pin is an active-low Reset to the device.. VPP, Pin Number.PIC18F6X8X.TQFP = . VPP, Pin Number.PIC18F6X8X.PLCC = . VPP, Pin Number.PIC18F8X8X.TQFP = . VPP, Pin Type. = P. VPP, Buffer Type. = . VPP, Description. = Programming voltage input.. OSC1/CLKI OSC1, Pin Number.PIC18F6X8X.TQFP = 39. OSC1/CLKI OSC1, Pin Number.PIC18F6X8X.PLCC = 50. OSC1/CLKI OSC1, Pin Number.PIC18F8X8X.TQFP = 49. OSC1/CLKI OSC1, Pin Type. = . OSC1/CLKI OSC1, Buffer Type. = . OSC1/CLKI OSC1, Description. =",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS\nOscillator crystal or external clock input.. , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC = . , Pin Number.PIC18F8X8X.TQFP = . , Pin Type. = I. , Buffer Type. = CMOS/ST. , Description. = Oscillator crystal input or external clock source input. ST buffer when configured in RC mode; otherwise CMOS.. CLKI, Pin Number.PIC18F6X8X.TQFP = . CLKI, Pin Number.PIC18F6X8X.PLCC = . CLKI, Pin Number.PIC18F8X8X.TQFP = . CLKI, Pin Type. = I. CLKI, Buffer Type. = CMOS. CLKI, Description. = External clock source input. Always associated with pin function OSC1 (see OSC1/CLKI, OSC2/CLKO pins).. OSC2/CLKO/RA6, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS\nNumber.PIC18F6X8X.TQFP = 40. OSC2/CLKO/RA6, Pin Number.PIC18F6X8X.PLCC = 51. OSC2/CLKO/RA6, Pin Number.PIC18F8X8X.TQFP = 50. OSC2/CLKO/RA6, Pin Type. = O. OSC2/CLKO/RA6, Buffer Type. = . OSC2/CLKO/RA6, Description. = Oscillator crystal or clock output. Oscillator crystal output.. OSC2 CLKO, Pin Number.PIC18F6X8X.TQFP = . OSC2 CLKO, Pin Number.PIC18F6X8X.PLCC = . OSC2 CLKO, Pin Number.PIC18F8X8X.TQFP = . OSC2 CLKO, Pin Type. = O. OSC2 CLKO, Buffer Type. = - -. OSC2 CLKO, Description. = Connects to crystal or",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS\nresonator in Crystal Oscillator mode. In RC mode, OSC2 pin outputs CLKO. RA6, Pin Number.PIC18F6X8X.TQFP = . RA6, Pin Number.PIC18F6X8X.PLCC = . RA6, Pin Number.PIC18F8X8X.TQFP = . RA6, Pin Type. = I/O. RA6, Buffer Type. = TTL. RA6, Description. = which has 1/4 the frequency of OSC1 and denotes the instruction cycle rate. General purpose I/O pin.\nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST\n=  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP\n=  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1: Alternate assignment for CCP2 in all operating modes except Microcontroller - applies to PIC18F8X8X only.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS\n2: Default assignment when CCP2MX is set.\n3: External memory interface functions are only available on PIC18F8X8X devices.\n4: CCP2 is multiplexed with this pin by default when configured in Microcontroller mode; otherwise, it is multiplexed with either RB3 or RC1.\n5: PORTH and PORTJ are only available on PIC18F8X8X (80-pin) devices.\n6: PSP is available in Microcontroller mode only.\n7: On PIC18F8X8X devices, these pins can be multiplexed with RH7/RH6 by changing the ECCPMX configuration bit.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRA0/AN0 RA0 AN0, Pin Number.PIC18F6X8X.TQFP = 24. RA0/AN0 RA0 AN0, Pin Number.PIC18F6X8X.PLCC = 34. RA0/AN0 RA0 AN0, Pin Number.PIC18F8X8X.TQFP = 30. RA0/AN0 RA0 AN0, Pin Type. = I/O I. RA0/AN0 RA0 AN0, Buffer Type. = TTL Analog. RA0/AN0 RA0 AN0, Description. = Digital I/O. Analog input 0.. RA1/AN1 RA1 AN1, Pin Number.PIC18F6X8X.TQFP = 23. RA1/AN1 RA1 AN1, Pin Number.PIC18F6X8X.PLCC = 33. RA1/AN1 RA1 AN1, Pin Number.PIC18F8X8X.TQFP = 29. RA1/AN1 RA1 AN1, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nType. = I/O I. RA1/AN1 RA1 AN1, Buffer Type. = TTL Analog. RA1/AN1 RA1 AN1, Description. = Digital I/O. Analog input 1.. RA2/AN2/VREF- RA2 AN2 VREF-, Pin Number.PIC18F6X8X.TQFP = 22. RA2/AN2/VREF- RA2 AN2 VREF-, Pin Number.PIC18F6X8X.PLCC = 32. RA2/AN2/VREF- RA2 AN2 VREF-, Pin Number.PIC18F8X8X.TQFP = 28. RA2/AN2/VREF- RA2 AN2 VREF-, Pin Type. = I/O I I. RA2/AN2/VREF- RA2 AN2 VREF-, Buffer Type. = TTL Analog Analog. RA2/AN2/VREF- RA2 AN2 VREF-, Description. = Digital I/O. Analog input",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n2. A/D reference voltage (Low) input.. RA3/AN3/VREF+ RA3 AN3 VREF+, Pin Number.PIC18F6X8X.TQFP = 21. RA3/AN3/VREF+ RA3 AN3 VREF+, Pin Number.PIC18F6X8X.PLCC = 31. RA3/AN3/VREF+ RA3 AN3 VREF+, Pin Number.PIC18F8X8X.TQFP = 27. RA3/AN3/VREF+ RA3 AN3 VREF+, Pin Type. = I/O I I. RA3/AN3/VREF+ RA3 AN3 VREF+, Buffer Type. = TTL Analog Analog. RA3/AN3/VREF+ RA3 AN3 VREF+, Description. = Digital I/O. Analog input 3. A/D reference voltage (High) input.. RA4/T0CKI RA4 T0CKI RA5, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.TQFP = 28. RA4/T0CKI RA4 T0CKI RA5, Pin Number.PIC18F6X8X.PLCC = 39. RA4/T0CKI RA4 T0CKI RA5, Pin Number.PIC18F8X8X.TQFP = 34. RA4/T0CKI RA4 T0CKI RA5, Pin Type. = I/O I. RA4/T0CKI RA4 T0CKI RA5, Buffer Type. = ST/OD. RA4/T0CKI RA4 T0CKI RA5, Description. = Digital I/O - Open-drain when configured as output.. RA5/AN4/LVDIN AN4 LVDIN RA6, Pin Number.PIC18F6X8X.TQFP = 27. RA5/AN4/LVDIN AN4 LVDIN RA6, Pin Number.PIC18F6X8X.PLCC = 38. RA5/AN4/LVDIN",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nAN4 LVDIN RA6, Pin Number.PIC18F8X8X.TQFP = 33. RA5/AN4/LVDIN AN4 LVDIN RA6, Pin Type. = I/O I I. RA5/AN4/LVDIN AN4 LVDIN RA6, Buffer Type. = ST TTL Analog Analog. RA5/AN4/LVDIN AN4 LVDIN RA6, Description. = Timer0 external clock input. Digital I/O. Analog input 4. Low-voltage detect input. See the OSC2/CLKO/RA6 pin.\nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST\n=  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP\n=  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1:",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nAlternate assignment for CCP2 in all operating modes except Microcontroller - applies to PIC18F8X8X only.\n2: Default assignment when CCP2MX is set.\n3: External memory interface functions are only available on PIC18F8X8X devices.\n4: CCP2 is multiplexed with this pin by default when configured in Microcontroller mode; otherwise, it is multiplexed with either RB3 or RC1.\n5: PORTH and PORTJ are only available on PIC18F8X8X (80-pin) devices.\n6: PSP is available in Microcontroller mode only.\n7: On PIC18F8X8X devices, these pins can be multiplexed with RH7/RH6 by changing the ECCPMX configuration bit.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRB0/INT0 RB0 INT0, Pin Number.PIC18F6X8X.TQFP = 48. RB0/INT0 RB0 INT0, Pin Number.PIC18F6X8X.PLCC = 60. RB0/INT0 RB0 INT0, Pin Number.PIC18F8X8X.TQFP = 58. RB0/INT0 RB0 INT0, Pin Type. = . RB0/INT0 RB0 INT0, Buffer Type. = . RB0/INT0 RB0 INT0, Description. = . , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC = . , Pin Number.PIC18F8X8X.TQFP = . , Pin Type. = I/O. , Buffer Type. = TTL. , Description. = Digital I/O.. , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC =",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n. , Pin Number.PIC18F8X8X.TQFP = . , Pin Type. = . , Buffer Type. = . , Description. = External interrupt 0.. RB1/INT1, Pin Number.PIC18F6X8X.TQFP = . RB1/INT1, Pin Number.PIC18F6X8X.PLCC = . RB1/INT1, Pin Number.PIC18F8X8X.TQFP = . RB1/INT1, Pin Type. = I. RB1/INT1, Buffer Type. = ST. RB1/INT1, Description. = . , Pin Number.PIC18F6X8X.TQFP = 47. , Pin Number.PIC18F6X8X.PLCC = 59. , Pin Number.PIC18F8X8X.TQFP = 57. , Pin Type. = . , Buffer Type. = . , Description. = . RB1, Pin Number.PIC18F6X8X.TQFP = . RB1, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.PLCC = . RB1, Pin Number.PIC18F8X8X.TQFP = . RB1, Pin Type. = I/O. RB1, Buffer Type. = TTL. RB1, Description. = Digital I/O.. INT1, Pin Number.PIC18F6X8X.TQFP = . INT1, Pin Number.PIC18F6X8X.PLCC = . INT1, Pin Number.PIC18F8X8X.TQFP = . INT1, Pin Type. = . INT1, Buffer Type. = . INT1, Description. = . RB2/INT2, Pin Number.PIC18F6X8X.TQFP = . RB2/INT2, Pin Number.PIC18F6X8X.PLCC = . RB2/INT2, Pin Number.PIC18F8X8X.TQFP = . RB2/INT2, Pin Type. = I. RB2/INT2, Buffer Type. =",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nST. RB2/INT2, Description. = External interrupt 1.. , Pin Number.PIC18F6X8X.TQFP = 46. , Pin Number.PIC18F6X8X.PLCC = 58. , Pin Number.PIC18F8X8X.TQFP = 56. , Pin Type. = . , Buffer Type. = . , Description. = . RB2, Pin Number.PIC18F6X8X.TQFP = . RB2, Pin Number.PIC18F6X8X.PLCC = . RB2, Pin Number.PIC18F8X8X.TQFP = . RB2, Pin Type. = I/O. RB2, Buffer Type. = TTL. RB2, Description. = Digital I/O.. INT2, Pin Number.PIC18F6X8X.TQFP = . INT2, Pin Number.PIC18F6X8X.PLCC = . INT2, Pin Number.PIC18F8X8X.TQFP = . INT2,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nPin Type. = I. INT2, Buffer Type. = ST. INT2, Description. = External interrupt 2.. RB3/INT3/CCP2, Pin Number.PIC18F6X8X.TQFP = 45. RB3/INT3/CCP2, Pin Number.PIC18F6X8X.PLCC = 57. RB3/INT3/CCP2, Pin Number.PIC18F8X8X.TQFP = 55. RB3/INT3/CCP2, Pin Type. = . RB3/INT3/CCP2, Buffer Type. = . RB3/INT3/CCP2, Description. = . RB3, Pin Number.PIC18F6X8X.TQFP = . RB3, Pin Number.PIC18F6X8X.PLCC = . RB3, Pin Number.PIC18F8X8X.TQFP = . RB3, Pin Type. = I/O. RB3, Buffer Type. = TTL. RB3, Description.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= Digital I/O.. INT3, Pin Number.PIC18F6X8X.TQFP = . INT3, Pin Number.PIC18F6X8X.PLCC = . INT3, Pin Number.PIC18F8X8X.TQFP = . INT3, Pin Type. = I/O. INT3, Buffer Type. = ST. INT3, Description. = External interrupt 3.. CCP2 (1), Pin Number.PIC18F6X8X.TQFP = . CCP2 (1), Pin Number.PIC18F6X8X.PLCC = . CCP2 (1), Pin Number.PIC18F8X8X.TQFP = . CCP2 (1), Pin Type. = I/O. CCP2 (1), Buffer Type. = ST. CCP2 (1), Description. = Capture 2 input/Compare 2 output/ PWM 2 output.. RB4/KBI0, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.TQFP = . RB4/KBI0, Pin Number.PIC18F6X8X.PLCC = . RB4/KBI0, Pin Number.PIC18F8X8X.TQFP = . RB4/KBI0, Pin Type. = . RB4/KBI0, Buffer Type. = . RB4/KBI0, Description. = . , Pin Number.PIC18F6X8X.TQFP = 44. , Pin Number.PIC18F6X8X.PLCC = 56. , Pin Number.PIC18F8X8X.TQFP = 54. , Pin Type. = . , Buffer Type. = . , Description. = . RB4, Pin Number.PIC18F6X8X.TQFP = . RB4, Pin Number.PIC18F6X8X.PLCC = . RB4, Pin Number.PIC18F8X8X.TQFP = . RB4, Pin Type. = I/O.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRB4, Buffer Type. = TTL. RB4, Description. = Digital I/O.. KBI0, Pin Number.PIC18F6X8X.TQFP = . KBI0, Pin Number.PIC18F6X8X.PLCC = . KBI0, Pin Number.PIC18F8X8X.TQFP = . KBI0, Pin Type. = I. KBI0, Buffer Type. = ST. KBI0, Description. = Interrupt-on-change pin.. RB5/KBI1/PGM RB5, Pin Number.PIC18F6X8X.TQFP = 43. RB5/KBI1/PGM RB5, Pin Number.PIC18F6X8X.PLCC = 55. RB5/KBI1/PGM RB5, Pin Number.PIC18F8X8X.TQFP = 53. RB5/KBI1/PGM RB5, Pin Type. = I/O I. RB5/KBI1/PGM",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRB5, Buffer Type. = TTL ST ST. RB5/KBI1/PGM RB5, Description. = Digital I/O. Interrupt-on-change pin.. KBI1, Pin Number.PIC18F6X8X.TQFP = . KBI1, Pin Number.PIC18F6X8X.PLCC = . KBI1, Pin Number.PIC18F8X8X.TQFP = . KBI1, Pin Type. = I/O. KBI1, Buffer Type. = . KBI1, Description. = . PGM, Pin Number.PIC18F6X8X.TQFP = . PGM, Pin Number.PIC18F6X8X.PLCC = . PGM, Pin Number.PIC18F8X8X.TQFP = . PGM, Pin Type. = . PGM, Buffer Type. = . PGM, Description. = Low-Voltage ICSP Programming enable pin.. RB6/KBI2/PGC, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.TQFP = 42. RB6/KBI2/PGC, Pin Number.PIC18F6X8X.PLCC = 54. RB6/KBI2/PGC, Pin Number.PIC18F8X8X.TQFP = 52. RB6/KBI2/PGC, Pin Type. = . RB6/KBI2/PGC, Buffer Type. = . RB6/KBI2/PGC, Description. = . RB6, Pin Number.PIC18F6X8X.TQFP = . RB6, Pin Number.PIC18F6X8X.PLCC = . RB6, Pin Number.PIC18F8X8X.TQFP = . RB6, Pin Type. = I/O. RB6, Buffer Type. = TTL. RB6, Description. = Digital I/O.. KBI2, Pin Number.PIC18F6X8X.TQFP = . KBI2, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.PLCC = . KBI2, Pin Number.PIC18F8X8X.TQFP = . KBI2, Pin Type. = I. KBI2, Buffer Type. = ST. KBI2, Description. = Interrupt-on-change pin.. PGC, Pin Number.PIC18F6X8X.TQFP = . PGC, Pin Number.PIC18F6X8X.PLCC = . PGC, Pin Number.PIC18F8X8X.TQFP = . PGC, Pin Type. = I/O. PGC, Buffer Type. = . PGC, Description. = In-circuit debugger and ICSP. , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC = . , Pin Number.PIC18F8X8X.TQFP = . , Pin Type. = . , Buffer Type. = ST. , Description. = programming clock..",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRB7/KBI3/PGD, Pin Number.PIC18F6X8X.TQFP = 37. RB7/KBI3/PGD, Pin Number.PIC18F6X8X.PLCC = 48. RB7/KBI3/PGD, Pin Number.PIC18F8X8X.TQFP = 47. RB7/KBI3/PGD, Pin Type. = . RB7/KBI3/PGD, Buffer Type. = . RB7/KBI3/PGD, Description. = . RB7, Pin Number.PIC18F6X8X.TQFP = . RB7, Pin Number.PIC18F6X8X.PLCC = . RB7, Pin Number.PIC18F8X8X.TQFP = . RB7, Pin Type. = I/O. RB7, Buffer Type. = TTL. RB7, Description. = Digital I/O.. KBI3, Pin Number.PIC18F6X8X.TQFP = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nKBI3, Pin Number.PIC18F6X8X.PLCC = . KBI3, Pin Number.PIC18F8X8X.TQFP = . KBI3, Pin Type. = I/O. KBI3, Buffer Type. = ST. KBI3, Description. = Interrupt-on-change pin.. PGD, Pin Number.PIC18F6X8X.TQFP = . PGD, Pin Number.PIC18F6X8X.PLCC = . PGD, Pin Number.PIC18F8X8X.TQFP = . PGD, Pin Type. = . PGD, Buffer Type. = . PGD, Description. = In-circuit debugger and ICSP programming data.\nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST\n=  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNote 1: Alternate assignment for CCP2 in all operating modes except Microcontroller - applies to PIC18F8X8X only.\n2: Default assignment when CCP2MX is set.\n3: External memory interface functions are only available on PIC18F8X8X devices.\n4: CCP2 is multiplexed with this pin by default when configured in Microcontroller mode; otherwise, it is multiplexed with either RB3 or RC1.\n5: PORTH and PORTJ are only available on PIC18F8X8X (80-pin) devices.\n6: PSP is available in Microcontroller mode only.\n7: On PIC18F8X8X devices, these pins can be multiplexed with RH7/RH6 by changing the ECCPMX configuration bit.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC0/T1OSO/T13CKI, Pin Number.PIC18F6X8X.TQFP = 30. RC0/T1OSO/T13CKI, Pin Number.PIC18F6X8X.PLCC = 41. RC0/T1OSO/T13CKI, Pin Number.PIC18F8X8X.TQFP = 36. RC0/T1OSO/T13CKI, Pin Type. = . RC0/T1OSO/T13CKI, Buffer Type. = . RC0/T1OSO/T13CKI, Description. = . RC0, Pin Number.PIC18F6X8X.TQFP = . RC0, Pin Number.PIC18F6X8X.PLCC = . RC0, Pin Number.PIC18F8X8X.TQFP = . RC0, Pin Type. = I/O. RC0, Buffer Type. = ST. RC0, Description. = Digital I/O.. T1OSO, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.TQFP = . T1OSO, Pin Number.PIC18F6X8X.PLCC = . T1OSO, Pin Number.PIC18F8X8X.TQFP = . T1OSO, Pin Type. = O. T1OSO, Buffer Type. = -. T1OSO, Description. = Timer1 oscillator output.. T13CKI, Pin Number.PIC18F6X8X.TQFP = . T13CKI, Pin Number.PIC18F6X8X.PLCC = . T13CKI, Pin Number.PIC18F8X8X.TQFP = . T13CKI, Pin Type. = I. T13CKI, Buffer Type. = ST. T13CKI, Description. = Timer1/Timer3 external clock input.. RC1/T1OSI/CCP2, Pin Number.PIC18F6X8X.TQFP = 29. RC1/T1OSI/CCP2, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.PLCC = 40. RC1/T1OSI/CCP2, Pin Number.PIC18F8X8X.TQFP = 35. RC1/T1OSI/CCP2, Pin Type. = . RC1/T1OSI/CCP2, Buffer Type. = . RC1/T1OSI/CCP2, Description. = . RC1, Pin Number.PIC18F6X8X.TQFP = . RC1, Pin Number.PIC18F6X8X.PLCC = . RC1, Pin Number.PIC18F8X8X.TQFP = . RC1, Pin Type. = I/O. RC1, Buffer Type. = ST. RC1, Description. = Digital I/O.. T1OSI, Pin Number.PIC18F6X8X.TQFP = . T1OSI, Pin Number.PIC18F6X8X.PLCC = . T1OSI, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F8X8X.TQFP = . T1OSI, Pin Type. = I. T1OSI, Buffer Type. = CMOS. T1OSI, Description. = Timer1 oscillator input.. CCP2 (1, 4), Pin Number.PIC18F6X8X.TQFP = . CCP2 (1, 4), Pin Number.PIC18F6X8X.PLCC = . CCP2 (1, 4), Pin Number.PIC18F8X8X.TQFP = . CCP2 (1, 4), Pin Type. = I/O. CCP2 (1, 4), Buffer Type. = ST. CCP2 (1, 4), Description. = CCP2 Capture input/Compare. , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC = . , Pin Number.PIC18F8X8X.TQFP = . , Pin Type. =",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n. , Buffer Type. = . , Description. = PWM 2 output.. RC2/CCP1/P1A, Pin Number.PIC18F6X8X.TQFP = 33. RC2/CCP1/P1A, Pin Number.PIC18F6X8X.PLCC = 44. RC2/CCP1/P1A, Pin Number.PIC18F8X8X.TQFP = 43. RC2/CCP1/P1A, Pin Type. = . RC2/CCP1/P1A, Buffer Type. = . RC2/CCP1/P1A, Description. = . RC2, Pin Number.PIC18F6X8X.TQFP = . RC2, Pin Number.PIC18F6X8X.PLCC = . RC2, Pin Number.PIC18F8X8X.TQFP = . RC2, Pin Type. = I/O. RC2, Buffer Type. = ST. RC2, Description. = Digital",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nI/O.. CCP1, Pin Number.PIC18F6X8X.TQFP = . CCP1, Pin Number.PIC18F6X8X.PLCC = . CCP1, Pin Number.PIC18F8X8X.TQFP = . CCP1, Pin Type. = I/O. CCP1, Buffer Type. = ST. CCP1, Description. = CCP1 Capture input/Compare output.. P1A, Pin Number.PIC18F6X8X.TQFP = . P1A, Pin Number.PIC18F6X8X.PLCC = . P1A, Pin Number.PIC18F8X8X.TQFP = . P1A, Pin Type. = I/O. P1A, Buffer Type. = ST. P1A, Description. = CCP1 PWM output A.. RC3/SCK/SCL, Pin Number.PIC18F6X8X.TQFP = 34.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC3/SCK/SCL, Pin Number.PIC18F6X8X.PLCC = 45. RC3/SCK/SCL, Pin Number.PIC18F8X8X.TQFP = 44. RC3/SCK/SCL, Pin Type. = . RC3/SCK/SCL, Buffer Type. = . RC3/SCK/SCL, Description. = . RC3, Pin Number.PIC18F6X8X.TQFP = . RC3, Pin Number.PIC18F6X8X.PLCC = . RC3, Pin Number.PIC18F8X8X.TQFP = . RC3, Pin Type. = I/O. RC3, Buffer Type. = ST. RC3, Description. = Digital I/O.. SCK, Pin Number.PIC18F6X8X.TQFP = . SCK, Pin Number.PIC18F6X8X.PLCC = . SCK, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F8X8X.TQFP = . SCK, Pin Type. = I/O. SCK, Buffer Type. = ST. SCK, Description. = Synchronous serial clock input/output for SPI mode.. SCL, Pin Number.PIC18F6X8X.TQFP = . SCL, Pin Number.PIC18F6X8X.PLCC = . SCL, Pin Number.PIC18F8X8X.TQFP = . SCL, Pin Type. = I/O. SCL, Buffer Type. = ST. SCL, Description. = Synchronous serial clock input/output 2. , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC = . , Pin Number.PIC18F8X8X.TQFP = . , Pin Type. = . , Buffer Type. = . , Description. = for I C mode.. RC4/SDI/SDA, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.TQFP = 35. RC4/SDI/SDA, Pin Number.PIC18F6X8X.PLCC = 46. RC4/SDI/SDA, Pin Number.PIC18F8X8X.TQFP = 45. RC4/SDI/SDA, Pin Type. = . RC4/SDI/SDA, Buffer Type. = . RC4/SDI/SDA, Description. = . RC4, Pin Number.PIC18F6X8X.TQFP = . RC4, Pin Number.PIC18F6X8X.PLCC = . RC4, Pin Number.PIC18F8X8X.TQFP = . RC4, Pin Type. = I/O. RC4, Buffer Type. = ST. RC4, Description. = Digital I/O.. SDI, Pin Number.PIC18F6X8X.TQFP = . SDI, Pin Number.PIC18F6X8X.PLCC = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nSDI, Pin Number.PIC18F8X8X.TQFP = . SDI, Pin Type. = I. SDI, Buffer Type. = ST. SDI, Description. = SPI data in.. SDA, Pin Number.PIC18F6X8X.TQFP = . SDA, Pin Number.PIC18F6X8X.PLCC = . SDA, Pin Number.PIC18F8X8X.TQFP = . SDA, Pin Type. = I/O. SDA, Buffer Type. = ST. SDA, Description. = I 2 C data I/O.. RC5/SDO, Pin Number.PIC18F6X8X.TQFP = 36. RC5/SDO, Pin Number.PIC18F6X8X.PLCC = 47. RC5/SDO, Pin Number.PIC18F8X8X.TQFP = 46. RC5/SDO, Pin Type. = . RC5/SDO, Buffer Type. = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC5/SDO, Description. = . RC5, Pin Number.PIC18F6X8X.TQFP = . RC5, Pin Number.PIC18F6X8X.PLCC = . RC5, Pin Number.PIC18F8X8X.TQFP = . RC5, Pin Type. = I/O. RC5, Buffer Type. = ST. RC5, Description. = Digital I/O.. SDO, Pin Number.PIC18F6X8X.TQFP = . SDO, Pin Number.PIC18F6X8X.PLCC = . SDO, Pin Number.PIC18F8X8X.TQFP = . SDO, Pin Type. = O. SDO, Buffer Type. = -. SDO, Description. = SPI data out.. RC6/TX/CK, Pin Number.PIC18F6X8X.TQFP = 31. RC6/TX/CK, Pin Number.PIC18F6X8X.PLCC = 42.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRC6/TX/CK, Pin Number.PIC18F8X8X.TQFP = 37. RC6/TX/CK, Pin Type. = . RC6/TX/CK, Buffer Type. = . RC6/TX/CK, Description. = . RC6, Pin Number.PIC18F6X8X.TQFP = . RC6, Pin Number.PIC18F6X8X.PLCC = . RC6, Pin Number.PIC18F8X8X.TQFP = . RC6, Pin Type. = I/O. RC6, Buffer Type. = ST. RC6, Description. = Digital I/O.. TX, Pin Number.PIC18F6X8X.TQFP = . TX, Pin Number.PIC18F6X8X.PLCC = . TX, Pin Number.PIC18F8X8X.TQFP = . TX, Pin Type. = O. TX, Buffer Type. = -. TX, Description. = USART asynchronous transmit.. CK,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nPin Number.PIC18F6X8X.TQFP = . CK, Pin Number.PIC18F6X8X.PLCC = . CK, Pin Number.PIC18F8X8X.TQFP = . CK, Pin Type. = I/O. CK, Buffer Type. = ST. CK, Description. = USART synchronous clock (see RX/DT).. RC7/RX/DT, Pin Number.PIC18F6X8X.TQFP = 32. RC7/RX/DT, Pin Number.PIC18F6X8X.PLCC = 43. RC7/RX/DT, Pin Number.PIC18F8X8X.TQFP = 38. RC7/RX/DT, Pin Type. = . RC7/RX/DT, Buffer Type. = . RC7/RX/DT, Description. = . RC7, Pin Number.PIC18F6X8X.TQFP = . RC7, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.PLCC = . RC7, Pin Number.PIC18F8X8X.TQFP = . RC7, Pin Type. = I/O. RC7, Buffer Type. = ST. RC7, Description. = Digital I/O.. RX, Pin Number.PIC18F6X8X.TQFP = . RX, Pin Number.PIC18F6X8X.PLCC = . RX, Pin Number.PIC18F8X8X.TQFP = . RX, Pin Type. = I. RX, Buffer Type. = ST. RX, Description. = USART 1 asynchronous receive.. DT, Pin Number.PIC18F6X8X.TQFP = . DT, Pin Number.PIC18F6X8X.PLCC = . DT, Pin Number.PIC18F8X8X.TQFP = . DT, Pin Type. = I/O. DT, Buffer Type. = ST. DT, Description. =",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nUSART 1 synchronous data (see TX/CK).\nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST\n=  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP\n=  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n1: Alternate assignment for CCP2 in all operating modes except Microcontroller - applies to PIC18F8X8X only.\n2: Default assignment when CCP2MX is set.\n3: External memory interface functions are only available on PIC18F8X8X devices.\n4: CCP2 is multiplexed with this pin by default when configured in Microcontroller mode; otherwise, it is multiplexed with either RB3 or RC1.\n5: PORTH and PORTJ are only available on PIC18F8X8X (80-pin) devices.\n6: PSP is available in Microcontroller mode only.\n7: On PIC18F8X8X devices, these pins can be multiplexed with RH7/RH6 by changing the ECCPMX configuration bit.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD0/PSP0/AD0, Pin Number.PIC18F6X8X.TQFP = 58. RD0/PSP0/AD0, Pin Number.PIC18F6X8X.PLCC = 3. RD0/PSP0/AD0, Pin Number.PIC18F8X8X.TQFP = 72. RD0/PSP0/AD0, Pin Type. = . RD0/PSP0/AD0, Buffer Type. = . RD0/PSP0/AD0, Description. = . RD0, Pin Number.PIC18F6X8X.TQFP = . RD0, Pin Number.PIC18F6X8X.PLCC = . RD0, Pin Number.PIC18F8X8X.TQFP = . RD0, Pin Type. = I/O. RD0, Buffer Type. = ST. RD0, Description. = Digital I/O.. PSP0 (6), Pin Number.PIC18F6X8X.TQFP",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= . PSP0 (6), Pin Number.PIC18F6X8X.PLCC = . PSP0 (6), Pin Number.PIC18F8X8X.TQFP = . PSP0 (6), Pin Type. = I/O. PSP0 (6), Buffer Type. = TTL. PSP0 (6), Description. = Parallel Slave Port data.. AD0 (3), Pin Number.PIC18F6X8X.TQFP = . AD0 (3), Pin Number.PIC18F6X8X.PLCC = . AD0 (3), Pin Number.PIC18F8X8X.TQFP = . AD0 (3), Pin Type. = I/O. AD0 (3), Buffer Type. = TTL. AD0 (3), Description. = External memory address/data 0.. RD1/PSP1/AD1, Pin Number.PIC18F6X8X.TQFP = 55.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD1/PSP1/AD1, Pin Number.PIC18F6X8X.PLCC = 67. RD1/PSP1/AD1, Pin Number.PIC18F8X8X.TQFP = 69. RD1/PSP1/AD1, Pin Type. = . RD1/PSP1/AD1, Buffer Type. = . RD1/PSP1/AD1, Description. = . RD1, Pin Number.PIC18F6X8X.TQFP = . RD1, Pin Number.PIC18F6X8X.PLCC = . RD1, Pin Number.PIC18F8X8X.TQFP = . RD1, Pin Type. = I/O. RD1, Buffer Type. = ST. RD1, Description. = Digital I/O.. PSP1 (6), Pin Number.PIC18F6X8X.TQFP = . PSP1 (6), Pin Number.PIC18F6X8X.PLCC = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nPSP1 (6), Pin Number.PIC18F8X8X.TQFP = . PSP1 (6), Pin Type. = I/O. PSP1 (6), Buffer Type. = TTL. PSP1 (6), Description. = Parallel Slave Port data.. AD1 (3), Pin Number.PIC18F6X8X.TQFP = . AD1 (3), Pin Number.PIC18F6X8X.PLCC = . AD1 (3), Pin Number.PIC18F8X8X.TQFP = . AD1 (3), Pin Type. = I/O. AD1 (3), Buffer Type. = TTL. AD1 (3), Description. = External memory address/data 1.. RD2/PSP2/AD2, Pin Number.PIC18F6X8X.TQFP = 54. RD2/PSP2/AD2, Pin Number.PIC18F6X8X.PLCC = 66.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD2/PSP2/AD2, Pin Number.PIC18F8X8X.TQFP = 68. RD2/PSP2/AD2, Pin Type. = . RD2/PSP2/AD2, Buffer Type. = . RD2/PSP2/AD2, Description. = . RD2, Pin Number.PIC18F6X8X.TQFP = . RD2, Pin Number.PIC18F6X8X.PLCC = . RD2, Pin Number.PIC18F8X8X.TQFP = . RD2, Pin Type. = I/O. RD2, Buffer Type. = ST. RD2, Description. = Digital I/O.. PSP2 (6), Pin Number.PIC18F6X8X.TQFP = . PSP2 (6), Pin Number.PIC18F6X8X.PLCC = . PSP2 (6), Pin Number.PIC18F8X8X.TQFP = . PSP2",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n(6), Pin Type. = I/O. PSP2 (6), Buffer Type. = TTL. PSP2 (6), Description. = Parallel Slave Port data.. AD2 (3), Pin Number.PIC18F6X8X.TQFP = . AD2 (3), Pin Number.PIC18F6X8X.PLCC = . AD2 (3), Pin Number.PIC18F8X8X.TQFP = . AD2 (3), Pin Type. = I/O. AD2 (3), Buffer Type. = TTL. AD2 (3), Description. = External memory address/data 2.. RD3/PSP3/AD3, Pin Number.PIC18F6X8X.TQFP = 53. RD3/PSP3/AD3, Pin Number.PIC18F6X8X.PLCC = 65. RD3/PSP3/AD3, Pin Number.PIC18F8X8X.TQFP = 67.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD3/PSP3/AD3, Pin Type. = . RD3/PSP3/AD3, Buffer Type. = . RD3/PSP3/AD3, Description. = . RD3, Pin Number.PIC18F6X8X.TQFP = . RD3, Pin Number.PIC18F6X8X.PLCC = . RD3, Pin Number.PIC18F8X8X.TQFP = . RD3, Pin Type. = I/O. RD3, Buffer Type. = ST. RD3, Description. = Digital I/O.. PSP3 (6), Pin Number.PIC18F6X8X.TQFP = . PSP3 (6), Pin Number.PIC18F6X8X.PLCC = . PSP3 (6), Pin Number.PIC18F8X8X.TQFP = . PSP3 (6), Pin Type. = I/O. PSP3 (6), Buffer Type. = TTL. PSP3",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n(6), Description. = Parallel Slave Port data.. AD3 (3), Pin Number.PIC18F6X8X.TQFP = . AD3 (3), Pin Number.PIC18F6X8X.PLCC = . AD3 (3), Pin Number.PIC18F8X8X.TQFP = . AD3 (3), Pin Type. = I/O. AD3 (3), Buffer Type. = TTL. AD3 (3), Description. = External memory address/data 3.. RD4/PSP4/AD4, Pin Number.PIC18F6X8X.TQFP = 52. RD4/PSP4/AD4, Pin Number.PIC18F6X8X.PLCC = 64. RD4/PSP4/AD4, Pin Number.PIC18F8X8X.TQFP = 66. RD4/PSP4/AD4, Pin Type. = . RD4/PSP4/AD4, Buffer Type. = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD4/PSP4/AD4, Description. = . RD4, Pin Number.PIC18F6X8X.TQFP = . RD4, Pin Number.PIC18F6X8X.PLCC = . RD4, Pin Number.PIC18F8X8X.TQFP = . RD4, Pin Type. = I/O. RD4, Buffer Type. = ST. RD4, Description. = Digital I/O.. PSP4 (6), Pin Number.PIC18F6X8X.TQFP = . PSP4 (6), Pin Number.PIC18F6X8X.PLCC = . PSP4 (6), Pin Number.PIC18F8X8X.TQFP = . PSP4 (6), Pin Type. = I/O. PSP4 (6), Buffer Type. = TTL. PSP4 (6), Description. = Parallel Slave Port data.. AD4 (3), Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.TQFP = . AD4 (3), Pin Number.PIC18F6X8X.PLCC = . AD4 (3), Pin Number.PIC18F8X8X.TQFP = . AD4 (3), Pin Type. = I/O. AD4 (3), Buffer Type. = TTL. AD4 (3), Description. = External memory address/data 4.. RD5/PSP5/AD5, Pin Number.PIC18F6X8X.TQFP = 51. RD5/PSP5/AD5, Pin Number.PIC18F6X8X.PLCC = 63. RD5/PSP5/AD5, Pin Number.PIC18F8X8X.TQFP = 65. RD5/PSP5/AD5, Pin Type. = . RD5/PSP5/AD5, Buffer Type. = . RD5/PSP5/AD5, Description. = . RD5, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.TQFP = . RD5, Pin Number.PIC18F6X8X.PLCC = . RD5, Pin Number.PIC18F8X8X.TQFP = . RD5, Pin Type. = I/O. RD5, Buffer Type. = ST. RD5, Description. = Digital I/O.. PSP5 (6), Pin Number.PIC18F6X8X.TQFP = . PSP5 (6), Pin Number.PIC18F6X8X.PLCC = . PSP5 (6), Pin Number.PIC18F8X8X.TQFP = . PSP5 (6), Pin Type. = I/O. PSP5 (6), Buffer Type. = TTL. PSP5 (6), Description. = Parallel Slave Port data.. AD5 (3), Pin Number.PIC18F6X8X.TQFP = . AD5 (3), Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.PLCC = . AD5 (3), Pin Number.PIC18F8X8X.TQFP = . AD5 (3), Pin Type. = I/O. AD5 (3), Buffer Type. = TTL. AD5 (3), Description. = External memory address/data 5.. RD6/PSP6/AD6, Pin Number.PIC18F6X8X.TQFP = 50. RD6/PSP6/AD6, Pin Number.PIC18F6X8X.PLCC = 62. RD6/PSP6/AD6, Pin Number.PIC18F8X8X.TQFP = 64. RD6/PSP6/AD6, Pin Type. = . RD6/PSP6/AD6, Buffer Type. = . RD6/PSP6/AD6, Description. = . RD6, Pin Number.PIC18F6X8X.TQFP = . RD6, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.PLCC = . RD6, Pin Number.PIC18F8X8X.TQFP = . RD6, Pin Type. = I/O. RD6, Buffer Type. = ST. RD6, Description. = Digital I/O.. PSP6 (6), Pin Number.PIC18F6X8X.TQFP = . PSP6 (6), Pin Number.PIC18F6X8X.PLCC = . PSP6 (6), Pin Number.PIC18F8X8X.TQFP = . PSP6 (6), Pin Type. = I/O. PSP6 (6), Buffer Type. = TTL. PSP6 (6), Description. = Parallel Slave Port data.. AD6 (3), Pin Number.PIC18F6X8X.TQFP = . AD6 (3), Pin Number.PIC18F6X8X.PLCC = . AD6 (3), Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F8X8X.TQFP = . AD6 (3), Pin Type. = I/O. AD6 (3), Buffer Type. = TTL. AD6 (3), Description. = External memory address/data 6.. RD7/PSP7/AD7, Pin Number.PIC18F6X8X.TQFP = 49. RD7/PSP7/AD7, Pin Number.PIC18F6X8X.PLCC = 61. RD7/PSP7/AD7, Pin Number.PIC18F8X8X.TQFP = 63. RD7/PSP7/AD7, Pin Type. = . RD7/PSP7/AD7, Buffer Type. = . RD7/PSP7/AD7, Description. = . RD7, Pin Number.PIC18F6X8X.TQFP = . RD7, Pin Number.PIC18F6X8X.PLCC = . RD7, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F8X8X.TQFP = . RD7, Pin Type. = I/O. RD7, Buffer Type. = ST. RD7, Description. = Digital I/O.. PSP7 (6), Pin Number.PIC18F6X8X.TQFP = . PSP7 (6), Pin Number.PIC18F6X8X.PLCC = . PSP7 (6), Pin Number.PIC18F8X8X.TQFP = . PSP7 (6), Pin Type. = I/O. PSP7 (6), Buffer Type. = TTL. PSP7 (6), Description. = Parallel Slave Port data.. AD7 (3), Pin Number.PIC18F6X8X.TQFP = . AD7 (3), Pin Number.PIC18F6X8X.PLCC = . AD7 (3), Pin Number.PIC18F8X8X.TQFP = . AD7 (3), Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nType. = I/O. AD7 (3), Buffer Type. = TTL. AD7 (3), Description. = External memory address/data 7.\nLegend:\nTTL\n=  TTL compatible input\nST\n=  Schmitt Trigger input with CMOS levels\nI\n=  Input\nP =  Power\nCMOS\n- =  CMOS compatible input or output\nAnalog\nO\n=  Analog input\n=  Output\nOD\n- =  Open-Drain (no P diode to VDD)\nNote 1: Alternate assignment for CCP2 in all operating modes except Microcontroller - applies to PIC18F8X8X only.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n2: Default assignment when CCP2MX is set.\n3: External memory interface functions are only available on PIC18F8X8X devices.\n4: CCP2 is multiplexed with this pin by default when configured in Microcontroller mode; otherwise, it is multiplexed with either RB3 or RC1.\n5: PORTH and PORTJ are only available on PIC18F8X8X (80-pin) devices.\n6: PSP is available in Microcontroller mode only.\n7: On PIC18F8X8X devices, these pins can be multiplexed with RH7/RH6 by changing the ECCPMX configuration bit.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRE0/RD/AD8, Pin Number.PIC18F6X8X.TQFP = 2. RE0/RD/AD8, Pin Number.PIC18F6X8X.PLCC = 11. RE0/RD/AD8, Pin Number.PIC18F8X8X.TQFP = 4. RE0/RD/AD8, Pin Type. = . RE0/RD/AD8, Buffer Type. = . RE0/RD/AD8, Description. = PORTE is a bidirectional I/O port.. RE0, Pin Number.PIC18F6X8X.TQFP = . RE0, Pin Number.PIC18F6X8X.PLCC = . RE0, Pin Number.PIC18F8X8X.TQFP = . RE0, Pin Type. = I/O. RE0, Buffer Type. = ST. RE0, Description. = Digital I/O.. RD (6), Pin Number.PIC18F6X8X.TQFP = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRD (6), Pin Number.PIC18F6X8X.PLCC = . RD (6), Pin Number.PIC18F8X8X.TQFP = . RD (6), Pin Type. = I. RD (6), Buffer Type. = TTL. RD (6), Description. = Read control for Parallel Slave Port (see WR and CS pins).. AD8 (3), Pin Number.PIC18F6X8X.TQFP = . AD8 (3), Pin Number.PIC18F6X8X.PLCC = . AD8 (3), Pin Number.PIC18F8X8X.TQFP = . AD8 (3), Pin Type. = I/O. AD8 (3), Buffer Type. = TTL. AD8 (3), Description. = External memory address/data 8.. RE1/WR/AD9, Pin Number.PIC18F6X8X.TQFP = 1. RE1/WR/AD9, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.PLCC = 10. RE1/WR/AD9, Pin Number.PIC18F8X8X.TQFP = 3. RE1/WR/AD9, Pin Type. = . RE1/WR/AD9, Buffer Type. = . RE1/WR/AD9, Description. = . RE1, Pin Number.PIC18F6X8X.TQFP = . RE1, Pin Number.PIC18F6X8X.PLCC = . RE1, Pin Number.PIC18F8X8X.TQFP = . RE1, Pin Type. = I/O. RE1, Buffer Type. = ST. RE1, Description. = Digital I/O.. WR (6), Pin Number.PIC18F6X8X.TQFP = . WR (6), Pin Number.PIC18F6X8X.PLCC = . WR (6), Pin Number.PIC18F8X8X.TQFP = . WR (6),",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nPin Type. = I. WR (6), Buffer Type. = TTL. WR (6), Description. = Write control for Parallel Slave Port (see CS and RD pins).. AD9 (3), Pin Number.PIC18F6X8X.TQFP = . AD9 (3), Pin Number.PIC18F6X8X.PLCC = . AD9 (3), Pin Number.PIC18F8X8X.TQFP = . AD9 (3), Pin Type. = . AD9 (3), Buffer Type. = TTL. AD9 (3), Description. = External memory address/data. , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC = . , Pin Number.PIC18F8X8X.TQFP = . , Pin Type. = I/O. , Buffer Type. = . , Description. = 9.. RE2/CS/AD10, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.TQFP = 64. RE2/CS/AD10, Pin Number.PIC18F6X8X.PLCC = 9. RE2/CS/AD10, Pin Number.PIC18F8X8X.TQFP = 78. RE2/CS/AD10, Pin Type. = . RE2/CS/AD10, Buffer Type. = . RE2/CS/AD10, Description. = . RE2, Pin Number.PIC18F6X8X.TQFP = . RE2, Pin Number.PIC18F6X8X.PLCC = . RE2, Pin Number.PIC18F8X8X.TQFP = . RE2, Pin Type. = I/O. RE2, Buffer Type. = ST. RE2, Description. = Digital I/O.. CS (6), Pin Number.PIC18F6X8X.TQFP = . CS (6), Pin Number.PIC18F6X8X.PLCC = . CS",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n(6), Pin Number.PIC18F8X8X.TQFP = . CS (6), Pin Type. = I. CS (6), Buffer Type. = TTL. CS (6), Description. = Chip select control for Parallel Slave Port (see RD and WR).. AD10 (3), Pin Number.PIC18F6X8X.TQFP = . AD10 (3), Pin Number.PIC18F6X8X.PLCC = . AD10 (3), Pin Number.PIC18F8X8X.TQFP = . AD10 (3), Pin Type. = I/O. AD10 (3), Buffer Type. = TTL. AD10 (3), Description. = External memory address/data 10.. RE3/AD11, Pin Number.PIC18F6X8X.TQFP = 63. RE3/AD11, Pin Number.PIC18F6X8X.PLCC = 8. RE3/AD11, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F8X8X.TQFP = 77. RE3/AD11, Pin Type. = . RE3/AD11, Buffer Type. = . RE3/AD11, Description. = . RE3, Pin Number.PIC18F6X8X.TQFP = . RE3, Pin Number.PIC18F6X8X.PLCC = . RE3, Pin Number.PIC18F8X8X.TQFP = . RE3, Pin Type. = I/O. RE3, Buffer Type. = ST. RE3, Description. = Digital I/O.. AD11 (3), Pin Number.PIC18F6X8X.TQFP = . AD11 (3), Pin Number.PIC18F6X8X.PLCC = . AD11 (3), Pin Number.PIC18F8X8X.TQFP = . AD11 (3), Pin Type. = I/O. AD11 (3), Buffer Type. = TTL. AD11",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n(3), Description. = External memory address/data 11.. RE4/AD12, Pin Number.PIC18F6X8X.TQFP = 62. RE4/AD12, Pin Number.PIC18F6X8X.PLCC = 7. RE4/AD12, Pin Number.PIC18F8X8X.TQFP = 76. RE4/AD12, Pin Type. = . RE4/AD12, Buffer Type. = ST. RE4/AD12, Description. = . , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC = . , Pin Number.PIC18F8X8X.TQFP = . , Pin Type. = I/O. , Buffer Type. = . , Description. = Digital I/O.. RE4 AD12 (3), Pin Number.PIC18F6X8X.TQFP = . RE4 AD12 (3), Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.PLCC = . RE4 AD12 (3), Pin Number.PIC18F8X8X.TQFP = . RE4 AD12 (3), Pin Type. = I/O. RE4 AD12 (3), Buffer Type. = TTL. RE4 AD12 (3), Description. = External memory address/data 12.. RE5/AD13/P1C, Pin Number.PIC18F6X8X.TQFP = 61. RE5/AD13/P1C, Pin Number.PIC18F6X8X.PLCC = 6. RE5/AD13/P1C, Pin Number.PIC18F8X8X.TQFP = 75. RE5/AD13/P1C, Pin Type. = . RE5/AD13/P1C, Buffer Type. = . RE5/AD13/P1C, Description. = . RE5, Pin Number.PIC18F6X8X.TQFP = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRE5, Pin Number.PIC18F6X8X.PLCC = . RE5, Pin Number.PIC18F8X8X.TQFP = . RE5, Pin Type. = I/O. RE5, Buffer Type. = ST. RE5, Description. = Digital I/O.. AD13 (3), Pin Number.PIC18F6X8X.TQFP = . AD13 (3), Pin Number.PIC18F6X8X.PLCC = . AD13 (3), Pin Number.PIC18F8X8X.TQFP = . AD13 (3), Pin Type. = I/O. AD13 (3), Buffer Type. = TTL. AD13 (3), Description. = External memory address/data 13.. P1C (7), Pin Number.PIC18F6X8X.TQFP = . P1C (7), Pin Number.PIC18F6X8X.PLCC = . P1C (7), Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F8X8X.TQFP = . P1C (7), Pin Type. = I/O. P1C (7), Buffer Type. = ST. P1C (7), Description. = ECCP1 PWM output C.. RE6/AD14/P1B, Pin Number.PIC18F6X8X.TQFP = . RE6/AD14/P1B, Pin Number.PIC18F6X8X.PLCC = . RE6/AD14/P1B, Pin Number.PIC18F8X8X.TQFP = . RE6/AD14/P1B, Pin Type. = . RE6/AD14/P1B, Buffer Type. = . RE6/AD14/P1B, Description. = . , Pin Number.PIC18F6X8X.TQFP = 60. , Pin Number.PIC18F6X8X.PLCC = 5. , Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F8X8X.TQFP = 74. , Pin Type. = . , Buffer Type. = . , Description. = . RE6, Pin Number.PIC18F6X8X.TQFP = . RE6, Pin Number.PIC18F6X8X.PLCC = . RE6, Pin Number.PIC18F8X8X.TQFP = . RE6, Pin Type. = I/O. RE6, Buffer Type. = ST. RE6, Description. = Digital I/O.. AD14 (3), Pin Number.PIC18F6X8X.TQFP = . AD14 (3), Pin Number.PIC18F6X8X.PLCC = . AD14 (3), Pin Number.PIC18F8X8X.TQFP = . AD14 (3), Pin Type. = I/O. AD14 (3), Buffer Type. = TTL. AD14 (3), Description. = External memory address/data 14.. P1B",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n(7), Pin Number.PIC18F6X8X.TQFP = . P1B (7), Pin Number.PIC18F6X8X.PLCC = . P1B (7), Pin Number.PIC18F8X8X.TQFP = . P1B (7), Pin Type. = I/O. P1B (7), Buffer Type. = ST. P1B (7), Description. = ECCP1 PWM output B.. RE7/CCP2/AD15, Pin Number.PIC18F6X8X.TQFP = 59. RE7/CCP2/AD15, Pin Number.PIC18F6X8X.PLCC = 4. RE7/CCP2/AD15, Pin Number.PIC18F8X8X.TQFP = 73. RE7/CCP2/AD15, Pin Type. = . RE7/CCP2/AD15, Buffer Type. = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRE7/CCP2/AD15, Description. = . RE7, Pin Number.PIC18F6X8X.TQFP = . RE7, Pin Number.PIC18F6X8X.PLCC = . RE7, Pin Number.PIC18F8X8X.TQFP = . RE7, Pin Type. = I/O. RE7, Buffer Type. = ST. RE7, Description. = Digital I/O.. CCP2 (1,4), Pin Number.PIC18F6X8X.TQFP = . CCP2 (1,4), Pin Number.PIC18F6X8X.PLCC = . CCP2 (1,4), Pin Number.PIC18F8X8X.TQFP = . CCP2 (1,4), Pin Type. = I/O. CCP2 (1,4), Buffer Type. = ST. CCP2 (1,4), Description. = Capture 2 input/Compare 2 output/ PWM 2",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\noutput.. AD15 (3), Pin Number.PIC18F6X8X.TQFP = . AD15 (3), Pin Number.PIC18F6X8X.PLCC = . AD15 (3), Pin Number.PIC18F8X8X.TQFP = . AD15 (3), Pin Type. = I/O. AD15 (3), Buffer Type. = TTL. AD15 (3), Description. = External memory address/data 15.\nLegend:\nTTL\n=  TTL compatible input\nST\n=  Schmitt Trigger input with CMOS levels\nI\n=  Input\nP =  Power\nCMOS\n=  CMOS compatible input or output\nAnalog\n=  Analog input\nO\n=  Output\nOD\n=  Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNote 1: Alternate assignment for CCP2 in all operating modes except Microcontroller - applies to PIC18F8X8X only.\n2: Default assignment when CCP2MX is set.\n3: External memory interface functions are only available on PIC18F8X8X devices.\n4: CCP2 is multiplexed with this pin by default when configured in Microcontroller mode; otherwise, it is multiplexed with either RB3 or RC1.\n5: PORTH and PORTJ are only available on PIC18F8X8X (80-pin) devices.\n6: PSP is available in Microcontroller mode only.\n7: On PIC18F8X8X devices, these pins can be multiplexed with RH7/RH6 by changing the ECCPMX configuration bit.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRF0/AN5, Pin Number.PIC18F6X8X.TQFP = 18. RF0/AN5, Pin Number.PIC18F6X8X.PLCC = 28. RF0/AN5, Pin Number.PIC18F8X8X.TQFP = 24. RF0/AN5, Pin Type. = . RF0/AN5, Buffer Type. = . RF0/AN5, Description. = . RF0, Pin Number.PIC18F6X8X.TQFP = . RF0, Pin Number.PIC18F6X8X.PLCC = . RF0, Pin Number.PIC18F8X8X.TQFP = . RF0, Pin Type. = I/O. RF0, Buffer Type. = ST. RF0, Description. = Digital I/O.. AN5, Pin Number.PIC18F6X8X.TQFP = . AN5, Pin Number.PIC18F6X8X.PLCC = . AN5, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F8X8X.TQFP = . AN5, Pin Type. = I. AN5, Buffer Type. = Analog. AN5, Description. = Analog input 5.. RF1/AN6/C2OUT, Pin Number.PIC18F6X8X.TQFP = 17. RF1/AN6/C2OUT, Pin Number.PIC18F6X8X.PLCC = 27. RF1/AN6/C2OUT, Pin Number.PIC18F8X8X.TQFP = 23. RF1/AN6/C2OUT, Pin Type. = . RF1/AN6/C2OUT, Buffer Type. = . RF1/AN6/C2OUT, Description. = . RF1, Pin Number.PIC18F6X8X.TQFP = . RF1, Pin Number.PIC18F6X8X.PLCC = . RF1, Pin Number.PIC18F8X8X.TQFP = . RF1, Pin Type. = I/O. RF1, Buffer",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nType. = ST. RF1, Description. = Digital I/O.. AN6, Pin Number.PIC18F6X8X.TQFP = . AN6, Pin Number.PIC18F6X8X.PLCC = . AN6, Pin Number.PIC18F8X8X.TQFP = . AN6, Pin Type. = I. AN6, Buffer Type. = Analog. AN6, Description. = Analog input 6.. C2OUT, Pin Number.PIC18F6X8X.TQFP = . C2OUT, Pin Number.PIC18F6X8X.PLCC = . C2OUT, Pin Number.PIC18F8X8X.TQFP = . C2OUT, Pin Type. = O. C2OUT, Buffer Type. = ST. C2OUT, Description. = Comparator 2 output.. RF2/AN7/C1OUT, Pin Number.PIC18F6X8X.TQFP = 16. RF2/AN7/C1OUT, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.PLCC = 26. RF2/AN7/C1OUT, Pin Number.PIC18F8X8X.TQFP = 18. RF2/AN7/C1OUT, Pin Type. = . RF2/AN7/C1OUT, Buffer Type. = . RF2/AN7/C1OUT, Description. = . RF2, Pin Number.PIC18F6X8X.TQFP = . RF2, Pin Number.PIC18F6X8X.PLCC = . RF2, Pin Number.PIC18F8X8X.TQFP = . RF2, Pin Type. = I/O. RF2, Buffer Type. = ST. RF2, Description. = Digital I/O.. AN7, Pin Number.PIC18F6X8X.TQFP = . AN7, Pin Number.PIC18F6X8X.PLCC = . AN7, Pin Number.PIC18F8X8X.TQFP = . AN7, Pin Type. =",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nI. AN7, Buffer Type. = Analog. AN7, Description. = Analog input 7.. C1OUT, Pin Number.PIC18F6X8X.TQFP = . C1OUT, Pin Number.PIC18F6X8X.PLCC = . C1OUT, Pin Number.PIC18F8X8X.TQFP = . C1OUT, Pin Type. = O. C1OUT, Buffer Type. = ST. C1OUT, Description. = Comparator 1 output.. RF3/AN8/C2IN+, Pin Number.PIC18F6X8X.TQFP = 15. RF3/AN8/C2IN+, Pin Number.PIC18F6X8X.PLCC = 25. RF3/AN8/C2IN+, Pin Number.PIC18F8X8X.TQFP = 17. RF3/AN8/C2IN+, Pin Type. = . RF3/AN8/C2IN+, Buffer Type. = . RF3/AN8/C2IN+, Description. =",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n. RF1, Pin Number.PIC18F6X8X.TQFP = . RF1, Pin Number.PIC18F6X8X.PLCC = . RF1, Pin Number.PIC18F8X8X.TQFP = . RF1, Pin Type. = I/O. RF1, Buffer Type. = ST. RF1, Description. = Digital I/O.. AN8, Pin Number.PIC18F6X8X.TQFP = . AN8, Pin Number.PIC18F6X8X.PLCC = . AN8, Pin Number.PIC18F8X8X.TQFP = . AN8, Pin Type. = I. AN8, Buffer Type. = Analog. AN8, Description. = Analog input 8.. C2IN+, Pin Number.PIC18F6X8X.TQFP = . C2IN+, Pin Number.PIC18F6X8X.PLCC = . C2IN+, Pin Number.PIC18F8X8X.TQFP = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nC2IN+, Pin Type. = I. C2IN+, Buffer Type. = Analog. C2IN+, Description. = Comparator 2 input (+).. RF4/AN9/C2IN-, Pin Number.PIC18F6X8X.TQFP = 14. RF4/AN9/C2IN-, Pin Number.PIC18F6X8X.PLCC = 24. RF4/AN9/C2IN-, Pin Number.PIC18F8X8X.TQFP = 16. RF4/AN9/C2IN-, Pin Type. = . RF4/AN9/C2IN-, Buffer Type. = . RF4/AN9/C2IN-, Description. = . RF1, Pin Number.PIC18F6X8X.TQFP = . RF1, Pin Number.PIC18F6X8X.PLCC = . RF1, Pin Number.PIC18F8X8X.TQFP = . RF1, Pin Type. = I/O. RF1, Buffer",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nType. = ST. RF1, Description. = Digital I/O.. AN9, Pin Number.PIC18F6X8X.TQFP = . AN9, Pin Number.PIC18F6X8X.PLCC = . AN9, Pin Number.PIC18F8X8X.TQFP = . AN9, Pin Type. = I. AN9, Buffer Type. = Analog. AN9, Description. = Analog input 9.. C2IN-, Pin Number.PIC18F6X8X.TQFP = . C2IN-, Pin Number.PIC18F6X8X.PLCC = . C2IN-, Pin Number.PIC18F8X8X.TQFP = . C2IN-, Pin Type. = I. C2IN-, Buffer Type. = Analog. C2IN-, Description. = Comparator 2 input (-).. RF5/AN10/C1IN+/CVREF, Pin Number.PIC18F6X8X.TQFP = 13.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRF5/AN10/C1IN+/CVREF, Pin Number.PIC18F6X8X.PLCC = 23. RF5/AN10/C1IN+/CVREF, Pin Number.PIC18F8X8X.TQFP = 15. RF5/AN10/C1IN+/CVREF, Pin Type. = . RF5/AN10/C1IN+/CVREF, Buffer Type. = . RF5/AN10/C1IN+/CVREF, Description. = . RF1 AN10, Pin Number.PIC18F6X8X.TQFP = . RF1 AN10, Pin Number.PIC18F6X8X.PLCC = . RF1 AN10, Pin Number.PIC18F8X8X.TQFP = . RF1 AN10, Pin Type. = I/O. RF1 AN10, Buffer Type. = ST. RF1 AN10, Description. = Digital I/O.. C1IN+, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.TQFP = . C1IN+, Pin Number.PIC18F6X8X.PLCC = . C1IN+, Pin Number.PIC18F8X8X.TQFP = . C1IN+, Pin Type. = I. C1IN+, Buffer Type. = Analog. C1IN+, Description. = Analog input 10.. CVREF, Pin Number.PIC18F6X8X.TQFP = . CVREF, Pin Number.PIC18F6X8X.PLCC = . CVREF, Pin Number.PIC18F8X8X.TQFP = . CVREF, Pin Type. = I. CVREF, Buffer Type. = Analog. CVREF, Description. = Comparator 1 input (+).. , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC = . , Pin Number.PIC18F8X8X.TQFP = . , Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nType. = O. , Buffer Type. = Analog. , Description. = Comparator VREF output.. RF6/AN11/C1IN-, Pin Number.PIC18F6X8X.TQFP = 12. RF6/AN11/C1IN-, Pin Number.PIC18F6X8X.PLCC = 22. RF6/AN11/C1IN-, Pin Number.PIC18F8X8X.TQFP = 14. RF6/AN11/C1IN-, Pin Type. = . RF6/AN11/C1IN-, Buffer Type. = . RF6/AN11/C1IN-, Description. = . RF6, Pin Number.PIC18F6X8X.TQFP = . RF6, Pin Number.PIC18F6X8X.PLCC = . RF6, Pin Number.PIC18F8X8X.TQFP = . RF6, Pin Type. = I/O. RF6, Buffer Type. = ST. RF6, Description. = Digital",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nI/O.. AN11, Pin Number.PIC18F6X8X.TQFP = . AN11, Pin Number.PIC18F6X8X.PLCC = . AN11, Pin Number.PIC18F8X8X.TQFP = . AN11, Pin Type. = I. AN11, Buffer Type. = Analog. AN11, Description. = Analog input 11.. C1IN-, Pin Number.PIC18F6X8X.TQFP = . C1IN-, Pin Number.PIC18F6X8X.PLCC = . C1IN-, Pin Number.PIC18F8X8X.TQFP = . C1IN-, Pin Type. = . C1IN-, Buffer Type. = Analog. C1IN-, Description. = (-). , Pin Number.PIC18F6X8X.TQFP = 11. , Pin Number.PIC18F6X8X.PLCC = 21. , Pin Number.PIC18F8X8X.TQFP = 13. , Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nType. = I. , Buffer Type. = . , Description. = Comparator 1 input. RF7/SS, Pin Number.PIC18F6X8X.TQFP = . RF7/SS, Pin Number.PIC18F6X8X.PLCC = . RF7/SS, Pin Number.PIC18F8X8X.TQFP = . RF7/SS, Pin Type. = I/O. RF7/SS, Buffer Type. = ST. RF7/SS, Description. = Digital I/O.. RF7 SS, Pin Number.PIC18F6X8X.TQFP = . RF7 SS, Pin Number.PIC18F6X8X.PLCC = . RF7 SS, Pin Number.PIC18F8X8X.TQFP = . RF7 SS, Pin Type. = I. RF7 SS, Buffer Type. = TTL. RF7 SS, Description. = SPI slave select input.\nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nST\n=  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)",
    "Note\n1: Alternate assignment for CCP2 in all operating modes except Microcontroller - applies to PIC18F8X8X only.\n2: Default assignment when CCP2MX is set.\n3: External memory interface functions are only available on PIC18F8X8X devices.\n4: CCP2 is multiplexed with this pin by default when configured in Microcontroller mode; otherwise, it is multiplexed with either RB3 or RC1.\n5: PORTH and PORTJ are only available on PIC18F8X8X (80-pin) devices.\n6: PSP is available in Microcontroller mode only.\n7: On PIC18F8X8X devices, these pins can be multiplexed with RH7/RH6 by changing the ECCPMX configuration bit.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRG0/CANTX1 RG0, Pin Number.PIC18F6X8X.TQFP = 3. RG0/CANTX1 RG0, Pin Number.PIC18F6X8X.PLCC = 12. RG0/CANTX1 RG0, Pin Number.PIC18F8X8X.TQFP = 5. RG0/CANTX1 RG0, Pin Type. = . RG0/CANTX1 RG0, Buffer Type. = . RG0/CANTX1 RG0, Description. = . , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC = . , Pin Number.PIC18F8X8X.TQFP = . , Pin Type. = I/O. , Buffer Type. = ST. , Description. = Digital I/O.. CANTX1, Pin Number.PIC18F6X8X.TQFP = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nCANTX1, Pin Number.PIC18F6X8X.PLCC = . CANTX1, Pin Number.PIC18F8X8X.TQFP = . CANTX1, Pin Type. = O. CANTX1, Buffer Type. = TTL. CANTX1, Description. = CAN bus transmit 1.. RG1/CANTX2, Pin Number.PIC18F6X8X.TQFP = 4. RG1/CANTX2, Pin Number.PIC18F6X8X.PLCC = 13. RG1/CANTX2, Pin Number.PIC18F8X8X.TQFP = 6. RG1/CANTX2, Pin Type. = . RG1/CANTX2, Buffer Type. = . RG1/CANTX2, Description. = . RG1, Pin Number.PIC18F6X8X.TQFP = . RG1, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.PLCC = . RG1, Pin Number.PIC18F8X8X.TQFP = . RG1, Pin Type. = I/O. RG1, Buffer Type. = ST. RG1, Description. = Digital I/O.. CANTX2, Pin Number.PIC18F6X8X.TQFP = . CANTX2, Pin Number.PIC18F6X8X.PLCC = . CANTX2, Pin Number.PIC18F8X8X.TQFP = . CANTX2, Pin Type. = O. CANTX2, Buffer Type. = TTL. CANTX2, Description. = CAN bus transmit 2.. RG2/CANRX, Pin Number.PIC18F6X8X.TQFP = 5. RG2/CANRX, Pin Number.PIC18F6X8X.PLCC = 14. RG2/CANRX, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F8X8X.TQFP = 7. RG2/CANRX, Pin Type. = . RG2/CANRX, Buffer Type. = . RG2/CANRX, Description. = . RG2, Pin Number.PIC18F6X8X.TQFP = . RG2, Pin Number.PIC18F6X8X.PLCC = . RG2, Pin Number.PIC18F8X8X.TQFP = . RG2, Pin Type. = I/O. RG2, Buffer Type. = ST. RG2, Description. = Digital I/O.. CANRX, Pin Number.PIC18F6X8X.TQFP = . CANRX, Pin Number.PIC18F6X8X.PLCC = . CANRX, Pin Number.PIC18F8X8X.TQFP = . CANRX, Pin Type. = I. CANRX, Buffer Type. = TTL. CANRX,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nDescription. = CAN bus receive.. RG3, Pin Number.PIC18F6X8X.TQFP = . RG3, Pin Number.PIC18F6X8X.PLCC = . RG3, Pin Number.PIC18F8X8X.TQFP = . RG3, Pin Type. = . RG3, Buffer Type. = . RG3, Description. = . , Pin Number.PIC18F6X8X.TQFP = 6. , Pin Number.PIC18F6X8X.PLCC = 15. , Pin Number.PIC18F8X8X.TQFP = 8. , Pin Type. = . , Buffer Type. = . , Description. = . RG3, Pin Number.PIC18F6X8X.TQFP = . RG3, Pin Number.PIC18F6X8X.PLCC = . RG3, Pin Number.PIC18F8X8X.TQFP = . RG3, Pin Type. = I/O.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRG3, Buffer Type. = ST. RG3, Description. = Digital I/O.. RG4/P1D, Pin Number.PIC18F6X8X.TQFP = 8. RG4/P1D, Pin Number.PIC18F6X8X.PLCC = 17. RG4/P1D, Pin Number.PIC18F8X8X.TQFP = 10. RG4/P1D, Pin Type. = I/O. RG4/P1D, Buffer Type. = . RG4/P1D, Description. = . RG4, Pin Number.PIC18F6X8X.TQFP = . RG4, Pin Number.PIC18F6X8X.PLCC = . RG4, Pin Number.PIC18F8X8X.TQFP = . RG4, Pin Type. = . RG4, Buffer Type. = ST. RG4, Description. = Digital I/O..",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nP1D, Pin Number.PIC18F6X8X.TQFP = . P1D, Pin Number.PIC18F6X8X.PLCC = . P1D, Pin Number.PIC18F8X8X.TQFP = . P1D, Pin Type. = . P1D, Buffer Type. = TTL. P1D, Description. = . , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC = . , Pin Number.PIC18F8X8X.TQFP = . , Pin Type. = O. , Buffer Type. = . , Description. = ECCP1 PWM output D.. RG5, Pin Number.PIC18F6X8X.TQFP = 7. RG5, Pin Number.PIC18F6X8X.PLCC = . RG5, Pin Number.PIC18F8X8X.TQFP = . RG5, Pin Type. = I.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRG5, Buffer Type. = ST. RG5, Description. = General purpose input pin.. , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC = 16. , Pin Number.PIC18F8X8X.TQFP = 9. , Pin Type. = . , Buffer Type. = . , Description. = \nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST\n=  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n1: Alternate assignment for CCP2 in all operating modes except Microcontroller - applies to PIC18F8X8X only.\n2: Default assignment when CCP2MX is set.\n3: External memory interface functions are only available on PIC18F8X8X devices.\n4: CCP2 is multiplexed with this pin by default when configured in Microcontroller mode; otherwise, it is multiplexed with either RB3 or RC1.\n5: PORTH and PORTJ are only available on PIC18F8X8X (80-pin) devices.\n6: PSP is available in Microcontroller mode only.\n7: On PIC18F8X8X devices, these pins can be multiplexed with RH7/RH6 by changing the ECCPMX configuration bit.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRH0/A16 RH0, Pin Number.PIC18F6X8X.TQFP = -. RH0/A16 RH0, Pin Number.PIC18F6X8X.PLCC = -. RH0/A16 RH0, Pin Number.PIC18F8X8X.TQFP = 79. RH0/A16 RH0, Pin Type. = . RH0/A16 RH0, Buffer Type. = . RH0/A16 RH0, Description. = PORTH is a bidirectional I/O port .. , Pin Number.PIC18F6X8X.TQFP = . , Pin Number.PIC18F6X8X.PLCC = . , Pin Number.PIC18F8X8X.TQFP = . , Pin Type. = I/O. , Buffer Type. = ST. , Description. = Digital I/O.. A16, Pin Number.PIC18F6X8X.TQFP = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nA16, Pin Number.PIC18F6X8X.PLCC = . A16, Pin Number.PIC18F8X8X.TQFP = . A16, Pin Type. = O. A16, Buffer Type. = TTL. A16, Description. = External memory address 16.. RH1/A17, Pin Number.PIC18F6X8X.TQFP = -. RH1/A17, Pin Number.PIC18F6X8X.PLCC = -. RH1/A17, Pin Number.PIC18F8X8X.TQFP = 80. RH1/A17, Pin Type. = . RH1/A17, Buffer Type. = . RH1/A17, Description. = . RH1, Pin Number.PIC18F6X8X.TQFP = . RH1, Pin Number.PIC18F6X8X.PLCC = . RH1, Pin Number.PIC18F8X8X.TQFP = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRH1, Pin Type. = I/O. RH1, Buffer Type. = ST. RH1, Description. = Digital I/O.. A17, Pin Number.PIC18F6X8X.TQFP = . A17, Pin Number.PIC18F6X8X.PLCC = . A17, Pin Number.PIC18F8X8X.TQFP = . A17, Pin Type. = O. A17, Buffer Type. = TTL. A17, Description. = External memory address 17.. RH2/A18, Pin Number.PIC18F6X8X.TQFP = -. RH2/A18, Pin Number.PIC18F6X8X.PLCC = -. RH2/A18, Pin Number.PIC18F8X8X.TQFP = 1. RH2/A18, Pin Type. = . RH2/A18, Buffer Type. = . RH2/A18, Description. = . RH2,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nPin Number.PIC18F6X8X.TQFP = . RH2, Pin Number.PIC18F6X8X.PLCC = . RH2, Pin Number.PIC18F8X8X.TQFP = . RH2, Pin Type. = I/O. RH2, Buffer Type. = ST. RH2, Description. = Digital I/O.. A18, Pin Number.PIC18F6X8X.TQFP = . A18, Pin Number.PIC18F6X8X.PLCC = . A18, Pin Number.PIC18F8X8X.TQFP = . A18, Pin Type. = O. A18, Buffer Type. = TTL. A18, Description. = External memory address 18.. RH3/A19, Pin Number.PIC18F6X8X.TQFP = -. RH3/A19, Pin Number.PIC18F6X8X.PLCC = -. RH3/A19, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F8X8X.TQFP = 2. RH3/A19, Pin Type. = . RH3/A19, Buffer Type. = . RH3/A19, Description. = . RH3, Pin Number.PIC18F6X8X.TQFP = . RH3, Pin Number.PIC18F6X8X.PLCC = . RH3, Pin Number.PIC18F8X8X.TQFP = . RH3, Pin Type. = I/O. RH3, Buffer Type. = ST. RH3, Description. = Digital I/O.. A19, Pin Number.PIC18F6X8X.TQFP = . A19, Pin Number.PIC18F6X8X.PLCC = . A19, Pin Number.PIC18F8X8X.TQFP = . A19, Pin Type. = O. A19, Buffer Type. = TTL. A19, Description. = External memory address 19..",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRH4/AN12, Pin Number.PIC18F6X8X.TQFP = -. RH4/AN12, Pin Number.PIC18F6X8X.PLCC = -. RH4/AN12, Pin Number.PIC18F8X8X.TQFP = 22. RH4/AN12, Pin Type. = . RH4/AN12, Buffer Type. = . RH4/AN12, Description. = . RH4, Pin Number.PIC18F6X8X.TQFP = . RH4, Pin Number.PIC18F6X8X.PLCC = . RH4, Pin Number.PIC18F8X8X.TQFP = . RH4, Pin Type. = I/O. RH4, Buffer Type. = ST. RH4, Description. = Digital I/O.. AN12, Pin Number.PIC18F6X8X.TQFP = . AN12, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.PLCC = . AN12, Pin Number.PIC18F8X8X.TQFP = . AN12, Pin Type. = I. AN12, Buffer Type. = Analog. AN12, Description. = Analog input 12.. RH5/AN13, Pin Number.PIC18F6X8X.TQFP = -. RH5/AN13, Pin Number.PIC18F6X8X.PLCC = -. RH5/AN13, Pin Number.PIC18F8X8X.TQFP = 21. RH5/AN13, Pin Type. = . RH5/AN13, Buffer Type. = . RH5/AN13, Description. = . RH5, Pin Number.PIC18F6X8X.TQFP = . RH5, Pin Number.PIC18F6X8X.PLCC = . RH5, Pin Number.PIC18F8X8X.TQFP = . RH5, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nType. = I/O. RH5, Buffer Type. = ST. RH5, Description. = Digital I/O.. AN13, Pin Number.PIC18F6X8X.TQFP = . AN13, Pin Number.PIC18F6X8X.PLCC = . AN13, Pin Number.PIC18F8X8X.TQFP = . AN13, Pin Type. = I. AN13, Buffer Type. = Analog. AN13, Description. = Analog input 13.. RH6/AN14/P1C, Pin Number.PIC18F6X8X.TQFP = -. RH6/AN14/P1C, Pin Number.PIC18F6X8X.PLCC = -. RH6/AN14/P1C, Pin Number.PIC18F8X8X.TQFP = 20. RH6/AN14/P1C, Pin Type. = . RH6/AN14/P1C, Buffer Type. = .",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRH6/AN14/P1C, Description. = . RH6, Pin Number.PIC18F6X8X.TQFP = . RH6, Pin Number.PIC18F6X8X.PLCC = . RH6, Pin Number.PIC18F8X8X.TQFP = . RH6, Pin Type. = I/O. RH6, Buffer Type. = ST. RH6, Description. = Digital I/O.. AN14 (7), Pin Number.PIC18F6X8X.TQFP = . AN14 (7), Pin Number.PIC18F6X8X.PLCC = . AN14 (7), Pin Number.PIC18F8X8X.TQFP = . AN14 (7), Pin Type. = I I/O. AN14 (7), Buffer Type. = Analog. AN14 (7), Description. = Analog input 14. Alternate CCP1 PWM output C..",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRH7/AN15/P1B, Pin Number.PIC18F6X8X.TQFP = -. RH7/AN15/P1B, Pin Number.PIC18F6X8X.PLCC = -. RH7/AN15/P1B, Pin Number.PIC18F8X8X.TQFP = 19. RH7/AN15/P1B, Pin Type. = . RH7/AN15/P1B, Buffer Type. = . RH7/AN15/P1B, Description. = . RH7, Pin Number.PIC18F6X8X.TQFP = . RH7, Pin Number.PIC18F6X8X.PLCC = . RH7, Pin Number.PIC18F8X8X.TQFP = . RH7, Pin Type. = I/O. RH7, Buffer Type. = ST. RH7, Description. = Digital I/O.. AN15, Pin",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nNumber.PIC18F6X8X.TQFP = . AN15, Pin Number.PIC18F6X8X.PLCC = . AN15, Pin Number.PIC18F8X8X.TQFP = . AN15, Pin Type. = I. AN15, Buffer Type. = Analog. AN15, Description. = Analog input 15.. P1B (7), Pin Number.PIC18F6X8X.TQFP = . P1B (7), Pin Number.PIC18F6X8X.PLCC = . P1B (7), Pin Number.PIC18F8X8X.TQFP = . P1B (7), Pin Type. = . P1B (7), Buffer Type. = . P1B (7), Description. = Alternate CCP1 PWM output B.\nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST =  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote\n1: Alternate assignment for CCP2 in all operating modes except Microcontroller - applies to PIC18F8X8X only.\n2: Default assignment when CCP2MX is set.\n3: External memory interface functions are only available on PIC18F8X8X devices.\n4: CCP2 is multiplexed with this pin by default when configured in Microcontroller mode; otherwise, it is multiplexed with either RB3 or RC1.\n5: PORTH and PORTJ are only available on PIC18F8X8X (80-pin) devices.\n6: PSP is available in Microcontroller mode only.\n7: On PIC18F8X8X devices, these pins can be multiplexed with RH7/RH6 by changing the ECCPMX configuration bit.",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nRJ0/ALE RJ0 ALE, Pin Number.PIC18F6X8X.TQFP = -. RJ0/ALE RJ0 ALE, Pin Number.PIC18F6X8X.PLCC = -. RJ0/ALE RJ0 ALE, Pin Number.PIC18F8X8X.TQFP = 62. RJ0/ALE RJ0 ALE, Pin Type. = . RJ0/ALE RJ0 ALE, Buffer Type. = . RJ0/ALE RJ0 ALE,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= PORTJ is a bidirectional I/O port (5) .. RJ1/OE RJ1, Pin Number.PIC18F6X8X.TQFP = -. RJ1/OE RJ1, Pin Number.PIC18F6X8X.PLCC = -. RJ1/OE RJ1, Pin Number.PIC18F8X8X.TQFP = 61. RJ1/OE RJ1, Pin Type. = . RJ1/OE RJ1, Buffer Type. = ST. RJ1/OE RJ1,  = . OE, Pin Number.PIC18F6X8X.TQFP = . OE, Pin Number.PIC18F6X8X.PLCC = . OE, Pin Number.PIC18F8X8X.TQFP = . OE, Pin Type. = I/O O. OE, Buffer Type. = TTL. OE,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= Digital I/O. External memory output enable.. RJ2/WRL RJ2, Pin Number.PIC18F6X8X.TQFP = -. RJ2/WRL RJ2, Pin Number.PIC18F6X8X.PLCC = -. RJ2/WRL RJ2, Pin Number.PIC18F8X8X.TQFP = 60. RJ2/WRL RJ2, Pin Type. = . RJ2/WRL RJ2, Buffer Type. = . RJ2/WRL RJ2,  = . WRL, Pin Number.PIC18F6X8X.TQFP = -. WRL, Pin Number.PIC18F6X8X.PLCC = -. WRL, Pin Number.PIC18F8X8X.TQFP = 59. WRL, Pin Type. = I/O O. WRL, Buffer Type. = ST TTL. WRL,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= Digital I/O. External memory write low control.. RJ3/WRH RJ3 WRH, Pin Number.PIC18F6X8X.TQFP = -. RJ3/WRH RJ3 WRH, Pin Number.PIC18F6X8X.PLCC = -. RJ3/WRH RJ3 WRH, Pin Number.PIC18F8X8X.TQFP = . RJ3/WRH RJ3 WRH, Pin Type. = I/O O. RJ3/WRH RJ3 WRH, Buffer Type. = ST TTL. RJ3/WRH RJ3 WRH,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= Digital I/O. External memory write high control.. RJ4/BA0 RJ4 BA0, Pin Number.PIC18F6X8X.TQFP = . RJ4/BA0 RJ4 BA0, Pin Number.PIC18F6X8X.PLCC = . RJ4/BA0 RJ4 BA0, Pin Number.PIC18F8X8X.TQFP = 39. RJ4/BA0 RJ4 BA0, Pin Type. = I/O O. RJ4/BA0 RJ4 BA0, Buffer Type. = ST TTL. RJ4/BA0 RJ4 BA0,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= Digital I/O. System bus byte address 0 control.. RJ5/CE CE, Pin Number.PIC18F6X8X.TQFP = -. RJ5/CE CE, Pin Number.PIC18F6X8X.PLCC = -. RJ5/CE CE, Pin Number.PIC18F8X8X.TQFP = 40. RJ5/CE CE, Pin Type. = I/O O. RJ5/CE CE, Buffer Type. = ST TTL. RJ5/CE CE,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= Digital I/O External memory chip enable.. RJ6/LB RJ6, Pin Number.PIC18F6X8X.TQFP = -. RJ6/LB RJ6, Pin Number.PIC18F6X8X.PLCC = -. RJ6/LB RJ6, Pin Number.PIC18F8X8X.TQFP = 42. RJ6/LB RJ6, Pin Type. = . RJ6/LB RJ6, Buffer Type. = . RJ6/LB RJ6,  = . LB, Pin Number.PIC18F6X8X.TQFP = . LB, Pin Number.PIC18F6X8X.PLCC = . LB, Pin Number.PIC18F8X8X.TQFP = . LB, Pin Type. = I/O O. LB, Buffer Type. = ST TTL. LB,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= Digital I/O. External memory low byte select.. VSS, Pin Number.PIC18F6X8X.TQFP = 9, 25, 41, 56. VSS, Pin Number.PIC18F6X8X.PLCC = 19, 36, 53, 68. VSS, Pin Number.PIC18F8X8X.TQFP = 11, 31,. VSS, Pin Type. = P. VSS, Buffer Type. = -. VSS,  = Ground reference for logic and I/O pins.. VDD, Pin Number.PIC18F6X8X.TQFP = 10,26, 38, 57. VDD, Pin Number.PIC18F6X8X.PLCC = 2, 20, 37, 49. VDD, Pin Number.PIC18F8X8X.TQFP = 12, 32, 48, 71. VDD, Pin Type. = P. VDD, Buffer Type. = -. VDD,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= Positive supply for logic and I/O pins.. AVSS, Pin Number.PIC18F6X8X.TQFP = 20. AVSS, Pin Number.PIC18F6X8X.PLCC = 30. AVSS, Pin Number.PIC18F8X8X.TQFP = 26. AVSS, Pin Type. = P. AVSS, Buffer Type. = -. AVSS,  = Ground reference for analog modules.. AVDD, Pin Number.PIC18F6X8X.TQFP = 19. AVDD, Pin Number.PIC18F6X8X.PLCC = 29. AVDD, Pin Number.PIC18F8X8X.TQFP = 25. AVDD, Pin Type. = P. AVDD, Buffer Type. = -. AVDD,",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\n= Positive supply for analog modules.. , Pin Number.PIC18F6X8X.TQFP = -. , Pin Number.PIC18F6X8X.PLCC = 1, 18, 35, 52. , Pin Number.PIC18F8X8X.TQFP = -. , Pin Type. = -. , Buffer Type. = -. ,  = No connect.. NC, Pin Number.PIC18F6X8X.TQFP = . NC, Pin Number.PIC18F6X8X.PLCC = . NC, Pin Number.PIC18F8X8X.TQFP = . NC, Pin Type. = . NC, Buffer Type. = . NC,  = \nLegend:\nTTL\n=  TTL compatible input\nCMOS\n=  CMOS compatible input or output\nST\n=  Schmitt Trigger input with CMOS levels\nAnalog\n=  Analog input\nI\n=  Input\nO\n=  Output\nP =  Power\nOD\n=  Open-Drain (no P diode to VDD)\nNote 1:",
    "TABLE 1-2: PIC18F6585/8585/6680/8680 PINOUT I/O DESCRIPTIONS  (CONTINUED)\nAlternate assignment for CCP2 in all operating modes except Microcontroller - applies to PIC18F8X8X only.\n2: Default assignment when CCP2MX is set.\n3: External memory interface functions are only available on PIC18F8X8X devices.\n4: CCP2 is multiplexed with this pin by default when configured in Microcontroller mode; otherwise, it is multiplexed with either RB3 or RC1.\n5: PORTH and PORTJ are only available on PIC18F8X8X (80-pin) devices.\n6: PSP is available in Microcontroller mode only.\n7: On PIC18F8X8X devices, these pins can be multiplexed with RH7/RH6 by changing the ECCPMX configuration bit.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "2.1 Oscillator Types\nThe  PIC18F6585/8585/6680/8680  devices  can  be operated in eleven different oscillator modes. The user can program four configuration bits (FOSC3, FOSC2, FOSC1  and  FOSC0)  to  select  one  of  these  eleven modes:\n1. LP\nLow-Power Crystal\n2. XT\nCrystal/Resonator\n3. HS\nHigh-Speed Crystal/Resonator\n4. RC\nExternal Resistor/Capacitor\n5. EC\nExternal Clock\n6. ECIO\nExternal Clock with I/O pin enabled\n7. HS+PLL\nHigh-Speed Crystal/Resonator with PLL enabled\n8. RCIO\nExternal Resistor/Capacitor with\nI/O pin enabled\n9.\nECIO+SPLL External Clock with software controlled PLL\n10. ECIO+PLL\nExternal  Clock  with  PLL  and  I/O pin enabled\n11. HS+SPLL\nHigh-Speed Crystal/Resonator with software control",
    "2.2 Crystal Oscillator/Ceramic Resonators\nIn XT, LP, HS, HS+PLL or HS+SPLL Oscillator modes, a crystal or ceramic resonator is connected to the OSC1 and  OSC2  pins  to  establish  oscillation.  Figure 2-1 shows the pin connections.\nThe  PIC18F6585/8585/6680/8680  oscillator design requires the use of a parallel cut crystal.",
    "Note:\nUse of a series cut crystal may give a fre- quency  out  of  the  crystal  manufacturers specifications.",
    "FIGURE 2-1:\nCRYSTAL/CERAMIC RESONATOR OPERATION (HS, XT OR LP CONFIGURATION)\nNote 1: See Table 2-1 and Table 2-2 for recommended values of C1 and C2.\n2: A series resistor (RS) may be required for AT strip cut crystals.\n3: RF varies with the oscillator mode chosen.",
    "Ranges Tested:\nXT, Freq = 455 kHz. XT, C1 = 68-100 pF. XT, C2 = 68-100 pF. , Freq = 2.0 MHz. , C1 = 15-68 pF. , C2 = 15-68 pF. , Freq = 4.0 MHz. , C1 = 15-68 pF. , C2 = 15-68 pF. HS, Freq = 8.0 MHz. HS, C1 = 10-68 pF. HS, C2 = 10-68 pF. , Freq = 16.0 MHz. , C1 = 10-22 pF. , C2 = 10-22 pF\nThese values are for design guidance only. See notes following this table.",
    "Resonators Used:\n2.0 MHz, 1 = Murata Erie CSA2.00MG. 2.0 MHz, 2 = \uf0b1 0.5%. 4.0 MHz, 1 = Murata Erie CSA4.00MG. 4.0 MHz, 2 = \uf0b1 0.5%. 8.0 MHz, 1 = Murata Erie CSA8.00MT. 8.0 MHz, 2 = \uf0b1 0.5%. 16.0 MHz, 1 = Murata Erie CSA16.00MX. 16.0 MHz, 2 = \uf0b1 0.5%. All resonators used did not have built-in capacitors., 1 = All resonators used did not have built-in capacitors.. All resonators used did not have built-in capacitors., 2 = All resonators used did not have built-in capacitors.",
    "Resonators Used:\nNote 1: Higher capacitance increases the stability of  the  oscillator,  but  also  increases  the start-up time.\n2: When operating below 3V VDD, or when using certain  ceramic  resonators  at  any voltage, it may be necessary to use high gain  HS  mode,  try  a  lower  frequency resonator, or switch to a crystal oscillator.\n3: Since each resonator/crystal has its own characteristics, the user should consult the resonator/crystal manufacturer for appropriate  values  of  external  components,  or verify oscillator performance.",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nLP, Ranges Tested:.Freq = 32.0 kHz. LP, Ranges Tested:.C1 = 33 pF. LP, Ranges Tested:.C2 = 33 pF. LP, Ranges Tested:.Freq = 200 kHz. LP, Ranges Tested:.C1 = 15 pF. LP, Ranges Tested:.C2 = 15 pF. XT, Ranges Tested:.Freq = 200 kHz. XT, Ranges Tested:.C1 = 47-68 pF. XT, Ranges Tested:.C2 = 47-68 pF. XT, Ranges Tested:.Freq = 1.0 MHz. XT, Ranges Tested:.C1 = 15 pF. XT, Ranges Tested:.C2 = 15 pF. XT, Ranges Tested:.Freq = 4.0 MHz. XT, Ranges Tested:.C1 = 15 pF. XT, Ranges Tested:.C2 = 15 pF. HS, Ranges Tested:.Freq = 4.0 MHz. HS, Ranges Tested:.C1 = 15 pF. HS, Ranges Tested:.C2 = 15",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\npF. HS, Ranges Tested:.Freq = 8.0 MHz. HS, Ranges Tested:.C1 = 15-33 pF. HS, Ranges Tested:.C2 = 15-33 pF. HS, Ranges Tested:.Freq = 20.0 MHz. HS, Ranges Tested:.C1 = 15-33 pF. HS, Ranges Tested:.C2 = 15-33 pF. HS, Ranges Tested:.Freq = 25.0 MHz. HS, Ranges Tested:.C1 = TBD. HS, Ranges Tested:.C2 = TBD\nThese values are for design guidance only. See notes following this table.",
    "Crystals Used\n32.0 kHz, 1 = Epson C-001R32.768K-A. 32.0 kHz, 2 = \u00b1 20 PPM. 200 kHz, 1 = STD XTL 200.000KHz. 200 kHz, 2 = \u00b1 20 PPM. 1.0 MHz, 1 = ECS ECS-10-13-1. 1.0 MHz, 2 = \u00b1 50 PPM. 4.0 MHz, 1 = ECS ECS-40-20-1. 4.0 MHz, 2 = \u00b1 50 PPM. 8.0 MHz, 1 = Epson CA-301 8.000M-C. 8.0 MHz, 2 = \u00b1 30 PPM. 20.0 MHz, 1 = Epson CA-301 20.000M-C. 20.0 MHz, 2 = \u00b1 30 PPM",
    "Crystals Used\nNote 1: Higher capacitance increases the stability of  the  oscillator,  but  also  increases  the start-up time.\n2: Rs (see  Figure 2-1)  may  be  required  in HS mode, as well as XT mode, to avoid overdriving  crystals  with  low  drive  level specifications.\n3: Since each resonator/crystal has its own characteristics, the user should consult the resonator/crystal manufacturer for appropriate  values  of  external  components,  or verify oscillator performance.\nAn external clock source may also be connected to the OSC1 pin in the HS, XT and LP modes, as shown in Figure 2-2.",
    "2.3 RC Oscillator\nFor timing insensitive applications, the 'RC'  and 'RCIO'  device  options  offer  additional  cost  savings. The RC oscillator frequency is a function of the supply voltage, the resistor (REXT) and capacitor (CEXT) values and the operating temperature. In addition to this, the oscillator frequency will vary from unit to unit, due to  normal  process  parameter  variation.  Furthermore, the difference in lead frame capacitance between package  types  will  also  affect  the  oscillation  frequency, especially for low CEXT values. The user also needs to take into account variation due to tolerance of external R and C components used. Figure 2-3 shows how the R/C combination is connected.\nIn  the  RC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic.",
    "FIGURE 2-3: RC OSCILLATOR MODE\nThe RCIO Oscillator mode functions like the RC mode except that the OSC2 pin becomes an additional general  purpose  I/O  pin.  The  I/O  pin  becomes  bit  6  of PORTA (RA6).",
    "2.4 External Clock Input\nThe  EC,  ECIO,  EC+PLL  and  EC+SPLL  Oscillator modes  require  an  external  clock  source  to  be  connected to the OSC1 pin. The feedback device between OSC1 and OSC2 is turned off in these modes to save current. There is a maximum 1.5 \uf06d s start-up required after a Power-on Reset, or wake-up from Sleep mode.\nIn  the  EC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic. Figure 2-4 shows the pin connections for the EC Oscillator mode.",
    "EXTERNAL CLOCK INPUT OPERATION\n(EC CONFIGURATION)\nThe ECIO Oscillator mode functions like the EC mode, except that the OSC2 pin becomes an additional general  purpose  I/O  pin.  The  I/O  pin  becomes  bit  6  of PORTA (RA6). Figure 2-5 shows the pin connections for the ECIO Oscillator mode.\nFIGURE 2-5:\n(ECIO CONFIGURATION)\nFIGURE 2-6: PLL BLOCK DIAGRAM",
    "2.5 Phase Locked Loop (PLL)\nA Phase  Locked Loop circuit is provided as a programmable option for users that want to multiply the frequency of the incoming oscillator signal by 4. For an input  clock  frequency  of  10  MHz,  the  internal  clock frequency will be multiplied to 40 MHz. This is useful for customers  who  are concerned with EMI  due  to high-frequency crystals.\nThe PLL can only be enabled when the oscillator configuration bits are programmed for High-Speed Oscillator or External Clock mode. If they are programmed for any other mode, the PLL is not enabled and the system clock will  come directly  from  OSC1. There are two types of PLL modes: Software Controlled PLL and Configuration bits Controlled PLL. In Software Controlled PLL mode, PIC18F6585/8585/6680/8680 executes at regular clock frequency after all Reset conditions. During execution, application  can  enable  PLL  and  switch  to  4x  clock frequency  operation  by  setting  the  PLLEN  bit  in  the OSCCON register. In Configuration bits Controlled PLL mode,  PIC18F6585/8585/6680/8680  always  executes with 4x clock frequency.",
    "2.5 Phase Locked Loop (PLL)\nThe  type  of  PLL  is  selected  by  programming  the FOSC<3:0>  configuration bits in the CONFIG1H Configuration register. The oscillator mode is specified during device programming.\nA PLL lock timer is used to ensure that the PLL has locked  before  device  execution  starts.  The  PLL  lock timer has a time-out that is called TPLL.",
    "2.6 Oscillator Switching Feature\nThe  PIC18F6585/8585/6680/8680  devices  include  a feature  that  allows  the  system  clock  source  to  be switched  from  the  main  oscillator  to  an  alternate low-frequency clock source. For the PIC18F6585/8585/6680/8680  devices,  this  alternate clock source is the Timer1 oscillator. If a low-frequency crystal (32 kHz, for example) has been attached to the Timer1  oscillator  pins  and  the  Timer1  oscillator  has been enabled, the device can switch to a low-power execution mode. Figure 2-7 shows a block diagram of the system clock sources. The clock switching feature is  enabled  by  programming  the  Oscillator  Switching Enable (OSCSEN) bit in configuration register, CONFIG1H, to a ' 0 '. Clock switching is disabled in an erased device. See Section 12.0 'Timer1 Module' for further details of the Timer1 oscillator. See Section 24.0 'Special  Features  of  the  CPU' for configuration register details.",
    "2.6.1 SYSTEM CLOCK SWITCH BIT\nThe system clock source switching is performed under software control. The System Clock Switch bits, SCS1:SCS0 (OSCCON<1:0>), control the clock switching. When the SCS0 bit is ' 0 ', the system clock source comes from the main oscillator that is selected by the FOSC  configuration bits in configuration register, CONFIG1H. When the SCS0 bit is set, the system clock source will come from the Timer1 oscillator. The SCS0 bit is cleared on all forms of Reset.\nWhen  FOSC  bits  are  programmed  for  software  PLL mode, the SCS1 bit can be used to select between primary oscillator/clock and PLL output. The SCS1 bit will only have an effect on the system clock if the PLL is enabled (PLLEN = 1 ) and locked (LOCK = 1 ), else it will be forced clear. When programmed with Configuration Controlled PLL mode, the SCS1 bit will be forced clear.",
    "Note:\nThe  Timer1  oscillator  must  be  enabled and operating to switch the system clock source.  The  Timer1  oscillator  is  enabled by setting the T1OSCEN bit in the Timer1 Control  register  (T1CON).  If  the  Timer1 oscillator is not enabled, then any write to the  SCS0  bit  will  be  ignored  (SCS0  bit forced cleared) and the main oscillator will continue to be the system clock source.",
    "REGISTER 2-1: OSCCON REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = LOCK. -, 5 = PLLEN. -, 6 = SCS1. -, 7 = SCS0\nbit 7\nbit 0",
    "bit  7-4 Unimplemented: Read as ' 0 '\nbit 3 LOCK: Phase Lock Loop Lock Status bit\n1 = Phase Lock Loop output is stable as system clock\n0 = Phase Lock Loop output is not stable and output cannot be used as system clock\nbit 2 PLLEN (1) : Phase Lock Loop Enable bit\n1 = Enable Phase Lock Loop output as system clock\n0 = Disable Phase Lock Loop\nbit 1 SCS1: System Clock Switch bit 1\nWhen PLLEN and LOCK bits are set:\n1 = Use PLL output\n0 = Use primary oscillator/clock input pin\nWhen PLLEN or LOCK bit is cleared:\nBit is forced clear.",
    "bit  0 SCS0 (2) :\nSystem Clock Switch bit 0\nWhen OSCSEN configuration bit = 0 and T1OSCEN bit = 1 :\n1 = Switch to Timer1 oscillator/clock pin\n0 = Use primary oscillator/clock input pin\nWhen OSCSEN and T1OSCEN are in other states:\nBit is forced clear.\nNote 1: PLLEN bit is ignored when configured for ECIO+PLL and HS+PLL. This bit is used in ECIO+SPLL and HS+SPLL modes only.\n2: The setting of SCS0 = 1 supersedes SCS1 = 1 .",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "2.6.2 OSCILLATOR TRANSITIONS\nPIC18F6585/8585/6680/8680 devices contain circuitry to prevent 'glitches' when switching between oscillator sources. Essentially, the circuitry waits for eight rising edges of the clock source that the processor is switching to. This ensures that the new clock source is stable and that its pulse width will not be less than the shortest pulse width of the two clock sources.\nThe sequence of events that takes place when switching from the Timer1 oscillator to the main oscillator will depend on the mode of the main oscillator. In addition to eight clock cycles of the main oscillator, additional delays may take place.\nA  timing  diagram,  indicating  the  transition  from  the main  oscillator  to  the  Timer1  oscillator,  is  shown  in Figure 2-8. The Timer1 oscillator is assumed to be running all the time. After the SCS0 bit is set, the processor is  frozen  at  the  next  occurring  Q1  cycle.  After  eight synchronization  cycles  are  counted  from  the  Timer1 oscillator, operation resumes. No additional delays are required after the synchronization cycles.",
    "2.6.2 OSCILLATOR TRANSITIONS\nIf the  main  oscillator  is  configured  for  an  external crystal (HS, XT, LP), then the transition will take place after an oscillator start-up time (T OST) has occurred. A timing diagram, indicating the transition from the Timer1 oscillator to the main oscillator for HS, XT and LP modes, is shown in Figure 2-9.",
    "FIGURE 2-8: TIMING DIAGRAM FOR TRANSITION FROM OSC1 TO TIMER1 OSCILLATOR\nFIGURE 2-9:\nTIMING FOR TRANSITION BETWEEN TIMER1 AND OSC1 (HS, XT, LP)",
    "PIC18F6585/8585/6680/8680\nIf  the  main  oscillator  is  configured  for  HS  mode  with PLL active, an oscillator  start-up time (TOST) plus an additional PLL time-out (TPLL) will occur. The PLL timeout is typically 2 ms and allows the PLL to lock to the main oscillator frequency. A timing diagram, indicating the  transition  from  the  Timer1  oscillator  to  the  main oscillator for HS-PLL mode, is shown in Figure 2-10.\nIf the main oscillator is configured for EC mode with PLL active, only the PLL time-out (TPLL) will occur. The PLL time-out is typically 2 ms and allows the PLL to lock to the main oscillator frequency. A timing diagram, indicating the transition from the Timer1 oscillator to the main oscillator for EC with PLL active, is shown in Figure 2-11.",
    "PIC18F6585/8585/6680/8680\nIf the main oscillator is configured in the RC, RCIO, EC or ECIO modes, there is no oscillator start-up time-out. Operation  will  resume  after  eight  cycles  of  the  main oscillator have been counted. A timing diagram, indicating the transition from the Timer1 oscillator  to the main oscillator for RC, RCIO, EC and ECIO modes, is shown in Figure 2-12.",
    "2.7 Effects of Sleep Mode on the On-Chip Oscillator\nWhen the device executes a SLEEP instruction, the onchip clocks and oscillator are turned off and the device is  held  at  the  beginning  of  an  instruction  cycle  (Q1 state).  With  the  oscillator  off,  the  OSC1  and  OSC2 signals  will  stop  oscillating.  Since  all  the  transistor switching  currents  have  been  removed,  Sleep  mode achieves the lowest current consumption of the device (only leakage currents). Enabling any on-chip feature that will operate during Sleep will increase the current consumed  during  Sleep.  The  user  can  wake  from Sleep through external Reset, Watchdog Timer Reset, or through an interrupt.",
    "TABLE 2-3: OSC1 AND OSC2 PIN STATES IN SLEEP MODE\nRC, OSC1 Pin = Floating, external resistor should pull high. RC, OSC2 Pin = At logic low. RCIO, OSC1 Pin = Floating, external resistor should pull high. RCIO, OSC2 Pin = Configured as PORTA, bit 6. ECIO, OSC1 Pin = Floating. ECIO, OSC2 Pin = Configured as PORTA, bit 6. EC, OSC1 Pin = Floating. EC, OSC2 Pin = At logic low. LP, XT, and HS, OSC1 Pin = Feedback inverter disabled at quiescent voltage level. LP, XT, and HS, OSC2 Pin = Feedback inverter disabled at quiescent voltage level\nNote: See Table 3-1 in Section 3.0 'Reset' , for time-outs due to Sleep and MCLR Reset.",
    "2.8 Power-up Delays\nPower-up delays are controlled by two timers so that no external  Reset  circuitry  is  required  for  most  applications.  The  delays  ensure  that  the  device  is  kept  in Reset until the device power supply and clock are stable. For additional information on Reset operation, see Section 3.0 'Reset' .\nThe first  timer  is  the  Power-up  Timer  (PWRT)  which optionally provides a fixed delay of 72 ms (nominal) on power-up only (POR and BOR). The second timer is the Oscillator Start-up Timer (OST), intended to keep the chip in Reset until the crystal oscillator is stable.",
    "2.8 Power-up Delays\nWith the PLL enabled (HS+PLL and EC+PLL Oscillator mode),  the  time-out  sequence  following  a  Power-on Reset  is  different  from  other  oscillator  modes.  The time-out sequence is as follows: First, the PWRT timeout  is  invoked  after  a  POR  time  delay  has  expired. Then, the Oscillator Start-up Timer (OST) is invoked. However, this is still not a sufficient amount of time to allow the PLL to lock at high frequencies. The PWRT timer  is  used  to  provide  an  additional  fixed  2  ms (nominal) time-out to allow the PLL ample time to lock to the incoming clock frequency.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "3.0 RESET\nThe PIC18F6585/8585/6680/8680 devices differentiate between various kinds of Reset:\na) Power-on Reset (POR)\nb) MCLR Reset during normal operation\nc) MCLR Reset during Sleep\nd) Watchdog  Timer  (WDT)  Reset  (during  normal operation)\ne) Programmable Brown-out Reset (BOR)\nf) RESET Instruction\ng) Stack Full Reset\nh) Stack Underflow Reset\nMost registers are unaffected by a Reset. Their status is unknown  on  POR  and  unchanged  by  all  other Resets.  The  other  registers  are  forced  to  a  'Reset state' on Power-on Reset, MCLR, WDT Reset, Brownout  Reset,  MCLR  Reset  during  Sleep  and  by  the RESET instruction.",
    "SIMPLIFIED BLOCK DIAGRAM OF ON-CHIP RESET CIRCUIT\nMost  registers  are  not  affected  by  a  WDT  wake-up since this is viewed as the resumption of normal operation. Status bits from the RCON register, RI, TO, PD, POR and BOR, are set or cleared differently in different Reset situations, as indicated in Table 3-2. These bits are  used  in  software  to  determine  the  nature  of  the Reset. See Table 3-3 for a full description of the Reset states of all registers.\nA simplified block diagram of the On-Chip Reset Circuit is shown in Figure 3-1.\nThe Enhanced MCU devices have a MCLR noise filter in  the  MCLR  Reset  path.  The  filter  will  detect  and ignore small pulses. The MCLR pin is not driven low by any internal Resets, including the WDT.",
    "3.1 Power-on Reset (POR)\nA  Power-on  Reset  pulse  is  generated  on-chip  when VDD rise is detected. To take advantage of the POR circuitry, tie the MCLR pin through a 1 k \uf057 to 10 k \uf057 resistor to VDD. This will eliminate external RC components usually needed to create a Power-on Reset delay. A minimum  rise  rate  for  VDD  is  specified  (parameter D004). For a slow rise time, see Figure 3-2.\nWhen the device starts normal operation (i.e., exits the Reset  condition),  device  operating  parameters  (voltage,  frequency,  temperature,  etc.)  must  be  met  to ensure operation. If these conditions are not met, the device  must  be  held  in  Reset  until  the  operating conditions are met.",
    "EXTERNAL POWER-ON RESET CIRCUIT (FOR SLOW VDD POWER-UP)\nNote 1: External  Power-on  Reset  circuit  is  required only  if  the  VDD  power-up  slope  is  too  slow. The  diode  D  helps  discharge  the  capacitor quickly when VDD powers down.\n2: R < 40 k \uf057 is recommended to make sure that the  voltage  drop  across  R  does  not  violate the device's electrical specification.\n3: R1 = 1 k \uf057 to 10 k \uf057 will limit any current flowing into MCLR from external capacitor C, in the event of MCLR/VPP pin breakdown due to Electrostatic  Discharge  (ESD)  or  Electrical Overstress (EOS).",
    "3.2 Power-up Timer (PWRT)\nThe Power-up Timer provides a fixed nominal time-out (parameter #33) only on power-up from the POR. The Power-up Timer operates on an internal RC oscillator. The chip is kept in Reset as long as the PWRT is active. The  PWRT's  time  delay  allows  VDD  to  rise  to  an acceptable  level.  A  configuration  bit  is  provided  to enable/disable the PWRT.\nThe power-up time delay will vary from chip-to-chip due to  VDD,  temperature  and  process  variation.  See  DC parameter #33 for details.",
    "3.3 Oscillator Start-up Timer (OST)\nThe  Oscillator  Start-up  Timer  (OST)  provides  1024 oscillator  cycles  (from  OSC1  input)  delay  after  the PWRT delay is over (parameter #32). This ensures that the  crystal  oscillator  or  resonator  has  started  and stabilized.\nThe OST time-out is invoked only for XT, LP and HS modes and only on Power-on Reset, or wake-up from Sleep.",
    "3.4 PLL Lock Time-out\nWith the PLL enabled, the time-out sequence following a  Power-on  Reset  is  different  from  other  oscillator modes. A portion of the Power-up Timer is used to provide a fixed time-out that is sufficient for the PLL to lock to the main oscillator frequency. This PLL lock time-out (TPLL)  is  typically  2  ms  and  follows  the  oscillator start-up time-out (OST).",
    "3.5 Brown-out Reset (BOR)\nA  configuration  bit,  BOREN,  can  disable  (if  clear/ programmed), or enable (if set) the Brown-out Reset circuitry. If VDD falls below parameter D005 for greater than parameter #35, the brown-out situation will reset the  chip.  A  Reset  may  not  occur  if  VDD  falls  below parameter D005 for less than parameter #35. The chip will  remain in Brown-out Reset until VDD rises above BVDD.  If  the  Power-up  Timer  is  enabled,  it  will  be invoked after VDD rises above BVDD; it then will keep the chip in Reset for an additional time delay (parameter #33). If VDD drops below BVDD while the Power-up Timer is running, the chip will go back into a Brown-out Reset and the Power-up Timer will be initialized. Once VDD  rises  above  BVDD,  the  Power-up  Timer  will execute the additional time delay.",
    "3.6 Time-out Sequence\nOn  power-up,  the  time-out  sequence  is  as  follows: First,  PWRT  time-out  is  invoked  after  the  POR  time delay has expired. Then, OST is activated. The total time-out will vary based on oscillator configuration and the status of the PWRT. For example, in RC mode with the  PWRT  disabled,  there  will  be  no  time-out  at  all. Figure 3-3, Figure 3-4, Figure 3-5, Figure 3-6 and Figure 3-7 depict time-out sequences on power-up.\nSince  the  time-outs  occur  from  the  POR  pulse,  the time-outs will expire if MCLR is kept low long enough. Bringing MCLR high will begin execution immediately (Figure 3-5).  This is  useful  for  testing  purposes  or  to synchronize more  than one PIC18FXX8X  device operating in parallel.\nTable 3-2 shows the Reset conditions for some Special Function  Registers  while  Table 3-3  shows  the  Reset conditions for all of the registers.",
    "TABLE 3-1: TIME-OUT IN VARIOUS SITUATIONS\nHS with PLL enabled (1), Power-up (2).PWRTE = 0 = 72 ms + 1024 T OSC + 2ms. HS with PLL enabled (1), Power-up (2).PWRTE = 1 = 1024 T OSC + 2 ms. HS with PLL enabled (1), Brown-out.Brown-out = 1024 T OSC + 2 ms. HS with PLL enabled (1), Wake-up from Sleep or Oscillator Switch.Wake-up from Sleep or Oscillator Switch = 1024 T OSC + 2 ms. EC with PLL enabled (1), Power-up (2).PWRTE = 0 = 72 ms + 2ms. EC with PLL enabled (1), Power-up (2).PWRTE = 1 = 1.5 \uf06d s + 2 ms. EC with PLL enabled (1), Brown-out.Brown-out = 2 ms. EC with PLL enabled (1), Wake-up from Sleep or Oscillator Switch.Wake-up from Sleep or Oscillator Switch =",
    "TABLE 3-1: TIME-OUT IN VARIOUS SITUATIONS\n1.5 \uf06d s + 2 ms. HS, XT, LP, Power-up (2).PWRTE = 0 = 72 ms + 1024 T OSC. HS, XT, LP, Power-up (2).PWRTE = 1 = 1024 T OSC. HS, XT, LP, Brown-out.Brown-out = 1024 T OSC. HS, XT, LP, Wake-up from Sleep or Oscillator Switch.Wake-up from Sleep or Oscillator Switch = 1024 T OSC. EC, Power-up (2).PWRTE = 0 = 72 ms. EC, Power-up (2).PWRTE = 1 = 1.5 \uf06d s. EC, Brown-out.Brown-out = 1.5 \uf06d s. EC, Wake-up from Sleep or Oscillator Switch.Wake-up from Sleep or Oscillator Switch = 1.5 \uf06d s (3). External RC, Power-up (2).PWRTE = 0 = 72 ms. External RC, Power-up (2).PWRTE = 1 =",
    "TABLE 3-1: TIME-OUT IN VARIOUS SITUATIONS\n1.5 \uf06d s. External RC, Brown-out.Brown-out = 1.5 \uf06d s. External RC, Wake-up from Sleep or Oscillator Switch.Wake-up from Sleep or Oscillator Switch = 1.5 \uf06d s\nNote 1: 2 ms is the nominal time required for the 4x PLL to lock.\n2: 72 ms is the nominal power-up timer delay if implemented.\n3: 1.5 \uf06d s is the recovery time from Sleep. There is no recovery time from oscillator switch.",
    "REGISTER 3-1: RCON REGISTER BITS AND POSITIONS\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R/W-1. R/W-0, 5 = R/W-1. R/W-0, 6 = R/W-1. R/W-0, 7 = R/W-0. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0\nNote: Refer to Section 4.14 'RCON Register' for bit definitions.",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nPower-on Reset, Program Counter = 0000h. Power-on Reset, RCON Register = 0--1 1100. Power-on Reset, RI = 1. Power-on Reset, TO = 1. Power-on Reset, PD = 1. Power-on Reset, POR = 0. Power-on Reset, BOR = 0. Power-on Reset, STKFUL = u. Power-on Reset, STKUNF = u. MCLR Reset during normal operation, Program Counter = 0000h. MCLR Reset during normal operation, RCON Register = 0--u uuuu. MCLR Reset during normal operation, RI = u. MCLR Reset during normal operation, TO = u. MCLR Reset during normal operation, PD = u. MCLR Reset during normal operation, POR = u. MCLR Reset during normal operation, BOR = u. MCLR Reset during normal operation, STKFUL = u. MCLR Reset during normal operation, STKUNF = u. Software Reset during normal operation, Program Counter = 0000h. Software Reset during normal operation, RCON Register =",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n0--0 uuuu. Software Reset during normal operation, RI = 0. Software Reset during normal operation, TO = u. Software Reset during normal operation, PD = u. Software Reset during normal operation, POR = u. Software Reset during normal operation, BOR = u. Software Reset during normal operation, STKFUL = u. Software Reset during normal operation, STKUNF = u. Stack Full Reset during normal operation, Program Counter = 0000h. Stack Full Reset during normal operation, RCON Register = 0--u uu11. Stack Full Reset during normal operation, RI = u. Stack Full Reset during normal operation, TO = u. Stack Full Reset during normal operation, PD = u. Stack Full Reset during normal operation, POR = u. Stack Full Reset during normal operation, BOR = u. Stack Full Reset during normal operation, STKFUL = u. Stack Full Reset during normal operation, STKUNF = 1. Stack Underflow Reset during normal operation, Program Counter = 0000h. Stack Underflow Reset during normal operation, RCON Register = 0--u uu11. Stack",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nUnderflow Reset during normal operation, RI = u. Stack Underflow Reset during normal operation, TO = u. Stack Underflow Reset during normal operation, PD = u. Stack Underflow Reset during normal operation, POR = u. Stack Underflow Reset during normal operation, BOR = u. Stack Underflow Reset during normal operation, STKFUL = 1. Stack Underflow Reset during normal operation, STKUNF = u. MCLR Reset during Sleep, Program Counter = 0000h. MCLR Reset during Sleep, RCON Register = 0--u 10uu. MCLR Reset during Sleep, RI = u. MCLR Reset during Sleep, TO = 1. MCLR Reset during Sleep, PD = 0. MCLR Reset during Sleep, POR = u. MCLR Reset during Sleep, BOR = u. MCLR Reset during Sleep, STKFUL = u. MCLR Reset during Sleep, STKUNF = u. WDT Reset, Program Counter = 0000h. WDT Reset, RCON Register = 0--u 01uu. WDT Reset, RI = 1. WDT Reset, TO =",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n0. WDT Reset, PD = 1. WDT Reset, POR = u. WDT Reset, BOR = u. WDT Reset, STKFUL = u. WDT Reset, STKUNF = u. WDT Wake-up, Program Counter = PC + 2. WDT Wake-up, RCON Register = u--u 00uu. WDT Wake-up, RI = u. WDT Wake-up, TO = 0. WDT Wake-up, PD = 0. WDT Wake-up, POR = u. WDT Wake-up, BOR = u. WDT Wake-up, STKFUL = u. WDT Wake-up, STKUNF = u. Brown-out Reset, Program Counter = 0000h. Brown-out Reset, RCON Register = 0--1 11u0. Brown-out Reset, RI = 1. Brown-out Reset, TO = 1. Brown-out Reset, PD = 1. Brown-out Reset, POR = 1. Brown-out Reset, BOR = 0. Brown-out Reset,",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nSTKFUL = u. Brown-out Reset, STKUNF = u. Interrupt wake-up from Sleep, Program Counter = PC + 2 (1). Interrupt wake-up from Sleep, RCON Register = u--u 00uu. Interrupt wake-up from Sleep, RI = u. Interrupt wake-up from Sleep, TO = 1. Interrupt wake-up from Sleep, PD = 0. Interrupt wake-up from Sleep, POR = u. Interrupt wake-up from Sleep, BOR = u. Interrupt wake-up from Sleep, STKFUL = u. Interrupt wake-up from Sleep, STKUNF = u\nLegend:\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 '\nNote 1: When the wake-up is due to an interrupt and the GIEH or GIEL bits are set, the PC is loaded with the interrupt vector (000008h or 000018h).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTOSU, Applicable Devices = PIC18F6X8X. TOSU, Applicable Devices = PIC18F8X8X. TOSU, Power-on Reset, Brown-out Reset = ---0 0000. TOSU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. TOSU, Wake-up via WDT or Interrupt = ---0 uuuu (3). TOSH, Applicable Devices = PIC18F6X8X. TOSH, Applicable Devices = PIC18F8X8X. TOSH, Power-on Reset, Brown-out Reset = 0000 0000. TOSH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSH, Wake-up via WDT or Interrupt = uuuu uuuu (3). TOSL, Applicable Devices = PIC18F6X8X. TOSL, Applicable Devices = PIC18F8X8X. TOSL, Power-on Reset, Brown-out Reset = 0000 0000. TOSL, MCLR Resets WDT Reset RESET Instruction Stack",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nResets = 0000 0000. TOSL, Wake-up via WDT or Interrupt = uuuu uuuu (3). STKPTR, Applicable Devices = PIC18F6X8X. STKPTR, Applicable Devices = PIC18F8X8X. STKPTR, Power-on Reset, Brown-out Reset = 00-0 0000. STKPTR, MCLR Resets WDT Reset RESET Instruction Stack Resets = uu-0 0000. STKPTR, Wake-up via WDT or Interrupt = uu-u uuuu (3). PCLATU, Applicable Devices = PIC18F6X8X. PCLATU, Applicable Devices = PIC18F8X8X. PCLATU, Power-on Reset, Brown-out Reset = ---0 0000. PCLATU, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---0 0000. PCLATU, Wake-up via WDT or Interrupt = ---u uuuu. PCLATH, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPIC18F6X8X. PCLATH, Applicable Devices = PIC18F8X8X. PCLATH, Power-on Reset, Brown-out Reset = 0000 0000. PCLATH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PCLATH, Wake-up via WDT or Interrupt = uuuu uuuu. PCL, Applicable Devices = PIC18F6X8X. PCL, Applicable Devices = PIC18F8X8X. PCL, Power-on Reset, Brown-out Reset = 0000 0000. PCL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PCL, Wake-up via WDT or Interrupt = PC + 2 (2). TBLPTRU, Applicable Devices = PIC18F6X8X. TBLPTRU, Applicable Devices = PIC18F8X8X. TBLPTRU, Power-on Reset, Brown-out Reset = --00 0000. TBLPTRU, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n--00 0000. TBLPTRU, Wake-up via WDT or Interrupt = --uu uuuu. TBLPTRH, Applicable Devices = PIC18F6X8X. TBLPTRH, Applicable Devices = PIC18F8X8X. TBLPTRH, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRH, Wake-up via WDT or Interrupt = uuuu uuuu. TBLPTRL, Applicable Devices = PIC18F6X8X. TBLPTRL, Applicable Devices = PIC18F8X8X. TBLPTRL, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRL, Wake-up via WDT or Interrupt = uuuu uuuu. TABLAT, Applicable Devices = PIC18F6X8X. TABLAT, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPIC18F8X8X. TABLAT, Power-on Reset, Brown-out Reset = 0000 0000. TABLAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TABLAT, Wake-up via WDT or Interrupt = uuuu uuuu. PRODH, Applicable Devices = PIC18F6X8X. PRODH, Applicable Devices = PIC18F8X8X. PRODH, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PRODH, Wake-up via WDT or Interrupt = uuuu uuuu. PRODL, Applicable Devices = PIC18F6X8X. PRODL, Applicable Devices = PIC18F8X8X. PRODL, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PRODL, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nuuuu uuuu. INTCON, Applicable Devices = PIC18F6X8X. INTCON, Applicable Devices = PIC18F8X8X. INTCON, Power-on Reset, Brown-out Reset = 0000 000x. INTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000x. INTCON, Wake-up via WDT or Interrupt = uuuu uuuu (1). INTCON2, Applicable Devices = PIC18F6X8X. INTCON2, Applicable Devices = PIC18F8X8X. INTCON2, Power-on Reset, Brown-out Reset = 1111 1111. INTCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. INTCON2, Wake-up via WDT or Interrupt = uuuu uuuu (1). INTCON3, Applicable Devices = PIC18F6X8X. INTCON3, Applicable Devices = PIC18F8X8X. INTCON3, Power-on Reset, Brown-out Reset = 1100 0000.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nINTCON3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1100 0000. INTCON3, Wake-up via WDT or Interrupt = uuuu uuuu (1). INDF0, Applicable Devices = PIC18F6X8X. INDF0, Applicable Devices = PIC18F8X8X. INDF0, Power-on Reset, Brown-out Reset = N/A. INDF0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF0, Wake-up via WDT or Interrupt = N/A. POSTINC0, Applicable Devices = PIC18F6X8X. POSTINC0, Applicable Devices = PIC18F8X8X. POSTINC0, Power-on Reset, Brown-out Reset = N/A. POSTINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC0, Wake-up via WDT or Interrupt = N/A. POSTDEC0, Applicable Devices = PIC18F6X8X. POSTDEC0, Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nDevices = PIC18F8X8X. POSTDEC0, Power-on Reset, Brown-out Reset = N/A. POSTDEC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC0, Wake-up via WDT or Interrupt = N/A. PREINC0, Applicable Devices = PIC18F6X8X. PREINC0, Applicable Devices = PIC18F8X8X. PREINC0, Power-on Reset, Brown-out Reset = N/A. PREINC0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC0, Wake-up via WDT or Interrupt = N/A. PLUSW0, Applicable Devices = PIC18F6X8X. PLUSW0, Applicable Devices = PIC18F8X8X. PLUSW0, Power-on Reset, Brown-out Reset = N/A. PLUSW0, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PLUSW0, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nN/A. FSR0H, Applicable Devices = PIC18F6X8X. FSR0H, Applicable Devices = PIC18F8X8X. FSR0H, Power-on Reset, Brown-out Reset = ---- xxxx. FSR0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR0H, Wake-up via WDT or Interrupt = ---- uuuu. FSR0L, Applicable Devices = PIC18F6X8X. FSR0L, Applicable Devices = PIC18F8X8X. FSR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR0L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR0L, Wake-up via WDT or Interrupt = uuuu uuuu. WREG, Applicable Devices = PIC18F6X8X. WREG, Applicable Devices = PIC18F8X8X. WREG, Power-on",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nReset, Brown-out Reset = xxxx xxxx. WREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. WREG, Wake-up via WDT or Interrupt = uuuu uuuu. INDF1, Applicable Devices = PIC18F6X8X. INDF1, Applicable Devices = PIC18F8X8X. INDF1, Power-on Reset, Brown-out Reset = N/A. INDF1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF1, Wake-up via WDT or Interrupt = N/A. POSTINC1, Applicable Devices = PIC18F6X8X. POSTINC1, Applicable Devices = PIC18F8X8X. POSTINC1, Power-on Reset, Brown-out Reset = N/A. POSTINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC1, Wake-up via WDT or Interrupt = N/A. POSTDEC1, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPIC18F6X8X. POSTDEC1, Applicable Devices = PIC18F8X8X. POSTDEC1, Power-on Reset, Brown-out Reset = N/A. POSTDEC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC1, Wake-up via WDT or Interrupt = N/A. PREINC1, Applicable Devices = PIC18F6X8X. PREINC1, Applicable Devices = PIC18F8X8X. PREINC1, Power-on Reset, Brown-out Reset = N/A. PREINC1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC1, Wake-up via WDT or Interrupt = N/A. PLUSW1, Applicable Devices = PIC18F6X8X. PLUSW1, Applicable Devices = PIC18F8X8X. PLUSW1, Power-on Reset, Brown-out Reset = N/A. PLUSW1, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPLUSW1, Wake-up via WDT or Interrupt = N/A\nLegend: u = unchanged, x = unknown, - = unimplemented bit, read as ' 0 ', q = value depends on condition.\nShaded cells indicate conditions do not apply for the designated device.\nNote",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFSR1H, Applicable Devices = PIC18F6X8X. FSR1H, Applicable Devices = PIC18F8X8X. FSR1H, Power-on Reset, Brown-out Reset = ---- xxxx. FSR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR1H, Wake-up via WDT or Interrupt = ---- uuuu. FSR1L, Applicable Devices = PIC18F6X8X. FSR1L, Applicable Devices = PIC18F8X8X. FSR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR1L, Wake-up via WDT or Interrupt = uuuu uuuu. BSR, Applicable Devices = PIC18F6X8X. BSR, Applicable Devices = PIC18F8X8X. BSR, Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = ---- 0000. BSR, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. BSR, Wake-up via WDT or Interrupt = ---- uuuu. INDF2, Applicable Devices = PIC18F6X8X. INDF2, Applicable Devices = PIC18F8X8X. INDF2, Power-on Reset, Brown-out Reset = N/A. INDF2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. INDF2, Wake-up via WDT or Interrupt = N/A. POSTINC2, Applicable Devices = PIC18F6X8X. POSTINC2, Applicable Devices = PIC18F8X8X. POSTINC2, Power-on Reset, Brown-out Reset = N/A. POSTINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTINC2, Wake-up via WDT or Interrupt = N/A. POSTDEC2, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F6X8X. POSTDEC2, Applicable Devices = PIC18F8X8X. POSTDEC2, Power-on Reset, Brown-out Reset = N/A. POSTDEC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC2, Wake-up via WDT or Interrupt = N/A. PREINC2, Applicable Devices = PIC18F6X8X. PREINC2, Applicable Devices = PIC18F8X8X. PREINC2, Power-on Reset, Brown-out Reset = N/A. PREINC2, MCLR Resets WDT Reset RESET Instruction Stack Resets = N/A. PREINC2, Wake-up via WDT or Interrupt = N/A. PLUSW2, Applicable Devices = PIC18F6X8X. PLUSW2, Applicable Devices = PIC18F8X8X. PLUSW2, Power-on Reset, Brown-out Reset = N/A. PLUSW2, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nN/A. PLUSW2, Wake-up via WDT or Interrupt = N/A. FSR2H, Applicable Devices = PIC18F6X8X. FSR2H, Applicable Devices = PIC18F8X8X. FSR2H, Power-on Reset, Brown-out Reset = ---- xxxx. FSR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR2H, Wake-up via WDT or Interrupt = ---- uuuu. FSR2L, Applicable Devices = PIC18F6X8X. FSR2L, Applicable Devices = PIC18F8X8X. FSR2L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR2L, Wake-up via WDT or Interrupt = uuuu uuuu. STATUS, Applicable Devices = PIC18F6X8X. STATUS,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices = PIC18F8X8X. STATUS, Power-on Reset, Brown-out Reset = ---x xxxx. STATUS, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---u uuuu. STATUS, Wake-up via WDT or Interrupt = ---u uuuu. TMR0H, Applicable Devices = PIC18F6X8X. TMR0H, Applicable Devices = PIC18F8X8X. TMR0H, Power-on Reset, Brown-out Reset = 0000 0000. TMR0H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR0H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR0L, Applicable Devices = PIC18F6X8X. TMR0L, Applicable Devices = PIC18F8X8X. TMR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR0L,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR0L, Wake-up via WDT or Interrupt = uuuu uuuu. T0CON, Applicable Devices = PIC18F6X8X. T0CON, Applicable Devices = PIC18F8X8X. T0CON, Power-on Reset, Brown-out Reset = 1111 1111. T0CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. T0CON, Wake-up via WDT or Interrupt = uuuu uuuu. OSCCON, Applicable Devices = PIC18F6X8X. OSCCON, Applicable Devices = PIC18F8X8X. OSCCON, Power-on Reset, Brown-out Reset = ---- 0000. OSCCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- 0000. OSCCON, Wake-up via WDT or Interrupt = ---- uuuu. LVDCON, Applicable Devices",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= PIC18F6X8X. LVDCON, Applicable Devices = PIC18F8X8X. LVDCON, Power-on Reset, Brown-out Reset = --00 0101. LVDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0101. LVDCON, Wake-up via WDT or Interrupt = --uu uuuu. WDTCON, Applicable Devices = PIC18F6X8X. WDTCON, Applicable Devices = PIC18F8X8X. WDTCON, Power-on Reset, Brown-out Reset = ---- ---0. WDTCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---- ---0. WDTCON, Wake-up via WDT or Interrupt = ---- ---u. RCON (4), Applicable Devices = PIC18F6X8X. RCON (4), Applicable Devices = PIC18F8X8X. RCON (4), Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0--q 11qq. RCON (4), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0--q qquu. RCON (4), Wake-up via WDT or Interrupt = u--u qquu. TMR1H, Applicable Devices = PIC18F6X8X. TMR1H, Applicable Devices = PIC18F8X8X. TMR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR1L, Applicable Devices = PIC18F6X8X. TMR1L, Applicable Devices = PIC18F8X8X. TMR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. TMR1L, Wake-up via WDT or Interrupt = uuuu uuuu. T1CON, Applicable Devices = PIC18F6X8X. T1CON, Applicable Devices = PIC18F8X8X. T1CON, Power-on Reset, Brown-out Reset = 0-00 0000. T1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = u-uu uuuu. T1CON, Wake-up via WDT or Interrupt = u-uu uuuu. TMR2, Applicable Devices = PIC18F6X8X. TMR2, Applicable Devices = PIC18F8X8X. TMR2, Power-on Reset, Brown-out Reset = 0000 0000. TMR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TMR2, Wake-up via WDT or Interrupt = uuuu uuuu. PR2, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F6X8X. PR2, Applicable Devices = PIC18F8X8X. PR2, Power-on Reset, Brown-out Reset = 1111 1111. PR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. PR2, Wake-up via WDT or Interrupt = 1111 1111. T2CON, Applicable Devices = PIC18F6X8X. T2CON, Applicable Devices = PIC18F8X8X. T2CON, Power-on Reset, Brown-out Reset = -000 0000. T2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000 0000. T2CON, Wake-up via WDT or Interrupt = -uuu uuuu. SSPBUF, Applicable Devices = PIC18F6X8X. SSPBUF, Applicable Devices = PIC18F8X8X. SSPBUF, Power-on Reset, Brown-out Reset = xxxx xxxx. SSPBUF, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. SSPBUF, Wake-up via WDT or Interrupt = uuuu uuuu. SSPADD, Applicable Devices = PIC18F6X8X. SSPADD, Applicable Devices = PIC18F8X8X. SSPADD, Power-on Reset, Brown-out Reset = 0000 0000. SSPADD, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPADD, Wake-up via WDT or Interrupt = uuuu uuuu. SSPSTAT, Applicable Devices = PIC18F6X8X. SSPSTAT, Applicable Devices = PIC18F8X8X. SSPSTAT, Power-on Reset, Brown-out Reset = 0000 0000. SSPSTAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPSTAT, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON1, Applicable Devices = PIC18F6X8X. SSPCON1, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. SSPCON1, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPCON1, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON2, Applicable Devices = PIC18F6X8X. SSPCON2, Applicable Devices = PIC18F8X8X. SSPCON2, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPCON2, Wake-up via WDT or Interrupt = uuuu uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLegend: u = unchanged, x = unknown, - = unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADRESH, Applicable Devices = PIC18F6X8X. ADRESH, Applicable Devices = PIC18F8X8X. ADRESH, Power-on Reset, Brown-out Reset = xxxx xxxx. ADRESH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. ADRESH, Wake-up via WDT or Interrupt = uuuu uuuu. ADRESL, Applicable Devices = PIC18F6X8X. ADRESL, Applicable Devices = PIC18F8X8X. ADRESL, Power-on Reset, Brown-out Reset = xxxx xxxx. ADRESL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. ADRESL, Wake-up via WDT or Interrupt = uuuu uuuu. ADCON0, Applicable Devices = PIC18F6X8X. ADCON0, Applicable Devices = PIC18F8X8X. ADCON0, Power-on Reset, Brown-out Reset = --00 0000.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADCON0, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. ADCON0, Wake-up via WDT or Interrupt = --uu uuuu. ADCON1, Applicable Devices = PIC18F6X8X. ADCON1, Applicable Devices = PIC18F8X8X. ADCON1, Power-on Reset, Brown-out Reset = --00 0000. ADCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. ADCON1, Wake-up via WDT or Interrupt = --uu uuuu. ADCON2, Applicable Devices = PIC18F6X8X. ADCON2, Applicable Devices = PIC18F8X8X 0-00. ADCON2, Power-on Reset, Brown-out Reset = 0000 0-00. ADCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ADCON2, Wake-up via WDT or Interrupt = u-uu uuuu. CCPR1H, Applicable Devices",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= PIC18F6X8X. CCPR1H, Applicable Devices = PIC18F8X8X. CCPR1H, Power-on Reset, Brown-out Reset = xxxx xxxx uuuu. CCPR1H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. CCPR1H, Wake-up via WDT or Interrupt = uuuu uuuu. CCPR1L, Applicable Devices = PIC18F6X8X. CCPR1L, Applicable Devices = PIC18F8X8X xxxx. CCPR1L, Power-on Reset, Brown-out Reset = xxxx. CCPR1L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR1L, Wake-up via WDT or Interrupt = uuuu uuuu. CCP1CON, Applicable Devices = PIC18F6X8X. CCP1CON, Applicable Devices = PIC18F8X8X 0000. CCP1CON, Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = 0000. CCP1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. CCP1CON, Wake-up via WDT or Interrupt = uuuu uuuu. CCPR2H, Applicable Devices = PIC18F6X8X. CCPR2H, Applicable Devices = PIC18F8X8X. CCPR2H, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR2H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR2H, Wake-up via WDT or Interrupt = uuuu uuuu. CCPR2L, Applicable Devices = PIC18F6X8X. CCPR2L, Applicable Devices = PIC18F8X8X. CCPR2L, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR2L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. CCPR2L,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu uuuu. CCP2CON, Applicable Devices = PIC18F6X8X. CCP2CON, Applicable Devices = PIC18F8X8X. CCP2CON, Power-on Reset, Brown-out Reset = --00 0000. CCP2CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00 0000. CCP2CON, Wake-up via WDT or Interrupt = --uu uuuu. CCPAS1, Applicable Devices = PIC18F6X8X. CCPAS1, Applicable Devices = PIC18F8X8X. CCPAS1, Power-on Reset, Brown-out Reset = 0000 0000. CCPAS1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. CCPAS1, Wake-up via WDT or Interrupt = uuuu uuuu. CVRCON, Applicable Devices = PIC18F6X8X. CVRCON, Applicable Devices = PIC18F8X8X.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nCVRCON, Power-on Reset, Brown-out Reset = 0000 0000. CVRCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. CVRCON, Wake-up via WDT or Interrupt = uuuu uuuu. CMCON, Applicable Devices = PIC18F6X8X. CMCON, Applicable Devices = PIC18F8X8X. CMCON, Power-on Reset, Brown-out Reset = 0000 0000. CMCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. CMCON, Wake-up via WDT or Interrupt = uuuu uuuu. TMR3H, Applicable Devices = PIC18F6X8X. TMR3H, Applicable Devices = PIC18F8X8X xxxx. TMR3H, Power-on Reset, Brown-out Reset = xxxx. TMR3H, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR3H,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu uuuu. TMR3L, Applicable Devices = PIC18F6X8X. TMR3L, Applicable Devices = PIC18F8X8X. TMR3L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR3L, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR3L, Wake-up via WDT or Interrupt = uuuu uuuu. T3CON, Applicable Devices = PIC18F6X8X. T3CON, Applicable Devices = PIC18F8X8X. T3CON, Power-on Reset, Brown-out Reset = 0000 0000. T3CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. T3CON, Wake-up via WDT or Interrupt = uuuu uuuu. PSPCON, Applicable Devices = PIC18F6X8X. PSPCON, Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = PIC18F8X8X. PSPCON, Power-on Reset, Brown-out Reset = 0000 ----. PSPCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 ----. PSPCON, Wake-up via WDT or Interrupt = uuuu ----. SPBRG, Applicable Devices = PIC18F6X8X. SPBRG, Applicable Devices = PIC18F8X8X. SPBRG, Power-on Reset, Brown-out Reset = 0000 0000. SPBRG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. SPBRG, Wake-up via WDT or Interrupt = uuuu uuuu. RCREG, Applicable Devices = PIC18F6X8X. RCREG, Applicable Devices = PIC18F8X8X. RCREG, Power-on Reset, Brown-out Reset = 0000 0000. RCREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRCREG, Wake-up via WDT or Interrupt = uuuu uuuu. TXREG, Applicable Devices = PIC18F6X8X. TXREG, Applicable Devices = PIC18F8X8X. TXREG, Power-on Reset, Brown-out Reset = 0000 0000. TXREG, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. TXREG, Wake-up via WDT or Interrupt = uuuu uuuu. TXSTA, Applicable Devices = PIC18F6X8X. TXSTA, Applicable Devices = PIC18F8X8X. TXSTA, Power-on Reset, Brown-out Reset = 0000 0010. TXSTA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0010. TXSTA, Wake-up via WDT or Interrupt = uuuu uuuu. RCSTA, Applicable Devices = PIC18F6X8X PIC18F6X8X. RCSTA, Applicable Devices = PIC18F8X8X. RCSTA,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = 0000 000x. RCSTA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 000x ----. RCSTA, Wake-up via WDT or Interrupt = uuuu ---- --uu. EEADRH, Applicable Devices = . EEADRH, Applicable Devices = . EEADRH, Power-on Reset, Brown-out Reset = ---- --00. EEADRH, MCLR Resets WDT Reset RESET Instruction Stack Resets = --00. EEADRH, Wake-up via WDT or Interrupt = uuuu uuuu. , Applicable Devices = . , Applicable Devices = PIC18F8X8X. , Power-on Reset, Brown-out Reset = . , MCLR Resets WDT Reset RESET Instruction Stack Resets = . , Wake-up via WDT or Interrupt = . EEADR, Applicable Devices = PIC18F6X8X. EEADR, Applicable Devices = PIC18F8X8X. EEADR, Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = 0000 0000. EEADR, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. EEADR, Wake-up via WDT or Interrupt = . EEDATA, Applicable Devices = PIC18F6X8X. EEDATA, Applicable Devices = PIC18F8X8X. EEDATA, Power-on Reset, Brown-out Reset = 0000 0000. EEDATA, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. EEDATA, Wake-up via WDT or Interrupt = uuuu uuuu\nLegend:\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 ', q = value depends on condition.\nShaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nIPR3, Applicable Devices = PIC18F6X8X. IPR3, Applicable Devices = PIC18F8X8X. IPR3, Power-on Reset, Brown-out Reset = 1111 1111. IPR3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. IPR3, Wake-up via WDT or Interrupt = uuuu uuuu. PIR3, Applicable Devices = PIC18F6X8X. PIR3, Applicable Devices = PIC18F8X8X. PIR3, Power-on Reset, Brown-out Reset = 0000 0000. PIR3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PIR3, Wake-up via WDT or Interrupt = uuuu uuuu. PIE3, Applicable Devices = PIC18F6X8X. PIE3, Applicable Devices = PIC18F8X8X. PIE3, Power-on Reset, Brown-out Reset = 0000 0000. PIE3, MCLR Resets WDT Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRESET Instruction Stack Resets = 0000 0000. PIE3, Wake-up via WDT or Interrupt = uuuu uuuu. IPR2, Applicable Devices = PIC18F6X8X. IPR2, Applicable Devices = PIC18F8X8X. IPR2, Power-on Reset, Brown-out Reset = -1-1 1111. IPR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = -1-1 1111. IPR2, Wake-up via WDT or Interrupt = -u-u uuuu. PIR2, Applicable Devices = PIC18F6X8X. PIR2, Applicable Devices = PIC18F8X8X. PIR2, Power-on Reset, Brown-out Reset = -0-0 0000. PIR2, MCLR Resets WDT Reset RESET Instruction Stack Resets = -0-0 0000. PIR2, Wake-up via WDT or Interrupt = -u-u uuuu (1). PIE2, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F6X8X. PIE2, Applicable Devices = PIC18F8X8X. PIE2, Power-on Reset, Brown-out Reset = -0-0 0000. PIE2, MCLR Resets WDT Reset RESET Instruction Stack Resets = -0-0 0000. PIE2, Wake-up via WDT or Interrupt = -u-u uuuu. IPR1, Applicable Devices = PIC18F6X8X. IPR1, Applicable Devices = PIC18F8X8X. IPR1, Power-on Reset, Brown-out Reset = 1111 1111. IPR1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. IPR1, Wake-up via WDT or Interrupt = uuuu uuuu. PIR1, Applicable Devices = PIC18F6X8X. PIR1, Applicable Devices = PIC18F8X8X. PIR1, Power-on Reset, Brown-out Reset = 0000 0000. PIR1, MCLR Resets WDT Reset RESET Instruction Stack",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets = 0000 0000. PIR1, Wake-up via WDT or Interrupt = uuuu uuuu (1). PIE1, Applicable Devices = PIC18F6X8X. PIE1, Applicable Devices = PIC18F8X8X. PIE1, Power-on Reset, Brown-out Reset = 0000 0000. PIE1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 0000. PIE1, Wake-up via WDT or Interrupt = uuuu uuuu. MEMCON, Applicable Devices = PIC18F6X8X. MEMCON, Applicable Devices = PIC18F8X8X. MEMCON, Power-on Reset, Brown-out Reset = 0-00 --00. MEMCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0-00 --00. MEMCON, Wake-up via WDT or Interrupt = u-uu --uu. TRISJ, Applicable Devices = PIC18F6X8X. TRISJ, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. TRISJ, Power-on Reset, Brown-out Reset = 1111 1111. TRISJ, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISJ, Wake-up via WDT or Interrupt = uuuu uuuu. TRISH, Applicable Devices = PIC18F6X8X. TRISH, Applicable Devices = PIC18F8X8X. TRISH, Power-on Reset, Brown-out Reset = 1111 1111. TRISH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISH, Wake-up via WDT or Interrupt = uuuu uuuu. TRISG, Applicable Devices = PIC18F6X8X. TRISG, Applicable Devices = PIC18F8X8X. TRISG, Power-on Reset, Brown-out Reset = ---1 1111. TRISG, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---1 1111. TRISG, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n---u uuuu. TRISF, Applicable Devices = PIC18F6X8X. TRISF, Applicable Devices = PIC18F8X8X. TRISF, Power-on Reset, Brown-out Reset = 1111 1111. TRISF, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISF, Wake-up via WDT or Interrupt = uuuu uuuu. TRISE, Applicable Devices = PIC18F6X8X. TRISE, Applicable Devices = PIC18F8X8X. TRISE, Power-on Reset, Brown-out Reset = 0000 -111. TRISE, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000 -111. TRISE, Wake-up via WDT or Interrupt = uuuu -uuu. TRISD, Applicable Devices = PIC18F6X8X. TRISD, Applicable Devices = PIC18F8X8X. TRISD, Power-on Reset, Brown-out Reset = 1111 1111. TRISD, MCLR Resets WDT Reset RESET",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInstruction Stack Resets = 1111 1111. TRISD, Wake-up via WDT or Interrupt = uuuu uuuu. TRISC, Applicable Devices = PIC18F6X8X. TRISC, Applicable Devices = PIC18F8X8X. TRISC, Power-on Reset, Brown-out Reset = 1111 1111. TRISC, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISC, Wake-up via WDT or Interrupt = uuuu uuuu. TRISB, Applicable Devices = PIC18F6X8X. TRISB, Applicable Devices = PIC18F8X8X. TRISB, Power-on Reset, Brown-out Reset = 1111 1111. TRISB, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1111 1111. TRISB, Wake-up via WDT or Interrupt = uuuu uuuu. TRISA (5,6), Applicable Devices = PIC18F6X8X. TRISA (5,6), Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. TRISA (5,6), Power-on Reset, Brown-out Reset = -111 1111 (5). TRISA (5,6), MCLR Resets WDT Reset RESET Instruction Stack Resets = -111 1111 (5). TRISA (5,6), Wake-up via WDT or Interrupt = -uuu uuuu (5). LATJ, Applicable Devices = PIC18F6X8X. LATJ, Applicable Devices = PIC18F8X8X. LATJ, Power-on Reset, Brown-out Reset = xxxx xxxx. LATJ, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATJ, Wake-up via WDT or Interrupt = uuuu uuuu. LATH, Applicable Devices = PIC18F6X8X. LATH, Applicable Devices = PIC18F8X8X. LATH, Power-on Reset, Brown-out Reset = xxxx xxxx. LATH, MCLR Resets",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATH, Wake-up via WDT or Interrupt = uuuu uuuu. LATG, Applicable Devices = PIC18F6X8X. LATG, Applicable Devices = PIC18F8X8X. LATG, Power-on Reset, Brown-out Reset = ---x xxxx. LATG, MCLR Resets WDT Reset RESET Instruction Stack Resets = ---u uuuu. LATG, Wake-up via WDT or Interrupt = ---u uuuu. LATF, Applicable Devices = PIC18F6X8X. LATF, Applicable Devices = PIC18F8X8X. LATF, Power-on Reset, Brown-out Reset = xxxx xxxx. LATF, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATF, Wake-up via WDT or Interrupt = uuuu uuuu. LATE, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F6X8X. LATE, Applicable Devices = PIC18F8X8X. LATE, Power-on Reset, Brown-out Reset = xxxx xxxx. LATE, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATE, Wake-up via WDT or Interrupt = uuuu uuuu. LATD, Applicable Devices = PIC18F6X8X. LATD, Applicable Devices = PIC18F8X8X. LATD, Power-on Reset, Brown-out Reset = xxxx xxxx. LATD, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATD, Wake-up via WDT or Interrupt = uuuu uuuu. LATC, Applicable Devices = PIC18F6X8X. LATC, Applicable Devices = PIC18F8X8X. LATC, Power-on Reset, Brown-out Reset = xxxx xxxx. LATC, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. LATC, Wake-up via WDT or Interrupt = uuuu uuuu. LATB, Applicable Devices = PIC18F6X8X. LATB, Applicable Devices = PIC18F8X8X. LATB, Power-on Reset, Brown-out Reset = xxxx xxxx. LATB, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. LATB, Wake-up via WDT or Interrupt = uuuu uuuu. LATA (5,6), Applicable Devices = PIC18F6X8X. LATA (5,6), Applicable Devices = PIC18F8X8X. LATA (5,6), Power-on Reset, Brown-out Reset = -xxx xxxx (5). LATA (5,6), MCLR Resets WDT Reset RESET Instruction Stack Resets = -uuu uuuu (5). LATA (5,6), Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n-uuu uuuu (5)\nLegend:\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPORTJ, Applicable Devices = PIC18F6X8X. PORTJ, Applicable Devices = PIC18F8X8X. PORTJ, Power-on Reset, Brown-out Reset = xxxx. PORTJ, Power-on Reset, Brown-out Reset = xxxx. PORTJ, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTJ, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTJ, Wake-up via WDT or Interrupt = uuuu. PORTJ, Wake-up via WDT or Interrupt = uuuu. PORTH, Applicable Devices = PIC18F6X8X. PORTH, Applicable Devices = PIC18F8X8X. PORTH, Power-on Reset, Brown-out Reset = 0000. PORTH, Power-on Reset, Brown-out Reset = xxxx. PORTH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. PORTH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTH, Wake-up",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nvia WDT or Interrupt = uuuu. PORTH, Wake-up via WDT or Interrupt = uuuu. PORTG, Applicable Devices = PIC18F6X8X. PORTG, Applicable Devices = PIC18F8X8X. PORTG, Power-on Reset, Brown-out Reset = --xx. PORTG, Power-on Reset, Brown-out Reset = xxxx. PORTG, MCLR Resets WDT Reset RESET Instruction Stack Resets = --uu. PORTG, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTG, Wake-up via WDT or Interrupt = --uu. PORTG, Wake-up via WDT or Interrupt = uuuu. PORTF, Applicable Devices = PIC18F6X8X. PORTF, Applicable Devices = PIC18F8X8X. PORTF, Power-on Reset, Brown-out Reset = x000. PORTF, Power-on Reset, Brown-out Reset = 0000. PORTF, MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nu000. PORTF, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. PORTF, Wake-up via WDT or Interrupt = u000. PORTF, Wake-up via WDT or Interrupt = 0000. PORTE, Applicable Devices = PIC18F6X8X. PORTE, Applicable Devices = PIC18F8X8X. PORTE, Power-on Reset, Brown-out Reset = ----. PORTE, Power-on Reset, Brown-out Reset = -000. PORTE, MCLR Resets WDT Reset RESET Instruction Stack Resets = ----. PORTE, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000. PORTE, Wake-up via WDT or Interrupt = ----. PORTE, Wake-up via WDT or Interrupt = -uuu. PORTD, Applicable Devices = PIC18F6X8X. PORTD, Applicable Devices = PIC18F8X8X. PORTD, Power-on Reset, Brown-out Reset = xxxx. PORTD, Power-on Reset, Brown-out Reset = xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPORTD, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTD, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTD, Wake-up via WDT or Interrupt = uuuu. PORTD, Wake-up via WDT or Interrupt = uuuu. PORTC, Applicable Devices = PIC18F6X8X. PORTC, Applicable Devices = PIC18F8X8X. PORTC, Power-on Reset, Brown-out Reset = xxxx. PORTC, Power-on Reset, Brown-out Reset = xxxx. PORTC, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTC, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTC, Wake-up via WDT or Interrupt = uuuu. PORTC, Wake-up via WDT or Interrupt = uuuu. PORTB, Applicable Devices = PIC18F6X8X. PORTB, Applicable Devices = PIC18F8X8X.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPORTB, Power-on Reset, Brown-out Reset = xxxx. PORTB, Power-on Reset, Brown-out Reset = xxxx. PORTB, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTB, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. PORTB, Wake-up via WDT or Interrupt = uuuu. PORTB, Wake-up via WDT or Interrupt = uuuu. PORTA (5,6), Applicable Devices = PIC18F6X8X. PORTA (5,6), Applicable Devices = PIC18F8X8X. PORTA (5,6), Power-on Reset, Brown-out Reset = -x0x. PORTA (5,6), Power-on Reset, Brown-out Reset = 0000 (5). PORTA (5,6), MCLR Resets WDT Reset RESET Instruction Stack Resets = -u0u. PORTA (5,6), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(5). PORTA (5,6), Wake-up via WDT or Interrupt = -uuu. PORTA (5,6), Wake-up via WDT or Interrupt = uuuu (5). SPBRGH, Applicable Devices = PIC18F6X8X. SPBRGH, Applicable Devices = PIC18F8X8X. SPBRGH, Power-on Reset, Brown-out Reset = 0000. SPBRGH, Power-on Reset, Brown-out Reset = 0000. SPBRGH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. SPBRGH, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. SPBRGH, Wake-up via WDT or Interrupt = uuuu. SPBRGH, Wake-up via WDT or Interrupt = uuuu. BAUDCON, Applicable Devices = PIC18F6X8X. BAUDCON, Applicable Devices = PIC18F8X8X. BAUDCON, Power-on Reset, Brown-out Reset = -1-0.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBAUDCON, Power-on Reset, Brown-out Reset = 0-00. BAUDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = -1-0. BAUDCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0-00. BAUDCON, Wake-up via WDT or Interrupt = -u-u. BAUDCON, Wake-up via WDT or Interrupt = u-uu. ECCP1DEL, Applicable Devices = PIC18F6X8X. ECCP1DEL, Applicable Devices = PIC18F8X8X. ECCP1DEL, Power-on Reset, Brown-out Reset = 0000. ECCP1DEL, Power-on Reset, Brown-out Reset = 0000. ECCP1DEL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ECCP1DEL, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ECCP1DEL, Wake-up via WDT or Interrupt = uuuu. ECCP1DEL, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. ECANCON, Applicable Devices = PIC18F6X8X. ECANCON, Applicable Devices = PIC18F8X8X. ECANCON, Power-on Reset, Brown-out Reset = 0001. ECANCON, Power-on Reset, Brown-out Reset = 0000. ECANCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0001. ECANCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. ECANCON, Wake-up via WDT or Interrupt = uuuu. ECANCON, Wake-up via WDT or Interrupt = uuuu. TXERRCNT, Applicable Devices = PIC18F6X8X. TXERRCNT, Applicable Devices = PIC18F8X8X. TXERRCNT, Power-on Reset, Brown-out Reset = 0000. TXERRCNT, Power-on Reset, Brown-out Reset = 0000. TXERRCNT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. TXERRCNT, MCLR",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets WDT Reset RESET Instruction Stack Resets = 0000. TXERRCNT, Wake-up via WDT or Interrupt = uuuu. TXERRCNT, Wake-up via WDT or Interrupt = uuuu. RXERRCNT, Applicable Devices = PIC18F6X8X. RXERRCNT, Applicable Devices = PIC18F8X8X. RXERRCNT, Power-on Reset, Brown-out Reset = 0000. RXERRCNT, Power-on Reset, Brown-out Reset = 0000. RXERRCNT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. RXERRCNT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. RXERRCNT, Wake-up via WDT or Interrupt = uuuu. RXERRCNT, Wake-up via WDT or Interrupt = uuuu. COMSTAT, Applicable Devices = PIC18F6X8X. COMSTAT, Applicable Devices = PIC18F8X8X. COMSTAT,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = 0000. COMSTAT, Power-on Reset, Brown-out Reset = 0000. COMSTAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. COMSTAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. COMSTAT, Wake-up via WDT or Interrupt = uuuu. COMSTAT, Wake-up via WDT or Interrupt = uuuu. CIOCON, Applicable Devices = PIC18F6X8X. CIOCON, Applicable Devices = PIC18F8X8X. CIOCON, Power-on Reset, Brown-out Reset = 0000. CIOCON, Power-on Reset, Brown-out Reset = ----. CIOCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. CIOCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = ----. CIOCON, Wake-up via WDT or Interrupt = uuuu. CIOCON, Wake-up via WDT",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nor Interrupt = ----. BRGCON3, Applicable Devices = PIC18F6X8X. BRGCON3, Applicable Devices = PIC18F8X8X. BRGCON3, Power-on Reset, Brown-out Reset = 00--. BRGCON3, Power-on Reset, Brown-out Reset = -000. BRGCON3, MCLR Resets WDT Reset RESET Instruction Stack Resets = 00--. BRGCON3, MCLR Resets WDT Reset RESET Instruction Stack Resets = -000. BRGCON3, Wake-up via WDT or Interrupt = uu--. BRGCON3, Wake-up via WDT or Interrupt = -uuu. BRGCON2, Applicable Devices = PIC18F6X8X. BRGCON2, Applicable Devices = PIC18F8X8X. BRGCON2, Power-on Reset, Brown-out Reset = 0000. BRGCON2, Power-on Reset, Brown-out Reset = 0000. BRGCON2, MCLR Resets WDT Reset RESET Instruction Stack",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets = 0000. BRGCON2, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. BRGCON2, Wake-up via WDT or Interrupt = uuuu. BRGCON2, Wake-up via WDT or Interrupt = uuuu. BRGCON1, Applicable Devices = PIC18F6X8X. BRGCON1, Applicable Devices = PIC18F8X8X. BRGCON1, Power-on Reset, Brown-out Reset = 0000. BRGCON1, Power-on Reset, Brown-out Reset = 0000. BRGCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. BRGCON1, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. BRGCON1, Wake-up via WDT or Interrupt = uuuu. BRGCON1, Wake-up via WDT or Interrupt = uuuu. CANCON, Applicable Devices = PIC18F6X8X. CANCON, Applicable Devices = PIC18F8X8X.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nCANCON, Power-on Reset, Brown-out Reset = 1000. CANCON, Power-on Reset, Brown-out Reset = 000-. CANCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 1000. CANCON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 000-. CANCON, Wake-up via WDT or Interrupt = uuuu. CANCON, Wake-up via WDT or Interrupt = uuu-. CANSTAT, Applicable Devices = PIC18F6X8X. CANSTAT, Applicable Devices = PIC18F8X8X. CANSTAT, Power-on Reset, Brown-out Reset = 100-. CANSTAT, Power-on Reset, Brown-out Reset = 000-. CANSTAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 100-. CANSTAT, MCLR Resets WDT Reset RESET Instruction Stack Resets = 000-. CANSTAT, Wake-up via WDT or Interrupt = uuu-. CANSTAT, Wake-up via WDT or Interrupt = uuu-. RXB0D7, Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = PIC18F6X8X. RXB0D7, Applicable Devices = PIC18F8X8X. RXB0D7, Power-on Reset, Brown-out Reset = xxxx. RXB0D7, Power-on Reset, Brown-out Reset = xxxx. RXB0D7, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D7, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D7, Wake-up via WDT or Interrupt = uuuu. RXB0D7, Wake-up via WDT or Interrupt = uuuu. RXB0D6, Applicable Devices = PIC18F6X8X. RXB0D6, Applicable Devices = PIC18F8X8X. RXB0D6, Power-on Reset, Brown-out Reset = xxxx. RXB0D6, Power-on Reset, Brown-out Reset = xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0D6, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D6, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D6, Wake-up via WDT or Interrupt = uuuu. RXB0D6, Wake-up via WDT or Interrupt = uuuu. RXB0D5, Applicable Devices = PIC18F6X8X. RXB0D5, Applicable Devices = PIC18F8X8X. RXB0D5, Power-on Reset, Brown-out Reset = xxxx. RXB0D5, Power-on Reset, Brown-out Reset = xxxx. RXB0D5, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D5, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D5, Wake-up via WDT or Interrupt = uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0D5, Wake-up via WDT or Interrupt = uuuu. RXB0D4, Applicable Devices = PIC18F6X8X. RXB0D4, Applicable Devices = PIC18F8X8X. RXB0D4, Power-on Reset, Brown-out Reset = xxxx. RXB0D4, Power-on Reset, Brown-out Reset = xxxx. RXB0D4, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D4, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D4, Wake-up via WDT or Interrupt = uuuu. RXB0D4, Wake-up via WDT or Interrupt = uuuu. RXB0D3, Applicable Devices = PIC18F6X8X. RXB0D3, Applicable Devices = PIC18F8X8X. RXB0D3, Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nxxxx. RXB0D3, Power-on Reset, Brown-out Reset = xxxx. RXB0D3, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D3, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D3, Wake-up via WDT or Interrupt = uuuu. RXB0D3, Wake-up via WDT or Interrupt = uuuu. RXB0D2, Applicable Devices = PIC18F6X8X. RXB0D2, Applicable Devices = PIC18F8X8X. RXB0D2, Power-on Reset, Brown-out Reset = xxxx. RXB0D2, Power-on Reset, Brown-out Reset = xxxx. RXB0D2, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D2, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0D2, Wake-up via WDT or Interrupt = uuuu. RXB0D2, Wake-up via WDT or Interrupt = uuuu. RXB0D1, Applicable Devices = PIC18F6X8X. RXB0D1, Applicable Devices = PIC18F8X8X. RXB0D1, Power-on Reset, Brown-out Reset = xxxx. RXB0D1, Power-on Reset, Brown-out Reset = xxxx. RXB0D1, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D1, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D1, Wake-up via WDT or Interrupt = uuuu. RXB0D1, Wake-up via WDT or Interrupt = uuuu. RXB0D0, Applicable Devices = PIC18F6X8X. RXB0D0, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. RXB0D0, Power-on Reset, Brown-out Reset = xxxx. RXB0D0, Power-on Reset, Brown-out Reset = xxxx. RXB0D0, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D0, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D0, Wake-up via WDT or Interrupt = uuuu. RXB0D0, Wake-up via WDT or Interrupt = uuuu. RXB0DLC, Applicable Devices = PIC18F6X8X. RXB0DLC, Applicable Devices = PIC18F8X8X. RXB0DLC, Power-on Reset, Brown-out Reset = -xxx. RXB0DLC, Power-on Reset, Brown-out Reset = xxxx. RXB0DLC, MCLR Resets WDT Reset RESET Instruction Stack Resets = -uuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0DLC, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB0DLC, Wake-up via WDT or Interrupt = -uuu. RXB0DLC, Wake-up via WDT or Interrupt = uuuu\nLegend:\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0EIDL, Applicable Devices = PIC18F6X8X. RXB0EIDL, Applicable Devices = PIC18F8X8X. RXB0EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB0EIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXB0EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXB0EIDH, Applicable Devices = PIC18F6X8X. RXB0EIDH, Applicable Devices = PIC18F8X8X. RXB0EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB0EIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXB0EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXB0SIDL, Applicable Devices = PIC18F6X8X.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0SIDL, Applicable Devices = PIC18F8X8X. RXB0SIDL, Power-on Reset, Brown-out Reset = xxxx x-xx. RXB0SIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu u-uu. RXB0SIDL, Wake-up via WDT or Interrupt = uuuu u-uu. RXB0SIDH, Applicable Devices = PIC18F6X8X. RXB0SIDH, Applicable Devices = PIC18F8X8X. RXB0SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB0SIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXB0SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXB0CON, Applicable Devices = PIC18F6X8X. RXB0CON, Applicable Devices = PIC18F8X8X.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0CON, Power-on Reset, Brown-out Reset = 000- 0000 000-. RXB0CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. RXB0CON, Wake-up via WDT or Interrupt = uuu- uuuu. RXB1D7, Applicable Devices = PIC18F6X8X. RXB1D7, Applicable Devices = PIC18F8X8X. RXB1D7, Power-on Reset, Brown-out Reset = xxxx xxxx uuuu. RXB1D7, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D7, Wake-up via WDT or Interrupt = uuuu uuuu. RXB1D6, Applicable Devices = PIC18F6X8X. RXB1D6, Applicable Devices = PIC18F8X8X. RXB1D6, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB1D6, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXB1D6, Wake-up via WDT or Interrupt = uuuu uuuu. RXB1D5, Applicable Devices = PIC18F6X8X. RXB1D5, Applicable Devices = PIC18F8X8X. RXB1D5, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1D5, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXB1D5, Wake-up via WDT or Interrupt = uuuu uuuu. RXB1D4, Applicable Devices = PIC18F6X8X. RXB1D4, Applicable Devices = PIC18F8X8X xxxx. RXB1D4, Power-on Reset, Brown-out Reset = xxxx. RXB1D4, MCLR Resets WDT Reset RESET Instruction Stack",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets = uuuu uuuu. RXB1D4, Wake-up via WDT or Interrupt = uuuu uuuu. RXB1D3, Applicable Devices = PIC18F6X8X. RXB1D3, Applicable Devices = PIC18F8X8X. RXB1D3, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1D3, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXB1D3, Wake-up via WDT or Interrupt = uuuu uuuu. RXB1D2, Applicable Devices = PIC18F6X8X. RXB1D2, Applicable Devices = PIC18F8X8X. RXB1D2, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1D2, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB1D2, Wake-up via WDT or Interrupt = uuuu uuuu. RXB1D1, Applicable Devices = PIC18F6X8X. RXB1D1, Applicable Devices = PIC18F8X8X. RXB1D1, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1D1, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXB1D1, Wake-up via WDT or Interrupt = uuuu uuuu. RXB1D0, Applicable Devices = PIC18F6X8X. RXB1D0, Applicable Devices = PIC18F8X8X. RXB1D0, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1D0, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXB1D0, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. RXB1DLC, Applicable Devices = PIC18F6X8X. RXB1DLC, Applicable Devices = PIC18F8X8X. RXB1DLC, Power-on Reset, Brown-out Reset = -xxx xxxx. RXB1DLC, MCLR Resets WDT Reset RESET Instruction Stack Resets = -uuu uuuu. RXB1DLC, Wake-up via WDT or Interrupt = -uuu uuuu. RXB1EIDL, Applicable Devices = PIC18F6X8X. RXB1EIDL, Applicable Devices = PIC18F8X8X. RXB1EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1EIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXB1EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXB1EIDH, Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = PIC18F6X8X. RXB1EIDH, Applicable Devices = PIC18F8X8X. RXB1EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1EIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXB1EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXB1SIDL, Applicable Devices = PIC18F6X8X. RXB1SIDL, Applicable Devices = PIC18F8X8X. RXB1SIDL, Power-on Reset, Brown-out Reset = xxxx x-xx uuuu. RXB1SIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = u-uu. RXB1SIDL, Wake-up via WDT or Interrupt = uuuu u-uu. RXB1SIDH, Applicable Devices = PIC18F6X8X. RXB1SIDH,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices = PIC18F8X8X. RXB1SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1SIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXB1SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXB1CON, Applicable Devices = PIC18F6X8X. RXB1CON, Applicable Devices = PIC18F8X8X. RXB1CON, Power-on Reset, Brown-out Reset = 000- 0000. RXB1CON, MCLR Resets WDT Reset RESET Instruction Stack Resets = 000- 0000. RXB1CON, Wake-up via WDT or Interrupt = uuu- uuuu. TXB0D7, Applicable Devices = PIC18F6X8X. TXB0D7, Applicable Devices = PIC18F8X8X. TXB0D7, Power-on Reset, Brown-out Reset = xxxx",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nxxxx. TXB0D7, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB0D7, Wake-up via WDT or Interrupt = uuuu uuuu. TXB0D6, Applicable Devices = PIC18F6X8X. TXB0D6, Applicable Devices = PIC18F8X8X. TXB0D6, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D6, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB0D6, Wake-up via WDT or Interrupt = uuuu uuuu. TXB0D5, Applicable Devices = PIC18F6X8X. TXB0D5, Applicable Devices = PIC18F8X8X. TXB0D5, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D5, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. TXB0D5, Wake-up via WDT or Interrupt = uuuu uuuu. TXB0D4, Applicable Devices = PIC18F6X8X. TXB0D4, Applicable Devices = PIC18F8X8X. TXB0D4, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D4, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB0D4, Wake-up via WDT or Interrupt = uuuu uuuu. TXB0D3, Applicable Devices = PIC18F6X8X. TXB0D3, Applicable Devices = PIC18F8X8X. TXB0D3, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D3, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB0D3, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. , Applicable Devices = PIC18F6X8X. , Applicable Devices = . , Power-on Reset, Brown-out Reset = xxxx xxxx. , MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. , Wake-up via WDT or Interrupt = uuuu uuuu. TXB0D2, Applicable Devices = . TXB0D2, Applicable Devices = PIC18F8X8X. TXB0D2, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D2, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB0D2, Wake-up via WDT or Interrupt = uuuu uuuu. TXB0D1, Applicable Devices = PIC18F6X8X. TXB0D1, Applicable Devices = PIC18F8X8X. TXB0D1, Power-on Reset, Brown-out Reset = . TXB0D1, MCLR Resets",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset RESET Instruction Stack Resets = . TXB0D1, Wake-up via WDT or Interrupt = . TXB0DLC TXB0EIDL, Applicable Devices = PIC18F6X8X. TXB0DLC TXB0EIDL, Applicable Devices = PIC18F8X8X PIC18F8X8X. TXB0DLC TXB0EIDL, Power-on Reset, Brown-out Reset = -x-- xxxx. TXB0DLC TXB0EIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB0DLC TXB0EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. , Applicable Devices = PIC18F6X8X. , Applicable Devices = . , Power-on Reset, Brown-out Reset = xxxx xxxx. , MCLR Resets WDT Reset RESET Instruction Stack Resets = -u-- uuuu. , Wake-up via WDT or Interrupt = -u-- uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB0EIDH, Applicable Devices = PIC18F6X8X PIC18F6X8X. TXB0EIDH, Applicable Devices = PIC18F8X8X. TXB0EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0EIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu uuu- u-uu. TXB0EIDH, Wake-up via WDT or Interrupt = -uuu uuu- u-uu. TXB0SIDL, Applicable Devices = . TXB0SIDL, Applicable Devices = PIC18F8X8X. TXB0SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. TXB0SIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = . TXB0SIDL, Wake-up via WDT or Interrupt = \nLegend:",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 ', q = value depends on condition.\nShaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB0SIDH, Applicable Devices = PIC18F6X8X. TXB0SIDH, Applicable Devices = PIC18F8X8X. TXB0SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0SIDH, WDT Reset RESET Instruction = uuuu uuuu. TXB0SIDH, Wake-up via WDT or Interrupt = uuuu. TXB0SIDH, Wake-up via WDT or Interrupt = uuuu. TXB0CON, Applicable Devices = PIC18F6X8X. TXB0CON, Applicable Devices = PIC18F8X8X. TXB0CON, Power-on Reset, Brown-out Reset = 0000 0-00. TXB0CON, WDT Reset RESET Instruction = 0000 0-00. TXB0CON, Wake-up via WDT or Interrupt = uuuu. TXB0CON, Wake-up via WDT or Interrupt = u-uu. TXB1D7, Applicable Devices = PIC18F6X8X.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB1D7, Applicable Devices = PIC18F8X8X. TXB1D7, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1D7, WDT Reset RESET Instruction = uuuu uuuu. TXB1D7, Wake-up via WDT or Interrupt = uuuu. TXB1D7, Wake-up via WDT or Interrupt = uuuu. TXB1D6, Applicable Devices = PIC18F6X8X. TXB1D6, Applicable Devices = PIC18F8X8X. TXB1D6, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1D6, WDT Reset RESET Instruction = uuuu uuuu. TXB1D6, Wake-up via WDT or Interrupt = uuuu. TXB1D6, Wake-up via WDT or Interrupt = uuuu. TXB1D5, Applicable Devices = PIC18F6X8X. TXB1D5, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. TXB1D5, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1D5, WDT Reset RESET Instruction = uuuu uuuu. TXB1D5, Wake-up via WDT or Interrupt = uuuu. TXB1D5, Wake-up via WDT or Interrupt = uuuu. TXB1D4, Applicable Devices = PIC18F6X8X. TXB1D4, Applicable Devices = PIC18F8X8X. TXB1D4, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1D4, WDT Reset RESET Instruction = uuuu uuuu. TXB1D4, Wake-up via WDT or Interrupt = uuuu. TXB1D4, Wake-up via WDT or Interrupt = uuuu. TXB1D3, Applicable Devices = PIC18F6X8X. TXB1D3, Applicable Devices = PIC18F8X8X.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB1D3, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1D3, WDT Reset RESET Instruction = uuuu uuuu. TXB1D3, Wake-up via WDT or Interrupt = uuuu. TXB1D3, Wake-up via WDT or Interrupt = uuuu. TXB1D2, Applicable Devices = PIC18F6X8X. TXB1D2, Applicable Devices = PIC18F8X8X. TXB1D2, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1D2, WDT Reset RESET Instruction = uuuu uuuu. TXB1D2, Wake-up via WDT or Interrupt = uuuu. TXB1D2, Wake-up via WDT or Interrupt = uuuu. TXB1D1, Applicable Devices = PIC18F6X8X. TXB1D1, Applicable Devices = PIC18F8X8X. TXB1D1, Power-on",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset = xxxx xxxx. TXB1D1, WDT Reset RESET Instruction = uuuu uuuu. TXB1D1, Wake-up via WDT or Interrupt = uuuu. TXB1D1, Wake-up via WDT or Interrupt = uuuu. TXB1D0, Applicable Devices = PIC18F6X8X. TXB1D0, Applicable Devices = PIC18F8X8X. TXB1D0, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1D0, WDT Reset RESET Instruction = uuuu uuuu. TXB1D0, Wake-up via WDT or Interrupt = uuuu. TXB1D0, Wake-up via WDT or Interrupt = uuuu. TXB1DLC, Applicable Devices = PIC18F6X8X. TXB1DLC, Applicable Devices = PIC18F8X8X. TXB1DLC, Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n-x-- xxxx. TXB1DLC, WDT Reset RESET Instruction = -u-- uuuu. TXB1DLC, Wake-up via WDT or Interrupt = -u--. TXB1DLC, Wake-up via WDT or Interrupt = uuuu. TXB1EIDL, Applicable Devices = PIC18F6X8X. TXB1EIDL, Applicable Devices = PIC18F8X8X. TXB1EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1EIDL, WDT Reset RESET Instruction = uuuu uuuu. TXB1EIDL, Wake-up via WDT or Interrupt = uuuu. TXB1EIDL, Wake-up via WDT or Interrupt = uuuu. TXB1EIDH, Applicable Devices = PIC18F6X8X. TXB1EIDH, Applicable Devices = PIC18F8X8X. TXB1EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB1EIDH, WDT Reset RESET Instruction = uuuu uuuu. TXB1EIDH, Wake-up via WDT or Interrupt = uuuu. TXB1EIDH, Wake-up via WDT or Interrupt = uuuu. TXB1SIDL, Applicable Devices = PIC18F6X8X. TXB1SIDL, Applicable Devices = PIC18F8X8X. TXB1SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. TXB1SIDL, WDT Reset RESET Instruction = uuu- u-uu. TXB1SIDL, Wake-up via WDT or Interrupt = uuu-. TXB1SIDL, Wake-up via WDT or Interrupt = uu-u. TXB1SIDH, Applicable Devices = PIC18F6X8X. TXB1SIDH, Applicable Devices = PIC18F8X8X. TXB1SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB1SIDH, WDT",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset RESET Instruction = uuuu uuuu. TXB1SIDH, Wake-up via WDT or Interrupt = -uuu. TXB1SIDH, Wake-up via WDT or Interrupt = uuuu. TXB1CON, Applicable Devices = PIC18F6X8X. TXB1CON, Applicable Devices = PIC18F8X8X. TXB1CON, Power-on Reset, Brown-out Reset = 0000 0-00. TXB1CON, WDT Reset RESET Instruction = 0000 0-00. TXB1CON, Wake-up via WDT or Interrupt = uuuu. TXB1CON, Wake-up via WDT or Interrupt = u-uu. TXB2D7, Applicable Devices = PIC18F6X8X. TXB2D7, Applicable Devices = PIC18F8X8X. TXB2D7, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D7, WDT Reset RESET Instruction = uuuu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB2D7, Wake-up via WDT or Interrupt = 0uuu. TXB2D7, Wake-up via WDT or Interrupt = uuuu. TXB2D6, Applicable Devices = PIC18F6X8X. TXB2D6, Applicable Devices = PIC18F8X8X. TXB2D6, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D6, WDT Reset RESET Instruction = uuuu uuuu. TXB2D6, Wake-up via WDT or Interrupt = 0uuu. TXB2D6, Wake-up via WDT or Interrupt = uuuu. TXB2D5, Applicable Devices = PIC18F6X8X. TXB2D5, Applicable Devices = PIC18F8X8X. TXB2D5, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D5, WDT Reset RESET Instruction = uuuu uuuu. TXB2D5, Wake-up via",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = 0uuu. TXB2D5, Wake-up via WDT or Interrupt = uuuu. TXB2D4, Applicable Devices = PIC18F6X8X. TXB2D4, Applicable Devices = PIC18F8X8X. TXB2D4, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D4, WDT Reset RESET Instruction = uuuu uuuu. TXB2D4, Wake-up via WDT or Interrupt = 0uuu. TXB2D4, Wake-up via WDT or Interrupt = uuuu. TXB2D3, Applicable Devices = PIC18F6X8X. TXB2D3, Applicable Devices = PIC18F8X8X. TXB2D3, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D3, WDT Reset RESET Instruction = uuuu uuuu. TXB2D3, Wake-up via WDT or Interrupt = 0uuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB2D3, Wake-up via WDT or Interrupt = uuuu. TXB2D2, Applicable Devices = PIC18F6X8X. TXB2D2, Applicable Devices = PIC18F8X8X. TXB2D2, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D2, WDT Reset RESET Instruction = uuuu uuuu. TXB2D2, Wake-up via WDT or Interrupt = 0uuu. TXB2D2, Wake-up via WDT or Interrupt = uuuu. TXB2D1, Applicable Devices = PIC18F6X8X. TXB2D1, Applicable Devices = PIC18F8X8X. TXB2D1, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D1, WDT Reset RESET Instruction = uuuu uuuu. TXB2D1, Wake-up via WDT or Interrupt = 0uuu. TXB2D1, Wake-up via",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu. TXB2D0, Applicable Devices = PIC18F6X8X. TXB2D0, Applicable Devices = PIC18F8X8X. TXB2D0, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D0, WDT Reset RESET Instruction = uuuu uuuu. TXB2D0, Wake-up via WDT or Interrupt = 0uuu. TXB2D0, Wake-up via WDT or Interrupt = uuuu. TXB2DLC, Applicable Devices = PIC18F6X8X. TXB2DLC, Applicable Devices = PIC18F8X8X. TXB2DLC, Power-on Reset, Brown-out Reset = -x-- xxxx. TXB2DLC, WDT Reset RESET Instruction = -u-- uuuu. TXB2DLC, Wake-up via WDT or Interrupt = -u--. TXB2DLC, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. TXB2EIDL, Applicable Devices = PIC18F6X8X. TXB2EIDL, Applicable Devices = PIC18F8X8X. TXB2EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2EIDL, WDT Reset RESET Instruction = uuuu uuuu. TXB2EIDL, Wake-up via WDT or Interrupt = uuuu. TXB2EIDL, Wake-up via WDT or Interrupt = uuuu. TXB2EIDH, Applicable Devices = PIC18F6X8X. TXB2EIDH, Applicable Devices = PIC18F8X8X. TXB2EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2EIDH, WDT Reset RESET Instruction = uuuu uuuu. TXB2EIDH, Wake-up via WDT or Interrupt = uuuu. TXB2EIDH, Wake-up via WDT or Interrupt = uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB2SIDL, Applicable Devices = PIC18F6X8X. TXB2SIDL, Applicable Devices = PIC18F8X8X. TXB2SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. TXB2SIDL, WDT Reset RESET Instruction = uuu- u-uu. TXB2SIDL, Wake-up via WDT or Interrupt = uuu-. TXB2SIDL, Wake-up via WDT or Interrupt = u-uu. TXB2SIDH, Applicable Devices = PIC18F6X8X. TXB2SIDH, Applicable Devices = PIC18F8X8X. TXB2SIDH, Power-on Reset, Brown-out Reset = xxx- x-xx. TXB2SIDH, WDT Reset RESET Instruction = uuu- u-uu. TXB2SIDH, Wake-up via WDT or Interrupt = uuu-. TXB2SIDH, Wake-up via WDT or Interrupt = u-uu. , Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F6X8X. , Applicable Devices = PIC18F8X8X. , Power-on Reset, Brown-out Reset = xxxx. , WDT Reset RESET Instruction = uuuu. , Wake-up via WDT or Interrupt = uuuu. , Wake-up via WDT or Interrupt = uuuu. RXM1EIDL, Applicable Devices = . RXM1EIDL, Applicable Devices = . RXM1EIDL, Power-on Reset, Brown-out Reset = xxxx. RXM1EIDL, WDT Reset RESET Instruction = uuuu. RXM1EIDL, Wake-up via WDT or Interrupt = . RXM1EIDL, Wake-up via WDT or Interrupt = \nLegend: = unchanged, = unknown, - = unimplemented bit, read as ' ', = value depends on condition.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nu x 0 q Shaded cells indicate conditions do not apply for the designated device.\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXM1EIDH, Applicable Devices = PIC18F6X8X. RXM1EIDH, Applicable Devices = PIC18F8X8X. RXM1EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM1EIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXM1EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXM1SIDL, Applicable Devices = PIC18F6X8X. RXM1SIDL, Applicable Devices = PIC18F8X8X. RXM1SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXM1SIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuu- u-uu. RXM1SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXM1SIDH, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F6X8X. RXM1SIDH, Applicable Devices = PIC18F8X8X. RXM1SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM1SIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXM1SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXM0EIDL, Applicable Devices = PIC18F6X8X. RXM0EIDL, Applicable Devices = PIC18F8X8X. RXM0EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM0EIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXM0EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXM0EIDH, Applicable Devices = PIC18F6X8X. RXM0EIDH, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. RXM0EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM0EIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXM0EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXM0SIDL, Applicable Devices = PIC18F6X8X. RXM0SIDL, Applicable Devices = PIC18F8X8X. RXM0SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXM0SIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuu- u-uu. RXM0SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXM0SIDH, Applicable Devices = PIC18F6X8X. RXM0SIDH, Applicable Devices = PIC18F8X8X. RXM0SIDH,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = xxxx xxxx. RXM0SIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXM0SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF5EIDL, Applicable Devices = PIC18F6X8X. RXF5EIDL, Applicable Devices = PIC18F8X8X. RXF5EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF5EIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF5EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF5EIDH, Applicable Devices = PIC18F6X8X. RXF5EIDH, Applicable Devices = PIC18F8X8X. RXF5EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF5EIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF5EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF5SIDL, Applicable Devices = PIC18F6X8X. RXF5SIDL, Applicable Devices = PIC18F8X8X. RXF5SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF5SIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuu- u-uu. RXF5SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF5SIDH, Applicable Devices = PIC18F6X8X. RXF5SIDH, Applicable Devices = PIC18F8X8X. RXF5SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF5SIDH, MCLR Resets WDT Reset RESET Instruction",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nStack Resets = uuuu uuuu. RXF5SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF4EIDL, Applicable Devices = PIC18F6X8X. RXF4EIDL, Applicable Devices = PIC18F8X8X. RXF4EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF4EIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF4EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF4EIDH, Applicable Devices = PIC18F6X8X. RXF4EIDH, Applicable Devices = PIC18F8X8X. RXF4EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF4EIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF4EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF4SIDL, Applicable Devices = PIC18F6X8X. RXF4SIDL, Applicable Devices = PIC18F8X8X. RXF4SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF4SIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuu- u-uu. RXF4SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF4SIDH, Applicable Devices = PIC18F6X8X. RXF4SIDH, Applicable Devices = PIC18F8X8X. RXF4SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF4SIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF4SIDH, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. RXF3EIDL, Applicable Devices = PIC18F6X8X. RXF3EIDL, Applicable Devices = PIC18F8X8X. RXF3EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF3EIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF3EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF3EIDH, Applicable Devices = PIC18F6X8X. RXF3EIDH, Applicable Devices = PIC18F8X8X. RXF3EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF3EIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF3EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF3SIDL, Applicable Devices",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= PIC18F6X8X. RXF3SIDL, Applicable Devices = PIC18F8X8X. RXF3SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF3SIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuu- u-uu. RXF3SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF3SIDH, Applicable Devices = PIC18F6X8X. RXF3SIDH, Applicable Devices = PIC18F8X8X. RXF3SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF3SIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF3SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF2EIDL, Applicable Devices = PIC18F6X8X. RXF2EIDL,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices = PIC18F8X8X. RXF2EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF2EIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF2EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF2EIDH, Applicable Devices = PIC18F6X8X. RXF2EIDH, Applicable Devices = PIC18F8X8X. RXF2EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF2EIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF2EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF2SIDL, Applicable Devices = PIC18F6X8X. RXF2SIDL, Applicable Devices = PIC18F8X8X. RXF2SIDL,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = xxx- x-xx. RXF2SIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuu- u-uu. RXF2SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF2SIDH, Applicable Devices = PIC18F6X8X. RXF2SIDH, Applicable Devices = PIC18F8X8X. RXF2SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF2SIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF2SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF1EIDL, Applicable Devices = PIC18F6X8X. RXF1EIDL, Applicable Devices = PIC18F8X8X. RXF1EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF1EIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF1EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF1EIDH, Applicable Devices = PIC18F6X8X. RXF1EIDH, Applicable Devices = PIC18F8X8X. RXF1EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF1EIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF1EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF1SIDL, Applicable Devices = PIC18F6X8X. RXF1SIDL, Applicable Devices = PIC18F8X8X. RXF1SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF1SIDL, MCLR Resets WDT Reset RESET Instruction",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nStack Resets = uuu- u-uu. RXF1SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF1SIDH, Applicable Devices = PIC18F6X8X. RXF1SIDH, Applicable Devices = PIC18F8X8X. RXF1SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF1SIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF1SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF0EIDL, Applicable Devices = PIC18F6X8X. RXF0EIDL, Applicable Devices = PIC18F8X8X. RXF0EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF0EIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF0EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF0EIDH, Applicable Devices = PIC18F6X8X. RXF0EIDH, Applicable Devices = PIC18F8X8X. RXF0EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF0EIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF0EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF0SIDH, Applicable Devices = PIC18F6X8X. RXF0SIDH, Applicable Devices = PIC18F8X8X. RXF0SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF0SIDH, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF0SIDH, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. RXF0SIDL, Applicable Devices = PIC18F6X8X. RXF0SIDL, Applicable Devices = PIC18F8X8X. RXF0SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF0SIDL, MCLR Resets WDT Reset RESET Instruction Stack Resets = uuu- u-uu. RXF0SIDL, Wake-up via WDT or Interrupt = uuu- u-uu\nLegend:\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB5D7 (7), Applicable Devices = PIC18F6X8X. B5D7 (7), Applicable Devices = PIC18F8X8X. B5D7 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D7 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B5D7 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D7 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D6 (7), Applicable Devices = PIC18F6X8X. B5D6 (7), Applicable Devices = PIC18F8X8X. B5D6 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D6 (7), Power-on Reset, Brown-out Reset = uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. B5D6 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D6 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D5 (7), Applicable Devices = PIC18F6X8X. B5D5 (7), Applicable Devices = PIC18F8X8X. B5D5 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D5 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B5D5 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D5 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D4 (7), Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F6X8X. B5D4 (7), Applicable Devices = PIC18F8X8X. B5D4 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D4 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B5D4 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D4 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D3 (7), Applicable Devices = PIC18F6X8X. B5D3 (7), Applicable Devices = PIC18F8X8X. B5D3 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D3 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B5D3 (7),",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D3 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D2 (7), Applicable Devices = PIC18F6X8X. B5D2 (7), Applicable Devices = PIC18F8X8X. B5D2 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D2 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B5D2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D1 (7), Applicable Devices = PIC18F6X8X. B5D1",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Applicable Devices = PIC18F8X8X. B5D1 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D1 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B5D1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5D0 (7), Applicable Devices = PIC18F6X8X. B5D0 (7), Applicable Devices = PIC18F8X8X. B5D0 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B5D0 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B5D0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu. B5D0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5DLC (7), Applicable Devices = PIC18F6X8X. B5DLC (7), Applicable Devices = PIC18F8X8X. B5DLC (7), Power-on Reset, Brown-out Reset = -xxx xxxx. B5DLC (7), Power-on Reset, Brown-out Reset = -uuu uuuu. B5DLC (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = -uuu. B5DLC (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5EIDL (7), Applicable Devices = PIC18F6X8X. B5EIDL (7), Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. B5EIDL (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B5EIDL (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B5EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5EIDH (7), Applicable Devices = PIC18F6X8X. B5EIDH (7), Applicable Devices = PIC18F8X8X. B5EIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B5EIDH (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B5EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= uuuu. B5EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5SIDL (7), Applicable Devices = PIC18F6X8X. B5SIDL (7), Applicable Devices = PIC18F8X8X. B5SIDL (7), Power-on Reset, Brown-out Reset = xxxx x-xx. B5SIDL (7), Power-on Reset, Brown-out Reset = uuuu u-uu. B5SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = u-uu. B5SIDH (7), Applicable Devices = PIC18F6X8X. B5SIDH (7), Applicable Devices = PIC18F8X8X. B5SIDH",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Power-on Reset, Brown-out Reset = xxxx x-xx. B5SIDH (7), Power-on Reset, Brown-out Reset = uuuu u-uu. B5SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = u-uu. B5CON (7), Applicable Devices = PIC18F6X8X. B5CON (7), Applicable Devices = PIC18F8X8X. B5CON (7), Power-on Reset, Brown-out Reset = 0000 0000. B5CON (7), Power-on Reset, Brown-out Reset = 0000 0000. B5CON (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B5CON (7), MCLR Resets WDT Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D7 (7), Applicable Devices = PIC18F6X8X. B4D7 (7), Applicable Devices = PIC18F8X8X. B4D7 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B4D7 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B4D7 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D7 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D6 (7), Applicable Devices = PIC18F6X8X. B4D6 (7), Applicable Devices = PIC18F8X8X. B4D6 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B4D6",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Power-on Reset, Brown-out Reset = uuuu uuuu. B4D6 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D6 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D5 (7), Applicable Devices = PIC18F6X8X. B4D5 (7), Applicable Devices = PIC18F8X8X. B4D5 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B4D5 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B4D5 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D5 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. B4D4 (7), Applicable Devices = PIC18F6X8X. B4D4 (7), Applicable Devices = PIC18F8X8X. B4D4 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B4D4 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B4D4 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D4 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D3 (7), Applicable Devices = PIC18F6X8X. B4D3 (7), Applicable Devices = PIC18F8X8X. B4D3 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B4D3 (7), Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. B4D3 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D3 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D2 (7), Applicable Devices = PIC18F6X8X. B4D2 (7), Applicable Devices = PIC18F8X8X. B4D2 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B4D2 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B4D2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D1 (7), Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = PIC18F6X8X. B4D1 (7), Applicable Devices = PIC18F8X8X. B4D1 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B4D1 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B4D1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D0 (7), Applicable Devices = PIC18F6X8X. B4D0 (7), Applicable Devices = PIC18F8X8X. B4D0 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B4D0 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B4D0",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4D0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4DLC (7), Applicable Devices = PIC18F6X8X. B4DLC (7), Applicable Devices = PIC18F8X8X. B4DLC (7), Power-on Reset, Brown-out Reset = -xxx xxxx. B4DLC (7), Power-on Reset, Brown-out Reset = -uuu uuuu. B4DLC (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = -uuu. B4DLC (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4EIDL (7), Applicable Devices = PIC18F6X8X.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB4EIDL (7), Applicable Devices = PIC18F8X8X. B4EIDL (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B4EIDL (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B4EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4EIDH (7), Applicable Devices = PIC18F6X8X. B4EIDH (7), Applicable Devices = PIC18F8X8X. B4EIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B4EIDH (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B4EIDH (7), MCLR Resets WDT Reset RESET Instruction",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nStack Resets Wake-up via WDT or Interrupt = uuuu. B4EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4SIDL (7), Applicable Devices = PIC18F6X8X. B4SIDL (7), Applicable Devices = PIC18F8X8X. B4SIDL (7), Power-on Reset, Brown-out Reset = xxxx x-xx. B4SIDL (7), Power-on Reset, Brown-out Reset = uuuu u-uu. B4SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = u-uu. B4SIDH (7), Applicable Devices = PIC18F6X8X. B4SIDH (7), Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. B4SIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B4SIDH (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B4SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B4SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D7 (7), Applicable Devices = PIC18F6X8X. B3D7 (7), Applicable Devices = PIC18F8X8X. B3D7 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B3D7 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B3D7 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. B3D7 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. (7), Applicable Devices = . (7), Applicable Devices = . (7), Power-on Reset, Brown-out Reset = . (7), Power-on Reset, Brown-out Reset = . (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = . (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D5 (7), Applicable Devices = PIC18F6X8X. B3D5 (7), Applicable Devices = PIC18F8X8X. B3D5 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B3D5 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B3D5 (7), MCLR Resets WDT Reset RESET Instruction Stack",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nResets Wake-up via WDT or Interrupt = uuuu. B3D5 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D6, Applicable Devices = PIC18F6X8X. B3D6, Applicable Devices = PIC18F8X8X. B3D6, Power-on Reset, Brown-out Reset = xxxx xxxx. B3D6, Power-on Reset, Brown-out Reset = uuuu uuuu. B3D6, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D6, MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = \nLegend:\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB3D4 (7), Applicable Devices = PIC18F6X8X. B3D4 (7), Applicable Devices = PIC18F8X8X. B3D4 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B3D4 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B3D4 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D4 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D3 (7), Applicable Devices = PIC18F6X8X. B3D3 (7), Applicable Devices = PIC18F8X8X. B3D3 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B3D3 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B3D3 (7),",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D3 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D2 (7), Applicable Devices = PIC18F6X8X. B3D2 (7), Applicable Devices = PIC18F8X8X. B3D2 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B3D2 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B3D2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D1 (7), Applicable Devices = PIC18F6X8X. B3D1 (7), Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. B3D1 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B3D1 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B3D1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D0 (7), Applicable Devices = PIC18F6X8X. B3D0 (7), Applicable Devices = PIC18F8X8X. B3D0 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B3D0 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B3D0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3D0",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3DLC (7), Applicable Devices = PIC18F6X8X. B3DLC (7), Applicable Devices = PIC18F8X8X. B3DLC (7), Power-on Reset, Brown-out Reset = -xxx xxxx. B3DLC (7), Power-on Reset, Brown-out Reset = -uuu uuuu. B3DLC (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = -uuu. B3DLC (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3EIDL (7), Applicable Devices = PIC18F6X8X. B3EIDL (7), Applicable Devices = PIC18F8X8X. B3EIDL (7), Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB3EIDL (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B3EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3EIDH (7), Applicable Devices = PIC18F6X8X. B3EIDH (7), Applicable Devices = PIC18F8X8X. B3EIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B3EIDH (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B3EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT or Interrupt = uuuu. B3SIDL (7), Applicable Devices = PIC18F6X8X. B3SIDL (7), Applicable Devices = PIC18F8X8X. B3SIDL (7), Power-on Reset, Brown-out Reset = xxxx x-xx. B3SIDL (7), Power-on Reset, Brown-out Reset = uuuu u-uu. B3SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = u-uu. B3SIDH (7), Applicable Devices = PIC18F6X8X. B3SIDH (7), Applicable Devices = PIC18F8X8X. B3SIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B3SIDH (7), Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = uuuu uuuu. B3SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3CON (7), Applicable Devices = PIC18F6X8X. B3CON (7), Applicable Devices = PIC18F8X8X. B3CON (7), Power-on Reset, Brown-out Reset = 0000 0000. B3CON (7), Power-on Reset, Brown-out Reset = 0000 0000. B3CON (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B3CON (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D7 (7), Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F6X8X. B2D7 (7), Applicable Devices = PIC18F8X8X. B2D7 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B2D7 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B2D7 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D7 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D6 (7), Applicable Devices = PIC18F6X8X. B2D6 (7), Applicable Devices = PIC18F8X8X. B2D6 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B2D6 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B2D6 (7),",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D6 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D5 (7), Applicable Devices = PIC18F6X8X. B2D5 (7), Applicable Devices = PIC18F8X8X. B2D5 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B2D5 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B2D5 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D5 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D4 (7), Applicable Devices = PIC18F6X8X. B2D4",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Applicable Devices = PIC18F8X8X. B2D4 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B2D4 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B2D4 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D4 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D3 (7), Applicable Devices = PIC18F6X8X. B2D3 (7), Applicable Devices = PIC18F8X8X. B2D3 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B2D3 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B2D3 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu. B2D3 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D2 (7), Applicable Devices = PIC18F6X8X. B2D2 (7), Applicable Devices = PIC18F8X8X. B2D2 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B2D2 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B2D2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D1 (7), Applicable Devices = PIC18F6X8X. B2D1 (7), Applicable Devices = PIC18F8X8X.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB2D1 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B2D1 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B2D1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2D0 (7), Applicable Devices = PIC18F6X8X. B2D0 (7), Applicable Devices = PIC18F8X8X. B2D0 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B2D0 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B2D0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB2D0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2DLC (7), Applicable Devices = PIC18F6X8X. B2DLC (7), Applicable Devices = PIC18F8X8X. B2DLC (7), Power-on Reset, Brown-out Reset = -xxx xxxx. B2DLC (7), Power-on Reset, Brown-out Reset = -uuu uuuu. B2DLC (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = -uuu. B2DLC (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2EIDL (7), Applicable Devices = PIC18F6X8X. B2EIDL (7), Applicable Devices = PIC18F8X8X. B2EIDL (7), Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = xxxx xxxx. B2EIDL (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B2EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2EIDH (7), Applicable Devices = PIC18F6X8X. B2EIDH (7), Applicable Devices = PIC18F8X8X. B2EIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B2EIDH (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B2EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2EIDH (7), MCLR Resets WDT Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2SIDL (7), Applicable Devices = PIC18F6X8X. B2SIDL (7), Applicable Devices = PIC18F8X8X. B2SIDL (7), Power-on Reset, Brown-out Reset = xxxx x-xx. B2SIDL (7), Power-on Reset, Brown-out Reset = uuuu u-uu. B2SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = u-uu. B2SIDH (7), Applicable Devices = PIC18F6X8X. B2SIDH (7), Applicable Devices = PIC18F8X8X. B2SIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B2SIDH",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Power-on Reset, Brown-out Reset = uuuu uuuu. B2SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2CON (7), Applicable Devices = PIC18F6X8X. B2CON (7), Applicable Devices = PIC18F8X8X. B2CON (7), Power-on Reset, Brown-out Reset = 0000 0000. B2CON (7), Power-on Reset, Brown-out Reset = 0000 0000. B2CON (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B2CON (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B1D7",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Applicable Devices = PIC18F6X8X. B1D7 (7), Applicable Devices = PIC18F8X8X. B1D7 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B1D7 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B1D7 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B1D7 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B1D6 (7), Applicable Devices = PIC18F6X8X. B1D6 (7), Applicable Devices = PIC18F8X8X. B1D6 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B1D6 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B1D6 (7), MCLR Resets",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B1D6 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B1D5 (7), Applicable Devices = PIC18F6X8X. B1D5 (7), Applicable Devices = PIC18F8X8X. B1D5 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B1D5 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B1D5 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B1D5 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B1D4 (7), Applicable Devices = PIC18F6X8X. B1D4 (7), Applicable Devices = PIC18F8X8X.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB1D4 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B1D4 (7), Power-on Reset, Brown-out Reset = uuuu uuuu. B1D4 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B1D4 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B1D2 (7), Applicable Devices = PIC18F6X8X. B1D2 (7), Applicable Devices = PIC18F8X8X. B1D2 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B1D2 (7), Power-on Reset, Brown-out Reset = uuuu. B1D2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B1D2 (7), MCLR Resets WDT Reset RESET",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInstruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B1D3 (7), Applicable Devices = PIC18F6X8X. B1D3 (7), Applicable Devices = PIC18F8X8X. B1D3 (7), Power-on Reset, Brown-out Reset = xxxx xxxx. B1D3 (7), Power-on Reset, Brown-out Reset = uuuu uuuu uuuu. B1D3 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. B1D3 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu\nLegend:\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB1D1 (7), Applicable Devices = PIC18F6X8X. B1D1 (7), Applicable Devices = PIC18F8X8X. B1D1 (7), Power-on Reset, Brown-out Reset = xxxx. B1D1 (7), Power-on Reset, Brown-out Reset = xxxx. B1D1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B1D1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B1D1 (7), Wake-up via WDT or Interrupt = uuuu. B1D1 (7), Wake-up via WDT or Interrupt = uuuu. B1D0 (7), Applicable Devices = PIC18F6X8X. B1D0 (7), Applicable Devices = PIC18F8X8X. B1D0 (7), Power-on Reset, Brown-out Reset = xxxx. B1D0 (7), Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nxxxx. B1D0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B1D0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B1D0 (7), Wake-up via WDT or Interrupt = uuuu. B1D0 (7), Wake-up via WDT or Interrupt = uuuu. B1DLC (7), Applicable Devices = PIC18F6X8X. B1DLC (7), Applicable Devices = PIC18F8X8X. B1DLC (7), Power-on Reset, Brown-out Reset = -xxx. B1DLC (7), Power-on Reset, Brown-out Reset = xxxx. B1DLC (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = -uuu. B1DLC (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B1DLC (7), Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n-uuu. B1DLC (7), Wake-up via WDT or Interrupt = uuuu. B1EIDL (7), Applicable Devices = PIC18F6X8X. B1EIDL (7), Applicable Devices = PIC18F8X8X. B1EIDL (7), Power-on Reset, Brown-out Reset = xxxx. B1EIDL (7), Power-on Reset, Brown-out Reset = xxxx. B1EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B1EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B1EIDL (7), Wake-up via WDT or Interrupt = uuuu. B1EIDL (7), Wake-up via WDT or Interrupt = uuuu. B1EIDH (7), Applicable Devices = PIC18F6X8X. B1EIDH (7), Applicable Devices = PIC18F8X8X. B1EIDH (7), Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = xxxx. B1EIDH (7), Power-on Reset, Brown-out Reset = xxxx. B1EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B1EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B1EIDH (7), Wake-up via WDT or Interrupt = uuuu. B1EIDH (7), Wake-up via WDT or Interrupt = uuuu. B1SIDL (7), Applicable Devices = PIC18F6X8X. B1SIDL (7), Applicable Devices = PIC18F8X8X. B1SIDL (7), Power-on Reset, Brown-out Reset = xxxx. B1SIDL (7), Power-on Reset, Brown-out Reset = x-xx. B1SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B1SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nu-uu. B1SIDL (7), Wake-up via WDT or Interrupt = uuuu. B1SIDL (7), Wake-up via WDT or Interrupt = u-uu. B1SIDH (7), Applicable Devices = PIC18F6X8X. B1SIDH (7), Applicable Devices = PIC18F8X8X. B1SIDH (7), Power-on Reset, Brown-out Reset = xxxx. B1SIDH (7), Power-on Reset, Brown-out Reset = xxxx. B1SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B1SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B1SIDH (7), Wake-up via WDT or Interrupt = uuuu. B1SIDH (7), Wake-up via WDT or Interrupt = uuuu. B1CON (7), Applicable Devices = PIC18F6X8X. B1CON (7), Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. B1CON (7), Power-on Reset, Brown-out Reset = 0000. B1CON (7), Power-on Reset, Brown-out Reset = 0000. B1CON (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. B1CON (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. B1CON (7), Wake-up via WDT or Interrupt = uuuu. B1CON (7), Wake-up via WDT or Interrupt = uuuu. B0D7 (7), Applicable Devices = PIC18F6X8X. B0D7 (7), Applicable Devices = PIC18F8X8X. B0D7 (7), Power-on Reset, Brown-out Reset = xxxx. B0D7 (7), Power-on Reset, Brown-out Reset = xxxx. B0D7 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D7",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D7 (7), Wake-up via WDT or Interrupt = uuuu. B0D7 (7), Wake-up via WDT or Interrupt = uuuu. B0D6 (7), Applicable Devices = PIC18F6X8X. B0D6 (7), Applicable Devices = PIC18F8X8X. B0D6 (7), Power-on Reset, Brown-out Reset = xxxx. B0D6 (7), Power-on Reset, Brown-out Reset = xxxx. B0D6 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D6 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D6 (7), Wake-up via WDT or Interrupt = uuuu. B0D6 (7), Wake-up via WDT or Interrupt = uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nB0D5 (7), Applicable Devices = PIC18F6X8X. B0D5 (7), Applicable Devices = PIC18F8X8X. B0D5 (7), Power-on Reset, Brown-out Reset = xxxx. B0D5 (7), Power-on Reset, Brown-out Reset = xxxx. B0D5 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D5 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D5 (7), Wake-up via WDT or Interrupt = uuuu. B0D5 (7), Wake-up via WDT or Interrupt = uuuu. B0D4 (7), Applicable Devices = PIC18F6X8X. B0D4 (7), Applicable Devices = PIC18F8X8X. B0D4 (7), Power-on Reset, Brown-out Reset = xxxx. B0D4",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Power-on Reset, Brown-out Reset = xxxx. B0D4 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D4 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D4 (7), Wake-up via WDT or Interrupt = uuuu. B0D4 (7), Wake-up via WDT or Interrupt = uuuu. B0D3 (7), Applicable Devices = PIC18F6X8X. B0D3 (7), Applicable Devices = PIC18F8X8X. B0D3 (7), Power-on Reset, Brown-out Reset = xxxx. B0D3 (7), Power-on Reset, Brown-out Reset = xxxx. B0D3 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D3 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. B0D3 (7), Wake-up via WDT or Interrupt = uuuu. B0D3 (7), Wake-up via WDT or Interrupt = uuuu. B0D2 (7), Applicable Devices = PIC18F6X8X. B0D2 (7), Applicable Devices = PIC18F8X8X. B0D2 (7), Power-on Reset, Brown-out Reset = xxxx. B0D2 (7), Power-on Reset, Brown-out Reset = xxxx. B0D2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D2 (7), Wake-up via WDT or Interrupt = uuuu. B0D2 (7), Wake-up via WDT or Interrupt = uuuu. B0D1 (7), Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F6X8X. B0D1 (7), Applicable Devices = PIC18F8X8X. B0D1 (7), Power-on Reset, Brown-out Reset = xxxx. B0D1 (7), Power-on Reset, Brown-out Reset = xxxx. B0D1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D1 (7), Wake-up via WDT or Interrupt = uuuu. B0D1 (7), Wake-up via WDT or Interrupt = uuuu. B0D0 (7), Applicable Devices = PIC18F6X8X. B0D0 (7), Applicable Devices = PIC18F8X8X. B0D0 (7), Power-on Reset, Brown-out Reset = xxxx. B0D0 (7), Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nxxxx. B0D0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0D0 (7), Wake-up via WDT or Interrupt = uuuu. B0D0 (7), Wake-up via WDT or Interrupt = uuuu. B0DLC (7), Applicable Devices = PIC18F6X8X. B0DLC (7), Applicable Devices = PIC18F8X8X. B0DLC (7), Power-on Reset, Brown-out Reset = -xxx. B0DLC (7), Power-on Reset, Brown-out Reset = xxxx. B0DLC (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = -uuu. B0DLC (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0DLC (7),",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = -uuu. B0DLC (7), Wake-up via WDT or Interrupt = uuuu. B0EIDL (7), Applicable Devices = PIC18F6X8X. B0EIDL (7), Applicable Devices = PIC18F8X8X. B0EIDL (7), Power-on Reset, Brown-out Reset = xxxx. B0EIDL (7), Power-on Reset, Brown-out Reset = xxxx. B0EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0EIDL (7), Wake-up via WDT or Interrupt = uuuu. B0EIDL (7), Wake-up via WDT or Interrupt = uuuu. B0EIDH (7), Applicable Devices = PIC18F6X8X. B0EIDH (7), Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. B0EIDH (7), Power-on Reset, Brown-out Reset = xxxx. B0EIDH (7), Power-on Reset, Brown-out Reset = xxxx. B0EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0EIDH (7), Wake-up via WDT or Interrupt = uuuu. B0EIDH (7), Wake-up via WDT or Interrupt = uuuu. B0SIDL (7), Applicable Devices = PIC18F6X8X. B0SIDL (7), Applicable Devices = PIC18F8X8X. B0SIDL (7), Power-on Reset, Brown-out Reset = xxxx. B0SIDL (7), Power-on Reset, Brown-out Reset = x-xx. B0SIDL (7), MCLR Resets WDT Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRESET Instruction Stack Resets = uuuu. B0SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = u-uu. B0SIDL (7), Wake-up via WDT or Interrupt = uuuu. B0SIDL (7), Wake-up via WDT or Interrupt = u-uu. B0SIDH (7), Applicable Devices = PIC18F6X8X. B0SIDH (7), Applicable Devices = PIC18F8X8X. B0SIDH (7), Power-on Reset, Brown-out Reset = xxxx. B0SIDH (7), Power-on Reset, Brown-out Reset = xxxx. B0SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. B0SIDH (7), Wake-up via WDT or Interrupt = uuuu. B0SIDH",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Wake-up via WDT or Interrupt = uuuu. B0CON (7), Applicable Devices = PIC18F6X8X. B0CON (7), Applicable Devices = PIC18F8X8X. B0CON (7), Power-on Reset, Brown-out Reset = 0000. B0CON (7), Power-on Reset, Brown-out Reset = 0000. B0CON (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. B0CON (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. B0CON (7), Wake-up via WDT or Interrupt = uuuu. B0CON (7), Wake-up via WDT or Interrupt = uuuu. TXBIE (7), Applicable Devices = PIC18F6X8X. TXBIE (7), Applicable Devices = PIC18F8X8X. TXBIE (7), Power-on Reset, Brown-out Reset = ---0. TXBIE",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Power-on Reset, Brown-out Reset = 00--. TXBIE (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = ---u. TXBIE (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uu--. TXBIE (7), Wake-up via WDT or Interrupt = ---u. TXBIE (7), Wake-up via WDT or Interrupt = uu--. BIE0 (7), Applicable Devices = PIC18F6X8X. BIE0 (7), Applicable Devices = PIC18F8X8X. BIE0 (7), Power-on Reset, Brown-out Reset = 0000. BIE0 (7), Power-on Reset, Brown-out Reset = 0000. BIE0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. BIE0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. BIE0 (7), Wake-up via WDT or",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInterrupt = uuuu. BIE0 (7), Wake-up via WDT or Interrupt = uuuu. BSEL0 (7), Applicable Devices = PIC18F6X8X. BSEL0 (7), Applicable Devices = PIC18F8X8X. BSEL0 (7), Power-on Reset, Brown-out Reset = 0000. BSEL0 (7), Power-on Reset, Brown-out Reset = 00--. BSEL0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. BSEL0 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 00--. BSEL0 (7), Wake-up via WDT or Interrupt = uuuu. BSEL0 (7), Wake-up via WDT or Interrupt = uu--. MSEL3 (7), Applicable Devices = PIC18F6X8X. MSEL3 (7), Applicable Devices = PIC18F8X8X. MSEL3 (7), Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = 0000. MSEL3 (7), Power-on Reset, Brown-out Reset = 0000. MSEL3 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. MSEL3 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. MSEL3 (7), Wake-up via WDT or Interrupt = uuuu. MSEL3 (7), Wake-up via WDT or Interrupt = uuuu. MSEL2 (7), Applicable Devices = PIC18F6X8X. MSEL2 (7), Applicable Devices = PIC18F8X8X. MSEL2 (7), Power-on Reset, Brown-out Reset = 0000. MSEL2 (7), Power-on Reset, Brown-out Reset = 0000. MSEL2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. MSEL2 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. MSEL2",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Wake-up via WDT or Interrupt = uuuu. MSEL2 (7), Wake-up via WDT or Interrupt = uuuu. MSEL1 (7), Applicable Devices = PIC18F6X8X. MSEL1 (7), Applicable Devices = PIC18F8X8X. MSEL1 (7), Power-on Reset, Brown-out Reset = 0000. MSEL1 (7), Power-on Reset, Brown-out Reset = 0101. MSEL1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. MSEL1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0101. MSEL1 (7), Wake-up via WDT or Interrupt = uuuu. MSEL1 (7), Wake-up via WDT or Interrupt = uuuu. MSEL0 (7) (7), Applicable Devices = PIC18F6X8X. MSEL0 (7) (7), Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. MSEL0 (7) (7), Power-on Reset, Brown-out Reset = 0101. MSEL0 (7) (7), Power-on Reset, Brown-out Reset = 0000. MSEL0 (7) (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0101. MSEL0 (7) (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. MSEL0 (7) (7), Wake-up via WDT or Interrupt = uuuu. MSEL0 (7) (7), Wake-up via WDT or Interrupt = uuuu. RXFCON1 (7), Applicable Devices = PIC18F6X8X. RXFCON1 (7), Applicable Devices = PIC18F8X8X. RXFCON1 (7), Power-on Reset, Brown-out Reset = 0000. RXFCON1 (7), Power-on Reset, Brown-out Reset = 0000.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXFCON1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = . RXFCON1 (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. RXFCON1 (7), Wake-up via WDT or Interrupt = uuuu. RXFCON1 (7), Wake-up via WDT or Interrupt = . , Applicable Devices = . , Applicable Devices = . , Power-on Reset, Brown-out Reset = . , Power-on Reset, Brown-out Reset = . , MCLR Resets WDT Reset RESET Instruction Stack Resets = 0000. , MCLR Resets WDT Reset RESET Instruction Stack Resets = . , Wake-up via WDT or Interrupt = . , Wake-up via WDT or Interrupt = uuuu\nLegend:\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXFCON0 (7), Applicable Devices = PIC18F6X8X. RXFCON0 (7), Applicable Devices = PIC18F8X8X. RXFCON0 (7), Power-on Reset, Brown-out Reset = 0000 0000. RXFCON0 (7), WDT Reset RESET Instruction = 0000 0000. RXFCON0 (7), Wake-up via WDT or Interrupt = uuuu. RXFCON0 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON7 (7), Applicable Devices = PIC18F6X8X. RXFBCON7 (7), Applicable Devices = PIC18F8X8X. RXFBCON7 (7), Power-on Reset, Brown-out Reset = 0000 0000. RXFBCON7 (7), WDT Reset RESET Instruction = 0000 0000. RXFBCON7 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON7",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Wake-up via WDT or Interrupt = uuuu. RXFBCON6 (7), Applicable Devices = PIC18F6X8X. RXFBCON6 (7), Applicable Devices = PIC18F8X8X. RXFBCON6 (7), Power-on Reset, Brown-out Reset = 0000 0000. RXFBCON6 (7), WDT Reset RESET Instruction = 0000 0000. RXFBCON6 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON6 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON5 (7), Applicable Devices = PIC18F6X8X. RXFBCON5 (7), Applicable Devices = PIC18F8X8X. RXFBCON5 (7), Power-on Reset, Brown-out Reset = 0000 0000. RXFBCON5 (7), WDT Reset RESET Instruction = 0000 0000. RXFBCON5 (7),",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu. RXFBCON5 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON4 (7), Applicable Devices = PIC18F6X8X. RXFBCON4 (7), Applicable Devices = PIC18F8X8X. RXFBCON4 (7), Power-on Reset, Brown-out Reset = 0000 0000. RXFBCON4 (7), WDT Reset RESET Instruction = 0000 0000. RXFBCON4 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON4 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON3 (7), Applicable Devices = PIC18F6X8X. RXFBCON3 (7), Applicable Devices = PIC18F8X8X. RXFBCON3 (7), Power-on Reset, Brown-out Reset = 0000 0000. RXFBCON3 (7), WDT",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset RESET Instruction = 0000 0000. RXFBCON3 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON3 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON2 (7), Applicable Devices = PIC18F6X8X. RXFBCON2 (7), Applicable Devices = PIC18F8X8X. RXFBCON2 (7), Power-on Reset, Brown-out Reset = 0001 0001. RXFBCON2 (7), WDT Reset RESET Instruction = 0001 0001. RXFBCON2 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON2 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON1 (7), Applicable Devices = PIC18F6X8X. RXFBCON1 (7), Applicable Devices = PIC18F8X8X. RXFBCON1 (7), Power-on Reset, Brown-out",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset = 0001 0001. RXFBCON1 (7), WDT Reset RESET Instruction = 0001 0001. RXFBCON1 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON1 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON0 (7), Applicable Devices = PIC18F6X8X. RXFBCON0 (7), Applicable Devices = PIC18F8X8X. RXFBCON0 (7), Power-on Reset, Brown-out Reset = 0000 0000. RXFBCON0 (7), WDT Reset RESET Instruction = 0000 0000. RXFBCON0 (7), Wake-up via WDT or Interrupt = uuuu. RXFBCON0 (7), Wake-up via WDT or Interrupt = uuuu. RXF15EIDL (7), Applicable Devices = PIC18F6X8X. RXF15EIDL (7), Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F8X8X. RXF15EIDL (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF15EIDL (7), WDT Reset RESET Instruction = uuuu uuuu. RXF15EIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF15EIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF15EIDH (7), Applicable Devices = PIC18F6X8X. RXF15EIDH (7), Applicable Devices = PIC18F8X8X. RXF15EIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF15EIDH (7), WDT Reset RESET Instruction = uuuu uuuu. RXF15EIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF15EIDH (7), Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. RXF15SIDL (7), Applicable Devices = PIC18F6X8X. RXF15SIDL (7), Applicable Devices = PIC18F8X8X. RXF15SIDL (7), Power-on Reset, Brown-out Reset = xxx- x-xx. RXF15SIDL (7), WDT Reset RESET Instruction = uuu- u-uu. RXF15SIDL (7), Wake-up via WDT or Interrupt = uuu-. RXF15SIDL (7), Wake-up via WDT or Interrupt = u-uu. RXF15SIDH (7), Applicable Devices = PIC18F6X8X. RXF15SIDH (7), Applicable Devices = PIC18F8X8X. RXF15SIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF15SIDH (7), WDT Reset RESET Instruction = uuuu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF15SIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF15SIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF14EIDL (7), Applicable Devices = PIC18F6X8X. RXF14EIDL (7), Applicable Devices = PIC18F8X8X. RXF14EIDL (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF14EIDL (7), WDT Reset RESET Instruction = uuuu uuuu. RXF14EIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF14EIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF14EIDH (7), Applicable Devices = PIC18F6X8X. RXF14EIDH (7), Applicable Devices = PIC18F8X8X. RXF14EIDH (7),",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = xxxx xxxx. RXF14EIDH (7), WDT Reset RESET Instruction = uuuu uuuu. RXF14EIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF14EIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF14SIDL (7), Applicable Devices = PIC18F6X8X. RXF14SIDL (7), Applicable Devices = PIC18F8X8X. RXF14SIDL (7), Power-on Reset, Brown-out Reset = xxx- x-xx. RXF14SIDL (7), WDT Reset RESET Instruction = uuu- u-uu. RXF14SIDL (7), Wake-up via WDT or Interrupt = uuu-. RXF14SIDL (7), Wake-up via WDT or Interrupt = u-uu. RXF14SIDH (7), Applicable Devices",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= PIC18F6X8X. RXF14SIDH (7), Applicable Devices = PIC18F8X8X. RXF14SIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF14SIDH (7), WDT Reset RESET Instruction = uuuu uuuu. RXF14SIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF14SIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF13EIDL (7), Applicable Devices = PIC18F6X8X. RXF13EIDL (7), Applicable Devices = PIC18F8X8X. RXF13EIDL (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF13EIDL (7), WDT Reset RESET Instruction = uuuu uuuu. RXF13EIDL (7), Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. RXF13EIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF13EIDH (7), Applicable Devices = PIC18F6X8X. RXF13EIDH (7), Applicable Devices = PIC18F8X8X. RXF13EIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF13EIDH (7), WDT Reset RESET Instruction = uuuu uuuu. RXF13EIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF13EIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF13SIDL (7), Applicable Devices = PIC18F6X8X. RXF13SIDL (7), Applicable Devices = PIC18F8X8X. RXF13SIDL (7), Power-on Reset, Brown-out Reset = xxx- x-xx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF13SIDL (7), WDT Reset RESET Instruction = uuu- u-uu. RXF13SIDL (7), Wake-up via WDT or Interrupt = uuu-. RXF13SIDL (7), Wake-up via WDT or Interrupt = u-uu. RXF13SIDH (7), Applicable Devices = PIC18F6X8X. RXF13SIDH (7), Applicable Devices = PIC18F8X8X. RXF13SIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF13SIDH (7), WDT Reset RESET Instruction = uuuu uuuu. RXF13SIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF13SIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF12EIDL (7), Applicable Devices = PIC18F6X8X. RXF12EIDL",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Applicable Devices = PIC18F8X8X. RXF12EIDL (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF12EIDL (7), WDT Reset RESET Instruction = uuuu uuuu. RXF12EIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF12EIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF12EIDH (7), Applicable Devices = PIC18F6X8X. RXF12EIDH (7), Applicable Devices = PIC18F8X8X. RXF12EIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF12EIDH (7), WDT Reset RESET Instruction = uuuu uuuu. RXF12EIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF12EIDH (7), Wake-up",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nvia WDT or Interrupt = uuuu. RXF12SIDL (7), Applicable Devices = PIC18F6X8X. RXF12SIDL (7), Applicable Devices = PIC18F8X8X. RXF12SIDL (7), Power-on Reset, Brown-out Reset = xxx- x-xx. RXF12SIDL (7), WDT Reset RESET Instruction = uuu- u-uu. RXF12SIDL (7), Wake-up via WDT or Interrupt = uuu-. RXF12SIDL (7), Wake-up via WDT or Interrupt = u-uu. RXF12SIDH (7), Applicable Devices = PIC18F6X8X. RXF12SIDH (7), Applicable Devices = PIC18F8X8X. RXF12SIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF12SIDH (7), WDT Reset RESET Instruction = uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. RXF12SIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF12SIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF11EIDL (7), Applicable Devices = PIC18F6X8X. RXF11EIDL (7), Applicable Devices = PIC18F8X8X. RXF11EIDL (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF11EIDL (7), WDT Reset RESET Instruction = uuuu uuuu. RXF11EIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF11EIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF11EIDH (7), Applicable Devices = PIC18F6X8X. RXF11EIDH (7), Applicable Devices = PIC18F8X8X. RXF11EIDH",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF11EIDH (7), WDT Reset RESET Instruction = uuuu uuuu. RXF11EIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF11EIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF11SIDL (7), Applicable Devices = PIC18F6X8X. RXF11SIDL (7), Applicable Devices = PIC18F8X8X. RXF11SIDL (7), Power-on Reset, Brown-out Reset = xxx- x-xx. RXF11SIDL (7), WDT Reset RESET Instruction = uuu- u-uu. RXF11SIDL (7), Wake-up via WDT or Interrupt = uuu-. RXF11SIDL (7), Wake-up via WDT or Interrupt = u-uu. RXF11SIDH",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Applicable Devices = PIC18F6X8X. RXF11SIDH (7), Applicable Devices = PIC18F8X8X. RXF11SIDH (7), Power-on Reset, Brown-out Reset = xxxx xxxx. RXF11SIDH (7), WDT Reset RESET Instruction = uuuu uuuu. RXF11SIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF11SIDH (7), Wake-up via WDT or Interrupt = uuuu. (7), Applicable Devices = . (7), Applicable Devices = PIC18F8X8X. (7), Power-on Reset, Brown-out Reset = xxxx xxxx. (7), WDT Reset RESET Instruction = uuuu. (7), Wake-up via WDT or Interrupt = -uuu. (7), Wake-up via WDT or Interrupt = uuuu. RXF10EIDH, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F6X8X. RXF10EIDH, Applicable Devices = . RXF10EIDH, Power-on Reset, Brown-out Reset = . RXF10EIDH, WDT Reset RESET Instruction = uuuu. RXF10EIDH, Wake-up via WDT or Interrupt = . RXF10EIDH, Wake-up via WDT or Interrupt = \nLegend:\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF10SIDL (7), Applicable Devices = PIC18F6X8X. RXF10SIDL (7), Applicable Devices = PIC18F8X8X. RXF10SIDL (7), Power-on Reset, Brown-out Reset = xxx-. RXF10SIDL (7), Power-on Reset, Brown-out Reset = x-xx. RXF10SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuu-. RXF10SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = u-uu. RXF10SIDL (7), Wake-up via WDT or Interrupt = -uuu. RXF10SIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF10SIDH (7), Applicable Devices = PIC18F6X8X. RXF10SIDH (7), Applicable Devices = PIC18F8X8X. RXF10SIDH",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Power-on Reset, Brown-out Reset = xxxx. RXF10SIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF10SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF10SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF10SIDH (7), Wake-up via WDT or Interrupt = -uuu. RXF10SIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF9EIDL (7), Applicable Devices = PIC18F6X8X. RXF9EIDL (7), Applicable Devices = PIC18F8X8X. RXF9EIDL (7), Power-on Reset, Brown-out Reset = xxxx. RXF9EIDL (7), Power-on Reset, Brown-out Reset = xxxx. RXF9EIDL (7),",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF9EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF9EIDL (7), Wake-up via WDT or Interrupt = -uuu. RXF9EIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF9EIDH (7), Applicable Devices = PIC18F6X8X. RXF9EIDH (7), Applicable Devices = PIC18F8X8X. RXF9EIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF9EIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF9EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF9EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF9EIDH (7), Wake-up via WDT or Interrupt = -uuu. RXF9EIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF9SIDL (7), Applicable Devices = PIC18F6X8X. RXF9SIDL (7), Applicable Devices = PIC18F8X8X. RXF9SIDL (7), Power-on Reset, Brown-out Reset = xxx-. RXF9SIDL (7), Power-on Reset, Brown-out Reset = x-xx. RXF9SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuu-. RXF9SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = u-uu. RXF9SIDL (7), Wake-up via WDT or Interrupt = -uuu. RXF9SIDL (7), Wake-up via WDT or Interrupt = uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF9SIDH (7), Applicable Devices = PIC18F6X8X. RXF9SIDH (7), Applicable Devices = PIC18F8X8X. RXF9SIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF9SIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF9SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF9SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF9SIDH (7), Wake-up via WDT or Interrupt = -uuu. RXF9SIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF8EIDL (7), Applicable Devices = PIC18F6X8X. RXF8EIDL (7), Applicable Devices = PIC18F8X8X. RXF8EIDL",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Power-on Reset, Brown-out Reset = xxxx. RXF8EIDL (7), Power-on Reset, Brown-out Reset = xxxx. RXF8EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF8EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF8EIDL (7), Wake-up via WDT or Interrupt = -uuu. RXF8EIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF8EIDH (7), Applicable Devices = PIC18F6X8X. RXF8EIDH (7), Applicable Devices = PIC18F8X8X. RXF8EIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF8EIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF8EIDH (7),",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF8EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF8EIDH (7), Wake-up via WDT or Interrupt = -uuu. RXF8EIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF8SIDL (7), Applicable Devices = PIC18F6X8X. RXF8SIDL (7), Applicable Devices = PIC18F8X8X. RXF8SIDL (7), Power-on Reset, Brown-out Reset = xxx-. RXF8SIDL (7), Power-on Reset, Brown-out Reset = x-xx. RXF8SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuu-. RXF8SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = u-uu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF8SIDL (7), Wake-up via WDT or Interrupt = -uuu. RXF8SIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF8SIDH (7), Applicable Devices = PIC18F6X8X. RXF8SIDH (7), Applicable Devices = PIC18F8X8X. RXF8SIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF8SIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF8SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF8SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF8SIDH (7), Wake-up via WDT or Interrupt = -uuu. RXF8SIDH (7), Wake-up via WDT or Interrupt = uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF7EIDL (7), Applicable Devices = PIC18F6X8X. RXF7EIDL (7), Applicable Devices = PIC18F8X8X. RXF7EIDL (7), Power-on Reset, Brown-out Reset = xxxx. RXF7EIDL (7), Power-on Reset, Brown-out Reset = xxxx. RXF7EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF7EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF7EIDL (7), Wake-up via WDT or Interrupt = -uuu. RXF7EIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF7EIDH (7), Applicable Devices = PIC18F6X8X. RXF7EIDH (7), Applicable Devices = PIC18F8X8X. RXF7EIDH",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Power-on Reset, Brown-out Reset = xxxx. RXF7EIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF7EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF7EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF7EIDH (7), Wake-up via WDT or Interrupt = -uuu. RXF7EIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF7SIDL (7), Applicable Devices = PIC18F6X8X. RXF7SIDL (7), Applicable Devices = PIC18F8X8X. RXF7SIDL (7), Power-on Reset, Brown-out Reset = xxx-. RXF7SIDL (7), Power-on Reset, Brown-out Reset = x-xx. RXF7SIDL",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuu-. RXF7SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = u-uu. RXF7SIDL (7), Wake-up via WDT or Interrupt = -uuu. RXF7SIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF7SIDH (7), Applicable Devices = PIC18F6X8X. RXF7SIDH (7), Applicable Devices = PIC18F8X8X. RXF7SIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF7SIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF7SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF7SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF7SIDH (7), Wake-up via WDT or Interrupt = -uuu. RXF7SIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF6EIDL (7), Applicable Devices = PIC18F6X8X. RXF6EIDL (7), Applicable Devices = PIC18F8X8X. RXF6EIDL (7), Power-on Reset, Brown-out Reset = xxxx. RXF6EIDL (7), Power-on Reset, Brown-out Reset = xxxx. RXF6EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF6EIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF6EIDL (7), Wake-up via WDT or Interrupt = -uuu. RXF6EIDL (7), Wake-up via WDT or Interrupt = uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF6EIDH (7), Applicable Devices = PIC18F6X8X. RXF6EIDH (7), Applicable Devices = PIC18F8X8X. RXF6EIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF6EIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF6EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF6EIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF6EIDH (7), Wake-up via WDT or Interrupt = -uuu. RXF6EIDH (7), Wake-up via WDT or Interrupt = uuuu. RXF6SIDL (7), Applicable Devices = PIC18F6X8X. RXF6SIDL (7), Applicable Devices = PIC18F8X8X. RXF6SIDL",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), Power-on Reset, Brown-out Reset = xxx-. RXF6SIDL (7), Power-on Reset, Brown-out Reset = x-xx. RXF6SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuu-. RXF6SIDL (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = u-uu. RXF6SIDL (7), Wake-up via WDT or Interrupt = -uuu. RXF6SIDL (7), Wake-up via WDT or Interrupt = uuuu. RXF6SIDH (7), Applicable Devices = PIC18F6X8X. RXF6SIDH (7), Applicable Devices = PIC18F8X8X. RXF6SIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF6SIDH (7), Power-on Reset, Brown-out Reset = xxxx. RXF6SIDH",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n(7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF6SIDH (7), MCLR Resets WDT Reset RESET Instruction Stack Resets = uuuu. RXF6SIDH (7), Wake-up via WDT or Interrupt = -uuu. RXF6SIDH (7), Wake-up via WDT or Interrupt = uuuu\nLegend:\nu = unchanged, x = unknown, - = unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.\nNote",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA, and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Bit 6 of PORTA, LATA and TRISA are not available on all devices. When unimplemented, they read ' 0 '.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n7: This register reads all ' 0 's until ECAN is set up in Mode 1 or Mode 2.",
    "PIC18F6585/8585/6680/8680\nFIGURE 3-4:\nTIME-OUT SEQUENCE ON POWER-UP (MCLR NOT TIED TO VDD): CASE 1",
    "4.0 MEMORY ORGANIZATION\nThere are three memory blocks in PIC18F6585/8585/6680/8680 devices. They are:",
    "4.1.1 PIC18F8X8X PROGRAM MEMORY MODES\n\u00b7 Program Memory\n\u00b7 Data RAM\n\u00b7 Data EEPROM\nData and program memory use separate busses which allows for concurrent access of these blocks. Additional detailed information for Flash program memory and data EEPROM is provided in Section 5.0 'Flash Program Memory' and Section 7.0 'Data EEPROM Memory' , respectively.\nIn addition to on-chip Flash, the PIC18F8X8X devices are also capable of accessing external program memory through an external memory bus. Depending on the selected operating mode (discussed in Section 4.1.1 'PIC18F8X8X Program Memory Modes' ), the controllers may access either internal or external program memory exclusively, or both internal and external memory in selected blocks. Additional information on the external memory interface is provided in Section 6.0 'External Memory Interface' .",
    "4.1 Program Memory Organization\nA 21-bit program counter is capable of addressing the 2-Mbyte program memory space. Accessing a location between the physically implemented memory and the 2-Mbyte address will cause a read of all ' 0 's  (a NOP instruction).\nThe PIC18F6585 and PIC18F8585 each have 48 Kbytes of on-chip Flash memory, while the PIC18F6680 and PIC18F8680 have 64 Kbytes of Flash. This means that PIC18FX585 devices can store internally up to 24,576 single-word instructions and PIC18FX680 devices can store up to 32,768 single-word instructions.\nThe Reset vector address is at 0000h and the interrupt vector addresses are at 0008h and 0018h.\nFigure 4-1 shows the program memory  map  for PIC18F6585/8585 devices while Figure 4-2 shows the program memory map for PIC18F6680/8680 devices.",
    "4.1 Program Memory Organization\nPIC18F8X8X  devices  differ  significantly  from  their PIC18  predecessors  in  their  utilization  of  program memory. In addition to available on-chip Flash program memory,  these  controllers  can  also  address  up  to 2 Mbytes  of  external  program  memory  through  the external  memory  interface.  There  are  four  distinct operating modes available to the controllers:\n\u00b7 Microprocessor (MP)\n\u00b7 Microprocessor with Boot Block (MPBB)\n\u00b7 Extended Microcontroller (EMC)\n\u00b7 Microcontroller (MC)\nThe Program Memory mode is determined by setting the two Least Significant bits of the CONFIG3L configuration  byte,  as  shown  in  Register 4-1.  (See  also Section 24.1 'Configuration Bits' for additional details on the device configuration bits.)\nThe Program Memory modes operate as follows:",
    "4.1 Program Memory Organization\n\u00b7 The Microprocessor Mode permits access only to external program memory; the contents of the on-chip Flash memory are ignored. The 21-bit program counter permits access to a 2-MByte linear program memory space.\n\u00b7 The Microprocessor with Boot Block Mode accesses on-chip Flash memory from addresses 000000h to 0007FFh. Above this, external program memory is accessed all the way up to the 2-MByte limit. Program execution automatically switches between the two memories as required.\n\u00b7 The Microcontroller Mode accesses only on-chip Flash memory. Attempts to read above the physical limit of the on-chip Flash (0BFFFh for the PIC18F8585, 0FFFFh for the PIC18F8680) causes a read of all ' 0 's (a NOP instruction). The Microcontroller mode is the only operating mode available to PIC18F6X8X devices.",
    "4.1 Program Memory Organization\n\u00b7 The Extended Microcontroller Mode allows access to both internal and external program memories as a single block. The device can access its entire on-chip Flash memory; above this, the device accesses external program memory up to the 2-MByte program space limit. As with Boot Block mode, execution automatically switches between the two memories as required.\nIn all modes, the microcontroller has complete access to data RAM and EEPROM.\nFigure 4-3 compares the memory maps of the different Program Memory modes. The differences between onchip and external memory access limitations are more fully explained in Table 4-1.",
    "PIC18F6585/8585/6680/8680\nFIGURE 4-1:\nINTERNAL PROGRAM MEMORY MAP AND STACK FOR PIC18F6585/8585\nFIGURE 4-2:\nINTERNAL PROGRAM MEMORY MAP AND STACK FOR PIC18F6680/8680",
    "TABLE 4-1: MEMORY ACCESS FOR PIC18F8X8X PROGRAM MEMORY MODES\nMicroprocessor, Internal Program Memory.Execution From = No Access. Microprocessor, Internal Program Memory.Table Read From = No Access. Microprocessor, Internal Program Memory.Table Write To = No Access. Microprocessor, External Program Memory.Execution From = Yes. Microprocessor, External Program Memory.Table Read From = Yes. Microprocessor, External Program Memory.Table Write To = Yes. Microprocessor w/ Boot Block, Internal Program Memory.Execution From = Yes. Microprocessor w/ Boot Block, Internal Program Memory.Table Read From = Yes. Microprocessor w/ Boot Block, Internal Program Memory.Table Write To = Yes. Microprocessor w/ Boot Block, External Program Memory.Execution From = Yes. Microprocessor w/ Boot Block, External Program Memory.Table Read From = Yes. Microprocessor w/ Boot Block, External Program Memory.Table Write To = Yes. Microcontroller, Internal Program Memory.Execution From = Yes. Microcontroller, Internal Program Memory.Table Read From = Yes. Microcontroller, Internal",
    "TABLE 4-1: MEMORY ACCESS FOR PIC18F8X8X PROGRAM MEMORY MODES\nProgram Memory.Table Write To = Yes. Microcontroller, External Program Memory.Execution From = No Access. Microcontroller, External Program Memory.Table Read From = No Access. Microcontroller, External Program Memory.Table Write To = No Access. Extended Microcontroller, Internal Program Memory.Execution From = Yes. Extended Microcontroller, Internal Program Memory.Table Read From = Yes. Extended Microcontroller, Internal Program Memory.Table Write To = Yes. Extended Microcontroller, External Program Memory.Execution From = Yes. Extended Microcontroller, External Program Memory.Table Read From = Yes. Extended Microcontroller, External Program Memory.Table Write To = Yes",
    "REGISTER 4-1:\nbit 7",
    "CONFIG3L CONFIGURATION BYTE\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = U-0. R/P-1, 6 = R/P-1. R/P-1, 7 = R/P-1. WAIT, 1 = -. WAIT, 2 = -. WAIT, 3 = -. WAIT, 4 = -. WAIT, 5 = -. WAIT, 6 = PM1. WAIT, 7 = PM0\nbit 7\nbit 0\nWAIT: External Bus Data Wait Enable bit\n1 = Wait selections unavailable, device will not wait\n0 = Wait programmed by WAIT1 and WAIT0 bits of MEMCOM register (MEMCOM<5:4>)\nbit 6-2 Unimplemented: Read as ' 0 '\nbit 1-0 PM1:PM0: Processor Data Memory Mode Select bits\n- 11 = Microcontroller mode\n10 = Microprocessor mode\n01 = Microcontroller with Boot Block mode\n- 00 = Extended Microcontroller mode",
    "Legend:\nR = Readable bit\nP = Programmable bit U = Unimplemented bit, read as '0'\n- n = Value after erase\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "FIGURE 4-3: MEMORY MAPS FOR PIC18F8X8X PROGRAM MEMORY MODES\n000000h External Program Memory External Memory,  = On-Chip Program Memory (No access). 000000h External Program Memory External Memory, Microprocessor with Boot Block Mode = 000800h 0007FFh 000000h. 000000h External Program Memory External Memory,  = 000000h On-Chip Program Memory 00FFFFh 00BFFFh 010000h 00C000h. 000000h External Program Memory External Memory, Microcontroller Mode = On-Chip Program Memory (2) (1) (2) (1). 000000h External Program Memory External Memory,  = 000000h 010000h (2) 00FFFFh (2) 00BFFFh (1) 00C000h (1). 000000h External Program Memory External Memory, Extended Microcontroller Mode = On-Chip Program Memory. 1FFFFFh,  = On-Chip. 1FFFFFh, Microprocessor with Boot Block Mode = 1FFFFFh. 1FFFFFh,",
    "FIGURE 4-3: MEMORY MAPS FOR PIC18F8X8X PROGRAM MEMORY MODES\n= On-Chip Flash. 1FFFFFh, Microcontroller Mode = 1FFFFFh. 1FFFFFh,  = 1FFFFFh. 1FFFFFh, Extended Microcontroller Mode = On-Chip Flash. Flash,  = . Flash, Microprocessor with Boot Block Mode = External Memory. Flash,  = . Flash, Microcontroller Mode = On-Chip Flash. Flash,  = External Memory. Flash, Extended Microcontroller Mode = ",
    "4.2 Return Address Stack\nThe return address stack allows any combination of up to  31  program  calls  and  interrupts  to  occur.  The  PC (Program Counter) is pushed onto the stack when a CALL or RCALL instruction is executed or an interrupt is Acknowledged. The PC value is pulled off the stack on a RETURN , RETLW ,  or a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN or CALL instructions.",
    "4.2.2 RETURN STACK POINTER (STKPTR)\nThe stack operates as a 31-word by 21-bit RAM and a 5-bit stack pointer, with the stack pointer initialized to 00000b after all Resets. There is no RAM associated with stack pointer 00000b. This is only a Reset value. During a CALL type instruction causing a push onto the stack,  the  stack  pointer  is  first  incremented  and  the RAM location pointed to by the stack pointer is written with  the  contents  of  the  PC.  During  a RETURN type instruction causing a pop from the stack, the contents of  the  RAM  location  pointed  to  by  the  STKPTR  are transferred  to  the  PC  and  then  the  stack  pointer  is decremented.\nThe stack space is not part of either program or data space. The stack pointer is readable and writable and the address on the top of the stack is readable and writable through SFR registers. Data can also be pushed to  or  popped  from  the  stack,  using  the  top-of-stack SFRs. Status bits indicate if the stack pointer is at or beyond the 31 levels provided.",
    "4.2.1 TOP-OF-STACK ACCESS\nThe top of the stack is readable and writable. Three register locations, TOSU, TOSH and TOSL, hold the contents  of the stack location pointed  to by  the STKPTR  register.  This  allows  users  to  implement  a software stack if necessary. After a CALL, RCALL or interrupt, the software can read the pushed value by reading the TOSU, TOSH and TOSL registers. These values can be placed on a user defined software stack. At  return  time,  the  software  can  replace  the  TOSU, TOSH and TOSL and do a return.\nThe user must disable the global interrupt enable bits during this time to prevent inadvertent stack operations.",
    "4.2.1 TOP-OF-STACK ACCESS\nThe STKPTR register contains the stack pointer value, the STKFUL (Stack Full) status bit, and the STKUNF (Stack  Underflow)  status  bits.  Register 4-2  shows  the STKPTR register. The value of the stack pointer can be 0 through 31. The stack pointer increments when values are pushed onto the stack and decrements when values are  popped off  the stack.  At  Reset,  the  stack  pointer value will be ' 0 '. The user may read and write the stack pointer value. This feature can be used by a Real-Time Operating System for return stack maintenance.\nAfter the PC is pushed onto the stack 31 times (without popping any values off the stack), the STKFUL bit is set. The STKFUL bit can only be cleared in software or by a POR.",
    "4.2.1 TOP-OF-STACK ACCESS\nThe action that takes place when the stack becomes full depends  on  the  state  of  the  STVREN  (Stack Overflow  Reset  Enable)  configuration  bit.  Refer  to Section 25.0 'Instruction Set Summary' for a description of the device configuration bits. If STVREN is  set  (default), the  31st push will  push the (PC + 2) value onto the stack, set the STKFUL bit and reset the device. The STKFUL bit will remain set and the stack pointer will be set to ' 0 '.\nIf STVREN is cleared, the STKFUL bit will be set on the 31st push and the stack pointer will increment to 31. Any additional pushes will not overwrite the 31st push and STKPTR will remain at 31.\nWhen  the  stack  has  been  popped  enough  times  to unload the stack, the next pop will return a value of zero to  the  PC  and  sets  the  STKUNF  bit  while  the  stack pointer remains at ' 0 '. The STKUNF bit will remain set until cleared in software or a POR occurs.",
    "Note:\nReturning a value of zero to the PC on an underflow has the effect of vectoring the program  to  the  Reset  vector,  where  the stack conditions can be verified and appropriate actions can be taken.",
    "REGISTER 4-2: STKPTR REGISTER\nR/C-0, 1 = R/C-0. R/C-0, 2 = U-0. R/C-0, 3 = R/W-0. R/C-0, 4 = R/W-0. R/C-0, 5 = R/W-0. R/C-0, 6 = R/W-0. R/C-0, 7 = R/W-0. STKFUL (1), 1 = STKUNF (1). STKFUL (1), 2 = -. STKFUL (1), 3 = SP4. STKFUL (1), 4 = SP3. STKFUL (1), 5 = SP2. STKFUL (1), 6 = SP1. STKFUL (1), 7 = SP0\nbit 7\nbit 0",
    "bit 7 STKFUL: Stack Full Flag bit\n1 = Stack became full or overflowed\n0 = Stack has not become full or overflowed",
    "bit 6 STKUNF: Stack Underflow Flag bit\n1 = Stack underflow occurred\n0 = Stack underflow did not occur\nbit 5 Unimplemented: Read as ' 0 '\nbit 4-0\nSP4:SP0: Stack Pointer Location bits\nNote 1: Bit 7 and bit 6 can only be cleared in user software or by a POR.\n- n = Value at POR, R = Readable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, read as '0' = '0' = Bit is cleared. - n = Value at POR, W=Writable bit = x = Bit is unknown",
    "4.2.4 STACK FULL/UNDERFLOW RESETS\nSince the Top-of-Stack (TOS) is readable and writable, the ability to push values onto the stack and pull values off the stack, without disturbing normal program execution, is a desirable option. To push the current PC value onto  the  stack,  a PUSH instruction  can  be  executed. This will increment the stack pointer and load the current PC value onto the stack. TOSU, TOSH and TOSL can then be modified to place a return address on the stack.\nThe ability to pull the TOS value off of the stack and replace  it  with  the  value  that  was  previously  pushed onto the stack, without disturbing normal execution, is achieved by using the POP instruction. The POP instruction  discards  the  current  TOS  by  decrementing  the stack  pointer.  The  previous  value  pushed  onto  the stack then becomes the TOS value.",
    "4.2.4 STACK FULL/UNDERFLOW RESETS\nThese  Resets are enabled by programming the STVREN configuration bit.  When  the  STVREN  bit  is disabled,  a  full  or  underflow  condition  will  set  the appropriate STKFUL or STKUNF bit, but not cause a device Reset. When the STVREN bit is enabled, a full or underflow condition will set the appropriate STKFUL or  STKUNF bit and then cause a device Reset. The STKFUL or STKUNF bits are only cleared by the user software or a POR Reset.",
    "4.3 Fast Register Stack\nA 'fast interrupt return' option is available for interrupts. A fast register stack is provided for the Status, WREG and BSR registers and is only one in depth. The stack is  not  readable  or  writable  and  is  loaded  with  the current value of the corresponding register when the processor vectors for an  interrupt.  The  values  in  the registers are then loaded back into the working registers if the FAST RETURN instruction is used to return from the interrupt.\nA low or high priority interrupt source will push values into  the  stack  registers.  If  both  low  and  high  priority interrupts  are  enabled,  the stack  registers  cannot  be used reliably for low priority interrupts. If a high priority interrupt occurs while servicing a low priority interrupt, the  stack  register  values  stored  by  the  low  priority interrupt will be overwritten.\nIf  high  priority  interrupts  are  not  disabled  during  low priority interrupts, users must save the key registers in software during a low priority interrupt.\nIf no interrupts are used, the fast register stack can be used to restore the Status, WREG and BSR registers at the end of a subroutine call.  To use the fast  register stack for a subroutine call, a FAST  CALL instruction must be executed.",
    "4.3 Fast Register Stack\nExample 4-1 shows a source code example that uses the fast register stack.",
    "4.4 PCL, PCLATH and PCLATU\nThe program counter (PC) specifies the address of the instruction  to  fetch  for  execution.  The  PC  is  21  bits wide. The low byte is called the PCL register; this register is readable and writable. The high byte is called the PCH register. This register contains the PC<15:8> bits and is not directly readable or writable; updates to the  PCH  register  may  be  performed  through  the PCLATH register. The upper byte is called PCU. This register contains the PC<20:16> bits and is not directly readable or writable; updates to the PCU register may be performed through the PCLATU register.\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the LSB of the PCL is fixed to a value of ' 0 '.  The  PC  increments  by  2  to  address  sequential instructions in the program memory.\nThe CALL, RCALL, GOTO and  program  branch instructions write to the program counter directly. For these instructions, the contents of PCLATH  and PCLATU are not transferred to the program counter.",
    "4.4 PCL, PCLATH and PCLATU\nThe contents of PCLATH and PCLATU will be transferred  to  the  program  counter  by  an  operation  that writes PCL. Similarly, the upper two bytes of the program  counter  will  be  transferred  to  PCLATH  and PCLATU by an operation that reads PCL. This is useful for  computed  offsets  to  the  PC  (see Section 4.8.1 'Computed GOTO' ).",
    "4.5 Clocking Scheme/Instruction Cycle\nThe clock  input  (from  OSC1)  is  internally  divided  by four to generate four non-overlapping quadrature clocks,  namely  Q1,  Q2,  Q3  and  Q4.  Internally,  the program  counter  (PC)  is  incremented  every  Q1,  the instruction  is  fetched  from  the  program  memory  and latched into the instruction register in Q4. The instruction is decoded and executed during the following Q1 through Q4. The clocks and instruction execution flow are shown in Figure 4-5.",
    "4.6 Instruction Flow/Pipelining\nAn 'Instruction  Cycle'  consists  of  four  Q  cycles  (Q1, Q2, Q3 and Q4). The instruction fetch and execute are pipelined  such  that fetch  takes  one  instruction cycle, while  decode  and  execute  takes  another  instruction cycle. However, due to the pipelining each instruction effectively  executes  in  one  cycle.  If  an  instruction causes the program counter to change (e.g., GOTO ), then two cycles are required to complete the instruction (Example 4-2).\nA  fetch  cycle  begins  with  the  program  counter  (PC) incrementing in Q1.\nIn the execution cycle, the fetched instruction is latched into  the  'Instruction  Register'  (IR)  in  cycle  Q1.  This instruction  is  then  decoded  and  executed  during  the Q2, Q3, and Q4 cycles. Data memory is read during Q2 (operand  read)  and  written  during  Q4  (destination write).",
    "EXAMPLE 4-2: INSTRUCTION PIPELINE FLOW\nAll instructions are single cycle except for any program branches. These take two cycles since the fetch instruction is 'flushed' from the pipeline while the new instruction is being fetched and then executed.",
    "4.7 Instructions in Program Memory\nThe program memory is addressed in bytes. Instructions are stored as two bytes or four bytes in program memory.  The  Least  Significant  Byte  (LSB)  of  an instruction word is always stored in a program memory location  with  an  even  address  (LSB  = 0 ).  Figure 4-6 shows an example of how instruction words are stored in  the  program  memory.  To  maintain  alignment  with instruction boundaries, the PC increments in steps of 2 and  the  LSB  will  always  read  ' 0 ' (see Section 4.4 'PCL, PCLATH and PCLATU' ).",
    "4.7 Instructions in Program Memory\nThe CALL and GOTO instructions have an absolute program memory address embedded into the instruction. Since instructions are always stored on word boundaries,  the  data  contained  in  the  instruction  is  a  word address.  The  word  address  is  written  to  PC<20:1> which accesses the desired byte address in program memory. Instruction  #2  in  Figure 4-6  shows  how  the instruction ' GOTO 000006h ' is encoded in the program memory. Program branch instructions which encode a relative  address  offset  operate  in  the  same  manner. The offset value stored in a branch instruction represents the number of single-word instructions that the PC  will  be  offset  by. Section 25.0  'Instruction  Set Summary' provides  further  details  of  the  instruction set.",
    "FIGURE 4-6: INSTRUCTIONS IN PROGRAM MEMORY\nLSB = 1, 1 = LSB = 0. LSB = 1, 2 = Word Address \uf0af. , 1 = . , 2 = 000000h. , 1 = . , 2 = 000002h. , 1 = . , 2 = 000004h. , 1 = . , 2 = 000006h. 0Fh, 1 = 55h. 0Fh, 2 = 000008h. 0EFh, 1 = 03h. 0EFh, 2 = 00000Ah. 0F0h, 1 = 00h. 0F0h, 2 = 00000Ch. 0C1h, 1 = 23h. 0C1h, 2 = 00000Eh. 0F4h, 1 = 56h. 0F4h, 2 = 000010h. , 1 = . , 2 = 000012h. , 1 = . , 2 = 000014h",
    "4.7.1 TWO-WORD INSTRUCTIONS\nThe  PIC18F6585/8585/6680/8680  devices  have  four two-word  instructions: MOVFF,  CALL,  GOTO and LFSR . The second word of these instructions has the 4 MSBs set to ' 1 's and is a special kind of NOP instruction. The lower 12 bits of the second word contain data to be used by the instruction. If the first word of the instruction  is  executed,  the  data  in  the  second  word  is accessed. If the second word of the instruction is executed by itself (first word was skipped), it will execute as a NOP .  This  action  is  necessary  when  the  two-word instruction is preceded by a conditional instruction that changes  the  PC.  A  program  example  that  demonstrates this concept is shown in Example 4-3. Refer to Section 25.0 'Instruction Set Summary' for further details of the instruction set.",
    "EXAMPLE 4-3: TWO-WORD INSTRUCTIONS\nCASE 1:\n0110 0110 0000 0000, Source Code = TSTFSZ REG1 ; is RAM location. 1100 0001 0010 0011, Source Code = MOVFF REG1, REG2 ; No, execute 2-word instruction. 1111 0100 0101, Source Code = ; 2nd operand holds address of REG2. 0010 0100 0000 0000, Source Code = ADDWF REG3 ; continue code",
    "CASE 2:\n0110, Object Code = 0110. 0110, Object Code = 0000. 0110, Source Code = 0000. 0110, Source Code = TSTFSZ. 0110, Source Code = REG1. 0110, Source Code = . 0110, Source Code = ;. 0110, Source Code = is RAM. 0110, Source Code = location. 1100, Object Code = 0001. 1100, Object Code = 0010. 1100, Source Code = 0011. 1100, Source Code = MOVFF. 1100, Source Code = REG1,. 1100, Source Code = REG2. 1100, Source Code = ;. 1100, Source Code = Yes. 1100, Source Code = . 1111, Object Code = 0100. 1111, Object Code = 0101. 1111, Source Code = 0110. 1111, Source Code = . 1111, Source Code = . 1111, Source Code = . 1111, Source Code = ;. 1111, Source Code = 2nd. 1111, Source Code = operand becomes. 0010, Object Code = 0100. 0010, Object Code = 0000. 0010, Source Code = 0000. 0010, Source",
    "CASE 2:\nCode = ADDWF. 0010, Source Code = REG3. 0010, Source Code = . 0010, Source Code = ;. 0010, Source Code = . 0010, Source Code = continue code",
    "4.8.2 TABLE READS/TABLE WRITES\nLook-up tables are implemented two ways. These are:\n\u00b7 Computed GOTO\n\u00b7 Table Reads",
    "4.8.1 COMPUTED GOTO\nA computed GOTO is accomplished by adding an offset to the program counter ( ADDWF PCL ).\nA  look-up  table  can  be  formed  with  an ADDWF  PCL instruction  and  a  group  of RETLW 0xnn instructions. WREG is loaded with an offset  into  the table before executing a call to that table. The first instruction of the called routine is the ADDWF PCL instruction. The next instruction  executed  will  be  one  of  the RETLW 0xnn instructions that returns the value 0xnn to the calling function.\nThe offset value (value in WREG) specifies the number of bytes that the program counter should advance.\nIn  this  method,  only  one  data  byte  may  be stored  in each  instruction  location  and  room  on  the  return address stack is required.\nA  better  method  of  storing  data  in  program  memory allows 2 bytes of data to be stored in each instruction location.",
    "4.8.1 COMPUTED GOTO\nLook-up table data may be stored 2 bytes per program word by using table reads and writes. The Table Pointer (TBLPTR)  specifies  the  byte  address  and  the  Table Latch (TABLAT) contains the data that is read from, or written to program memory. Data is transferred to/from program memory, one byte at a time.\nA description of the table read/table write operation is shown in Section 5.0 'Flash Program Memory' .",
    "4.9 Data Memory Organization\nThe data memory is implemented as static RAM. Each register  in  the  data  memory  has  a  12-bit  address, allowing up to 4096 bytes of data memory. Figure 4-7 shows the data memory organization for the PIC18F6585/8585/6680/8680 devices.\nThe data  memory  map  is divided into  16  banks  that contain 256 bytes each. The lower 4 bits of the Bank Select Register (BSR<3:0>) select which bank will be accessed.  The  upper  4  bits  for  the  BSR  are  not implemented.\nThe data memory contains Special Function Registers (SFR)  and  General  Purpose  Registers  (GPR).  The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratch pad operations in the user's application. The SFRs start at the last location of Bank 15 (0FFFh) and extend downwards. Any remaining space beyond the SFRs in the Bank may be implemented as GPRs. GPRs start at the first location of Bank 0 and grow upwards. Any read of an unimplemented location will read as ' 0 's.",
    "4.9 Data Memory Organization\nThe entire data memory may be accessed directly or indirectly. Direct addressing may require the use of the BSR register. Indirect addressing requires the use of a File Select Register (FSRn) and a corresponding Indirect  File  Operand  (INDFn).  Each  FSR holds a  12-bit address value that can be used to access any location in the data memory map without banking.\nThe instruction  set  and  architecture  allow  operations across all banks. This may be accomplished by indirect addressing or by the use of the MOVFF instruction. The MOVFF instruction  is  a  two-word/two-cycle  instruction that moves a value from one register to another.\nTo  ensure  that  commonly  used  registers  (SFRs  and select GPRs) can be accessed in a single cycle regardless  of  the  current  BSR  values,  an  Access  Bank  is implemented. A segment of Bank 0 and a segment of Bank  15  comprise  the  Access  RAM. Section 4.10 'Access Bank' provides a detailed description of the Access RAM.",
    "4.9.1 GENERAL PURPOSE REGISTER FILE\nThe register file can be accessed either directly or indirectly. Indirect addressing operates using a File Select Register and corresponding Indirect File Operand. The operation of indirect addressing is shown in Section 4.12  'Indirect  Addressing,  INDF and  FSR Registers' .\nEnhanced MCU devices may have banked memory in the GPR area. GPRs are not initialized by a Power-on Reset and are unchanged on all other Resets.\nData RAM is available for use as general purpose registers  by  all  instructions.  The  top  section  of  Bank  15 (0F60h to 0FFFh) contains SFRs. All other banks of data memory contain GPR registers, starting with Bank 0.",
    "4.9.2 SPECIAL FUNCTION REGISTERS\nThe Special Function Registers (SFRs) are registers used by the CPU and peripheral modules for controlling the desired operation of the device. These registers are implemented as static RAM. A list of these registers is given in Table 4-2 and Table 4-3.\nThe SFRs can be classified into two sets: those associated with the 'core' function and those related to the peripheral  functions.  Those  registers  related  to  the 'core' are described in this section, while those related to the operation of the peripheral features are described in the section of that peripheral feature. The SFRs are typically distributed  among the peripherals whose functions they control.\nThe  unused  SFR  locations  are  unimplemented  and read as ' 0 's. The addresses for the SFRs are listed in Table 4-2.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nFFFh, Name = TOSU. FFFh, Address = FDFh. FFFh, Name = INDF2 (3). FFFh, Address = FBFh. FFFh, Name = CCPR1H. FFFh, Address = F9Fh. FFFh, Name = IPR1. FFEh, Name = TOSH. FFEh, Address = FDEh. FFEh, Name = POSTINC2 (3). FFEh, Address = FBEh. FFEh, Name = CCPR1L. FFEh, Address = F9Eh. FFEh, Name = PIR1. FFDh, Name = TOSL. FFDh, Address = FDDh. FFDh, Name = POSTDEC2 (3). FFDh, Address = FBDh. FFDh, Name = CCP1CON. FFDh, Address = F9Dh. FFDh, Name = PIE1. FFCh, Name = STKPTR. FFCh, Address = FDCh. FFCh, Name = PREINC2 (3). FFCh, Address = FBCh.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nFFCh, Name = CCPR2H. FFCh, Address = F9Ch. FFCh, Name = MEMCON (2). FFBh, Name = PCLATU. FFBh, Address = FDBh. FFBh, Name = PLUSW2 (3). FFBh, Address = FBBh. FFBh, Name = CCPR2L. FFBh, Address = F9Bh. FFBh, Name = - (1). FFAh, Name = PCLATH. FFAh, Address = FDAh. FFAh, Name = FSR2H. FFAh, Address = FBAh. FFAh, Name = CCP2CON. FFAh, Address = F9Ah. FFAh, Name = TRISJ (2). FF9h, Name = PCL. FF9h, Address = FD9h. FF9h, Name = FSR2L. FF9h, Address = FB9h. FF9h, Name = - (1). FF9h, Address = F99h. FF9h, Name = TRISH (2). FF8h, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nTBLPTRU. FF8h, Address = FD8h. FF8h, Name = STATUS. FF8h, Address = FB8h. FF8h, Name = - (1). FF8h, Address = F98h. FF8h, Name = TRISG. FF7h, Name = TBLPTRH. FF7h, Address = FD7h. FF7h, Name = TMR0H. FF7h, Address = FB7h. FF7h, Name = - (1). FF7h, Address = F97h. FF7h, Name = TRISF. FF6h, Name = TBLPTRL. FF6h, Address = FD6h. FF6h, Name = TMR0L. FF6h, Address = FB6h. FF6h, Name = ECCP1AS. FF6h, Address = F96h. FF6h, Name = TRISE. FF5h, Name = TABLAT. FF5h, Address = FD5h. FF5h, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nT0CON. FF5h, Address = FB5h. FF5h, Name = CVRCON. FF5h, Address = F95h. FF5h, Name = TRISD. FF4h, Name = PRODH. FF4h, Address = FD4h. FF4h, Name = - (1). FF4h, Address = FB4h. FF4h, Name = CMCON. FF4h, Address = F94h. FF4h, Name = TRISC. FF3h, Name = PRODL. FF3h, Address = FD3h. FF3h, Name = OSCCON. FF3h, Address = FB3h. FF3h, Name = TMR3H. FF3h, Address = F93h. FF3h, Name = TRISB. FF2h, Name = INTCON. FF2h, Address = FD2h. FF2h, Name = LVDCON. FF2h, Address = FB2h. FF2h, Name = TMR3L. FF2h, Address",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\n= F92h. FF2h, Name = TRISA. FF1h, Name = INTCON2. FF1h, Address = FD1h. FF1h, Name = WDTCON. FF1h, Address = FB1h. FF1h, Name = T3CON. FF1h, Address = F91h. FF1h, Name = LATJ (2). FF0h, Name = INTCON3. FF0h, Address = FD0h. FF0h, Name = RCON. FF0h, Address = FB0h. FF0h, Name = PSPCON. FF0h, Address = F90h. FF0h, Name = LATH (2). FEFh, Name = INDF0 (3). FEFh, Address = FCFh. FEFh, Name = TMR1H. FEFh, Address = FAFh. FEFh, Name = SPBRG. FEFh, Address = F8Fh. FEFh, Name = LATG. FEEh, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nPOSTINC0 (3). FEEh, Address = FCEh. FEEh, Name = TMR1L. FEEh, Address = FAEh. FEEh, Name = RCREG. FEEh, Address = F8Eh. FEEh, Name = LATF. FEDh, Name = POSTDEC0 (3). FEDh, Address = FCDh. FEDh, Name = T1CON. FEDh, Address = FADh. FEDh, Name = TXREG. FEDh, Address = F8Dh. FEDh, Name = LATE. FECh, Name = PREINC0 (3). FECh, Address = FCCh. FECh, Name = TMR2. FECh, Address = FACh. FECh, Name = TXSTA. FECh, Address = F8Ch. FECh, Name = LATD. FEBh, Name = PLUSW0 (3). FEBh, Address = FCBh. FEBh, Name = PR2. FEBh, Address = FABh. FEBh, Name = RCSTA. FEBh, Address = F8Bh. FEBh, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nLATC. FEAh, Name = FSR0H. FEAh, Address = FCAh. FEAh, Name = T2CON. FEAh, Address = FAAh. FEAh, Name = EEADRH. FEAh, Address = F8Ah. FEAh, Name = LATB. FE9h, Name = FSR0L. FE9h, Address = FC9h. FE9h, Name = SSPBUF. FE9h, Address = FA9h. FE9h, Name = EEADR. FE9h, Address = F89h. FE9h, Name = LATA. FE8h, Name = WREG. FE8h, Address = FC8h. FE8h, Name = SSPADD. FE8h, Address = FA8h. FE8h, Name = EEDATA. FE8h, Address = F88h. FE8h, Name = PORTJ (2). FE7h, Name = INDF1 (3). FE7h, Address = FC7h. FE7h, Name = SSPSTAT. FE7h, Address",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\n= FA7h. FE7h, Name = EECON2. FE7h, Address = F87h. FE7h, Name = PORTH (2). FE6h, Name = POSTINC1 (3). FE6h, Address = FC6h. FE6h, Name = SSPCON1. FE6h, Address = FA6h. FE6h, Name = EECON1. FE6h, Address = F86h. FE6h, Name = PORTG. FE5h, Name = POSTDEC1 (3). FE5h, Address = FC5h. FE5h, Name = SSPCON2. FE5h, Address = FA5h. FE5h, Name = IPR3. FE5h, Address = F85h. FE5h, Name = PORTF. FE4h, Name = PREINC1 (3). FE4h, Address = FC4h. FE4h, Name = ADRESH. FE4h, Address = FA4h. FE4h, Name = PIR3. FE4h, Address =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nF84h. FE4h, Name = PORTE. FE3h, Name = PLUSW1 (3). FE3h, Address = FC3h. FE3h, Name = ADRESL. FE3h, Address = FA3h. FE3h, Name = PIE3. FE3h, Address = F83h. FE3h, Name = PORTD. FE2h, Name = FSR1H. FE2h, Address = FC2h. FE2h, Name = ADCON0. FE2h, Address = FA2h. FE2h, Name = IPR2. FE2h, Address = F82h. FE2h, Name = PORTC. FE1h, Name = FSR1L. FE1h, Address = FC1h. FE1h, Name = ADCON1. FE1h, Address = FA1h. FE1h, Name = PIR2. FE1h, Address = F81h. FE1h, Name = PORTB. FE0h, Name = BSR. FE0h, Address = FC0h.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP\nFE0h, Name = ADCON2. FE0h, Address = FA0h. FE0h, Name = PIE2. FE0h, Address = F80h. FE0h, Name = PORTA\nNote 1: Unimplemented registers are read as ' 0 '.\n2: This register is not available on PIC18F6X8X devices.\n3: This is not a physical register.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF7Fh, Name = SPBRGH. F7Fh, Address = F5Fh. F7Fh, Name = CANCON_RO0. F7Fh, Address = F3Fh. F7Fh, Name = CANCON_RO2. F7Fh, Address = F1Fh. F7Fh, Name = RXM1EIDL. F7Eh, Name = BAUDCON. F7Eh, Address = F5Eh. F7Eh, Name = CANSTAT_RO0. F7Eh, Address = F3Eh. F7Eh, Name = CANSTAT_RO2. F7Eh, Address = F1Eh. F7Eh, Name = RXM1EIDH. F7Dh, Name = - (1). F7Dh, Address = F5Dh. F7Dh, Name = RXB1D7. F7Dh, Address = F3Dh. F7Dh, Name = TXB1D7. F7Dh, Address = F1Dh. F7Dh, Name = RXM1SIDL. F7Ch,",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nName = - (1). F7Ch, Address = F5Ch. F7Ch, Name = RXB1D6. F7Ch, Address = F3Ch. F7Ch, Name = TXB1D6. F7Ch, Address = F1Ch. F7Ch, Name = RXM1SIDH. F7Bh, Name = - (1). F7Bh, Address = F5Bh. F7Bh, Name = RXB1D5. F7Bh, Address = F3Bh. F7Bh, Name = TXB1D5. F7Bh, Address = F1Bh. F7Bh, Name = RXM0EIDL. F7Ah, Name = - (1). F7Ah, Address = F5Ah. F7Ah, Name = RXB1D4. F7Ah, Address = F3Ah. F7Ah, Name = TXB1D4. F7Ah, Address = F1Ah. F7Ah, Name = RXM0EIDH. F79h, Name = ECCP1DEL.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF79h, Address = F59h. F79h, Name = RXB1D3. F79h, Address = F39h. F79h, Name = TXB1D3. F79h, Address = F19h. F79h, Name = RXM0SIDL. F78h, Name = - (1). F78h, Address = F58h. F78h, Name = RXB1D2. F78h, Address = F38h. F78h, Name = TXB1D2. F78h, Address = F18h. F78h, Name = RXM0SIDH. F77h, Name = ECANCON. F77h, Address = F57h. F77h, Name = RXB1D1. F77h, Address = F37h. F77h, Name = TXB1D1. F77h, Address = F17h. F77h, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nRXF5EIDL. F76h, Name = TXERRCNT. F76h, Address = F56h. F76h, Name = RXB1D0. F76h, Address = F36h. F76h, Name = TXB1D0. F76h, Address = F16h. F76h, Name = RXF5EIDH. F75h, Name = RXERRCNT. F75h, Address = F55h. F75h, Name = RXB1DLC. F75h, Address = F35h. F75h, Name = TXB1DLC. F75h, Address = F15h. F75h, Name = RXF5SIDL. F74h, Name = COMSTAT. F74h, Address = F54h. F74h, Name = RXB1EIDL. F74h, Address = F34h. F74h, Name = TXB1EIDL. F74h, Address = F14h.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF74h, Name = RXF5SIDH. F73h, Name = CIOCON. F73h, Address = F53h. F73h, Name = RXB1EIDH. F73h, Address = F33h. F73h, Name = TXB1EIDH. F73h, Address = F13h. F73h, Name = RXF4EIDL. F72h, Name = BRGCON3. F72h, Address = F52h. F72h, Name = RXB1SIDL. F72h, Address = F32h. F72h, Name = TXB1SIDL. F72h, Address = F12h. F72h, Name = RXF4EIDH. F71h, Name = BRGCON2. F71h, Address = F51h. F71h, Name = RXB1SIDH. F71h, Address = F31h. F71h, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nTXB1SIDH. F71h, Address = F11h. F71h, Name = RXF4SIDL. F70h, Name = BRGCON1. F70h, Address = F50h. F70h, Name = RXB1CON. F70h, Address = F30h. F70h, Name = TXB1CON. F70h, Address = F10h. F70h, Name = RXF4SIDH. F6Fh, Name = CANCON. F6Fh, Address = F4Fh. F6Fh, Name = CANCON_RO1. F6Fh, Address = F2Fh. F6Fh, Name = CANCON_RO3. F6Fh, Address = F0Fh. F6Fh, Name = RXF3EIDL. F6Eh, Name = CANSTAT. F6Eh, Address = F4Eh. F6Eh, Name = CANSTAT_RO1. F6Eh, Address = F2Eh. F6Eh, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nCANSTAT_RO3. F6Eh, Address = F0Eh. F6Eh, Name = RXF3EIDH. F6Dh, Name = RXB0D7. F6Dh, Address = F4Dh. F6Dh, Name = TXB0D7. F6Dh, Address = F2Dh. F6Dh, Name = TXB2D7. F6Dh, Address = F0Dh. F6Dh, Name = RXF3SIDL. F6Ch, Name = RXB0D6. F6Ch, Address = F4Ch. F6Ch, Name = TXB0D6. F6Ch, Address = F2Ch. F6Ch, Name = TXB2D6. F6Ch, Address = F0Ch. F6Ch, Name = RXF3SIDH. F6Bh, Name = RXB0D5. F6Bh, Address = F4Bh. F6Bh, Name = TXB0D5. F6Bh, Address = F2Bh. F6Bh, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nTXB2D5. F6Bh, Address = F0Bh. F6Bh, Name = RXF2EIDL. F6Ah, Name = RXB0D4. F6Ah, Address = F4Ah. F6Ah, Name = TXB0D4. F6Ah, Address = F2Ah. F6Ah, Name = TXB2D4. F6Ah, Address = F0Ah. F6Ah, Name = RXF2EIDH. F69h, Name = RXB0D3. F69h, Address = F49h. F69h, Name = TXB0D3. F69h, Address = F29h. F69h, Name = TXB2D3. F69h, Address = F09h. F69h, Name = RXF2SIDL. F68h, Name = RXB0D2. F68h, Address = F48h. F68h, Name = TXB0D2. F68h, Address =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF28h. F68h, Name = TXB2D2. F68h, Address = F08h. F68h, Name = RXF2SIDH. F67h, Name = RXB0D1. F67h, Address = F47h. F67h, Name = TXB0D1. F67h, Address = F27h. F67h, Name = TXB2D1. F67h, Address = F07h. F67h, Name = RXF1EIDL. F66h, Name = RXB0D0. F66h, Address = F46h. F66h, Name = TXB0D0. F66h, Address = F26h. F66h, Name = TXB2D0. F66h, Address = F06h. F66h, Name = RXF1EIDH. F65h, Name = RXB0DLC. F65h, Address = F45h. F65h, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nTXB0DLC. F65h, Address = F25h. F65h, Name = TXB2DLC. F65h, Address = F05h. F65h, Name = RXF1SIDL. F64h, Name = RXB0EIDL. F64h, Address = F44h. F64h, Name = TXB0EIDL. F64h, Address = F24h. F64h, Name = TXB2EIDL. F64h, Address = F04h. F64h, Name = RXF1SIDH. F63h, Name = RXB0EIDH. F63h, Address = F43h. F63h, Name = TXB0EIDH. F63h, Address = F23h. F63h, Name = TXB2EIDH. F63h, Address = F03h. F63h, Name = RXF0EIDL. F62h, Name = RXB0SIDL. F62h, Address =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF42h. F62h, Name = TXB0SIDL. F62h, Address = F22h. F62h, Name = TXB2SIDL. F62h, Address = F02h. F62h, Name = RXF0EIDH. F61h, Name = RXB0SIDH. F61h, Address = F41h. F61h, Name = TXB0SIDH. F61h, Address = F21h. F61h, Name = TXB2SIDH. F61h, Address = F01h. F61h, Name = RXF0SIDL. F60h, Name = RXB0CON. F60h, Address = F40h. F60h, Name = TXB0CON. F60h, Address = F20h. F60h, Name = TXB2CON. F60h, Address = F00h. F60h, Name = RXF0SIDH",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nNote 1: Unimplemented registers are read as ' 0 '.\n2: This register is not available on PIC18F6X8X devices.\n3: This is not a physical register.",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nEFFh, Name = - (1). EFFh, Address = EDFh. EFFh, Name = - (1). EFFh, Address = EBFh. EFFh, Name = - (1). EFEh, Name = - (1). EFEh, Address = EDEh. EFEh, Name = - (1). EFEh, Address = EBEh. EFEh, Name = - (1). EFDh, Name = - (1). EFDh, Address = EDDh. EFDh, Name = - (1). EFDh, Address = EBDh. EFDh, Name = - (1). EFCh, Name = - (1). EFCh, Address = EDCh. EFCh, Name = - (1). EFCh, Address = EBCh. EFCh, Name = - (1). EFBh, Name = - (1). EFBh, Address = EDBh. EFBh, Name = - (1). EFBh, Address =",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nEBBh. EFBh, Name = - (1). EFAh, Name = - (1). EFAh, Address = EDAh. EFAh, Name = - (1). EFAh, Address = EBAh. EFAh, Name = - (1). EF9h, Name = - (1). EF9h, Address = ED9h. EF9h, Name = - (1). EF9h, Address = EB9h. EF9h, Name = - (1). EF8h, Name = - (1). EF8h, Address = ED8h. EF8h, Name = - (1). EF8h, Address = EB8h. EF8h, Name = - (1). EF7h, Name = - (1). EF7h, Address = ED7h. EF7h, Name = - (1). EF7h, Address = EB7h. EF7h, Name = - (1). EF6h, Name",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\n= - (1). EF6h, Address = ED6h. EF6h, Name = - (1). EF6h, Address = EB6h. EF6h, Name = - (1). EF5h, Name = - (1). EF5h, Address = ED5h. EF5h, Name = - (1). EF5h, Address = EB5h. EF5h, Name = - (1). EF4h, Name = - (1). EF4h, Address = ED4h. EF4h, Name = - (1). EF4h, Address = EB4h. EF4h, Name = - (1). EF3h, Name = - (1). EF3h, Address = ED3h. EF3h, Name = - (1). EF3h, Address = EB3h. EF3h, Name = - (1). EF2h, Name = - (1). EF2h, Address =",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nED2h. EF2h, Name = - (1). EF2h, Address = EB2h. EF2h, Name = - (1). EF1h, Name = - (1). EF1h, Address = ED1h. EF1h, Name = - (1). EF1h, Address = EB1h. EF1h, Name = - (1). EF0h, Name = - (1). EF0h, Address = ED0h. EF0h, Name = - (1). EF0h, Address = EB0h. EF0h, Name = - (1). EEFh, Name = - (1). EEFh, Address = ECFh. EEFh, Name = - (1). EEFh, Address = EAFh. EEFh, Name = - (1). EEEh, Name = - (1). EEEh, Address = ECEh. EEEh, Name = - (1). EEEh, Address = EAEh.",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nEEEh, Name = - (1). EEDh, Name = - (1). EEDh, Address = ECDh. EEDh, Name = - (1). EEDh, Address = EADh. EEDh, Name = - (1). EECh, Name = - (1). EECh, Address = ECCh. EECh, Name = - (1). EECh, Address = EACh. EECh, Name = - (1). EEBh, Name = - (1). EEBh, Address = ECBh. EEBh, Name = - (1). EEBh, Address = EABh. EEBh, Name = - (1). EEAh, Name = - (1). EEAh, Address = ECAh. EEAh, Name = - (1). EEAh, Address = EAAh. EEAh, Name = - (1). EE9h, Name = - (1). EE9h, Address = EC9h. EE9h, Name = - (1). EE9h, Address = EA9h. EE9h, Name = - (1).",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nEE8h, Name = - (1). EE8h, Address = EC8h. EE8h, Name = - (1). EE8h, Address = EA8h. EE8h, Name = - (1). EE7h, Name = - (1). EE7h, Address = EC7h. EE7h, Name = - (1). EE7h, Address = EA7h. EE7h, Name = - (1). EE6h, Name = - (1). EE6h, Address = EC6h. EE6h, Name = - (1). EE6h, Address = EA6h. EE6h, Name = - (1). EE5h, Name = - (1). EE5h, Address = EC5h. EE5h, Name = - (1). EE5h, Address = EA5h. EE5h, Name = - (1). EE4h, Name = - (1). EE4h, Address = EC4h. EE4h, Name = - (1). EE4h, Address",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\n= EA4h. EE4h, Name = - (1). EE3h, Name = - (1). EE3h, Address = EC3h. EE3h, Name = - (1). EE3h, Address = EA3h. EE3h, Name = - (1). EE2h, Name = - (1). EE2h, Address = EC2h. EE2h, Name = - (1). EE2h, Address = EA2h. EE2h, Name = - (1). EE1h, Name = - (1). EE1h, Address = EC1h. EE1h, Name = - (1). EE1h, Address = EA1h. EE1h, Name = - (1). EE0h, Name = - (1). EE0h, Address = EC0h. EE0h, Name = - (1). EE0h, Address = EA0h. EE0h, Name = - (1)",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nNote 1: Unimplemented registers are read as ' 0 '.\n2: This register is not available on PIC18F6X8X devices.\n3: This is not a physical register.\nAddress\nE9Fh\nE9Eh\nE9Dh\nE9Ch\nE9Bh\nE9Ah\nE99h\nE98h\nE97h\nE96h\nE95h\nE94h\nE93h\nE92h\nE91h\nE90h\nE8Fh\nE8Eh\nE8Dh\nE8Ch\nE8Bh\nE8Ah\nE89h\nE88h\nE87h\nE86h\nE85h\nE84h\nE83h\nE82h\nE81h\nE80h\nName\n-\n(1)\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nE7Fh, Name = CANCON_RO4. E7Fh, Address = E5Fh. E7Fh, Name = CANCON_RO6. E7Fh, Address = E3Fh. E7Fh, Name = CANCON_RO8. E7Fh, Address = E1Fh. E7Fh, Name = - (1). E7Eh, Name = CANSTAT_RO4. E7Eh, Address = E5Eh. E7Eh, Name = CANSTAT_RO6. E7Eh, Address = E3Eh. E7Eh, Name = CANSTAT_RO8. E7Eh, Address = E1Eh. E7Eh, Name = - (1). E7Dh, Name = B5D7. E7Dh, Address = E5Dh. E7Dh, Name = B3D7. E7Dh, Address = E3Dh. E7Dh, Name = B1D7. E7Dh, Address = E1Dh. E7Dh, Name = - (1). E7Ch, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nB5D6. E7Ch, Address = E5Ch. E7Ch, Name = B3D6. E7Ch, Address = E3Ch. E7Ch, Name = B1D6. E7Ch, Address = E1Ch. E7Ch, Name = - (1). E7Bh, Name = B5D5. E7Bh, Address = E5Bh. E7Bh, Name = B3D5. E7Bh, Address = E3Bh. E7Bh, Name = B1D5. E7Bh, Address = E1Bh. E7Bh, Name = - (1). E7Ah, Name = B5D4. E7Ah, Address = E5Ah. E7Ah, Name = B3D4. E7Ah, Address = E3Ah. E7Ah, Name = B1D4. E7Ah, Address = E1Ah. E7Ah, Name = - (1). E79h, Name = B5D3. E79h, Address = E59h. E79h, Name = B3D3.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nE79h, Address = E39h. E79h, Name = B1D3. E79h, Address = E19h. E79h, Name = - (1). E78h, Name = B5D2. E78h, Address = E58h. E78h, Name = B3D2. E78h, Address = E38h. E78h, Name = B1D2. E78h, Address = E18h. E78h, Name = - (1). E77h, Name = B5D1. E77h, Address = E57h. E77h, Name = B3D1. E77h, Address = E37h. E77h, Name = B1D1. E77h, Address = E17h. E77h, Name = - (1). E76h, Name = B5D0. E76h, Address = E56h. E76h, Name = B3D0. E76h, Address =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nE36h. E76h, Name = B1D0. E76h, Address = E16h. E76h, Name = - (1). E75h, Name = B5DLC. E75h, Address = E55h. E75h, Name = B3DLC. E75h, Address = E35h. E75h, Name = B1DLC. E75h, Address = E15h. E75h, Name = - (1). E74h, Name = B5EIDL. E74h, Address = E54h. E74h, Name = B3EIDL. E74h, Address = E34h. E74h, Name = B1EIDL. E74h, Address = E14h. E74h, Name = - (1). E73h, Name = B5EIDH. E73h, Address = E53h. E73h, Name = B3EIDH. E73h, Address = E33h. E73h, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nB1EIDH. E73h, Address = E13h. E73h, Name = - (1). E72h, Name = B5SIDL. E72h, Address = E52h. E72h, Name = B3SIDL. E72h, Address = E32h. E72h, Name = B1SIDL. E72h, Address = E12h. E72h, Name = - (1). E71h, Name = B5SIDH. E71h, Address = E51h. E71h, Name = B3SIDH. E71h, Address = E31h. E71h, Name = B1SIDH. E71h, Address = E11h. E71h, Name = - (1). E70h, Name = B5CON. E70h, Address = E50h. E70h, Name = B3CON. E70h, Address = E30h. E70h, Name = B1CON. E70h, Address =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nE10h. E70h, Name = - (1). E6Fh, Name = CANCON_RO5. E6Fh, Address = E4Fh. E6Fh, Name = CANCON_RO7. E6Fh, Address = E2Fh. E6Fh, Name = CANCON_RO9. E6Fh, Address = E0Fh. E6Fh, Name = - (1). E6Eh, Name = CANSTAT_RO5. E6Eh, Address = E4Eh. E6Eh, Name = CANSTAT_RO7. E6Eh, Address = E2Eh. E6Eh, Name = CANSTAT_RO9. E6Eh, Address = E0Eh. E6Eh, Name = - (1). E6Dh, Name = B4D7. E6Dh, Address = E4Dh. E6Dh, Name = B2D7. E6Dh, Address = E2Dh. E6Dh, Name = B0D7. E6Dh, Address = E0Dh.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nE6Dh, Name = - (1). E6Ch, Name = B4D6. E6Ch, Address = E4Ch. E6Ch, Name = B2D6. E6Ch, Address = E2Ch. E6Ch, Name = B0D6. E6Ch, Address = E0Ch. E6Ch, Name = - (1). E6Bh, Name = B4D5. E6Bh, Address = E4Bh. E6Bh, Name = B2D5. E6Bh, Address = E2Bh. E6Bh, Name = B0D5. E6Bh, Address = E0Bh. E6Bh, Name = - (1). E6Ah, Name = B4D4. E6Ah, Address = E4Ah. E6Ah, Name = B2D4. E6Ah, Address = E2Ah. E6Ah, Name = B0D4. E6Ah, Address = E0Ah. E6Ah, Name = - (1). E69h, Name =",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nB4D3. E69h, Address = E49h. E69h, Name = B2D3. E69h, Address = E29h. E69h, Name = B0D3. E69h, Address = E09h. E69h, Name = - (1). E68h, Name = B4D2. E68h, Address = E48h. E68h, Name = B2D2. E68h, Address = E28h. E68h, Name = B0D2. E68h, Address = E08h. E68h, Name = - (1). E67h, Name = B4D1. E67h, Address = E47h. E67h, Name = B2D1. E67h, Address = E27h. E67h, Name = B0D1. E67h, Address = E07h. E67h, Name = - (1). E66h, Name",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\n= B4D0. E66h, Address = E46h. E66h, Name = B2D0. E66h, Address = E26h. E66h, Name = B0D0. E66h, Address = E06h. E66h, Name = - (1). E65h, Name = B4DLC. E65h, Address = E45h. E65h, Name = B2DLC. E65h, Address = E25h. E65h, Name = B0DLC. E65h, Address = E05h. E65h, Name = - (1). E64h, Name = B4EIDL. E64h, Address = E44h. E64h, Name = B2EIDL. E64h, Address = E24h. E64h, Name = B0EIDL. E64h, Address = E04h. E64h, Name = - (1). E63h, Name = B4EIDH. E63h, Address = E43h.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nE63h, Name = B2EIDH. E63h, Address = E23h. E63h, Name = B0EIDH. E63h, Address = E03h. E63h, Name = - (1). E62h, Name = B4SIDL. E62h, Address = E42h. E62h, Name = B2SIDL. E62h, Address = E22h. E62h, Name = B0SIDL. E62h, Address = E02h. E62h, Name = - (1). E61h, Name = B4SIDH. E61h, Address = E41h. E61h, Name = B2SIDH. E61h, Address = E21h. E61h, Name = B0SIDH. E61h, Address = E01h. E61h, Name = - (1). E60h, Name = B4CON. E60h, Address = E40h.",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nE60h, Name = B2CON. E60h, Address = E20h. E60h, Name = B0CON. E60h, Address = E00h. E60h, Name = - (1)\nNote 1: Unimplemented registers are read as ' 0 '.\n2: This register is not available on PIC18F6X8X devices.\n3: This is not a physical register.",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nDFFh, Name = - (1). DFFh, Address = DDFh. DFFh, Name = - (1). DFFh, Address = DBFh. DFFh, Name = - (1). DFEh, Name = - (1). DFEh, Address = DDEh. DFEh, Name = - (1). DFEh, Address = DBEh. DFEh, Name = - (1). DFDh, Name = - (1). DFDh, Address = DDDh. DFDh, Name = - (1). DFDh, Address = DBDh. DFDh, Name = - (1). DFCh, Name = TXBIE. DFCh, Address = DDCh. DFCh, Name = - (1). DFCh, Address = DBCh. DFCh, Name = - (1). DFBh, Name = - (1). DFBh, Address = DDBh. DFBh, Name = - (1). DFBh, Address = DBBh. DFBh, Name = -",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\n(1). DFAh, Name = BIE0. DFAh, Address = DDAh. DFAh, Name = - (1). DFAh, Address = DBAh. DFAh, Name = - (1). DF9h, Name = - (1). DF9h, Address = DD9h. DF9h, Name = - (1). DF9h, Address = DB9h. DF9h, Name = - (1). DF8h, Name = BSEL0. DF8h, Address = DD8h. DF8h, Name = SDFLC. DF8h, Address = DB8h. DF8h, Name = - (1). DF7h, Name = - (1). DF7h, Address = DD7h. DF7h, Name = - (1). DF7h, Address = DB7h. DF7h, Name = - (1). DF6h, Name = - (1). DF6h, Address = DD6h.",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nDF6h, Name = - (1). DF6h, Address = DB6h. DF6h, Name = - (1). DF5h, Name = - (1). DF5h, Address = DD5h. DF5h, Name = RXFCON1. DF5h, Address = DB5h. DF5h, Name = - (1). DF4h, Name = - (1). DF4h, Address = DD4h. DF4h, Name = RXFCON0. DF4h, Address = DB4h. DF4h, Name = - (1). DF3h, Name = MSEL3. DF3h, Address = DD3h. DF3h, Name = - (1). DF3h, Address = DB3h. DF3h, Name = - (1). DF2h, Name = MSEL2. DF2h, Address = DD2h. DF2h, Name = - (1). DF2h,",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nAddress = DB2h. DF2h, Name = - (1). DF1h, Name = MSEL1. DF1h, Address = DD1h. DF1h, Name = - (1). DF1h, Address = DB1h. DF1h, Name = - (1). DF0h, Name = MSEL0. DF0h, Address = DD0h. DF0h, Name = - (1). DF0h, Address = DB0h. DF0h, Name = - (1). DEFh, Name = - (1). DEFh, Address = DCFh. DEFh, Name = - (1). DEFh, Address = DAFh. DEFh, Name = - (1). DEEh, Name = - (1). DEEh, Address = DCEh. DEEh, Name = - (1). DEEh, Address = DAEh. DEEh, Name = - (1). DEDh, Name = - (1). DEDh, Address = DCDh. DEDh, Name =",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\n- (1). DEDh, Address = DADh. DEDh, Name = - (1). DECh, Name = - (1). DECh, Address = DCCh. DECh, Name = - (1). DECh, Address = DACh. DECh, Name = - (1). DEBh, Name = - (1). DEBh, Address = DCBh. DEBh, Name = - (1). DEBh, Address = DABh. DEBh, Name = - (1). DEAh, Name = - (1). DEAh, Address = DCAh. DEAh, Name = - (1). DEAh, Address = DAAh. DEAh, Name = - (1). DE9h, Name = - (1). DE9h, Address = DC9h. DE9h, Name = - (1). DE9h, Address = DA9h. DE9h, Name = - (1). DE8h, Name = - (1). DE8h, Address = DC8h. DE8h, Name = - (1).",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nDE8h, Address = DA8h. DE8h, Name = - (1). DE7h, Name = RXFBCON7. DE7h, Address = DC7h. DE7h, Name = - (1). DE7h, Address = DA7h. DE7h, Name = - (1). DE6h, Name = RXFBCON6. DE6h, Address = DC6h. DE6h, Name = - (1). DE6h, Address = DA6h. DE6h, Name = - (1). DE5h, Name = RXFBCON5. DE5h, Address = DC5h. DE5h, Name = - (1). DE5h, Address = DA5h. DE5h, Name = - (1). DE4h, Name = RXFBCON4. DE4h, Address = DC4h. DE4h, Name = - (1). DE4h, Address = DA4h. DE4h, Name = - (1). DE3h, Name = RXFBCON3.",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nDE3h, Address = DC3h. DE3h, Name = - (1). DE3h, Address = DA3h. DE3h, Name = - (1). DE2h, Name = RXFBCON2. DE2h, Address = DC2h. DE2h, Name = - (1). DE2h, Address = DA2h. DE2h, Name = - (1). DE1h, Name = RXFBCON1. DE1h, Address = DC1h. DE1h, Name = - (1). DE1h, Address = DA1h. DE1h, Name = - (1). DE0h, Name = RXFBCON0. DE0h, Address = DC0h. DE0h, Name = - (1). DE0h, Address = DA0h. DE0h, Name = - (1)\nNote 1: Unimplemented registers are read as ' 0 '.\n2: This register is not available on PIC18F6X8X devices.\n3: This is not a physical register.",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nD9Fh, Name = - (1). D9Eh, Name = - (1). D9Dh, Name = - (1). D9Ch, Name = - (1). D9Bh, Name = - (1). D9Ah, Name = - (1). D99h, Name = - (1). D98h, Name = - (1). D97h, Name = - (1). D96h, Name = - (1). D95h, Name = - (1). D94h, Name = - (1). D93h, Name = RXF15EIDL. D92h, Name = RXF15EIDH. D91h, Name = RXF15SIDL. D90h, Name = RXF15SIDH. D8Fh, Name = - (1). D8Eh, Name = - (1). D8Dh, Name = - (1). D8Ch, Name = - (1). D8Bh, Name =",
    "SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nRXF14EIDL. D8Ah, Name = RXF14EIDH. D89h, Name = RXF14SIDL. D88h, Name = RXF14SIDH. D87h, Name = RXF13EIDL. D86h, Name = RXF13EIDH. D85h, Name = RXF13SIDL. D84h, Name = RXF13SIDH. D83h, Name = RXF12EIDL. D82h, Name = RXF12EIDH. D81h, Name = RXF12SIDL. D80h, Name = RXF12SIDH",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nD7Fh, Name = - (1). D7Eh, Name = - (1). D7Dh, Name = - (1). D7Ch, Name = - (1). D7Bh, Name = RXF11EIDL. D7Ah, Name = RXF11EIDH. D79h, Name = RXF11SIDL. D78h, Name = RXF11SIDH. D77h, Name = RXF10EIDL. D76h, Name = RXF10EIDH. D75h, Name = RXF10SIDL. D74h, Name = RXF10SIDH. D73h, Name = RXF9EIDL. D72h, Name = RXF9EIDH. D71h, Name = RXF9SIDL. D70h, Name = RXF9SIDH. D6Fh, Name = - (1). D6Eh, Name = - (1). D6Dh, Name = - (1).",
    "TABLE 4-2: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nD6Ch, Name = - (1). D6Bh, Name = RXF8EIDL. D6Ah, Name = RXF8EIDH. D69h, Name = RXF8SIDL. D68h, Name = RXF8SIDH. D67h, Name = RXF7EIDL. D66h, Name = RXF7EIDH. D65h, Name = RXF7SIDL. D64h, Name = RXF7SIDH. D63h, Name = RXF6EIDL. D62h, Name = RXF6EIDH. D61h, Name = RXF6SIDL. D60h, Name = RXF6SIDH\nNote 1: Unimplemented registers are read as ' 0 '.\n2: This register is not available on PIC18F6X8X devices.\n3: This is not a physical register.",
    "TABLE 4-3: REGISTER FILE SUMMARY\nTOSU, Bit 7 = -. TOSU, Bit 6 = -. TOSU, Bit 5 = -. TOSU, Bit 4 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 3 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 2 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 1 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 0 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Value on POR, BOR = ---0 0000. TOSU, Details on page: = 36, 54. TOSH, Bit 7 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 6 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 5 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 4 = Top-of-Stack",
    "TABLE 4-3: REGISTER FILE SUMMARY\nHigh Byte (TOS<15:8>). TOSH, Bit 3 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 2 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 1 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 0 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Value on POR, BOR = 0000 0000. TOSH, Details on page: = 36, 54. TOSL, Bit 7 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 6 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 5 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 4 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 3 = Top-of-Stack Low Byte (TOS<7:0>).",
    "TABLE 4-3: REGISTER FILE SUMMARY\nTOSL, Bit 2 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 1 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 0 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Value on POR, BOR = 0000 0000. TOSL, Details on page: = 36, 54. STKPTR, Bit 7 = STKFUL. STKPTR, Bit 6 = STKUNF. STKPTR, Bit 5 = -. STKPTR, Bit 4 = Return Stack Pointer. STKPTR, Bit 3 = Return Stack Pointer. STKPTR, Bit 2 = Return Stack Pointer. STKPTR, Bit 1 = Return Stack Pointer. STKPTR, Bit 0 = Return Stack Pointer. STKPTR, Value on POR, BOR = 00-0 0000. STKPTR, Details on page: = 36, 55. PCLATU, Bit 7 = -. PCLATU, Bit 6 = -. PCLATU, Bit 5 =",
    "TABLE 4-3: REGISTER FILE SUMMARY\nbit 21. PCLATU, Bit 4 = Holding Register for PC<20:16>. PCLATU, Bit 3 = Holding Register for PC<20:16>. PCLATU, Bit 2 = Holding Register for PC<20:16>. PCLATU, Bit 1 = Holding Register for PC<20:16>. PCLATU, Bit 0 = Holding Register for PC<20:16>. PCLATU, Value on POR, BOR = --00 0000. PCLATU, Details on page: = 36, 56. PCLATH, Bit 7 = Holding Register for PC<15:8>. PCLATH, Bit 6 = Holding Register for PC<15:8>. PCLATH, Bit 5 = Holding Register for PC<15:8>. PCLATH, Bit 4 = Holding Register for PC<15:8>. PCLATH, Bit 3 = Holding Register for PC<15:8>. PCLATH, Bit 2 = Holding Register for PC<15:8>. PCLATH, Bit 1 = Holding Register for PC<15:8>. PCLATH, Bit 0 = Holding Register for",
    "TABLE 4-3: REGISTER FILE SUMMARY\nPC<15:8>. PCLATH, Value on POR, BOR = 0000 0000. PCLATH, Details on page: = 36, 56. PCL, Bit 7 = PCLowByte (PC<7:0>). PCL, Bit 6 = PCLowByte (PC<7:0>). PCL, Bit 5 = PCLowByte (PC<7:0>). PCL, Bit 4 = PCLowByte (PC<7:0>). PCL, Bit 3 = PCLowByte (PC<7:0>). PCL, Bit 2 = PCLowByte (PC<7:0>). PCL, Bit 1 = PCLowByte (PC<7:0>). PCL, Bit 0 = PCLowByte (PC<7:0>). PCL, Value on POR, BOR = 0000 0000. PCL, Details on page: = 36, 56. TBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit 21",
    "TABLE 4-3: REGISTER FILE SUMMARY\n(2). TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on POR, BOR = --00 0000. TBLPTRU, Details on page: = 36, 86. TBLPTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 4 = Program Memory Table Pointer",
    "TABLE 4-3: REGISTER FILE SUMMARY\nHigh Byte (TBLPTR<15:8>). TBLPTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Value on POR, BOR = 0000 0000. TBLPTRH, Details on page: = 36, 86. TBLPTRL, Bit 7 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>).",
    "TABLE 4-3: REGISTER FILE SUMMARY\nTBLPTRL, Bit 3 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Value on POR, BOR = 0000 0000. TBLPTRL, Details on page: = 36, 86. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on POR, BOR = 0000 0000. TABLAT, Details on page: = 36, 86.",
    "TABLE 4-3: REGISTER FILE SUMMARY\nPRODH, Bit 7 = Product Register High Byte. PRODH, Bit 6 = Product Register High Byte. PRODH, Bit 5 = Product Register High Byte. PRODH, Bit 4 = Product Register High Byte. PRODH, Bit 3 = Product Register High Byte. PRODH, Bit 2 = Product Register High Byte. PRODH, Bit 1 = Product Register High Byte. PRODH, Bit 0 = Product Register High Byte. PRODH, Value on POR, BOR = xxxx xxxx. PRODH, Details on page: = 36, 107. PRODL, Bit 7 = Product Register Low Byte. PRODL, Bit 6 = Product Register Low Byte. PRODL, Bit 5 = Product Register Low Byte. PRODL, Bit 4 = Product Register Low Byte. PRODL, Bit 3 = Product Register Low Byte. PRODL, Bit 2 = Product Register Low Byte. PRODL, Bit 1 = Product Register Low Byte. PRODL, Bit 0 = Product Register Low Byte. PRODL, Value on POR, BOR = xxxx xxxx. PRODL, Details on page: = 36, 107. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 =",
    "TABLE 4-3: REGISTER FILE SUMMARY\nPEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Details on page: = 36, 111. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = INTEDG3. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = INT3IP. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111 1111. INTCON2, Details on page: = 36, 112. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 =",
    "TABLE 4-3: REGISTER FILE SUMMARY\nINT3IE. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = INT3IF. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 1100 0000. INTCON3, Details on page: = 36, 113. INDF0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register).",
    "TABLE 4-3: REGISTER FILE SUMMARY\nINDF0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Value on POR, BOR = n/a. INDF0, Details on page: = 79. POSTINC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 4 = Uses contents of FSR0 to address data memory",
    "TABLE 4-3: REGISTER FILE SUMMARY\n- value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Value on POR, BOR = n/a. POSTINC0, Details on page: = 79. POSTDEC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 6 = Uses contents of FSR0 to address data memory - value of",
    "TABLE 4-3: REGISTER FILE SUMMARY\nFSR0 post-decremented (not a physical register). POSTDEC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-decremented (not a physical register). POSTDEC0, Value on POR, BOR = n/a.",
    "TABLE 4-3: REGISTER FILE SUMMARY\nPOSTDEC0, Details on page: = 79. PREINC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Bit 1 = Uses contents of FSR0 to address data memory - value",
    "TABLE 4-3: REGISTER FILE SUMMARY\nof FSR0 pre-incremented (not a physical register). PREINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register). PREINC0, Value on POR, BOR = n/a. PREINC0, Details on page: = 79. PLUSW0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical. PLUSW0, Bit 6 = register) -. PLUSW0, Bit 5 = value of FSR0offset. PLUSW0, Bit 4 = by value. PLUSW0, Bit 3 = in WREG. PLUSW0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical. PLUSW0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical. PLUSW0, Bit 0 = Uses contents of FSR0 to address data memory - value of",
    "TABLE 4-3: REGISTER FILE SUMMARY\nFSR0 pre-incremented (not a physical. PLUSW0, Value on POR, BOR = n/a. PLUSW0, Details on page: = 79. FSR0H, Bit 7 = -. FSR0H, Bit 6 = -. FSR0H, Bit 5 = -. FSR0H, Bit 4 = -. FSR0H, Bit 3 = Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 2 = Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 1 = Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Bit 0 = Indirect Data Memory Address Pointer 0 High Byte. FSR0H, Value on POR, BOR = ---- 0000. FSR0H, Details on page: = 36, 79. FSR0L, Bit 7 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 6 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 5 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 4 = Indirect Data Memory Address Pointer 0 Low Byte.",
    "TABLE 4-3: REGISTER FILE SUMMARY\nFSR0L, Bit 3 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 2 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 1 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Bit 0 = Indirect Data Memory Address Pointer 0 Low Byte. FSR0L, Value on POR, BOR = xxxx xxxx. FSR0L, Details on page: = 36, 79. WREG, Bit 7 = Working Register. WREG, Bit 6 = Working Register. WREG, Bit 5 = Working Register. WREG, Bit 4 = Working Register. WREG, Bit 3 = Working Register. WREG, Bit 2 = Working Register. WREG, Bit 1 = Working Register. WREG, Bit 0 = Working Register. WREG, Value on POR, BOR = xxxx xxxx. WREG, Details on page: = 36. INDF1, Bit 7 = . INDF1, Bit 6 = . INDF1, Bit 5 = . INDF1, Bit 4 = . INDF1, Bit 3 = . INDF1, Bit 2 = . INDF1,",
    "TABLE 4-3: REGISTER FILE SUMMARY\nBit 1 = . INDF1, Bit 0 = . INDF1, Value on POR, BOR = n/a. INDF1, Details on page: = 79. POSTINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 not changed (not a physical register) Uses contents. POSTINC1, Bit 6 = of FSR1 to. POSTINC1, Bit 5 = address data. POSTINC1, Bit 4 = memory - value. POSTINC1, Bit 3 = of FSR1. POSTINC1, Bit 2 = post-incremented (not. POSTINC1, Bit 1 = a physical. POSTINC1, Bit 0 = register). POSTINC1, Value on POR, BOR = n/a. POSTINC1, Details on page: = 79. POSTDEC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 6 = Uses contents of FSR1 to address data memory - value of",
    "TABLE 4-3: REGISTER FILE SUMMARY\nFSR1 post-decremented (not a physical register). POSTDEC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-decremented (not a physical register). POSTDEC1, Value on POR, BOR = n/a.",
    "TABLE 4-3: REGISTER FILE SUMMARY\nPOSTDEC1, Details on page: = 79. PREINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 1 = Uses contents of FSR1 to address data memory - value",
    "TABLE 4-3: REGISTER FILE SUMMARY\nof FSR1 pre-incremented (not a physical register). PREINC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Value on POR, BOR = n/a. PREINC1, Details on page: = 79. PLUSW1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1offset by value in WREG. PLUSW1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1offset by value in WREG. PLUSW1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1offset by value in WREG. PLUSW1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1",
    "TABLE 4-3: REGISTER FILE SUMMARY\npre-incremented (not a physical register) - value of FSR1offset by value in WREG. PLUSW1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1offset by value in WREG. PLUSW1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1offset by value in WREG. PLUSW1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1offset by value in WREG. PLUSW1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register) - value of FSR1offset by value in WREG. PLUSW1, Value on POR, BOR = n/a. PLUSW1, Details on page: = 79. FSR1H,",
    "TABLE 4-3: REGISTER FILE SUMMARY\nBit 7 = -. FSR1H, Bit 6 = -. FSR1H, Bit 5 = -. FSR1H, Bit 4 = -. FSR1H, Bit 3 = Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 2 = Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 1 = Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Bit 0 = Indirect Data Memory Address Pointer 1 High Byte. FSR1H, Value on POR, BOR = ---- 0000. FSR1H, Details on page: = 37, 79. FSR1L, Bit 7 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 6 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 5 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 4 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 3 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 2 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 1 = Indirect Data",
    "TABLE 4-3: REGISTER FILE SUMMARY\nMemory Address Pointer 1 Low Byte. FSR1L, Bit 0 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Value on POR, BOR = xxxx xxxx. FSR1L, Details on page: = 37, 79. BSR, Bit 7 = -. BSR, Bit 6 = -. BSR, Bit 5 = -. BSR, Bit 4 = -. BSR, Bit 3 = Bank Select Register. BSR, Bit 2 = Bank Select Register. BSR, Bit 1 = Bank Select Register. BSR, Bit 0 = Bank Select Register. BSR, Value on POR, BOR = ---- 0000. BSR, Details on page: = 37, 78. , Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). , Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). , Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). , Bit 4 = Uses",
    "TABLE 4-3: REGISTER FILE SUMMARY\ncontents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). , Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). , Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). , Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). , Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). , Value on POR, BOR = n/a. , Details on page: = 79. POSTINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 5 = Uses contents of FSR2 to address",
    "TABLE 4-3: REGISTER FILE SUMMARY\ndata memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Value on POR, BOR = . POSTINC2, Details on page: = . POSTDEC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2",
    "TABLE 4-3: REGISTER FILE SUMMARY\npost-decremented (not a physical register). POSTDEC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-decremented (not a physical register). POSTDEC2, Bit 0 = Uses contents of FSR2 to address data memory - value",
    "TABLE 4-3: REGISTER FILE SUMMARY\nof FSR2 post-decremented (not a physical register). POSTDEC2, Value on POR, BOR = n/a. POSTDEC2, Details on page: = 79. PREINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2",
    "TABLE 4-3: REGISTER FILE SUMMARY\npre-incremented (not a physical register). PREINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Value on POR, BOR = . PREINC2, Details on page: = 79. , Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. , Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. , Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. , Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. , Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. , Bit 2 = Uses contents of",
    "TABLE 4-3: REGISTER FILE SUMMARY\nFSR2 to address data memory - value of FSR2 pre-incremented. , Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. , Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented. , Value on POR, BOR = n/a. , Details on page: = . FSR2H, Bit 7 = - - - - Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 6 = - - - - Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 5 = - - - - Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 4 = - - - - Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 3 = - - - - Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 2 = - - - - Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 1 = - - - - Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Bit 0 = - - -",
    "TABLE 4-3: REGISTER FILE SUMMARY\n- Indirect Data Memory Address Pointer 2 High Byte. FSR2H, Value on POR, BOR = ---- 0000. FSR2H, Details on page: = 37, 79. FSR2L, Bit 7 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 6 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 5 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 4 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 3 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 2 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 1 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Bit 0 = Indirect Data Memory Address Pointer 2 Low Byte. FSR2L, Value on POR, BOR = xxxx xxxx. FSR2L, Details on page: = 37, 79\nLegend:\nx\n= unknown,\nu\n= unchanged, - = unimplemented,\nq\n= value depends on condition",
    "TABLE 4-3: REGISTER FILE SUMMARY\nNote 1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6X80 devices; always maintain these clear.\n4: These bits have multiple functions depending on the CAN module mode selection.\n5: Meaning of this register depends on whether this buffer is configured as transmit or receive.\n6: RG5 is available as an input when MCLR is disabled.\n7: This register reads all ' 0 's until the ECAN module is set up in Mode 1 or Mode 2.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nSTATUS, Bit 7 = -. STATUS, Bit 6 = -. STATUS, Bit 5 = -. STATUS, Bit 4 = N. STATUS, Bit 3 = OV. STATUS, Bit 2 = Z. STATUS, Bit 1 = DC. STATUS, Bit 0 = C. STATUS, Value on POR, BOR = ---x xxxx. STATUS, Details on page: = 37, 81. TMR0H, Bit 7 = Timer0 Register High Byte. TMR0H, Bit 6 = Timer0 Register High Byte. TMR0H, Bit 5 = Timer0 Register High Byte. TMR0H, Bit 4 = Timer0 Register High Byte. TMR0H, Bit 3 = Timer0 Register High Byte. TMR0H, Bit 2 = Timer0 Register High Byte. TMR0H, Bit 1 = Timer0 Register High Byte. TMR0H, Bit 0 = 0000. TMR0H, Value on POR, BOR = 0000. TMR0H, Details on page: = 37, 157. TMR0L, Bit 7 = Timer0 Register Low",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nByte. TMR0L, Bit 6 = Timer0 Register Low Byte. TMR0L, Bit 5 = Timer0 Register Low Byte. TMR0L, Bit 4 = Timer0 Register Low Byte. TMR0L, Bit 3 = Timer0 Register Low Byte. TMR0L, Bit 2 = Timer0 Register Low Byte. TMR0L, Bit 1 = Timer0 Register Low Byte. TMR0L, Bit 0 = xxxx. TMR0L, Value on POR, BOR = xxxx. TMR0L, Details on page: = 37, 157. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = 1111 1111.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nT0CON, Details on page: = 37, 155. OSCCON, Bit 7 = -. OSCCON, Bit 6 = -. OSCCON, Bit 5 = -. OSCCON, Bit 4 = -. OSCCON, Bit 3 = LOCK. OSCCON, Bit 2 = PLLEN. OSCCON, Bit 1 = SCS1 SCS. OSCCON, Bit 0 = ----. OSCCON, Value on POR, BOR = 0000. OSCCON, Details on page: = 27, 37. LVDCON, Bit 7 = -. LVDCON, Bit 6 = -. LVDCON, Bit 5 = IRVST. LVDCON, Bit 4 = LVDEN. LVDCON, Bit 3 = LVDL3. LVDCON, Bit 2 = LVDL2. LVDCON, Bit 1 = LVDL1. LVDCON, Bit 0 = LVDL0. LVDCON, Value on POR, BOR = --00 0101. LVDCON, Details on page: = 37, 271. WDTCON, Bit 7 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n-. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTE. WDTCON, Value on POR, BOR = ---- ---0. WDTCON, Details on page: = 37, 355. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Value on POR, BOR = 0--1 11qq. RCON, Details on page: = 37, 82, 123. TMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = xxxx. TMR1H, Value on POR, BOR = xxxx. TMR1H, Details on page: = 37, 159. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1 = Timer1 Register Low Byte. TMR1L, Bit 0 = xxxx. TMR1L, Value on POR, BOR = xxxx. TMR1L, Details on",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\npage: = 37, 159. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00 0000. T1CON, Details on page: = 37, 159. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2 Register. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = 0000. TMR2, Value on POR, BOR = 0000.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTMR2, Details on page: = 37, 162. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = 1111. PR2, Value on POR, BOR = 1111. PR2, Details on page: = 37, 163. T2CON, Bit 7 = -. T2CON, Bit 6 = T2OUTPS3. T2CON, Bit 5 = T2OUTPS2. T2CON, Bit 4 = T2OUTPS1. T2CON, Bit 3 = T2OUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1 T2CKPS0. T2CON, Bit 0 = -000. T2CON, Value on POR, BOR = 0000. T2CON,",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nDetails on page: = 37, 162. SSPBUF, Bit 7 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 0 = xxxx. SSPBUF, Value on POR, BOR = xxxx. SSPBUF, Details on page: = 37, 189. SSPADD, Bit 7 = SSP Address Register in I 2 CSlave mode. SSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 6 = SSP Address Register in I 2 CSlave mode. SSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 5 = SSP Address Register in I 2",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCSlave mode. SSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 4 = SSP Address Register in I 2 CSlave mode. SSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 3 = SSP Address Register in I 2 CSlave mode. SSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 2 = SSP Address Register in I 2 CSlave mode. SSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 1 = SSP Address Register in I 2 CSlave mode. SSPBaud Rate Reload Register in I 2 CMaster mode.. SSPADD, Bit 0 = 0000. SSPADD, Value on POR, BOR = 0000. SSPADD, Details on page: = 37, 198. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nS. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA BF. SSPSTAT, Bit 0 = 0000. SSPSTAT, Value on POR, BOR = 0000. SSPSTAT, Details on page: = 37, 199. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 = SSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3 = SSPM3. SSPCON1, Bit 2 = SSPM2. SSPCON1, Bit 1 = SSPM1. SSPCON1, Bit 0 = SSPM0 0000. SSPCON1, Value on POR, BOR = 0000. SSPCON1, Details on page: = 37, 191. SSPCON2, Bit 7 = GCEN. SSPCON2, Bit 6 = ACKSTAT. SSPCON2, Bit 5 = ACKDT. SSPCON2, Bit 4 = ACKEN. SSPCON2, Bit 3 = RCEN.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nSSPCON2, Bit 2 = PEN. SSPCON2, Bit 1 = RSEN. SSPCON2, Bit 0 = SEN. SSPCON2, Value on POR, BOR = 0000 0000. SSPCON2, Details on page: = 37, 201. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = xxxx. ADRESH, Value on POR, BOR = xxxx. ADRESH, Details on page: = 38, 257. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n= A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = xxxx. ADRESL, Value on POR, BOR = xxxx. ADRESL, Details on page: = 38, 257. ADCON0, Bit 7 = -. ADCON0, Bit 6 = -. ADCON0, Bit 5 = CHS3. ADCON0, Bit 4 = CHS2. ADCON0, Bit 3 = CHS1. ADCON0, Bit 2 = CHS0. ADCON0, Bit 1 = GO/DONE. ADCON0, Bit 0 = ADON --00. ADCON0, Value on POR, BOR = 0000. ADCON0, Details on page: = 38, 249. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nVCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = --00 0000. ADCON1, Details on page: = 38, 257. ADCON2, Bit 7 = ADFM. ADCON2, Bit 6 = -. ADCON2, Bit 5 = ACQT2. ADCON2, Bit 4 = ACQT1. ADCON2, Bit 3 = ACQT0. ADCON2, Bit 2 = ADCS2. ADCON2, Bit 1 = ADCS1. ADCON2, Bit 0 = ADCS0. ADCON2, Value on POR, BOR = 0-00 0000. ADCON2, Details on page: = 38, 251. CCPR1H, Bit 7 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Enhanced Capture/Compare/PWM Register 1 High Byte.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCCPR1H, Bit 5 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 2 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Enhanced Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = xxxx. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Details on page: = 38, 173. CCPR1L, Bit 7 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Enhanced Capture/Compare/PWM",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRegister 1 Low Byte. CCPR1L, Bit 2 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Enhanced Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Details on page: = 38, 172. CCP1CON, Bit 7 = P1M1. CCP1CON, Bit 6 = P1M0. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = 0000 0000. CCP1CON, Details on page: = 38, 172. CCPR2H, Bit 7 = Capture/Compare/PWM Register 2 High",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nByte. CCPR2H, Bit 6 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 5 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 4 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 3 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 2 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 1 = Capture/Compare/PWM Register 2 High Byte. CCPR2H, Bit 0 = xxxx. CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Details on page: = 38, 172. CCPR2L, Bit 7 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 6 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 5 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 4 = Capture/Compare/PWM Register 2 Low Byte.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCCPR2L, Bit 3 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 2 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 1 = Capture/Compare/PWM Register 2 Low Byte. CCPR2L, Bit 0 = xxxx. CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Details on page: = 38, 172. CCP2CON, Bit 7 = -. CCP2CON, Bit 6 = -. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0 --00. CCP2CON, Value on POR, BOR = 0000. CCP2CON, Details on page: = 38, 172. ECCP1AS, Bit 7 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nECCPASE. ECCP1AS, Bit 6 = ECCPAS2. ECCP1AS, Bit 5 = ECCPAS1. ECCP1AS, Bit 4 = ECCPAS0. ECCP1AS, Bit 3 = PSSAC1. ECCP1AS, Bit 2 = PSSAC0. ECCP1AS, Bit 1 = PSSBD1. ECCP1AS, Bit 0 = PSSBD0 0000. ECCP1AS, Value on POR, BOR = 0000. ECCP1AS, Details on page: = 38, 172. CVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0 0000. CVRCON, Value on POR, BOR = 0000. CVRCON, Details on page: = 38, 265. CMCON, Bit",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Value on POR, BOR = 0000 0000. CMCON, Details on page: = 38, 259. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit 2 = Timer3 Register High Byte. TMR3H, Bit 1 = Timer3 Register High Byte. TMR3H, Bit 0 = xxxx. TMR3H, Value on POR, BOR = xxxx. TMR3H, Details on page: = 38, 164.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte. TMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4 = Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register Low Byte. TMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = xxxx. TMR3L, Value on POR, BOR = xxxx. TMR3L, Details on page: = 38, 164. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTMR3ON. T3CON, Value on POR, BOR = 0000 0000. T3CON, Details on page: = 38, 164. PSPCON, Bit 7 = IBF. PSPCON, Bit 6 = OBF. PSPCON, Bit 5 = IBOV. PSPCON, Bit 4 = PSPMODE. PSPCON, Bit 3 = -. PSPCON, Bit 2 = -. PSPCON, Bit 1 = -. PSPCON, Bit 0 = -. PSPCON, Value on POR, BOR = 0000 ----. PSPCON, Details on page: = 38, 153\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6X80 devices; always maintain these clear.\n4: These bits have multiple functions depending on the CAN module mode selection.\n5: Meaning of this register depends on whether this buffer is configured as transmit or receive.\n6: RG5 is available as an input when MCLR is disabled.\n7: This register reads all ' 0 's until the ECAN module is set up in Mode 1 or Mode 2.",
    "TABLE 4-3:\nSPBRG, Bit 7 = USART Baud Rate Generator. SPBRG, Bit 6 = USART Baud Rate Generator. SPBRG, Bit 5 = USART Baud Rate Generator. SPBRG, Bit 4 = USART Baud Rate Generator. SPBRG, Bit 3 = USART Baud Rate Generator. SPBRG, Bit 2 = USART Baud Rate Generator. SPBRG, Bit 1 = USART Baud Rate Generator. SPBRG, Bit 0 = USART Baud Rate Generator. SPBRG, Value on POR, BOR = 0000 0000. SPBRG, Details on page: = 38, 239. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register. RCREG, Bit 5 = USART Receive Register. RCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000",
    "TABLE 4-3:\n0000. RCREG, Details on page: = 38, 241. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register. TXREG, Bit 5 = USART Transmit Register. TXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000 0000. TXREG, Details on page: = 38, 239. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000 0010. TXSTA, Details on page: = 38, 230. RCSTA, Bit 7 = SPEN.",
    "TABLE 4-3:\nRCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000 000x. RCSTA, Details on page: = 38, 231. EEADRH, Bit 7 = -. EEADRH, Bit 6 = -. EEADRH, Bit 5 = -. EEADRH, Bit 4 = -. EEADRH, Bit 3 = -. EEADRH, Bit 2 = -. EEADRH, Bit 1 = EEAdr Register High. EEADRH, Bit 0 = EEAdr Register High. EEADRH, Value on POR, BOR = ---- --00. EEADRH, Details on page: = 38, 105. EEADR, Bit 7 = Data EEPROMAddress Register. EEADR, Bit 6 = Data EEPROMAddress Register. EEADR, Bit 5 = Data EEPROMAddress Register.",
    "TABLE 4-3:\nEEADR, Bit 4 = Data EEPROMAddress Register. EEADR, Bit 3 = Data EEPROMAddress Register. EEADR, Bit 2 = Data EEPROMAddress Register. EEADR, Bit 1 = Data EEPROMAddress Register. EEADR, Bit 0 = Data EEPROMAddress Register. EEADR, Value on POR, BOR = 0000 0000. EEADR, Details on page: = 38, 105. EEDATA, Bit 7 = Data EEPROMData Register. EEDATA, Bit 6 = Data EEPROMData Register. EEDATA, Bit 5 = Data EEPROMData Register. EEDATA, Bit 4 = Data EEPROMData Register. EEDATA, Bit 3 = Data EEPROMData Register. EEDATA, Bit 2 = Data EEPROMData Register. EEDATA, Bit 1 = Data EEPROMData Register. EEDATA, Bit 0 = Data EEPROMData Register. EEDATA, Value on POR, BOR = 0000 0000. EEDATA, Details on page: = 38, 105. EECON2, Bit 7",
    "TABLE 4-3:\n= Data EEPROMControl Register 2 (not a physical register). EECON2, Bit 6 = Data EEPROMControl Register 2 (not a physical register). EECON2, Bit 5 = Data EEPROMControl Register 2 (not a physical register). EECON2, Bit 4 = Data EEPROMControl Register 2 (not a physical register). EECON2, Bit 3 = Data EEPROMControl Register 2 (not a physical register). EECON2, Bit 2 = Data EEPROMControl Register 2 (not a physical register). EECON2, Bit 1 = Data EEPROMControl Register 2 (not a physical register). EECON2, Bit 0 = Data EEPROMControl Register 2 (not a physical register). EECON2, Value on POR, BOR = ---- ----. EECON2, Details on page: = 38, 105. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 =",
    "TABLE 4-3:\nWRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on POR, BOR = 00-0 x000. EECON1, Details on page: = 38, 102. IPR3, Bit 7 = IRXIP. IPR3, Bit 6 = WAKIP. IPR3, Bit 5 = ERRIP. IPR3, Bit 4 = TXB2IP/ TXBnIP. IPR3, Bit 3 = TXB1IP. IPR3, Bit 2 = TXB0IP. IPR3, Bit 1 = RXB1IP/ RXBnIP. IPR3, Bit 0 = RXB0IP/ FIFOWMIP. IPR3, Value on POR, BOR = 1111 1111. IPR3, Details on page: = 39, 122. PIR3, Bit 7 = IRXIF. PIR3, Bit 6 = WAKIF. PIR3, Bit 5 = ERRIF. PIR3, Bit 4 = TXB2IF/ TXBnIF.",
    "TABLE 4-3:\nPIR3, Bit 3 = TXB1IF. PIR3, Bit 2 = TXB0IF. PIR3, Bit 1 = RXB1IF/ RXBnIF. PIR3, Bit 0 = RXB0IF/ FIFOWMIF. PIR3, Value on POR, BOR = 0000 0000. PIR3, Details on page: = 39, 116. PIE3, Bit 7 = IRXIE. PIE3, Bit 6 = WAKIE. PIE3, Bit 5 = ERRIE. PIE3, Bit 4 = TXB2IE/ TXBnIE. PIE3, Bit 3 = TXB1IE. PIE3, Bit 2 = TXB0IE. PIE3, Bit 1 = RXB1IE/ RXBnIE. PIE3, Bit 0 = RXB0IE/ FIFOWMIE. PIE3, Value on POR, BOR = 0000 0000. PIE3, Details on page: = 39, 119. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 =",
    "TABLE 4-3:\nEEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = -1-1 1111. IPR2, Details on page: = 39, 121. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = -0-0 0000. PIR2, Details on page: = 39, 115. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE.",
    "TABLE 4-3:\nPIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = -0-0 0000. PIE2, Details on page: = 39, 118. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0111 1111. IPR1, Details on page: = 39, 120. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF.",
    "TABLE 4-3:\nPIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000 0000. PIR1, Details on page: = 39, 114. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000 0000. PIE1, Details on page: = 39, 117. MEMCON (3), Bit 7 = EBDIS. MEMCON (3), Bit 6 = -. MEMCON (3), Bit 5 = WAIT1. MEMCON (3), Bit 4 = WAIT0. MEMCON (3), Bit 3 = -. MEMCON (3), Bit 2 = -. MEMCON (3), Bit 1 = WM1. MEMCON (3), Bit 0 =",
    "TABLE 4-3:\nWM0. MEMCON (3), Value on POR, BOR = 0-00 --00. MEMCON (3), Details on page: = 39, 94. TRISJ (3), Bit 7 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 6 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 5 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 4 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 3 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 2 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 1 = Data Direction Control Register for PORTJ. TRISJ (3), Bit 0 = Data Direction Control Register for PORTJ. TRISJ (3), Value on POR, BOR = 1111 1111. TRISJ (3), Details on page: = 39, 151. TRISH (3), Bit 7 = Data Direction Control Register for PORTH. TRISH (3), Bit 6 = Data Direction Control Register for",
    "TABLE 4-3:\nPORTH. TRISH (3), Bit 5 = Data Direction Control Register for PORTH. TRISH (3), Bit 4 = Data Direction Control Register for PORTH. TRISH (3), Bit 3 = Data Direction Control Register for PORTH. TRISH (3), Bit 2 = Data Direction Control Register for PORTH. TRISH (3), Bit 1 = Data Direction Control Register for PORTH. TRISH (3), Bit 0 = Data Direction Control Register for PORTH. TRISH (3), Value on POR, BOR = 1111 1111. TRISH (3), Details on page: = 39, 148. TRISG, Bit 7 = -. TRISG, Bit 6 = -. TRISG, Bit 5 = -. TRISG, Bit 4 = Data Direction Control Register for. TRISG, Bit 3 = PORTG. TRISG, Bit 2 = PORTG. TRISG, Bit 1 = PORTG. TRISG, Bit 0 = PORTG. TRISG, Value on POR, BOR = ---1 1111. TRISG, Details on page: = 39, 145. TRISF, Bit 7 = Data Direction Control Register for",
    "TABLE 4-3:\nPORTF. TRISF, Bit 6 = Data Direction Control Register for PORTF. TRISF, Bit 5 = Data Direction Control Register for PORTF. TRISF, Bit 4 = Data Direction Control Register for PORTF. TRISF, Bit 3 = Data Direction Control Register for PORTF. TRISF, Bit 2 = Data Direction Control Register for PORTF. TRISF, Bit 1 = Data Direction Control Register for PORTF. TRISF, Bit 0 = Data Direction Control Register for PORTF. TRISF, Value on POR, BOR = 1111 1111. TRISF, Details on page: = 39, 141. TRISE, Bit 7 = Data Direction Control Register for PORTE. TRISE, Bit 6 = Data Direction Control Register for PORTE. TRISE, Bit 5 = Data Direction Control Register for PORTE. TRISE, Bit 4 = Data Direction Control Register for PORTE. TRISE, Bit 3 = Data Direction Control Register for PORTE. TRISE, Bit 2 = Data Direction Control Register for PORTE. TRISE, Bit 1 = Data Direction Control Register for PORTE. TRISE, Bit 0 = Data Direction Control Register for PORTE. TRISE, Value on POR, BOR = 1111 1111. TRISE, Details",
    "TABLE 4-3:\non page: = 39, 138. TRISD, Bit 7 = Data Direction Control Register for PORTD. TRISD, Bit 6 = Data Direction Control Register for PORTD. TRISD, Bit 5 = Data Direction Control Register for PORTD. TRISD, Bit 4 = Data Direction Control Register for PORTD. TRISD, Bit 3 = Data Direction Control Register for PORTD. TRISD, Bit 2 = Data Direction Control Register for PORTD. TRISD, Bit 1 = Data Direction Control Register for PORTD. TRISD, Bit 0 = Data Direction Control Register for PORTD. TRISD, Value on POR, BOR = 1111 1111. TRISD, Details on page: = 39, 135. TRISC, Bit 7 = Data Direction Control Register for PORTC. TRISC, Bit 6 = Data Direction Control Register for PORTC. TRISC, Bit 5 = Data Direction Control Register for PORTC. TRISC, Bit 4 = Data Direction Control Register for PORTC. TRISC, Bit 3 = Data Direction Control Register for PORTC. TRISC, Bit 2 = Data Direction Control Register for PORTC. TRISC, Bit 1 = Data Direction Control Register for PORTC. TRISC, Bit 0 =",
    "TABLE 4-3:\nData Direction Control Register for PORTC. TRISC, Value on POR, BOR = 1111 1111. TRISC, Details on page: = 39, 131. TRISB, Bit 7 = Data Direction Control Register for PORTB. TRISB, Bit 6 = Data Direction Control Register for PORTB. TRISB, Bit 5 = Data Direction Control Register for PORTB. TRISB, Bit 4 = Data Direction Control Register for PORTB. TRISB, Bit 3 = Data Direction Control Register for PORTB. TRISB, Bit 2 = Data Direction Control Register for PORTB. TRISB, Bit 1 = Data Direction Control Register for PORTB. TRISB, Bit 0 = Data Direction Control Register for PORTB. TRISB, Value on POR, BOR = 1111 1111. TRISB, Details on page: = 39, 128. TRISA, Bit 7 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 6 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 5 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 4 = - TRISA6 (1) Data",
    "TABLE 4-3:\nDirection Control Register for PORTA. TRISA, Bit 3 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 2 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 1 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Bit 0 = - TRISA6 (1) Data Direction Control Register for PORTA. TRISA, Value on POR, BOR = -111 1111. TRISA, Details on page: = 39, 125. LATJ (3), Bit 7 = Read PORTJ. LATJ (3), Bit 6 = Data Latch,. LATJ (3), Bit 5 = Write PORTJ Data Latch. LATJ (3), Bit 4 = Write PORTJ Data Latch. LATJ (3), Bit 3 = Write PORTJ Data Latch. LATJ (3), Bit 2 = Write PORTJ Data Latch. LATJ (3), Bit 1 = Write PORTJ Data Latch. LATJ (3), Bit 0 = Write PORTJ Data Latch. LATJ (3), Value on",
    "TABLE 4-3:\nPOR, BOR = xxxx xxxx. LATJ (3), Details on page: = 39, 151. LATH (3), Bit 7 = Read PORTHData Latch, Write PORTH Data Latch. LATH (3), Bit 6 = Read PORTHData Latch, Write PORTH Data Latch. LATH (3), Bit 5 = Read PORTHData Latch, Write PORTH Data Latch. LATH (3), Bit 4 = Read PORTHData Latch, Write PORTH Data Latch. LATH (3), Bit 3 = Read PORTHData Latch, Write PORTH Data Latch. LATH (3), Bit 2 = Read PORTHData Latch, Write PORTH Data Latch. LATH (3), Bit 1 = Read PORTHData Latch, Write PORTH Data Latch. LATH (3), Bit 0 = Read PORTHData Latch, Write PORTH Data Latch. LATH (3), Value on POR, BOR = xxxx xxxx. LATH (3), Details on page: = 39, 148. LATG, Bit 7 = -. LATG, Bit 6 = -. LATG, Bit 5",
    "TABLE 4-3:\n= -. LATG, Bit 4 = -. LATG, Bit 3 = -. LATG, Bit 2 = -. LATG, Bit 1 = -. LATG, Bit 0 = -. LATG, Value on POR, BOR = ---x xxxx. LATG, Details on page: = 39, 145. LATF, Bit 7 = . LATF, Bit 6 = -. LATF, Bit 5 = -. LATF, Bit 4 = Read. LATF, Bit 3 = PORTGData Latch, Write PORTGData Latch. LATF, Bit 2 = PORTGData Latch, Write PORTGData Latch. LATF, Bit 1 = PORTGData Latch, Write PORTGData Latch. LATF, Bit 0 = PORTGData Latch, Write PORTGData Latch. LATF, Value on POR, BOR = xxxx xxxx. LATF, Details on page: = 39, 141. , Bit 7 = Read PORTFData Latch, Write PORTFDataLatch Read PORTEData Latch, Write PORTEData Latch. , Bit 6 = Read PORTFData",
    "TABLE 4-3:\nLatch, Write PORTFDataLatch Read PORTEData Latch, Write PORTEData Latch. , Bit 5 = Read PORTFData Latch, Write PORTFDataLatch Read PORTEData Latch, Write PORTEData Latch. , Bit 4 = Read PORTFData Latch, Write PORTFDataLatch Read PORTEData Latch, Write PORTEData Latch. , Bit 3 = Read PORTFData Latch, Write PORTFDataLatch Read PORTEData Latch, Write PORTEData Latch. , Bit 2 = Read PORTFData Latch, Write PORTFDataLatch Read PORTEData Latch, Write PORTEData Latch. , Bit 1 = Read PORTFData Latch, Write PORTFDataLatch Read PORTEData Latch, Write PORTEData Latch. , Bit 0 = Read PORTFData Latch, Write PORTFDataLatch Read PORTEData Latch, Write PORTEData Latch. , Value on POR, BOR = xxxx xxxx. , Details on page: = 39, 138. LATE, Bit 7 = . LATE, Bit 6 = . LATE, Bit 5 = . LATE, Bit 4 = . LATE, Bit 3 = . LATE, Bit 2 = . LATE, Bit 1 =",
    "TABLE 4-3:\n. LATE, Bit 0 = . LATE, Value on POR, BOR = . LATE, Details on page: = . LATD, Bit 7 = Read PORTDData Latch, Write PORTD Data Latch. LATD, Bit 6 = Read PORTDData Latch, Write PORTD Data Latch. LATD, Bit 5 = Read PORTDData Latch, Write PORTD Data Latch. LATD, Bit 4 = Read PORTDData Latch, Write PORTD Data Latch. LATD, Bit 3 = Read PORTDData Latch, Write PORTD Data Latch. LATD, Bit 2 = Read PORTDData Latch, Write PORTD Data Latch. LATD, Bit 1 = Read PORTDData Latch, Write PORTD Data Latch. LATD, Bit 0 = Read PORTDData Latch, Write PORTD Data Latch. LATD, Value on POR, BOR = xxxx xxxx. LATD, Details on page: = 39, 133. LATC, Bit 7 = Read PORTCData Latch, Write PORTC Data Latch. LATC, Bit 6 = Read PORTCData Latch, Write PORTC Data Latch. LATC, Bit 5 = Read",
    "TABLE 4-3:\nPORTCData Latch, Write PORTC Data Latch. LATC, Bit 4 = Read PORTCData Latch, Write PORTC Data Latch. LATC, Bit 3 = Read PORTCData Latch, Write PORTC Data Latch. LATC, Bit 2 = Read PORTCData Latch, Write PORTC Data Latch. LATC, Bit 1 = Read PORTCData Latch, Write PORTC Data Latch. LATC, Bit 0 = Read PORTCData Latch, Write PORTC Data Latch. LATC, Value on POR, BOR = xxxx xxxx. LATC, Details on page: = 39, 131 39, 128. LATB LATA, Bit 7 = Read PORTBData - LATA6 (1) Read PORTAData Latch, Write PORTAData Latch (1). LATB LATA, Bit 6 = Latch,. LATB LATA, Bit 5 = Write PORTBData. LATB LATA, Bit 4 = Latch. LATB LATA, Bit 3 = Read PORTBData - LATA6 (1) Read PORTAData Latch, Write PORTAData Latch (1). LATB LATA, Bit 2 = Read",
    "TABLE 4-3:\nPORTBData - LATA6 (1) Read PORTAData Latch, Write PORTAData Latch (1). LATB LATA, Bit 1 = Read PORTBData - LATA6 (1) Read PORTAData Latch, Write PORTAData Latch (1). LATB LATA, Bit 0 = Read PORTBData - LATA6 (1) Read PORTAData Latch, Write PORTAData Latch (1). LATB LATA, Value on POR, BOR = xxxx xxxx -xxx xxxx. LATB LATA, Details on page: = 39, 125",
    "REGISTER FILE SUMMARY (CONTINUED)\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6X80 devices; always maintain these clear.\n4: These bits have multiple functions depending on the CAN module mode selection.\n5: Meaning of this register depends on whether this buffer is configured as transmit or receive.\n6: RG5 is available as an input when MCLR is disabled.\n7: This register reads all ' 0 's until the ECAN module is set up in Mode 1 or Mode 2.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPORTJ (3), Bit 7 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 6 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 5 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 4 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 3 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 2 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 1 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Bit 0 = Read PORTJ pins, Write PORTJ Data Latch. PORTJ (3), Value on POR, BOR = xxxx xxxx. PORTJ (3), Details on page: = 40, 151. PORTH (3), Bit 7 = Read PORTHpins, Write PORTHData Latch. PORTH (3), Bit 6 = Read PORTHpins, Write PORTHData Latch. PORTH (3), Bit 5 = Read",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPORTHpins, Write PORTHData Latch. PORTH (3), Bit 4 = Read PORTHpins, Write PORTHData Latch. PORTH (3), Bit 3 = Read PORTHpins, Write PORTHData Latch. PORTH (3), Bit 2 = Read PORTHpins, Write PORTHData Latch. PORTH (3), Bit 1 = Read PORTHpins, Write PORTHData Latch. PORTH (3), Bit 0 = Read PORTHpins, Write PORTHData Latch. PORTH (3), Value on POR, BOR = xxxx xxxx. PORTH (3), Details on page: = 40, 148. PORTG, Bit 7 = -. PORTG, Bit 6 = -. PORTG, Bit 5 = RG5 (6). PORTG, Bit 4 = Read. PORTG, Bit 3 = PORTGpins, Write PORTGData Latch. PORTG, Bit 2 = PORTGpins, Write PORTGData Latch. PORTG, Bit 1 = PORTGpins, Write PORTGData Latch. PORTG, Bit 0 = PORTGpins, Write",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPORTGData Latch. PORTG, Value on POR, BOR = --0x xxxx. PORTG, Details on page: = 40, 145. PORTF, Bit 7 = Read PORTFpins, Write PORTF Data Latch. PORTF, Bit 6 = Read PORTFpins, Write PORTF Data Latch. PORTF, Bit 5 = Read PORTFpins, Write PORTF Data Latch. PORTF, Bit 4 = Read PORTFpins, Write PORTF Data Latch. PORTF, Bit 3 = Read PORTFpins, Write PORTF Data Latch. PORTF, Bit 2 = Read PORTFpins, Write PORTF Data Latch. PORTF, Bit 1 = Read PORTFpins, Write PORTF Data Latch. PORTF, Bit 0 = Read PORTFpins, Write PORTF Data Latch. PORTF, Value on POR, BOR = xxxx xxxx. PORTF, Details on page: = 40, 141. PORTE, Bit 7 = Read PORTEpins, Write PORTEDataLatch. PORTE, Bit 6 = Read PORTEpins, Write PORTEDataLatch. PORTE, Bit 5 = Read PORTEpins, Write PORTEDataLatch. PORTE,",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nBit 4 = Read PORTEpins, Write PORTEDataLatch. PORTE, Bit 3 = Read PORTEpins, Write PORTEDataLatch. PORTE, Bit 2 = Read PORTEpins, Write PORTEDataLatch. PORTE, Bit 1 = Read PORTEpins, Write PORTEDataLatch. PORTE, Bit 0 = Read PORTEpins, Write PORTEDataLatch. PORTE, Value on POR, BOR = xxxx xxxx. PORTE, Details on page: = 40, 136. PORTD, Bit 7 = Read PORTDpins, Write PORTDData Latch. PORTD, Bit 6 = Read PORTDpins, Write PORTDData Latch. PORTD, Bit 5 = Read PORTDpins, Write PORTDData Latch. PORTD, Bit 4 = Read PORTDpins, Write PORTDData Latch. PORTD, Bit 3 = Read PORTDpins, Write PORTDData Latch. PORTD, Bit 2 = Read PORTDpins, Write PORTDData Latch. PORTD, Bit 1 = Read PORTDpins, Write PORTDData Latch. PORTD, Bit 0 = Read PORTDpins, Write PORTDData Latch. PORTD, Value on POR, BOR =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nxxxx xxxx. PORTD, Details on page: = 40, 133. PORTC, Bit 7 = Read PORTCpins, Write PORTCData Latch. PORTC, Bit 6 = Read PORTCpins, Write PORTCData Latch. PORTC, Bit 5 = Read PORTCpins, Write PORTCData Latch. PORTC, Bit 4 = Read PORTCpins, Write PORTCData Latch. PORTC, Bit 3 = Read PORTCpins, Write PORTCData Latch. PORTC, Bit 2 = Read PORTCpins, Write PORTCData Latch. PORTC, Bit 1 = Read PORTCpins, Write PORTCData Latch. PORTC, Bit 0 = Read PORTCpins, Write PORTCData Latch. PORTC, Value on POR, BOR = xxxx xxxx. PORTC, Details on page: = 40, 131. PORTB, Bit 7 = Read PORTBpins, Write PORTBDataLatch. PORTB, Bit 6 = Read PORTBpins, Write PORTBDataLatch. PORTB, Bit 5 = Read PORTBpins, Write PORTBDataLatch. PORTB, Bit 4 = Read",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPORTBpins, Write PORTBDataLatch. PORTB, Bit 3 = Read PORTBpins, Write PORTBDataLatch. PORTB, Bit 2 = Read PORTBpins, Write PORTBDataLatch. PORTB, Bit 1 = Read PORTBpins, Write PORTBDataLatch. PORTB, Bit 0 = Read PORTBpins, Write PORTBDataLatch. PORTB, Value on POR, BOR = xxxx xxxx. PORTB, Details on page: = 40, 128. PORTA, Bit 7 = -. PORTA, Bit 6 = RA6 (1). PORTA, Bit 5 = Read PORTApins, Write PORTAData Latch (1). PORTA, Bit 4 = Read PORTApins, Write PORTAData Latch (1). PORTA, Bit 3 = Read PORTApins, Write PORTAData Latch (1). PORTA, Bit 2 = Read PORTApins, Write PORTAData Latch (1). PORTA, Bit 1 = Read PORTApins, Write PORTAData Latch (1). PORTA, Bit 0 = Read",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPORTApins, Write PORTAData Latch (1). PORTA, Value on POR, BOR = -x0x 0000. PORTA, Details on page: = 40, 125. SPBRGH, Bit 7 = Enhanced USARTBaud Rate Generator High Byte. SPBRGH, Bit 6 = Enhanced USARTBaud Rate Generator High Byte. SPBRGH, Bit 5 = Enhanced USARTBaud Rate Generator High Byte. SPBRGH, Bit 4 = Enhanced USARTBaud Rate Generator High Byte. SPBRGH, Bit 3 = Enhanced USARTBaud Rate Generator High Byte. SPBRGH, Bit 2 = Enhanced USARTBaud Rate Generator High Byte. SPBRGH, Bit 1 = Enhanced USARTBaud Rate Generator High Byte. SPBRGH, Bit 0 = Enhanced USARTBaud Rate Generator High Byte. SPBRGH, Value on POR, BOR = 0000 0000. SPBRGH, Details on page: = 40, 233. BAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nSCKP. BAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Value on POR, BOR = -1-0 0-00. BAUDCON, Details on page: = 40, 233. ECCP1DEL, Bit 7 = PRSEN. ECCP1DEL, Bit 6 = PDC6. ECCP1DEL, Bit 5 = PDC5. ECCP1DEL, Bit 4 = PDC4. ECCP1DEL, Bit 3 = PDC3. ECCP1DEL, Bit 2 = PDC2. ECCP1DEL, Bit 1 = PDC1. ECCP1DEL, Bit 0 = PDC0. ECCP1DEL, Value on POR, BOR = 0000 0000. ECCP1DEL, Details on page: = 40, 187. TXERRCNT, Bit 7 = TEC7. TXERRCNT, Bit 6 = TEC6. TXERRCNT, Bit 5 = TEC5. TXERRCNT, Bit 4",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n= TEC4. TXERRCNT, Bit 3 = TEC3. TXERRCNT, Bit 2 = TEC2. TXERRCNT, Bit 1 = TEC1. TXERRCNT, Bit 0 = TEC0. TXERRCNT, Value on POR, BOR = 0000 0000. TXERRCNT, Details on page: = 40, 288. RXERRCNT, Bit 7 = REC7. RXERRCNT, Bit 6 = REC6. RXERRCNT, Bit 5 = REC5. RXERRCNT, Bit 4 = REC4. RXERRCNT, Bit 3 = REC3. RXERRCNT, Bit 2 = REC2. RXERRCNT, Bit 1 = REC1. RXERRCNT, Bit 0 = REC0. RXERRCNT, Value on POR, BOR = 0000 0000. RXERRCNT, Details on page: = 40, 296. COMSTAT Mode 0, Bit 7 = RXB0OVFL. COMSTAT Mode 0, Bit 6 = RXB1OVFL.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCOMSTAT Mode 0, Bit 5 = TXBO. COMSTAT Mode 0, Bit 4 = TXBP. COMSTAT Mode 0, Bit 3 = RXBP. COMSTAT Mode 0, Bit 2 = TXWARN. COMSTAT Mode 0, Bit 1 = RXWARN. COMSTAT Mode 0, Bit 0 = EWARN. COMSTAT Mode 0, Value on POR, BOR = 0000 0000. COMSTAT Mode 0, Details on page: = 40, 284. COMSTAT Mode 1, Bit 7 = -. COMSTAT Mode 1, Bit 6 = RXBnOVFL. COMSTAT Mode 1, Bit 5 = TXBO. COMSTAT Mode 1, Bit 4 = TXBP. COMSTAT Mode 1, Bit 3 = RXBP. COMSTAT Mode 1, Bit 2 = TXWARN. COMSTAT Mode 1, Bit 1 = RXWARN. COMSTAT Mode 1, Bit 0 = EWARN. COMSTAT Mode 1, Value on POR, BOR = -000 0000. COMSTAT Mode 1, Details on page:",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n= 40, 284. COMSTAT Mode 2, Bit 7 = FIFOEMPTY. COMSTAT Mode 2, Bit 6 = RXBnOVFL. COMSTAT Mode 2, Bit 5 = TXBO. COMSTAT Mode 2, Bit 4 = TXBP. COMSTAT Mode 2, Bit 3 = RXBP. COMSTAT Mode 2, Bit 2 = TXWARN. COMSTAT Mode 2, Bit 1 = RXWARN. COMSTAT Mode 2, Bit 0 = EWARN. COMSTAT Mode 2, Value on POR, BOR = 0000 0000. COMSTAT Mode 2, Details on page: = 40, 284. CIOCON, Bit 7 = TX2SRC. CIOCON, Bit 6 = TX2EN. CIOCON, Bit 5 = ENDRHI. CIOCON, Bit 4 = CANCAP. CIOCON, Bit 3 = -. CIOCON, Bit 2 = -. CIOCON, Bit 1 = -. CIOCON, Bit 0 = -. CIOCON, Value on POR, BOR = 0000 ----.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nCIOCON, Details on page: = 40, 318. BRGCON3, Bit 7 = WAKDIS. BRGCON3, Bit 6 = WAKFIL. BRGCON3, Bit 5 = -. BRGCON3, Bit 4 = -. BRGCON3, Bit 3 = -. BRGCON3, Bit 2 = SEG2PH2. BRGCON3, Bit 1 = SEG2PH1. BRGCON3, Bit 0 = SEG2PH0. BRGCON3, Value on POR, BOR = 00-- -000. BRGCON3, Details on page: = 40, 317. BRGCON2, Bit 7 = SEG2PHT. BRGCON2, Bit 6 = SAM. BRGCON2, Bit 5 = SEG1PH2. BRGCON2, Bit 4 = SEG1PH1. BRGCON2, Bit 3 = SEG1PH0. BRGCON2, Bit 2 = PRSEG2. BRGCON2, Bit 1 = PRSEG1. BRGCON2, Bit 0 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPRSEG0. BRGCON2, Value on POR, BOR = 0000 0000. BRGCON2, Details on page: = 40, 317. BRGCON1, Bit 7 = SJW1. BRGCON1, Bit 6 = SJW0. BRGCON1, Bit 5 = BRP5. BRGCON1, Bit 4 = BRP4. BRGCON1, Bit 3 = BRP3. BRGCON1, Bit 2 = BRP2. BRGCON1, Bit 1 = BRP1. BRGCON1, Bit 0 = BRP0. BRGCON1, Value on POR, BOR = 0000 0000. BRGCON1, Details on page: = 40, 317. CANCON Mode 0, Bit 7 = REQOP2. CANCON Mode 0, Bit 6 = REQOP1. CANCON Mode 0, Bit 5 = REQOP0. CANCON Mode 0, Bit 4 = ABAT. CANCON Mode 0, Bit 3 = WIN2. CANCON Mode 0, Bit 2 = WIN1. CANCON Mode 0, Bit 1 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nWIN0. CANCON Mode 0, Bit 0 = -. CANCON Mode 0, Value on POR, BOR = 1000 000-. CANCON Mode 0, Details on page: = 40, 239. CANCON Mode 1, Bit 7 = REQOP2. CANCON Mode 1, Bit 6 = REQOP1. CANCON Mode 1, Bit 5 = REQOP0. CANCON Mode 1, Bit 4 = ABAT. CANCON Mode 1, Bit 3 = -. CANCON Mode 1, Bit 2 = -. CANCON Mode 1, Bit 1 = -. CANCON Mode 1, Bit 0 = -. CANCON Mode 1, Value on POR, BOR = 1000 ----. CANCON Mode 1, Details on page: = 40, 239. CANCON Mode 2, Bit 7 = REQOP2. CANCON Mode 2, Bit 6 = REQOP1. CANCON Mode 2, Bit 5 = REQOP0. CANCON Mode 2, Bit 4 = ABAT. CANCON Mode 2, Bit 3 = FP3. CANCON Mode 2, Bit 2 = FP2. CANCON Mode 2, Bit",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n1 = FP1. CANCON Mode 2, Bit 0 = FP0. CANCON Mode 2, Value on POR, BOR = 1000 0000. CANCON Mode 2, Details on page: = 40, 239. CANSTAT Mode 0, Bit 7 = OPMODE2. CANSTAT Mode 0, Bit 6 = OPMODE1. CANSTAT Mode 0, Bit 5 = OPMODE0. CANSTAT Mode 0, Bit 4 = -. CANSTAT Mode 0, Bit 3 = ICODE2. CANSTAT Mode 0, Bit 2 = ICODE1. CANSTAT Mode 0, Bit 1 = ICODE0. CANSTAT Mode 0, Bit 0 = -. CANSTAT Mode 0, Value on POR, BOR = 000- 0000. CANSTAT Mode 0, Details on page: = 40, 239. CANSTAT Modes 0, 1, Bit 7 = OPMODE2. CANSTAT Modes 0, 1, Bit 6 = OPMODE1. CANSTAT Modes 0, 1, Bit 5 = OPMODE0. CANSTAT Modes 0, 1, Bit 4 = EICODE4. CANSTAT Modes 0, 1, Bit 3 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nEICODE3. CANSTAT Modes 0, 1, Bit 2 = EICODE2. CANSTAT Modes 0, 1, Bit 1 = EICODE1. CANSTAT Modes 0, 1, Bit 0 = EICODE0. CANSTAT Modes 0, 1, Value on POR, BOR = 0000 0000. CANSTAT Modes 0, 1, Details on page: = 40, 239. ECANCON, Bit 7 = MDSEL1. ECANCON, Bit 6 = MDSEL0. ECANCON, Bit 5 = FIFOWM. ECANCON, Bit 4 = EWIN4. ECANCON, Bit 3 = EWIN3. ECANCON, Bit 2 = EWIN2. ECANCON, Bit 1 = EWIN1. ECANCON, Bit 0 = EWIN0. ECANCON, Value on POR, BOR = 0001 0000. ECANCON, Details on page: = 40, 323. RXB0D7, Bit 7 = RXB0D77. RXB0D7, Bit 6 = RXB0D76.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXB0D7, Bit 5 = RXB0D75. RXB0D7, Bit 4 = RXB0D74. RXB0D7, Bit 3 = RXB0D73. RXB0D7, Bit 2 = RXB0D72. RXB0D7, Bit 1 = RXB0D71. RXB0D7, Bit 0 = RXB0D70. RXB0D7, Value on POR, BOR = xxxx xxxx. RXB0D7, Details on page: = 40, 230. RXB0D6, Bit 7 = RXB0D67. RXB0D6, Bit 6 = RXB0D66. RXB0D6, Bit 5 = RXB0D65. RXB0D6, Bit 4 = RXB0D64. RXB0D6, Bit 3 = RXB0D63. RXB0D6, Bit 2 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXB0D62. RXB0D6, Bit 1 = RXB0D61. RXB0D6, Bit 0 = RXB0D60. RXB0D6, Value on POR, BOR = xxxx xxxx. RXB0D6, Details on page: = 40, 230. RXB0D5, Bit 7 = RXB0D57. RXB0D5, Bit 6 = RXB0D56. RXB0D5, Bit 5 = RXB0D55. RXB0D5, Bit 4 = RXB0D54. RXB0D5, Bit 3 = RXB0D53. RXB0D5, Bit 2 = RXB0D52. RXB0D5, Bit 1 = RXB0D51. RXB0D5, Bit 0 = RXB0D50. RXB0D5, Value on POR, BOR = xxxx xxxx. RXB0D5, Details on page: =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n40, 230. RXB0D4, Bit 7 = RXB0D47. RXB0D4, Bit 6 = RXB0D46. RXB0D4, Bit 5 = RXB0D45. RXB0D4, Bit 4 = RXB0D44. RXB0D4, Bit 3 = RXB0D43. RXB0D4, Bit 2 = RXB0D42. RXB0D4, Bit 1 = RXB0D41. RXB0D4, Bit 0 = RXB0D40. RXB0D4, Value on POR, BOR = xxxx xxxx. RXB0D4, Details on page: = 40, 230. RXB0D3, Bit 7 = RXB0D37. RXB0D3, Bit 6 = RXB0D36. RXB0D3, Bit 5 = RXB0D35. RXB0D3, Bit 4 = RXB0D34.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXB0D3, Bit 3 = RXB0D33. RXB0D3, Bit 2 = RXB0D32. RXB0D3, Bit 1 = RXB0D31. RXB0D3, Bit 0 = RXB0D30. RXB0D3, Value on POR, BOR = xxxx xxxx. RXB0D3, Details on page: = 40, 230. RXB0D2, Bit 7 = RXB0D27. RXB0D2, Bit 6 = RXB0D26. RXB0D2, Bit 5 = RXB0D25. RXB0D2, Bit 4 = RXB0D24. RXB0D2, Bit 3 = RXB0D23. RXB0D2, Bit 2 = RXB0D22. RXB0D2, Bit 1 = RXB0D21. RXB0D2, Bit 0 = RXB0D20.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXB0D2, Value on POR, BOR = xxxx xxxx. RXB0D2, Details on page: = 40, 230. RXB0D1, Bit 7 = RXB0D17. RXB0D1, Bit 6 = RXB0D16. RXB0D1, Bit 5 = RXB0D15. RXB0D1, Bit 4 = RXB0D14. RXB0D1, Bit 3 = RXB0D13. RXB0D1, Bit 2 = RXB0D12. RXB0D1, Bit 1 = RXB0D11. RXB0D1, Bit 0 = RXB0D10. RXB0D1, Value on POR, BOR = xxxx xxxx. RXB0D1, Details on page: = 40, 230. RXB0D0, Bit 7 = RXB0D07. RXB0D0, Bit 6 = RXB0D06.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXB0D0, Bit 5 = RXB0D05. RXB0D0, Bit 4 = RXB0D04. RXB0D0, Bit 3 = RXB0D03. RXB0D0, Bit 2 = RXB0D02. RXB0D0, Bit 1 = RXB0D01. RXB0D0, Bit 0 = RXB0D00. RXB0D0, Value on POR, BOR = xxxx xxxx. RXB0D0, Details on page: = 40, 230\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nNote 1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6X80 devices; always maintain these clear.\n4: These bits have multiple functions depending on the CAN module mode selection.\n5: Meaning of this register depends on whether this buffer is configured as transmit or receive.\n6: RG5 is available as an input when MCLR is disabled.\n7: This register reads all ' 0 's until the ECAN module is set up in Mode 1 or Mode 2.",
    "TABLE 4-3:\nRXB0DLC, Bit 7 = -. RXB0DLC, Bit 6 = RXRTR. RXB0DLC, Bit 5 = RB1. RXB0DLC, Bit 4 = RB0. RXB0DLC, Bit 3 = DLC3. RXB0DLC, Bit 2 = DLC2. RXB0DLC, Bit 1 = DLC1. RXB0DLC, Bit 0 = DLC0. RXB0DLC, Value on POR, BOR = -xxx xxxx. RXB0DLC, Details on page: = 40, 230. RXB0EIDL, Bit 7 = EID7. RXB0EIDL, Bit 6 = EID6. RXB0EIDL, Bit 5 = EID5. RXB0EIDL, Bit 4 = EID4. RXB0EIDL, Bit 3 = EID3. RXB0EIDL, Bit 2 = EID2. RXB0EIDL, Bit 1 = EID1. RXB0EIDL, Bit",
    "TABLE 4-3:\n0 = EID0. RXB0EIDL, Value on POR, BOR = xxxx xxxx. RXB0EIDL, Details on page: = 41, 230. RXB0EIDH, Bit 7 = EID15. RXB0EIDH, Bit 6 = EID14. RXB0EIDH, Bit 5 = EID13. RXB0EIDH, Bit 4 = EID12. RXB0EIDH, Bit 3 = EID11. RXB0EIDH, Bit 2 = EID10. RXB0EIDH, Bit 1 = EID9. RXB0EIDH, Bit 0 = EID8. RXB0EIDH, Value on POR, BOR = xxxx xxxx. RXB0EIDH, Details on page: = 41, 230. RXB0SIDL, Bit 7 = SID2. RXB0SIDL, Bit 6 = SID1. RXB0SIDL, Bit 5 = SID0. RXB0SIDL, Bit 4 = SRR. RXB0SIDL, Bit 3 =",
    "TABLE 4-3:\nEXID. RXB0SIDL, Bit 2 = -. RXB0SIDL, Bit 1 = EID17. RXB0SIDL, Bit 0 = EID16. RXB0SIDL, Value on POR, BOR = xxxx x-xx. RXB0SIDL, Details on page: = 41, 230. RXB0SIDH, Bit 7 = SID10. RXB0SIDH, Bit 6 = SID9. RXB0SIDH, Bit 5 = SID8. RXB0SIDH, Bit 4 = SID7. RXB0SIDH, Bit 3 = SID6. RXB0SIDH, Bit 2 = SID5. RXB0SIDH, Bit 1 = SID4. RXB0SIDH, Bit 0 = SID3. RXB0SIDH, Value on POR, BOR = xxxx xxxx. RXB0SIDH, Details on page: = 41, 230. RXB0CON Mode 0, Bit 7 = RXFUL. RXB0CON Mode 0, Bit 6 = RXM1.",
    "TABLE 4-3:\nRXB0CON Mode 0, Bit 5 = RXM0 (4). RXB0CON Mode 0, Bit 4 = - (4). RXB0CON Mode 0, Bit 3 = RXRTRR0 (4). RXB0CON Mode 0, Bit 2 = RXB0DBEN (4). RXB0CON Mode 0, Bit 1 = JTOFF (4). RXB0CON Mode 0, Bit 0 = FILHIT0 (4). RXB0CON Mode 0, Value on POR, BOR = 000- 0000. RXB0CON Mode 0, Details on page: = 41, 230. RXB0CON Mode 1, 2, Bit 7 = RXFUL. RXB0CON Mode 1, 2, Bit 6 = RXM1. RXB0CON Mode 1, 2, Bit 5 = RTRR0 (4). RXB0CON Mode 1, 2, Bit 4 = FILHIT4 (4). RXB0CON Mode 1, 2, Bit 3 = FILHIT3 (4).",
    "TABLE 4-3:\nRXB0CON Mode 1, 2, Bit 2 = FILHIT2 (4). RXB0CON Mode 1, 2, Bit 1 = FILHIT1 (4). RXB0CON Mode 1, 2, Bit 0 = FILHIT0 (4). RXB0CON Mode 1, 2, Value on POR, BOR = 0000 0000. RXB0CON Mode 1, 2, Details on page: = 41, 230. RXB1D7, Bit 7 = RXB1D77. RXB1D7, Bit 6 = RXB1D76. RXB1D7, Bit 5 = RXB1D75. RXB1D7, Bit 4 = RXB1D74. RXB1D7, Bit 3 = RXB1D73. RXB1D7, Bit 2 = RXB1D72. RXB1D7, Bit 1 = RXB1D71. RXB1D7, Bit 0 = RXB1D70.",
    "TABLE 4-3:\nRXB1D7, Value on POR, BOR = xxxx xxxx. RXB1D7, Details on page: = 41, 230. RXB1D6, Bit 7 = RXB1D67. RXB1D6, Bit 6 = RXB1D66. RXB1D6, Bit 5 = RXB1D65. RXB1D6, Bit 4 = RXB1D64. RXB1D6, Bit 3 = RXB1D63. RXB1D6, Bit 2 = RXB1D62. RXB1D6, Bit 1 = RXB1D61. RXB1D6, Bit 0 = RXB1D60. RXB1D6, Value on POR, BOR = xxxx xxxx. RXB1D6, Details on page: = 41, 230. RXB1D5, Bit 7 = RXB1D57. RXB1D5, Bit 6 = RXB1D56. RXB1D5,",
    "TABLE 4-3:\nBit 5 = RXB1D55. RXB1D5, Bit 4 = RXB1D54. RXB1D5, Bit 3 = RXB1D53. RXB1D5, Bit 2 = RXB1D52. RXB1D5, Bit 1 = RXB1D51. RXB1D5, Bit 0 = RXB1D50. RXB1D5, Value on POR, BOR = xxxx xxxx. RXB1D5, Details on page: = 41, 230. RXB1D4, Bit 7 = RXB1D47. RXB1D4, Bit 6 = RXB1D46. RXB1D4, Bit 5 = RXB1D45. RXB1D4, Bit 4 = RXB1D44. RXB1D4, Bit 3 = RXB1D43. RXB1D4, Bit 2 = RXB1D42. RXB1D4, Bit 1 = RXB1D41.",
    "TABLE 4-3:\nRXB1D4, Bit 0 = RXB1D40. RXB1D4, Value on POR, BOR = xxxx xxxx. RXB1D4, Details on page: = 41, 230. RXB1D3, Bit 7 = RXB1D37. RXB1D3, Bit 6 = RXB1D36. RXB1D3, Bit 5 = RXB1D35. RXB1D3, Bit 4 = RXB1D34. RXB1D3, Bit 3 = RXB1D33. RXB1D3, Bit 2 = RXB1D32. RXB1D3, Bit 1 = RXB1D31. RXB1D3, Bit 0 = RXB1D30. RXB1D3, Value on POR, BOR = xxxx xxxx. RXB1D3, Details on page: = 41, 230. RXB1D2, Bit 7 = RXB1D27. RXB1D2, Bit 6 =",
    "TABLE 4-3:\nRXB1D26. RXB1D2, Bit 5 = RXB1D25. RXB1D2, Bit 4 = RXB1D24. RXB1D2, Bit 3 = RXB1D23. RXB1D2, Bit 2 = RXB1D22. RXB1D2, Bit 1 = RXB1D21. RXB1D2, Bit 0 = RXB1D20. RXB1D2, Value on POR, BOR = xxxx xxxx. RXB1D2, Details on page: = 41, 230. RXB1D1, Bit 7 = RXB1D17. RXB1D1, Bit 6 = RXB1D16. RXB1D1, Bit 5 = RXB1D15. RXB1D1, Bit 4 = RXB1D14. RXB1D1, Bit 3 = RXB1D13. RXB1D1, Bit 2 = RXB1D12.",
    "TABLE 4-3:\nRXB1D1, Bit 1 = RXB1D11. RXB1D1, Bit 0 = RXB1D10. RXB1D1, Value on POR, BOR = xxxx xxxx. RXB1D1, Details on page: = 41, 230. RXB1D0, Bit 7 = RXB1D07. RXB1D0, Bit 6 = RXB1D06. RXB1D0, Bit 5 = RXB1D05. RXB1D0, Bit 4 = RXB1D04. RXB1D0, Bit 3 = RXB1D03. RXB1D0, Bit 2 = RXB1D02. RXB1D0, Bit 1 = RXB1D01. RXB1D0, Bit 0 = RXB1D00. RXB1D0, Value on POR, BOR = xxxx xxxx. RXB1D0, Details on page: = 41, 230.",
    "TABLE 4-3:\nRXB1DLC, Bit 7 = -. RXB1DLC, Bit 6 = RXRTR. RXB1DLC, Bit 5 = RB1. RXB1DLC, Bit 4 = RB0. RXB1DLC, Bit 3 = DLC3. RXB1DLC, Bit 2 = DLC2. RXB1DLC, Bit 1 = DLC1. RXB1DLC, Bit 0 = DLC0. RXB1DLC, Value on POR, BOR = -xxx xxxx. RXB1DLC, Details on page: = 41, 230. RXB1EIDL, Bit 7 = EID7. RXB1EIDL, Bit 6 = EID6. RXB1EIDL, Bit 5 = EID5. RXB1EIDL, Bit 4 = EID4. RXB1EIDL, Bit 3 = EID3. RXB1EIDL, Bit 2 = EID2. RXB1EIDL, Bit 1 = EID1. RXB1EIDL, Bit",
    "TABLE 4-3:\n0 = EID0. RXB1EIDL, Value on POR, BOR = xxxx xxxx. RXB1EIDL, Details on page: = 41, 230. RXB1EIDH, Bit 7 = EID15. RXB1EIDH, Bit 6 = EID14. RXB1EIDH, Bit 5 = EID13. RXB1EIDH, Bit 4 = EID12. RXB1EIDH, Bit 3 = EID11. RXB1EIDH, Bit 2 = EID10. RXB1EIDH, Bit 1 = EID9. RXB1EIDH, Bit 0 = EID8. RXB1EIDH, Value on POR, BOR = xxxx xxxx. RXB1EIDH, Details on page: = 41, 230. RXB1SIDL, Bit 7 = SID2. RXB1SIDL, Bit 6 = SID1. RXB1SIDL, Bit 5 = SID0. RXB1SIDL, Bit 4 = SRR. RXB1SIDL, Bit 3 =",
    "TABLE 4-3:\nEXID. RXB1SIDL, Bit 2 = -. RXB1SIDL, Bit 1 = EID17. RXB1SIDL, Bit 0 = EID16. RXB1SIDL, Value on POR, BOR = xxxx x-xx. RXB1SIDL, Details on page: = 41, 230. RXB1SIDH, Bit 7 = SID10. RXB1SIDH, Bit 6 = SID9. RXB1SIDH, Bit 5 = SID8. RXB1SIDH, Bit 4 = SID7. RXB1SIDH, Bit 3 = SID6. RXB1SIDH, Bit 2 = SID5. RXB1SIDH, Bit 1 = SID4. RXB1SIDH, Bit 0 = SID3. RXB1SIDH, Value on POR, BOR = xxxx xxxx. RXB1SIDH, Details on page: = 41, 230. RXB1CON Mode 0, Bit 7 = RXFUL. RXB1CON Mode 0, Bit 6 = RXM1.",
    "TABLE 4-3:\nRXB1CON Mode 0, Bit 5 = RXM0 (4). RXB1CON Mode 0, Bit 4 = - (4). RXB1CON Mode 0, Bit 3 = RXRTRR0 (4). RXB1CON Mode 0, Bit 2 = FILHIT2 (4). RXB1CON Mode 0, Bit 1 = FILHIT1 (4). RXB1CON Mode 0, Bit 0 = FILHIT0 (4). RXB1CON Mode 0, Value on POR, BOR = 000- 0000. RXB1CON Mode 0, Details on page: = 41, 230. RXB1CON Mode 1, 2, Bit 7 = RXFUL. RXB1CON Mode 1, 2, Bit 6 = RXM1. RXB1CON Mode 1, 2, Bit 5 = RTRRO (4). RXB1CON Mode 1, 2, Bit 4 = FILHIT4 (4). RXB1CON Mode 1, 2, Bit 3 = FILHIT3 (4). RXB1CON Mode",
    "TABLE 4-3:\n1, 2, Bit 2 = FILHIT2 (4). RXB1CON Mode 1, 2, Bit 1 = FILHIT1 (4). RXB1CON Mode 1, 2, Bit 0 = FILHIT0 (4). RXB1CON Mode 1, 2, Value on POR, BOR = 0000 0000. RXB1CON Mode 1, 2, Details on page: = 41, 230. TXB0D7, Bit 7 = TXB0D77. TXB0D7, Bit 6 = TXB0D76. TXB0D7, Bit 5 = TXB0D75. TXB0D7, Bit 4 = TXB0D74. TXB0D7, Bit 3 = TXB0D73. TXB0D7, Bit 2 = TXB0D72. TXB0D7, Bit 1 = TXB0D71. TXB0D7, Bit 0 = TXB0D70. TXB0D7, Value on POR, BOR = xxxx xxxx. TXB0D7, Details on",
    "TABLE 4-3:\npage: = 41, 230. TXB0D6, Bit 7 = TXB0D67. TXB0D6, Bit 6 = TXB0D66. TXB0D6, Bit 5 = TXB0D65. TXB0D6, Bit 4 = TXB0D64. TXB0D6, Bit 3 = TXB0D63. TXB0D6, Bit 2 = TXB0D62. TXB0D6, Bit 1 = TXB0D61. TXB0D6, Bit 0 = TXB0D60. TXB0D6, Value on POR, BOR = xxxx xxxx. TXB0D6, Details on page: = 41, 230. TXB0D5, Bit 7 = TXB0D57. TXB0D5, Bit 6 = TXB0D56. TXB0D5, Bit 5 = TXB0D55. TXB0D5, Bit 4 = TXB0D54. TXB0D5, Bit 3 = TXB0D53. TXB0D5, Bit 2 =",
    "TABLE 4-3:\nTXB0D52. TXB0D5, Bit 1 = TXB0D51. TXB0D5, Bit 0 = TXB0D50. TXB0D5, Value on POR, BOR = xxxx xxxx. TXB0D5, Details on page: = 41, 230. TXB0D4, Bit 7 = TXB0D47. TXB0D4, Bit 6 = TXB0D46. TXB0D4, Bit 5 = TXB0D45. TXB0D4, Bit 4 = TXB0D44. TXB0D4, Bit 3 = TXB0D43. TXB0D4, Bit 2 = TXB0D42. TXB0D4, Bit 1 = TXB0D41. TXB0D4, Bit 0 = TXB0D40. TXB0D4, Value on POR, BOR = xxxx xxxx. TXB0D4, Details on page: = 41, 230. TXB0D3, Bit 7 = TXB0D37. TXB0D3, Bit 6 =",
    "TABLE 4-3:\nTXB0D36. TXB0D3, Bit 5 = TXB0D35. TXB0D3, Bit 4 = TXB0D34. TXB0D3, Bit 3 = TXB0D33. TXB0D3, Bit 2 = TXB0D32. TXB0D3, Bit 1 = TXB0D31. TXB0D3, Bit 0 = TXB0D30. TXB0D3, Value on POR, BOR = xxxx xxxx. TXB0D3, Details on page: = 41, 230. TXB0D2, Bit 7 = TXB0D27. TXB0D2, Bit 6 = TXB0D26. TXB0D2, Bit 5 = TXB0D25. TXB0D2, Bit 4 = TXB0D24. TXB0D2, Bit 3 = TXB0D23. TXB0D2, Bit 2 = TXB0D22. TXB0D2, Bit 1 = TXB0D21. TXB0D2, Bit 0 = TXB0D20.",
    "TABLE 4-3:\nTXB0D2, Value on POR, BOR = xxxx xxxx. TXB0D2, Details on page: = 41, 230. TXB0D1, Bit 7 = TXB0D17. TXB0D1, Bit 6 = TXB0D16. TXB0D1, Bit 5 = TXB0D15. TXB0D1, Bit 4 = TXB0D14. TXB0D1, Bit 3 = TXB0D13. TXB0D1, Bit 2 = TXB0D12. TXB0D1, Bit 1 = TXB0D11. TXB0D1, Bit 0 = TXB0D10. TXB0D1, Value on POR, BOR = xxxx xxxx. TXB0D1, Details on page: = 41, 230. TXB0D0, Bit 7 = TXB0D07. TXB0D0, Bit 6 = TXB0D06. TXB0D0, Bit 5 = TXB0D05. TXB0D0, Bit 4 = TXB0D04.",
    "TABLE 4-3:\nTXB0D0, Bit 3 = TXB0D03. TXB0D0, Bit 2 = TXB0D02. TXB0D0, Bit 1 = TXB0D01. TXB0D0, Bit 0 = TXB0D00. TXB0D0, Value on POR, BOR = xxxx xxxx. TXB0D0, Details on page: = 41, 230. TXB0DLC, Bit 7 = -. TXB0DLC, Bit 6 = TXRTR. TXB0DLC, Bit 5 = -. TXB0DLC, Bit 4 = -. TXB0DLC, Bit 3 = DLC3. TXB0DLC, Bit 2 = DLC2. TXB0DLC, Bit 1 = DLC1. TXB0DLC, Bit 0 = DLC0. TXB0DLC, Value on POR, BOR = -x-- xxxx. TXB0DLC, Details on page: = 41, 230. TXB0EIDL, Bit 7 = EID7. TXB0EIDL, Bit 6 =",
    "TABLE 4-3:\nEID6. TXB0EIDL, Bit 5 = EID5. TXB0EIDL, Bit 4 = EID4. TXB0EIDL, Bit 3 = EID3. TXB0EIDL, Bit 2 = EID2. TXB0EIDL, Bit 1 = EID1. TXB0EIDL, Bit 0 = EID0. TXB0EIDL, Value on POR, BOR = xxxx xxxx. TXB0EIDL, Details on page: = 41, 230. TXB0EIDH, Bit 7 = EID15. TXB0EIDH, Bit 6 = EID14. TXB0EIDH, Bit 5 = EID13. TXB0EIDH, Bit 4 = EID12. TXB0EIDH, Bit 3 = EID11. TXB0EIDH, Bit 2 = EID10. TXB0EIDH, Bit 1 = EID9. TXB0EIDH, Bit 0 = EID8. TXB0EIDH, Value on POR, BOR = xxxx xxxx. TXB0EIDH, Details on page: = 41,",
    "TABLE 4-3:\n230. TXB0SIDL, Bit 7 = SID2. TXB0SIDL, Bit 6 = SID1. TXB0SIDL, Bit 5 = SID0. TXB0SIDL, Bit 4 = -. TXB0SIDL, Bit 3 = EXIDE. TXB0SIDL, Bit 2 = -. TXB0SIDL, Bit 1 = EID17. TXB0SIDL, Bit 0 = EID16. TXB0SIDL, Value on POR, BOR = xx-x x-xx. TXB0SIDL, Details on page: = 41, 230. TXB0SIDH, Bit 7 = SID10. TXB0SIDH, Bit 6 = SID9. TXB0SIDH, Bit 5 = SID8. TXB0SIDH, Bit 4 = SID7. TXB0SIDH, Bit 3 = SID6. TXB0SIDH, Bit 2 = SID5. TXB0SIDH, Bit 1 = SID4. TXB0SIDH, Bit 0 = SID3. TXB0SIDH, Value on POR, BOR = xxxx xxxx.",
    "TABLE 4-3:\nTXB0SIDH, Details on page: = 42, 230. TXB0CON Mode 0, Bit 7 = -. TXB0CON Mode 0, Bit 6 = TXABT. TXB0CON Mode 0, Bit 5 = TXLARB. TXB0CON Mode 0, Bit 4 = TXERR. TXB0CON Mode 0, Bit 3 = TXREQ. TXB0CON Mode 0, Bit 2 = -. TXB0CON Mode 0, Bit 1 = TXPRI1. TXB0CON Mode 0, Bit 0 = TXPRI0. TXB0CON Mode 0, Value on POR, BOR = -000 0-00. TXB0CON Mode 0, Details on page: = 42, 230. TXB0CON Mode 1, 2, Bit 7 = TXBIF. TXB0CON Mode 1, 2, Bit 6 = TXABT. TXB0CON Mode 1, 2, Bit 5 = TXLARB. TXB0CON Mode 1, 2, Bit 4 = TXERR. TXB0CON Mode 1, 2, Bit 3 = TXREQ. TXB0CON Mode 1, 2, Bit",
    "TABLE 4-3:\n2 = -. TXB0CON Mode 1, 2, Bit 1 = TXPRI1. TXB0CON Mode 1, 2, Bit 0 = TXPRI0. TXB0CON Mode 1, 2, Value on POR, BOR = 0000 0-00. TXB0CON Mode 1, 2, Details on page: = 42, 230",
    "REGISTER FILE SUMMARY (CONTINUED)\nLegend:\n- x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote\n1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6X80 devices; always maintain these clear.\n4: These bits have multiple functions depending on the CAN module mode selection.\n5: Meaning of this register depends on whether this buffer is configured as transmit or receive.\n6: RG5 is available as an input when MCLR is disabled.\n7: This register reads all ' 0 's until the ECAN module is set up in Mode 1 or Mode 2.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTXB1D7, Bit 7 = TXB1D77. TXB1D7, Bit 6 = TXB1D76. TXB1D7, Bit 5 = TXB1D75. TXB1D7, Bit 4 = TXB1D74. TXB1D7, Bit 3 = TXB1D73. TXB1D7, Bit 2 = TXB1D72. TXB1D7, Bit 1 = TXB1D71. TXB1D7, Bit 0 = TXB1D70. TXB1D7, Value on POR, BOR = xxxx xxxx. TXB1D7, Details on page: = 42, 230. TXB1D6, Bit 7 = TXB1D67. TXB1D6, Bit 6 = TXB1D66. TXB1D6, Bit 5 = TXB1D65. TXB1D6, Bit 4 = TXB1D64. TXB1D6, Bit 3 = TXB1D63. TXB1D6, Bit 2 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTXB1D62. TXB1D6, Bit 1 = TXB1D61. TXB1D6, Bit 0 = TXB1D60. TXB1D6, Value on POR, BOR = xxxx xxxx. TXB1D6, Details on page: = 42, 230. TXB1D5, Bit 7 = TXB1D57. TXB1D5, Bit 6 = TXB1D56. TXB1D5, Bit 5 = TXB1D55. TXB1D5, Bit 4 = TXB1D54. TXB1D5, Bit 3 = TXB1D53. TXB1D5, Bit 2 = TXB1D52. TXB1D5, Bit 1 = TXB1D51. TXB1D5, Bit 0 = TXB1D50. TXB1D5, Value on POR, BOR = xxxx xxxx. TXB1D5, Details on page: = 42, 230. TXB1D4, Bit 7 = TXB1D47. TXB1D4,",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nBit 6 = TXB1D46. TXB1D4, Bit 5 = TXB1D45. TXB1D4, Bit 4 = TXB1D44. TXB1D4, Bit 3 = TXB1D43. TXB1D4, Bit 2 = TXB1D42. TXB1D4, Bit 1 = TXB1D41. TXB1D4, Bit 0 = TXB1D40. TXB1D4, Value on POR, BOR = xxxx xxxx. TXB1D4, Details on page: = 42, 230. TXB1D3, Bit 7 = TXB1D37. TXB1D3, Bit 6 = TXB1D36. TXB1D3, Bit 5 = TXB1D35. TXB1D3, Bit 4 = TXB1D34. TXB1D3, Bit 3 = TXB1D33. TXB1D3, Bit 2 = TXB1D32. TXB1D3, Bit 1 = TXB1D31. TXB1D3, Bit 0",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n= TXB1D30. TXB1D3, Value on POR, BOR = xxxx xxxx. TXB1D3, Details on page: = 42, 230. TXB1D2, Bit 7 = TXB1D27. TXB1D2, Bit 6 = TXB1D26. TXB1D2, Bit 5 = TXB1D25. TXB1D2, Bit 4 = TXB1D24. TXB1D2, Bit 3 = TXB1D23. TXB1D2, Bit 2 = TXB1D22. TXB1D2, Bit 1 = TXB1D21. TXB1D2, Bit 0 = TXB1D20. TXB1D2, Value on POR, BOR = xxxx xxxx. TXB1D2, Details on page: = 42, 230. TXB1D1, Bit 7 = TXB1D17. TXB1D1, Bit 6 = TXB1D16. TXB1D1, Bit 5 = TXB1D15. TXB1D1, Bit",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n4 = TXB1D14. TXB1D1, Bit 3 = TXB1D13. TXB1D1, Bit 2 = TXB1D12. TXB1D1, Bit 1 = TXB1D11. TXB1D1, Bit 0 = TXB1D10. TXB1D1, Value on POR, BOR = xxxx xxxx. TXB1D1, Details on page: = 42, 230. TXB1D0, Bit 7 = TXB1D07. TXB1D0, Bit 6 = TXB1D06. TXB1D0, Bit 5 = TXB1D05. TXB1D0, Bit 4 = TXB1D04. TXB1D0, Bit 3 = TXB1D03. TXB1D0, Bit 2 = TXB1D02. TXB1D0, Bit 1 = TXB1D01. TXB1D0, Bit 0 = TXB1D00. TXB1D0, Value on POR, BOR = xxxx xxxx.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTXB1D0, Details on page: = 42, 230. TXB1DLC, Bit 7 = -. TXB1DLC, Bit 6 = TXRTR. TXB1DLC, Bit 5 = -. TXB1DLC, Bit 4 = -. TXB1DLC, Bit 3 = DLC3. TXB1DLC, Bit 2 = DLC2. TXB1DLC, Bit 1 = DLC1. TXB1DLC, Bit 0 = DLC0. TXB1DLC, Value on POR, BOR = -x-- xxxx. TXB1DLC, Details on page: = 42, 230. TXB1EIDL, Bit 7 = EID7. TXB1EIDL, Bit 6 = EID6. TXB1EIDL, Bit 5 = EID5. TXB1EIDL, Bit 4 = EID4. TXB1EIDL, Bit 3 = EID3. TXB1EIDL, Bit 2 = EID2. TXB1EIDL, Bit 1 = EID1. TXB1EIDL,",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nBit 0 = EID0. TXB1EIDL, Value on POR, BOR = xxxx xxxx. TXB1EIDL, Details on page: = 42, 230. TXB1EIDH, Bit 7 = EID15. TXB1EIDH, Bit 6 = EID14. TXB1EIDH, Bit 5 = EID13. TXB1EIDH, Bit 4 = EID12. TXB1EIDH, Bit 3 = EID11. TXB1EIDH, Bit 2 = EID10. TXB1EIDH, Bit 1 = EID9. TXB1EIDH, Bit 0 = EID8. TXB1EIDH, Value on POR, BOR = xxxx xxxx. TXB1EIDH, Details on page: = 42, 230. TXB1SIDL, Bit 7 = SID2. TXB1SIDL, Bit 6 = SID1. TXB1SIDL, Bit 5 = SID0. TXB1SIDL, Bit 4 = -. TXB1SIDL, Bit 3 = EXIDE. TXB1SIDL, Bit 2 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n-. TXB1SIDL, Bit 1 = EID17. TXB1SIDL, Bit 0 = EID16. TXB1SIDL, Value on POR, BOR = xx-x x-xx. TXB1SIDL, Details on page: = 42, 230. TXB1SIDH, Bit 7 = SID10. TXB1SIDH, Bit 6 = SID9. TXB1SIDH, Bit 5 = SID8. TXB1SIDH, Bit 4 = SID7. TXB1SIDH, Bit 3 = SID6. TXB1SIDH, Bit 2 = SID5. TXB1SIDH, Bit 1 = SID4. TXB1SIDH, Bit 0 = SID3. TXB1SIDH, Value on POR, BOR = xxxx xxxx. TXB1SIDH, Details on page: = 42, 230. TXB1CON Mode 0, Bit 7 = -. TXB1CON Mode 0, Bit 6 = TXABT. TXB1CON Mode 0, Bit 5 = TXLARB. TXB1CON Mode 0, Bit 4 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTXERR. TXB1CON Mode 0, Bit 3 = TXREQ. TXB1CON Mode 0, Bit 2 = -. TXB1CON Mode 0, Bit 1 = TXPRI1. TXB1CON Mode 0, Bit 0 = TXPRI0. TXB1CON Mode 0, Value on POR, BOR = -000 0-00. TXB1CON Mode 0, Details on page: = 42, 230. TXB1CON Mode 1, 2, Bit 7 = TXBIF. TXB1CON Mode 1, 2, Bit 6 = TXABT. TXB1CON Mode 1, 2, Bit 5 = TXLARB. TXB1CON Mode 1, 2, Bit 4 = TXERR. TXB1CON Mode 1, 2, Bit 3 = TXREQ. TXB1CON Mode 1, 2, Bit 2 = -. TXB1CON Mode 1, 2, Bit 1 = TXPRI1. TXB1CON Mode 1, 2, Bit 0 = TXPRI0. TXB1CON Mode 1, 2, Value on POR, BOR = 0000",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n0-00. TXB1CON Mode 1, 2, Details on page: = 42, 230. TXB2D7, Bit 7 = TXB2D77. TXB2D7, Bit 6 = TXB2D76. TXB2D7, Bit 5 = TXB2D75. TXB2D7, Bit 4 = TXB2D74. TXB2D7, Bit 3 = TXB2D73. TXB2D7, Bit 2 = TXB2D72. TXB2D7, Bit 1 = TXB2D71. TXB2D7, Bit 0 = TXB2D70. TXB2D7, Value on POR, BOR = xxxx xxxx. TXB2D7, Details on page: = 42, 230. TXB2D6, Bit 7 = TXB2D67. TXB2D6, Bit 6 = TXB2D66. TXB2D6, Bit 5 = TXB2D65. TXB2D6, Bit 4 = TXB2D64.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTXB2D6, Bit 3 = TXB2D63. TXB2D6, Bit 2 = TXB2D62. TXB2D6, Bit 1 = TXB2D61. TXB2D6, Bit 0 = TXB2D60. TXB2D6, Value on POR, BOR = xxxx xxxx. TXB2D6, Details on page: = 42, 230. TXB2D5, Bit 7 = TXB2D57. TXB2D5, Bit 6 = TXB2D56. TXB2D5, Bit 5 = TXB2D55. TXB2D5, Bit 4 = TXB2D54. TXB2D5, Bit 3 = TXB2D53. TXB2D5, Bit 2 = TXB2D52. TXB2D5, Bit 1 = TXB2D51. TXB2D5, Bit 0 = TXB2D50. TXB2D5, Value on POR, BOR = xxxx xxxx. TXB2D5, Details on page: =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n42, 230. TXB2D4, Bit 7 = TXB2D47. TXB2D4, Bit 6 = TXB2D46. TXB2D4, Bit 5 = TXB2D45. TXB2D4, Bit 4 = TXB2D44. TXB2D4, Bit 3 = TXB2D43. TXB2D4, Bit 2 = TXB2D42. TXB2D4, Bit 1 = TXB2D41. TXB2D4, Bit 0 = TXB2D40. TXB2D4, Value on POR, BOR = xxxx xxxx. TXB2D4, Details on page: = 42, 230. TXB2D3, Bit 7 = TXB2D37. TXB2D3, Bit 6 = TXB2D36. TXB2D3, Bit 5 = TXB2D35. TXB2D3, Bit 4 = TXB2D34. TXB2D3, Bit 3 = TXB2D33. TXB2D3, Bit 2 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTXB2D32. TXB2D3, Bit 1 = TXB2D31. TXB2D3, Bit 0 = TXB2D30. TXB2D3, Value on POR, BOR = xxxx xxxx. TXB2D3, Details on page: = 42, 230. TXB2D2, Bit 7 = TXB2D27. TXB2D2, Bit 6 = TXB2D26. TXB2D2, Bit 5 = TXB2D25. TXB2D2, Bit 4 = TXB2D24. TXB2D2, Bit 3 = TXB2D23. TXB2D2, Bit 2 = TXB2D22. TXB2D2, Bit 1 = TXB2D21. TXB2D2, Bit 0 = TXB2D20. TXB2D2, Value on POR, BOR = xxxx xxxx. TXB2D2, Details on page: = 42, 230. TXB2D1, Bit 7 = TXB2D17. TXB2D1, Bit 6",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n= TXB2D16. TXB2D1, Bit 5 = TXB2D15. TXB2D1, Bit 4 = TXB2D14. TXB2D1, Bit 3 = TXB2D13. TXB2D1, Bit 2 = TXB2D12. TXB2D1, Bit 1 = TXB2D11. TXB2D1, Bit 0 = TXB2D10. TXB2D1, Value on POR, BOR = xxxx xxxx. TXB2D1, Details on page: = 42, 230. TXB2D0, Bit 7 = TXB2D07. TXB2D0, Bit 6 = TXB2D06. TXB2D0, Bit 5 = TXB2D05. TXB2D0, Bit 4 = TXB2D04. TXB2D0, Bit 3 = TXB2D03. TXB2D0, Bit 2 = TXB2D02. TXB2D0, Bit 1 = TXB2D01.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nTXB2D0, Bit 0 = TXB2D00. TXB2D0, Value on POR, BOR = xxxx xxxx. TXB2D0, Details on page: = 42, 230. TXB2DLC, Bit 7 = -. TXB2DLC, Bit 6 = TXRTR. TXB2DLC, Bit 5 = -. TXB2DLC, Bit 4 = -. TXB2DLC, Bit 3 = DLC3. TXB2DLC, Bit 2 = DLC2. TXB2DLC, Bit 1 = DLC1. TXB2DLC, Bit 0 = DLC0. TXB2DLC, Value on POR, BOR = -x-- xxxx. TXB2DLC, Details on page: = 42, 230. TXB2EIDL, Bit 7 = EID7. TXB2EIDL, Bit 6 = EID6. TXB2EIDL, Bit 5 = EID5. TXB2EIDL, Bit 4 = EID4. TXB2EIDL, Bit 3 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nEID3. TXB2EIDL, Bit 2 = EID2. TXB2EIDL, Bit 1 = EID1. TXB2EIDL, Bit 0 = EID0. TXB2EIDL, Value on POR, BOR = xxxx xxxx. TXB2EIDL, Details on page: = 42, 230. TXB2EIDH, Bit 7 = EID15. TXB2EIDH, Bit 6 = EID14. TXB2EIDH, Bit 5 = EID13. TXB2EIDH, Bit 4 = EID12. TXB2EIDH, Bit 3 = EID11. TXB2EIDH, Bit 2 = EID10. TXB2EIDH, Bit 1 = EID9. TXB2EIDH, Bit 0 = EID8. TXB2EIDH, Value on POR, BOR = xxxx xxxx. TXB2EIDH, Details on page: = 42, 230. TXB2SIDL, Bit 7 = SID2. TXB2SIDL, Bit 6 = SID1. TXB2SIDL, Bit 5",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n= SID0. TXB2SIDL, Bit 4 = -. TXB2SIDL, Bit 3 = EXIDE. TXB2SIDL, Bit 2 = -. TXB2SIDL, Bit 1 = EID17. TXB2SIDL, Bit 0 = EID16. TXB2SIDL, Value on POR, BOR = xxx- x-xx. TXB2SIDL, Details on page: = 42, 230. TXB2SIDH, Bit 7 = SID10. TXB2SIDH, Bit 6 = SID9. TXB2SIDH, Bit 5 = SID8. TXB2SIDH, Bit 4 = SID7. TXB2SIDH, Bit 3 = SID6. TXB2SIDH, Bit 2 = SID5. TXB2SIDH, Bit 1 = SID4. TXB2SIDH, Bit 0 = SID3. TXB2SIDH, Value on POR, BOR = xxxx xxxx. TXB2SIDH, Details on page: = 42, 230. TXB2CON Mode 0, Bit 7 = -. TXB2CON Mode",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n0, Bit 6 = TXABT. TXB2CON Mode 0, Bit 5 = TXLARB. TXB2CON Mode 0, Bit 4 = TXERR. TXB2CON Mode 0, Bit 3 = TXREQ. TXB2CON Mode 0, Bit 2 = -. TXB2CON Mode 0, Bit 1 = TXPRI1. TXB2CON Mode 0, Bit 0 = TXPRI0. TXB2CON Mode 0, Value on POR, BOR = -000 0-00. TXB2CON Mode 0, Details on page: = 42, 230. TXB2CON Mode 1, 2, Bit 7 = TXBIF. TXB2CON Mode 1, 2, Bit 6 = TXABT. TXB2CON Mode 1, 2, Bit 5 = TXLARB. TXB2CON Mode 1, 2, Bit 4 = TXERR. TXB2CON Mode 1, 2, Bit 3 = TXREQ. TXB2CON Mode 1, 2, Bit 2 = -. TXB2CON Mode 1, 2, Bit 1 = TXPRI1. TXB2CON Mode",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n1, 2, Bit 0 = TXPRI0. TXB2CON Mode 1, 2, Value on POR, BOR = 0000 0-00. TXB2CON Mode 1, 2, Details on page: = 42, 230. RXM1EIDL, Bit 7 = EID7. RXM1EIDL, Bit 6 = EID6. RXM1EIDL, Bit 5 = EID5. RXM1EIDL, Bit 4 = EID4. RXM1EIDL, Bit 3 = EID3. RXM1EIDL, Bit 2 = EID2. RXM1EIDL, Bit 1 = EID1. RXM1EIDL, Bit 0 = EID0. RXM1EIDL, Value on POR, BOR = xxxx xxxx. RXM1EIDL, Details on page: = 42, 230. RXM1EIDH, Bit 7 = EID15. RXM1EIDH, Bit 6 = EID14. RXM1EIDH, Bit 5 = EID13.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXM1EIDH, Bit 4 = EID12. RXM1EIDH, Bit 3 = EID11. RXM1EIDH, Bit 2 = EID10. RXM1EIDH, Bit 1 = EID9. RXM1EIDH, Bit 0 = EID8. RXM1EIDH, Value on POR, BOR = xxxx xxxx. RXM1EIDH, Details on page: = 43, 230. RXM1SIDL, Bit 7 = SID2. RXM1SIDL, Bit 6 = SID1. RXM1SIDL, Bit 5 = SID0. RXM1SIDL, Bit 4 = -. RXM1SIDL, Bit 3 = EXIDEN. RXM1SIDL, Bit 2 = -. RXM1SIDL, Bit 1 = EID17. RXM1SIDL, Bit 0 = EID16. RXM1SIDL, Value on POR, BOR = xx-x 0-xx. RXM1SIDL, Details on page: = 43,",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n230. RXM1SIDH, Bit 7 = SID10. RXM1SIDH, Bit 6 = SID9. RXM1SIDH, Bit 5 = SID8. RXM1SIDH, Bit 4 = SID7. RXM1SIDH, Bit 3 = SID6. RXM1SIDH, Bit 2 = SID5. RXM1SIDH, Bit 1 = SID4. RXM1SIDH, Bit 0 = SID3. RXM1SIDH, Value on POR, BOR = xxxx xxxx. RXM1SIDH, Details on page: = 43, 230. RXM0EIDL, Bit 7 = EID7. RXM0EIDL, Bit 6 = EID6. RXM0EIDL, Bit 5 = EID5. RXM0EIDL, Bit 4 = EID4. RXM0EIDL, Bit 3 = EID3. RXM0EIDL, Bit 2 = EID2. RXM0EIDL, Bit 1 = EID1.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXM0EIDL, Bit 0 = EID0. RXM0EIDL, Value on POR, BOR = xxxx xxxx. RXM0EIDL, Details on page: = 43, 230. RXM0EIDH, Bit 7 = EID15. RXM0EIDH, Bit 6 = EID14. RXM0EIDH, Bit 5 = EID13. RXM0EIDH, Bit 4 = EID12. RXM0EIDH, Bit 3 = EID11. RXM0EIDH, Bit 2 = EID10. RXM0EIDH, Bit 1 = EID9. RXM0EIDH, Bit 0 = EID8. RXM0EIDH, Value on POR, BOR = xxxx xxxx. RXM0EIDH, Details on page: = 43, 230. RXM0SIDL, Bit 7 = SID2. RXM0SIDL, Bit 6 = SID1. RXM0SIDL, Bit 5 = SID0. RXM0SIDL, Bit 4 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n-. RXM0SIDL, Bit 3 = EXIDM. RXM0SIDL, Bit 2 = -. RXM0SIDL, Bit 1 = EID17. RXM0SIDL, Bit 0 = EID16. RXM0SIDL, Value on POR, BOR = xx-x 0-xx. RXM0SIDL, Details on page: = 43, 230. RXM0SIDH, Bit 7 = SID10. RXM0SIDH, Bit 6 = SID9. RXM0SIDH, Bit 5 = SID8. RXM0SIDH, Bit 4 = SID7. RXM0SIDH, Bit 3 = SID6. RXM0SIDH, Bit 2 = SID5. RXM0SIDH, Bit 1 = SID4. RXM0SIDH, Bit 0 = SID3. RXM0SIDH, Value on POR, BOR = xxxx xxxx. RXM0SIDH, Details on page: = 43, 230. RXF15EIDL (7), Bit 7 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nEID7. RXF15EIDL (7), Bit 6 = EID6. RXF15EIDL (7), Bit 5 = EID5. RXF15EIDL (7), Bit 4 = EID4. RXF15EIDL (7), Bit 3 = EID3. RXF15EIDL (7), Bit 2 = EID2. RXF15EIDL (7), Bit 1 = EID1. RXF15EIDL (7), Bit 0 = EID0. RXF15EIDL (7), Value on POR, BOR = xxxx xxxx. RXF15EIDL (7), Details on page: = 47, 230\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6X80 devices; always maintain these clear.\n4: These bits have multiple functions depending on the CAN module mode selection.\n5: Meaning of this register depends on whether this buffer is configured as transmit or receive.\n6: RG5 is available as an input when MCLR is disabled.\n7: This register reads all ' 0 's until the ECAN module is set up in Mode 1 or Mode 2.",
    "TABLE 4-3:\nRXF15EIDH (7), Bit 7 = EID15. RXF15EIDH (7), Bit 6 = EID14. RXF15EIDH (7), Bit 5 = EID13. RXF15EIDH (7), Bit 4 = EID12. RXF15EIDH (7), Bit 3 = EID11. RXF15EIDH (7), Bit 2 = EID10. RXF15EIDH (7), Bit 1 = EID9. RXF15EIDH (7), Bit 0 = EID8. RXF15EIDH (7), Value on POR, BOR = xxxx xxxx. RXF15EIDH (7), Details on page: = 47, 230. RXF15SIDL (7), Bit 7 = SID2. RXF15SIDL (7), Bit 6 = SID1. RXF15SIDL (7), Bit 5 = SID0. RXF15SIDL (7), Bit 4 = -. RXF15SIDL (7), Bit",
    "TABLE 4-3:\n3 = EXIDEN. RXF15SIDL (7), Bit 2 = -. RXF15SIDL (7), Bit 1 = EID17. RXF15SIDL (7), Bit 0 = EID16. RXF15SIDL (7), Value on POR, BOR = xx-x x-xx. RXF15SIDL (7), Details on page: = 47, 230. RXF15SIDH (7), Bit 7 = SID10. RXF15SIDH (7), Bit 6 = SID9. RXF15SIDH (7), Bit 5 = SID8. RXF15SIDH (7), Bit 4 = SID7. RXF15SIDH (7), Bit 3 = SID6. RXF15SIDH (7), Bit 2 = SID5. RXF15SIDH (7), Bit 1 = SID4. RXF15SIDH (7), Bit 0 = SID3. RXF15SIDH (7), Value on POR, BOR = xxxx xxxx.",
    "TABLE 4-3:\nRXF15SIDH (7), Details on page: = 47, 230. RXF14EIDL (7), Bit 7 = EID7. RXF14EIDL (7), Bit 6 = EID6. RXF14EIDL (7), Bit 5 = EID5. RXF14EIDL (7), Bit 4 = EID4. RXF14EIDL (7), Bit 3 = EID3. RXF14EIDL (7), Bit 2 = EID2. RXF14EIDL (7), Bit 1 = EID1. RXF14EIDL (7), Bit 0 = EID0. RXF14EIDL (7), Value on POR, BOR = xxxx xxxx. RXF14EIDL (7), Details on page: = 47, 230. RXF14EIDH (7), Bit 7 = EID15. RXF14EIDH (7), Bit 6 = EID14. RXF14EIDH (7), Bit 5 = EID13.",
    "TABLE 4-3:\nRXF14EIDH (7), Bit 4 = EID12. RXF14EIDH (7), Bit 3 = EID11. RXF14EIDH (7), Bit 2 = EID10. RXF14EIDH (7), Bit 1 = EID9. RXF14EIDH (7), Bit 0 = EID8. RXF14EIDH (7), Value on POR, BOR = xxxx xxxx. RXF14EIDH (7), Details on page: = 47, 230. RXF14SIDL (7), Bit 7 = SID2. RXF14SIDL (7), Bit 6 = SID1. RXF14SIDL (7), Bit 5 = SID0. RXF14SIDL (7), Bit 4 = -. RXF14SIDL (7), Bit 3 = EXIDEN. RXF14SIDL (7), Bit 2 = -. RXF14SIDL (7), Bit 1 = EID17. RXF14SIDL (7), Bit 0 =",
    "TABLE 4-3:\nEID16. RXF14SIDL (7), Value on POR, BOR = xx-x x-xx. RXF14SIDL (7), Details on page: = 47, 230. RXF14SIDH (7), Bit 7 = SID10. RXF14SIDH (7), Bit 6 = SID9. RXF14SIDH (7), Bit 5 = SID8. RXF14SIDH (7), Bit 4 = SID7. RXF14SIDH (7), Bit 3 = SID6. RXF14SIDH (7), Bit 2 = SID5. RXF14SIDH (7), Bit 1 = SID4. RXF14SIDH (7), Bit 0 = SID3. RXF14SIDH (7), Value on POR, BOR = xxxx xxxx. RXF14SIDH (7), Details on page: = 47, 230. RXF13EIDL (7), Bit 7 = EID7. RXF13EIDL (7), Bit 6 = EID6.",
    "TABLE 4-3:\nRXF13EIDL (7), Bit 5 = EID5. RXF13EIDL (7), Bit 4 = EID4. RXF13EIDL (7), Bit 3 = EID3. RXF13EIDL (7), Bit 2 = EID2. RXF13EIDL (7), Bit 1 = EID1. RXF13EIDL (7), Bit 0 = EID0. RXF13EIDL (7), Value on POR, BOR = xxxx xxxx. RXF13EIDL (7), Details on page: = 47, 230. RXF13EIDH (7), Bit 7 = EID15. RXF13EIDH (7), Bit 6 = EID14. RXF13EIDH (7), Bit 5 = EID13. RXF13EIDH (7), Bit 4 = EID12. RXF13EIDH (7), Bit 3 = EID11. RXF13EIDH (7), Bit 2 = EID10. RXF13EIDH",
    "TABLE 4-3:\n(7), Bit 1 = EID9. RXF13EIDH (7), Bit 0 = EID8. RXF13EIDH (7), Value on POR, BOR = xxxx xxxx. RXF13EIDH (7), Details on page: = 47, 230. RXF13SIDL (7), Bit 7 = SID2. RXF13SIDL (7), Bit 6 = SID1. RXF13SIDL (7), Bit 5 = SID0. RXF13SIDL (7), Bit 4 = -. RXF13SIDL (7), Bit 3 = EXIDEN. RXF13SIDL (7), Bit 2 = -. RXF13SIDL (7), Bit 1 = EID17. RXF13SIDL (7), Bit 0 = EID16. RXF13SIDL (7), Value on POR, BOR = xx-x x-xx. RXF13SIDL (7), Details on page: = 47, 230. RXF13SIDH (7),",
    "TABLE 4-3:\nBit 7 = SID10. RXF13SIDH (7), Bit 6 = SID9. RXF13SIDH (7), Bit 5 = SID8. RXF13SIDH (7), Bit 4 = SID7. RXF13SIDH (7), Bit 3 = SID6. RXF13SIDH (7), Bit 2 = SID5. RXF13SIDH (7), Bit 1 = SID4. RXF13SIDH (7), Bit 0 = SID3. RXF13SIDH (7), Value on POR, BOR = xxxx xxxx. RXF13SIDH (7), Details on page: = 47, 230. RXF12EIDL (7), Bit 7 = EID7. RXF12EIDL (7), Bit 6 = EID6. RXF12EIDL (7), Bit 5 = EID5. RXF12EIDL (7), Bit 4 = EID4. RXF12EIDL (7), Bit 3 = EID3. RXF12EIDL",
    "TABLE 4-3:\n(7), Bit 2 = EID2. RXF12EIDL (7), Bit 1 = EID1. RXF12EIDL (7), Bit 0 = EID0. RXF12EIDL (7), Value on POR, BOR = xxxx xxxx. RXF12EIDL (7), Details on page: = 47, 230. RXF12EIDH (7), Bit 7 = EID15. RXF12EIDH (7), Bit 6 = EID14. RXF12EIDH (7), Bit 5 = EID13. RXF12EIDH (7), Bit 4 = EID12. RXF12EIDH (7), Bit 3 = EID11. RXF12EIDH (7), Bit 2 = EID10. RXF12EIDH (7), Bit 1 = EID9. RXF12EIDH (7), Bit 0 = EID8. RXF12EIDH (7), Value on POR, BOR = xxxx xxxx. RXF12EIDH",
    "TABLE 4-3:\n(7), Details on page: = 47, 230. RXF12SIDL (7), Bit 7 = SID2. RXF12SIDL (7), Bit 6 = SID1. RXF12SIDL (7), Bit 5 = SID0. RXF12SIDL (7), Bit 4 = -. RXF12SIDL (7), Bit 3 = EXIDEN. RXF12SIDL (7), Bit 2 = -. RXF12SIDL (7), Bit 1 = EID17. RXF12SIDL (7), Bit 0 = EID16. RXF12SIDL (7), Value on POR, BOR = xx-x x-xx. RXF12SIDL (7), Details on page: = 47, 230. RXF12SIDH (7), Bit 7 = SID10. RXF12SIDH (7), Bit 6 = SID9. RXF12SIDH (7), Bit 5 = SID8. RXF12SIDH (7), Bit 4 = SID7.",
    "TABLE 4-3:\nRXF12SIDH (7), Bit 3 = SID6. RXF12SIDH (7), Bit 2 = SID5. RXF12SIDH (7), Bit 1 = SID4. RXF12SIDH (7), Bit 0 = SID3. RXF12SIDH (7), Value on POR, BOR = xxxx xxxx. RXF12SIDH (7), Details on page: = 47, 230. RXF11EIDL (7), Bit 7 = EID7. RXF11EIDL (7), Bit 6 = EID6. RXF11EIDL (7), Bit 5 = EID5. RXF11EIDL (7), Bit 4 = EID4. RXF11EIDL (7), Bit 3 = EID3. RXF11EIDL (7), Bit 2 = EID2. RXF11EIDL (7), Bit 1 = EID1. RXF11EIDL (7), Bit 0 = EID0. RXF11EIDL (7),",
    "TABLE 4-3:\nValue on POR, BOR = xxxx xxxx. RXF11EIDL (7), Details on page: = 47, 230. RXF11EIDH (7), Bit 7 = EID15. RXF11EIDH (7), Bit 6 = EID14. RXF11EIDH (7), Bit 5 = EID13. RXF11EIDH (7), Bit 4 = EID12. RXF11EIDH (7), Bit 3 = EID11. RXF11EIDH (7), Bit 2 = EID10. RXF11EIDH (7), Bit 1 = EID9. RXF11EIDH (7), Bit 0 = EID8. RXF11EIDH (7), Value on POR, BOR = xxxx xxxx. RXF11EIDH (7), Details on page: = 47, 230. RXF11SIDL (7), Bit 7 = SID2. RXF11SIDL (7), Bit 6 = SID1. RXF11SIDL (7), Bit",
    "TABLE 4-3:\n5 = SID0. RXF11SIDL (7), Bit 4 = -. RXF11SIDL (7), Bit 3 = EXIDEN. RXF11SIDL (7), Bit 2 = -. RXF11SIDL (7), Bit 1 = EID17. RXF11SIDL (7), Bit 0 = EID16. RXF11SIDL (7), Value on POR, BOR = xx-x x-xx. RXF11SIDL (7), Details on page: = 47, 230. RXF11SIDH (7), Bit 7 = SID10. RXF11SIDH (7), Bit 6 = SID9. RXF11SIDH (7), Bit 5 = SID8. RXF11SIDH (7), Bit 4 = SID7. RXF11SIDH (7), Bit 3 = SID6. RXF11SIDH (7), Bit 2 = SID5. RXF11SIDH (7), Bit 1 = SID4. RXF11SIDH (7),",
    "TABLE 4-3:\nBit 0 = SID3. RXF11SIDH (7), Value on POR, BOR = xxxx xxxx. RXF11SIDH (7), Details on page: = 47, 230. RXF10EIDL (7), Bit 7 = EID7. RXF10EIDL (7), Bit 6 = EID6. RXF10EIDL (7), Bit 5 = EID5. RXF10EIDL (7), Bit 4 = EID4. RXF10EIDL (7), Bit 3 = EID3. RXF10EIDL (7), Bit 2 = EID2. RXF10EIDL (7), Bit 1 = EID1. RXF10EIDL (7), Bit 0 = EID0. RXF10EIDL (7), Value on POR, BOR = xxxx xxxx. RXF10EIDL (7), Details on page: = 47, 230. RXF10EIDH (7), Bit 7 = EID15. RXF10EIDH (7),",
    "TABLE 4-3:\nBit 6 = EID14. RXF10EIDH (7), Bit 5 = EID13. RXF10EIDH (7), Bit 4 = EID12. RXF10EIDH (7), Bit 3 = EID11. RXF10EIDH (7), Bit 2 = EID10. RXF10EIDH (7), Bit 1 = EID9. RXF10EIDH (7), Bit 0 = EID8. RXF10EIDH (7), Value on POR, BOR = xxxx xxxx. RXF10EIDH (7), Details on page: = 47, 230. RXF10SIDL (7), Bit 7 = SID2. RXF10SIDL (7), Bit 6 = SID1. RXF10SIDL (7), Bit 5 = SID0. RXF10SIDL (7), Bit 4 = -. RXF10SIDL (7), Bit 3 = EXIDEN. RXF10SIDL (7), Bit 2 = -. RXF10SIDL",
    "TABLE 4-3:\n(7), Bit 1 = EID17. RXF10SIDL (7), Bit 0 = EID16. RXF10SIDL (7), Value on POR, BOR = xx-x x-xx. RXF10SIDL (7), Details on page: = 48, 230. RXF10SIDH (7), Bit 7 = SID10. RXF10SIDH (7), Bit 6 = SID9. RXF10SIDH (7), Bit 5 = SID8. RXF10SIDH (7), Bit 4 = SID7. RXF10SIDH (7), Bit 3 = SID6. RXF10SIDH (7), Bit 2 = SID5. RXF10SIDH (7), Bit 1 = SID4. RXF10SIDH (7), Bit 0 = SID3. RXF10SIDH (7), Value on POR, BOR = xxxx xxxx. RXF10SIDH (7), Details on page: = 48, 230. RXF9EIDL (7), Bit",
    "TABLE 4-3:\n7 = EID7. RXF9EIDL (7), Bit 6 = EID6. RXF9EIDL (7), Bit 5 = EID5. RXF9EIDL (7), Bit 4 = EID4. RXF9EIDL (7), Bit 3 = EID3. RXF9EIDL (7), Bit 2 = EID2. RXF9EIDL (7), Bit 1 = EID1. RXF9EIDL (7), Bit 0 = EID0. RXF9EIDL (7), Value on POR, BOR = xxxx xxxx. RXF9EIDL (7), Details on page: = 47, 230. RXF9EIDH (7), Bit 7 = EID15. RXF9EIDH (7), Bit 6 = EID14. RXF9EIDH (7), Bit 5 = EID13. RXF9EIDH (7), Bit 4 = EID12. RXF9EIDH (7), Bit 3 = EID11.",
    "TABLE 4-3:\nRXF9EIDH (7), Bit 2 = EID10. RXF9EIDH (7), Bit 1 = EID9. RXF9EIDH (7), Bit 0 = EID8. RXF9EIDH (7), Value on POR, BOR = xxxx xxxx. RXF9EIDH (7), Details on page: = 48, 230. RXF9SIDL (7), Bit 7 = SID2. RXF9SIDL (7), Bit 6 = SID1. RXF9SIDL (7), Bit 5 = SID0. RXF9SIDL (7), Bit 4 = -. RXF9SIDL (7), Bit 3 = EXIDEN. RXF9SIDL (7), Bit 2 = -. RXF9SIDL (7), Bit 1 = EID17. RXF9SIDL (7), Bit 0 = EID16. RXF9SIDL (7), Value on POR, BOR = xx-x x-xx. RXF9SIDL",
    "TABLE 4-3:\n(7), Details on page: = 48, 230. RXF9SIDH (7), Bit 7 = SID10. RXF9SIDH (7), Bit 6 = SID9. RXF9SIDH (7), Bit 5 = SID8. RXF9SIDH (7), Bit 4 = SID7. RXF9SIDH (7), Bit 3 = SID6. RXF9SIDH (7), Bit 2 = SID5. RXF9SIDH (7), Bit 1 = SID4. RXF9SIDH (7), Bit 0 = SID3. RXF9SIDH (7), Value on POR, BOR = xxxx xxxx. RXF9SIDH (7), Details on page: = 48, 230. RXF8EIDL (7), Bit 7 = EID7. RXF8EIDL (7), Bit 6 = EID6. RXF8EIDL (7), Bit 5 = EID5. RXF8EIDL (7), Bit 4 = EID4.",
    "TABLE 4-3:\nRXF8EIDL (7), Bit 3 = EID3. RXF8EIDL (7), Bit 2 = EID2. RXF8EIDL (7), Bit 1 = EID1. RXF8EIDL (7), Bit 0 = EID0. RXF8EIDL (7), Value on POR, BOR = xxxx xxxx. RXF8EIDL (7), Details on page: = 48, 230. RXF8EIDH (7), Bit 7 = EID15. RXF8EIDH (7), Bit 6 = EID14. RXF8EIDH (7), Bit 5 = EID13. RXF8EIDH (7), Bit 4 = EID12. RXF8EIDH (7), Bit 3 = EID11. RXF8EIDH (7), Bit 2 = EID10. RXF8EIDH (7), Bit 1 = EID9. RXF8EIDH (7), Bit 0 = EID8. RXF8EIDH",
    "TABLE 4-3:\n(7), Value on POR, BOR = xxxx xxxx. RXF8EIDH (7), Details on page: = 48, 230. RXF8SIDL (7), Bit 7 = SID2. RXF8SIDL (7), Bit 6 = SID1. RXF8SIDL (7), Bit 5 = SID0. RXF8SIDL (7), Bit 4 = -. RXF8SIDL (7), Bit 3 = EXIDEN. RXF8SIDL (7), Bit 2 = -. RXF8SIDL (7), Bit 1 = EID17. RXF8SIDL (7), Bit 0 = EID16. RXF8SIDL (7), Value on POR, BOR = xx-x x-xx. RXF8SIDL (7), Details on page: = 48, 230. RXF8SIDH (7), Bit 7 = SID10. RXF8SIDH (7), Bit 6 = SID9. RXF8SIDH (7), Bit 5",
    "TABLE 4-3:\n= SID8. RXF8SIDH (7), Bit 4 = SID7. RXF8SIDH (7), Bit 3 = SID6. RXF8SIDH (7), Bit 2 = SID5. RXF8SIDH (7), Bit 1 = SID4. RXF8SIDH (7), Bit 0 = SID3. RXF8SIDH (7), Value on POR, BOR = xxxx xxxx. RXF8SIDH (7), Details on page: = 48, 230. RXF7EIDL (7), Bit 7 = EID7. RXF7EIDL (7), Bit 6 = EID6. RXF7EIDL (7), Bit 5 = EID5. RXF7EIDL (7), Bit 4 = EID4. RXF7EIDL (7), Bit 3 = EID3. RXF7EIDL (7), Bit 2 = EID2. RXF7EIDL (7), Bit 1 = EID1. RXF7EIDL",
    "TABLE 4-3:\n(7), Bit 0 = EID0. RXF7EIDL (7), Value on POR, BOR = xxxx xxxx. RXF7EIDL (7), Details on page: = 48, 230. RXF7EIDH (7), Bit 7 = EID15. RXF7EIDH (7), Bit 6 = EID14. RXF7EIDH (7), Bit 5 = EID13. RXF7EIDH (7), Bit 4 = EID12. RXF7EIDH (7), Bit 3 = EID11. RXF7EIDH (7), Bit 2 = EID10. RXF7EIDH (7), Bit 1 = EID9. RXF7EIDH (7), Bit 0 = EID8. RXF7EIDH (7), Value on POR, BOR = xxxx xxxx. RXF7EIDH (7), Details on page: = 48, 230. RXF7SIDL (7), Bit 7 = SID2. RXF7SIDL",
    "TABLE 4-3:\n(7), Bit 6 = SID1. RXF7SIDL (7), Bit 5 = SID0. RXF7SIDL (7), Bit 4 = -. RXF7SIDL (7), Bit 3 = EXIDEN. RXF7SIDL (7), Bit 2 = -. RXF7SIDL (7), Bit 1 = EID17. RXF7SIDL (7), Bit 0 = EID16. RXF7SIDL (7), Value on POR, BOR = xx-x x-xx. RXF7SIDL (7), Details on page: = 48, 230. RXF7SIDH (7), Bit 7 = SID10. RXF7SIDH (7), Bit 6 = SID9. RXF7SIDH (7), Bit 5 = SID8. RXF7SIDH (7), Bit 4 = SID7. RXF7SIDH (7), Bit 3 = SID6. RXF7SIDH (7), Bit 2 = SID5.",
    "TABLE 4-3:\nRXF7SIDH (7), Bit 1 = SID4. RXF7SIDH (7), Bit 0 = SID3. RXF7SIDH (7), Value on POR, BOR = xxxx xxxx. RXF7SIDH (7), Details on page: = 48, 230. RXF6EIDL (7), Bit 7 = EID7. RXF6EIDL (7), Bit 6 = EID6. RXF6EIDL (7), Bit 5 = EID5. RXF6EIDL (7), Bit 4 = EID4. RXF6EIDL (7), Bit 3 = EID3. RXF6EIDL (7), Bit 2 = EID2. RXF6EIDL (7), Bit 1 = EID1. RXF6EIDL (7), Bit 0 = EID0. RXF6EIDL (7), Value on POR, BOR = xxxx xxxx. RXF6EIDL (7), Details on page: = 48, 230.",
    "TABLE 4-3:\nRXF6EIDH (7), Bit 7 = EID15. RXF6EIDH (7), Bit 6 = EID14. RXF6EIDH (7), Bit 5 = EID13. RXF6EIDH (7), Bit 4 = EID12. RXF6EIDH (7), Bit 3 = EID11. RXF6EIDH (7), Bit 2 = EID10. RXF6EIDH (7), Bit 1 = EID9. RXF6EIDH (7), Bit 0 = EID8. RXF6EIDH (7), Value on POR, BOR = xxxx xxxx. RXF6EIDH (7), Details on page: = 48, 230. RXF6SIDL (7), Bit 7 = SID2. RXF6SIDL (7), Bit 6 = SID1. RXF6SIDL (7), Bit 5 = SID0. RXF6SIDL (7), Bit 4 = -. RXF6SIDL (7), Bit",
    "TABLE 4-3:\n3 = EXIDEN. RXF6SIDL (7), Bit 2 = -. RXF6SIDL (7), Bit 1 = EID17. RXF6SIDL (7), Bit 0 = EID16. RXF6SIDL (7), Value on POR, BOR = xx-x x-xx. RXF6SIDL (7), Details on page: = 48, 230. RXF6SIDH (7), Bit 7 = SID10. RXF6SIDH (7), Bit 6 = SID9. RXF6SIDH (7), Bit 5 = SID8. RXF6SIDH (7), Bit 4 = SID7. RXF6SIDH (7), Bit 3 = SID6. RXF6SIDH (7), Bit 2 = SID5. RXF6SIDH (7), Bit 1 = SID4. RXF6SIDH (7), Bit 0 = SID3. RXF6SIDH (7), Value on POR, BOR = xxxx xxxx.",
    "TABLE 4-3:\nRXF6SIDH (7), Details on page: = 48, 230. RXF5EIDL, Bit 7 = EID7. RXF5EIDL, Bit 6 = EID6. RXF5EIDL, Bit 5 = EID5. RXF5EIDL, Bit 4 = EID4. RXF5EIDL, Bit 3 = EID3. RXF5EIDL, Bit 2 = EID2. RXF5EIDL, Bit 1 = EID1. RXF5EIDL, Bit 0 = EID0. RXF5EIDL, Value on POR, BOR = xxxx xxxx. RXF5EIDL, Details on page: = 43, 230. RXF5EIDH, Bit 7 = EID15. RXF5EIDH, Bit 6 = EID14. RXF5EIDH, Bit 5 = EID13. RXF5EIDH, Bit 4 = EID12. RXF5EIDH, Bit 3 = EID11. RXF5EIDH, Bit 2 = EID10.",
    "TABLE 4-3:\nRXF5EIDH, Bit 1 = EID9. RXF5EIDH, Bit 0 = EID8. RXF5EIDH, Value on POR, BOR = xxxx xxxx. RXF5EIDH, Details on page: = 43, 230",
    "REGISTER FILE SUMMARY (CONTINUED)\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote\n1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6X80 devices; always maintain these clear.\n4: These bits have multiple functions depending on the CAN module mode selection.\n5: Meaning of this register depends on whether this buffer is configured as transmit or receive.\n6: RG5 is available as an input when MCLR is disabled.\n7: This register reads all ' 0 's until the ECAN module is set up in Mode 1 or Mode 2.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXF5SIDL, Bit 7 = SID2. RXF5SIDL, Bit 6 = SID1. RXF5SIDL, Bit 5 = SID0. RXF5SIDL, Bit 4 = -. RXF5SIDL, Bit 3 = EXIDEN. RXF5SIDL, Bit 2 = -. RXF5SIDL, Bit 1 = EID17. RXF5SIDL, Bit 0 = EID16. RXF5SIDL, Value on POR, BOR = xx-x x-xx. RXF5SIDL, Details on page: = 43, 230. RXF5SIDH, Bit 7 = SID10. RXF5SIDH, Bit 6 = SID9. RXF5SIDH, Bit 5 = SID8. RXF5SIDH, Bit 4 = SID7. RXF5SIDH, Bit 3 = SID6. RXF5SIDH, Bit 2 = SID5. RXF5SIDH, Bit 1 = SID4. RXF5SIDH, Bit 0 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nSID3. RXF5SIDH, Value on POR, BOR = xxxx xxxx. RXF5SIDH, Details on page: = 43, 230. RXF4EIDL, Bit 7 = EID7. RXF4EIDL, Bit 6 = EID6. RXF4EIDL, Bit 5 = EID5. RXF4EIDL, Bit 4 = EID4. RXF4EIDL, Bit 3 = EID3. RXF4EIDL, Bit 2 = EID2. RXF4EIDL, Bit 1 = EID1. RXF4EIDL, Bit 0 = EID0. RXF4EIDL, Value on POR, BOR = xxxx xxxx. RXF4EIDL, Details on page: = 43, 230. RXF4EIDH, Bit 7 = EID15. RXF4EIDH, Bit 6 = EID14. RXF4EIDH, Bit 5 = EID13. RXF4EIDH, Bit 4 = EID12.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXF4EIDH, Bit 3 = EID11. RXF4EIDH, Bit 2 = EID10. RXF4EIDH, Bit 1 = EID9. RXF4EIDH, Bit 0 = EID8. RXF4EIDH, Value on POR, BOR = xxxx xxxx. RXF4EIDH, Details on page: = 43, 230. RXF4SIDL, Bit 7 = SID2. RXF4SIDL, Bit 6 = SID1. RXF4SIDL, Bit 5 = SID0. RXF4SIDL, Bit 4 = -. RXF4SIDL, Bit 3 = EXIDEN. RXF4SIDL, Bit 2 = -. RXF4SIDL, Bit 1 = EID17. RXF4SIDL, Bit 0 = EID16. RXF4SIDL, Value on POR, BOR = xx-x x-xx. RXF4SIDL, Details on page: = 43, 230. RXF4SIDH, Bit 7 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nSID10. RXF4SIDH, Bit 6 = SID9. RXF4SIDH, Bit 5 = SID8. RXF4SIDH, Bit 4 = SID7. RXF4SIDH, Bit 3 = SID6. RXF4SIDH, Bit 2 = SID5. RXF4SIDH, Bit 1 = SID4. RXF4SIDH, Bit 0 = SID3. RXF4SIDH, Value on POR, BOR = xxxx xxxx. RXF4SIDH, Details on page: = 43, 230. RXF3EIDL, Bit 7 = EID7. RXF3EIDL, Bit 6 = EID6. RXF3EIDL, Bit 5 = EID5. RXF3EIDL, Bit 4 = EID4. RXF3EIDL, Bit 3 = EID3. RXF3EIDL, Bit 2 = EID2. RXF3EIDL, Bit 1 = EID1. RXF3EIDL, Bit 0 = EID0.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXF3EIDL, Value on POR, BOR = xxxx xxxx. RXF3EIDL, Details on page: = 43, 230. RXF3EIDH, Bit 7 = EID15. RXF3EIDH, Bit 6 = EID14. RXF3EIDH, Bit 5 = EID13. RXF3EIDH, Bit 4 = EID12. RXF3EIDH, Bit 3 = EID11. RXF3EIDH, Bit 2 = EID10. RXF3EIDH, Bit 1 = EID9. RXF3EIDH, Bit 0 = EID8. RXF3EIDH, Value on POR, BOR = xxxx xxxx. RXF3EIDH, Details on page: = 43, 230. RXF3SIDL, Bit 7 = SID2. RXF3SIDL, Bit 6 = SID1. RXF3SIDL, Bit 5 = SID0. RXF3SIDL, Bit 4 = -. RXF3SIDL, Bit 3 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nEXIDEN. RXF3SIDL, Bit 2 = -. RXF3SIDL, Bit 1 = EID17. RXF3SIDL, Bit 0 = EID16. RXF3SIDL, Value on POR, BOR = xx-x x-xx. RXF3SIDL, Details on page: = 43, 230. RXF3SIDH, Bit 7 = SID10. RXF3SIDH, Bit 6 = SID9. RXF3SIDH, Bit 5 = SID8. RXF3SIDH, Bit 4 = SID7. RXF3SIDH, Bit 3 = SID6. RXF3SIDH, Bit 2 = SID5. RXF3SIDH, Bit 1 = SID4. RXF3SIDH, Bit 0 = SID3. RXF3SIDH, Value on POR, BOR = xxxx xxxx. RXF3SIDH, Details on page: = 43, 230. RXF2EIDL, Bit 7 = EID7. RXF2EIDL, Bit 6 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nEID6. RXF2EIDL, Bit 5 = EID5. RXF2EIDL, Bit 4 = EID4. RXF2EIDL, Bit 3 = EID3. RXF2EIDL, Bit 2 = EID2. RXF2EIDL, Bit 1 = EID1. RXF2EIDL, Bit 0 = EID0. RXF2EIDL, Value on POR, BOR = xxxx xxxx. RXF2EIDL, Details on page: = 43, 230. RXF2EIDH, Bit 7 = EID15. RXF2EIDH, Bit 6 = EID14. RXF2EIDH, Bit 5 = EID13. RXF2EIDH, Bit 4 = EID12. RXF2EIDH, Bit 3 = EID11. RXF2EIDH, Bit 2 = EID10. RXF2EIDH, Bit 1 = EID9. RXF2EIDH, Bit 0 = EID8. RXF2EIDH, Value on",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPOR, BOR = xxxx xxxx. RXF2EIDH, Details on page: = 43, 230. RXF2SIDL, Bit 7 = SID2. RXF2SIDL, Bit 6 = SID1. RXF2SIDL, Bit 5 = SID0. RXF2SIDL, Bit 4 = -. RXF2SIDL, Bit 3 = EXIDEN. RXF2SIDL, Bit 2 = -. RXF2SIDL, Bit 1 = EID17. RXF2SIDL, Bit 0 = EID16. RXF2SIDL, Value on POR, BOR = xx-x x-xx. RXF2SIDL, Details on page: = 43, 230. RXF2SIDH, Bit 7 = SID10. RXF2SIDH, Bit 6 = SID9. RXF2SIDH, Bit 5 = SID8. RXF2SIDH, Bit 4 = SID7. RXF2SIDH, Bit 3 = SID6. RXF2SIDH, Bit 2 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nSID5. RXF2SIDH, Bit 1 = SID4. RXF2SIDH, Bit 0 = SID3. RXF2SIDH, Value on POR, BOR = xxxx xxxx. RXF2SIDH, Details on page: = 43, 230. RXF1EIDL, Bit 7 = EID7. RXF1EIDL, Bit 6 = EID6. RXF1EIDL, Bit 5 = EID5. RXF1EIDL, Bit 4 = EID4. RXF1EIDL, Bit 3 = EID3. RXF1EIDL, Bit 2 = EID2. RXF1EIDL, Bit 1 = EID1. RXF1EIDL, Bit 0 = EID0. RXF1EIDL, Value on POR, BOR = xxxx xxxx. RXF1EIDL, Details on page: = 43, 230. RXF1EIDH, Bit 7 = EID15. RXF1EIDH, Bit 6 = EID14.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXF1EIDH, Bit 5 = EID13. RXF1EIDH, Bit 4 = EID12. RXF1EIDH, Bit 3 = EID11. RXF1EIDH, Bit 2 = EID10. RXF1EIDH, Bit 1 = EID9. RXF1EIDH, Bit 0 = EID8. RXF1EIDH, Value on POR, BOR = xxxx xxxx. RXF1EIDH, Details on page: = 43, 230. RXF1SIDL, Bit 7 = SID2. RXF1SIDL, Bit 6 = SID1. RXF1SIDL, Bit 5 = SID0. RXF1SIDL, Bit 4 = -. RXF1SIDL, Bit 3 = EXIDEN. RXF1SIDL, Bit 2 = -. RXF1SIDL, Bit 1 = EID17. RXF1SIDL, Bit 0 = EID16. RXF1SIDL, Value on POR, BOR = xx-x x-xx.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXF1SIDL, Details on page: = 43, 230. RXF1SIDH, Bit 7 = SID10. RXF1SIDH, Bit 6 = SID9. RXF1SIDH, Bit 5 = SID8. RXF1SIDH, Bit 4 = SID7. RXF1SIDH, Bit 3 = SID6. RXF1SIDH, Bit 2 = SID5. RXF1SIDH, Bit 1 = SID4. RXF1SIDH, Bit 0 = SID3. RXF1SIDH, Value on POR, BOR = xxxx xxxx. RXF1SIDH, Details on page: = 43, 230. RXF0EIDL, Bit 7 = EID7. RXF0EIDL, Bit 6 = EID6. RXF0EIDL, Bit 5 = EID5. RXF0EIDL, Bit 4 = EID4. RXF0EIDL, Bit 3 = EID3. RXF0EIDL, Bit 2 = EID2.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXF0EIDL, Bit 1 = EID1. RXF0EIDL, Bit 0 = EID0. RXF0EIDL, Value on POR, BOR = xxxx xxxx. RXF0EIDL, Details on page: = 43, 230. RXF0EIDH, Bit 7 = EID15. RXF0EIDH, Bit 6 = EID14. RXF0EIDH, Bit 5 = EID13. RXF0EIDH, Bit 4 = EID12. RXF0EIDH, Bit 3 = EID11. RXF0EIDH, Bit 2 = EID10. RXF0EIDH, Bit 1 = EID9. RXF0EIDH, Bit 0 = EID8. RXF0EIDH, Value on POR, BOR = xxxx xxxx. RXF0EIDH, Details on page: = 43, 230. RXF0SIDL, Bit 7 = SID2. RXF0SIDL, Bit 6 = SID1. RXF0SIDL, Bit 5",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n= SID0. RXF0SIDL, Bit 4 = -. RXF0SIDL, Bit 3 = EXIDEN. RXF0SIDL, Bit 2 = -. RXF0SIDL, Bit 1 = EID17. RXF0SIDL, Bit 0 = EID16. RXF0SIDL, Value on POR, BOR = xx-x x-xx. RXF0SIDL, Details on page: = 43, 230. RXF0SIDH, Bit 7 = SID10. RXF0SIDH, Bit 6 = SID9. RXF0SIDH, Bit 5 = SID8. RXF0SIDH, Bit 4 = SID7. RXF0SIDH, Bit 3 = SID6. RXF0SIDH, Bit 2 = SID5. RXF0SIDH, Bit 1 = SID4. RXF0SIDH, Bit 0 = SID3. RXF0SIDH, Value on POR, BOR = xxxx xxxx. RXF0SIDH, Details on page: = 43,",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n230. B5D7 (7), Bit 7 = B5D77. B5D7 (7), Bit 6 = B5D76. B5D7 (7), Bit 5 = B5D75. B5D7 (7), Bit 4 = B5D74. B5D7 (7), Bit 3 = B5D73. B5D7 (7), Bit 2 = B5D72. B5D7 (7), Bit 1 = B5D71. B5D7 (7), Bit 0 = B5D70. B5D7 (7), Value on POR, BOR = xxxx xxxx. B5D7 (7), Details on page: = 44, 230. B5D6 (7), Bit 7 = B5D67. B5D6 (7), Bit 6 = B5D66. B5D6 (7), Bit 5 = B5D65. B5D6 (7), Bit 4 = B5D64. B5D6",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n(7), Bit 3 = B5D63. B5D6 (7), Bit 2 = B5D62. B5D6 (7), Bit 1 = B5D61. B5D6 (7), Bit 0 = B5D60. B5D6 (7), Value on POR, BOR = xxxx xxxx. B5D6 (7), Details on page: = 44, 230. B5D5 (7), Bit 7 = B5D57. B5D5 (7), Bit 6 = B5D56. B5D5 (7), Bit 5 = B5D55. B5D5 (7), Bit 4 = B5D54. B5D5 (7), Bit 3 = B5D53. B5D5 (7), Bit 2 = B5D52. B5D5 (7), Bit 1 = B5D51. B5D5 (7), Bit 0 = B5D50. B5D5 (7), Value on POR, BOR = xxxx",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nxxxx. B5D5 (7), Details on page: = 44, 230. B5D4 (7), Bit 7 = B5D47. B5D4 (7), Bit 6 = B5D46. B5D4 (7), Bit 5 = B5D45. B5D4 (7), Bit 4 = B5D44. B5D4 (7), Bit 3 = B5D43. B5D4 (7), Bit 2 = B5D42. B5D4 (7), Bit 1 = B5D41. B5D4 (7), Bit 0 = B5D40. B5D4 (7), Value on POR, BOR = xxxx xxxx. B5D4 (7), Details on page: = 44, 230. B5D3 (7), Bit 7 = B5D37. B5D3 (7), Bit 6 = B5D36. B5D3 (7), Bit 5 = B5D35. B5D3 (7), Bit 4 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nB5D34. B5D3 (7), Bit 3 = B5D33. B5D3 (7), Bit 2 = B5D32. B5D3 (7), Bit 1 = B5D31. B5D3 (7), Bit 0 = B5D30. B5D3 (7), Value on POR, BOR = xxxx xxxx. B5D3 (7), Details on page: = 44, 230. B5D2 (7), Bit 7 = B5D27. B5D2 (7), Bit 6 = B5D26. B5D2 (7), Bit 5 = B5D25. B5D2 (7), Bit 4 = B5D24. B5D2 (7), Bit 3 = B5D23. B5D2 (7), Bit 2 = B5D22. B5D2 (7), Bit 1 = B5D21. B5D2 (7), Bit 0 = B5D20. B5D2 (7), Value on",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nPOR, BOR = xxxx xxxx. B5D2 (7), Details on page: = 44, 230. B5D1 (7), Bit 7 = B5D17. B5D1 (7), Bit 6 = B5D16. B5D1 (7), Bit 5 = B5D15. B5D1 (7), Bit 4 = B5D14. B5D1 (7), Bit 3 = B5D13. B5D1 (7), Bit 2 = B5D12. B5D1 (7), Bit 1 = B5D11. B5D1 (7), Bit 0 = B5D10. B5D1 (7), Value on POR, BOR = xxxx xxxx. B5D1 (7), Details on page: = 44, 230. B5D0 (7), Bit 7 = B5D07. B5D0 (7), Bit 6 = B5D06. B5D0 (7), Bit 5 = B5D05.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nB5D0 (7), Bit 4 = B5D04. B5D0 (7), Bit 3 = B5D03. B5D0 (7), Bit 2 = B5D02. B5D0 (7), Bit 1 = B5D01. B5D0 (7), Bit 0 = B5D00. B5D0 (7), Value on POR, BOR = xxxx xxxx. B5D0 (7), Details on page: = 44, 230. B5DLC (7), Bit 7 = -. B5DLC (7), Bit 6 = RXRTR. B5DLC (7), Bit 5 = RB1. B5DLC (7), Bit 4 = RB0. B5DLC (7), Bit 3 = DLC3. B5DLC (7), Bit 2 = DLC2. B5DLC (7), Bit 1 = DLC1. B5DLC (7), Bit 0 = DLC0. B5DLC (7),",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nValue on POR, BOR = -xxx xxxx. B5DLC (7), Details on page: = 44, 230. B5EIDL (7), Bit 7 = EID7. B5EIDL (7), Bit 6 = EID6. B5EIDL (7), Bit 5 = EID5. B5EIDL (7), Bit 4 = EID4. B5EIDL (7), Bit 3 = EID3. B5EIDL (7), Bit 2 = EID2. B5EIDL (7), Bit 1 = EID1. B5EIDL (7), Bit 0 = EID0. B5EIDL (7), Value on POR, BOR = xxxx xxxx. B5EIDL (7), Details on page: = 44, 230. B5EIDH (7), Bit 7 = EID15. B5EIDH (7), Bit 6 = EID14. B5EIDH (7), Bit 5 = EID13. B5EIDH (7), Bit 4 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nEID12. B5EIDH (7), Bit 3 = EID11. B5EIDH (7), Bit 2 = EID10. B5EIDH (7), Bit 1 = EID9. B5EIDH (7), Bit 0 = EID8. B5EIDH (7), Value on POR, BOR = xxxx xxxx. B5EIDH (7), Details on page: = 44, 230. B5SIDL (7), Bit 7 = SID2. B5SIDL (7), Bit 6 = SID1. B5SIDL (7), Bit 5 = SID0. B5SIDL (7), Bit 4 = SRR. B5SIDL (7), Bit 3 = EXID/ EXIDE (5). B5SIDL (7), Bit 2 = -. B5SIDL (7), Bit 1 = EID17. B5SIDL (7), Bit 0 = EID16. B5SIDL (7), Value on POR, BOR = xxxx x-xx. B5SIDL",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n(7), Details on page: = 44, 230. B5SIDH (7), Bit 7 = SID10. B5SIDH (7), Bit 6 = SID9. B5SIDH (7), Bit 5 = SID8. B5SIDH (7), Bit 4 = SID7. B5SIDH (7), Bit 3 = SID6. B5SIDH (7), Bit 2 = SID5. B5SIDH (7), Bit 1 = SID4. B5SIDH (7), Bit 0 = SID3. B5SIDH (7), Value on POR, BOR = xxxx xxxx. B5SIDH (7), Details on page: = 44, 230. B5CON (5, 7), Bit 7 = RXFUL/ TXBIF. B5CON (5, 7), Bit 6 = RXM1/ TXABT. B5CON (5, 7), Bit 5 = RTRRO/ TXLARB. B5CON (5, 7), Bit 4 = FILHIT4/ TXERR.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nB5CON (5, 7), Bit 3 = FILHIT3/ TXREQ. B5CON (5, 7), Bit 2 = FILHIT2/ RTREN. B5CON (5, 7), Bit 1 = FILHIT1/ TXPRI1. B5CON (5, 7), Bit 0 = FILHIT0/ TXPRI0. B5CON (5, 7), Value on POR, BOR = 0000 0000. B5CON (5, 7), Details on page: = 44, 230. B4D7 (7), Bit 7 = B4D77. B4D7 (7), Bit 6 = B4D76. B4D7 (7), Bit 5 = B4D75. B4D7 (7), Bit 4 = B4D74. B4D7 (7), Bit 3 = B4D73. B4D7 (7), Bit 2 = B4D72. B4D7 (7), Bit 1 = B4D71.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nB4D7 (7), Bit 0 = B4D70. B4D7 (7), Value on POR, BOR = xxxx xxxx. B4D7 (7), Details on page: = 44, 230. B4D6 (7), Bit 7 = B4D67. B4D6 (7), Bit 6 = B4D66. B4D6 (7), Bit 5 = B4D65. B4D6 (7), Bit 4 = B4D64. B4D6 (7), Bit 3 = B4D63. B4D6 (7), Bit 2 = B4D62. B4D6 (7), Bit 1 = B4D61. B4D6 (7), Bit 0 = B4D60. B4D6 (7), Value on POR, BOR = xxxx xxxx. B4D6 (7), Details on page: = 44, 230. B4D5 (7), Bit 7 = B4D57. B4D5",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n(7), Bit 6 = B4D56. B4D5 (7), Bit 5 = B4D55. B4D5 (7), Bit 4 = B4D54. B4D5 (7), Bit 3 = B4D53. B4D5 (7), Bit 2 = B4D52. B4D5 (7), Bit 1 = B4D51. B4D5 (7), Bit 0 = B4D50. B4D5 (7), Value on POR, BOR = xxxx xxxx. B4D5 (7), Details on page: = 44, 230. B4D4 (7), Bit 7 = B4D47. B4D4 (7), Bit 6 = B4D46. B4D4 (7), Bit 5 = B4D45. B4D4 (7), Bit 4 = B4D44. B4D4 (7), Bit 3 = B4D43. B4D4 (7), Bit 2 = B4D42. B4D4",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n(7), Bit 1 = B4D41. B4D4 (7), Bit 0 = B4D40. B4D4 (7), Value on POR, BOR = xxxx xxxx. B4D4 (7), Details on page: = 44, 230\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6X80 devices; always maintain these clear.\n4: These bits have multiple functions depending on the CAN module mode selection.\n5: Meaning of this register depends on whether this buffer is configured as transmit or receive.\n6: RG5 is available as an input when MCLR is disabled.\n7: This register reads all ' 0 's until the ECAN module is set up in Mode 1 or Mode 2.",
    "TABLE 4-3:\nB4D3 (7), Bit 7 = B4D37. B4D3 (7), Bit 6 = B4D36. B4D3 (7), Bit 5 = B4D35. B4D3 (7), Bit 4 = B4D34. B4D3 (7), Bit 3 = B4D33. B4D3 (7), Bit 2 = B4D32. B4D3 (7), Bit 1 = B4D31. B4D3 (7), Bit 0 = B4D30. B4D3 (7), Value on POR, BOR = xxxx xxxx. B4D3 (7), Details on page: = 44, 230. B4D2 (7), Bit 7 = B4D27. B4D2 (7), Bit 6 = B4D26. B4D2 (7), Bit 5 = B4D25. B4D2 (7), Bit 4 = B4D24. B4D2 (7), Bit 3 = B4D23. B4D2",
    "TABLE 4-3:\n(7), Bit 2 = B4D22. B4D2 (7), Bit 1 = B4D21. B4D2 (7), Bit 0 = B4D20. B4D2 (7), Value on POR, BOR = xxxx xxxx. B4D2 (7), Details on page: = 44, 230. B4D1 (7), Bit 7 = B4D17. B4D1 (7), Bit 6 = B4D16. B4D1 (7), Bit 5 = B4D15. B4D1 (7), Bit 4 = B4D14. B4D1 (7), Bit 3 = B4D13. B4D1 (7), Bit 2 = B4D12. B4D1 (7), Bit 1 = B4D11. B4D1 (7), Bit 0 = B4D10. B4D1 (7), Value on POR, BOR = xxxx xxxx. B4D1 (7), Details on page: = 44, 230. B4D0",
    "TABLE 4-3:\n(7), Bit 7 = B4D07. B4D0 (7), Bit 6 = B4D06. B4D0 (7), Bit 5 = B4D05. B4D0 (7), Bit 4 = B4D04. B4D0 (7), Bit 3 = B4D03. B4D0 (7), Bit 2 = B4D02. B4D0 (7), Bit 1 = B4D01. B4D0 (7), Bit 0 = B4D00. B4D0 (7), Value on POR, BOR = xxxx xxxx. B4D0 (7), Details on page: = 44, 230. B4DLC (7), Bit 7 = -. B4DLC (7), Bit 6 = RXRTR. B4DLC (7), Bit 5 = RB1. B4DLC (7), Bit 4 = RB0. B4DLC (7), Bit 3 = DLC3. B4DLC (7), Bit 2 =",
    "TABLE 4-3:\nDLC2. B4DLC (7), Bit 1 = DLC1. B4DLC (7), Bit 0 = DLC0. B4DLC (7), Value on POR, BOR = -xxx xxxx. B4DLC (7), Details on page: = 44, 230. B4EIDL (7), Bit 7 = EID7. B4EIDL (7), Bit 6 = EID6. B4EIDL (7), Bit 5 = EID5. B4EIDL (7), Bit 4 = EID4. B4EIDL (7), Bit 3 = EID3. B4EIDL (7), Bit 2 = EID2. B4EIDL (7), Bit 1 = EID1. B4EIDL (7), Bit 0 = EID0. B4EIDL (7), Value on POR, BOR = xxxx xxxx. B4EIDL (7), Details on page: = 44, 230. B4EIDH (7), Bit 7 = EID15. B4EIDH",
    "TABLE 4-3:\n(7), Bit 6 = EID14. B4EIDH (7), Bit 5 = EID13. B4EIDH (7), Bit 4 = EID12. B4EIDH (7), Bit 3 = EID11. B4EIDH (7), Bit 2 = EID10. B4EIDH (7), Bit 1 = EID9. B4EIDH (7), Bit 0 = EID8. B4EIDH (7), Value on POR, BOR = xxxx xxxx. B4EIDH (7), Details on page: = 44, 230. B4SIDL (7), Bit 7 = SID2. B4SIDL (7), Bit 6 = SID1. B4SIDL (7), Bit 5 = SID0. B4SIDL (7), Bit 4 = SRR. B4SIDL (7), Bit 3 = EXID/ EXIDE (5). B4SIDL (7), Bit 2 = -. B4SIDL (7), Bit 1 = EID17. B4SIDL (7), Bit",
    "TABLE 4-3:\n0 = EID16. B4SIDL (7), Value on POR, BOR = xxxx x-xx. B4SIDL (7), Details on page: = 44, 230. B4SIDH (7), Bit 7 = SID10. B4SIDH (7), Bit 6 = SID9. B4SIDH (7), Bit 5 = SID8. B4SIDH (7), Bit 4 = SID7. B4SIDH (7), Bit 3 = SID6. B4SIDH (7), Bit 2 = SID5. B4SIDH (7), Bit 1 = SID4. B4SIDH (7), Bit 0 = SID3. B4SIDH (7), Value on POR, BOR = xxxx xxxx. B4SIDH (7), Details on page: = 44, 230. B4CON (5, 7), Bit 7 = RXFUL/ TXB3IF. B4CON (5, 7), Bit 6 = RXM1/ TXABT. B4CON (5, 7), Bit 5 = RTRRO/",
    "TABLE 4-3:\nTXLARB. B4CON (5, 7), Bit 4 = FILHIT4/ TXERR. B4CON (5, 7), Bit 3 = FILHIT3/ TXREQ. B4CON (5, 7), Bit 2 = FILHIT2/ RTREN. B4CON (5, 7), Bit 1 = FILHIT1/ TXPRI1. B4CON (5, 7), Bit 0 = FILHIT0/ TXPRI0. B4CON (5, 7), Value on POR, BOR = 0000 0000. B4CON (5, 7), Details on page: = 44, 230. B3D7 (7), Bit 7 = B3D77. B3D7 (7), Bit 6 = B3D76. B3D7 (7), Bit 5 = B3D75. B3D7 (7), Bit 4 = B3D74. B3D7 (7), Bit 3 = B3D73. B3D7 (7), Bit 2 = B3D72. B3D7 (7), Bit 1 =",
    "TABLE 4-3:\nB3D71. B3D7 (7), Bit 0 = B3D70. B3D7 (7), Value on POR, BOR = xxxx xxxx. B3D7 (7), Details on page: = 44, 230. B3D6 (7), Bit 7 = B3D67. B3D6 (7), Bit 6 = B3D66. B3D6 (7), Bit 5 = B3D65. B3D6 (7), Bit 4 = B3D64. B3D6 (7), Bit 3 = B3D63. B3D6 (7), Bit 2 = B3D62. B3D6 (7), Bit 1 = B3D61. B3D6 (7), Bit 0 = B3D60. B3D6 (7), Value on POR, BOR = xxxx xxxx. B3D6 (7), Details on page: = 44, 230. B3D5 (7), Bit 7 = B3D57. B3D5 (7), Bit 6 = B3D56. B3D5 (7), Bit 5 = B3D55. B3D5",
    "TABLE 4-3:\n(7), Bit 4 = B3D54. B3D5 (7), Bit 3 = B3D53. B3D5 (7), Bit 2 = B3D52. B3D5 (7), Bit 1 = B3D51. B3D5 (7), Bit 0 = B3D50. B3D5 (7), Value on POR, BOR = xxxx xxxx. B3D5 (7), Details on page: = 44, 230. B3D4 (7), Bit 7 = B3D47. B3D4 (7), Bit 6 = B3D46. B3D4 (7), Bit 5 = B3D45. B3D4 (7), Bit 4 = B3D44. B3D4 (7), Bit 3 = B3D43. B3D4 (7), Bit 2 = B3D42. B3D4 (7), Bit 1 = B3D41. B3D4 (7), Bit 0 = B3D40. B3D4 (7), Value on POR, BOR = xxxx xxxx. B3D4 (7), Details on page: = 45, 230.",
    "TABLE 4-3:\nB3D3 (7), Bit 7 = B3D37. B3D3 (7), Bit 6 = B3D36. B3D3 (7), Bit 5 = B3D35. B3D3 (7), Bit 4 = B3D34. B3D3 (7), Bit 3 = B3D33. B3D3 (7), Bit 2 = B3D32. B3D3 (7), Bit 1 = B3D31. B3D3 (7), Bit 0 = B3D30. B3D3 (7), Value on POR, BOR = xxxx xxxx. B3D3 (7), Details on page: = 45, 230. B3D2 (7), Bit 7 = B3D27. B3D2 (7), Bit 6 = B3D26. B3D2 (7), Bit 5 = B3D25. B3D2 (7), Bit 4 = B3D24. B3D2 (7), Bit 3 = B3D23. B3D2 (7), Bit 2 = B3D22. B3D2 (7), Bit 1 = B3D21. B3D2",
    "TABLE 4-3:\n(7), Bit 0 = B3D20. B3D2 (7), Value on POR, BOR = xxxx xxxx. B3D2 (7), Details on page: = 45, 230. B3D1 (7), Bit 7 = B3D17. B3D1 (7), Bit 6 = B3D16. B3D1 (7), Bit 5 = B3D15. B3D1 (7), Bit 4 = B3D14. B3D1 (7), Bit 3 = B3D13. B3D1 (7), Bit 2 = B3D12. B3D1 (7), Bit 1 = B3D11. B3D1 (7), Bit 0 = B3D10. B3D1 (7), Value on POR, BOR = xxxx xxxx. B3D1 (7), Details on page: = 45, 230. B3D0 (7), Bit 7 = B3D07. B3D0 (7), Bit 6 = B3D06. B3D0 (7), Bit 5 = B3D05. B3D0 (7), Bit 4 =",
    "TABLE 4-3:\nB3D04. B3D0 (7), Bit 3 = B3D03. B3D0 (7), Bit 2 = B3D02. B3D0 (7), Bit 1 = B3D01. B3D0 (7), Bit 0 = B3D00. B3D0 (7), Value on POR, BOR = xxxx xxxx. B3D0 (7), Details on page: = 45, 230. B3DLC (7), Bit 7 = -. B3DLC (7), Bit 6 = RXRTR. B3DLC (7), Bit 5 = RB1. B3DLC (7), Bit 4 = RB0. B3DLC (7), Bit 3 = DLC3. B3DLC (7), Bit 2 = DLC2. B3DLC (7), Bit 1 = DLC1. B3DLC (7), Bit 0 = DLC0. B3DLC (7), Value on POR, BOR = -xxx xxxx. B3DLC (7), Details on page: = 45, 230. B3EIDL (7),",
    "TABLE 4-3:\nBit 7 = EID7. B3EIDL (7), Bit 6 = EID6. B3EIDL (7), Bit 5 = EID5. B3EIDL (7), Bit 4 = EID4. B3EIDL (7), Bit 3 = EID3. B3EIDL (7), Bit 2 = EID2. B3EIDL (7), Bit 1 = EID1. B3EIDL (7), Bit 0 = EID0. B3EIDL (7), Value on POR, BOR = xxxx xxxx. B3EIDL (7), Details on page: = 45, 230. B3EIDH (7), Bit 7 = EID15. B3EIDH (7), Bit 6 = EID14. B3EIDH (7), Bit 5 = EID13. B3EIDH (7), Bit 4 = EID12. B3EIDH (7), Bit 3 = EID11. B3EIDH (7), Bit 2 = EID10. B3EIDH (7), Bit 1 =",
    "TABLE 4-3:\nEID9. B3EIDH (7), Bit 0 = EID8. B3EIDH (7), Value on POR, BOR = xxxx xxxx. B3EIDH (7), Details on page: = 45, 230. B3SIDL (7), Bit 7 = SID2. B3SIDL (7), Bit 6 = SID1. B3SIDL (7), Bit 5 = SID0. B3SIDL (7), Bit 4 = SRR. B3SIDL (7), Bit 3 = EXID/ EXIDE (5). B3SIDL (7), Bit 2 = -. B3SIDL (7), Bit 1 = EID17. B3SIDL (7), Bit 0 = EID16. B3SIDL (7), Value on POR, BOR = xxxx x-xx. B3SIDL (7), Details on page: = 45, 230. B3SIDH (7), Bit 7 = SID10. B3SIDH (7), Bit 6 = SID9. B3SIDH (7), Bit 5",
    "TABLE 4-3:\n= SID8. B3SIDH (7), Bit 4 = SID7. B3SIDH (7), Bit 3 = SID6. B3SIDH (7), Bit 2 = SID5. B3SIDH (7), Bit 1 = SID4. B3SIDH (7), Bit 0 = SID3. B3SIDH (7), Value on POR, BOR = xxxx xxxx. B3SIDH (7), Details on page: = 45, 230. B3CON (5, 7), Bit 7 = RXFUL/ TXBIF. B3CON (5, 7), Bit 6 = RXM1/ TXABT. B3CON (5, 7), Bit 5 = RTRRO/ TXLARB. B3CON (5, 7), Bit 4 = FILHIT4/ TXERR. B3CON (5, 7), Bit 3 = FILHIT3/ TXREQ. B3CON (5, 7), Bit 2 = FILHIT2/ RTREN. B3CON (5, 7), Bit 1 = FILHIT1/",
    "TABLE 4-3:\nTXPRI1. B3CON (5, 7), Bit 0 = FILHIT0/ TXPRI0. B3CON (5, 7), Value on POR, BOR = 0000 0000. B3CON (5, 7), Details on page: = 45, 230. B2D7 (7), Bit 7 = B2D77. B2D7 (7), Bit 6 = B2D76. B2D7 (7), Bit 5 = B2D75. B2D7 (7), Bit 4 = B2D74. B2D7 (7), Bit 3 = B2D73. B2D7 (7), Bit 2 = B2D72. B2D7 (7), Bit 1 = B2D71. B2D7 (7), Bit 0 = B2D70. B2D7 (7), Value on POR, BOR = xxxx xxxx. B2D7 (7), Details on page: = 45, 230. B2D6 (7), Bit 7 =",
    "TABLE 4-3:\nB2D67. B2D6 (7), Bit 6 = B2D66. B2D6 (7), Bit 5 = B2D65. B2D6 (7), Bit 4 = B2D64. B2D6 (7), Bit 3 = B2D63. B2D6 (7), Bit 2 = B2D62. B2D6 (7), Bit 1 = B2D61. B2D6 (7), Bit 0 = B2D60. B2D6 (7), Value on POR, BOR = xxxx xxxx. B2D6 (7), Details on page: = 45, 230. B2D5 (7), Bit 7 = B2D57. B2D5 (7), Bit 6 = B2D56. B2D5 (7), Bit 5 = B2D55. B2D5 (7), Bit 4 = B2D54. B2D5 (7), Bit 3 = B2D53. B2D5 (7), Bit 2 =",
    "TABLE 4-3:\nB2D52. B2D5 (7), Bit 1 = B2D51. B2D5 (7), Bit 0 = B2D50. B2D5 (7), Value on POR, BOR = xxxx xxxx. B2D5 (7), Details on page: = 45, 230. B2D4 (7), Bit 7 = B2D47. B2D4 (7), Bit 6 = B2D46. B2D4 (7), Bit 5 = B2D45. B2D4 (7), Bit 4 = B2D44. B2D4 (7), Bit 3 = B2D43. B2D4 (7), Bit 2 = B2D42. B2D4 (7), Bit 1 = B2D41. B2D4 (7), Bit 0 = B2D40. B2D4 (7), Value on POR, BOR = xxxx xxxx. B2D4 (7), Details on page: = 45, 230. B2D3 (7), Bit 7 =",
    "TABLE 4-3:\nB2D37. B2D3 (7), Bit 6 = B2D36. B2D3 (7), Bit 5 = B2D35. B2D3 (7), Bit 4 = B2D34. B2D3 (7), Bit 3 = B2D33. B2D3 (7), Bit 2 = B2D32. B2D3 (7), Bit 1 = B2D31. B2D3 (7), Bit 0 = B2D30. B2D3 (7), Value on POR, BOR = xxxx xxxx. B2D3 (7), Details on page: = 45, 230. B2D2 (7), Bit 7 = B2D27. B2D2 (7), Bit 6 = B2D26. B2D2 (7), Bit 5 = B2D25. B2D2 (7), Bit 4 = B2D24. B2D2 (7), Bit 3 = B2D23. B2D2 (7), Bit 2 = B2D22.",
    "TABLE 4-3:\nB2D2 (7), Bit 1 = B2D21. B2D2 (7), Bit 0 = B2D20. B2D2 (7), Value on POR, BOR = xxxx xxxx. B2D2 (7), Details on page: = 45, 230. B2D1 (7), Bit 7 = B2D17. B2D1 (7), Bit 6 = B2D16. B2D1 (7), Bit 5 = B2D15. B2D1 (7), Bit 4 = B2D14. B2D1 (7), Bit 3 = B2D13. B2D1 (7), Bit 2 = B2D12. B2D1 (7), Bit 1 = B2D11. B2D1 (7), Bit 0 = B2D10. B2D1 (7), Value on POR, BOR = xxxx xxxx. B2D1 (7), Details on page: = 45, 230. B2D0 (7), Bit 7 = B2D07.",
    "TABLE 4-3:\nB2D0 (7), Bit 6 = B2D06. B2D0 (7), Bit 5 = B2D05. B2D0 (7), Bit 4 = B2D04. B2D0 (7), Bit 3 = B2D03. B2D0 (7), Bit 2 = B2D02. B2D0 (7), Bit 1 = B2D01. B2D0 (7), Bit 0 = B2D00. B2D0 (7), Value on POR, BOR = xxxx xxxx. B2D0 (7), Details on page: = 45, 230. B2DLC (7), Bit 7 = -. B2DLC (7), Bit 6 = RXRTR. B2DLC (7), Bit 5 = RB1. B2DLC (7), Bit 4 = RB0. B2DLC (7), Bit 3 = DLC3. B2DLC (7), Bit 2 = DLC2. B2DLC (7), Bit 1",
    "TABLE 4-3:\n= DLC1. B2DLC (7), Bit 0 = DLC0. B2DLC (7), Value on POR, BOR = -xxx xxxx. B2DLC (7), Details on page: = 45, 230. B2EIDL (7), Bit 7 = EID7. B2EIDL (7), Bit 6 = EID6. B2EIDL (7), Bit 5 = EID5. B2EIDL (7), Bit 4 = EID4. B2EIDL (7), Bit 3 = EID3. B2EIDL (7), Bit 2 = EID2. B2EIDL (7), Bit 1 = EID1. B2EIDL (7), Bit 0 = EID0. B2EIDL (7), Value on POR, BOR = xxxx xxxx. B2EIDL (7), Details on page: = 45, 230. B2EIDH (7), Bit 7 = EID15. B2EIDH (7), Bit 6 = EID14. B2EIDH",
    "TABLE 4-3:\n(7), Bit 5 = EID13. B2EIDH (7), Bit 4 = EID12. B2EIDH (7), Bit 3 = EID11. B2EIDH (7), Bit 2 = EID10. B2EIDH (7), Bit 1 = EID9. B2EIDH (7), Bit 0 = EID8. B2EIDH (7), Value on POR, BOR = xxxx xxxx. B2EIDH (7), Details on page: = 45, 230. B2SIDL (7), Bit 7 = SID2. B2SIDL (7), Bit 6 = SID1. B2SIDL (7), Bit 5 = SID0. B2SIDL (7), Bit 4 = SRR. B2SIDL (7), Bit 3 = EXID/ EXIDE (5). B2SIDL (7), Bit 2 = -. B2SIDL (7), Bit 1 = EID17. B2SIDL (7), Bit 0 = EID16. B2SIDL (7), Value",
    "TABLE 4-3:\non POR, BOR = xxxx x-xx. B2SIDL (7), Details on page: = 45, 230",
    "REGISTER FILE SUMMARY (CONTINUED)\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote\n1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6X80 devices; always maintain these clear.\n4: These bits have multiple functions depending on the CAN module mode selection.\n5: Meaning of this register depends on whether this buffer is configured as transmit or receive.\n6: RG5 is available as an input when MCLR is disabled.\n7: This register reads all ' 0 's until the ECAN module is set up in Mode 1 or Mode 2.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nB2CON (5, 7), Bit 7 = RXFUL/ TXBIF. B2CON (5, 7), Bit 6 = RXM1/ TXABT. B2CON (5, 7), Bit 5 = RTRRO/ TXLARB. B2CON (5, 7), Bit 4 = FILHIT4/ TXERR. B2CON (5, 7), Bit 3 = FILHIT3/ TXREQ. B2CON (5, 7), Bit 2 = FILHIT2/ RTREN. B2CON (5, 7), Bit 1 = FILHIT1/ TXPRI1. B2CON (5, 7), Bit 0 = FILHIT0/ TXPRI0. B2CON (5, 7), Value on POR, BOR = 0000 0000. B2CON (5, 7), Details on page: = 45, 230. B1D7 (7), Bit 7 = B1D77. B1D7 (7), Bit 6 = B1D76. B1D7 (7), Bit 5 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nB1D75. B1D7 (7), Bit 4 = B1D74. B1D7 (7), Bit 3 = B1D73. B1D7 (7), Bit 2 = B1D72. B1D7 (7), Bit 1 = B1D71. B1D7 (7), Bit 0 = B1D70. B1D7 (7), Value on POR, BOR = xxxx xxxx. B1D7 (7), Details on page: = 45, 230. B1D6 (7), Bit 7 = B1D67. B1D6 (7), Bit 6 = B1D66. B1D6 (7), Bit 5 = B1D65. B1D6 (7), Bit 4 = B1D64. B1D6 (7), Bit 3 = B1D63. B1D6 (7), Bit 2 = B1D62. B1D6 (7), Bit 1 = B1D61. B1D6 (7), Bit 0 = B1D60. B1D6 (7), Value on POR, BOR = xxxx",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nxxxx. B1D6 (7), Details on page: = 45, 230. B1D5 (7), Bit 7 = B1D57. B1D5 (7), Bit 6 = B1D56. B1D5 (7), Bit 5 = B1D55. B1D5 (7), Bit 4 = B1D54. B1D5 (7), Bit 3 = B1D53. B1D5 (7), Bit 2 = B1D52. B1D5 (7), Bit 1 = B1D51. B1D5 (7), Bit 0 = B1D50. B1D5 (7), Value on POR, BOR = xxxx xxxx. B1D5 (7), Details on page: = 45, 230. B1D4 (7), Bit 7 = B1D47. B1D4 (7), Bit 6 = B1D46. B1D4 (7), Bit 5 = B1D45. B1D4 (7), Bit 4 = B1D44. B1D4 (7), Bit 3 = B1D43. B1D4 (7), Bit 2",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n= B1D42. B1D4 (7), Bit 1 = B1D41. B1D4 (7), Bit 0 = B1D40. B1D4 (7), Value on POR, BOR = xxxx xxxx. B1D4 (7), Details on page: = 45, 230. B1D3 (7), Bit 7 = B1D37. B1D3 (7), Bit 6 = B1D36. B1D3 (7), Bit 5 = B1D35. B1D3 (7), Bit 4 = B1D34. B1D3 (7), Bit 3 = B1D33. B1D3 (7), Bit 2 = B1D32. B1D3 (7), Bit 1 = B1D31. B1D3 (7), Bit 0 = B1D30. B1D3 (7), Value on POR, BOR = xxxx xxxx. B1D3 (7), Details on page: = 45, 230. B1D2 (7), Bit 7 = B1D27. B1D2 (7), Bit 6 = B1D26.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nB1D2 (7), Bit 5 = B1D25. B1D2 (7), Bit 4 = B1D24. B1D2 (7), Bit 3 = B1D23. B1D2 (7), Bit 2 = B1D22. B1D2 (7), Bit 1 = B1D21. B1D2 (7), Bit 0 = B1D20. B1D2 (7), Value on POR, BOR = xxxx xxxx. B1D2 (7), Details on page: = 45, 230. B1D1 (7), Bit 7 = B1D17. B1D1 (7), Bit 6 = B1D16. B1D1 (7), Bit 5 = B1D15. B1D1 (7), Bit 4 = B1D14. B1D1 (7), Bit 3 = B1D13. B1D1 (7), Bit 2 = B1D12. B1D1 (7), Bit 1 = B1D11. B1D1 (7), Bit 0 = B1D10. B1D1 (7), Value on POR, BOR =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nxxxx xxxx. B1D1 (7), Details on page: = 46, 230. B1D0 (7), Bit 7 = B1D07. B1D0 (7), Bit 6 = B1D06. B1D0 (7), Bit 5 = B1D05. B1D0 (7), Bit 4 = B1D04. B1D0 (7), Bit 3 = B1D03. B1D0 (7), Bit 2 = B1D02. B1D0 (7), Bit 1 = B1D01. B1D0 (7), Bit 0 = B1D00. B1D0 (7), Value on POR, BOR = xxxx xxxx. B1D0 (7), Details on page: = 46, 230. B1DLC (7), Bit 7 = -. B1DLC (7), Bit 6 = RXRTR. B1DLC (7), Bit 5 = RB1. B1DLC (7), Bit 4 = RB0. B1DLC (7), Bit 3 = DLC3. B1DLC",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n(7), Bit 2 = DLC2. B1DLC (7), Bit 1 = DLC1. B1DLC (7), Bit 0 = DLC0. B1DLC (7), Value on POR, BOR = -xxx xxxx. B1DLC (7), Details on page: = 46, 230. B1EIDL (7), Bit 7 = EID7. B1EIDL (7), Bit 6 = EID6. B1EIDL (7), Bit 5 = EID5. B1EIDL (7), Bit 4 = EID4. B1EIDL (7), Bit 3 = EID3. B1EIDL (7), Bit 2 = EID2. B1EIDL (7), Bit 1 = EID1. B1EIDL (7), Bit 0 = EID0. B1EIDL (7), Value on POR, BOR = xxxx xxxx. B1EIDL (7), Details on page: = 46, 230. B1EIDH (7), Bit 7 = EID15. B1EIDH (7), Bit 6",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n= EID14. B1EIDH (7), Bit 5 = EID13. B1EIDH (7), Bit 4 = EID12. B1EIDH (7), Bit 3 = EID11. B1EIDH (7), Bit 2 = EID10. B1EIDH (7), Bit 1 = EID9. B1EIDH (7), Bit 0 = EID8. B1EIDH (7), Value on POR, BOR = xxxx xxxx. B1EIDH (7), Details on page: = 46, 230. B1SIDL (7), Bit 7 = SID2. B1SIDL (7), Bit 6 = SID1. B1SIDL (7), Bit 5 = SID0. B1SIDL (7), Bit 4 = SRR. B1SIDL (7), Bit 3 = EXID. B1SIDL (7), Bit 2 = -. B1SIDL (7), Bit 1 = EID17. B1SIDL (7), Bit 0 = EID16. B1SIDL (7), Value on POR, BOR = xxxx",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nx-xx. B1SIDL (7), Details on page: = 46, 230. B1SIDH (7), Bit 7 = SID10. B1SIDH (7), Bit 6 = SID9. B1SIDH (7), Bit 5 = SID8. B1SIDH (7), Bit 4 = SID7. B1SIDH (7), Bit 3 = SID6. B1SIDH (7), Bit 2 = SID5. B1SIDH (7), Bit 1 = SID4. B1SIDH (7), Bit 0 = SID3. B1SIDH (7), Value on POR, BOR = xxxx xxxx. B1SIDH (7), Details on page: = 46, 230. B1CON (5, 7), Bit 7 = RXFUL/ TXBIF. B1CON (5, 7), Bit 6 = RXM1/ TXABT. B1CON (5, 7), Bit 5 = RTRRO/ TXLARB. B1CON (5, 7), Bit 4 = FILHIT4/ TXERR. B1CON (5, 7), Bit",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n3 = FILHIT3/ TXREQ. B1CON (5, 7), Bit 2 = FILHIT2/ RTREN. B1CON (5, 7), Bit 1 = FILHIT1/ TXPRI1. B1CON (5, 7), Bit 0 = FILHIT0/ TXPRI0. B1CON (5, 7), Value on POR, BOR = 0000 0000. B1CON (5, 7), Details on page: = 46, 230. B0D7 (7), Bit 7 = B0D77. B0D7 (7), Bit 6 = B0D76. B0D7 (7), Bit 5 = B0D75. B0D7 (7), Bit 4 = B0D74. B0D7 (7), Bit 3 = B0D73. B0D7 (7), Bit 2 = B0D72. B0D7 (7), Bit 1 = B0D71. B0D7 (7), Bit 0 = B0D70.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nB0D7 (7), Value on POR, BOR = xxxx xxxx. B0D7 (7), Details on page: = 46, 230. B0D6 (7), Bit 7 = B0D67. B0D6 (7), Bit 6 = B0D66. B0D6 (7), Bit 5 = B0D65. B0D6 (7), Bit 4 = B0D64. B0D6 (7), Bit 3 = B0D63. B0D6 (7), Bit 2 = B0D62. B0D6 (7), Bit 1 = B0D61. B0D6 (7), Bit 0 = B0D60. B0D6 (7), Value on POR, BOR = xxxx xxxx. B0D6 (7), Details on page: = 46, 230. B0D5 (7), Bit 7 = B0D57. B0D5 (7), Bit 6 = B0D56. B0D5",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n(7), Bit 5 = B0D55. B0D5 (7), Bit 4 = B0D54. B0D5 (7), Bit 3 = B0D53. B0D5 (7), Bit 2 = B0D52. B0D5 (7), Bit 1 = B0D51. B0D5 (7), Bit 0 = B0D50. B0D5 (7), Value on POR, BOR = xxxx xxxx. B0D5 (7), Details on page: = 46, 230. B0D4 (7), Bit 7 = B0D47. B0D4 (7), Bit 6 = B0D46. B0D4 (7), Bit 5 = B0D45. B0D4 (7), Bit 4 = B0D44. B0D4 (7), Bit 3 = B0D43. B0D4 (7), Bit 2 = B0D42. B0D4 (7), Bit 1 = B0D41. B0D4",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n(7), Bit 0 = B0D40. B0D4 (7), Value on POR, BOR = xxxx xxxx. B0D4 (7), Details on page: = 46, 230. B0D3 (7), Bit 7 = B0D37. B0D3 (7), Bit 6 = B0D36. B0D3 (7), Bit 5 = B0D35. B0D3 (7), Bit 4 = B0D34. B0D3 (7), Bit 3 = B0D33. B0D3 (7), Bit 2 = B0D32. B0D3 (7), Bit 1 = B0D31. B0D3 (7), Bit 0 = B0D30. B0D3 (7), Value on POR, BOR = xxxx xxxx. B0D3 (7), Details on page: = 46, 230. B0D2 (7), Bit 7 = B0D27. B0D2 (7), Bit 6 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nB0D26. B0D2 (7), Bit 5 = B0D25. B0D2 (7), Bit 4 = B0D24. B0D2 (7), Bit 3 = B0D23. B0D2 (7), Bit 2 = B0D22. B0D2 (7), Bit 1 = B0D21. B0D2 (7), Bit 0 = B0D20. B0D2 (7), Value on POR, BOR = xxxx xxxx. B0D2 (7), Details on page: = 46, 230. B0D1 (7), Bit 7 = B0D17. B0D1 (7), Bit 6 = B0D16. B0D1 (7), Bit 5 = B0D15. B0D1 (7), Bit 4 = B0D14. B0D1 (7), Bit 3 = B0D13. B0D1 (7), Bit 2 = B0D12. B0D1 (7), Bit 1 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nB0D11. B0D1 (7), Bit 0 = B0D10. B0D1 (7), Value on POR, BOR = xxxx xxxx. B0D1 (7), Details on page: = 46, 230. B0D0 (7), Bit 7 = B0D07. B0D0 (7), Bit 6 = B0D06. B0D0 (7), Bit 5 = B0D05. B0D0 (7), Bit 4 = B0D04. B0D0 (7), Bit 3 = B0D03. B0D0 (7), Bit 2 = B0D02. B0D0 (7), Bit 1 = B0D01. B0D0 (7), Bit 0 = B0D00. B0D0 (7), Value on POR, BOR = xxxx xxxx. B0D0 (7), Details on page: = 46, 230. B0DLC (7), Bit 7 = -.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nB0DLC (7), Bit 6 = RTR. B0DLC (7), Bit 5 = RB1. B0DLC (7), Bit 4 = RB0. B0DLC (7), Bit 3 = DLC3. B0DLC (7), Bit 2 = DLC2. B0DLC (7), Bit 1 = DLC1. B0DLC (7), Bit 0 = DLC0. B0DLC (7), Value on POR, BOR = -xxx xxxx. B0DLC (7), Details on page: = 46, 230. B0EIDL (7), Bit 7 = EID7. B0EIDL (7), Bit 6 = EID6. B0EIDL (7), Bit 5 = EID5. B0EIDL (7), Bit 4 = EID4. B0EIDL (7), Bit 3 = EID3. B0EIDL (7), Bit 2 = EID2. B0EIDL (7), Bit 1 = EID1.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nB0EIDL (7), Bit 0 = EID0. B0EIDL (7), Value on POR, BOR = xxxx xxxx. B0EIDL (7), Details on page: = 46, 230. B0EIDH (7), Bit 7 = EID15. B0EIDH (7), Bit 6 = EID14. B0EIDH (7), Bit 5 = EID13. B0EIDH (7), Bit 4 = EID12. B0EIDH (7), Bit 3 = EID11. B0EIDH (7), Bit 2 = EID10. B0EIDH (7), Bit 1 = EID9. B0EIDH (7), Bit 0 = EID8. B0EIDH (7), Value on POR, BOR = xxxx xxxx. B0EIDH (7), Details on page: = 46, 230. B0SIDL (7), Bit 7 = SID2. B0SIDL (7), Bit 6 = SID1. B0SIDL (7),",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nBit 5 = SID0. B0SIDL (7), Bit 4 = SRR. B0SIDL (7), Bit 3 = EXID. B0SIDL (7), Bit 2 = -. B0SIDL (7), Bit 1 = EID17. B0SIDL (7), Bit 0 = EID16. B0SIDL (7), Value on POR, BOR = xxxx x-xx. B0SIDL (7), Details on page: = 46, 230. B0SIDH (7), Bit 7 = SID10. B0SIDH (7), Bit 6 = SID9. B0SIDH (7), Bit 5 = SID8. B0SIDH (7), Bit 4 = SID7. B0SIDH (7), Bit 3 = SID6. B0SIDH (7), Bit 2 = SID5. B0SIDH (7), Bit 1 = SID4. B0SIDH (7), Bit 0 = SID3. B0SIDH (7), Value on POR, BOR = xxxx",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nxxxx. B0SIDH (7), Details on page: = 46, 230. B0CON (5, 7), Bit 7 = RXFUL/ TXBIF. B0CON (5, 7), Bit 6 = RXM1/ TXABT. B0CON (5, 7), Bit 5 = RTRRO/ TXLARB. B0CON (5, 7), Bit 4 = FILHIT4/ TXERR. B0CON (5, 7), Bit 3 = FILHIT3/ TXREQ. B0CON (5, 7), Bit 2 = FILHIT2/ RTREN. B0CON (5, 7), Bit 1 = FILHIT1/ TXPRI1. B0CON (5, 7), Bit 0 = FILHIT0/ TXPRI0. B0CON (5, 7), Value on POR, BOR = 0000 0000. B0CON (5, 7), Details on page: = 46, 230. TXBIE (7), Bit 7 = -. TXBIE (7), Bit 6 =",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n-. TXBIE (7), Bit 5 = -. TXBIE (7), Bit 4 = TXB2IE. TXBIE (7), Bit 3 = TXB1IE. TXBIE (7), Bit 2 = TXB0IE. TXBIE (7), Bit 1 = -. TXBIE (7), Bit 0 = -. TXBIE (7), Value on POR, BOR = ---0 00--. TXBIE (7), Details on page: = 46, 230. BIE0 (7), Bit 7 = B5IE. BIE0 (7), Bit 6 = B4IE. BIE0 (7), Bit 5 = B3IE. BIE0 (7), Bit 4 = B2IE. BIE0 (7), Bit 3 = B1IE. BIE0 (7), Bit 2 = B0IE. BIE0 (7), Bit 1 = RXB1IE. BIE0 (7), Bit 0 = RXB0IE. BIE0 (7), Value on POR, BOR = 0000",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n0000. BIE0 (7), Details on page: = 46, 230. BSEL0 (7), Bit 7 = B5TXEN. BSEL0 (7), Bit 6 = B4TXEN. BSEL0 (7), Bit 5 = B3TXEN. BSEL0 (7), Bit 4 = B2TXEN. BSEL0 (7), Bit 3 = B1TXEN. BSEL0 (7), Bit 2 = B0TXEN. BSEL0 (7), Bit 1 = -. BSEL0 (7), Bit 0 = -. BSEL0 (7), Value on POR, BOR = 0000 00--. BSEL0 (7), Details on page: = 46, 230. MSEL3 (7), Bit 7 = FIL15_1. MSEL3 (7), Bit 6 = FIL15_0. MSEL3 (7), Bit 5 = FIL14_1. MSEL3 (7), Bit 4 = FIL14_0. MSEL3 (7),",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nBit 3 = FIL13_1. MSEL3 (7), Bit 2 = FIL13_0. MSEL3 (7), Bit 1 = FIL12_1. MSEL3 (7), Bit 0 = FIL12_0. MSEL3 (7), Value on POR, BOR = 0000 0000. MSEL3 (7), Details on page: = 46, 230. MSEL2 (7), Bit 7 = FIL11_1. MSEL2 (7), Bit 6 = FIL11_0. MSEL2 (7), Bit 5 = FIL10_1. MSEL2 (7), Bit 4 = FIL10_0. MSEL2 (7), Bit 3 = FIL9_1. MSEL2 (7), Bit 2 = FIL9_0. MSEL2 (7), Bit 1 = FIL8_1. MSEL2 (7), Bit 0 = FIL8_0. MSEL2 (7), Value on POR, BOR = 0000 0000. MSEL2",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n(7), Details on page: = 46, 230. MSEL1 (7), Bit 7 = FIL7_1. MSEL1 (7), Bit 6 = FIL7_0. MSEL1 (7), Bit 5 = FIL6_1. MSEL1 (7), Bit 4 = FIL6_0. MSEL1 (7), Bit 3 = FIL5_1. MSEL1 (7), Bit 2 = FIL5_0. MSEL1 (7), Bit 1 = FIL4_1. MSEL1 (7), Bit 0 = FIL4_0. MSEL1 (7), Value on POR, BOR = 0000 0101. MSEL1 (7), Details on page: = 46, 230. MSEL0 (7), Bit 7 = FIL3_1. MSEL0 (7), Bit 6 = FIL3_0. MSEL0 (7), Bit 5 = FIL2_1. MSEL0 (7), Bit 4 = FIL2_0. MSEL0",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n(7), Bit 3 = FIL1_1. MSEL0 (7), Bit 2 = FIL1_0. MSEL0 (7), Bit 1 = FIL0_1. MSEL0 (7), Bit 0 = FIL0_0. MSEL0 (7), Value on POR, BOR = 0101 0000. MSEL0 (7), Details on page: = 46, 230. SDFLC (7), Bit 7 = -. SDFLC (7), Bit 6 = -. SDFLC (7), Bit 5 = -. SDFLC (7), Bit 4 = DFLC4. SDFLC (7), Bit 3 = DFLC3. SDFLC (7), Bit 2 = DFLC2. SDFLC (7), Bit 1 = DFLC1. SDFLC (7), Bit 0 = DFLC0. SDFLC (7), Value on POR, BOR = ---0 0000. SDFLC (7), Details on page: = 46, 230.",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\nRXFCON1 (7), Bit 7 = RXF15EN. RXFCON1 (7), Bit 6 = RXF14EN. RXFCON1 (7), Bit 5 = RXF13EN. RXFCON1 (7), Bit 4 = RXF12EN. RXFCON1 (7), Bit 3 = RXF11EN. RXFCON1 (7), Bit 2 = RXF10EN. RXFCON1 (7), Bit 1 = RXF9EN. RXFCON1 (7), Bit 0 = RXF8EN. RXFCON1 (7), Value on POR, BOR = 0000 0000. RXFCON1 (7), Details on page: = 46, 230. RXFCON0 (7), Bit 7 = RXF7EN. RXFCON0 (7), Bit 6 = RXF6EN. RXFCON0 (7), Bit 5 = RXF5EN. RXFCON0",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n(7), Bit 4 = RXF4EN. RXFCON0 (7), Bit 3 = RXF3EN. RXFCON0 (7), Bit 2 = RXF2EN. RXFCON0 (7), Bit 1 = RXF1EN. RXFCON0 (7), Bit 0 = RXF0EN. RXFCON0 (7), Value on POR, BOR = 0011 1111. RXFCON0 (7), Details on page: = 47, 230\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote",
    "TABLE 4-3: REGISTER FILE SUMMARY (CONTINUED)\n1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6X80 devices; always maintain these clear.\n4: These bits have multiple functions depending on the CAN module mode selection.\n5: Meaning of this register depends on whether this buffer is configured as transmit or receive.\n6: RG5 is available as an input when MCLR is disabled.\n7: This register reads all ' 0 's until the ECAN module is set up in Mode 1 or Mode 2.",
    "REGISTER FILE SUMMARY (CONTINUED)\nRXFBCON7 (7), Bit 7 = F15BP_3. RXFBCON7 (7), Bit 6 = F15BP_2. RXFBCON7 (7), Bit 5 = F15BP_1. RXFBCON7 (7), Bit 4 = F15BP_0. RXFBCON7 (7), Bit 3 = F14BP_3. RXFBCON7 (7), Bit 2 = F14BP_2. RXFBCON7 (7), Bit 1 = F14BP_1. RXFBCON7 (7), Bit 0 = F14BP_01. RXFBCON7 (7), Value on POR, BOR = 0000 0000. RXFBCON7 (7), Details on page: = 47, 230. RXFBCON6 (7), Bit 7 = F13BP_3. RXFBCON6 (7), Bit 6 = F13BP_2. RXFBCON6 (7), Bit 5 = F13BP_1.",
    "REGISTER FILE SUMMARY (CONTINUED)\nRXFBCON6 (7), Bit 4 = F13BP_0. RXFBCON6 (7), Bit 3 = F12BP_3. RXFBCON6 (7), Bit 2 = F12BP_2. RXFBCON6 (7), Bit 1 = F12BP_1. RXFBCON6 (7), Bit 0 = F12BP_01. RXFBCON6 (7), Value on POR, BOR = 0000 0000. RXFBCON6 (7), Details on page: = 47, 230. RXFBCON5 (7), Bit 7 = F11BP_3. RXFBCON5 (7), Bit 6 = F11BP_2. RXFBCON5 (7), Bit 5 = F11BP_1. RXFBCON5 (7), Bit 4 = F11BP_0. RXFBCON5 (7), Bit 3 = F10BP_3. RXFBCON5 (7), Bit 2 = F10BP_2.",
    "REGISTER FILE SUMMARY (CONTINUED)\nRXFBCON5 (7), Bit 1 = F10BP_1. RXFBCON5 (7), Bit 0 = F10BP_01. RXFBCON5 (7), Value on POR, BOR = 0000 0000. RXFBCON5 (7), Details on page: = 47, 230. RXFBCON4 (7), Bit 7 = F9BP_3. RXFBCON4 (7), Bit 6 = F9BP_2. RXFBCON4 (7), Bit 5 = F9BP_1. RXFBCON4 (7), Bit 4 = F9BP_0. RXFBCON4 (7), Bit 3 = F8BP_3. RXFBCON4 (7), Bit 2 = F8BP_2. RXFBCON4 (7), Bit 1 = F8BP_1. RXFBCON4 (7), Bit 0 = F8BP_01. RXFBCON4 (7), Value on POR, BOR = 0000 0000.",
    "REGISTER FILE SUMMARY (CONTINUED)\nRXFBCON4 (7), Details on page: = 47, 230. RXFBCON3 (7), Bit 7 = F7BP_3. RXFBCON3 (7), Bit 6 = F7BP_2. RXFBCON3 (7), Bit 5 = F7BP_1. RXFBCON3 (7), Bit 4 = F7BP_0. RXFBCON3 (7), Bit 3 = F6BP_3. RXFBCON3 (7), Bit 2 = F6BP_2. RXFBCON3 (7), Bit 1 = F6BP_1. RXFBCON3 (7), Bit 0 = F6BP_01. RXFBCON3 (7), Value on POR, BOR = 0000 0000. RXFBCON3 (7), Details on page: = 47, 230. RXFBCON2 (7), Bit 7 = F5BP_3. RXFBCON2 (7), Bit 6 = F5BP_2.",
    "REGISTER FILE SUMMARY (CONTINUED)\nRXFBCON2 (7), Bit 5 = F5BP_1. RXFBCON2 (7), Bit 4 = F5BP_0. RXFBCON2 (7), Bit 3 = F4BP_3. RXFBCON2 (7), Bit 2 = F4BP_2. RXFBCON2 (7), Bit 1 = F4BP_1. RXFBCON2 (7), Bit 0 = F4BP_01. RXFBCON2 (7), Value on POR, BOR = 0000 0000. RXFBCON2 (7), Details on page: = 47, 230. RXFBCON1 (7), Bit 7 = F3BP_3. RXFBCON1 (7), Bit 6 = F3BP_2. RXFBCON1 (7), Bit 5 = F3BP_1. RXFBCON1 (7), Bit 4 = F3BP_0. RXFBCON1 (7), Bit 3 = F2BP_3.",
    "REGISTER FILE SUMMARY (CONTINUED)\nRXFBCON1 (7), Bit 2 = F2BP_2. RXFBCON1 (7), Bit 1 = F2BP_1. RXFBCON1 (7), Bit 0 = F2BP_01. RXFBCON1 (7), Value on POR, BOR = 0000 0000. RXFBCON1 (7), Details on page: = 47, 230. RXFBCON0 (7), Bit 7 = F1BP_3. RXFBCON0 (7), Bit 6 = F1BP_2. RXFBCON0 (7), Bit 5 = F1BP_1. RXFBCON0 (7), Bit 4 = F1BP_0. RXFBCON0 (7), Bit 3 = F0BP_3. RXFBCON0 (7), Bit 2 = F0BP_2. RXFBCON0 (7), Bit 1 = F0BP_1. RXFBCON0 (7), Bit 0 = F0BP_01. RXFBCON0",
    "REGISTER FILE SUMMARY (CONTINUED)\n(7), Value on POR, BOR = 0000 0000. RXFBCON0 (7), Details on page: = 47, 230\nLegend:\n- x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote\n1: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: These registers are unused on PIC18F6X80 devices; always maintain these clear.\n4: These bits have multiple functions depending on the CAN module mode selection.\n5: Meaning of this register depends on whether this buffer is configured as transmit or receive.\n6: RG5 is available as an input when MCLR is disabled.\n7: This register reads all ' 0 's until the ECAN module is set up in Mode 1 or Mode 2.",
    "4.11 Bank Select Register (BSR)\nThe  Access  Bank  is  an  architectural  enhancement which is very useful for C compiler code optimization. The techniques used by the C compiler may also be useful for programs written in assembly.\nThis data memory region can be used for:\n\u00b7 Intermediate computational values\n\u00b7 Local variables of subroutines\n\u00b7 Faster context saving/switching of variables\n\u00b7 Common variables\n\u00b7 Faster evaluation/control of SFRs (no banking)\nThe Access Bank is comprised of the upper 160 bytes in Bank 15 (SFRs) and the lower 96 bytes in Bank 0. These two sections will be referred to as Access RAM High  and  Access  RAM  Low,  respectively.  Figure 4-7 indicates the Access RAM areas.\nA bit in the instruction word specifies if the operation is to occur in the bank specified by the BSR register or in the Access Bank. This bit is denoted by the 'a' bit (for access bit).\nWhen  forced  in  the  Access  Bank  (a  = 0 ),  the  last address  in  Access  RAM  Low  is  followed  by  the  first address in Access RAM High. Access RAM High maps the Special Function Registers so that these registers can be accessed without any software overhead. This is useful for testing status flags and modifying control bits.",
    "4.11 Bank Select Register (BSR)\nThe need for a large general purpose memory space dictates a RAM banking scheme. The data memory is partitioned into sixteen  banks.  When  using  direct addressing,  the  BSR  should  be  configured  for  the desired bank.\nBSR<3:0> holds  the  upper  4  bits  of  the  12-bit  RAM address. The BSR<7:4> bits will always read ' 0 's and writes will have no effect.\nA MOVLB instruction has been provided in the instruction set to assist in selecting banks.\nIf the currently selected bank is not implemented, any read will return all ' 0 's and all writes are ignored. The Status register bits will be set/cleared as appropriate for the instruction performed.\nEach Bank extends up to 0FFh (256 bytes). All data memory is implemented as static RAM.\nA MOVFF instruction ignores the BSR since the 12-bit addresses are embedded into the instruction word.\nSection 4.12  'Indirect  Addressing,  INDF and  FSR Registers' provides a description of indirect addressing which allows linear addressing of the entire RAM space.",
    "4.12 Indirect Addressing, INDF and FSR Registers\nIndirect addressing is a mode of addressing data memory where the data memory address in the instruction is not fixed. An FSR register is used as a pointer to the data memory location that is to be read or written. Since this pointer is in RAM, the contents can be modified by the program. This can be useful for data tables in the data  memory  and  for  software  stacks.  Figure 4-9 shows the operation of indirect addressing. This shows the moving of the value to the data memory address specified by the value of the FSR register.\nIndirect  addressing  is  possible  by  using  one  of  the INDF registers. Any instruction using the INDF register actually  accesses  the  register  pointed  to  by  the  File Select Register, FSR. Reading the INDF register itself, indirectly (FSR = 0 ), will read 00h. Writing to the INDF register indirectly, results in a no operation. The FSR register  contains  a  12-bit  address  which  is  shown  in Figure 4-10.\nThe INDFn register is not a physical register. Addressing INDFn  actually  addresses  the  register  whose address is contained in the FSRn register (FSRn is a pointer). This is indirect addressing.",
    "4.12 Indirect Addressing, INDF and FSR Registers\nExample 4-4 shows a simple use of indirect addressing to clear the RAM in Bank 1 (locations 100h-1FFh) in a minimum number of instructions.",
    "EXAMPLE 4-4: HOW TO CLEAR RAM (BANK 1) USING INDIRECT ADDRESSING\nNEXT, 1 = LFSR CLRF. NEXT, 2 = FSR0, 100h POSTINC0. NEXT, 3 = ; ; Clear INDF ; register and ; inc pointer. , 1 = BTFSS. , 2 = FSR0H, 1. , 3 = ; All done with ; Bank1?. , 1 = BRA. , 2 = NEXT. , 3 = ; NO, clear next ; YES, continue. CONTINUE, 1 = CONTINUE. CONTINUE, 2 = CONTINUE. CONTINUE, 3 = \nThere  are  three  Indirect Addressing  registers. To address the entire data memory space (4096 bytes), these registers are 12-bits wide. To store the 12 bits of addressing information, two 8-bit registers are required. These Indirect Addressing registers are:\n1. FSR0: composed of FSR0H:FSR0L\n2. FSR1: composed of FSR1H:FSR1L\n3. FSR2: composed of FSR2H:FSR2L",
    "EXAMPLE 4-4: HOW TO CLEAR RAM (BANK 1) USING INDIRECT ADDRESSING\nIn  addition,  there  are  registers  INDF0,  INDF1  and INDF2 which are not physically implemented. Reading or writing to these registers activates indirect addressing  with  the  value  in  the  corresponding  FSR  register being the address of the data. If an instruction writes a value to INDF0, the value will be written to the address pointed to by FSR0H:FSR0L. A read from INDF1 reads the data from the address pointed to by FSR1H:FSR1L. INDFn can be used in code anywhere an operand can be used.\nIf  INDF0, INDF1, or INDF2 are read indirectly via an FSR,  all  ' 0 's  are  read  (zero  bit  is  set).  Similarly,  if INDF0, INDF1, or INDF2 are written to indirectly, the operation will be equivalent to a NOP instruction and the Status bits are not affected.",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nEach  FSR  register  has  an  INDF  register  associated with it plus four additional register addresses. Performing an operation on one of these five registers determines  how  the  FSR  will  be  modified  during indirect addressing.\nWhen data access is done to one of the five INDFn locations, the address selected will configure the FSRn register to:\n\u00b7 Do nothing to FSRn after an indirect access (no change) - INDFn.\n\u00b7 Auto-decrement FSRn after an indirect access (post-decrement) - POSTDECn.\n\u00b7 Auto-increment FSRn after an indirect access (post-increment) - POSTINCn.\n\u00b7 Auto-increment FSRn before an indirect access (pre-increment) - PREINCn.\n\u00b7 Use the value in the WREG register as an offset to FSRn. Do not modify the value of the WREG or the FSRn register after an indirect access (no change) - PLUSWn.",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nWhen using the auto-increment or auto-decrement features, the effect on the FSR is not reflected in the Status register. For example, if the indirect address causes the FSR to equal ' 0 ', the Z bit will not be set.\nIncrementing  or  decrementing  an  FSR  affects  all 12 bits. That  is, when  FSRnL  overflows  from  an increment, FSRnH will be incremented automatically.\nAdding these features allows the FSRn to be used as a stack pointer in addition to its uses for table operations in data memory.\nEach  FSR  has  an  address  associated  with  it  that performs  an  indexed  indirect  access.  When  a  data access to this INDFn location (PLUSWn) occurs, the FSRn  is  configured  to  add  the  signed  value  in  the WREG  register  and  the  value  in  FSR  to  form  the address before an indirect access. The FSR value is not changed.\nIf an FSR register contains a value that points to one of the INDFn, an indirect read will read 00h (zero bit is set), while an indirect write will be equivalent to a NOP (Status bits are not affected).",
    "PIC18F6585/8585/6680/8680\nIf  an indirect addressing operation is done where the target  address  is  an  FSRnH  or  FSRnL  register,  the write operation will dominate over the preor post-increment/decrement functions.",
    "4.13 Status Register\nThe Status register, shown in Register 4-3, contains the arithmetic status of the ALU. The Status register can be the destination for any instruction as with any other register.  If  the  Status  register  is  the  destination  for  an instruction that affects the Z, DC, C, OV or N bits, then the write to these five bits is disabled. These bits are set or cleared according to the device logic. Therefore, the result  of  an  instruction  with  the  Status  register  as destination may be different than intended.\nFor example, CLRF STATUS will clear the upper three bits and set the Z bit.   This leaves the Status register as 000u u1uu (where u = unchanged).\nIt  is  recommended,  therefore,  that  only BCF,  BSF, SWAPF,  MOVFF and MOVWF instructions are used to alter the Status register because these instructions do not affect the Z, C, DC, OV or N bits from the Status register. For other instructions not affecting any status bits, see Table 25-2.\nNote:\nThe C and DC bits operate as a borrow and digit borrow bit respectively, in subtraction.",
    "REGISTER 4-3: STATUS REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-x. U-0, 4 = R/W-x. U-0, 5 = R/W-x. U-0, 6 = R/W-x. U-0, 7 = R/W-x. -, 1 = -. -, 2 = -. -, 3 = N. -, 4 = OV. -, 5 = Z. -, 6 = DC. -, 7 = C\nbit 7\nbit 0",
    "bit 4 N: Negative bit\nThis bit is used for signed arithmetic (2's complement). It indicates whether the result was negative (ALU MSB = 1 ).\n1 = Result was negative\n0 = Result was positive",
    "bit 3 OV: Overflow bit\nThis bit is used for signed arithmetic (2's complement). It indicates an overflow of the 7-bit magnitude which causes the sign bit (bit 7) to change state.\n1 = Overflow occurred for signed arithmetic (in this arithmetic operation)\n0 = No overflow occurred",
    "bit 2 Z: Zero bit\n1 = The result of an arithmetic or logic operation is zero\n0 = The result of an arithmetic or logic operation is not zero",
    "bit 1\nDC: Digit carry/borrow bit\nFor ADDWF, ADDLW, SUBLW , and SUBWF instructions:\n1 = A carry-out from the 4th low order bit of the result occurred\n0 = No carry-out from the 4th low order bit of the result\nNote:\nFor  borrow,  the  polarity  is  reversed.  A  subtraction  is  executed  by  adding  the 2's complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either the bit 4 or bit 3 of the source register.",
    "bit 0 C: Carry/borrow bit\nFor ADDWF, ADDLW, SUBLW , and SUBWF instructions:\n1 = A carry-out from the Most Significant bit of the result occurred\n0 = No carry-out from the Most Significant bit of the result occurred\nNote:\nFor  borrow,  the  polarity  is  reversed.  A  subtraction  is  executed  by  adding  the 2's complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either the high or low-order bit of the source register.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "4.14 RCON Register\n- Note 1: It is recommended that the POR bit be set\nThe Reset Control (RCON) register contains flag bits that  allow  differentiation  between  the  sources  of  a device Reset. These flags include the TO, PD, POR, BOR and RI bits. This register is readable and writable.\nafter a Power-on Reset has been detected  so  that  subsequent  Power-on Resets may be detected.\n2: Brown-out Reset is said to have occurred when BOR is ' 0 ' and POR is ' 1 ' (assuming that POR was set to ' 1 '  by  software immediately after POR).",
    "REGISTER 4-4: RCON REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R/W-1. R/W-0, 5 = R/W-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0",
    "bit 7 IPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16CXXX Compatibility mode)",
    "bit 4 RI: RESET Instruction Flag bit\n1 = The RESET instruction was not executed\n0 = The RESET instruction was executed causing a device Reset (must be set in software after a Brown-out Reset occurs)",
    "bit 3 TO: Watchdog Time-out Flag bit\n1 = After power-up, CLRWDT instruction, or SLEEP instruction\n0 = A WDT time-out occurred",
    "bit 2 PD: Power-down Detection Flag bit\n1 = After power-up or by the CLRWDT instruction\n0 = By execution of the SLEEP instruction",
    "bit 1 POR: Power-on Reset Status bit\n1 = A Power-on Reset has not occurred\n0 = A Power-on Reset occurred (must be set in software after a Power-on Reset occurs)",
    "bit 0 BOR: Brown-out Reset Status bit\n1 = A Brown-out Reset has not occurred\n0 = A Brown-out Reset occurred (must be set in software after a Brown-out Reset occurs)",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "5.1 Table Reads and Table Writes\nThe Flash program memory is readable, writable and erasable during normal operation over the entire VDD range.\nA read from program memory is executed on one byte at a time. A write to program memory is executed on blocks of 8 bytes at a time. Program memory is erased in blocks of 64 bytes at a time. A bulk erase operation cannot be issued from user code.\nWriting or erasing program memory will cease instruction fetches until the operation is complete. The program memory cannot be accessed during the write or erase, therefore, code cannot execute. An internal programming timer terminates program memory writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing  a  program  memory location  that  forms  an  invalid  instruction  results  in  a NOP .\nIn order to read and write program memory, there are two operations that allow the processor to move bytes between the program memory space and the data RAM:\n\u00b7 Table Read ( TBLRD )\n\u00b7 Table Write ( TBLWT )\nThe program memory space is 16 bits wide, while the data RAM space is 8-bits wide. Table reads and table writes move data between these two memory spaces through an 8-bit register (TABLAT).",
    "5.1 Table Reads and Table Writes\nTable  read  operations  retrieve  data  from  program memory  and  places  it  into  the  data  RAM  space. Figure 5-1  shows  the  operation  of  a  table  read  with program memory and data RAM.\nTable write operations store data from the data memory space into holding registers in program memory. The procedure to write the contents of the holding registers into program memory is detailed in Section 5.5  'Writing  to  Flash  Program  Memory' . Figure 5-2  shows  the  operation  of  a  table  write  with program memory and data RAM.\nTable operations work with byte entities. A table block containing data, rather than program instructions, is not required to be word aligned. Therefore, a table block can start and end at any byte address. If a table write is being used  to  write  executable  code  into  program  memory, program instructions will need to be word aligned.",
    "PIC18F6585/8585/6680/8680\nFIGURE 5-2:",
    "5.2 Control Registers\nSeveral control registers are used in conjunction with the TBLRD and TBLWT instructions. These include the:\nThe FREE bit, when set, will allow a program memory erase operation. When the FREE bit is set, the erase operation is initiated on the next WR command. When FREE is clear, only writes are enabled.\n\u00b7 EECON1 register\n\u00b7 EECON2 register\n\u00b7 TABLAT register\n\u00b7 TBLPTR registers",
    "5.2.1 EECON1 AND EECON2 REGISTERS\nEECON1 is the control register for memory accesses.\nEECON2 is not a physical register. Reading EECON2 will read  all ' 0 's. The  EECON2  register  is  used exclusively in the memory write and erase sequences.\nControl bit EEPGD determines if the access will be a program  or  data  EEPROM  memory  access.  When clear,  any  subsequent operations  will operate on  the data  EEPROM  memory.  When  set,  any  subsequent operations will operate on the program memory.\nControl bit CFGS determines if the access will be to the configuration/calibration registers or to program memory/data  EEPROM  memory.  When  set,  subsequent operations will operate on configuration registers regardless  of  EEPGD  (see Section 24.0  'Special Features of the CPU' ). When clear, memory selection access is determined by EEPGD.",
    "5.2.1 EECON1 AND EECON2 REGISTERS\nThe WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear. The WRERR bit is set when a write operation is interrupted by a MCLR Reset or a WDT Time-out Reset during normal operation. In these  situations,  the  user  can  check  the WRERR bit and rewrite the location. It is necessary to reload  the  data  and  address  registers  (EEDATA  and EEADR) due to Reset values of zero.\nThe WR control bit initiates  write operations.  The  bit cannot be cleared, only set in software; it is cleared in hardware at the completion of the write operation. The inability  to  clear  the  WR  bit  in  software  prevents  the accidental or premature termination of a write operation.\nNote:, 1 = Interrupt flag bit, EEIF in the PIR2 register, is set when the write is complete. It must be cleared in software.",
    "REGISTER 5-1: EECON1 REGISTER (ADDRESS FA6h)\nR/W-x, 1 = R/W-x. R/W-x, 2 = U-0. R/W-x, 3 = R/W-0. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-0. R/W-x, 6 = R/S-0. R/W-x, 7 = R/S-0. EEPGD, 1 = CFGS. EEPGD, 2 = -. EEPGD, 3 = FREE. EEPGD, 4 = WRERR. EEPGD, 5 = WREN. EEPGD, 6 = WR. EEPGD, 7 = RD\nbit 7\nbit 0",
    "bit 7 EEPGD: Flash Program or Data EEPROM Memory Select bit\n1 = Access Flash program memory\n0 = Access data EEPROM memory",
    "bit 6 CFGS: Flash Program/Data EEPROM or Configuration Select bit\n1 = Access configuration registers\n0 = Access Flash program or data EEPROM memory",
    "bit 4 FREE: Flash Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation)\n0 = Perform write only",
    "bit 3 WRERR: Flash Program/Data EEPROM Error Flag bit\n- 1 = A write operation is prematurely terminated\n(any Reset during self-timed programming in normal operation)\n- 0 = The write operation completed\nNote:\nWhen a WRERR occurs, the EEPGD and CFGS bits are not cleared. This allows tracing of the error condition.",
    "bit 2 WREN: Flash Program/Data EEPROM Write Enable bit\n1 = Allows write cycles\n0 = Inhibits write to the EEPROM",
    "bit 1 WR: Write Control bit\n1 = Initiates  a  data  EEPROM erase/write cycle or a  program memory erase cycle or write cycle.  (The  operation  is  self-timed  and  the  bit  is  cleared  by  hardware  once  write  is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle to the EEPROM is complete",
    "bit 0 RD: Read Control bit\n1 = Initiates an EEPROM read. (Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared) in software. RD bit cannot be set when EEPGD = 1 .)\n0 = Does not initiate an EEPROM read",
    "Legend:\nR = Readable bit\nU = Unimplemented bit, read as '0'\nW = Writable bit\nS = Settable bit\n- n = Value after erase\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "5.2.4 TABLE POINTER BOUNDARIES\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch is used to hold 8bit data during data transfers between program memory and data RAM.",
    "5.2.3 TBLPTR - TABLE POINTER REGISTER\nThe Table Pointer (TBLPTR) addresses a byte within the  program  memory.  The  TBLPTR  is  comprised  of three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL).  These  three  registers  join  to  form  a  22-bit  wide  pointer.  The  low-order 21 bits allow the device to address up to 2 Mbytes of program memory space. The 22nd bit allows access to the device ID, the user ID and the configuration bits.\nTBLPTR  is  used  in  reads,  writes  and  erases  of  the Flash program memory.\nWhen  a TBLRD is  executed,  all  22  bits  of  the  table pointer  determine  which  byte  is  read  from  program memory into TABLAT.",
    "5.2.3 TBLPTR - TABLE POINTER REGISTER\nWhen a TBLWT is executed, the three LSbs of the Table Pointer (TBLPTR<2:0>) determine which of the eight program memory holding registers is written to. When the timed write to program memory (long write) begins, the 19 MSbs of the Table Pointer (TBLPTR<21:3>) will determine which program memory block of 8 bytes is written to. For more detail, see Section 5.5 'Writing to Flash Program Memory' .\nThe Table Pointer, TBLPTR, is used by the TBLRD and TBLWT instructions. These instructions can update the TBLPTR in one of four ways based on the table operation. These operations are shown in Table 5-1. These operations  on  the  TBLPTR  only  affect  the  low-order 21 bits.\nWhen an erase of program memory is executed, the 16 MSbs of the Table Pointer (TBLPTR<21:6>) point to the  64-byte  block  that  will  be  erased.  The  Least Significant bits (TBLPTR<5:0>) are ignored.\nFigure 5-3 describes the relevant boundaries of TBLPTR based on Flash program memory operations.",
    "TABLE 5-1: TABLE POINTER OPERATIONS WITH TBLRD AND TBLWT INSTRUCTIONS\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write",
    "5.3 Reading the Flash Program Memory\nThe TBLRD instruction  is  used  to  retrieve  data  from program memory and places it into data RAM. Table reads from program memory are performed one byte at a time.\nTBLPTR points to a byte address in program space. Executing TBLRD places  the  byte  pointed  to  into TABLAT. In addition, TBLPTR can be modified automatically for the next table read operation.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. Figure 5-4 shows  the  interface  between  the  internal  program memory and the TABLAT.",
    "EXAMPLE 5-1: READING A FLASH PROGRAM MEMORY WORD\n, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF. , 2 = upper(CODE_ADDR) TBLPTRU high(CODE_ADDR) TBLPTRH low(CODE_ADDR_LOW) TBLPTRL. , 3 = ; Load TBLPTR with the base ; address of the word. READ_WORD, 1 = . READ_WORD, 2 = . READ_WORD, 3 = . , 1 = TBLRD*+ MOVF MOVWF TBLRD*+ MOVF MOVWF. , 2 = TABLAT, W LSB. , 3 = ; read into TABLAT and increment ; get data. , 1 = . , 2 = TABLAT, W MSB. , 3 = ; read into TABLAT and increment ; get data",
    "5.4 Erasing Flash Program Memory\nThe minimum erase block is 32 words or 64 bytes. Only through the use of an external programmer or through ICSP control can larger blocks of program memory be bulk  erased.  Word  erase  in  the  Flash  array  is  not supported.\nWhen  initiating  an  erase  sequence  from  the  microcontroller itself, a block of 64 bytes of program memory is erased. The Most Significant 16 bits of the TBLPTR<21:6>  point  to  the block being erased. TBLPTR<5:0> are ignored.\nThe EECON1 register commands the erase operation. The  EEPGD  bit  must  be  set  to  point  to  the  Flash program memory. The WREN bit must be set to enable write operations. The FREE bit is set to select an erase operation.\nFor protection, the write initiate sequence for EECON2 must be used.",
    "5.4.1 FLASH PROGRAM MEMORY ERASE SEQUENCE\nThe sequence of events for erasing a block of internal program memory location is:\n1. Load  table  pointer  with  address  of  row  being erased.\n2. Set the EECON1 register for the erase operation:\n\u00b7 set EEPGD bit to point to program memory;\n\u00b7 clear the CFGS bit to access program memory;\n\u00b7 set WREN bit to enable writes;\n\u00b7 set FREE bit to enable the erase.\n3. Disable interrupts.\n4. Write 55h to EECON2.\n5. Write 0AAh to EECON2.\n6. Set the WR bit.  This  will  begin  the  row  erase cycle.\nA long write is necessary for erasing the internal Flash. Instruction  execution  is  halted  while  in  a  long  write cycle. The long write will be terminated by the internal programming timer.\n7. The  CPU  will  stall  for  duration  of  the  erase (about 2 ms using internal timer).\n8. Execute a NOP .\n9. Re-enable interrupts.",
    "EXAMPLE 5-2: ERASING A FLASH PROGRAM MEMORY ROW\nERASE_ROW, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF. ERASE_ROW, 2 = upper(CODE_ADDR) TBLPTRU high(CODE_ADDR) TBLPTRH low(CODE_ADDR) TBLPTRL. ERASE_ROW, 3 = ; load ; address. Required Sequence, 1 = BSF BCF BSF BSF BCF MOVLW MOVWF MOVLW MOVWF BSF NOP. Required Sequence, 2 = EECON1, EEPGD EECON1, CFGS EECON1, WREN EECON1, FREE INTCON, GIE 55h EECON2 0AAh EECON2 EECON1, WR. Required Sequence, 3 = ; point to Flash program memory ; access Flash program memory ; enable write to memory ; enable Row Erase operation ; disable interrupts ; write 55h ; write 0AAh ; start erase (CPU stall). , 1 = BSF. , 2 = INTCON, GIE. , 3 = ; re-enable interrupts",
    "5.5 Writing to Flash Program Memory\nThe minimum programming block is 4 words or 8 bytes. Word or byte programming is not supported.\nTable  writes  are  used  internally  to  load  the  holding registers needed to program the Flash memory. There are eight holding registers used by the table writes for programming.\nthe holding registers are written. At the end of updating eight registers, the EECON1 register must be written to, to start the programming operation with a long write.\nThe long write is necessary for programming the internal Flash. Instruction execution is halted while in a long write  cycle.  The  long  write  will  be  terminated  by  the internal programming timer.\nSince the Table Latch (TABLAT) is only a single byte, the TBLWT instruction has to be executed 8 times for each  programming  operation.  All  of  the  table  write operations will essentially be short writes because only\nThe  EEPROM  on-chip  timer  controls  the  write  time. The write/erase voltages are generated by an on-chip charge pump, rated to operate over the voltage range of the device for byte or word operations.",
    "5.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\nThe sequence of events for programming an internal program memory location should be:\n1. Read 64 bytes into RAM.\n2. Update data values in RAM as necessary.\n3. Load table pointer with address being erased.\n4. Do the row erase procedure.\n5. Load  table  pointer  with  address  of  first  byte being written.\n6. Write the first 8 bytes into the holding registers with auto-increment.\n7. Set the EECON1 register for the write operation:\n\u00b7 set EEPGD bit to point to program memory;\n\u00b7 clear the CFGS bit to access program memory;\n\u00b7 set WREN to enable byte writes.\n8. Disable interrupts.\n9. Write 55h to EECON2.\n10. Write 0AAh to EECON2.\n11. Set the WR bit. This will begin the write cycle.\n12. The CPU will stall for duration of the write (about 5 ms using internal timer).\n13. Execute a NOP .\n14. Re-enable interrupts.\n15. Repeat steps 6-14 seven times to write 64 bytes.\n16. Verify the memory (table read).",
    "5.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\nThis procedure will require about 40 ms to update one row of 64 bytes of memory. An example of the required code is given in Example 5-3.",
    "Note:\nBefore setting the WR  bit, the Table Pointer  address  needs  to  be  within  the intended address range of the eight bytes in the holding register.",
    "EXAMPLE 5-3: WRITING TO FLASH PROGRAM MEMORY\nREAD_BLOCK MODIFY_WORD, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF TBLRD*+ MOVF MOVWF DECFSZ BRA. READ_BLOCK MODIFY_WORD, 2 = D'64 COUNTER high(BUFFER_ADDR) FSR0H low(BUFFER_ADDR) FSR0L upper(CODE_ADDR) TBLPTRU high(CODE_ADDR) TBLPTRH low(CODE_ADDR) TBLPTRL TABLAT, POSTINC0 COUNTER READ_BLOCK. READ_BLOCK MODIFY_WORD, 3 = ; number of bytes in erase block ; point to buffer ; Load TBLPTR with the base ; address of the memory block ; ; ; ; ;\nEXAMPLE 5-3:",
    "WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\nMOVLW, 1 = upper(CODE_ADDR). MOVLW, 2 = . MOVLW, 3 = ; load TBLPTR with the base. MOVWF, 1 = TBLPTRU. MOVWF, 2 = . MOVWF, 3 = ; address of the memory block. MOVLW, 1 = high(CODE_ADDR). MOVLW, 2 = . MOVLW, 3 = . MOVWF, 1 = TBLPTRH. MOVWF, 2 = . MOVWF, 3 = . MOVLW, 1 = low(CODE_ADDR). MOVLW, 2 = . MOVLW, 3 = . MOVWF, 1 = TBLPTRL. MOVWF, 2 = . MOVWF, 3 = . BSF, 1 = EECON1,. BSF, 2 = EEPGD. BSF, 3 = ; point to Flash program memory. BCF, 1 = EECON1,. BCF, 2 = CFGS. BCF, 3 = ; access Flash",
    "WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\nprogram memory. BSF, 1 = EECON1,. BSF, 2 = WREN. BSF, 3 = ; enable write to memory. BSF, 1 = EECON1,. BSF, 2 = FREE. BSF, 3 = ; enable Row Erase operation. BCF, 1 = INTCON, GIE. BCF, 2 = . BCF, 3 = ; disable interrupts. MOVLW, 1 = 55h. MOVLW, 2 = . MOVLW, 3 = . MOVWF, 1 = EECON2. MOVWF, 2 = . MOVWF, 3 = ; write 55H. , 1 = 0AAh. , 2 = . , 3 = . MOVLW, 1 = . MOVLW, 2 = . MOVLW, 3 = . MOVWF, 1 = EECON2. MOVWF, 2 = . MOVWF, 3 = ; write AAH. BSF, 1 = EECON1,. BSF, 2 = WR. BSF, 3 = ; start erase (CPU stall). BSF, 1",
    "WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\n= INTCON, GIE. BSF, 2 = . BSF, 3 = ; re-enable interrupts. TBLRD*-, 1 = . TBLRD*-, 2 = . TBLRD*-, 3 = ; dummy read decrement. MOVLW, 1 = 8. MOVLW, 2 = . MOVLW, 3 = ; number of write buffer groups of 8 bytes. MOVWF, 1 = COUNTER_HI. MOVWF, 2 = . MOVWF, 3 = . MOVLW, 1 = high(BUFFER_ADDR). MOVLW, 2 = . MOVLW, 3 = ; point to buffer. MOVWF, 1 = FSR0H. MOVWF, 2 = . MOVWF, 3 = . MOVLW, 1 = low(BUFFER_ADDR). MOVLW, 2 = . MOVLW, 3 = . MOVWF, 1 = FSR0L. MOVWF, 2 = . MOVWF, 3 = . MOVLW, 1 =",
    "WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\n8. MOVLW, 2 = . MOVLW, 3 = ; number of bytes in holding register. MOVWF, 1 = COUNTER. MOVWF, 2 = . MOVWF, 3 = . MOVFW, 1 = POSTINC0,. MOVFW, 2 = W. MOVFW, 3 = ; get low byte of buffer data. MOVWF, 1 = TABLAT. MOVWF, 2 = . MOVWF, 3 = ; present data to table latch write. TBLWT+*, 1 = . TBLWT+*, 2 = . TBLWT+*, 3 = ; write data, perform a short ; to internal TBLWT holding register.. DECFSZ, 1 = COUNTER. DECFSZ, 2 = . DECFSZ, 3 = ; loop until buffers are full. BSF, 1 = EECON1,. BSF, 2 = EEPGD. BSF, 3 = ; point to Flash program memory. BCF, 1 = EECON1,. BCF, 2 = CFGS. BCF, 3 = ; access",
    "WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\nFlash program memory. BSF, 1 = EECON1,. BSF, 2 = WREN. BSF, 3 = ; enable write to memory. BCF, 1 = INTCON,. BCF, 2 = . BCF, 3 = ; disable interrupts. MOVLW, 1 = . MOVLW, 2 = GIE. MOVLW, 3 = ; write 55h. MOVWF, 1 = 55h EECON2. MOVWF, 2 = . MOVWF, 3 = . MOVLW, 1 = 0AAh. MOVLW, 2 = . MOVLW, 3 = . MOVWF, 1 = EECON2. MOVWF, 2 = . MOVWF, 3 = ; write 0AAh. BSF NOP, 1 = EECON1,. BSF NOP, 2 = WR. BSF NOP, 3 = start program (CPU stall). BSF, 1 = . BSF, 2 = . BSF, 3 = ;. DECFSZ, 1 = INTCON, GIE. DECFSZ, 2 =",
    "WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\n. DECFSZ, 3 = ; re-enable ; loop until done. BRA, 1 = COUNTER_HI PROGRAM_LOOP. BRA, 2 = . BRA, 3 = . BCF, 1 = EECON1,. BCF, 2 = WREN. BCF, 3 = ; disable write to memory",
    "5.5.2 WRITE VERIFY\nDepending  on  the  application,  good  programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "5.5.3 UNEXPECTED TERMINATION OF WRITE OPERATION\nIf a write is terminated by an unplanned event, such as loss  of  power  or  an  unexpected  Reset,  the  memory location just programmed should be verified and reprogrammed if  needed.  The  WRERR  bit  is  set  when  a write  operation is interrupted by  a  MCLR  Reset  or a WDT Time-out Reset during normal operation. In these situations, users can check the WRERR bit and rewrite the location.",
    "5.5.4 PROTECTION AGAINST SPURIOUS WRITES\nTo  protect  against  spurious  writes  to  Flash  program memory,  the  write  initiate  sequence  must  also  be followed. See Section 24.0 'Special Features of the CPU' for more detail.",
    "5.6 Flash Program Operation During Code Protection\nSee Section 24.0 'Special Features of the CPU' for details on code protection of Flash program memory.",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nTBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit 21. TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on: POR, BOR = --00 0000. TBLPTRU, Value on all other Resets = --00 0000. TBPLTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>).",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nTBPLTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Value on: POR, BOR = 0000 0000. TBPLTRH, Value on all other Resets = 0000 0000. TBLPTRL, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nTable Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<7:0>). TBLPTRL, Value on: POR, BOR = 0000 0000. TBLPTRL, Value on all other Resets = 0000 0000. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on: POR, BOR = 0000 0000. TABLAT, Value on all other Resets = 0000 0000. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INTE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INTF. INTCON, Bit 0 = RBIF. INTCON, Value on: POR, BOR = 0000 0000. INTCON, Value on all other Resets = 0000 0000. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register).",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nEECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Value on: POR, BOR = - -. EECON2, Value on all other Resets = - -. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on: POR, BOR = xx-0 x000. EECON1, Value on all other Resets = uu-0 u000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP.",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nIPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on: POR, BOR = -1-1 1111. IPR2, Value on all other Resets = -1-1 1111. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on: POR, BOR = -0-0 0000. PIR2, Value on all other Resets = -0-0 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit",
    "TABLE 5-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on: POR, BOR = -0-0 0000. PIE2, Value on all other Resets = -0-0 0000\nLegend:\nx = unknown, u = unchanged, r = reserved, - = unimplemented, read as ' 0 '.\nShaded cells are not used during Flash/EEPROM access.",
    "6.0 EXTERNAL MEMORY INTERFACE\nNote:\nThe  external memory  interface  is not implemented on PIC18F6X8X (64/68-pin) devices.\nThe  external  memory  interface  is  a  feature  of  the PIC18F8X8X  devices  that  allows  the  controller  to access  external  memory  devices  (such  as  Flash, EPROM, SRAM, etc.) as program memory.\nThe  physical  implementation  of  the  interface  uses 27 pins. These pins are reserved for external address/ data bus functions; they are multiplexed with I/O port pins on four ports. Three I/O ports are multiplexed with the  address/data  bus,  while  the  fourth  port  is  multiplexed with the bus control signals. The I/O port functions are enabled when the EBDIS bit in the MEMCON register is set (see Register 6-1). A list of the multiplexed  pins  and  their  functions  is  provided  in Table 6-1.",
    "6.0 EXTERNAL MEMORY INTERFACE\nAs  implemented  in  the  PIC18F8X8X  devices,  the interface operates in a similar manner to the external memory interface introduced on PIC18C601/801 microcontrollers.  The  most  notable  difference  is  that the interface on PIC18F8X8X devices only operates in 16-bit modes. The 8-bit mode is not supported.\nFor a more complete discussion of the operating modes that use the external memory interface, refer to Section 4.1.1 'PIC18F8X8X Program Memory Modes' .",
    "6.1 Program Memory Modes and the External Memory Interface\nAs  previously noted, PIC18F8X8X  controllers  are capable of operating in any one of four program memory modes using combinations of on-chip and external program memory. The functions of the multiplexed port pins depend on the program memory mode selected as well as the setting of the EBDIS bit.\nIn Microprocessor Mode , the external bus is always active  and  the  port  pins  have  only  the  external  bus function.\nIn Microcontroller Mode, the bus is not active and the pins  have  their  port  functions  only.  Writes  to  the MEMCOM register are not permitted.\nIn Microprocessor  with  Boot  Block or Extended Microcontroller Mode, the external program memory bus shares I/O port functions on the pins. When the device  is fetching or doing  table  read/table  write operations on the external program memory space, the pins will have the external bus function. If the device is fetching and  accessing internal program  memory locations  only,  the  EBDIS  control  bit  will  change  the pins from external memory to I/O port functions. When EBDIS = 0 , the pins function as the external bus. When EBDIS = 1 , the pins function as I/O ports.",
    "MEMCON REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = U-0. R/W-0, 5 = U-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. EBDIS (1), 1 = -. EBDIS (1), 2 = WAIT1. EBDIS (1), 3 = WAIT0. EBDIS (1), 4 = -. EBDIS (1), 5 = -. EBDIS (1), 6 = WM1. EBDIS (1), 7 = WM0\nbit 7\nbit 0",
    "bit 7 EBDIS : External Bus Disable bit (1)\n1 = External system bus disabled, all external bus drivers are mapped as I/O ports\n0 = External system bus enabled and I/O ports are disabled\nNote 1: This bit is ignored when device is accessing external memory either to fetch an instruction or perform TBLRD/TBLWT .",
    "bit 5-4 WAIT<1:0> : Table Reads and Writes Bus Cycle Wait Count bits\n11 = Table reads and writes will wait 0 TCY\n10 = Table reads and writes will wait 1 TCY\n01 = Table reads and writes will wait 2 TCY\n00 = Table reads and writes will wait 3 TCY",
    "bit 1-0 WM<1:0> : TBLWT Operation with 16-bit Bus bits\n1x = Word Write mode: LSB and MSB word output, WRH active when MSB written\n01 = Byte Select mode: TABLAT data copied on both MS and LS Byte, WRH and (UB or LB) will activate\n00 = Byte Write mode: TABLAT data copied on both MS and LS Byte, WRH or WRL will activate",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nNote:\nThe MEMCON register is held in Reset in Microcontroller mode.",
    "PIC18F6585/8585/6680/8680\nIf  the  device  fetches  or  accesses  external  memory while EBDIS = 1 , the pins will switch to external bus. If the EBDIS bit is set by a program executing from external memory, the action of setting the bit will be delayed until the program branches into the internal memory. At that time, the pins will change from external bus to I/O ports.\nWhen the device is  executing  out  of  internal  memory (with  EBDIS  = 0 )  in  Microprocessor  with  Boot  Block mode or Extended Microcontroller mode, the control signals will be in inactive. They will go to a state where the AD<15:0>, A<19:16> are tri-state; the OE, WRH, WRL, UB and LB signals are ' 1 '; and ALE and BA0 are ' 0 '.",
    "TABLE 6-1: PIC18F8X8X EXTERNAL BUS - I/O PORT FUNCTIONS\nRD0/AD0, Port = PORTD. RD0/AD0, Bit = bit 0. RD0/AD0, Function = Input/Output or System Bus Address bit 0 or Data bit 0. RD1/AD1, Port = PORTD. RD1/AD1, Bit = bit 1. RD1/AD1, Function = Input/Output or System Bus Address bit 1 or Data bit 1. RD2/AD2, Port = PORTD. RD2/AD2, Bit = bit 2. RD2/AD2, Function = Input/Output or System Bus Address bit 2 or Data bit 2. RD3/AD3, Port = PORTD. RD3/AD3, Bit = bit 3. RD3/AD3, Function = Input/Output or System Bus Address bit 3 or Data bit 3. RD4/AD4, Port = PORTD. RD4/AD4, Bit = bit 4. RD4/AD4, Function = Input/Output or System Bus Address bit 4 or Data bit 4. RD5/AD5, Port = PORTD.",
    "TABLE 6-1: PIC18F8X8X EXTERNAL BUS - I/O PORT FUNCTIONS\nRD5/AD5, Bit = bit 5. RD5/AD5, Function = Input/Output or System Bus Address bit 5 or Data bit 5. RD6/AD6, Port = PORTD. RD6/AD6, Bit = bit 6. RD6/AD6, Function = Input/Output or System Bus Address bit 6 or Data bit 6. RD7/AD7, Port = PORTD. RD7/AD7, Bit = bit 7. RD7/AD7, Function = Input/Output or System Bus Address bit 7 or Data bit 7. RE0/AD8, Port = PORTE. RE0/AD8, Bit = bit 0. RE0/AD8, Function = Input/Output or System Bus Address bit 8 or Data bit 8. RE1/AD9, Port = PORTE. RE1/AD9, Bit = bit 1. RE1/AD9, Function = Input/Output or System Bus Address bit 9 or Data bit 9. RE2/AD10, Port = PORTE. RE2/AD10, Bit = bit 2. RE2/AD10, Function =",
    "TABLE 6-1: PIC18F8X8X EXTERNAL BUS - I/O PORT FUNCTIONS\nInput/Output or System Bus Address bit 10 or Data bit 10. RE3/AD11, Port = PORTE. RE3/AD11, Bit = bit 3. RE3/AD11, Function = Input/Output or System Bus Address bit 11 or Data bit 11. RE4/AD12, Port = PORTE. RE4/AD12, Bit = bit 4. RE4/AD12, Function = Input/Output or System Bus Address bit 12 or Data bit 12. RE5/AD13, Port = PORTE. RE5/AD13, Bit = bit 5. RE5/AD13, Function = Input/Output or System Bus Address bit 13 or Data bit 13. RE6/AD14, Port = PORTE. RE6/AD14, Bit = bit 6. RE6/AD14, Function = Input/Output or System Bus Address bit 14 or Data bit 14. RE7/AD15, Port = PORTE. RE7/AD15, Bit = bit 7. RE7/AD15, Function = Input/Output or System Bus Address bit 15 or Data bit 15. RH0/A16,",
    "TABLE 6-1: PIC18F8X8X EXTERNAL BUS - I/O PORT FUNCTIONS\nPort = PORTH. RH0/A16, Bit = bit 0. RH0/A16, Function = Input/Output or System Bus Address bit 16. RH1/A17, Port = PORTH. RH1/A17, Bit = bit 1. RH1/A17, Function = Input/Output or System Bus Address bit 17. RH2/A18, Port = PORTH. RH2/A18, Bit = bit 2. RH2/A18, Function = Input/Output or System Bus Address bit 18. RH3/A19, Port = PORTH. RH3/A19, Bit = bit 3. RH3/A19, Function = Input/Output or System Bus Address bit 19. RJ0/ALE, Port = PORTJ. RJ0/ALE, Bit = bit 0. RJ0/ALE, Function = Input/Output or System Bus Address Latch Enable (ALE) Control pin. RJ1/OE, Port = PORTJ. RJ1/OE, Bit = bit 1.",
    "TABLE 6-1: PIC18F8X8X EXTERNAL BUS - I/O PORT FUNCTIONS\nRJ1/OE, Function = Input/Output or System Bus Output Enable (OE) Control pin. RJ2/WRL, Port = PORTJ. RJ2/WRL, Bit = bit 2. RJ2/WRL, Function = Input/Output or System Bus Write Low (WRL) Control pin. RJ3/WRH, Port = PORTJ. RJ3/WRH, Bit = bit 3. RJ3/WRH, Function = Input/Output or System Bus Write High (WRH) Control pin. RJ4/BA0, Port = PORTJ. RJ4/BA0, Bit = bit 4. RJ4/BA0, Function = Input/Output or System Bus Byte Address bit 0. RJ5/CE, Port = PORTJ. RJ5/CE, Bit = bit 5. RJ5/CE, Function = Input/Output or Chip Enable. RJ6/LB, Port = PORTJ. RJ6/LB, Bit = bit 6. RJ6/LB, Function = Input/Output or System",
    "TABLE 6-1: PIC18F8X8X EXTERNAL BUS - I/O PORT FUNCTIONS\nBus Lower Byte Enable (LB) Control pin. RJ7/UB, Port = PORTJ. RJ7/UB, Bit = bit 7. RJ7/UB, Function = Input/Output or System Bus Upper Byte Enable (UB) Control pin",
    "6.2 16-bit Mode\nThe external memory interface implemented in PIC18F8X8X  devices  operates  only  in  16-bit  mode. The mode selection is not software configurable but is programmed via the configuration bits.\nFor all 16-bit modes, the Address Latch Enable (ALE) pin indicates that the Address bits (A<15:0>) are available on the external memory interface bus. Following the address latch, the Output Enable signal (OE ) will enable both bytes of program memory at once to form a 16-bit instruction word.\nThe WM<1:0> bits in the MEMCON register determine three  types  of  connections  in  16-bit  mode.  They  are referred to as:\n\u00b7 16-bit Byte Write\n\u00b7 16-bit Word Write\n\u00b7 16-bit Byte Select\nIn Byte Select mode, JEDEC standard Flash memories will require BA0 for the byte address line, and one I/O line to select between Byte and Word mode. The other 16-bit modes do not need BA0. JEDEC standard static RAM memories will use the UB or LB signals for byte selection.\nThese three different configurations allow the designer maximum flexibility  in  using  8-bit  and  16-bit  memory devices.",
    "6.2.1 16-BIT BYTE WRITE MODE\nFigure 6-1  shows  an  example  of  16-bit  Byte  Write mode for PIC18F8X8X devices.",
    "6.2.2 16-BIT WORD WRITE MODE\nFigure 6-2  shows  an  example  of  16-bit  Word  Write mode for PIC18F8X8X devices.",
    "6.2.3 16-BIT BYTE SELECT MODE\nFigure 6-3  shows  an  example  of  16-bit  Byte  Select mode for PIC18F8X8X devices.",
    "6.2.4 16-BIT MODE TIMING\nFigure 6-4 shows the 16-bit mode external bus timing for PIC18F8X8X devices.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "7.0 DATA EEPROM MEMORY\nThe data EEPROM is readable and writable during normal  operation  over  the  entire  VDD  range.  The  data memory  is  not  directly  mapped  in  the  register  file space. Instead, it  is  indirectly  addressed  through  the Special Function Registers (SFR).\nThere  are  five  SFRs  used  to  read  and  write  the program and data EEPROM memory. These registers are:\n\u00b7 EECON1\n\u00b7 EECON2\n\u00b7 EEDATA\n\u00b7 EEADR\n\u00b7 EEADRH\nThe EEPROM data memory allows byte read and write. When interfacing to the data memory block, EEDATA holds the 8-bit data for read/write and EEADR holds the address  of  the  EEPROM  location  being  accessed. These devices have 1024 bytes of data EEPROM with an address range from 0h to 3FFh.",
    "7.0 DATA EEPROM MEMORY\nThe  EEPROM data  memory is rated  for  high  erase/ write cycles. A byte write automatically erases the location and writes the new data (erase-before-write). The write time is controlled by an on-chip timer. The write time will vary with voltage and temperature as well as from  chip  to  chip.  Please  refer  to  parameter  D122 (Electrical  Characteristics, Section 27.0  'Electrical Characteristics' ) for exact limits.",
    "7.1 EEADRH:EEADR\nThe  address  register pair, EEADRH:EEADR,  can address  up  to  a  maximum  of  1024  bytes  of  data EEPROM.",
    "7.2 EECON1 and EECON2 Registers\nEECON1 is the control register for EEPROM memory accesses.\nEECON2 is not a physical register. Reading EECON2 will read  all ' 0 's. The  EECON2  register  is  used exclusively in the EEPROM write sequence.\nControl bits RD and WR initiate read and write operations, respectively. These bits cannot be cleared, only set  in  software.  They  are  cleared  in  hardware at  the completion of the read or write operation. The inability to clear the WR bit in software prevents the accidental or premature termination of a write operation.\nThe WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear. The WRERR bit is set when a write operation is interrupted by a MCLR Reset or a WDT Time-out Reset during normal operation. In these  situations,  the  user  can  check  the WRERR bit and rewrite the location. It is necessary to reload  the  data  and  address  registers  (EEDATA  and EEADR)  due  to  the Reset condition forcing the contents of the registers to zero.",
    "Note:\nInterrupt flag bit, EEIF in the PIR2 register, is set when write is complete. It must be cleared in software.",
    "EECON1 REGISTER (ADDRESS FA6h)\nR/W-x, 1 = R/W-x. R/W-x, 2 = U-0. R/W-x, 3 = R/W-0. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-0. R/W-x, 6 = R/S-0. R/W-x, 7 = R/S-0. EEPGD, 1 = CFGS. EEPGD, 2 = -. EEPGD, 3 = FREE. EEPGD, 4 = WRERR. EEPGD, 5 = WREN. EEPGD, 6 = WR. EEPGD, 7 = RD\nbit 7\nbit 0",
    "bit 7 EEPGD: Flash Program or Data EEPROM Memory Select bit\n1 = Access Flash program memory\n0 = Access data EEPROM memory",
    "bit 6 CFGS: Flash Program/Data EE or Configuration Select bit\n1 = Access configuration or calibration registers\n0 = Access Flash program or data EEPROM memory",
    "bit 4 FREE: Flash Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation)\n0 = Perform write only",
    "bit 3 WRERR: Flash Program/Data EE Error Flag bit\n1 = A write operation is prematurely terminated (any MCLR or any WDT Reset during self-timed programming in normal operation)\n0 = The write operation completed\nNote:\nWhen a WRERR occurs, the EEPGD or FREE bits are not cleared. This allows tracing of the error condition.",
    "bit 2 WREN: Flash Program/Data EE Write Enable bit\n1 = Allows write cycles\n0 = Inhibits write to the EEPROM\nWR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle. (The operation is self-timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle to the EEPROM is complete",
    "bit 0 RD: Read Control bit\n1 = Initiates an EEPROM read. (Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared) in software. RD bit cannot be set when EEPGD = 1 .)\n0 = Does not initiate an EEPROM read",
    "Legend:\nR = Readable bit\nU = Unimplemented bit, read as '0'\nW = Writable bit\nS = Settable bit\n- n = Value after erase\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "7.3 Reading the Data EEPROM Memory\nTo read a data memory location, the user must write the address to the EEADR register, clear the EEPGD control bit (EECON1<7>),  clear  the  CFGS  control  bit\n(EECON1<6>) and then set control bit, RD (EECON1<0>). The data is available for the very next instruction cycle; therefore, the EEDATA register can be read by the next instruction. EEDATA will hold this value until another read operation or until it is written to by the user (during a write operation).",
    "EXAMPLE 7-1: DATA EEPROM READ\nMOVLW, 1 = DATA_EE_ADR_HI. MOVLW, 2 = ;. MOVWF, 1 = EEADRH. MOVWF, 2 = ;. MOVLW, 1 = DATA_EE_ADDR_LOW. MOVLW, 2 = ;. MOVWF, 1 = EEADR. MOVWF, 2 = ; Data Memory Address to read. BCF, 1 = EECON1, EEPGD. BCF, 2 = ; Point to DATA memory. BCF, 1 = EECON1, CFGS. BCF, 2 = ; Access program Flash or Data EEPROM memory. BSF, 1 = EECON1, RD. BSF, 2 = ; EEPROM Read. MOVF, 1 = EEDATA, W. MOVF, 2 = ; W = EEDATA",
    "7.4 Writing to the Data EEPROM Memory\nTo write an EEPROM data location, the address must first  be  written  to  the  EEADRH:EEADR  register  pair and the data written to the EEDATA register. Then the sequence in Example 7-2 must be followed to initiate the write cycle.\ncution (i.e., runaway programs). The WREN bit should be  kept  clear  at  all  times  except  when  updating  the EEPROM. The WREN bit is not cleared by hardware.\nThe write will not initiate if the above sequence is not exactly followed (write 55h to EECON2, write 0AAh to EECON2, then set WR bit) for each byte. It is strongly recommended that interrupts  be  disabled  during  this code segment.\nAdditionally, the WREN bit in EECON1 must be set to enable  writes.  This  mechanism  prevents  accidental writes to data EEPROM due to unexpected code exe-",
    "7.4 Writing to the Data EEPROM Memory\nAfter  a  write  sequence  has  been  initiated,  EECON1, EEADRH:EEADR and EDATA cannot be modified. The WR  bit  will  be  inhibited  from  being  set  unless  the WREN bit is set. The WREN bit must be set on a previous instruction. Both WR and WREN cannot be set with the same instruction.\nAt  the  completion  of  the  write  cycle,  the  WR  bit  is cleared in hardware and the EEPROM Write Complete Interrupt  Flag  bit  (EEIF)  is  set.  The  user  may  either enable  this  interrupt  or  poll  this  bit.  EEIF  must  be cleared by software.",
    "EXAMPLE 7-2: DATA EEPROM WRITE\n, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF BCF BCF BSF. , 2 = DATA_EE_ADDR_HI EEADRH DATA_EE_ADDR_LOW EEADR DATA_EE_DATA EEDATA EECON1, EEPGD EECON1, CFGS EECON1, WREN. , 3 = ; ; ; ; Data Memory Address ; ; Data Memory Value ; Point to DATA ; Access program ; Enable writes. , 4 = to read to write memory Flash or Data EEPROM memory. Required Sequence, 1 = BCF MOVLW MOVWF MOVLW. Required Sequence, 2 = INTCON, GIE 55h EECON2 0AAh. Required Sequence, 3 = ; ; ; ;. Required Sequence, 4 = Disable interrupts Write 55h. Required Sequence, 1 = MOVWF BSF BSF. Required Sequence, 2 = EECON2 EECON1, WR INTCON, GIE. Required Sequence, 3 = ; ; ;. Required Sequence, 4 = Write 0AAh Set WR bit to begin",
    "EXAMPLE 7-2: DATA EEPROM WRITE\nwrite Enable interrupts. Required Sequence, 1 = . . . BCF. Required Sequence, 2 = EECON1, WREN. Required Sequence, 3 = ; ;. Required Sequence, 4 = user code execution Disable writes on write complete (EEIF set)",
    "7.7 Operation During Code-Protect\nDepending  on  the  application,  good  programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "7.6 Protection Against Spurious Write\nThere are conditions when the device may not want to write to the data EEPROM memory. To protect against spurious EEPROM writes, various mechanisms have been built-in. On power-up, the WREN bit is cleared. Also,  the  Power-up  Timer  (72  ms  duration)  prevents EEPROM write.\nThe write initiate sequence and the WREN bit together help  prevent  an  accidental  write  during  brown-out, power glitch, or software malfunction.\nData  EEPROM  memory  has  its  own  code-protect mechanism.  External  read  and  write  operations  are disabled if either of these mechanisms are enabled.\nThe microcontroller itself can both read and write to the internal  data  EEPROM  regardless  of  the  state  of  the code-protect  configuration  bit.  Refer  to Section 24.0 'Special Features of the CPU' for additional information.",
    "7.8 Using the Data EEPROM\nThe data EEPROM is a high endurance, byte addressable array that has been optimized for the storage of frequently  changing  information  (e.g.,  program  variables or other data that are updated often). Frequently changing values will typically  be  updated  more  often than specification D124. If this is not the case, an array refresh must be performed. For this reason, variables that change  infrequently  (such  as  constants,  IDs, calibration,  etc.)  should  be  stored  in  Flash  program memory.\nA  simple  data  EEPROM  refresh  routine  is  shown  in Example 7-3.",
    "Note:\nIf data EEPROM is only used to store con- stants and/or data that changes rarely, an array  refresh  is  likely  not  required.  See specification D124.",
    "EXAMPLE 7-3: DATA EEPROM REFRESH ROUTINE\n, 1 = CLRF CLRF. , 2 = EEADRH. , 3 = ;. , 4 = . , 1 = . , 2 = EEADR. , 3 = ;. , 4 = Start at address 0. , 1 = BCF. , 2 = EECON1, CFGS. , 3 = ;. , 4 = Set for memory. , 1 = BCF. , 2 = EECON1, EEPGD. , 3 = ;. , 4 = Set for Data EEPROM. , 1 = BCF. , 2 = INTCON, GIE. , 3 = ;. , 4 = Disable interrupts. , 1 = BSF. , 2 = EECON1, WREN. , 3 = ;. , 4 = Enable writes. Loop, 1 = . Loop, 2 = . Loop, 3 = . Loop, 4 = ; Loop to refresh array. , 1 = BSF. , 2 = EECON1, RD. , 3 = ;. , 4 = Read current address. , 1 = MOVLW. , 2 = 55h. , 3 = ;. , 4 = . , 1 =",
    "EXAMPLE 7-3: DATA EEPROM REFRESH ROUTINE\nMOVWF. , 2 = EECON2. , 3 = ;. , 4 = Write 55h. , 1 = MOVLW. , 2 = 0AAh. , 3 = ;. , 4 = . , 1 = MOVWF. , 2 = EECON2. , 3 = ;. , 4 = Write 0AAh. , 1 = BSF. , 2 = EECON1, WR. , 3 = ;. , 4 = Set WR bit to begin write. , 1 = BTFSC. , 2 = EECON1, WR. , 3 = ;. , 4 = Wait for write to complete. , 1 = BRA. , 2 = $-2. , 3 = . , 4 = . , 1 = INCFSZ. , 2 = EEADR, F. , 3 = ;. , 4 = Increment address. , 1 = BRA. , 2 = Loop. , 3 = ;. , 4 = Not zero, do it again. , 1 = INCFS2. , 2 = EEADRH, F. , 3 = ;. , 4 = . , 1 = BRA. , 2 =",
    "EXAMPLE 7-3: DATA EEPROM REFRESH ROUTINE\nLoop. , 3 = . , 4 = ;. , 1 = BCF. , 2 = EECON1, WREN. , 3 = ;. , 4 = Disable writes. , 1 = BSF. , 2 = INTCON, GIE. , 3 = ;. , 4 = Enable interrupts",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = T0IE. INTCON, Bit 4 = INTE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = T0IF. INTCON, Bit 1 = INTF. INTCON, Bit 0 = RBIF. INTCON, Value on: POR, BOR = 0000 000x. INTCON, Value on all other Resets = 0000 000u. EEADRH, Bit 7 = -. EEADRH, Bit 6 = -. EEADRH, Bit 5 = -. EEADRH, Bit 4 = -. EEADRH, Bit 3 = -. EEADRH, Bit 2 = -. EEADRH, Bit 1 = EE Addr High. EEADRH, Bit 0 = EE Addr High. EEADRH, Value on: POR, BOR = ---- --00. EEADRH, Value on all other Resets = ---- --00. EEADR, Bit 7 = EEPROM Address Register.",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nEEADR, Bit 6 = EEPROM Address Register. EEADR, Bit 5 = EEPROM Address Register. EEADR, Bit 4 = EEPROM Address Register. EEADR, Bit 3 = EEPROM Address Register. EEADR, Bit 2 = EEPROM Address Register. EEADR, Bit 1 = EEPROM Address Register. EEADR, Bit 0 = EEPROM Address Register. EEADR, Value on: POR, BOR = 0000 0000. EEADR, Value on all other Resets = 0000 0000. EEDATA, Bit 7 = EEPROM Data Register. EEDATA, Bit 6 = EEPROM Data Register. EEDATA, Bit 5 = EEPROM Data Register. EEDATA, Bit 4 = EEPROM Data Register. EEDATA, Bit 3 = EEPROM Data Register. EEDATA, Bit 2 = EEPROM Data Register. EEDATA, Bit 1 = EEPROM Data Register. EEDATA, Bit 0 = EEPROM Data Register. EEDATA, Value on: POR, BOR = 0000",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\n0000. EEDATA, Value on all other Resets = 0000 0000. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Value on: POR, BOR = -. EECON2, Value on all other Resets = -. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 =",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nFREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on: POR, BOR = xx-0 x000. EECON1, Value on all other Resets = uu-0 u000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on: POR, BOR = -1-1 1111. IPR2, Value on all other Resets = ---1 1111. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3",
    "TABLE 7-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\n= BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on: POR, BOR = -0-0 0000. PIR2, Value on all other Resets = ---0 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on: POR, BOR = -0-0 0000. PIE2, Value on all other Resets = ---0 0000\nLegend:\n= unknown, = unchanged, = reserved, = unimplemented, read as ' '.\nx u r -0 Shaded cells are not used during Flash/EEPROM access.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "8.1 Introduction\nAn 8 x 8 hardware multiplier is included in the ALU of the PIC18F6585/8585/6680/8680 devices. By making the multiply a hardware operation, it completes in a single instruction cycle. This is an unsigned multiply that gives a 16-bit result. The result is stored in the 16-bit product register pair (PRODH:PRODL). The multiplier does not affect any flags in the ALUSTA register.\nMaking the 8 x 8 multiplier execute in a single cycle gives the following advantages:\n\u00b7 Higher computational throughput\n\u00b7 Reduces code size requirements for multiply algorithms\nThe performance increase allows the device to be used in  applications  previously  reserved  for  Digital  Signal Processors.\nTable 8-1 shows a performance comparison between enhanced  devices  using  the  single-cycle  hardware multiply and performing the same function without the hardware multiply.",
    "8.2 Operation\nExample 8-1  shows  the  sequence  to  do  an  8  x  8 unsigned  multiply.  Only  one  instruction  is  required when one argument of the multiply is already loaded in the WREG register.\nExample 8-2 shows the sequence to do an 8 x 8 signed multiply. To account for the sign bits of the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "EXAMPLE 8-1: 8 x 8 UNSIGNED MULTIPLY ROUTINE\nMOVF\nARG1, W\n;\nMULWF\nARG2\n; ARG1 * ARG2 ->\n; PRODH:PRODL",
    "EXAMPLE 8-2: 8 x 8 SIGNED MULTIPLY ROUTINE\nMOVF MULWF, 1 = ARG1, W ARG2. MOVF MULWF, 2 = ; ; ARG1 * ARG2 -> ; PRODH:PRODL. BTFSC SUBWF, 1 = ARG2, SB PRODH. BTFSC SUBWF, 2 = ; Test Sign Bit ; PRODH = PRODH. MOVF BTFSC SUBWF, 1 = ARG2, W SB. MOVF BTFSC SUBWF, 2 = ; ; Test Sign Bit ; PRODH = PRODH. , 1 = ARG1,. , 2 = . , 1 = PRODH. , 2 = . , 1 = . , 2 = ; - ARG2",
    "TABLE 8-1: PERFORMANCE COMPARISON\n8 x 8 unsigned, Multiply Method = Without hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 13. 8 x 8 unsigned, Cycles (Max). = 69. 8 x 8 unsigned, Time.@40 MHz = 6.9 \uf06d s. 8 x 8 unsigned, Time.@10 MHz = 27.6 \uf06d s. 8 x 8 unsigned, Time.@4MHz = 69 \uf06d s. 8 x 8 unsigned, Multiply Method = Hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 1. 8 x 8 unsigned, Cycles (Max). = 1. 8 x 8 unsigned, Time.@40 MHz = 100 ns. 8 x 8 unsigned, Time.@10 MHz = 400 ns. 8 x 8 unsigned, Time.@4MHz = 1 \uf06d s. 8 x 8 signed, Multiply Method = Without hardware multiply. 8 x 8 signed, Program Memory (Words). = 33. 8 x 8 signed, Cycles (Max). = 91. 8 x 8 signed, Time.@40 MHz = 9.1 \uf06d s. 8 x 8 signed, Time.@10 MHz = 36.4 \uf06d s. 8 x 8",
    "TABLE 8-1: PERFORMANCE COMPARISON\nsigned, Time.@4MHz = 91 \uf06d s. 8 x 8 signed, Multiply Method = Hardware multiply. 8 x 8 signed, Program Memory (Words). = 6. 8 x 8 signed, Cycles (Max). = 6. 8 x 8 signed, Time.@40 MHz = 600 ns. 8 x 8 signed, Time.@10 MHz = 2.4 \uf06d s. 8 x 8 signed, Time.@4MHz = 6 \uf06d s. 16 x 16 unsigned, Multiply Method = Without hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 21. 16 x 16 unsigned, Cycles (Max). = 242. 16 x 16 unsigned, Time.@40 MHz = 24.2 \uf06d s. 16 x 16 unsigned, Time.@10 MHz = 96.8 \uf06d s. 16 x 16 unsigned, Time.@4MHz = 242 \uf06d s. 16 x 16 unsigned, Multiply Method = Hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 24. 16 x 16 unsigned, Cycles (Max). = 24. 16 x 16 unsigned, Time.@40 MHz = 2.4 \uf06d s. 16 x 16 unsigned,",
    "TABLE 8-1: PERFORMANCE COMPARISON\nTime.@10 MHz = 9.6 \uf06d s. 16 x 16 unsigned, Time.@4MHz = 24 \uf06d s. 16 x 16 signed, Multiply Method = Without hardware multiply. 16 x 16 signed, Program Memory (Words). = 52. 16 x 16 signed, Cycles (Max). = 254. 16 x 16 signed, Time.@40 MHz = 25.4 \uf06d s. 16 x 16 signed, Time.@10 MHz = 102.6 \uf06d s. 16 x 16 signed, Time.@4MHz = 254 \uf06d s. 16 x 16 signed, Multiply Method = Hardware multiply. 16 x 16 signed, Program Memory (Words). = 36. 16 x 16 signed, Cycles (Max). = 36. 16 x 16 signed, Time.@40 MHz = 3.6 \uf06d s. 16 x 16 signed, Time.@10 MHz = 14.4 \uf06d s. 16 x 16 signed, Time.@4MHz = 36 \uf06d s",
    "PIC18F6585/8585/6680/8680\nExample 8-3  shows  the  sequence  to  do  a  16  x  16 unsigned  multiply.  Equation 8-1  shows  the  algorithm that is used. The 32-bit result is stored in four registers, RES3:RES0.\nEQUATION 8-2:\n16 x 16 SIGNED MULTIPLICATION ALGORITHM\nEQUATION 8-1:\n16 x 16 UNSIGNED MULTIPLICATION ALGORITHM\nRES3:RES0, 1 = ARG1H:ARG1L \uf0b7 ARG2H:ARG2L (ARG1H \uf0b7 ARG2H \uf0b7 216) + (ARG1H \uf0b7 ARG2L \uf0b7 28) + (ARG1L \uf0b7 ARG2H \uf0b7 28) + (ARG1L \uf0b7 ARG2L)",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF, 1 = ARG1L, ARG2L. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = . MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 = ARG1L * ARG2L -> ; PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 = RES1. MOVFF, 3 = ;. MOVFF, 4 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES0. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 = ARG1H * ARG2H -> PRODH:PRODL.",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVFF, 1 = PRODH,. MOVFF, 2 = RES3. MOVFF, 3 = ;. MOVFF, 4 = . MOVFF, 1 = PRODL,. MOVFF, 2 = RES2. MOVFF, 3 = ;. MOVFF, 4 = . MOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = . MOVF, 4 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ; ;. MULWF, 4 = ARG1L * ARG2H -> PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF, 1 = RES1. ADDWF, 2 = . ADDWF, 3 = ;. ADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF,",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\n3 = ;. MOVF, 4 = products. ADDWFC, 1 = RES2. ADDWFC, 2 = . ADDWFC, 3 = ;. ADDWFC, 4 = . CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3. ADDWFC, 2 = . ADDWFC, 3 = ;. ADDWFC, 4 = . MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . MULWF, 1 = ARG2L. MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 = ARG1H * ARG2L ->. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = . ADDWF, 1 = RES1. ADDWF, 2 = . ADDWF, 3 = ;.",
    "EXAMPLE 8-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nADDWF, 4 = Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ;. MOVF, 4 = products. ADDWFC, 1 = RES2. ADDWFC, 2 = . ADDWFC, 3 = ;. ADDWFC, 4 = . CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. CLRF, 4 = . ADDWFC, 1 = RES3. ADDWFC, 2 = . ADDWFC, 3 = ;. ADDWFC, 4 = \nExample 8-4  shows  the  sequence  to  do  a  16  x  16 signed  multiply. Equation 8-2  shows  the  algorithm used.  The  32-bit  result  is  stored  in  four  registers, RES3:RES0. To account for the sign bits of the arguments, each argument pairs' Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "RES3:RES0\n=\nARG1H:ARG1L   ARG2H:ARG2L \uf0b7\n=\n(ARG1H   ARG2H   216) +\n\uf0b7\n\uf0b7\n(ARG1H   ARG2L   28) + \uf0b7 \uf0b7\n(ARG1L   ARG2H   28) + \uf0b7 \uf0b7\n(ARG1L   ARG2L) + \uf0b7\n(-1 \uf0b7 ARG2H<7>   ARG1H:ARG1L   216) + \uf0b7 \uf0b7\n(-1 \uf0b7 ARG1H<7>   ARG2H:ARG2L   216) \uf0b7 \uf0b7",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\nMULWF, ARG1L, = ARG2L PRODH,. MULWF, W = . MULWF,  = ; ;. MULWF,  = ARG1L * ARG2L -> PRODH:PRODL. MOVFF, ARG1L, = . MOVFF, W = RES1. MOVFF,  = ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES0. MOVFF,  = ;. MOVFF,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF,  = ;. MULWF,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= ARG1H * ARG2H -> PRODH:PRODL. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES3. MOVFF,  = ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES2. MOVFF,  = ;. MOVFF,  = . MOVF, ARG1L, = ARG1L,. MOVF, W = W. MOVF,  = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1L * ARG2H -> PRODH:PRODL. MOVF, ARG1L, = PRODL,. MOVF, W = W. MOVF,  = ;. MOVF,  = . ADDWF, ARG1L, = RES1. ADDWF, W = . ADDWF,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= ;. ADDWF,  = Add cross. MOVF, ARG1L, = PRODH,. MOVF, W = . MOVF,  = . MOVF,  = . , ARG1L, = . , W = W. ,  = ;. ,  = products. ADDWFC, ARG1L, = RES2. ADDWFC, W = . ADDWFC,  = ;. ADDWFC,  = . CLRF, ARG1L, = WREG. CLRF, W = . CLRF,  = ;. CLRF,  = . ADDWFC, ARG1L, = RES3. ADDWFC, W = . ADDWFC,  = ;. ADDWFC,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = ;. MOVF,  = . MULWF, ARG1L, = ARG2L. MULWF, W = . MULWF,  = ;. MULWF,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= ARG1H * ARG2L ->. MOVF, ARG1L, = PRODL,. MOVF, W = W. MOVF,  = ;. MOVF,  = . ADDWF, ARG1L, = RES1. ADDWF, W = . ADDWF,  = ;. ADDWF,  = Add cross. MOVF, ARG1L, = PRODH,. MOVF, W = W. MOVF,  = ;. MOVF,  = products. ADDWFC, ARG1L, = RES2. ADDWFC, W = . ADDWFC,  = ;. ADDWFC,  = . CLRF, ARG1L, = WREG. CLRF, W = . CLRF,  = ;. CLRF,  = . ADDWFC, ARG1L, = RES3. ADDWFC, W = . ADDWFC,  = ;. ADDWFC,  = . BTFSS, ARG1L, = ARG2H,. BTFSS, W = 7. BTFSS,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= ;. BTFSS,  = ARG2H:ARG2L neg?. BRA, ARG1L, = SIGN_ARG1. BRA, W = . BRA,  = ;. BRA,  = no, check ARG1. MOVF, ARG1L, = ARG1L,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWF, ARG1L, = RES2. SUBWF, W = . SUBWF,  = ;. SUBWF,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWFB, ARG1L, = RES3. SUBWFB, W = . SUBWFB,  = . SUBWFB,  = . ; SIGN_ARG1, ARG1L, = . ; SIGN_ARG1, W = . ; SIGN_ARG1,  = . ; SIGN_ARG1,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . BTFSS, ARG1L, = ARG1H,. BTFSS, W = 7. BTFSS,  = ;. BTFSS,  = ARG1H:ARG1L neg?. BRA, ARG1L, = CONT_CODE. BRA, W = . BRA,  = ;. BRA,  = no, done. MOVF, ARG1L, = ARG2L,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWF, ARG1L, = RES2. SUBWF, W = . SUBWF,  = ;. SUBWF,  = . MOVF, ARG1L, = ARG2H,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWFB, ARG1L, = RES3. SUBWFB, W = . SUBWFB,  = . SUBWFB,",
    "EXAMPLE 8-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . CONT_CODE, ARG1L, = . CONT_CODE, W = . CONT_CODE,  = . CONT_CODE,  = . :, ARG1L, = . :, W = . :,  = . :,  = ",
    "9.0 INTERRUPTS\nThe PIC18F6585/8585/6680/8680 devices have multiple  interrupt  sources  and  an  interrupt  priority  feature that allows each interrupt source to be assigned a high or a low priority level. The high priority interrupt vector is at 000008h while the low priority interrupt vector is at 000018h. High priority interrupt events will override any low priority interrupts that may be in progress.\nWhen  the  IPEN  bit  is  cleared  (default  state),  the interrupt priority feature is disabled and interrupts are compatible with PIC \u00ae  mid-range devices. In Compatibility  mode,  the  interrupt  priority  bits  for  each  source have  no  effect.  INTCON<6>  is  the  PEIE  bit  which enables/disables all peripheral interrupt sources. INTCON<7> is the GIE bit which enables/disables all interrupt  sources.  All  interrupts  branch  to  address 000008h in Compatibility mode.\nThere are thirteen registers which are used to control interrupt operation. They are:\n\u00b7 RCON\n\u00b7 INTCON\n\u00b7 INTCON2\n\u00b7 INTCON3\n\u00b7 PIR1, PIR2, PIR3\n\u00b7 PIE1, PIE2, PIE3\n\u00b7 IPR1, IPR2, IPR3",
    "9.0 INTERRUPTS\nIt is  recommended  that  the  Microchip  header  files supplied with MPLAB \u00ae  IDE be used for the symbolic bit names in these registers. This allows the assembler/ compiler to automatically take care of the placement of these bits within the specified register.\nEach interrupt source (except INT0) has three bits to control its operation. The functions of these bits are:\n\u00b7 Flag bit to indicate that an interrupt event occurred\n\u00b7 Enable bit that allows program execution to branch to the interrupt vector address when the flag bit is set\n\u00b7 Priority bit to select high priority or low priority\nThe interrupt priority feature is enabled by setting the IPEN bit (RCON<7>). When  interrupt priority is enabled,  there  are  two  bits  which  enable  interrupts globally. Setting the GIEH bit (INTCON<7>) enables all interrupts that have the priority bit set. Setting the GIEL bit  (INTCON<6>) enables all interrupts that  have the priority bit cleared. When the interrupt flag, enable bit and appropriate global interrupt enable bit are set, the interrupt will vector immediately to address 000008h or 000018h  depending  on  the  priority  level.  Individual interrupts can be disabled through their corresponding enable bits.",
    "9.0 INTERRUPTS\nWhen an interrupt is responded to, the global interrupt enable bit is cleared to disable further interrupts. If the IPEN bit is cleared, this is the GIE bit. If interrupt priority levels are used, this will be either the GIEH or GIEL bit. High  priority  interrupt  sources  can  interrupt  a  low priority interrupt.\nThe return address is pushed onto the stack and the PC  is loaded with the interrupt vector address (000008h or 000018h). Once in the Interrupt Service Routine,  the  source(s)  of  the  interrupt  can  be  determined by polling  the  interrupt  flag  bits.  The  interrupt flag bits must be cleared in software before re-enabling interrupts to avoid recursive interrupts.\nThe 'return  from  interrupt'  instruction, RETFIE ,  exits the interrupt routine and sets the GIE bit (GIEH or GIEL if priority levels are used) which re-enables interrupts.",
    "9.0 INTERRUPTS\nFor external interrupt events, such as the INT pins or the PORTB input change interrupt, the interrupt latency will be  three  to  four  instruction  cycles.  The  exact latency is the same for one- or two-cycle instructions. Individual interrupt flag  bits  are  set  regardless  of  the status of their corresponding enable bit or the GIE bit.",
    "PIC18F6585/8585/6680/8680\nFIGURE 9-1:\nINTERRUPT LOGIC",
    "9.1 INTCON Registers\nNote:\nThe  INTCON  registers  are  readable  and  writable registers which contain various enable, priority and flag bits.\nInterrupt flag bits are set when an interrupt condition occurs regardless of the state of its corresponding enable bit or the global enable  bit.  User  software  should  ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.",
    "REGISTER 9-1: INTCON REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-x. GIE/GIEH, 1 = PEIE/GIEL. GIE/GIEH, 2 = TMR0IE. GIE/GIEH, 3 = INT0IE. GIE/GIEH, 4 = RBIE. GIE/GIEH, 5 = TMR0IF. GIE/GIEH, 6 = INT0IF. GIE/GIEH, 7 = RBIF\nbit 7\nbit 0",
    "When IPEN (RCON<7>) = 0 :\n1 = Enables all unmasked interrupts\n0 = Disables all interrupts",
    "When IPEN (RCON<7>) = 1 :\n1 = Enables all high priority interrupts\n0 = Disables all interrupts",
    "When IPEN (RCON<7>) = 0 :\n1 = Enables all unmasked peripheral interrupts\n0 = Disables all peripheral interrupts",
    "When IPEN (RCON<7>) = 1 :\n1 = Enables all low priority peripheral interrupts\n0 = Disables all low priority peripheral interrupts\nbit 5 TMR0IE: TMR0 Overflow Interrupt Enable bit\n1 = Enables the TMR0 overflow interrupt\n0 = Disables the TMR0 overflow interrupt",
    "bit 4 INT0IE: INT0 External Interrupt Enable bit\n1 = Enables the INT0 external interrupt\n0 = Disables the INT0 external interrupt",
    "bit 3 RBIE: RB Port Change Interrupt Enable bit\n1 = Enables the RB port change interrupt\n0 = Disables the RB port change interrupt",
    "bit 2 TMR0IF: TMR0 Overflow Interrupt Flag bit\n1 = TMR0 register has overflowed (must be cleared in software)\n0 = TMR0 register did not overflow",
    "bit 1 INT0IF: INT0 External Interrupt Flag bit\n1 = The INT0 external interrupt occurred (must be cleared in software)\n0 = The INT0 external interrupt did not occur\nbit 0 RBIF: RB Port Change Interrupt Flag bit\n1 = At least one of the RB7:RB4 pins changed state (must be cleared in software)\n0 = None of the RB7:RB4 pins have changed state\nNote:\nA mismatch condition will continue to set this bit.  Reading  PORTB will end the mismatch condition and allow the bit to be cleared.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "PIC18F6585/8585/6680/8680\nREGISTER 9-2:",
    "INTCON2 REGISTER\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nR/W-1\nRBPU\nINTEDG0\nINTEDG1\nINTEDG2\nINTEDG3\nTMR0IP\nINT3IP\nRBIP\nbit 7\nbit 0\nbit 7\nRBPU : PORTB Pull-up Enable bit\n1 = All PORTB pull-ups are disabled\n0 = PORTB pull-ups are enabled by individual port latch values\nbit 6 INTEDG0 : External Interrupt 0 Edge Select bit\n1 =  Interrupt on rising edge\n0 =  Interrupt on falling edge\nbit 5 INTEDG1 : External Interrupt 1 Edge Select bit\n1 = Interrupt on rising edge\n0 =  Interrupt on falling edge\nbit 4 INTEDG2 : External Interrupt 2 Edge Select bit\n1 =  Interrupt on rising edge\n0 =  Interrupt on falling edge\nbit 3 INTEDG3 : External Interrupt 3 Edge Select bit\n1 =  Interrupt on rising edge\n0 =  Interrupt on falling edge\nbit 2 TMR0IP : TMR0 Overflow Interrupt Priority bit\n1 =  High priority\n0 =  Low priority\nbit 1\nINT3IP:\nINT3 External Interrupt Priority bit\n1 = High priority",
    "INTCON2 REGISTER\n0 = Low priority\nbit 0 RBIP : RB Port Change Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nNote:\nInterrupt flag bits are set when an interrupt condition occurs regardless of the state of its corresponding enable bit or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.",
    "INTCON3 REGISTER\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-0. R/W-1, 3 = R/W-0. R/W-1, 4 = R/W-0. R/W-1, 5 = R/W-0. R/W-1, 6 = R/W-0. R/W-1, 7 = R/W-0. INT2IP, 1 = INT1IP. INT2IP, 2 = INT3IE. INT2IP, 3 = INT2IE. INT2IP, 4 = INT1IE. INT2IP, 5 = INT3IF. INT2IP, 6 = INT2IF. INT2IP, 7 = INT1IF\nbit 7\nbit 0",
    "bit 7 INT2IP: INT2 External Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 6 INT1IP: INT1 External Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 5 INT3IE: INT3 External Interrupt Enable bit\n1 = Enables the INT3 external interrupt\n0 = Disables the INT3 external interrupt",
    "bit 4 INT2IE: INT2 External Interrupt Enable bit\n1 = Enables the INT2 external interrupt\n0 = Disables the INT2 external interrupt",
    "bit 3 INT1IE: INT1 External Interrupt Enable bit\n1 = Enables the INT1 external interrupt\n0 = Disables the INT1 external interrupt",
    "bit 2 INT3IF: INT3 External Interrupt Flag bit\n1 = The INT3 external interrupt occurred (must be cleared in software)\n0 = The INT3 external interrupt did not occur\nbit 1 INT2IF: INT2 External Interrupt Flag bit\n1 = The INT2 external interrupt occurred (must be cleared in software)\n0 = The INT2 external interrupt did not occur",
    "bit 0 INT1IF: INT1 External Interrupt Flag bit\n1 = The INT1 external interrupt occurred (must be cleared in software)\n0 = The INT1 external interrupt did not occur",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "Note:\nInterrupt flag bits are set when an interrupt condition occurs regardless of the state of its corresponding enable bit or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.",
    "9.2 PIR Registers\nThe PIR registers contain the individual flag bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are three Peripheral Interrupt Flag registers (PIR1, PIR2 and PIR3).\nNote 1: Interrupt flag bits are set when an interrupt condition occurs regardless of the state of its corresponding enable bit or the global enable bit, GIE (INTCON<7>).\n2: User software should ensure the appropriate interrupt flag bits are cleared prior to enabling an interrupt, and after servicing that interrupt.",
    "PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PSPIF (1), 1 = ADIF. PSPIF (1), 2 = RCIF. PSPIF (1), 3 = TXIF. PSPIF (1), 4 = SSPIF. PSPIF (1), 5 = CCP1IF. PSPIF (1), 6 = TMR2IF. PSPIF (1), 7 = TMR1IF\nbit 7\nbit 0\nbit 7 PSPIF: Parallel Slave Port Read/Write Interrupt Flag bit (1)\n1\n= A read or a write operation has taken place (must be cleared in software) = No read or write has occurred\n0",
    "PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nbit 6 ADIF : A/D Converter Interrupt Flag bit\n1 = An A/D conversion completed (must be cleared in software)\n0 = The A/D conversion is not complete\nbit 5\nRCIF : USART Receive Interrupt Flag bit\n1 = The USART receive buffer, RCREG, is full (cleared when RCREG is read)\n0 = The USART receive buffer is empty\nbit 4 TXIF : USART Transmit Interrupt Flag bit\n1 = The USART transmit buffer, TXREG, is empty (cleared when TXREG is written)\n0\n= The USART transmit buffer is full",
    "bit 3 SSPIF : Master Synchronous Serial Port Interrupt Flag bit\n1\n= The transmission/reception is complete (must be cleared in software) = Waiting to transmit/receive\n0\nbit 2 CCP1IF : Enhanced CCP1 Interrupt Flag bit",
    "Capture mode:\n1 = A TMR1 register capture occurred (must be cleared in software)\n0 = No TMR1 register capture occurred",
    "Compare mode:\n1 = A TMR1 register compare match occurred (must be cleared in software)\n0 = No TMR1 register compare match occurred",
    "PWM mode:\nUnused in this mode.",
    "bit 1 TMR2IF: TMR2 to PR2 Match Interrupt Flag bit\n1 = TMR2 to PR2 match occurred (must be cleared in software)\n0\n= No TMR2 to PR2 match occurred",
    "bit 0 TMR1IF: TMR1 Overflow Interrupt Flag bit\n1 = TMR1 register overflowed (must be cleared in software)\n0 = TMR1 register did not overflow\nNote 1: Available in Microcontroller mode only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "PIR2: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 2\nU-0, 1 = R/W-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = CMIF. -, 2 = -. -, 3 = EEIF. -, 4 = BCLIF. -, 5 = LVDIF. -, 6 = TMR3IF. -, 7 = CCP2IF\nbit 7\nbit 0",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6 CMIF : Comparator Interrupt Flag bit\n1 = The comparator input has changed (must be cleared in software)\n0 = The comparator input has not changed\nbit 5 Unimplemented: Read as ' 0 '\nbit 4 EEIF : Data EEPROM/Flash Write Operation Interrupt Flag bit\n1 = The write operation is complete (must be cleared in software)\n0 = The write operation is not complete, or has not been started",
    "bit 3 BCLIF : Bus Collision Interrupt Flag bit\n1 = A bus collision occurred while the SSP module (configured in I 2 C Master mode) was transmitting (must be cleared in software)\n0 = No bus collision occurred\nbit 2 LVDIF : Low-Voltage Detect Interrupt Flag bit\n1 = A low-voltage condition occurred (must be cleared in software)\n0 = The device voltage is above the Low-Voltage Detect trip point",
    "bit 1 TMR3IF\n: TMR3 Overflow Interrupt Flag bit\n1 = TMR3 register overflowed (must be cleared in software)\n0 = TMR3 register did not overflow\nCCP2IF\n: CCP2 Interrupt Flag bit",
    "Capture mode:\n1 = A TMR1 or TMR3 register capture occurred (must be cleared in software)\n0 = No TMR1 or TMR3 register capture occurred",
    "Compare mode:\n1 = A TMR1 or TMR3 register compare match occurred (must be cleared in software)\n0 = No TMR1 or TMR3 register compare match occurred",
    "PWM mode:\nUnused in this mode.\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown\nbit 0",
    "PIR3: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 3\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IRXIF, 1 = WAKIF. IRXIF, 2 = ERRIF. IRXIF, 3 = TXB2IF/ TXBnIF. IRXIF, 4 = TXB1IF (1). IRXIF, 5 = TXB0IF (1). IRXIF, 6 = RXB1IF/ RXBnIF. IRXIF, 7 = RXB0IF/ FIFOWMIF\nbit 7\nbit 0",
    "bit 7 IRXIF: CAN Invalid Received Message Interrupt Flag bit\n1 = An invalid message has occurred on the CAN bus\n0 = No invalid message on CAN bus",
    "bit 6 WAKIF: CAN bus Activity Wake-up Interrupt Flag bit\n1 = Activity on CAN bus has occurred\n0 = No activity on CAN bus",
    "bit 5 ERRIF: CAN bus Error Interrupt Flag bit\n1 = An error has occurred in the CAN module (multiple sources)\n0 = No CAN module errors",
    "bit 4 When CAN is in Mode 0:\nTXB2IF: CAN Transmit Buffer 2 Interrupt Flag bit\n1 = Transmit Buffer 2 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 2 has not completed transmission of a message",
    "TXBnIF: Any Transmit Buffer Interrupt Flag bit\n1 = One  or  more  transmit  buffers  has  completed  transmission  of  a  message  and  may  be reloaded (TXBIE or BIE0<7:2> must be non-zero)\n0 = No message was transmitted",
    "bit 3 TXB1IF: CAN Transmit Buffer 1 Interrupt Flag bit (1)\n1 = Transmit Buffer 1 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 1 has not completed transmission of a message",
    "TXB0IF: CAN Transmit Buffer 0 Interrupt Flag bit (1)\n1\n= Transmit Buffer 0 has completed transmission of a message and may be reloaded\n- 0 = Transmit Buffer 0 has not completed transmission of a message",
    "bit 1 When CAN is in Mode 0:\nRXB1IF: CAN Receive Buffer 1 Interrupt Flag bit\n1 = Receive Buffer 1 has received a new message\n0 = Receive Buffer 1 has not received a new message",
    "RXBnIF: CAN Receive Buffer Interrupt Flag bit\n1 = One or more receive buffers has received a new message\n0 = No receive buffer has received a new message",
    "RXB0IF: CAN Receive Buffer 0 Interrupt Flag bit (1)\n1 = Receive Buffer 0 has received a new message\n0 = Receive Buffer 0 has not received a new message",
    "When CAN is in Mode 1:\nUnimplemented: Read as ' 0 '",
    "When CAN is in Mode 2:\nFIFOWMIF: FIFO Watermark Interrupt Flag bit\n1 = FIFO high watermark is reached\n0 = FIFO high watermark is not reached",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "9.3 PIE Registers\nThe PIE registers contain the individual enable bits for the peripheral interrupts. Due  to the number  of peripheral interrupt sources, there are three Peripheral Interrupt  Enable  registers  (PIE1,  PIE2  and  PIE3). When the IPEN bit (RCON<7>) is ' 0 ', the PEIE bit must be set to enable any of these peripheral interrupts.",
    "REGISTER 9-7: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PSPIE (1), 1 = ADIE. PSPIE (1), 2 = RCIE. PSPIE (1), 3 = TXIE. PSPIE (1), 4 = SSPIE. PSPIE (1), 5 = CCP1IE. PSPIE (1), 6 = TMR2IE. PSPIE (1), 7 = TMR1IE\nbit 7\nbit 0",
    "bit 7 PSPIE: Parallel Slave Port Read/Write Interrupt Enable bit (1)\n1 = Enables the PSP read/write interrupt\n0 = Disables the PSP read/write interrupt\nNote 1: Available in Microcontroller mode only.",
    "bit 6 ADIE : A/D Converter Interrupt Enable bit\n1 = Enables the A/D interrupt\n0 = Disables the A/D interrupt\nbit 5 RCIE : USART Receive Interrupt Enable bit\n1 = Enables the USART receive interrupt\n0 = Disables the USART receive interrupt",
    "bit 4 TXIE : USART Transmit Interrupt Enable bit\n1 = Enables the USART transmit interrupt\n0 = Disables the USART transmit interrupt\nSSPIE : Master Synchronous Serial Port Interrupt Enable bit\n1 = Enables the MSSP interrupt\n0 = Disables the MSSP interrupt\nCCP1IE : Enhanced CCP1 Interrupt Enable bit\n1 = Enables the CCP1 interrupt\n0 = Disables the CCP1 interrupt\nTMR2IE : TMR2 to PR2 Match Interrupt Enable bit\n1 = Enables the TMR2 to PR2 match interrupt\n0 = Disables the TMR2 to PR2 match interrupt\nTMR1IE : TMR1 Overflow Interrupt Enable bit\n1 = Enables the TMR1 overflow interrupt\n0 = Disables the TMR1 overflow interrupt",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nU-0, 1 = R/W-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = CMIE. -, 2 = -. -, 3 = EEIE. -, 4 = BCLIE. -, 5 = LVDIE. -, 6 = TMR3IE. -, 7 = CCP2IE\nbit 7\nbit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nCMIE : Comparator Interrupt Enable bit\n1 = Enables the comparator interrupt\n0 = Disables the comparator interrupt\nbit 5 Unimplemented: Read as ' 0 '\nbit 4 EEIE : Data EEPROM/Flash Write Operation Interrupt Enable bit\n1 = Enables the write operation interrupt\n0 = Disables the write operation interrupt\nbit 3\nBCLIE : Bus Collision Interrupt Enable bit\n1 = Enables the bus collision interrupt",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\n0 = Disables the bus collision interrupt\nbit 2\nLVDIE : Low-Voltage Detect Interrupt Enable bit\n1 = Enables the Low-Voltage Detect interrupt\n0 = Disables the Low-Voltage Detect interrupt",
    "bit 1\nTMR3IE : TMR3 Overflow Interrupt Enable bit\n1 = Enables the TMR3 overflow interrupt\n0 = Disables the TMR3 overflow interrupt\nbit 0\nCCP2IE : CCP2 Interrupt Enable bit\n1 = Enables the CCP2 interrupt\n0 = Disables the CCP2 interrupt",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 9-9:\nbit 7\n- bit 3",
    "PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IRXIE, 1 = WAKIE. IRXIE, 2 = ERRIE. IRXIE, 3 = TXB2IE/ TXBnIE. IRXIE, 4 = TXB1IE (1). IRXIE, 5 = TXB0IE (1). IRXIE, 6 = RXB1IE/ RXBnIE. IRXIE, 7 = RXB0IE/ FIFOWMIE\nbit 7\nbit 0\nIRXIE:\nCAN Invalid Received Message Interrupt Enable bit\n1 = Enable invalid message received interrupt\n0 = Disable invalid message received interrupt",
    "bit 6 WAKIE: CAN bus Activity Wake-up Interrupt Enable bit\n1 = Enable bus activity wake-up interrupt\n0 = Disable bus activity wake-up interrupt",
    "bit 5 ERRIE: CAN bus Error Interrupt Enable bit\n1 = Enable CAN bus error interrupt\n0 = Disable CAN bus error interrupt",
    "bit 4 When CAN is in Mode 0:\nTXB2IE: CAN Transmit Buffer 2 Interrupt Enable bit\n1 = Enable Transmit Buffer 2 interrupt\n0 = Disable Transmit Buffer 2 interrupt\nWhen CAN is in Mode 1 or 2:\nTXBnIE: CAN Transmit Buffer Interrupts Enable bit\n1 = Enable transmit buffer interrupt; individual interrupt is enabled by TXBIE and BIE0\n0 = Disable all transmit buffer interrupts\nTXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit (1)\n1 = Enable Transmit Buffer 1 interrupt\n0 = Disable Transmit Buffer 1 interrupt",
    "bit 2 TXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit (1)\n1 = Enable Transmit Buffer 0 interrupt\n0 = Disable Transmit Buffer 0 interrupt",
    "bit 1 When CAN is in Mode 0:\nRXB1IE: CAN Receive Buffer 1 Interrupt Enable bit\n1 = Enable Receive Buffer 1 interrupt\n0 = Disable Receive Buffer 1 interrupt\nWhen CAN is in Mode 1 or 2:\nRXBnIE: CAN Receive Buffer Interrupts Enable bit\n1 = Enable receive buffer interrupt; individual interrupt is enabled by BIE0\n0 = Disable all receive buffer interrupts",
    "bit 0 When CAN is in Mode 0:\nRXB0IE: CAN Receive Buffer 0 Interrupt Enable bit\n1 = Enable Receive Buffer 0 interrupt\n0 = Disable Receive Buffer 0 interrupt\nWhen CAN is in Mode 1:\nUnimplemented: Read as ' 0 '\nWhen CAN is in Mode 2:\nFIFOWMIE: FIFO Watermark Interrupt Enable bit\n1 = Enable FIFO watermark interrupt\n0 = Disable FIFO watermark interrupt\nNote 1: In CAN Mode 1 and 2, this bit is forced to ' 0 '.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "9.4 IPR Registers\nThe IPR registers contain the individual priority bits for the peripheral interrupts. Due  to the number  of peripheral interrupt sources, there are three Peripheral Interrupt Priority registers (IPR1, IPR2 and IPR3). The operation of the priority bits requires that the Interrupt Priority Enable (IPEN) bit be set.",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\n, R/W-1 = PSPIP (1). , R/W-1 = ADIP. , R/W-1 = RCIP. , R/W-1 = TXIP. , R/W-1 = SSPIP. , R/W-1 = CCP1IP. , R/W-1 = TMR2IP. , R/W-1 = TMR1IP. , R/W-1 = bit 7. , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = bit 0. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nRead/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. , R/W-1 = Note 1: Available in Microcontroller mode only.. , R/W-1 = Note 1: Available in Microcontroller mode only.. , R/W-1 = Note 1: Available in Microcontroller mode",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nonly.. , R/W-1 = Note 1: Available in Microcontroller mode only.. , R/W-1 = Note 1: Available in Microcontroller mode only.. , R/W-1 = Note 1: Available in Microcontroller mode only.. , R/W-1 = Note 1: Available in Microcontroller mode only.. , R/W-1 = Note 1: Available in Microcontroller mode only.. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit. bit 6, R/W-1 = ADIP : A/D Converter Interrupt",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nPriority bit. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit.",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nbit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit. bit 4,",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nR/W-1 = TXIP : USART Transmit Interrupt Priority bit. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit. bit 3,",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nR/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. ,",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nR/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority.",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\n, R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. , R/W-1 = 1 = High priority 0 = Low priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 =",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nTMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP :",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nTMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. , R/W-1 = Legend:. , R/W-1 = Legend:. , R/W-1 = Legend:. , R/W-1 = Legend:. , R/W-1 = Legend:. , R/W-1 = Legend:. , R/W-1 = Legend:. , R/W-1 = Legend:. , R/W-1 = R = Readable bit - n = Value at",
    "IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nPOR. , R/W-1 = R = Readable bit - n = Value at POR. , R/W-1 = W=Writable bit '1' = Bit is set. , R/W-1 = W=Writable bit '1' = Bit is set. , R/W-1 = U = Unimplemented bit, read as '0' '0' = Bit is cleared x = Bit is unknown. , R/W-1 = U = Unimplemented bit, read as '0' '0' = Bit is cleared x = Bit is unknown. , R/W-1 = U = Unimplemented bit, read as '0' '0' = Bit is cleared x = Bit is unknown. , R/W-1 = U = Unimplemented bit, read as '0' '0' = Bit is cleared x = Bit is unknown",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nbit 7, U-0.-.bit 7 = Unimplemented: Read as ' 0 '. bit 7, R/W-1.CMIP. = Unimplemented: Read as ' 0 '. bit 7, U-0.-. = Unimplemented: Read as ' 0 '. bit 7, R/W-1.EEIP. = Unimplemented: Read as ' 0 '. bit 7, R/W-1.BCLIP. = Unimplemented: Read as ' 0 '. bit 7, R/W-1.LVDIP. = Unimplemented: Read as ' 0 '. bit 7, R/W-1.TMR3IP. = Unimplemented: Read as ' 0 '. bit 7, R/W-1.CCP2IP.bit 0 = Unimplemented: Read as ' 0 '. bit 6, U-0.-.bit 7 = CMIP : Comparator Interrupt Priority bit. bit 6, R/W-1.CMIP. = CMIP : Comparator Interrupt Priority",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nbit. bit 6, U-0.-. = CMIP : Comparator Interrupt Priority bit. bit 6, R/W-1.EEIP. = CMIP : Comparator Interrupt Priority bit. bit 6, R/W-1.BCLIP. = CMIP : Comparator Interrupt Priority bit. bit 6, R/W-1.LVDIP. = CMIP : Comparator Interrupt Priority bit. bit 6, R/W-1.TMR3IP. = CMIP : Comparator Interrupt Priority bit. bit 6, R/W-1.CCP2IP.bit 0 = CMIP : Comparator Interrupt Priority bit. bit 5, U-0.-.bit 7 = Unimplemented: Read as ' 0 '. bit 5, R/W-1.CMIP. = Unimplemented: Read as ' 0 '. bit 5, U-0.-. = Unimplemented: Read as ' 0 '. bit 5, R/W-1.EEIP. = Unimplemented: Read as ' 0 '. bit 5,",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nR/W-1.BCLIP. = Unimplemented: Read as ' 0 '. bit 5, R/W-1.LVDIP. = Unimplemented: Read as ' 0 '. bit 5, R/W-1.TMR3IP. = Unimplemented: Read as ' 0 '. bit 5, R/W-1.CCP2IP.bit 0 = Unimplemented: Read as ' 0 '. bit 4, U-0.-.bit 7 = EEIP : Data EEPROM/Flash Write Operation Interrupt Priority bit 1 = High priority. bit 4, R/W-1.CMIP. = EEIP : Data EEPROM/Flash Write Operation Interrupt Priority bit 1 = High priority. bit 4, U-0.-. = EEIP : Data EEPROM/Flash Write Operation Interrupt Priority bit 1 = High priority. bit 4, R/W-1.EEIP. = EEIP : Data EEPROM/Flash Write Operation Interrupt Priority bit 1 = High priority. bit 4, R/W-1.BCLIP. = EEIP : Data",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nEEPROM/Flash Write Operation Interrupt Priority bit 1 = High priority. bit 4, R/W-1.LVDIP. = EEIP : Data EEPROM/Flash Write Operation Interrupt Priority bit 1 = High priority. bit 4, R/W-1.TMR3IP. = EEIP : Data EEPROM/Flash Write Operation Interrupt Priority bit 1 = High priority. bit 4, R/W-1.CCP2IP.bit 0 = EEIP : Data EEPROM/Flash Write Operation Interrupt Priority bit 1 = High priority. bit 3, U-0.-.bit 7 = 0 = Low priority BCLIP : Bus Collision Interrupt Priority bit. bit 3, R/W-1.CMIP. = 0 = Low priority BCLIP : Bus Collision Interrupt Priority bit. bit 3, U-0.-. = 0 = Low priority BCLIP : Bus Collision Interrupt Priority bit. bit 3, R/W-1.EEIP. = 0 = Low priority BCLIP : Bus Collision Interrupt Priority bit. bit 3, R/W-1.BCLIP. = 0 = Low priority BCLIP : Bus Collision Interrupt Priority bit. bit",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\n3, R/W-1.LVDIP. = 0 = Low priority BCLIP : Bus Collision Interrupt Priority bit. bit 3, R/W-1.TMR3IP. = 0 = Low priority BCLIP : Bus Collision Interrupt Priority bit. bit 3, R/W-1.CCP2IP.bit 0 = 0 = Low priority BCLIP : Bus Collision Interrupt Priority bit. , U-0.-.bit 7 = 1 = High priority 0 = Low priority LVDIP : Low-Voltage Detect Interrupt Priority bit. , R/W-1.CMIP. = 1 = High priority 0 = Low priority LVDIP : Low-Voltage Detect Interrupt Priority bit. , U-0.-. = 1 = High priority 0 = Low priority LVDIP : Low-Voltage Detect Interrupt Priority bit. , R/W-1.EEIP. = 1 = High priority 0 = Low priority LVDIP : Low-Voltage Detect Interrupt Priority bit. , R/W-1.BCLIP. = 1 = High priority 0 = Low priority LVDIP : Low-Voltage Detect Interrupt Priority bit. , R/W-1.LVDIP.",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\n= 1 = High priority 0 = Low priority LVDIP : Low-Voltage Detect Interrupt Priority bit. , R/W-1.TMR3IP. = 1 = High priority 0 = Low priority LVDIP : Low-Voltage Detect Interrupt Priority bit. , R/W-1.CCP2IP.bit 0 = 1 = High priority 0 = Low priority LVDIP : Low-Voltage Detect Interrupt Priority bit. bit 2, U-0.-.bit 7 = 1 = High priority = Low priority. bit 2, R/W-1.CMIP. = 1 = High priority = Low priority. bit 2, U-0.-. = 1 = High priority = Low priority. bit 2, R/W-1.EEIP. = 1 = High priority = Low priority. bit 2, R/W-1.BCLIP. = 1 = High priority = Low priority. bit 2, R/W-1.LVDIP. = 1 = High priority = Low priority. bit 2, R/W-1.TMR3IP. = 1 = High priority = Low priority. bit 2,",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nR/W-1.CCP2IP.bit 0 = 1 = High priority = Low priority. bit 1, U-0.-.bit 7 = TMR3IP : TMR3 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1.CMIP. = TMR3IP : TMR3 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, U-0.-. = TMR3IP : TMR3 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1.EEIP. = TMR3IP : TMR3 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1.BCLIP. = TMR3IP : TMR3 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1.LVDIP. = TMR3IP : TMR3 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1,",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nR/W-1.TMR3IP. = TMR3IP : TMR3 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1.CCP2IP.bit 0 = TMR3IP : TMR3 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, U-0.-.bit 7 = CCP2IP : CCP2 Interrupt Priority bit 1 = High priority 0 = Low priority Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. bit 0, R/W-1.CMIP. = CCP2IP : CCP2 Interrupt Priority bit 1 = High priority 0 = Low priority Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. bit 0, U-0.-. = CCP2IP : CCP2 Interrupt Priority bit 1 = High priority 0 = Low priority Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\n'0'. bit 0, R/W-1.EEIP. = CCP2IP : CCP2 Interrupt Priority bit 1 = High priority 0 = Low priority Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. bit 0, R/W-1.BCLIP. = CCP2IP : CCP2 Interrupt Priority bit 1 = High priority 0 = Low priority Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. bit 0, R/W-1.LVDIP. = CCP2IP : CCP2 Interrupt Priority bit 1 = High priority 0 = Low priority Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. bit 0, R/W-1.TMR3IP. = CCP2IP : CCP2 Interrupt Priority bit 1 = High priority 0 = Low priority Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'. bit 0,",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nR/W-1.CCP2IP.bit 0 = CCP2IP : CCP2 Interrupt Priority bit 1 = High priority 0 = Low priority Legend: R = Readable bit W=Writable bit U = Unimplemented bit, read as '0'",
    "PIC18F6585/8585/6680/8680\nREGISTER 9-12:",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nIRXIP, R/W-1 = WAKIP. IRXIP, R/W-1 = ERRIP. IRXIP, R/W-1 = TXB2IP/ TXBnIP. IRXIP, R/W-1 = TXB1IP (1). IRXIP, R/W-1 = TXB0IP (1). IRXIP, R/W-1 = RXB1IP/ RXBnIP. IRXIP, R/W-1 = RXB0IP/ FIFOWMIP\nbit 7\nbit 0\nIRXIP: CAN Invalid Received Message Interrupt Priority bit\n1 = High priority\n0 = Low priority\nWAKIP: CAN bus Activity Wake-up Interrupt Priority bit\n1 = High priority\n0 = Low priority\nERRIP: CAN bus Error Interrupt Priority bit\n1 = High priority\n0\n= Low priority",
    "bit 4 When CAN is in Mode 0:\nTXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 1 or 2:\nTXBnIP: CAN Transmit Buffer Interrupt Priority bit\n1 = High priority\n0 = Low priority\nTXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1)\n1 = High priority\n0 = Low priority",
    "bit 2 TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1)\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 0:\nRXB1IP: CAN Receive Buffer 1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 1 or 2:\nRXBnIP:\nCAN Receive Buffer Interrupts Priority bit\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 0:\nRXB0IP: CAN Receive Buffer 0 Interrupt Priority bit\n1 = High priority\n0\n= Low priority\nWhen CAN is in Mode 1:\nUnimplemented: Read as ' 0 '\nWhen CAN is in Mode 2:\nFIFOWMIP: FIFO Watermark Interrupt Priority bit\n1 = High priority\n0 = Low priority\nNote 1: In CAN Mode 1 and 2, this bit is forced to ' 0 '.",
    "Legend:\nR = Readable bit\n- n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown\nbit 7\nbit 6",
    "bit 5\nbit 3",
    "9.5 RCON Register\nThe RCON register contains the IPEN bit which is used to  enable  prioritized  interrupts.  The  functions  of  the other bits in this register are discussed in more detail in\nSection 4.14 'RCON Register' .\nREGISTER 9-13:",
    "RCON REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R-1. R/W-0, 5 = R-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0\nbit 7 IPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16 Compatibility mode)\nbit 6-5 Unimplemented: Read as ' 0 '\nbit 4\nRI: RESET Instruction Flag bit\nFor details of bit operation, see Register 4-4.\nbit 3\nTO: Watchdog Time-out Flag bit\nFor details of bit operation, see Register 4-4.\nbit 2\nPD: Power-down Detection Flag bit",
    "RCON REGISTER\nFor details of bit operation, see Register 4-4.\nbit 1\nPOR: Power-on Reset Status bit\nFor details of bit operation, see Register 4-4.\nbit 0\nBOR: Brown-out Reset Status bit\nFor details of bit operation, see Register 4-4.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared x = Bit is unknown",
    "9.7 TMR0 Interrupt\nExternal interrupts on the RB0/INT0, RB1/INT1, RB2/ INT2 and RB3/INT3 pins are edge-triggered: either rising  if  the  corresponding  INTEDGx  bit  is  set  in  the INTCON2 register, or falling if the INTEDGx bit is clear. When a valid edge appears on the RBx/INTx pin, the corresponding flag bit, INTxF, is set. This interrupt can be disabled by clearing the corresponding enable bit, INTxE. Flag bit, INTxF, must be cleared in software in the  Interrupt  Service  Routine  before  re-enabling  the interrupt. All external interrupts (INT0, INT1, INT2 and INT3)  can  wake-up  the  processor  from  Sleep  if  bit INTxIE was set prior to going into Sleep. If the global interrupt enable bit GIE is set, the processor will branch to the interrupt vector following wake-up.",
    "9.7 TMR0 Interrupt\nThe interrupt priority for INT, INT2 and INT3 is determined by the value contained in the interrupt priority bits:  INT1IP  (INTCON3<6>),  INT2IP  (INTCON3<7>) and  INT3IP  (INTCON2<1>).  There  is  no  priority  bit associated  with  INT0;  it  is  always  a  high  priority interrupt source.\nIn 8-bit mode (which is the default), an overflow in the TMR0 register (0FFh \uf0ae\uf020 00h) will set flag bit TMR0IF. In 16-bit mode, an overflow in the TMR0H:TMR0L registers (0FFFFh \uf0ae\uf020 0000h) will set flag bit, TMR0IF. The interrupt  can  be  enabled/disabled  by  setting/clearing enable bit, TMR0IE (INTCON<5>). Interrupt priority for Timer0  is  determined  by  the  value  contained  in  the interrupt priority bit, TMR0IP  (INTCON2<2>).  See Section 11.0 'Timer0 Module' for  further  details  on the Timer0 module.",
    "9.8 PORTB Interrupt-on-Change\nAn input change  on  PORTB<7:4>  sets  flag  bit  RBIF (INTCON<0>). The interrupt can be enabled/disabled by  setting/clearing  enable  bit,  RBIE  (INTCON<3>). Interrupt  priority  for  PORTB  interrupt-on-change  is determined  by  the  value  contained  in  the  interrupt priority bit, RBIP (INTCON2<0>).",
    "9.9 Context Saving During Interrupts\nDuring an interrupt, the return PC value is saved on the stack. Additionally, the WREG, Status and BSR registers are saved on the fast return stack. If a fast return from interrupt is not used (See Section 4.3 'Fast Register Stack' ), the user may need to save the WREG, Status and BSR registers in software. Depending on the user's application, other registers may also need to be saved. Example 9-1 saves and restores the WREG, Status and BSR registers during an Interrupt Service Routine.",
    "EXAMPLE 9-1: SAVING STATUS, WREG AND BSR REGISTERS IN RAM\nMOVWF W_TEMP MOVFF STATUS, STATUS_TEMP MOVFF BSR, BSR_TEMP ; ; USER ISR CODE ; MOVFF BSR_TEMP, BSR MOVF W_TEMP, W MOVFF STATUS_TEMP,, 1 = ; W_TEMP is in virtual bank ; STATUS_TEMP located anywhere ; BSR located anywhere ; Restore BSR ; Restore WREG",
    "10.0 I/O PORTS\nDepending on the device selected, there are either seven or nine I/O ports available on PIC18F6X8X/8X8X devices. Some of their pins are multiplexed with one or more alternate functions from the other peripheral features  on  the  device.  In  general,  when  a  peripheral  is enabled, that pin may not be used as a general purpose I/O pin.\nEach port has three registers for its operation. These registers are:\n\u00b7 TRIS register (data direction register)\n\u00b7 PORT register (reads the levels on the pins of the device)\n\u00b7 LAT register (output latch)\nThe Data Latch register (LAT) is useful for read-modifywrite  operations  on  the  value  that  the  I/O  pins  are driving.\nA  simplified  version  of  a  generic  I/O  port  and  its operation is shown in Figure 10-1.",
    "10.1 PORTA, TRISA and LATA Registers\nPORTA is a 7-bit wide, bidirectional port.  The  corresponding  data  direction  register  is  TRISA.  Setting  a TRISA bit (= 1 ) will make the corresponding PORTA pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISA bit (= 0 ) will make the corresponding PORTA pin an output (i.e., put the contents of the output latch on the selected pin).\nReading the  PORTA register  reads  the  status  of  the pins, whereas writing to it will write to the port latch.\nThe  Data  Latch  register (LATA) is also memory mapped.  Read-modify-write  operations  on  the  LATA register  read  and  write  the  latched  output  value  for PORTA.\nThe  RA4  pin  is  multiplexed  with  the  Timer0  module clock input to become  the  RA4/T0CKI  pin. The RA4/T0CKI pin is a Schmitt Trigger input and an opendrain  output.  All  other  RA  port  pins  have  TTL  input levels and full CMOS output drivers.",
    "10.1 PORTA, TRISA and LATA Registers\nThe RA6 pin is only enabled as a general I/O pin in ECIO and RCIO Oscillator modes.\nThe  other  PORTA  pins  are  multiplexed  with  analog inputs  and  the  analog  VREF+  and  VREF-  inputs.  The operation of each pin is selected by clearing/setting the control  bits  in  the  ADCON1  register  (A/D  Control Register 1).\nNote:, 1 = On a Power-on Reset, RA5 and RA3:RA0 are configured as analog inputs and read as ' 0 '. RA6 and RA4 are configured as digital inputs.\nThe TRISA register controls the direction of the RA pins even when they are being used as analog inputs. The user  must  ensure  the  bits  in  the  TRISA  register  are maintained set when using them as analog inputs.",
    "EXAMPLE 10-1: INITIALIZING PORTA\nCLRF, 1 = PORTA. CLRF, 2 = ; Initialize PORTA by ; clearing output ; data latches. CLRF, 1 = LATA. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF MOVLW, 1 = 0Fh ADCON1 0CFh. MOVLW MOVWF MOVLW, 2 = ; Configure A/D ; for digital inputs ; Value used to ; initialize data. MOVWF, 1 = TRISA. MOVWF, 2 = ; Set RA<3:0> as inputs ; RA<5:4> as outputs",
    "TABLE 10-1: PORTA FUNCTIONS\nRA0/AN0, Bit# = bit 0. RA0/AN0, Buffer = TTL. RA0/AN0, Function = Input/output or analog input.. RA1/AN1, Bit# = bit 1. RA1/AN1, Buffer = TTL. RA1/AN1, Function = Input/output or analog input.. RA2/AN2/VREF-, Bit# = bit 2. RA2/AN2/VREF-, Buffer = TTL. RA2/AN2/VREF-, Function = Input/output or analog input or VREF-.. RA3/AN3/VREF+, Bit# = bit 3. RA3/AN3/VREF+, Buffer = TTL. RA3/AN3/VREF+, Function = Input/output or analog input or VREF+.. RA4/T0CKI, Bit# = bit 4. RA4/T0CKI, Buffer = ST/OD. RA4/T0CKI, Function = Input/output or external clock input for Timer0. Output is open-drain type..",
    "TABLE 10-1: PORTA FUNCTIONS\nRA5/AN4/LVDIN, Bit# = bit 5. RA5/AN4/LVDIN, Buffer = TTL. RA5/AN4/LVDIN, Function = Input/output or slave select input for synchronous serial port or analog input, or Low-Voltage Detect input.. OSC2/CLKO/RA6, Bit# = bit 6. OSC2/CLKO/RA6, Buffer = TTL. OSC2/CLKO/RA6, Function = OSC2 or clock output, or I/O pin.\nLegend: TTL = TTL input, ST = Schmitt Trigger input",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nPORTA, Bit 7 = -. PORTA, Bit 6 = RA6. PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR = -x0x 0000. PORTA, Value on all other Resets = -u0u 0000. LATA, Bit 7 = -. LATA, Bit 6 = LATA Data Output Register. LATA, Bit 5 = LATA Data Output Register. LATA, Bit 4 = LATA Data Output Register. LATA, Bit 3 = LATA Data Output Register. LATA, Bit 2 = LATA Data Output Register. LATA, Bit 1 = LATA Data Output Register. LATA, Bit 0 = . LATA, Value on POR, BOR = -xxx xxxx. LATA, Value on all other Resets = -uuu uuuu. TRISA, Bit 7 = -. TRISA, Bit 6 = PORTA Data",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nDirection Register. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = . TRISA, Value on POR, BOR = -111 1111. TRISA, Value on all other Resets = -111 1111. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = --00 0000. ADCON1, Value on all other Resets = --00 0000\nLegend:",
    "TABLE 10-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nx = unknown, u = unchanged, - = unimplemented locations read as ' 0 '. Shaded cells are not used by PORTA.",
    "10.2 PORTB, TRISB and LATB Registers\nA mismatch condition will continue to set flag bit, RBIF. Reading PORTB will end the mismatch condition and allow flag bit RBIF to be cleared.\nPORTB is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISB.  Setting  a TRISB bit (= 1 )  will  make the corresponding PORTB pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISB bit (= 0 ) will make the corresponding PORTB pin an output (i.e., put the contents of the output latch on the selected pin).\nThe Data Latch register (LATB) is also memory mapped. Read-modify-write operations on the LATB register read and write the latched output value for PORTB.",
    "EXAMPLE 10-2: INITIALIZING PORTB\nCLRF, 1 = PORTB. CLRF, 2 = ; Initialize PORTB by ; clearing output ; data latches. CLRF, 1 = LATB. CLRF, 2 = ; Alternate method ; to clear output. MOVLW, 1 = 0CFh. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISB. MOVWF, 2 = ; Set RB<3:0> as inputs ; RB<5:4> as outputs ; RB<7:6> as inputs\nEach of the PORTB pins has a weak internal pull-up. A single control bit can  turn on  all  the  pull-ups.  This  is performed by clearing bit RBPU (INTCON2<7>). The weak pull-up is automatically turned off when the port pin is configured  as  an  output.  The  pull-ups  are disabled on a Power-on Reset.\nNote: On  a  Power-on  Reset,  these  pins  are configured as digital inputs.",
    "EXAMPLE 10-2: INITIALIZING PORTB\nFour of the PORTB pins (RB3:RB0) are the external interrupt pins, INT3 through INT0. In order to use these pins as external  interrupts, the corresponding TRISB bit must be set to ' 1 '.\nThe  other  four PORTB  pins  (RB7:RB4)  have  an interrupt-on-change  feature.  Only  pins  configured  as inputs  can  cause  this  interrupt  to  occur  (i.e.,  any RB7:RB4 pin configured as an output is excluded from the interrupt-on-change comparison). The input pins (of RB7:RB4) are compared with the old value latched on the  last  read  of  PORTB.  The  'mismatch'  outputs  of RB7:RB4 are OR'ed together to generate the RB port change interrupt with flag bit, RBIF (INTCON<0>).\nThis  interrupt  can  wake  the  device  from  Sleep.  The user,  in  the  Interrupt  Service  Routine,  can  clear  the interrupt in the following manner:\na) Any  read  or  write  of  PORTB  (except  with  the MOVFF instruction). This will end the mismatch condition.\nb) Clear flag bit RBIF.",
    "EXAMPLE 10-2: INITIALIZING PORTB\nThe interrupt-on-change  feature  is  recommended  for wake-up on key depression operation and operations where PORTB is only used for the interrupt-on-change feature. Polling of PORTB is not recommended while using the interrupt-on-change feature.\nFor PIC18FXX85 devices, RB3 can be configured by the configuration bit, CCP2MX, as the alternate peripheral pin for the CCP2 module. This is only available when the device is configured in Microprocessor, Microprocessor with Boot Block, or Extended Microcontroller Operating modes.\nThe  RB5  pin  is  used  as  the  LVP  programming  pin. When the LVP configuration bit is programmed, this pin loses the I/O function and becomes a programming test function.\nNote:\nWhen LVP is enabled, the weak pull-up on RB5 is disabled.",
    "FIGURE 10-5: BLOCK DIAGRAM OF RB7:RB4 PINS\nNote 1: I/O pins have diode protection to VDD and VSS.\n- 2: To enable weak pull-ups, set the appropriate TRIS bit(s) and clear the RBPU bit (INTCON2<7>).",
    "FIGURE 10-7: BLOCK DIAGRAM OF RB3 PIN\n2: To enable weak pull-ups, set the appropriate TRIS bit(s) and clear the RBPU bit (INTCON2<7>).\n3: For PIC18FXX85 parts, the CCP2 input/output is multiplexed with RB3 if the CCP2MX bit is enabled (= 0 ) in the Configuration register and the device is operating in Microprocessor, Microprocessor with Boot Block or Extended Microcontroller mode.",
    "TABLE 10-3: PORTB FUNCTIONS\nRB0/INT0, Bit# = bit 0. RB0/INT0, Buffer = TTL/ST (1). RB0/INT0, Function = Input/output pin or external interrupt input 0. Internal software programmable weak pull-up.. RB1/INT1, Bit# = bit 1. RB1/INT1, Buffer = TTL/ST (1). RB1/INT1, Function = Input/output pin or external interrupt input 1. Internal software programmable weak pull-up.. RB2/INT2, Bit# = bit 2. RB2/INT2, Buffer = TTL/ST (1). RB2/INT2, Function = Input/output pin or external interrupt input 2. Internal software programmable weak pull-up.. RB3/INT3/CCP2 (3), Bit# = bit 3. RB3/INT3/CCP2 (3), Buffer = TTL/ST (4). RB3/INT3/CCP2 (3), Function = Input/output pin or external interrupt input 3. Capture 2 input/ Compare 2 output/PWM output",
    "TABLE 10-3: PORTB FUNCTIONS\n(when CCP2MX configuration bit is enabled, all PIC18FXX85 operating modes except Microcontroller mode). Internal software programmable weak pull-up.. RB4/KBI0, Bit# = bit 4. RB4/KBI0, Buffer = TTL. RB4/KBI0, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up.. RB5/KBI1/PGM, Bit# = bit 5. RB5/KBI1/PGM, Buffer = TTL/ST (2). RB5/KBI1/PGM, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Low-voltage ICSP enable pin.. RB6/KBI2/PGC, Bit# = bit 6. RB6/KBI2/PGC, Buffer = TTL/ST (2). RB6/KBI2/PGC, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Serial programming clock..",
    "TABLE 10-3: PORTB FUNCTIONS\nRB7/KBI3/PGD, Bit# = bit 7. RB7/KBI3/PGD, Buffer = TTL/ST (2). RB7/KBI3/PGD, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Serial programming data.\nLegend:\nTTL = TTL input, ST = Schmitt Trigger input\nNote 1: This buffer is a Schmitt Trigger input when configured as the external interrupt.\n2: This buffer is a Schmitt Trigger input when used in Serial Programming mode.\n3: RC1 is the alternate assignment for CCP2 when CCP2MX is not set (all operating modes except Microcontroller mode).\n4: This buffer is a Schmitt Trigger input when configured as the CCP2 input.",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nPORTB, Bit 7 = RB7. PORTB, Bit 6 = RB6. PORTB, Bit 5 = RB5. PORTB, Bit 4 = RB4. PORTB, Bit 3 = RB3. PORTB, Bit 2 = RB2. PORTB, Bit 1 = RB1. PORTB, Bit 0 = RB0. PORTB, Value on POR, BOR = xxxx xxxx. PORTB, Value on all other Resets = uuuu uuuu. LATB, Bit 7 = LATB Data Output Register. LATB, Bit 6 = LATB Data Output Register. LATB, Bit 5 = LATB Data Output Register. LATB, Bit 4 = LATB Data Output Register. LATB, Bit 3 = LATB Data Output Register. LATB, Bit 2 = LATB Data Output Register. LATB, Bit 1 = LATB Data Output Register. LATB, Bit 0 = LATB Data Output Register. LATB, Value on POR, BOR = xxxx xxxx. LATB, Value on all other Resets",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\n= uuuu uuuu. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR = 1111 1111. TRISB, Value on all other Resets = 1111 1111. INTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 0000. INTCON, Value on all other",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nResets = 0000 0000. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = INTEDG2. INTCON2, Bit 3 = INTEDG3. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = INT3IP. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 1111 1111. INTCON2, Value on all other Resets = 1111 1111. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = INT3IE. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = INT3IF. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 1100 0000. INTCON3, Value on all other",
    "TABLE 10-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nResets = 1100 0000\nLegend:\nx = unknown, u = unchanged. Shaded cells are not used by PORTB.",
    "10.3 PORTC, TRISC and LATC Registers\nPORTC is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISC.  Setting  a TRISC bit (= 1 )  will  make the corresponding PORTC pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISC bit (= 0 ) will make the corresponding PORTC pin an output (i.e., put the contents of the output latch on the selected pin).\nThe Data Latch register (LATC) is also memory mapped. Read-modify-write operations on the LATC register read and write the latched output value for PORTC.\nPORTC is multiplexed with several peripheral functions (Table 10-5). PORTC pins have Schmitt Trigger input buffers.\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTC pin. Some peripherals  override  the  TRIS  bit  to  make  a  pin  an output, while other peripherals override the TRIS bit to make a pin an input. The user should refer to the corresponding  peripheral  section  for  the  correct  TRIS  bit settings.",
    "10.3 PORTC, TRISC and LATC Registers\nThe pin override value is not loaded into the TRIS register. This allows read-modify-write of the TRIS register without concern due to peripheral overrides.\nRC1  is normally configured by configuration bit, CCP2MX, as the default peripheral pin  of  the  CCP2 module (default/erased state, CCP2MX = 1 ).",
    "EXAMPLE 10-3: INITIALIZING PORTC\nCLRF, 1 = PORTC. CLRF, 2 = ; Initialize PORTC by ; clearing output ; data latches. CLRF, 1 = LATC. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0CFh. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISC. MOVWF, 2 = ; Set RC<3:0> as inputs ; RC<5:4> as outputs ; RC<7:6> as inputs\nNote:, 1 = On a Power-on Reset, these pins are configured as digital inputs.",
    "TABLE 10-5: PORTC FUNCTIONS\nRC0/T1OSO/T13CKI, Bit# = bit 0. RC0/T1OSO/T13CKI, Buffer Type = ST. RC0/T1OSO/T13CKI, Function = Input/output port pin, Timer1 oscillator output or Timer1/Timer3 clock input.. RC1/T1OSI/CCP2 (1), Bit# = bit 1. RC1/T1OSI/CCP2 (1), Buffer Type = ST. RC1/T1OSI/CCP2 (1), Function = Input/output port pin, Timer1 oscillator input or Capture 2 input/ Compare 2 output/PWM output (when CCP2MX configuration bit is disabled).. RC2/CCP1/P1A, Bit# = bit 2. RC2/CCP1/P1A, Buffer Type = ST. RC2/CCP1/P1A, Function = Input/output port pin or Capture 1 input/Compare 1 output/ PWM1 output.. RC3/SCK/SCL, Bit# = bit 3.",
    "TABLE 10-5: PORTC FUNCTIONS\nRC3/SCK/SCL, Buffer Type = ST. RC3/SCK/SCL, Function = RC3 can also be the synchronous serial clock for both SPI and I 2 C modes.. RC4/SDI/SDA, Bit# = bit 4. RC4/SDI/SDA, Buffer Type = ST. RC4/SDI/SDA, Function = RC4 can also be the SPI data in (SPI mode) or data I/O (I 2 C mode).. RC5/SDO, Bit# = bit 5. RC5/SDO, Buffer Type = ST. RC5/SDO, Function = Input/output port pin or synchronous serial port data output.. RC6/TX/CK, Bit# = bit 6. RC6/TX/CK, Buffer Type = ST. RC6/TX/CK, Function = Input/output port pin, addressable USART asynchronous transmit or addressable USART synchronous clock.. RC7/RX/DT, Bit# = bit 7. RC7/RX/DT, Buffer",
    "TABLE 10-5: PORTC FUNCTIONS\nType = ST. RC7/RX/DT, Function = Input/output port pin, addressable USART asynchronous receive or addressable USART synchronous data.\nLegend: ST = Schmitt Trigger input\nNote 1: RB3 is the alternate assignment for CCP2 when CCP2MX is set.",
    "TABLE 10-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nPORTC, Bit 7 = RC7. PORTC, Bit 6 = RC6. PORTC, Bit 5 = RC5. PORTC, Bit 4 = RC4. PORTC, Bit 3 = RC3. PORTC, Bit 2 = RC2. PORTC, Bit 1 = RC1. PORTC, Bit 0 = RC0. PORTC, Value on POR, BOR = xxxx. PORTC, all other Resets = xxxx. PORTC, Value on = uuuu. PORTC, Value on = uuuu. LATC, Bit 7 = LATC Data Output Register. LATC, Bit 6 = LATC Data Output Register. LATC, Bit 5 = LATC Data Output Register. LATC, Bit 4 = LATC Data Output Register. LATC, Bit 3 = LATC Data Output Register. LATC, Bit 2 = LATC Data Output Register. LATC, Bit 1 = LATC Data Output Register. LATC, Bit 0 = LATC Data Output Register. LATC, Value on POR, BOR = xxxx. LATC, all other Resets = xxxx. LATC, Value on =",
    "TABLE 10-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nuuuu. LATC, Value on = uuuu. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, all other Resets = 1111. TRISC, Value on = 1111. TRISC, Value on = 1111\nLegend: x = unknown, u = unchanged",
    "10.4 PORTD, TRISD and LATD Registers\nPORTD is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISD.  Setting  a TRISD bit (= 1 )  will  make the corresponding PORTD pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISD bit (= 0 ) will make the corresponding PORTD pin an output (i.e., put the contents of the output latch on the selected pin).\nThe Data Latch register (LATD) is also memory mapped. Read-modify-write operations on the LATD register read and write the latched output value for PORTD.\nPORTD  is  an  8-bit  port  with  Schmitt  Trigger  input buffers. Each pin is individually configurable as an input or output.\nNote:, 1 = On a Power-on Reset, these pins are configured as digital inputs.",
    "10.4 PORTD, TRISD and LATD Registers\nOn PIC18F8X8X devices, PORTD is multiplexed with the system bus as the external memory interface; I/O port functions are only available when the system bus is disabled by setting the EBDIS bit in the MEMCOM register (MEMCON<7>). When operating as the external memory interface, PORTD is the low-order byte of the multiplexed address/data bus (AD7:AD0).\nPORTD can also be configured as an 8-bit wide microprocessor port (Parallel Slave Port) by setting control bit,  PSPMODE  (TRISE<4>).  In  this  mode,  the  input buffers  are  TTL.  See Section 10.10  'Parallel  Slave Port (PSP)' for additional information.",
    "EXAMPLE 10-4: INITIALIZING PORTD\nCLRF, 1 = PORTD. CLRF, 2 = ; Initialize PORTD by ; clearing output ; data latches. CLRF, 1 = LATD. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0CFh. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISD. MOVWF, 2 = ; Set RD<3:0> as inputs ; RD<5:4> as outputs ; RD<7:6> as inputs",
    "TABLE 10-7: PORTD FUNCTIONS\nRD0/PSP0/AD0 (2), Bit# = bit 0. RD0/PSP0/AD0 (2), Buffer Type = ST/TTL (1). RD0/PSP0/AD0 (2), Function = Input/output port pin, Parallel Slave Port bit 0 or address/data bus bit 0.. RD1/PSP1/AD1 (2), Bit# = bit 1. RD1/PSP1/AD1 (2), Buffer Type = ST/TTL (1). RD1/PSP1/AD1 (2), Function = Input/output port pin, Parallel Slave Port bit 1 or address/data bus bit 1.. RD2/PSP2/AD2 (2), Bit# = bit 2. RD2/PSP2/AD2 (2), Buffer Type = ST/TTL (1). RD2/PSP2/AD2 (2), Function = Input/output port pin, Parallel Slave Port bit 2 or address/data bus bit 2.. RD3/PSP3/AD3 (2),",
    "TABLE 10-7: PORTD FUNCTIONS\nBit# = bit 3. RD3/PSP3/AD3 (2), Buffer Type = ST/TTL (1). RD3/PSP3/AD3 (2), Function = Input/output port pin, Parallel Slave Port bit 3 or address/data bus bit 3.. RD4/PSP4/AD4 (2), Bit# = bit 4. RD4/PSP4/AD4 (2), Buffer Type = ST/TTL (1). RD4/PSP4/AD4 (2), Function = Input/output port pin, Parallel Slave Port bit 4 or address/data bus bit 4.. RD5/PSP5/AD5 (2), Bit# = bit 5. RD5/PSP5/AD5 (2), Buffer Type = ST/TTL (1). RD5/PSP5/AD5 (2), Function = Input/output port pin, Parallel Slave Port bit 5 or address/data bus bit 5.. RD6/PSP6/AD6 (2), Bit# = bit 6.",
    "TABLE 10-7: PORTD FUNCTIONS\nRD6/PSP6/AD6 (2), Buffer Type = ST/TTL (1). RD6/PSP6/AD6 (2), Function = Input/output port pin, Parallel Slave Port bit 6 or address/data bus bit 6.. RD7/PSP7/AD7 (2), Bit# = bit 7. RD7/PSP7/AD7 (2), Buffer Type = ST/TTL (1). RD7/PSP7/AD7 (2), Function = Input/output port pin, Parallel Slave Port bit 7 or address/data bus bit 7.\nLegend: ST = Schmitt Trigger input, TTL = TTL input\nNote 1: Input buffers are Schmitt Triggers when in I/O mode and TTL buffers when in System Bus or Parallel Slave Port mode.\n2: Available in PIC18F8X8X devices only.",
    "TABLE 10-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nPORTD, Bit 7 = RD7. PORTD, Bit 6 = RD6. PORTD, Bit 5 = RD5. PORTD, Bit 4 = RD4. PORTD, Bit 3 = RD3. PORTD, Bit 2 = RD2. PORTD, Bit 1 = RD1. PORTD, Bit 0 = RD0. PORTD, Value on POR, BOR = xxxx. PORTD, Value on POR, BOR = xxxx. PORTD, Value on all other Resets = uuuu. PORTD, Value on all other Resets = uuuu. LATD, Bit 7 = LATD Data Output Register. LATD, Bit 6 = LATD Data Output Register. LATD, Bit 5 = LATD Data Output Register. LATD, Bit 4 = LATD Data Output Register. LATD, Bit 3 = LATD Data Output Register. LATD, Bit 2 = LATD Data Output Register. LATD, Bit 1 = LATD Data Output Register. LATD, Bit 0 = LATD Data Output Register. LATD,",
    "TABLE 10-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nValue on POR, BOR = xxxx. LATD, Value on POR, BOR = xxxx. LATD, Value on all other Resets = uuuu. LATD, Value on all other Resets = uuuu. TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Value on POR, BOR = 1111. TRISD, Value on POR, BOR = 1111. TRISD, Value on all other Resets = 1111. TRISD, Value on all other Resets = 1111. PSPCON, Bit 7 = IBF. PSPCON, Bit 6 = OBF. PSPCON, Bit 5 = IBOV. PSPCON, Bit 4 =",
    "TABLE 10-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nPSPMODE. PSPCON, Bit 3 = -. PSPCON, Bit 2 = -. PSPCON, Bit 1 = -. PSPCON, Bit 0 = -. PSPCON, Value on POR, BOR = 0000. PSPCON, Value on POR, BOR = ----. PSPCON, Value on all other Resets = 0000. PSPCON, Value on all other Resets = ----. MEMCON, Bit 7 = EBDIS. MEMCON, Bit 6 = -. MEMCON, Bit 5 = WAIT1. MEMCON, Bit 4 = WAIT0. MEMCON, Bit 3 = -. MEMCON, Bit 2 = -. MEMCON, Bit 1 = WM1. MEMCON, Bit 0 = WM0. MEMCON, Value on POR, BOR = 0-00. MEMCON, Value on POR, BOR = --00. MEMCON, Value on all other Resets = 0-00. MEMCON, Value on all other Resets = --00",
    "TABLE 10-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nLegend: x = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by PORTD.",
    "10.5 PORTE, TRISE and LATE Registers\nPORTE is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISE.  Setting  a TRISE bit (= 1 )  will  make the corresponding PORTE pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISE bit (= 0 ) will make the corresponding PORTE pin an output (i.e., put the contents of the output latch on the selected pin).\nRead-modify-write  operations  on  the  LATE  register read and write the latched output value for PORTE.\nPORTE  is  an  8-bit  port  with  Schmitt  Trigger  input buffers. Each pin is individually configurable as an input or  output.  PORTE  is  multiplexed  with  the  Enhanced CCP module (Table 10-9).",
    "10.5 PORTE, TRISE and LATE Registers\nOn  PIC18F8X8X  devices,  PORTE  is  also  multiplexed with the system bus as the external memory interface; the  I/O  bus  is  available  only  when  the  system  bus  is disabled  by  setting  the  EBDIS  bit  in  the  MEMCON register  (MEMCON<7>).  If  the  device  is  configured  in Microprocessor or Extended Microcontroller mode, then the PORTE<7:0> becomes the high byte of the address/ data bus for the external program memory interface. In Microcontroller mode, the PORTE<2:0> pins become the control  inputs  for the  Parallel  Slave  Port  when  bit PSPMODE (PSPCON<4>) is set. (Refer to Section 4.1.1 'PIC18F8X8X Program Memory Modes' for more  information  on  program  memory modes.)",
    "10.5 PORTE, TRISE and LATE Registers\nWhen the Parallel Slave Port is active, three PORTE pins (RE0/RD/AD8, RE1/WR/AD9 and RE2/CS/AD10) function as its control inputs. This automatically occurs when the PSPMODE bit (PSPCON<4>) is set. Users must also make certain that bits TRISE<2:0> are set to configure the pins as digital inputs and the ADCON1 register is configured for digital I/O. The PORTE PSP control functions are summarized in Table 10-9.\nPin RE7 can be configured as the alternate peripheral pin for the CCP2 module when the device is operating in Microcontroller mode. This is done by clearing the configuration  bit,  CCP2MX,  in  configuration  register, CONFIG3H (CONFIG3H<0>).\nNote:, 1 = For PIC18F8X8X (80-pin) devices operat- ing in other than Microcontroller mode, PORTE defaults to the system bus on Power-on Reset.",
    "EXAMPLE 10-5: INITIALIZING PORTE\nCLRF, 1 = PORTE. CLRF, 2 = ; Initialize PORTE by ; clearing output ; data latches. CLRF, 1 = LATE. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 03h. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISE. MOVWF, 2 = ; Set RE1:RE0 as inputs ; RE7:RE2 as outputs",
    "TABLE 10-9: PORTE FUNCTIONS\nRE0/RD/AD8 (2), Bit# = bit 0. RE0/RD/AD8 (2), Buffer Type = ST/TTL (1). RE0/RD/AD8 (2), Function = Input/output port pin, read control for Parallel Slave Port or address/data bit 8. For RD (PSP Control mode): 1 = Not a read operation 0 = Read operation, reads PORTD register (if chip selected). RE1/WR/AD9 (2), Bit# = bit 1. RE1/WR/AD9 (2), Buffer Type = ST/TTL (1). RE1/WR/AD9 (2), Function = Input/output port pin, write control for Parallel Slave Port or address/data bit 9. For WR (PSP Control mode): 1 = Not a write operation 0 = Write operation, writes PORTD register (if chip selected). RE2/CS/AD10 (2), Bit# = bit 2. RE2/CS/AD10 (2), Buffer Type = ST/TTL (1). RE2/CS/AD10",
    "TABLE 10-9: PORTE FUNCTIONS\n(2), Function = Input/output port pin, chip select control for Parallel Slave Port or address/data bit 10. For CS (PSP Control mode): 1 = Device is not selected 0 = Device is selected. RE3/AD11 (2), Bit# = bit 3. RE3/AD11 (2), Buffer Type = ST/TTL (1). RE3/AD11 (2), Function = Input/output port pin or address/data bit 11.. RE4/AD12 (2), Bit# = bit 4. RE4/AD12 (2), Buffer Type = ST/TTL (1). RE4/AD12 (2), Function = Input/output port pin or address/data bit 12.. RE5/AD13/ (2) P1C (3), Bit# = bit 5. RE5/AD13/ (2) P1C (3), Buffer Type = ST/TTL (1). RE5/AD13/ (2) P1C (3), Function = Input/output port pin, address/data bit 13 or ECCP1",
    "TABLE 10-9: PORTE FUNCTIONS\nPWM output C.. RE6/AD14/ (2) P1B (3), Bit# = bit 6. RE6/AD14/ (2) P1B (3), Buffer Type = ST/TTL (1). RE6/AD14/ (2) P1B (3), Function = Input/output port pin, address/data bit 13 or ECCP1 PWM output B.. RE7/CCP2/AD15 (2), Bit# = bit 7. RE7/CCP2/AD15 (2), Buffer Type = ST/TTL (1). RE7/CCP2/AD15 (2), Function = Input/output port pin, Capture 2 input/Compare 2 output/PWM output (PIC18F8X20 devices in Microcontroller mode only) or address/data bit 15.\nLegend: ST = Schmitt Trigger input, TTL = TTL input",
    "TABLE 10-9: PORTE FUNCTIONS\nNote 1: Input buffers are Schmitt Triggers when in I/O or CCP mode, and TTL buffers when in System Bus or PSP Control mode.\n2: Available in PIC18F8X8X devices only.\n3: On PIC18F8X8X devices, these pins may be moved to RHY or RH6 by changing the ECCPMX configuration bit.",
    "TABLE 10-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nTRISE, Bit 7 = PORTE Data Direction Control Register. TRISE, Bit 6 = PORTE Data Direction Control Register. TRISE, Bit 5 = PORTE Data Direction Control Register. TRISE, Bit 4 = PORTE Data Direction Control Register. TRISE, Bit 3 = PORTE Data Direction Control Register. TRISE, Bit 2 = PORTE Data Direction Control Register. TRISE, Bit 1 = PORTE Data Direction Control Register. TRISE, Bit 0 = PORTE Data Direction Control Register. TRISE, Value on: POR, BOR = 1111. TRISE, all other = 1111. TRISE, Value Resets = 1111. TRISE, on = 1111. PORTE, Bit 7 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 6 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 5 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 4 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 3 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 2 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 1 = Read PORTE pin/Write PORTE Data Latch. PORTE, Bit 0 = Read PORTE pin/Write",
    "TABLE 10-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nPORTE Data Latch. PORTE, Value on: POR, BOR = xxxx. PORTE, all other = xxxx. PORTE, Value Resets = uuuu. PORTE, on = uuuu. LATE, Bit 7 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 6 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 5 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 4 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 3 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 2 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 1 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Bit 0 = Read PORTE Data Latch/Write PORTE Data Latch. LATE, Value on: POR, BOR = xxxx. LATE, all other = xxxx. LATE, Value Resets = uuuu. LATE, on = uuuu. MEMCON, Bit 7 = EBDIS. MEMCON, Bit 6 = -. MEMCON, Bit 5 = WAIT1. MEMCON, Bit 4 =",
    "TABLE 10-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nWAIT0. MEMCON, Bit 3 = -. MEMCON, Bit 2 = -. MEMCON, Bit 1 = WM1. MEMCON, Bit 0 = WM0. MEMCON, Value on: POR, BOR = 0-00. MEMCON, all other = --00. MEMCON, Value Resets = 0000. MEMCON, on = --00. PSPCON, Bit 7 = IBF. PSPCON, Bit 6 = OBF. PSPCON, Bit 5 = IBOV. PSPCON, Bit 4 = PSPMODE. PSPCON, Bit 3 = -. PSPCON, Bit 2 = -. PSPCON, Bit 1 = -. PSPCON, Bit 0 = -. PSPCON, Value on: POR, BOR = 0000. PSPCON, all other = ----. PSPCON, Value Resets = 0000. PSPCON, on = ----\nLegend: x = unknown, u = unchanged. Shaded cells are not used by PORTE.",
    "EXAMPLE 10-6: INITIALIZING PORTF\nPORTF is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISF.  Setting  a TRISF bit (= 1 ) will make the corresponding PORTF pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISF bit (= 0 ) will make the corresponding PORTF pin an output (i.e., put the contents of the output latch on the selected pin).\nRead-modify-write  operations  on  the  LATF  register read and write the latched output value for PORTF.\nPORTF is multiplexed with several analog peripheral functions, including the A/D  converter  inputs  and comparator inputs, outputs, and voltage reference.\nNote 1: On a Power-on Reset, the RF6:RF0 pins are configured as inputs and read as ' 0 '.\n2: To configure PORTF as digital I/O, turn off comparators and set ADCON1 value.",
    "EXAMPLE 10-6: INITIALIZING PORTF\nCLRF, 1 = PORTF. CLRF, 2 = ; Initialize PORTF by ; clearing output ; data latches. CLRF, 1 = LATF. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF MOVLW MOVWF MOVLW, 1 = 07h CMCON 0Fh 0CFh. MOVLW MOVWF MOVLW MOVWF MOVLW, 2 = ; ; Turn off comparators ; ;. MOVWF, 1 = ADCON1. MOVWF, 2 = Set PORTF as digital I/O ; Value used to ; initialize data ; direction Set RF3:RF0 as inputs RF5:RF4 as outputs. , 1 = TRISF. , 2 = ; ; ; RF7:RF6 as inputs",
    "TABLE 10-11: PORTF FUNCTIONS\nRF0/AN5, Bit# = bit 0. RF0/AN5, Buffer Type = ST. RF0/AN5, Function = Input/output port pin or analog input.. RF1/AN6/C2OUT, Bit# = bit 1. RF1/AN6/C2OUT, Buffer Type = ST. RF1/AN6/C2OUT, Function = Input/output port pin, analog input or comparator 2 output.. RF2/AN7/C1OUT, Bit# = bit 2. RF2/AN7/C1OUT, Buffer Type = ST. RF2/AN7/C1OUT, Function = Input/output port pin, analog input or comparator 1 output.. RF3/AN8/C2IN+, Bit# = bit 3. RF3/AN8/C2IN+, Buffer Type = ST. RF3/AN8/C2IN+, Function = Input/output port pin, analog input or comparator 2 input (+).. RF4/AN9/C2IN-, Bit# = bit 4. RF4/AN9/C2IN-, Buffer Type = ST.",
    "TABLE 10-11: PORTF FUNCTIONS\nRF4/AN9/C2IN-, Function = Input/output port pin, analog input or comparator 2 input (-).. RF5/AN10/ C1IN+/CVREF, Bit# = bit 5. RF5/AN10/ C1IN+/CVREF, Buffer Type = ST. RF5/AN10/ C1IN+/CVREF, Function = Input/output port pin, analog input, comparator 1 input (+) or comparator reference output.. RF6/AN11/C1IN-, Bit# = bit 6. RF6/AN11/C1IN-, Buffer Type = ST. RF6/AN11/C1IN-, Function = Input/output port pin, analog input or comparator 1 input (-).. RF7/SS, Bit# = bit 7. RF7/SS, Buffer Type = ST/TTL. RF7/SS, Function = Input/output port pin or slave select pin for synchronous serial port.\nLegend: ST = Schmitt Trigger input, TTL = TTL input",
    "TABLE 10-12: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nTRISF, Bit 7 = PORTF Data Direction Control Register. TRISF, Bit 6 = PORTF Data Direction Control Register. TRISF, Bit 5 = PORTF Data Direction Control Register. TRISF, Bit 4 = PORTF Data Direction Control Register. TRISF, Bit 3 = PORTF Data Direction Control Register. TRISF, Bit 2 = PORTF Data Direction Control Register. TRISF, Bit 1 = PORTF Data Direction Control Register. TRISF, Bit 0 = PORTF Data Direction Control Register. TRISF, Value on: POR, BOR = 1111. TRISF, Value on: POR, BOR = 1111. TRISF, Value on all other Resets = 1111. TRISF, Value on all other Resets = 1111. PORTF, Bit 7 = Read PORTF pin/Write PORTF Data Latch. PORTF, Bit 6 = Read PORTF pin/Write PORTF Data Latch. PORTF, Bit 5 = Read PORTF pin/Write PORTF Data Latch. PORTF, Bit 4 = Read PORTF pin/Write PORTF Data Latch. PORTF, Bit 3 = Read PORTF pin/Write PORTF Data Latch.",
    "TABLE 10-12: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nPORTF, Bit 2 = Read PORTF pin/Write PORTF Data Latch. PORTF, Bit 1 = Read PORTF pin/Write PORTF Data Latch. PORTF, Bit 0 = Read PORTF pin/Write PORTF Data Latch. PORTF, Value on: POR, BOR = xxxx. PORTF, Value on: POR, BOR = xxxx. PORTF, Value on all other Resets = uuuu. PORTF, Value on all other Resets = uuuu. LATF, Bit 7 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 6 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 5 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 4 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 3 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 2 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 1 = Read PORTF Data Latch/Write PORTF Data Latch. LATF, Bit 0 = Read PORTF",
    "TABLE 10-12: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nData Latch/Write PORTF Data Latch. LATF, Value on: POR, BOR = 0000. LATF, Value on: POR, BOR = 0000. LATF, Value on all other Resets = uuuu. LATF, Value on all other Resets = uuuu. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on: POR, BOR = --00. ADCON1, Value on: POR, BOR = 0000. ADCON1, Value on all other Resets = --00. ADCON1, Value on all other Resets = 0000. CMCON, Bit 7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 =",
    "TABLE 10-12: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\nC2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Value on: POR, BOR = 0000. CMCON, Value on: POR, BOR = 0000. CMCON, Value on all other Resets = 0000. CMCON, Value on all other Resets = 0000. CVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0. CVRCON, Value on: POR, BOR = 0000. CVRCON, Value on: POR, BOR = 0000. CVRCON, Value on all other Resets = 0000. CVRCON, Value on all other Resets =",
    "TABLE 10-12: SUMMARY OF REGISTERS ASSOCIATED WITH PORTF\n0000\nLegend: x = unknown, u = unchanged. Shaded cells are not used by PORTF.",
    "10.7 PORTG, TRISG and LATG Registers\nThe pin override value is not loaded into the TRIS register. This allows read-modify-write of the TRIS register without concern due to peripheral overrides.\nPORTG is a 6-bit wide port with 5 bidirectional pins and 1 unidirectional pin. The corresponding data direction register is TRISG. Setting a TRISG bit (= 1 ) will make the  corresponding  PORTG pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISG bit (= 0 ) will make the corresponding PORTG pin an output (i.e., put the contents of the output latch on the selected pin).\nThe Data Latch register (LATG) is also memory mapped. Read-modify-write operations on the LATG register read and write the latched output value for PORTG.",
    "10.7 PORTG, TRISG and LATG Registers\nPins RG0-RG2 on PORTG are multiplexed with the CAN peripheral. Refer to Section 23.0 'ECAN Module' for proper settings of TRISG when CAN is enabled. RG5 is multiplexed with MCLR/VPP. Refer to Register 24-5 for more information.\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTG pin. Some peripherals override the TRIS bit to make a pin an output, while other peripherals override the TRIS bit to make a pin an input. The user should refer to the corresponding peripheral section for the correct TRIS bit settings.\nNote: On  a  Power-on  Reset,  these  pins  are configured as digital inputs.",
    "EXAMPLE 10-7: INITIALIZING PORT\nCLRF, 1 = PORTG. CLRF, 2 = ; Initialize PORTG by ; clearing output ; data latches. CLRF, 1 = LATG. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 04h. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISG. MOVWF, 2 = ; Set RG1:RG0 as outputs ; RG2 as input ; RG4:RG3 as inputs\nNote 1: On a Power-on Reset, RG5 is enabled as a digital input only if Master Clear functionality is disabled (MCLRE = 0 ).\n2: If  the  device  Master  Clear  is  disabled, verify that either of the following is done to ensure proper entry into ICSP mode:\na) disable  Low-Voltage  Programming (CONFIG4L<2> = 0 ); or\nb) make certain that RB5/KBI1/PGM is held low during entry into ICSP.",
    "FIGURE 10-17: RG1/CANTX2 PIN BLOCK DIAGRAM\nFIGURE 10-18: RG2/CANRX PIN BLOCK DIAGRAM\nFIGURE 10-19:\nRG3 PIN BLOCK\nDIAGRAM",
    "TABLE 10-13: PORTG FUNCTIONS\nRG0/CANTX1, Bit# = bit 0. RG0/CANTX1, Buffer Type = ST. RG0/CANTX1, Function = Input/output port pin or CAN bus transmit output.. RG1/CANTX2, Bit# = bit 1. RG1/CANTX2, Buffer Type = ST. RG1/CANTX2, Function = Input/output port pin, CAN bus complimentary transmit output or CAN bus bit time clock.. RG2/CANRX, Bit# = bit 2. RG2/CANRX, Buffer Type = ST. RG2/CANRX, Function = Input/output port pin or CAN bus receive.. RG3, Bit# = bit 3. RG3, Buffer Type = ST. RG3, Function = Input/output port pin.. RG4/P1D, Bit# = bit 4. RG4/P1D, Buffer Type = ST. RG4/P1D, Function = Input/output port pin or ECCP1 PWM output D..",
    "TABLE 10-13: PORTG FUNCTIONS\nRG5/MCLR/VPP, Bit# = bit 5. RG5/MCLR/VPP, Buffer Type = ST. RG5/MCLR/VPP, Function = Master Clear input or programming voltage input (if MCLR is enabled). Input only port pin or programming voltage input (if MCLR is disabled).\nLegend: ST = Schmitt Trigger input",
    "TABLE 10-14: SUMMARY OF REGISTERS ASSOCIATED WITH PORTG\nPORTG, Bit 7 = -. PORTG, Bit 6 = -. PORTG, Bit 5 = RG5 (1). PORTG, Bit 4 = Read PORTF pin/Write PORTF Data Latch. PORTG, Bit 3 = Read PORTF pin/Write PORTF Data Latch. PORTG, Bit 2 = Read PORTF pin/Write PORTF Data Latch. PORTG, Bit 1 = Read PORTF pin/Write PORTF Data Latch. PORTG, Value on POR, BOR = --0x xxxx. PORTG, Value on all other Resets = --0u uuuu. LATG, Bit 7 = -. LATG, Bit 6 = -. LATG, Bit 5 = -. LATG, Bit 4 = LATG Data Output Register. LATG, Bit 3 = LATG Data Output Register. LATG, Bit 2 = LATG Data Output Register. LATG, Bit 1 = LATG Data Output Register. LATG, Value on POR, BOR = ---x xxxx. LATG, Value on all other Resets",
    "TABLE 10-14: SUMMARY OF REGISTERS ASSOCIATED WITH PORTG\n= ---u uuuu. TRISG, Bit 7 = -. TRISG, Bit 6 = -. TRISG, Bit 5 = -. TRISG, Bit 4 = Data Direction Control Register for PORTG. TRISG, Bit 3 = Data Direction Control Register for PORTG. TRISG, Bit 2 = Data Direction Control Register for PORTG. TRISG, Bit 1 = Data Direction Control Register for PORTG. TRISG, Value on POR, BOR = ---1 1111. TRISG, Value on all other Resets = ---1 1111\nLegend: x = unknown, u = unchanged\nNote 1: RG5 is available as an input only when MCLR is disabled.",
    "FIGURE 10-22: RH3:RH0 PINS BLOCK DIAGRAM IN I/O MODE\nNote:, 1 = PORTH is available only on PIC18F8X8X devices.\nPORTH is an 8-bit wide, bidirectional I/O port. The corresponding data direction register is TRISH. Setting a TRISH bit (= 1 )  will  make the corresponding PORTH pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISH bit (= 0 ) will make the corresponding PORTH pin an output (i.e., put the contents of the output latch on the selected pin).\nRead-modify-write  operations  on  the  LATH  register read and write the latched output value for PORTH.",
    "FIGURE 10-22: RH3:RH0 PINS BLOCK DIAGRAM IN I/O MODE\nPins  RH7:RH4  are  multiplexed  with  analog  inputs AN15:AN12. Pins RH3:RH0 are multiplexed with the system bus as the external memory interface; they are the high-order address bits, A19:A16. By default, pins RH7:RH4 are enabled as A/D inputs and pins RH3:RH0  are  enabled  as  the  system  address  bus. Register ADCON1 configures RH7:RH4 as I/O or A/D inputs. Register MEMCON configures RH3:RH0 as I/O or system bus pins.\nPins RH7 and RH6 can be configured as the alternate peripheral pins for CCP1 PWM output P1B and P1C, respectively. This is done by clearing the configuration bit ECCPMX,  in  configuration  register  CONFIG3H (CONFIG3H<1>).",
    "FIGURE 10-22: RH3:RH0 PINS BLOCK DIAGRAM IN I/O MODE\nNote 1: On Power-on Reset, PORTH pins RH7:RH4 default to A/D inputs and read as ' 0 '.\n2: On Power-on Reset, PORTH pins RH3:RH0 default to system bus signals.",
    "EXAMPLE 10-8: INITIALIZING PORTH\nCLRF, 1 = PORTH. CLRF, 2 = ; Initialize PORTH by ; clearing output ; data latches. CLRF, 1 = LATH. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF MOVLW, 1 = 0Fh ADCON1 0CFh. MOVLW MOVWF MOVLW, 2 = ; ; ; Value used ; initialize. MOVWF, 1 = TRISH. MOVWF, 2 = ; Set RH3:RH0 as inputs ; RH5:RH4 as outputs ; RH7:RH6 as inputs",
    "TABLE 10-15: PORTH FUNCTIONS\nRH0/A16, Bit# = bit 0. RH0/A16, Buffer Type = ST/TTL (1). RH0/A16, Function = Input/output port pin or address bit 16 for external memory interface.. RH1/A17, Bit# = bit 1. RH1/A17, Buffer Type = ST/TTL (1). RH1/A17, Function = Input/output port pin or address bit 17 for external memory interface.. RH2/A18, Bit# = bit 2. RH2/A18, Buffer Type = ST/TTL (1). RH2/A18, Function = Input/output port pin or address bit 18 for external memory interface.. RH3/A19, Bit# = bit 3. RH3/A19, Buffer Type = ST/TTL (1). RH3/A19, Function = Input/output port pin or address bit 19 for external memory interface.. RH4/AN12, Bit# = bit 4. RH4/AN12, Buffer Type = ST.",
    "TABLE 10-15: PORTH FUNCTIONS\nRH4/AN12, Function = Input/output port pin or analog input channel 12.. RH5/AN13, Bit# = bit 5. RH5/AN13, Buffer Type = ST. RH5/AN13, Function = Input/output port pin or analog input channel 13.. RH6/AN14/P1C (2), Bit# = bit 6. RH6/AN14/P1C (2), Buffer Type = ST. RH6/AN14/P1C (2), Function = Input/output port pin or analog input channel 14.. RH7/AN15/P1B (2), Bit# = bit 7. RH7/AN15/P1B (2), Buffer Type = ST. RH7/AN15/P1B (2), Function = Input/output port pin or analog input channel 15.\nLegend: ST = Schmitt Trigger input, TTL = TTL input",
    "TABLE 10-15: PORTH FUNCTIONS\nNote 1: Input buffers are Schmitt Triggers when in I/O mode and TTL buffers when in System Bus or Parallel Slave Port mode.\n2: Alternate pin assignment when ECCPMX configuration bit is cleared.",
    "TABLE 10-16: SUMMARY OF REGISTERS ASSOCIATED WITH PORTH\nTRISH, Bit 7 = PORTH Data Direction Control Register. TRISH, Bit 6 = PORTH Data Direction Control Register. TRISH, Bit 5 = PORTH Data Direction Control Register. TRISH, Bit 4 = PORTH Data Direction Control Register. TRISH, Bit 3 = PORTH Data Direction Control Register. TRISH, Bit 2 = PORTH Data Direction Control Register. TRISH, Bit 1 = PORTH Data Direction Control Register. TRISH, Bit 0 = PORTH Data Direction Control Register. TRISH, Value on: POR, BOR = 1111 1111. TRISH, Value on all other Resets = 1111 1111. PORTH, Bit 7 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 6 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 5 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 4 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 3 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 2 = Read PORTH pin/Write PORTH Data Latch. PORTH, Bit 1 = Read",
    "TABLE 10-16: SUMMARY OF REGISTERS ASSOCIATED WITH PORTH\nPORTH pin/Write PORTH Data Latch. PORTH, Bit 0 = Read PORTH pin/Write PORTH Data Latch. PORTH, Value on: POR, BOR = xxxx xxxx. PORTH, Value on all other Resets = uuuu uuuu. LATH, Bit 7 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 6 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 5 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 4 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 3 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 2 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 1 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Bit 0 = Read PORTH Data Latch/Write PORTH Data Latch. LATH, Value on: POR, BOR = xxxx xxxx. LATH, Value on all other Resets = uuuu uuuu.",
    "TABLE 10-16: SUMMARY OF REGISTERS ASSOCIATED WITH PORTH\nADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on: POR, BOR = --00 0000. ADCON1, Value on all other Resets = --00 0000. MEMCON (1), Bit 7 = EBDIS. MEMCON (1), Bit 6 = -. MEMCON (1), Bit 5 = WAIT1. MEMCON (1), Bit 4 = WAIT0. MEMCON (1), Bit 3 = -. MEMCON (1), Bit 2 = -. MEMCON (1), Bit 1 = WM1. MEMCON (1), Bit 0 = WM0. MEMCON (1), Value on: POR, BOR =",
    "TABLE 10-16: SUMMARY OF REGISTERS ASSOCIATED WITH PORTH\n0-00 --00. MEMCON (1), Value on all other Resets = 0-00 --00\nLegend: x = unknown, u = unchanged, - = unimplemented. Shaded cells are not used by PORTH.\nNote 1: This register is held in Reset in Microcontroller mode.",
    "10.9 PORTJ, TRISJ and LATJ Registers\nNote:\nPORTJ is available only on PIC18F8X8X devices.\nPORTJ is an 8-bit wide, bidirectional port. The corresponding  data  direction  register  is  TRISJ.  Setting  a TRISJ bit (= 1 ) will make the corresponding PORTJ pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISJ bit (= 0 ) will make the corresponding PORTJ pin an output (i.e., put the contents of the output latch on the selected pin).\nThe  Data Latch register (LATJ) is also memory mapped.  Read-modify-write  operations  on  the  LATJ register  read  and  write  the  latched  output  value  for PORTJ.\nPORTJ  is  multiplexed  with  the  system  bus  as  the external memory interface; I/O port functions are only available  when  the  system  bus  is  disabled.  When operating  as  the  external  memory  interface,  PORTJ provides the control signal to external memory devices. The RJ5 pin is not  multiplexed  with  any  system  bus functions.",
    "10.9 PORTJ, TRISJ and LATJ Registers\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTJ pin. Some peripherals  override  the  TRIS  bit  to  make  a  pin  an output, while other peripherals override the TRIS bit to make  a  pin  an  input.  The  user  should  refer  to  the corresponding peripheral section for the correct TRIS bit settings.\nNote:, 1 = On a Power-on Reset, these pins are configured as digital inputs.\nThe pin override value is not loaded into the TRIS register. This allows read-modify-write of the TRIS register without concern due to peripheral overrides.",
    "EXAMPLE 10-9: INITIALIZING PORTJ\nCLRF, 1 = PORTJ. CLRF, 2 = ; Initialize ; clearing ; data. CLRF, 1 = LATJ. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0CFh. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISJ. MOVWF, 2 = ; Set RJ3:RJ0 as inputs ; RJ5:RJ4 as output ; RJ7:RJ6 as inputs",
    "TABLE 10-17: PORTJ FUNCTIONS\nRJ0/ALE, Bit# = bit 0. RJ0/ALE, Buffer Type = ST. RJ0/ALE, Function = Input/output port pin or address latch enable control for external memory interface.. RJ1/OE, Bit# = bit 1. RJ1/OE, Buffer Type = ST. RJ1/OE, Function = Input/output port pin or output enable control for external memory interface.. RJ2/WRL, Bit# = bit 2. RJ2/WRL, Buffer Type = ST. RJ2/WRL, Function = Input/output port pin or write low byte control for external memory interface.. RJ3/WRH, Bit# = bit 3. RJ3/WRH, Buffer Type = ST. RJ3/WRH, Function = Input/output port pin or write high byte control for external memory interface.. RJ4/BA0, Bit# = bit 4. RJ4/BA0, Buffer Type = ST. RJ4/BA0, Function = Input/output port pin or byte address 0 control for external memory interface..",
    "TABLE 10-17: PORTJ FUNCTIONS\nRJ5/CE, Bit# = bit 5. RJ5/CE, Buffer Type = ST. RJ5/CE, Function = Input/output port pin or external memory chip enable.. RJ6/LB, Bit# = bit 6. RJ6/LB, Buffer Type = ST. RJ6/LB, Function = Input/output port pin or lower byte select control for external memory interface.. RJ7/UB, Bit# = bit 7. RJ7/UB, Buffer Type = ST. RJ7/UB, Function = Input/output port pin or upper byte select control for external memory interface.\nLegend: ST = Schmitt Trigger input",
    "TABLE 10-18: SUMMARY OF REGISTERS ASSOCIATED WITH PORTJ\nPORTJ, Bit 7 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 6 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 5 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 4 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 3 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 2 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 1 = Read PORTJ pin/Write PORTJ Data Latch. PORTJ, Bit 0 = xxxx. PORTJ, Value on POR, BOR all = xxxx. PORTJ, Value on other Resets = uuuu. PORTJ, Value on other Resets = uuuu. PORTJ,",
    "TABLE 10-18: SUMMARY OF REGISTERS ASSOCIATED WITH PORTJ\n= . LATJ, Bit 7 = LATJ Data Output Register. LATJ, Bit 6 = LATJ Data Output Register. LATJ, Bit 5 = LATJ Data Output Register. LATJ, Bit 4 = LATJ Data Output Register. LATJ, Bit 3 = LATJ Data Output Register. LATJ, Bit 2 = LATJ Data Output Register. LATJ, Bit 1 = LATJ Data Output Register. LATJ, Bit 0 = xxxx. LATJ, Value on POR, BOR all = xxxx. LATJ, Value on other Resets = uuuu. LATJ, Value on other Resets = uuuu. LATJ,",
    "TABLE 10-18: SUMMARY OF REGISTERS ASSOCIATED WITH PORTJ\n= . TRISJ, Bit 7 = Data Direction Control Register for PORTJ. TRISJ, Bit 6 = Data Direction Control Register for PORTJ. TRISJ, Bit 5 = Data Direction Control Register for PORTJ. TRISJ, Bit 4 = Data Direction Control Register for PORTJ. TRISJ, Bit 3 = Data Direction Control Register for PORTJ. TRISJ, Bit 2 = Data Direction Control Register for PORTJ. TRISJ, Bit 1 = Data Direction Control Register for PORTJ. TRISJ, Bit 0 = 1111. TRISJ, Value on POR, BOR all = 1111. TRISJ, Value on other Resets = 1111. TRISJ, Value on other Resets = 1111. TRISJ,  = \nLegend: x = unknown, u = unchanged",
    "FIGURE 10-28:\nPORTD also operates as an 8-bit wide Parallel Slave Port, or microprocessor port, when control bit PSPMODE  (TRISE<4>)  is  set.  It  is  asynchronously readable and writable by the external world through RD control input pin, RE0/RD/AD8 and WR control input pin, RE1/WR/AD9.\nNote:, 1 = For PIC18F8X8X devices, the Parallel Slave Port is available only in Microcontroller mode.",
    "FIGURE 10-28:\nThe  PSP  can  directly  interface  to  an  8-bit  microprocessor data bus. The external microprocessor can read or write the PORTD latch as an 8-bit latch. Setting bit PSPMODE enables port pin RE0/RD/AD8 to be the RD  input,  RE1/WR/AD9  to  be  the  WR  input  and RE2/CS/AD10 to be the CS (chip select) input. For this functionality,  the  corresponding  data  direction  bits  of the TRISE register (TRISE<2:0>) must be configured as inputs (set). The A/D port configuration bits PCFG2:PCFG0 (ADCON1<2:0>) must be set, which will configure pins RE2:RE0 as digital I/O.\nA write to the PSP occurs when both the CS and WR lines are first detected low. A read from the PSP occurs when both the CS and RD lines are first detected low.",
    "FIGURE 10-28:\nThe  PORTE  I/O  pins  become  control inputs for the microprocessor port when bit PSPMODE (PSPCON<4>) is set. In this mode, the user must make sure that the TRISE<2:0> bits are set (pins are configured as digital inputs) and the ADCON1 is configured for digital I/O. In this mode, the input buffers are TTL.",
    "PSPCON REGISTER\nR-0, 1 = R-0. R-0, 2 = R/W-0. R-0, 3 = R/W-0. R-0, 4 = U-0. R-0, 5 = U-0. R-0, 6 = U-0. R-0, 7 = U-0. IBF, 1 = OBF. IBF, 2 = IBOV. IBF, 3 = PSPMODE. IBF, 4 = -. IBF, 5 = -. IBF, 6 = -. IBF, 7 = -\nbit 7\nbit 0\nbit 7 IBF: Input Buffer Full Status bit\n1 = A data byte has been received and is waiting to be read by the CPU\n0\n= No data byte has been received\nbit 6 OBF: Output Buffer Full Status bit\n1 = The output buffer still holds a previously written data byte\n0 = The output buffer has been read\nbit 5 IBOV: Input Buffer Overflow Detect bit\n1 = A write occurred when a previously input data byte has not been read\n(must be cleared in software)\n0 = No overflow occurred\nbit 4 PSPMODE: Parallel Slave Port Mode Select bit\n1 = Parallel Slave Port mode",
    "PSPCON REGISTER\n0 = General Purpose I/O mode\n- bit 3-0 Unimplemented: Read as ' 0 '\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "FIGURE 10-29: PARALLEL SLAVE PORT WRITE WAVEFORMS\n, 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = Q4. , 5 = Q1. , 6 = Q2. , 7 = Q3. , 8 = Q4. , 9 = Q1. , 10 = Q2. , 11 = Q3. , 12 = Q4. CS, 1 = . CS, 2 = . CS, 3 = . CS, 4 = . CS, 5 = . CS, 6 = . CS, 7 = . CS, 8 = . CS, 9 = . CS, 10 = . CS, 11 = . CS, 12 = . WR, 1 = . WR, 2 = . WR, 3 = . WR, 4 = . WR, 5 = . WR, 6 = . WR, 7 = . WR, 8 = . WR, 9 = . WR, 10 = . WR, 11 = . WR, 12 = . RD, 1 = . RD, 2 = . RD, 3 = . RD, 4 = . RD, 5 = . RD, 6 = . RD, 7 = . RD, 8 = . RD, 9 = . RD, 10 = . RD, 11",
    "FIGURE 10-29: PARALLEL SLAVE PORT WRITE WAVEFORMS\n= . RD, 12 = . PORTD<7:0>, 1 = . PORTD<7:0>, 2 = . PORTD<7:0>, 3 = . PORTD<7:0>, 4 = . PORTD<7:0>, 5 = . PORTD<7:0>, 6 = . PORTD<7:0>, 7 = . PORTD<7:0>, 8 = . PORTD<7:0>, 9 = . PORTD<7:0>, 10 = . PORTD<7:0>, 11 = . PORTD<7:0>, 12 = . IBF, 1 = . IBF, 2 = . IBF, 3 = . IBF, 4 = . IBF, 5 = . IBF, 6 = . IBF, 7 = . IBF, 8 = . IBF, 9 = . IBF, 10 = . IBF, 11 = . IBF, 12 = . OBF, 1 = . OBF, 2 = . OBF, 3 = . OBF, 4 = . OBF, 5 = . OBF, 6",
    "FIGURE 10-29: PARALLEL SLAVE PORT WRITE WAVEFORMS\n= . OBF, 7 = . OBF, 8 = . OBF, 9 = . OBF, 10 = . OBF, 11 = . OBF, 12 = . PSPIF, 1 = . PSPIF, 2 = . PSPIF, 3 = . PSPIF, 4 = . PSPIF, 5 = . PSPIF, 6 = . PSPIF, 7 = . PSPIF, 8 = . PSPIF, 9 = . PSPIF, 10 = . PSPIF, 11 = . PSPIF, 12 = ",
    "PIC18F6585/8585/6680/8680\nCS WR, 1 = Q1. CS WR, 2 = Q2. CS WR, 3 = Q3. CS WR, 4 = Q4. CS WR, 5 = Q1. CS WR, 6 = Q2. CS WR, 7 = Q3. CS WR, 8 = Q4. CS WR, 9 = Q1. CS WR, 10 = Q2. CS WR, 11 = Q3. CS WR, 12 = Q4. PSPIF, 1 = . PSPIF, 2 = . PSPIF, 3 = . PSPIF, 4 = . PSPIF, 5 = . PSPIF, 6 = . PSPIF, 7 = . PSPIF, 8 = . PSPIF, 9 = . PSPIF, 10 = . PSPIF, 11 = . PSPIF, 12 = ",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nPORTD, Bit 7 = Port Data Latch when Written; Port pins when Read. PORTD, Bit 6 = Port Data Latch when Written; Port pins when Read. PORTD, Bit 5 = Port Data Latch when Written; Port pins when Read. PORTD, Bit 4 = Port Data Latch when Written; Port pins when Read. PORTD, Bit 3 = Port Data Latch when Written; Port pins when Read. PORTD, Bit 2 = Port Data Latch when Written; Port pins when Read. PORTD, Bit 1 = Port Data Latch when Written; Port pins when Read. PORTD, Bit 0 = Port Data Latch when Written; Port pins when Read. PORTD, Value on POR, BOR = xxxx. PORTD, Value on all other Resets = xxxx uuuu. PORTD, Value on all other Resets = uuuu. PORTD,",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n= . LATD, Bit 7 = LATD Data Output bits. LATD, Bit 6 = LATD Data Output bits. LATD, Bit 5 = LATD Data Output bits. LATD, Bit 4 = LATD Data Output bits. LATD, Bit 3 = LATD Data Output bits. LATD, Bit 2 = LATD Data Output bits. LATD, Bit 1 = LATD Data Output bits. LATD, Bit 0 = LATD Data Output bits. LATD, Value on POR, BOR = xxxx. LATD, Value on all other Resets = xxxx uuuu. LATD, Value on all other Resets = uuuu. LATD,",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n= . TRISD, Bit 7 = PORTD Data Direction bits. TRISD, Bit 6 = PORTD Data Direction bits. TRISD, Bit 5 = PORTD Data Direction bits. TRISD, Bit 4 = PORTD Data Direction bits. TRISD, Bit 3 = PORTD Data Direction bits. TRISD, Bit 2 = PORTD Data Direction bits. TRISD, Bit 1 = PORTD Data Direction bits. TRISD, Bit 0 = PORTD Data Direction bits. TRISD, Value on POR, BOR = 1111. TRISD, Value on all other Resets = 1111 1111. TRISD, Value on all other Resets = 1111. TRISD,",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n= . PORTE, Bit 7 = RE7/CCP2/ AD15. PORTE, Bit 6 = RE6/AD14/ P1B. PORTE, Bit 5 = RE5/AD13/ P1C. PORTE, Bit 4 = RE4/ AD12. PORTE, Bit 3 = RE3/ AD11. PORTE, Bit 2 = RE2/CS (1) / AD10. PORTE, Bit 1 = RE1/WR (1) / AD9. PORTE, Bit 0 = RE0/RD (1) / AD8. PORTE, Value on POR, BOR = xxxx. PORTE, Value on all other Resets = xxxx uuuu. PORTE, Value on all other Resets = uuuu. PORTE,",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n= . LATE, Bit 7 = LATE Data Output bits. LATE, Bit 6 = LATE Data Output bits. LATE, Bit 5 = LATE Data Output bits. LATE, Bit 4 = LATE Data Output bits. LATE, Bit 3 = LATE Data Output bits. LATE, Bit 2 = LATE Data Output bits. LATE, Bit 1 = LATE Data Output bits. LATE, Bit 0 = LATE Data Output bits. LATE, Value on POR, BOR = xxxx. LATE, Value on all other Resets = xxxx uuuu. LATE, Value on all other Resets = uuuu. LATE,",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n= . TRISE, Bit 7 = PORTE Data Direction bits. TRISE, Bit 6 = PORTE Data Direction bits. TRISE, Bit 5 = PORTE Data Direction bits. TRISE, Bit 4 = PORTE Data Direction bits. TRISE, Bit 3 = PORTE Data Direction bits. TRISE, Bit 2 = PORTE Data Direction bits. TRISE, Bit 1 = PORTE Data Direction bits. TRISE, Bit 0 = PORTE Data Direction bits. TRISE, Value on POR, BOR = 1111. TRISE, Value on all other Resets = 1111 1111. TRISE, Value on all other Resets = 1111. TRISE,",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n= . PSPCON, Bit 7 = IBF. PSPCON, Bit 6 = OBF. PSPCON, Bit 5 = IBOV. PSPCON, Bit 4 = PSPMODE. PSPCON, Bit 3 = -. PSPCON, Bit 2 = -. PSPCON, Bit 1 = -. PSPCON, Bit 0 = -. PSPCON, Value on POR, BOR = 0000. PSPCON, Value on all other Resets = ---- 0000. PSPCON, Value on all other Resets = ----. PSPCON,",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n= . INTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IF. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on all other Resets = 0000 0000. INTCON, Value on all other Resets = 0000. INTCON,",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n= . PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000 0000. PIR1, Value on all other Resets = 0000. PIR1,",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n= . PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000 0000. PIE1, Value on all other Resets = 0000. PIE1,",
    "TABLE 10-19: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\n= . IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111 1111. IPR1, Value on all other Resets = 1111. IPR1,  = \nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the Parallel Slave Port.\nNote 1: Enabled only in Microcontroller mode.",
    "11.0 TIMER0 MODULE\nThe Timer0 module has the following features:\n- \u00b7 Software selectable as an 8-bit or 16-bit timer/ counter\nFigure 11-1  shows  a  simplified  block  diagram  of  the Timer0 module in 8-bit mode and Figure 11-2 shows a simplified block diagram of the Timer0 module in 16-bit mode.\n\u00b7 Readable and writable\n\u00b7 Dedicated 8-bit software programmable prescaler\n\u00b7 Clock source selectable to be external or internal\n\u00b7 Interrupt-on-overflow from 0FFh to 00h in 8-bit mode and 0FFFFh to 0000h in 16-bit mode\n\u00b7 Edge select for external clock",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-1. R/W-1, 3 = R/W-1. R/W-1, 4 = R/W-1. R/W-1, 5 = R/W-1. R/W-1, 6 = R/W-1. R/W-1, 7 = R/W-1. TMR0ON, 1 = T08BIT. TMR0ON, 2 = T0CS. TMR0ON, 3 = T0SE. TMR0ON, 4 = PSA. TMR0ON, 5 = T0PS2. TMR0ON, 6 = T0PS1. TMR0ON, 7 = T0PS0\nbit 7\nbit 0\nbit 7\nTMR0ON:\nTimer0 On/Off Control bit\n1 = Enables Timer0\n0 = Stops Timer0\nbit 6 T08BIT : Timer0 8-bit/16-bit Control bit",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\n1 = Timer0 is configured as an 8-bit timer/counter\n0 = Timer0 is configured as a 16-bit timer/counter",
    "bit 5\nT0CS : Timer0 Clock Source Select bit\n1 = Transition on T0CKI pin\n0 = Internal instruction cycle clock (CLKO)",
    "bit 4\nT0SE : Timer0 Source Edge Select bit\n1 = Increment on high-to-low transition on T0CKI pin\n0 = Increment on low-to-high transition on T0CKI pin",
    "bit 3\nPSA : Timer0 Prescaler Assignment bit\n1 = TImer0 prescaler is not assigned. Timer0 clock input bypasses prescaler.\n0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.",
    "bit 2-0 T0PS2:T0PS0 : Timer0 Prescaler Select bits\n111 = 1:256 prescale value\n110 = 1:128 prescale value\n101 = 1:64   prescale value\n100 = 1:32   prescale value\n011 = 1:16   prescale value\n010 = 1:8     prescale value\n001\n= 1:4     prescale value\n000\n= 1:2     prescale value",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nThe T0CON register (Register 11-1) is a readable and writable register that controls all the aspects of Timer0, including the prescale selection.\nNote:\nTimer0 is enabled on POR.",
    "11.1 Timer0 Operation\nTimer0 can operate as a timer or as a counter.",
    "11.2.1 SWITCHING PRESCALER ASSIGNMENT\nTimer  mode  is  selected  by  clearing  the  T0CS  bit.  In Timer mode, the Timer0 module will increment every instruction cycle (without prescaler). If the TMR0 register is written, the increment is inhibited for the following two instruction cycles. The user can work around this by writing an adjusted value to the TMR0 register.\nCounter mode is selected by setting the T0CS bit. In Counter mode, Timer0 will increment either on every rising or falling edge of pin RA4/T0CKI. The incrementing  edge  is  determined  by  the  Timer0  Source  Edge Select  bit  (T0SE).  Clearing  the  T0SE  bit  selects  the rising edge. Restrictions on the external clock input are discussed below.\nWhen an external clock input is used for Timer0, it must meet certain requirements. The requirements ensure the external clock can be synchronized with the internal phase clock (TOSC). Also, there is a delay in the actual incrementing of Timer0 after synchronization.",
    "11.2 Prescaler\nAn  8-bit  counter  is  available  as  a  prescaler  for  the Timer0  module.  The  prescaler  is  not  readable  or writable.\nThe PSA  and T0PS2:T0PS0  bits determine the prescaler assignment and prescale ratio.\nClearing bit PSA will assign the prescaler to the Timer0 module. When the prescaler is assigned to the Timer0 module,  prescale  values  of  1:2,  1:4,  ...,  1:256  are selectable.\nWhen assigned to the Timer0 module, all instructions writing to the TMR0 register (e.g., CLRF TMR0, MOVWF TMR0, BSF TMR0, x , ..., etc.) will clear the prescaler count.\nThe  prescaler  assignment  is  fully under  software control  (i.e.,  it can  be  changed  'on-the-fly'  during program execution).",
    "11.3 Timer0 Interrupt\nThe TMR0 interrupt is generated when the TMR0 register  overflows  from  0FFh  to  00h  in  8-bit  mode,  or 0FFFFh to 0000h in 16-bit mode. This overflow sets the TMR0IF bit. The interrupt can be masked by clearing the  TMR0IE  bit.  The  TMR0IE  bit  must  be  cleared  in software by the Timer0  module  Interrupt Service Routine  before  re-enabling  this  interrupt.  The  TMR0 interrupt  cannot  awaken  the  processor  from  Sleep since the timer is shut-off during Sleep.",
    "11.4 16-Bit Mode Timer Reads and Writes\nTMR0H  is  not  the  high  byte  of  the  timer/counter  in 16-bit  mode, but is actually a buffered version of the high byte of Timer0 (refer to Figure 11-2). The high byte of the Timer0 counter/timer is not directly readable nor writable.  TMR0H is updated with the contents of the high byte of Timer0 during a read of TMR0L. This provides the  ability  to  read  all  16  bits  of  Timer0  without having to verify that the read of the high and low byte were valid due to a rollover between successive reads of the high and low byte.\nA write to the high byte of Timer0 must also take place through the TMR0H buffer register. Timer0 high byte is updated  with  the  contents  of  TMR0H  when  a  write occurs to TMR0L. This allows all 16 bits of Timer0 to be updated at once.\nNote:\nWriting  to  TMR0  when  the  prescaler  is assigned to Timer0 will clear the prescaler count  but  will  not  change  the  prescaler assignment.",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0L, Bit 7 = Timer0 Module Low Byte Register. TMR0L, Bit 6 = Timer0 Module Low Byte Register. TMR0L, Bit 5 = Timer0 Module Low Byte Register. TMR0L, Bit 4 = Timer0 Module Low Byte Register. TMR0L, Bit 3 = Timer0 Module Low Byte Register. TMR0L, Bit 2 = Timer0 Module Low Byte Register. TMR0L, Bit 1 = Timer0 Module Low Byte Register. TMR0L, Bit 0 = Timer0 Module Low Byte Register. TMR0L, Value on POR, BOR = xxxx. TMR0L, Value on POR, BOR = xxxx. TMR0L, Value on all other Resets = uuuu. TMR0L, Value on all other Resets = uuuu. TMR0H, Bit 7 = Timer0 Module High Byte Register. TMR0H, Bit 6 = Timer0 Module High Byte Register. TMR0H, Bit 5 = Timer0 Module High Byte Register.",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0H, Bit 4 = Timer0 Module High Byte Register. TMR0H, Bit 3 = Timer0 Module High Byte Register. TMR0H, Bit 2 = Timer0 Module High Byte Register. TMR0H, Bit 1 = Timer0 Module High Byte Register. TMR0H, Bit 0 = Timer0 Module High Byte Register. TMR0H, Value on POR, BOR = 0000. TMR0H, Value on POR, BOR = 0000. TMR0H, Value on all other Resets = 0000. TMR0H, Value on all other Resets = 0000. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON,",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nValue on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = 1111. T0CON, Value on POR, BOR = 1111. T0CON, Value on all other Resets = 1111. T0CON, Value on all other Resets = 1111. TRISA, Bit 7 = -. TRISA, Bit 6 = PORTA Data Direction Register. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\n= PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = -111. TRISA, Value on POR, BOR = 1111. TRISA, Value on all other Resets = -111. TRISA, Value on all other Resets = 1111\nLegend:\nx = unknown, u = unchanged, -= unimplemented locations, read as ' 0 '. Shaded cells are not used by Timer0.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "12.0 TIMER1 MODULE\nThe  Timer1  module  timer/counter  has  the  following features:\nFigure 12-1 is a simplified block diagram of the Timer1 module.\n\u2022\n16-bit timer/counter\n(two 8-bit registers; TMR1H and TMR1L)\n\u00b7 Readable and writable (both registers)\n\u00b7 Internal or external clock select\n\u00b7 Interrupt on overflow from 0FFFFh to 0000h\n\u00b7 Reset from CCP module special event trigger",
    "REGISTER 12-1: T1CON: TIMER1 CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. RD16, 1 = -. RD16, 2 = T1CKPS1. RD16, 3 = T1CKPS0. RD16, 4 = T1OSCEN. RD16, 5 = T1SYNC. RD16, 6 = TMR1CS. RD16, 7 = TMR1ON\nbit 7\nbit 0",
    "bit 7\nRD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register read/write of Timer1 in one 16-bit operation\n0 = Enables register read/write of Timer1 in two 8-bit operations",
    "bit 5-4 T1CKPS1:T1CKPS0 : Timer1 Input Clock Prescale Select bits\n11 = 1:8 prescale value\n10 = 1:4 prescale value\n01 = 1:2 prescale value\n00 = 1:1 prescale value",
    "bit 3 T1OSCEN: Timer1 Oscillator Enable bit\n1 = Timer1 oscillator is enabled\n0 = Timer1 oscillator is shut-off\nThe oscillator inverter and feedback resistor are turned off to eliminate power drain.",
    "bit 2 T1SYNC:\nTimer1 External Clock Input Synchronization Select bit\nWhen TMR1CS = 1 :\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR1CS = 0 :\nThis bit is ignored. Timer1 uses the internal clock when TMR1CS = 0 .",
    "bit 1 TMR1CS: Timer1 Clock Source Select bit\n1 = External clock from pin RC0/T1OSO/T13CKI (on the rising edge)\n0 = Internal clock (FOSC/4)\nbit 0\nTMR1ON:\nTimer1 On bit\n1 = Enables Timer1\n0 = Stops Timer1",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nRegister 12-1 details the Timer1 Control register. This register  controls  the  operating  mode  of  the  Timer1 module and contains the Timer1 Oscillator Enable bit (T1OSCEN).  Timer1  can  be  enabled  or  disabled  by setting or clearing control bit, TMR1ON (T1CON<0>).",
    "12.1 Timer1 Operation\nTimer1 can operate in one of these modes:\n- \u00b7 As a timer\nWhen TMR1CS = 0 , Timer1 increments every instruction cycle. When TMR1CS = 1 , Timer1 increments on every  rising  edge  of  the  external  clock  input  or  the Timer1 oscillator if enabled.\n\u00b7 As a synchronous counter\n\u00b7 As an asynchronous counter\nThe operating mode is determined by the clock select bit, TMR1CS (T1CON<1>).\nWhen the Timer1 oscillator is enabled (T1OSCEN is set),  the  RC1/T1OSI  and  RC0/T1OSO/T13CKI  pins become  inputs.  That  is,  the  TRISC<1:0>  value  is ignored and the pins are read as ' 0 '.\nTimer1 also has an internal 'Reset input'. This Reset can be generated by the CCP module ( Section 15.0 'Capture/Compare/PWM (CCP) Modules' ).",
    "12.2 Timer1 Oscillator\nA crystal oscillator circuit is built-in between pins T1OSI (input) and T1OSO (amplifier output). It is enabled by setting control bit, T1OSCEN (T1CON<3>). The oscillator is a low-power oscillator rated up to 200 kHz. It will continue to run during Sleep. It is primarily intended for a  32  kHz  crystal.  Table 12-1  shows  the  capacitor selection for the Timer1 oscillator.\nThe user must provide a software time delay to ensure proper start-up of the Timer1 oscillator.",
    "12.2 Timer1 Oscillator\nTABLE 12-1: CAPACITOR SELECTION FOR THE ALTERNATE OSCILLATOR\n\nLP, Freq = 32 kHz. LP, C1 = TBD (1). LP, C2 = TBD (1). Crystal to be Tested:, Freq = Crystal to be Tested:. Crystal to be Tested:, C1 = Crystal to be Tested:. Crystal to be Tested:, C2 = Crystal to be Tested:. 32.768 kHz, Freq = Epson C-001R32.768K-A. 32.768 kHz, C1 = Epson C-001R32.768K-A. 32.768 kHz, C2 = \uf0b1 20 PPM\nNote 1: Microchip  suggests  33  pF  as  a  starting point in validating the oscillator circuit.\n2: Higher capacitance increases the stability of  the  oscillator  but  also  increases  the start-up time.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer for appropriate values of external components.\n4: Capacitor values are for design guidance only.",
    "12.3 Timer1 Interrupt\nThe TMR1 register pair (TMR1H:TMR1L) increments from 0000h to 0FFFFh and rolls over to 0000h. The TMR1 interrupt, if  enabled,  is  generated  on  overflow which is latched in interrupt flag bit, TMR1IF (PIR1<0>). This interrupt can be enabled/disabled by setting/clearing  TMR1  interrupt  enable  bit,  TMR1IE (PIE1<0>).",
    "12.4 Resetting Timer1 Using a CCP Trigger Output\nIf  the  CCP  module  is  configured  in  Compare  mode to generate a 'special event trigger' (CCP1M3:CCP1M0  = 1011 ), this signal  will  reset Timer1 and start an A/D conversion (if the A/D module is enabled).\nNote:, 1 = The special event triggers from the CCP1 module will not set interrupt flag bit TMR1IF (PIR1<0>).\nTimer1 must be configured for either Timer or Synchronized Counter mode to take advantage of this feature. If  Timer1  is  running  in  Asynchronous Counter  mode, this Reset operation may not work.\nIn  the  event  that  a  write  to  Timer1  coincides  with  a special  event  trigger  from  CCP1,  the  write  will  take precedence.\nIn this mode of operation, the CCPR1H:CCPR1L register pair effectively becomes the period register for Timer1.",
    "12.5 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured for 16-bit reads and writes (see Figure 12-2). When the RD16 control bit (T1CON<7>) is set, the address for TMR1H is mapped to a buffer register for the high byte of Timer1. A read from TMR1L will load the contents of the high byte of Timer1 into the Timer1 high byte buffer. This provides the user with the ability to accurately read all 16 bits of Timer1 without having to determine whether a read of the high byte, followed by a read of the low byte, is valid due to a rollover between reads.\nA write to the high byte of Timer1 must also take place through the TMR1H Buffer register. Timer1 high byte is updated  with  the  contents  of  TMR1H  when  a  write occurs to TMR1L. This allows a user to write all 16 bits to both the high and low bytes of Timer1 at once.",
    "12.5 Timer1 16-Bit Read/Write Mode\nThe high byte of Timer1 is not directly readable or writable in this mode. All reads and writes must take place through the Timer1 High Byte Buffer register. Writes to TMR1H  do  not  clear the Timer1 prescaler. The prescaler is only cleared on writes to TMR1L.",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 0000. INTCON, Value on all other Resets = 0000 0000. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000 0000. PIR1, Value on all other Resets = 0000 0000. PIE1,",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nBit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000 0000 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 0111 1111. IPR1, Value on all other Resets = 0111 1111. TMR1L, Bit 7 = Holding Register for",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nthe Least Significant Byte of the 16-bit TMR1 Register xxxx. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register xxxx. TMR1L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register xxxx. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register xxxx. TMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register xxxx. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register xxxx. TMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register xxxx. TMR1L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register xxxx. TMR1L, Value on POR, BOR = xxxx uuuu.",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nTMR1L, Value on all other Resets = uuuu. TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Value",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\non POR, BOR = xxxx xxxx. TMR1H, Value on all other Resets = uuuu uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00 0000. T1CON, Value on all other Resets = u-uu uuuu\nLegend:\nx = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by the Timer1 module.",
    "13.1 Timer2 Operation\nThe Timer2 module timer has the following features:\n\u00b7 8-bit timer (TMR2 register)\n\u00b7 8-bit period register (PR2)\n\u00b7 Readable and writable (both registers)\n\u00b7 Software programmable prescaler (1:1, 1:4, 1:16)\n\u00b7 Software programmable postscaler (1:1 to 1:16)\n\u00b7 Interrupt on TMR2 match of PR2\n\u00b7 SSP module optional use of TMR2 output to generate clock shift",
    "13.1 Timer2 Operation\nTimer2  can  be  used  as  the  PWM  time  base  for  the PWM mode of the CCP module. The TMR2 register is readable  and  writable  and  is  cleared  on  any  device Reset. The input clock (FOSC/4) has a prescale option of 1:1, 1:4 or 1:16, selected by control bits, T2CKPS1:T2CKPS0 (T2CON<1:0>). The match output  of  TMR2  goes  through  a  4-bit  postscaler  (which gives  a  1:1  to  1:16  scaling  inclusive)  to  generate  a TMR2 interrupt latched in flag bit, TMR2IF (PIR1<1>).\nTimer2 has a control register shown in Register 13-1. Timer2 can be shut-off by clearing control bit, TMR2ON (T2CON<2>), to minimize power consumption. Figure 13-1 is a simplified block diagram of the Timer2 module. Register 13-1 shows the Timer2 Control register.  The prescaler and postscaler selection of Timer2 are controlled by this register.",
    "13.1 Timer2 Operation\nThe  prescaler  and  postscaler  counters  are  cleared when any of the following occurs:\n\u00b7 a write to the TMR2 register\n\u00b7 a write to the T2CON register\n\u00b7 any device Reset (Power-on Reset, MCLR Reset, Watchdog Timer Reset, or Brown-out Reset)\nTMR2 is not cleared when T2CON is written.",
    "REGISTER 13-1: T2CON: TIMER2 CONTROL REGISTER\n-, R/W-0 = T2OUTPS3. -, R/W-0 = T2OUTPS2. -, R/W-0 = T2OUTPS1. -, R/W-0 = T2OUTPS0. -, R/W-0 = TMR2ON. -, R/W-0 = T2CKPS1. -, R/W-0 = T2CKPS0. bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = bit 0",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6-3 T2OUTPS3:T2OUTPS0 : Timer2 Output Postscale Select bits\n0000 = 1:1 postscale\n0001 = 1:2 postscale\n\u2022\n\u2022\n\u2022\n1111 = 1:16 postscale",
    "bit 2 TMR2ON : Timer2 On bit\n1 = Timer2 is on\n0 = Timer2 is off",
    "bit 1-0 T2CKPS1:T2CKPS0 : Timer2 Clock Prescale Select bits\n00 = Prescaler is 1\n01 = Prescaler is 4\n1x = Prescaler is 16",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "13.2 Timer2 Interrupt\nThe Timer2 module has an 8-bit period register, PR2. Timer2 increments from 00h until it matches PR2 and then resets to 00h on the next increment cycle. PR2 is a readable and writable register. The PR2 register is initialized to 0FFh upon Reset.",
    "13.3 Output of TMR2\nThe output of TMR2 (before the postscaler) is fed to the synchronous serial port module which optionally uses it to generate the shift clock.",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 0000. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 0000. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP.",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nIPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR, BOR = 0000. TMR2, Value on all other Resets = 0000. TMR2, Value on all other",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nResets = 0000. T2CON, Bit 7 = -. T2CON, Bit 6 = T2OUTPS3. T2CON, Bit 5 = T2OUTPS2. T2CON, Bit 4 = T2OUTPS1. T2CON, Bit 3 = T2OUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. T2CON, Value on all other Resets = -000. T2CON, Value on all other Resets = 0000. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register.",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nPR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR, BOR = 1111. PR2, Value on all other Resets = 1111. PR2, Value on all other Resets = 1111\nLegend: x = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by the Timer2 module.",
    "14.0 TIMER3 MODULE\nThe  Timer3  module  timer/counter  has  the  following features:\nFigure 14-1 is a simplified block diagram of the Timer3 module.\n\u00b7 16-bit timer/counter\n(two 8-bit registers; TMR3H and TMR3L)\n\u00b7 Readable and writable (both registers)\n\u00b7 Internal or external clock select\n\u00b7 Interrupt on overflow from FFFFh to 0000h\n\u00b7 Reset from CCP module trigger\nRegister 14-1 shows the Timer3 Control register. This register  controls  the  operating  mode  of  the  Timer3 module and sets the Enhanced CCP1 and CCP2 clock source.\nRegister 12-1 shows the Timer1 Control register. This register  controls  the  operating  mode  of  the  Timer1 module,  as  well  as  containing  the  Timer1  oscillator enable bit (T1OSCEN) which can be a clock source for Timer3.",
    "REGISTER 14-1: T3CON: TIMER3 CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. RD16, 1 = T3CCP2. RD16, 2 = T3CKPS1. RD16, 3 = T3CKPS0. RD16, 4 = T3CCP1. RD16, 5 = T3SYNC. RD16, 6 = TMR3CS. RD16, 7 = TMR3ON\nbit 7\nbit 0",
    "bit 7 RD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register read/write of Timer3 in one 16-bit operation\n0 = Enables register read/write of Timer3 in two 8-bit operations",
    "bit 6, 3 T3CCP2:T3CCP1: Timer3 and Timer1 to CCPx Enable bits\n1x = Timer3 is the clock source for compare/capture of CCP1 and CCP2 modules\n01 = Timer3 is the clock source for compare/capture of CCP2 module,\nTimer1 is the clock source for compare/capture of CCP1 module\n00 = Timer1 is the clock source for compare/capture of CCP1 and CCP2 modules",
    "bit 5-4 T3CKPS1:T3CKPS0 : Timer3 Input Clock Prescale Select bits\n11 = 1:8 prescale value\n10 = 1:4 prescale value\n01 = 1:2 prescale value\n00 = 1:1 prescale value",
    "bit 2 T3SYNC: Timer3 External Clock Input Synchronization Control bit\n(Not usable if the system clock comes from Timer1/Timer3.)",
    "When TMR3CS = 1 :\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input",
    "When TMR3CS = 0 :\nThis bit is ignored. Timer3 uses the internal clock when TMR3CS = 0 .",
    "bit 1 TMR3CS: Timer3 Clock Source Select bit\n1 = External clock input from Timer1 oscillator or T13CKI\n(on the rising edge after the first falling edge)\n0 = Internal clock (FOSC/4)",
    "bit 0\nTMR3ON: Timer3 On bit\n1 = Enables Timer3\n0 = Stops Timer3",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "14.1 Timer3 Operation\nTimer3 can operate in one of these modes:\n\u00b7 As a timer\n\u00b7 As a synchronous counter\n\u00b7 As an asynchronous counter\nThe operating mode is determined by the clock select bit, TMR3CS (T3CON<1>).\nWhen TMR3CS = 0 , Timer3 increments every instruction cycle. When TMR3CS = 1 , Timer3 increments on every rising edge of the Timer1 external clock input or the Timer1 oscillator if enabled.\nWhen the Timer1 oscillator is enabled (T1OSCEN is set),  the  RC1/T1OSI  and  RC0/T1OSO/T13CKI  pins become  inputs.  That  is,  the  TRISC<1:0>  value  is ignored and the pins are read as ' 0 '.\nTimer3 also has an internal 'Reset input'.  This  Reset can  be  generated  by  the  CCP  module  ( Section 14.0 'Timer3 Module' ).",
    "FIGURE 14-1: TIMER3 BLOCK DIAGRAM\nNote 1: When enable bit T1OSCEN is cleared, the inverter and feedback resistor are turned off. This eliminates power drain.",
    "14.2 Timer1 Oscillator\nThe Timer1 oscillator may be used as the clock source for Timer3. The Timer1 oscillator is enabled by setting the T1OSCEN (T1CON<3>) bit. The oscillator is a lowpower oscillator rated up to 200 kHz. See Section 12.0 'Timer1 Module' for further details.",
    "14.3 Timer3 Interrupt\nThe TMR3 register pair (TMR3H:TMR3L) increments from 0000h to 0FFFFh and rolls over to 0000h. The TMR3 interrupt, if  enabled,  is  generated  on  overflow which is latched in interrupt flag bit, TMR3IF (PIR2<1>). This interrupt can be enabled/disabled by setting/clearing  TMR3  interrupt  enable  bit,  TMR3IE (PIE2<1>).",
    "14.4 Resetting Timer3 Using a CCP Trigger Output\nIf  the  CCP  module  is  configured  in  Compare  mode to generate a 'special event trigger' (CCP1M3:CCP1M0 = 1011 ), this signal will reset Timer3.\nNote:, 1 = The special event triggers from the CCP module will not set interrupt flag bit, TMR3IF (PIR1<0>).\nTimer3 must be configured for either Timer or Synchronized Counter mode to take advantage of this feature. If  Timer3  is  running  in  Asynchronous Counter  mode, this Reset operation may not work. In the event that a write to Timer3 coincides with a special event trigger from CCP1, the write will take precedence. In this mode of operation, the CCPR1H:CCPR1L  register pair effectively becomes the period register for Timer3.",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 0000. INTCON, Value on all other Resets = 0000 0000. INTCON,",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\n= . PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = -0-0 0000. PIR2, Value on all other Resets = -0-0 0000. PIR2,",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\n= . PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = -0-0 0000. PIE2, Value on all other Resets = -0-0 0000. PIE2,  = . IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = -1-1 1111. IPR2, Value on all other Resets = -1-1 1111. IPR2,",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\n= . TMR3L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Value on POR, BOR = xxxx xxxx.",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nTMR3L, Value on all other Resets = uuuu uuuu. TMR3L,",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\n= . TMR3H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\non all other Resets = uuuu uuuu. TMR3H,\n= . T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00. T1CON, Value on all other Resets = u-uu uuuu. T1CON,",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\n= . T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000. T3CON, Value on all other Resets = uuuu uuuu. T3CON,  = \nLegend:\nx = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by the Timer3 module.\nbit 5-4",
    "15.0 CAPTURE/COMPARE/PWM (CCP) MODULES\nPIC18FXX80/XX85 devices contain a total of two CCP modules:  CCP1  and  CCP2.  CCP1  is  an  enhanced version of the CCP2 module. CCP1 is fully backward compatible with the CCP2 module.\nAdditionally,  the  CCP2  special  event  trigger  may  be used to start an A/D conversion if the A/D module is enabled.\nThe CCP1 module differs from CCP2 in the following respect:\n\u00b7 CCP1 contains a special trigger event that may reset Timer1 or the Timer3 register pair\n\u00b7 CCP1 contains 'CAN Message Time-Stamp Trigger'\nTo avoid duplicate information, this section describes basic CCP module operation that applies to both CCP1 and CCP2. Enhanced CCP functionality of the CCP1 module is described in Section 16.0 'Enhanced Capture/Compare/PWM (ECCP) Module' .\nThe control registers for the CCP1 and CCP2 modules are shown in Register 15-1 and Register 15-2, respectively. Table 15-2 details the interactions of the CCP and ECCP modules.",
    "15.0 CAPTURE/COMPARE/PWM (CCP) MODULES\n- \u00b7 CCP1 contains enhanced PWM output with programmable dead band and auto-shutdown functionality",
    "REGISTER 15-1: CCP1CON REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. P1M1, 1 = P1M0. P1M1, 2 = DC1B1. P1M1, 3 = DC1B0. P1M1, 4 = CCP1M3. P1M1, 5 = CCP1M2. P1M1, 6 = CCP1M1. P1M1, 7 = CCP1M0\nbit 7\nbit 0",
    "bit 7-6 P1M1:P1M0: Enhanced PWM Output Configuration bits\nIf CCP1M<3:2> = 00 01 10 , , :\nxx\n=P1A assigned as capture/compare input; P1B, P1C, P1D assigned as port pins",
    "If CCP1M<3:2> = 11 :\n00 = Single output; P1A modulated; P1B, P1C, P1D assigned as port pins\n01 = Full-bridge output forward; P1D modulated; P1A active; P1B, P1C inactive\n10 = Half-bridge output; P1A, P1B modulated with dead-band control; P1C, P1D assigned as port pins\n11 = Full-bridge output reverse; P1B modulated; P1C active; P1A, P1D inactive\nDC1B1:DC1B0 : PWM Duty Cycle bit 1 and bit 0\nCapture mode:\nUnused.\nCompare mode:\nUnused.",
    "PWM mode:\nThese bits are the two LSbs of the 10-bit PWM duty cycle. The eight MSbs of the duty cycle are found in CCPR1L.",
    "bit 3-0 CCP1M3:CCP1M0 : Enhanced CCP Mode Select bits\n0000 = Capture/Compare/PWM off (resets CCP1 module)\n0001 = Reserved\n0010 = Compare mode, toggle output on match\n0011 = Reserved\n0100 = Capture mode, every falling edge\n0101 = Capture mode, every rising edge\n0110 = Capture mode, every 4th rising edge\n0111 = Capture mode, every 16th rising edge\n1000 = Compare mode, initialize CCP pin low, on compare match force CCP pin high\n1001 = Compare mode, initialize CCP pin high, on compare match force CCP pin low\n1010 = Compare mode, generate software interrupt only, CCP pin is unaffected\n1011 = Compare mode, trigger special event, resets TMR1 or TMR3\n1100 = PWM mode; P1A, P1C active-high; P1B, P1D active-high\n1101 = PWM mode; P1A, P1C active-high; P1B, P1D active-low",
    "bit 3-0 CCP1M3:CCP1M0 : Enhanced CCP Mode Select bits\n1110 = PWM mode; P1A, P1C active-low; P1B, P1D active-high\n1111 = PWM mode; P1A, P1C active-low; P1B, P1D active-low",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "PIC18F6585/8585/6680/8680\nREGISTER 15-2:",
    "CCP2CON REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = DC2B1. -, 3 = DC2B0. -, 4 = CCP2M3. -, 5 = CCP2M2. -, 6 = CCP2M1. -, 7 = CCP2M0\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5-4\nDC2B1:DC2B0 : PWM Duty Cycle bit 1 and bit 0\nCapture mode:\nUnused.\nCompare mode:\nUnused.\nPWM mode:\nThese bits are the two LSbs of the 10-bit PWM duty cycle. The eight MSbs of the duty cycle are found in CCPR2L.",
    "bit 3-0 CCP2M3:CCP2M0 : CCP2 Mode Select bits\n0000 = Capture/Compare/PWM off (resets CCP2 module)\n0001 = Reserved\n0010 = Compare mode, toggle output on match\n0011 = Reserved\n0100 = Capture mode, every falling edge\n0101 = Capture mode, every rising edge\n0110 = Capture mode, every 4th rising edge\n0111 = Capture mode, every 16th rising edge\n1000 = Compare mode, initialize CCP pin low, on compare match force CCP pin high\n1001 = Compare mode, initialize CCP pin high, on compare match force CCP pin low\n1010 = Compare mode, generate software interrupt only, CCP pin is unaffected\n1011 = Compare mode, trigger special event, resets TMR1 or TMR3 and starts A/D conversion\nif A/D module is enabled\n11xx = PWM mode",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "15.1 CCP Module\nBoth  CCP1  and  CCP2  are  comprised  of  two  8-bit registers: CCPRxL (low byte) and CCPRxH (high byte), 1 \uf0a3 x \uf0a3 2. The CCPxCON register controls the operation of CCPx. All are readable and writable.\nTable 15-1  shows  the  timer  resources  of  the  CCP module modes.\nTABLE 15-1: CCP MODE - TIMER RESOURCE\n\nCapture Compare PWM, Timer Resource = Timer1 or Timer3 Timer1 or Timer3 Timer2",
    "15.2 Capture Mode\nIn Capture  mode,  CCPRxH:CCPRxL  captures  the 16-bit value  of  the  TMR1 or  TMR3 register  when  an event occurs on pin CCPn. An event is defined as:\n\u00b7 every falling edge\n\u00b7 every rising edge\n\u00b7 every 4th rising edge\n\u00b7 every 16th rising edge",
    "TABLE 15-2: INTERACTION OF CCP MODULES\nCapture, CCP2 Mode = Capture. Capture, Interaction = TMR1 or TMR3 time base. Time base can be different for each CCP.. Capture, CCP2 Mode = Compare. Capture, Interaction = The compare could be configured for the special event trigger which clears either TMR1 or TMR3 depending upon which time base is used.. Compare, CCP2 Mode = Compare. Compare, Interaction = The compare(s) could be configured for the special event trigger which clears TMR1 or TMR3 depending upon which time base is used.. PWM, CCP2 Mode = PWM. PWM, Interaction = The PWMs will have the same frequency and update rate (TMR2 interrupt).. PWM, CCP2 Mode = Capture. PWM, Interaction = None.. PWM, CCP2 Mode = Compare. PWM, Interaction = None.",
    "TABLE 15-2: INTERACTION OF CCP MODULES\nAn event is selected by control bits CCPxM3:CCPxM0 (CCPxCON<3:0>). When a capture is made, the interrupt request flag bit, CCPxIF (PIR registers), is set. It must be cleared in software. If another capture occurs before  the  value  in  register  CCPRx  is  read,  the  old captured value will be lost.",
    "15.2.1 CCP PIN CONFIGURATION\nIn Capture mode, the CCPx pin should be configured as an input by setting the appropriate TRIS bit.\nNote:, 1 = If the CCPx is configured as an output, a write to the port can cause a capture condition.",
    "15.2.2 TIMER1/TIMER3 MODE SELECTION\nThe timer used with each CCP module is selected in the T3CCP2:T3CCP1 bits of the T3CON register. The timers used with the capture feature (either Timer1 or Timer3) must be running in Timer mode or Synchronized Counter mode. In Asynchronous Counter mode, the capture operation may not work.",
    "15.2.3 SOFTWARE INTERRUPT\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user should keep bit CCPxIE (PIE registers) clear to avoid false interrupts and  should  clear  the  flag  bit,  CCPxIF,  following  any such change in operating mode.",
    "15.2.4 CCP PRESCALER\nThere  are  four  prescaler  settings  specified  by  bits CCPxM3:CCPxM0.  Whenever  the  CCPx  module  is turned off, or the CCPx module is not in Capture mode, the prescaler counter is cleared. This means that any Reset will clear the prescaler counter.",
    "15.2.5 CAN MESSAGE TIME-STAMP\nThe  CAN  capture  event  occurs  when  a  message  is received  in  any  of  the  receive  buffers.  When  configured, the CAN module provides the trigger to the CCP1 module  to  cause  a  capture  event.  This  feature  is provided to time-stamp the received CAN messages.\nThis feature is enabled by setting the CANCAP bit of the CAN  I/O  Control  register  (CIOCON<4>).  The message  receive  signal  from  the  CAN  module  then takes the place of the events on RC2/CCP1.",
    "EXAMPLE 15-1: CHANGING BETWEEN CAPTURE PRESCALERS\nSwitching from one capture prescaler to another may generate an interrupt. The prescaler counter will not be cleared;  therefore,  the  first  capture  may  be  from  a non-zero prescaler. Example 15-1 shows the recommended method for switching between capture prescalers.  This  example  also  clears  the  prescaler counter and will not generate the 'false' interrupt.\nCLRF MOVLW, 1 = CCP1CON NEW_CAPT_PS. CLRF MOVLW, 2 = ; Turn CCP module off ; Load WREG with the ; new prescaler mode ; value and CCP ON. MOVWF, 1 = CCP1CON. MOVWF, 2 = ; Load CCP1CON with ; this value",
    "15.3 Compare Mode\nIn Compare mode, the 16-bit CCPRx register value is constantly compared against either the TMR1 register pair  value  or  the  TMR3  register  pair  value.  When  a match  occurs,  the  CCPx  pin  can  have  one  of  the following actions:\n\u00b7 Driven high\n\u00b7 Driven low\n\u00b7 Toggle output (high-to-low or low-to-high)\n\u00b7 Remains unchanged\nThe action on the pin is based on the value of control bits,  CCPxM3:CCPxM0.  At  the  same  time,  interrupt flag bit, CCPxIF, is set.\nWhen configured to drive the CCP pin, the CCP1 pin cannot be changed; CCP1 module controls the pin.",
    "15.3.1 CCP PIN CONFIGURATION\nThe user must configure the CCPx pin as an output by clearing the appropriate TRIS bit.\nBy  default,  the  CCP2  pin  is  multiplexed  with  RC1. Alternately, it can also be multiplexed with either RB3 or RE7.  This  is  done  by  changing  the  CCP2MX configuration bit.",
    "Note:\nClearing the CCPxCON register will force the  CCPx  compare  output  latch  to  the default low level. This is not the data latch.",
    "15.3.2 TIMER1/TIMER3 MODE SELECTION\nThe timer used with each CCP module is selected in the  T3CCP2:T3CCP1  bits  of  the  T3CON  register. Timer1 and/or Timer3 must be running in Timer mode, or Synchronized Counter mode, if the CCP module is using the compare feature. In Asynchronous Counter mode, the compare operation may not work.",
    "15.3.3 SOFTWARE INTERRUPT MODE\nWhen generate software interrupt is chosen, the CCPx pin is not affected. Only a CCP interrupt is generated (if enabled).",
    "15.3.4 SPECIAL EVENT TRIGGER\nIn this mode, an internal hardware trigger is generated which may be used to initiate an action.\nThe special event trigger output of CCP1 resets either the TMR1 or TMR3 register pair. This allows the CCPR1 register to effectively be a 16-bit programmable period register for TMR1 or TMR3.\nAdditionally, the CCP2 special event trigger will start an A/D conversion if the A/D module is enabled.",
    "Note:\nThe special event trigger from the CCPx module will not set the Timer1 or Timer3 interrupt flag bits.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on all other Resets = 000x 0000. INTCON, Value on all other Resets = 000u. INTCON,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000 0000. PIR1, Value on all other Resets = 0000. PIR1,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000 0000. PIE1, Value on all other Resets = 0000. PIE1,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111 1111. IPR1, Value on all other Resets = 1111. IPR1,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Value on POR, BOR = 1111. TRISD, Value on all other Resets = 1111 1111. TRISD, Value on all other Resets = 1111. TRISD,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TMR1L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Value on POR, BOR = xxxx.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR1L, Value on all other Resets = xxxx uuuu. TMR1L, Value on all other Resets = uuuu. TMR1L,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Value on POR, BOR = xxxx.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR1H, Value on all other Resets = xxxx uuuu. TMR1H, Value on all other Resets = uuuu. TMR1H,\n= . T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00. T1CON, Value on all other Resets = 0000 u-uu. T1CON, Value on all other Resets = uuuu. T1CON,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on all other Resets = xxxx uuuu. CCPR1L, Value on all other Resets = uuuu. CCPR1L,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . CCPR1H, Bit 7 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on all other Resets = xxxx uuuu. CCPR1H, Value on all other Resets = uuuu. CCPR1H,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . CCP1CON, Bit 7 = P1M1. CCP1CON, Bit 6 = P1M0. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on all other Resets = 0000 0000. CCP1CON, Value on all other Resets = 0000. CCP1CON,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = -0-0. PIR2, Value on all other Resets = 0000 -0-0. PIR2, Value on all other Resets = 0000. PIR2,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR, BOR = -0-0. PIE2, Value on all other Resets = 0000 -0-0. PIE2, Value on all other Resets = 0000. PIE2,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = -1-1. IPR2, Value on all other Resets = 1111 -1-1. IPR2, Value on all other Resets = 1111. IPR2,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TMR3L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Value on POR, BOR = xxxx.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3L, Value on all other Resets = xxxx uuuu. TMR3L, Value on all other Resets = uuuu. TMR3L,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TMR3H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Value on POR, BOR = xxxx.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3H, Value on all other Resets = xxxx uuuu. TMR3H, Value on all other Resets = uuuu. TMR3H,\n= . T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3CCP2. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000. T3CON, Value on all other Resets = 0000 uuuu. T3CON, Value on all other Resets = uuuu. T3CON,  = \nLegend:\nx = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by capture and Timer1.",
    "15.4 PWM Mode\nIn Pulse Width Modulation (PWM) mode, the CCPx pin produces  up  to  a  10-bit  resolution  PWM  output.  For PWM mode to function properly, the TRIS bit for the CCPx pin must be cleared to make it an output.\nNote:, 1 = Clearing the CCPxCON register will force the CCPx PWM output latch to the default low level. This is not the port data latch.\nFigure 15-3  shows  a  simplified  block  diagram  of  the CCP module in PWM mode.\nFor a step-by-step procedure on how to set up the CCP module for PWM  operation, see Section 15.4.3 'Setup for PWM Operation' .",
    "FIGURE 15-3: SIMPLIFIED PWM BLOCK DIAGRAM\nA PWM output (Figure 15-4) has a time base (period) and a time that the output stays high (duty cycle). The frequency  of  the  PWM  is  the  inverse  of  the  period (1/period).",
    "15.4.1 PWM PERIOD\nThe  PWM  period  is  specified  by  writing  to  the  PR2 register. The PWM period can be calculated using the following formula.",
    "EQUATION 15-1:\nPWM Period  = [(PR2) + 1] \u2022 4 \u2022 TOSC \u2022 (TMR2 Prescale Value)\nPWM frequency is defined as 1/[PWM period].\nWhen TMR2 is equal to PR2, the following three events occur on the next increment cycle:\n\u00b7 TMR2 is cleared\n\u00b7 The CCP1 pin is set (exception: if PWM duty cycle = 0%, the CCP1 pin will not be set)\n\u00b7 The PWM duty cycle is latched from CCPR1L into CCPR1H\nNote:\nThe Timer2 postscaler (see Section 13.0 'Timer2  Module' ) is not  used  in  the determination of the PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.",
    "15.4.2 PWM DUTY CYCLE\nThe  PWM  duty  cycle  is  specified  by  writing  to  the CCPRxL register and to the CCPxCON<5:4> bits. Up to 10-bit resolution is available. The CCPRxL contains the eight MSbs and the CCPxCON<5:4> contain the two LSbs. This 10-bit value is represented by CCPRxL:CCPxCON<5:4>.  The  following  equation  is used to calculate the PWM duty cycle in time.",
    "EQUATION 15-2:\nPWM Duty Cycle  = (CCPRxL:CCPxCON<5:4>) \u00b7 TOSC \u00b7 (TMR2 Prescale Value)\nCCPRxL and CCPxCON<5:4> can be written to at any time  but  the  duty  cycle  value  is  not  latched  into CCPRxH until after a match between PR2 and TMR2 occurs  (i.e.,  the  period  is  complete).  In  PWM  mode, CCPRxH is a read-only register.\nThe  CCPRxH  register  and  a  2-bit  internal  latch  are used  to  double-buffer  the PWM  duty  cycle.  This double-buffering is essential for glitchless PWM operation.\nWhen  the  CCPRxH  and  2-bit  latch  match  TMR2, concatenated with an internal 2-bit Q clock or 2 bits of the TMR2 prescaler, the CCPx pin is cleared.",
    "PIC18F6585/8585/6680/8680\nThe maximum PWM resolution (bits) for a given PWM frequency is given by the following equation.",
    "EQUATION 15-3:\n<!-- formula-not-decoded -->\nThe following steps should be taken when configuring the CCP module for PWM operation:\n1. Set  the  PWM  period  by  writing  to  the  PR2 register.\n2. Set  the  PWM  duty  cycle  by  writing  to  the CCPRxL register and CCPxCON<5:4> bits.\n3. Make  the  CCPx  pin  an  output  by  clearing corresponding TRIS bit.\n4. Set the TMR2 prescale value and enable Timer2 by writing to T2CON.\n5. Configure the CCPx module for PWM operation.\nNote:, 1 = If the PWMduty cycle value is longer than the PWM period, the CCP1 pin will not be cleared.",
    "TABLE 15-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\nTimer Prescaler (1, 4, 16), 2.44 kHz = 16. Timer Prescaler (1, 4, 16), 9.76 kHz = 4. Timer Prescaler (1, 4, 16), 39.06 kHz = 1. Timer Prescaler (1, 4, 16), 156.3 kHz = 1. Timer Prescaler (1, 4, 16), 312.5 kHz = 1. Timer Prescaler (1, 4, 16), 416.6 kHz = 1. PR2 Value, 2.44 kHz = 0FFh. PR2 Value, 9.76 kHz = 0FFh. PR2 Value, 39.06 kHz = 0FFh. PR2 Value, 156.3 kHz = 3Fh. PR2 Value, 312.5 kHz = 1Fh. PR2 Value, 416.6 kHz = 17h. Maximum Resolution (bits), 2.44 kHz = 10. Maximum Resolution (bits), 9.76 kHz = 10. Maximum Resolution (bits), 39.06 kHz = 10. Maximum Resolution (bits), 156.3",
    "TABLE 15-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\nkHz = 8. Maximum Resolution (bits), 312.5 kHz = 7. Maximum Resolution (bits), 416.6 kHz = 5.5",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on all other Resets = 000x 0000. INTCON, Value on all other Resets = 000u. INTCON,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000 0000. PIR1, Value on all other Resets = 0000. PIR1,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000 0000. PIE1, Value on all other Resets = 0000. PIE1,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111 1111. IPR1, Value on all other Resets = 1111. IPR1,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on all other Resets = 1111 1111. TRISC, Value on all other Resets = 1111. TRISC,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on all other Resets = 0000 0000. TMR2, Value on all other Resets = 0000. TMR2,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . PR2, Bit 7 = Timer2 Module Period Register. PR2, Bit 6 = Timer2 Module Period Register. PR2, Bit 5 = Timer2 Module Period Register. PR2, Bit 4 = Timer2 Module Period Register. PR2, Bit 3 = Timer2 Module Period Register. PR2, Bit 2 = Timer2 Module Period Register. PR2, Bit 1 = Timer2 Module Period Register. PR2, Bit 0 = Timer2 Module Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on all other Resets = 1111 1111. PR2, Value on all other Resets = 1111. PR2,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on all other Resets = 0000 -000. T2CON, Value on all other Resets = 0000. T2CON,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on all other Resets = xxxx uuuu. CCPR1L, Value on all other Resets = uuuu. CCPR1L,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . CCPR1H, Bit 7 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on all other Resets = xxxx uuuu. CCPR1H, Value on all other Resets = uuuu. CCPR1H,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . CCP1CON, Bit 7 = P1M1. CCP1CON, Bit 6 = P1M0. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on all other Resets = 0000 0000. CCP1CON, Value on all other Resets = 0000. CCP1CON,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . CCPR2L, Bit 7 = Capture/Compare/PWM Register 2 (LSB). CCPR2L, Bit 6 = Capture/Compare/PWM Register 2 (LSB). CCPR2L, Bit 5 = Capture/Compare/PWM Register 2 (LSB). CCPR2L, Bit 4 = Capture/Compare/PWM Register 2 (LSB). CCPR2L, Bit 3 = Capture/Compare/PWM Register 2 (LSB). CCPR2L, Bit 2 = Capture/Compare/PWM Register 2 (LSB). CCPR2L, Bit 1 = Capture/Compare/PWM Register 2 (LSB). CCPR2L, Bit 0 = Capture/Compare/PWM Register 2 (LSB). CCPR2L, Value on POR, BOR = xxxx. CCPR2L, Value on all other Resets = xxxx uuuu. CCPR2L, Value on all other Resets = uuuu. CCPR2L,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . CCPR2H, Bit 7 = Capture/Compare/PWM Register 2 (MSB). CCPR2H, Bit 6 = Capture/Compare/PWM Register 2 (MSB). CCPR2H, Bit 5 = Capture/Compare/PWM Register 2 (MSB). CCPR2H, Bit 4 = Capture/Compare/PWM Register 2 (MSB). CCPR2H, Bit 3 = Capture/Compare/PWM Register 2 (MSB). CCPR2H, Bit 2 = Capture/Compare/PWM Register 2 (MSB). CCPR2H, Bit 1 = Capture/Compare/PWM Register 2 (MSB). CCPR2H, Bit 0 = Capture/Compare/PWM Register 2 (MSB). CCPR2H, Value on POR, BOR = xxxx. CCPR2H, Value on all other Resets = xxxx uuuu. CCPR2H, Value on all other Resets = uuuu. CCPR2H,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . CCP2CON, Bit 7 = -. CCP2CON, Bit 6 = -. CCP2CON, Bit 5 = DC2B1. CCP2CON, Bit 4 = DC2B0. CCP2CON, Bit 3 = CCP2M3. CCP2CON, Bit 2 = CCP2M2. CCP2CON, Bit 1 = CCP2M1. CCP2CON, Bit 0 = CCP2M0. CCP2CON, Value on POR, BOR = --00. CCP2CON, Value on all other Resets = 0000 --00. CCP2CON, Value on all other Resets = 0000. CCP2CON,  = \nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by PWM and Timer2.",
    "16.0 ENHANCED CAPTURE/ COMPARE/PWM (ECCP) MODULE\nThe control register for CCP1 is shown in Register 16-1.\nThe CCP1 module is implemented as a standard CCP module with enhanced PWM capabilities. These capabilities allow for 2 or 4 output channels, user selectable polarity,  dead-band  control,  and  automatic  shutdown and restart and are discussed in detail in Section 16.2 'Enhanced PWM Mode' .\nIn addition to the expanded functions of the CCP1CON  register, the CCP1  module  has two additional  registers  associated  with  enhanced  PWM operation and auto-shutdown features:\n\u00b7 ECCP1DEL\n\u00b7 ECCP1AS",
    "REGISTER 16-1: CCP1CON REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. P1M1, 1 = P1M0. P1M1, 2 = DC1B1. P1M1, 3 = DC1B0. P1M1, 4 = CCP1M3. P1M1, 5 = CCP1M2. P1M1, 6 = CCP1M1. P1M1, 7 = CCP1M0\nbit 7\nbit 0",
    "bit 7-6 P1M1:P1M0: Enhanced PWM Output Configuration bits\nIf CCP1M<3:2> = 00 01 10 , , :\nxx\n= P1A assigned as capture/compare input; P1B, P1C, P1D assigned as port pins",
    "If CCP1M<3:2> = 11 :\n00 = Single output; P1A modulated, P1B, P1C, P1D assigned as port pins\n01 = Full-bridge output forward; P1D modulated; P1A active; P1B, P1C inactive\n10 = Half-bridge output; P1A, P1B modulated with dead-band control; P1C, P1D assigned as port pins\n11 = Full-bridge output reverse; P1B modulated; P1C active; P1A, P1D inactive",
    "bit 5-4 DC1B1:DC1B0 : PWM Duty Cycle bit 1 and bit 0\nCapture mode:\nUnused.\nCompare mode:\nUnused.\nPWM mode:\nThese bits are the two LSbs of the 10-bit PWM duty cycle. The eight MSbs of the duty cycle are found in CCPR1L.",
    "bit 3-0 CCP1M3:CCP1M0 : Enhanced CCP Mode Select bits\n0000 =Capture/Compare/PWM off (resets CCP1 module)\n0001 =Reserved\n0010 =Compare mode, toggle output on match\n0011 =Capture mode, CAN message time-stamp\n0100 =Capture mode, every falling edge\n0101 =Capture mode, every rising edge\n0110 =Capture mode, every 4th rising edge\n0111 =Capture mode, every 16th rising edge\n1000 =Compare mode, initialize CCP pin low, on compare match, force CCP pin high\n1001 =Compare mode, initialize CCP pin high, on compare match, force CCP pin low\n1010 =Compare mode, generate software interrupt only, CCP pin is unaffected\n1011 =Compare mode, trigger special event, resets TMR1 or TMR3\n1100 =PWM mode; P1A, P1C active-high; P1B, P1D active-high\n1101 =PWM mode; P1A, P1C active-high; P1B, P1D active-low",
    "bit 3-0 CCP1M3:CCP1M0 : Enhanced CCP Mode Select bits\n1110 =PWM mode; P1A, P1C active-low; P1B, P1D active-high\n1111 =PWM mode; P1A, P1C active-low; P1B, P1D active-low",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "16.1 ECCP Outputs\nThe  enhanced  CCP  module  may  have  up  to  four outputs  depending  on  the  selected  operating  mode. These  outputs,  designated  P1A  through  P1D,  are multiplexed  with  I/O  pins  RC2,  RE6,  RE5  and  RG4. The pin assignments are summarized in Table 16-1.\nTo configure I/O pins as PWM outputs, the proper PWM mode  must  be  selected  by  setting  the  P1Mx  and CCP1Mx  bits  (CCP1CON<7:6>  and  <3:0>,  respectively). The appropriate TRIS direction bits for the port pins must also be set as outputs.",
    "TABLE 16-1: PIN ASSIGNMENTS FOR VARIOUS ECCP MODES\nCompatible CCP, CCP1CON Configuration = 00xx11xx. Compatible CCP, RC2 = CCP1. Compatible CCP, RE6 = RE6. Compatible CCP, RE5 = RE5. Compatible CCP, RG4 = RG4. Dual PWM, CCP1CON Configuration = 10xx11xx. Dual PWM, RC2 = P1A. Dual PWM, RE6 = P1B (2). Dual PWM, RE5 = RE5. Dual PWM, RG4 = RG4. Quad PWM, CCP1CON Configuration = x1xx11xx. Quad PWM, RC2 = P1A. Quad PWM, RE6 = P1B (2). Quad PWM, RE5 = P1C (2). Quad PWM, RG4 = P1D\nLegend: x = Don't care. Shaded cells indicate pin assignments not used by ECCP in a given mode.",
    "TABLE 16-1: PIN ASSIGNMENTS FOR VARIOUS ECCP MODES\nNote 1: TRIS register values must be configured appropriately.\n2: On PIC18F8X8X devices, these pins can be alternately multiplexed with RH7 or RH6 by changing the ECCPMX configuration bit.",
    "16.2 Enhanced PWM Mode\nThe Enhanced PWM mode provides additional PWM output options for a broader range of control applications. The module is a backward compatible version of the standard CCP module and offers up to four outputs, designated P1A through P1D. Users are also able to select  the  polarity  of  the  signal  (either  active-high  or active-low). The module's output mode and polarity are configured by setting the P1M1:P1M0 and CCP1M3:CCP1M0  bits  of  the  CCP1CON  register (CCP1CON<7:6> and CCP1CON<3:0>, respectively).",
    "16.2 Enhanced PWM Mode\nFigure 16-2 shows a simplified block diagram of PWM operation. All control registers are double-buffered and are loaded at the beginning of a new PWM cycle (the period boundary when Timer2 resets) in order to prevent glitches on any of the outputs. The exception is the PWM Delay register, ECCP1DEL, which is loaded at either the duty cycle boundary or the boundary period (whichever comes first). Because of the buffering, the module waits until the assigned timer resets instead of starting immediately. This means that enhanced PWM waveforms  do  not  exactly  match  the  standard  PWM waveforms, but are instead offset by one full instruction cycle (4 TOSC).\nAs  before,  the  user  must  manually  configure  the appropriate TRIS bits for output.",
    "16.2.1 PWM PERIOD\nThe  PWM  period  is  specified  by  writing  to  the  PR2 register. The PWM period can be calculated using the following equation.",
    "EQUATION 16-1:\nPWM Period   =\n[(PR2) + 1] \u2022 4 \u2022 TOSC \u2022\n(TMR2 Prescale Value)\nPWM frequency is defined as 1/[PWM period]. When TMR2 is equal to PR2, the following three events occur on the next increment cycle:\n\u00b7 TMR2 is cleared\n\u00b7 The CCP1 pin is set (if PWM duty cycle = 0%, the CCP1 pin will not be set)\n\u00b7 The PWM duty cycle is copied from CCPR1L into CCPR1H\nNote:\nThe Timer2 postscaler (see Section 13.0 'Timer2  Module' ) is not  used  in  the determination of the PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.",
    "16.2.2 PWM DUTY CYCLE\nThe  PWM  duty  cycle  is  specified  by  writing  to  the CCPR1L register and to the CCP1CON<5:4> bits. Up to 10-bit resolution is available. The CCPR1L contains the eight MSbs and the CCP1CON<5:4> contains the two LSbs. This 10-bit value is represented by CCPR1L:CCP1CON<5:4>.  The  PWM  duty  cycle  is calculated by the following equation.",
    "EQUATION 16-2:\nPWM Duty Cycle  = (CCPR1L:CCP1CON<5:4>) \u00b7 TOSC \u00b7 (TMR2 Prescale Value)\nCCPR1L and CCP1CON<5:4> can be written to at any time,  but  the  duty  cycle  value  is  not  copied  into CCPR1H until a match between PR2 and TMR2 occurs (i.e., the period is complete). In PWM mode, CCPR1H is a read-only register.\nThe  CCPR1H  register  and  a  2-bit  internal  latch  are used  to  double-buffer  the PWM  duty  cycle.  This double-buffering is essential for glitchless PWM operation. When the CCPR1H and 2-bit latch match TMR2, concatenated with an internal 2-bit Q clock or two bits of the TMR2 prescaler, the CCP1 pin is cleared. The maximum  PWM  resolution  (bits)  for  a  given  PWM frequency is given by the following equation:",
    "EQUATION 16-3:\n<!-- formula-not-decoded -->\nNote:\nIf the PWM duty cycle value is longer than the PWM period, the CCP1 pin will not be cleared.",
    "16.2.3 PWM OUTPUT CONFIGURATIONS\nThe P1M1:P1M0 bits in the CCP1CON register allow one of four configurations:\n\u00b7 Single Output\n\u00b7 Half-Bridge Output\n\u00b7 Full-Bridge Output, Forward mode\n\u00b7 Full-Bridge Output, Reverse mode\nThe Single Output mode is the standard PWM mode discussed in Section 16.2 'Enhanced PWM Mode' . The  Half-Bridge  and  Full-Bridge  Output  modes  are covered in detail in the sections that follow.\nThe general relationship of the outputs in all configurations is summarized in Figure 16-3.",
    "TABLE 16-2: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\nTimer Prescaler (1, 4, 16), 2.44 kHz = 16. Timer Prescaler (1, 4, 16), 9.77 kHz = 4. Timer Prescaler (1, 4, 16), 39.06 kHz = 1. Timer Prescaler (1, 4, 16), 156.25 kHz = 1. Timer Prescaler (1, 4, 16), 312.50 kHz = 1. Timer Prescaler (1, 4, 16), 416.67 kHz = 1. PR2 Value, 2.44 kHz = FFh. PR2 Value, 9.77 kHz = FFh. PR2 Value, 39.06 kHz = FFh. PR2 Value, 156.25 kHz = 3Fh. PR2 Value, 312.50 kHz = 1Fh. PR2 Value, 416.67 kHz = 17h. Maximum Resolution (bits), 2.44 kHz = 10. Maximum Resolution (bits), 9.77 kHz = 10. Maximum Resolution (bits), 39.06 kHz = 10. Maximum Resolution (bits), 156.25 kHz =",
    "TABLE 16-2: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\n8. Maximum Resolution (bits), 312.50 kHz = 7. Maximum Resolution (bits), 416.67 kHz = 6.58",
    "FIGURE 16-3: PWM OUTPUT RELATIONSHIPS (ACTIVE-HIGH STATE)\n00, CCP1CON <7:6> = (Single Output). 00, SIGNAL = P1A Modulated. 00, 0 = Delay (1). 00,  = Delay (1). 00, PR2 + 1 = . 10, CCP1CON <7:6> = (Half-Bridge). 10, SIGNAL = P1B Modulated. 10, 0 = . 10,  = . 10, PR2 + 1 = . 01, CCP1CON <7:6> = (Full-Bridge, Forward). 01, SIGNAL = P1A Active. 01, 0 = . 01,  = . 01, PR2 + 1 = . , CCP1CON <7:6> = P1D. , SIGNAL = P1B Inactive P1C Inactive. , 0 = . ,  = . , PR2 + 1 = . 11, CCP1CON <7:6> = . 11, SIGNAL = Modulated P1A Inactive. 11, 0 = . 11,",
    "FIGURE 16-3: PWM OUTPUT RELATIONSHIPS (ACTIVE-HIGH STATE)\n= . 11, PR2 + 1 = . , CCP1CON <7:6> = (Full-Bridge, Reverse). , SIGNAL = P1B Modulated P1C Active. , 0 = . ,  = . , PR2 + 1 = . , CCP1CON <7:6> = . , SIGNAL = Inactive. , 0 = . ,  = . , PR2 + 1 = . , CCP1CON <7:6> = P1D. , SIGNAL = . , 0 = . ,  = . , PR2 + 1 = . using, CCP1CON <7:6> = . using, SIGNAL = . using, 0 = ECCP1DEL register. using,  = 16.2.6 'Programmable. using, PR2 + 1 = . programmed, CCP1CON <7:6> = . programmed, SIGNAL = . programmed, 0 = . programmed,",
    "FIGURE 16-3: PWM OUTPUT RELATIONSHIPS (ACTIVE-HIGH STATE)\n= . programmed, PR2 + 1 = . Note Dead-band delay is, CCP1CON <7:6> = . Note Dead-band delay is, SIGNAL = . Note Dead-band delay is, 0 = . Note Dead-band delay is,  = . Note Dead-band delay is, PR2 + 1 = . 1:, CCP1CON <7:6> = . 1:, SIGNAL = . 1:, 0 = . 1:,  = . 1:, PR2 + 1 = ",
    "FIGURE 16-4: PWM OUTPUT RELATIONSHIPS (ACTIVE-LOW STATE)\nNote 1: Dead-band delay is programmed using the ECCP1DEL register ( Section 16.2.6 'Programmable Dead-Band Delay' ).",
    "Relationships:\n\u00b7 Period = 4 * TOSC * (PR2 + 1) * (TMR2 prescale value)\n\u00b7 Duty Cycle = TOSC * (CCPR1L<7:0>:CCP1CON<5:4>) * (TMR2 prescale value)\n\u00b7 Delay = 4 * TOSC * (PWM1CON<6:0>)",
    "16.2.4 HALF-BRIDGE MODE\nIn the Half-Bridge Output mode, two pins are used as outputs to drive push-pull loads. The PWM output signal is output on the P1A pin while the complementary PWM output  signal  is  output  on  the  P1B  pin  (Figure 16-5). This mode can be used for half-bridge applications, as shown  in  Figure 16-6,  or  for  full-bridge  applications where four power switches are being modulated with two PWM signals.\nIn Half-Bridge Output mode, the programmable deadband  delay  can  be  used  to  prevent  shoot-through current in half-bridge power devices. The value of bits PDC6:PDC0  sets  the  number  of  instruction  cycles before the output is driven active. If the value is greater than the duty cycle, the corresponding output remains inactive  during  the  entire  cycle.  See Section 16.2.6 'Programmable Dead-Band Delay' for more details of the dead-band delay operations.",
    "16.2.4 HALF-BRIDGE MODE\nSince the P1A and P1B outputs are multiplexed with the  PORTC<2>  and  PORTE<6>  data  latches,  the TRISC<2>  and  TRISE<6>  bits  must  be  cleared  to configure P1A and P1B as outputs.\nFIGURE 16-5: HALF-BRIDGE PWM OUTPUT\nNote 1: At this time, the TMR2 register is equal to the PR2 register.\n2: Output signals are shown as active-high.",
    "16.2.5 FULL-BRIDGE MODE\nIn  Full-Bridge  Output  mode,  four  pins  are  used  as outputs; however, only two outputs are active at a time. In the Forward mode, pin P1A is continuously active and pin P1D is modulated. In the Reverse mode, pin PGC is continuously active and pin P1B is modulated. These are illustrated in Figure 16-7.\nP1A, P1B, P1C and P1D outputs are multiplexed with the  PORTC<2>,  PORTE<6:5>  and  PORTG<4>  data latches. The TRISC<2>, TRISC<6:5> and TRISG<4> bits must be cleared to make the P1A, P1B, P1C and P1D pins outputs.\nFIGURE 16-7: FULL-BRIDGE PWM OUTPUT",
    "16.2.5 FULL-BRIDGE MODE\nP1A (2), Forward Mode. = . P1A (2), Forward Mode.Period = . P1A (2), Forward Mode. = . P1A (2), Forward Mode. = . , Forward Mode. = Duty Cycle. , Forward Mode.Period = . , Forward Mode. = . , Forward Mode. = . P1B (2), Forward Mode. = . P1B (2), Forward Mode.Period = . P1B (2), Forward Mode. = . P1B (2), Forward Mode. = . P1C (2), Forward Mode. = . P1C (2), Forward Mode.Period = . P1C (2), Forward Mode. = . P1C (2), Forward Mode. = . P1D (2), Forward Mode. = . P1D (2), Forward Mode.Period = . P1D (2), Forward Mode. = . P1D (2), Forward Mode. = . , Forward Mode. = (1). , Forward Mode.Period = . , Forward Mode. =",
    "16.2.5 FULL-BRIDGE MODE\n(1). , Forward Mode. = . Reverse Mode, Forward Mode. = Reverse Mode. Reverse Mode, Forward Mode.Period = Reverse Mode. Reverse Mode, Forward Mode. = Reverse Mode. Reverse Mode, Forward Mode. = Reverse Mode. , Forward Mode. = . , Forward Mode.Period = Period. , Forward Mode. = . , Forward Mode. = . , Forward Mode. = Duty Cycle. , Forward Mode.Period = . , Forward Mode. = . , Forward Mode. = . P1A (2), Forward Mode. = . P1A (2), Forward Mode.Period = . P1A (2), Forward Mode. = . P1A (2), Forward Mode. = . (2), Forward Mode. = . (2), Forward Mode.Period = . (2), Forward Mode. = . (2), Forward Mode. = . P1B, Forward Mode. = . P1B, Forward Mode.Period = . P1B, Forward Mode. = . P1B, Forward Mode. = . P1C (2), Forward Mode. = . P1C (2), Forward",
    "16.2.5 FULL-BRIDGE MODE\nMode.Period = . P1C (2), Forward Mode. = . P1C (2), Forward Mode. = . (2), Forward Mode. = . (2), Forward Mode.Period = . (2), Forward Mode. = . (2), Forward Mode. = . P1D, Forward Mode. = . P1D, Forward Mode.Period = . P1D, Forward Mode. = . P1D, Forward Mode. = . , Forward Mode. = (1). , Forward Mode.Period = . , Forward Mode. = (1). , Forward Mode. = . Note 1: At this time, the TMR2 register is equal to the PR2 register., Forward Mode. = Note 1: At this time, the TMR2 register is equal to the PR2 register.. Note 1: At this time, the TMR2 register is equal to the PR2 register., Forward Mode.Period = Note 1: At this time, the TMR2 register is equal to the PR2 register.. Note 1: At this time, the TMR2 register is equal to",
    "16.2.5 FULL-BRIDGE MODE\nthe PR2 register., Forward Mode. = Note 1: At this time, the TMR2 register is equal to the PR2 register.. Note 1: At this time, the TMR2 register is equal to the PR2 register., Forward Mode. = Note 1: At this time, the TMR2 register is equal to the PR2 register.",
    "16.2.5.1 Direction Change in Full-Bridge Mode\nIn  the  Full-Bridge  Output  mode,  the  P1M1  bit  in  the CCP1CON  register  allows  the  user  to  control  the forward/reverse direction. When the application firmware changes this direction control bit, the module will assume the new direction on the next PWM cycle.\nJust before the end of the current PWM period, the modulated outputs (P1B and P1D) are placed in their inactive state while the unmodulated outputs (P1A and P1C) are switched to drive in the opposite direction. This occurs in a  time  interval  of  (4  TOSC  *  (Timer2  Prescale  value)) before the next PWM  period  begins.  The  Timer2 prescaler  will  be  either  1,  4  or  16,  depending  on  the value  of  the  T2CKPS  bit  (T2CON<1:0>).  During  the interval from the switch of the unmodulated outputs to the beginning of the next period, the modulated outputs (P1B  and  P1D)  remain  inactive.  This  relationship  is shown in Figure 16-9.",
    "16.2.5.1 Direction Change in Full-Bridge Mode\nNote that in  the  Full-Bridge  Output  mode,  the  CCP1 module  does  not  provide  any  dead-band  delay.  In general, since only one output is modulated at all times, dead-band delay is not required. However, there is a situation where a dead-band delay might be required. This situation occurs  when  both  of  the  following conditions are true:\n1. The direction of the PWM output changes when the duty cycle of the output is at or near 100%.\n2. The turn off time of the power switch, including the  power  device  and  driver  circuit,  is  greater than the turn on time.",
    "16.2.5.1 Direction Change in Full-Bridge Mode\nFigure 16-10 shows an example where the PWM direction changes from forward to reverse at a near 100% duty cycle. At time t1, the output P1A and P1D become inactive  while  output  P1C  becomes  active.  In  this example, since the turn off time of the power devices is longer than the turn on time, a shoot-through current may  flow  through  power  devices  QC  and  QD  (see Figure 16-8) for the duration of 't'. The same phenomenon will occur to power devices QA and QB for PWM direction change from reverse to forward.\nIf changing PWM direction at high duty cycle is required for  an  application,  one  of  the  following  requirements must be met:\n1. Reduce PWM  for a PWM  period before changing directions.\n2. Use switch drivers that can drive the switches off faster than they can drive them on.\nOther  options  to  prevent  shoot-through  current  may exist.",
    "16.2.6 PROGRAMMABLE DEAD-BAND DELAY\nIn half-bridge applications where all power switches are modulated  at  the  PWM  frequency  at  all  times,  the power switches normally require more time to turn off than  to  turn  on.  If  both  the  upper  and  lower  power switches are switched at the same time (one turned on and the other turned off), both switches may be on for a short period of time until one switch completely turns off. During this brief interval, a very high current (shootthrough current) may flow through both power switches,  shorting  the  bridge  supply.  To  avoid  this potentially destructive shoot-through current from flowing  during  switching,  turning  on  either  of  the  power switches is normally delayed to allow the other switch to completely turn off.",
    "16.2.6 PROGRAMMABLE DEAD-BAND DELAY\nA shutdown event can be caused by either of the two comparator modules or a low level on the RB0 pin (or any combination of these three sources). The comparators may be used to monitor a voltage input proportional to a current being monitored in the bridge circuit. If  the  voltage  exceeds  a  threshold,  the  comparator switches state and triggers a shutdown. Alternatively, a low  digital  signal  on  the  RB0  pin  can  also  trigger  a shutdown. The auto-shutdown feature can be disabled by  not  selecting  any  auto-shutdown  sources.  The auto-shutdown sources to be used are selected using the ECCPAS2:ECCPAS0  bits (bits <6:4> of the ECCP1AS register).",
    "16.2.6 PROGRAMMABLE DEAD-BAND DELAY\nIn the Half-Bridge Output mode,  a digitally programmable  dead-band  delay  is  available  to  avoid shoot-through current from destroying the bridge power  switches. The  delay occurs at the signal transition from the non-active state to the active state. See Figure 16-5 for an illustration. The lower seven bits of  the  ECCP1DEL  register  (Register 16-2)  set  the delay  period  in  terms  of  microcontroller  instruction cycles (TCY or 4 TOSC).",
    "16.2.7 ENHANCED PWM AUTO-SHUTDOWN\nWhen a shutdown occurs, the output pins  are asynchronously placed in their shutdown states, specified by the PSSAC1:PSSAC0 and PSSBD1:PSSBD0 bits (ECCP1AS<3:0>). Each pin pair (P1A/P1C and P1B/ P1D) may be set to drive high, drive low, or be tri-stated (not driving). The ECCPASE bit (ECCP1AS<7>) is also set to hold the enhanced  PWM  outputs  in  their shutdown states.\nThe ECCPASE bit is set by hardware when a shutdown event occurs. If automatic restarts are not enabled, the ECCPASE bit is cleared by firmware when the cause of the shutdown clears. If automatic restarts are enabled, the  ECCPASE  bit  is  automatically  cleared  when  the cause of the auto-shutdown has cleared.",
    "16.2.7 ENHANCED PWM AUTO-SHUTDOWN\nWhen  the  CCP1  is  programmed  for  any  of  the enhanced PWM modes, the active output pins may be configured for auto-shutdown. Auto-shutdown immediately  places  the  enhanced  PWM  output  pins  into  a defined shutdown  state when  a shutdown event occurs.\nIf the ECCPASE bit is set when a PWM period begins, the PWM outputs remain in their shutdown state for that entire PWM period. When the ECCPASE bit is cleared, the PWM outputs will return to normal operation at the beginning of the next PWM period.\nNote: Writing  to  the  ECCPASE  bit  is  disabled while a shutdown condition is active.",
    "REGISTER 16-2: ECCP1DEL: ECCP1 DELAY REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PRSEN, 1 = PDC6. PRSEN, 2 = PDC5. PRSEN, 3 = PDC4. PRSEN, 4 = PDC3. PRSEN, 5 = PDC2. PRSEN, 6 = PDC1. PRSEN, 7 = PDC0\nbit 7\nbit 0",
    "bit 7 PRSEN: PWM Restart Enable bit\n1 = Upon auto-shutdown, the ECCPASE bit clears automatically once the shutdown event goes away; the PWM restarts automatically\n0 = Upon auto-shutdown, ECCPASE must be cleared in software to restart the PWM\nPDC<6:0>: PWM Delay Count bits\nNumber of FOSC/4 (4 * TOSC) cycles between the scheduled time when a PWM signal should transition active and the actual time it transitions active.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "ECCP1AS: ENHANCED CAPTURE/COMPARE/PWM AUTO-SHUTDOWN CONTROL REGISTER\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nECCPASE\nECCPAS2\nECCPAS1\nECCPAS0\nPSSAC1\nPSSAC0\nPSSBD1\nPSSBD0\nbit 7\nbit 0\nbit 7\nECCPASE: ECCP Auto-Shutdown Event Status bit\n0 = ECCP outputs are operating\n1 = A shutdown event has occurred; ECCP outputs are in shutdown state",
    "bit 6-4 ECCPAS<2:0>: ECCP Auto-Shutdown Source Select bits\n000 = Auto-shutdown is disabled\n001 = Comparator 1 output\n010 = Comparator 2 output\n011 = Either Comparator 1 or 2\n100 = RB0\n101 = RB0 or Comparator 1\n110 = RB0 or Comparator 2\n111 = RB0 or Comparator 1 or Comparator 2\nbit 3-2 PSSACn: Pins A and C Shutdown State Control bits\n00 = Drive pins A and C to ' 0 '\n01 = Drive pins A and C to ' 1 '\n1x = Pins A and C tri-state",
    "bit 1-0 PSSBDn: Pins B and D Shutdown State Control bits\n00 = Drive pins B and D to ' 0 '\n01 = Drive pins B and D to ' 1 '\n1x = Pins B and D tri-state",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "16.2.8 START-UP CONSIDERATIONS\nThe auto-shutdown feature can be configured to allow automatic restarts of the module following a shutdown event. This is enabled by setting the PRSEN bit of the ECCP1DEL register (ECCP1DEL<7>).\nIn Shutdown mode with PRSEN = 1 (Figure 16-11), the ECCPASE bit will remain set for as long as the cause of the shutdown continues. When the shutdown condition clears, the ECCPASE bit is cleared. If PRSEN = 0 (Figure 16-12), once a shutdown condition occurs, the ECCPASE bit will remain set until it is cleared by firmware. Once ECCPASE is cleared, the enhanced PWM will resume at the beginning of the next PWM period.\nNote:, 1 = Writing to the ECCPASE bit is disabled while a shutdown condition is active.\nIndependent  of  the  PRSEN  bit  setting,  if  the  autoshutdown source is one of the comparators, the shutdown condition is a level. The ECCPASE bit cannot be cleared as long as the cause of the shutdown persists.",
    "16.2.8 START-UP CONSIDERATIONS\nWhen the ECCP module is used in the PWM mode, the application hardware must use the proper external pullup and/or pull-down resistors on the PWM output pins. When the microcontroller is released from Reset, all of the I/O pins are in the high-impedance state. The external circuits must keep the power switch devices in the off state until the microcontroller drives the I/O pins with the proper signal levels or activates the PWM output(s).\nThe  CCP1M1:CCP1M0  bits  (CCP1CON<1:0>)  allow the user to choose whether the PWM output signals are active-high or active-low for each pair of PWM output pins (P1A/P1C  and  P1B/P1D).  The  PWM  output polarities must be selected before the PWM pins are configured as outputs. Changing the polarity configuration while the PWM pins are configured as outputs is not recommended since it may result in damage to the application circuits.",
    "16.2.8 START-UP CONSIDERATIONS\nThe Auto-Shutdown mode can be forced by writing a ' 1 ' to the ECCPASE bit.\nThe P1A, P1B, P1C and P1D output latches may not be in the proper states when the PWM module is initialized. Enabling the PWM pins for output at the same time as the ECCP module may cause damage to the application circuit. The ECCP module must be enabled in the proper  Output  mode  and  complete  a  full  PWM  cycle before configuring the PWM pins as outputs. The completion of a full PWM cycle is indicated by the TMR2IF bit being set as the second PWM period begins.\nFIGURE 16-11: PWM AUTO-SHUTDOWN (PRSEN =  , AUTO-RESTART ENABLED) 1\nFIGURE 16-12: PWM AUTO-SHUTDOWN (PRSEN =  , AUTO-RESTART DISABLED) 0",
    "16.2.9 SETUP FOR PWM OPERATION\nThe following steps should be taken when configuring the ECCP1 module for PWM operation:",
    "16.2.9 SETUP FOR PWM OPERATION\n1. Configure  the  PWM  pins,  P1A  and  P1B  (and P1C and P1D, if used), as inputs by setting the corresponding TRISB bits.\n2. Set the PWM period by loading the PR2 register.\n3. Configure  the  ECCP1  module  for  the  desired PWM  mode  and  configuration  by  loading  the CCP1CON register with the appropriate values:\n\u00b7 Select one of the available output configurations and direction with the P1M1:P1M0 bits.\n\u00b7 Select the polarities of the PWM output signals with the CCP1M3:CCP1M0 bits.\n4. Set the PWM duty cycle by loading the CCPR1L register and CCP1CON<5:4> bits.\n5. For  Half-Bridge  Output  mode,  set  the  deadband  delay  by  loading  ECCP1DEL<6:0>  with the appropriate value.\n6. If auto-shutdown operation is required, load the ECCPAS register:\n\u00b7 Select the auto-shutdown sources using the ECCPAS<2:0> bits.",
    "16.2.9 SETUP FOR PWM OPERATION\n\u00b7 Select the shutdown states of the PWM output pins using PSSAC1:PSSAC0 and PSSBD1:PSSBD0 bits.\n\u00b7 Set the ECCPASE bit (ECCPAS<7>).\n\u00b7 Configure the comparators using the CMCON register.\n\u00b7 Configure the comparator inputs as analog inputs.",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000.",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nPIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1,",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nBit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on all other Resets = 1111. TRISC, Value on all other Resets = 1111. TRISE, Bit 7 = PORTE Data Direction Register. TRISE, Bit 6",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= PORTE Data Direction Register. TRISE, Bit 5 = PORTE Data Direction Register. TRISE, Bit 4 = PORTE Data Direction Register. TRISE, Bit 3 = PORTE Data Direction Register. TRISE, Bit 2 = PORTE Data Direction Register. TRISE, Bit 1 = PORTE Data Direction Register. TRISE, Bit 0 = PORTE Data Direction Register. TRISE, Value on POR, BOR = 1111. TRISE, Value on POR, BOR = 1111. TRISE, Value on all other Resets = 1111. TRISE, Value on all other Resets = 1111. TRISG, Bit 7 = -. TRISG, Bit 6 = -. TRISG, Bit 5 = -. TRISG, Bit 4 = PORTG Data Direction Register. TRISG, Bit 3 = PORTG Data Direction Register. TRISG, Bit 2 = PORTG Data Direction Register. TRISG, Bit 1 = PORTG Data Direction Register. TRISG, Bit 0 = PORTG Data Direction Register. TRISG, Value on POR, BOR = ---1. TRISG, Value on POR, BOR = 1111. TRISG, Value on all",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nother Resets = ---1. TRISG, Value on all other Resets = 1111. TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR, BOR = 0000. TMR2, Value on all other Resets = 0000. TMR2, Value on all other Resets = 0000. PR2, Bit 7 = Timer2 Module Period Register. PR2, Bit 6 = Timer2 Module Period Register. PR2, Bit 5 = Timer2 Module Period Register. PR2, Bit 4 = Timer2 Module Period Register. PR2, Bit 3 = Timer2",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nModule Period Register. PR2, Bit 2 = Timer2 Module Period Register. PR2, Bit 1 = Timer2 Module Period Register. PR2, Bit 0 = Timer2 Module Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR, BOR = 1111. PR2, Value on all other Resets = 1111. PR2, Value on all other Resets = 1111. T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. T2CON, Value on all other Resets = -000. T2CON, Value on all other Resets =",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n0000. CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on all other Resets = uuuu. CCPR1L, Value on all other Resets =",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nuuuu. CCPR1H, Bit 7 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on all other Resets = uuuu. CCPR1H, Value on all other Resets =",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nuuuu. CCP1CON, Bit 7 = P1M1. CCP1CON, Bit 6 = P1M0. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on POR, BOR = 0000. CCP1CON, Value on all other Resets = 0000. CCP1CON, Value on all other Resets = 0000. ECCP1AS, Bit 7 = ECCPASE. ECCP1AS, Bit 6 = ECCPAS2. ECCP1AS, Bit 5 = ECCPAS1. ECCP1AS, Bit 4 = ECCPAS0. ECCP1AS, Bit 3 = PSSAC1. ECCP1AS,",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nBit 2 = PSSAC0. ECCP1AS, Bit 1 = PSSBD1. ECCP1AS, Bit 0 = PSSBD0. ECCP1AS, Value on POR, BOR = 0000. ECCP1AS, Value on POR, BOR = 0000. ECCP1AS, Value on all other Resets = 0000. ECCP1AS, Value on all other Resets = 0000. ECCP1DEL, Bit 7 = PRSEN. ECCP1DEL, Bit 6 = PDC6. ECCP1DEL, Bit 5 = PDC5. ECCP1DEL, Bit 4 = PDC4. ECCP1DEL, Bit 3 = PDC3. ECCP1DEL, Bit 2 = PDC2. ECCP1DEL, Bit 1 = PDC1. ECCP1DEL, Bit 0 = PDC0. ECCP1DEL, Value on POR, BOR = 0000. ECCP1DEL, Value on POR, BOR = 0000. ECCP1DEL, Value on all other Resets = uuuu. ECCP1DEL, Value",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH PWM AND TIMER2\non all other Resets = uuuu\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by PWM and Timer2.",
    "TABLE 16-3: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n7. If auto-restart  operation  is  required,  set  the PRSEN bit (ECCP1DEL<7>).\n8. Configure and start TMR2:\n\u00b7 Clear the TMR2 interrupt flag bit by clearing the TMR2IF bit (PIR1<1>).\n\u00b7 Set the TMR2 prescale value by loading the T2CKPS bits (T2CON<1:0>).\n\u00b7 Enable Timer2 by setting the TMR2ON bit (T2CON<2>).\n9. Enable  PWM outputs after  a  new  PWM  cycle has started:\n\u00b7 Wait until TMR2 overflows (TMR2IF bit is set).\n\u00b7 Enable the CCP1/P1A, P1B, P1C and/or P1D pin outputs by clearing the respective TRISB bits.\n\u00b7 Clear the ECCPASE bit (ECCP1AS<7>).",
    "16.2.10 EFFECTS OF A RESET\nBoth  Power-on  and  subsequent  Resets  will  force  all ports  to  Input  mode  and  the  CCP  registers  to  their Reset states.\nThis  forces the  Enhanced CCP module to reset to a state compatible with the standard CCP module.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "17.1 Master SSP (MSSP) Module Overview\nThe Master Synchronous Serial Port (MSSP) module is a serial interface, useful for communicating with other peripheral or microcontroller devices. These peripheral devices may be serial EEPROMs, shift registers, display drivers, A/D converters, etc. The MSSP module can operate in one of two modes:\n\u00b7 Serial Peripheral Interface (SPI)\n\u00b7 Inter-Integrated Circuit (I 2 C)\n-Full Master mode\n-Slave mode (with general address call)\nThe  I 2 C  interface  supports  the  following  modes  in hardware:\n\u00b7 Master mode\n\u00b7 Multi-Master mode\n\u00b7 Slave mode",
    "17.2 Control Registers\nThe  MSSP  module  has  three  associated  registers. These  include  a  status  register  (SSPSTAT)  and  two control registers (SSPCON1 and SSPCON2). The use of these registers and their individual configuration bits differ  significantly  depending  on  whether  the  MSSP module is operated in SPI or I 2 C mode.\nAdditional  details  are  provided  under  the  individual sections.",
    "17.3 SPI Mode\nThe SPI mode allows 8 bits of data to be synchronously transmitted and received simultaneously. All four modes of SPI are supported. To accomplish communication, typically three pins are used:\n\u00b7 Serial Data Out (SDO) - RC5/SDO\n\u00b7 Serial Data In (SDI) - RC4/SDI/SDA\n\u00b7 Serial Clock (SCK) - RC3/SCK/SCL\nAdditionally, a fourth pin may be used when in a Slave mode of operation:\n- \u00b7 Slave Select (SS) - RF7/SS\nFigure 17-1  shows  the  block  diagram  of  the  MSSP module when operating in SPI mode.",
    "17.3.1 REGISTERS\nThe  MSSP  module  has  four  registers  for  SPI  mode operation. These are:\nSSPSR is the shift register used for shifting data in or out. SSPBUF is the buffer register to which data bytes are written to or read from.\n\u00b7 MSSP Control Register 1 (SSPCON1)\n\u00b7 MSSP Status Register (SSPSTAT)\n\u00b7 Serial Receive/Transmit Buffer Register (SSPBUF)\n\u00b7 MSSP Shift Register (SSPSR) - Not directly accessible\nIn receive operations, SSPSR and SSPBUF together create a double-buffered receiver. When  SSPSR receives a complete byte, it is transferred to SSPBUF and the SSPIF interrupt is set.\nDuring  transmission,  the  SSPBUF  is  not  doublebuffered. A write to SSPBUF will write to both SSPBUF and SSPSR.\nSSPCON1 and SSPSTAT are the control and status registers in SPI mode operation. The SSPCON1 register  is  readable  and  writable.  The  lower  6  bits  of  the SSPSTAT  are  read-only.  The  upper  two  bits  of  the SSPSTAT are read/write.",
    "REGISTER 17-1: SSPSTAT: MSSP STATUS REGISTER (SPI MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P. SMP, 4 = S. SMP, 5 = R/W. SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "SPI Master mode:\n1 = Input data sampled at end of data output time\n0 = Input data sampled at middle of data output time",
    "SPI Slave mode:\nSMP must be cleared when SPI is used in Slave mode.",
    "When CKP = 0 :\n1 = Data transmitted on rising edge of SCK\n0 = Data transmitted on falling edge of SCK",
    "When CKP = 1 :\n1 = Data transmitted on falling edge of SCK\n0 = Data transmitted on rising edge of SCK",
    "bit 5 D/A: Data/Address bit\nUsed in I 2 C mode only.",
    "bit 4 P: Stop bit\nUsed in I 2 C mode only. This bit is cleared when the MSSP module is disabled, SSPEN is cleared.",
    "bit 3 S: Start bit\nUsed in I 2 C mode only.",
    "bit 2 R/W: Read/Write bit Information\nUsed in I 2 C mode only.",
    "bit 1 UA: Update Address bit\nUsed in I 2 C mode only.",
    "bit 0\nBF: Buffer Full Status bit (Receive mode only)\n1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "SSPCON1: MSSP CONTROL REGISTER 1 (SPI MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. WCOL, 1 = SSPOV. WCOL, 2 = SSPEN. WCOL, 3 = CKP. WCOL, 4 = SSPM3. WCOL, 5 = SSPM2. WCOL, 6 = SSPM1. WCOL, 7 = SSPM0\nbit 7\nbit 0",
    "bit 7 WCOL: Write Collision Detect bit (Transmit mode only)\n1 = The SSPBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision",
    "SPI Slave mode:\n1 = A new byte is received while the SSPBUF register is still holding the previous data. In case of overflow, the data in SSPSR is lost. Overflow can only occur in Slave mode.The user must read the SSPBUF, even if only transmitting data, to avoid setting overflow (must be cleared in software).\n0 = No overflow\nNote:\nIn  Master  mode,  the  overflow  bit  is  not  set  since  each  new  reception  (and transmission) is initiated by writing to the SSPBUF register.",
    "bit 5 SSPEN: Synchronous Serial Port Enable bit\n- 1 = Enables serial port and configures SCK, SDO, SDI, and SS as  serial port pins\n0 = Disables serial port and configures these pins as I/O port pins\nNote: When enabled, these pins must be properly configured as input or output.",
    "bit 4 CKP: Clock Polarity Select bit\n1 = Idle state for clock is a high level\n0 = Idle state for clock is a low level",
    "bit 3-0 SSPM3:SSPM0: Synchronous Serial Port Mode Select bits\n0101 = SPI Slave mode, clock = SCK pin, SS pin control disabled, SS can be used as I/O pin 0100 = SPI Slave mode, clock = SCK pin, SS pin control enabled\n0011 = SPI Master mode, clock = TMR2 output/2\n0010 = SPI Master mode, clock = FOSC/64\n0001 = SPI Master mode, clock = FOSC/16\n0000 = SPI Master mode, clock = FOSC/4\nNote: Bit combinations not specifically listed here are either reserved or implemented in\nI 2 C mode only.",
    "bit 3-0 SSPM3:SSPM0: Synchronous Serial Port Mode Select bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "17.3.2 OPERATION\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control  bits  (SSPCON1<5:0>  and  SSPSTAT<7:6>). These control bits allow the following to be specified:\n- \u00b7 Master mode (SCK is the clock output)\nreading the data that was just received. Any write to the SSPBUF register during transmission/reception of data will be ignored and the Write Collision detect bit, WCOL (SSPCON1<7>), will be set. User software must clear the WCOL bit so that it can be determined if the following write(s) to the SSPBUF  register completed successfully.\n\u00b7 Slave mode (SCK is the clock input)\n\u00b7 Clock Polarity (Idle state of SCK)\n\u00b7 Data Input Sample Phase (middle or end of data output time)\n\u00b7 Clock Edge (output data on rising/falling edge of SCK)\n\u00b7 Clock Rate (Master mode only)\n\u00b7 Slave Select mode (Slave mode only)",
    "17.3.2 OPERATION\nThe MSSP consists of a Transmit/Receive Shift register  (SSPSR)  and  a  Buffer  register  (SSPBUF).  The SSPSR shifts the data in and out of the device, MSb first. The SSPBUF holds the data that was written to the SSPSR, until the received data is ready. Once the 8 bits of data have been received, that byte is moved to the SSPBUF register. Then the Buffer Full detect bit, BF (SSPSTAT<0>) and the interrupt flag  bit,  SSPIF,  are set. This double-buffering of the received data (SSPBUF) allows the next byte to start reception before",
    "17.3.2 OPERATION\nWhen the application software is expecting to receive valid data, the SSPBUF should be read before the next byte of data to transfer is written to the SSPBUF. Buffer Full  bit,  BF (SSPSTAT<0>), indicates when SSPBUF has been loaded with the received data (transmission is complete). When the SSPBUF is read, the BF bit is cleared. This data may be irrelevant if the SPI is only a transmitter.  Generally,  the  MSSP  interrupt  is  used  to determine when the transmission/reception has completed. The SSPBUF must be read and/or written. If the interrupt method is not going to be used, then software polling can be done to ensure that a write collision does not  occur.  Example 17-1  shows  the  loading  of  the SSPBUF (SSPSR) for data transmission.\nThe SSPSR is not directly readable or writable and can only be accessed by addressing the SSPBUF register. Additionally,  the  MSSP  Status  register  (SSPSTAT) indicates the various status conditions.",
    "EXAMPLE 17-1: LOADING THE SSPBUF (SSPSR) REGISTER\nLOOP, 1 = BTFSS. LOOP, 2 = SSPSTAT, BF. LOOP, 3 = ;Has data been received(transmit complete)?. , 1 = BRA. , 2 = LOOP. , 3 = ;No. , 1 = MOVF. , 2 = SSPBUF, W. , 3 = ;WREG reg = contents of SSPBUF. , 1 = MOVWF. , 2 = RXDATA. , 3 = ;Save in user RAM, if data is meaningful. , 1 = MOVF. , 2 = TXDATA, W. , 3 = ;W reg = contents of TXDATA. , 1 = MOVWF. , 2 = SSPBUF. , 3 = ;New data to xmit",
    "17.3.3 ENABLING SPI I/O\nTo  enable  the  serial  port,  SSP  Enable  bit,  SSPEN (SSPCON1<5>), must be set. To reset or reconfigure SPI mode, clear the SSPEN  bit, reinitialize the SSPCON registers and then set the SSPEN bit. This configures the SDI, SDO, SCK and SS pins as serial port pins. For the pins to behave as the serial port function,  some must have their data direction bits (in the TRIS register) appropriately programmed as follows:\n\u00b7 SDI is automatically controlled by the SPI module\n\u00b7 SDO must have TRISC<5> bit cleared\n\u00b7 SCK (Master mode) must have TRISC<3> bit cleared\n\u00b7 SCK (Slave mode) must have TRISC<3> bit set\n\u00b7 SS must have TRISF<7> bit set",
    "17.3.4 TYPICAL CONNECTION\nFigure 17-2 shows a typical connection between two microcontrollers. The  master controller (Processor  1) initiates the data transfer by sending the SCK signal. Data is shifted out of both shift registers on their programmed clock edge and latched on the opposite edge of the clock. Both processors should be programmed to the same Clock Polarity (CKP), then both controllers would  send  and  receive  data  at  the  same  time. Whether  the  data  is  meaningful  (or  dummy  data) depends  on  the  application  software.  This  leads  to three scenarios for data transmission:\n\u00b7 Master sends data - Slave sends dummy data \uf020 \uf020\n\u00b7 Master sends data - Slave sends data \uf020 \uf020\n\u00b7 Master sends dummy data - Slave sends data \uf020 \uf020\nAny  serial  port  function  that  is  not  desired  may  be overridden  by  programming  the  corresponding  data direction (TRIS) register to the opposite value.",
    "17.3.5 MASTER MODE\nThe master can initiate the data transfer  at any time because it controls the SCK. The master determines when  the slave (Processor 2, Figure 17-2) is to broadcast data by the software protocol.\nIn  Master  mode,  the  data  is  transmitted/received  as soon as the SSPBUF register is written to. If the SPI is only  going  to  receive,  the  SDO  output  could  be  disabled (programmed as an input). The SSPSR register will continue to shift in the signal present on the SDI pin at the programmed  clock  rate. As  each  byte  is received, it will be loaded into the SSPBUF register as if  a  normal  received  byte  (interrupts  and  status  bits appropriately  set).  This  could  be  useful  in  receiver applications as a 'Line Activity Monitor' mode.\nFigure 17-3,  Figure 17-5  and  Figure 17-6,  where  the MSB is transmitted first. In Master mode, the SPI clock rate (bit rate) is user programmable to be one of the following:",
    "17.3.5 MASTER MODE\n\u00b7 FOSC/4 (or TCY)\n\u00b7 FOSC/16 (or 4 \u00b7 TCY)\n\u00b7 FOSC/64 (or 16 \u00b7 TCY)\n\u00b7 Timer2 output/2\nThis  allows  a  maximum  data  rate  (at  40  MHz)  of 10.00 Mbps.\nThe clock polarity is selected by appropriately programming  the  CKP  bit  (SSPCON1<4>).  This  then,  would give waveforms for SPI communication, as shown in\nFigure 17-3  shows  the  waveforms  for  Master  mode. When the CKE bit is set, the SDO data is valid before there is a clock edge on SCK. The change of the input sample is shown based on the state of the SMP bit. The time  when  the  SSPBUF  is  loaded  with  the  received data is shown.\nFIGURE 17-3: SPI MODE WAVEFORM (MASTER MODE)",
    "17.3.6 SLAVE MODE\nIn Slave mode, the data is transmitted and received as the external  clock pulses  appear  on  SCK.  When  the last bit is latched, the SSPIF interrupt flag bit is set.\nWhile in Slave mode, the external clock is supplied by the external clock source on the SCK pin. This external clock must meet the minimum high and low times as specified in the electrical specifications.\nWhile in  Sleep  mode,  the  slave  can  transmit/receive data. When a byte is received, the device will wake-up from Sleep.",
    "17.3.7 SLAVE SELECT SYNCHRONIZATION\nthe SS pin goes high, the SDO pin is no longer driven even if in the middle of a transmitted byte and becomes a  floating  output.  External  pull-up/pull-down  resistors may be desirable depending on the application.\nNote 1: When the SPI is in Slave mode with SS pin control enabled (SSPCON<3:0> = 0100 ), the SPI module will reset if the SS pin is set to VDD.\n2: If the SPI is used in Slave mode with CKE set,  then  the  SS  pin  control  must  be enabled.\nWhen the SPI module resets, the bit counter is forced to ' 0 '. This can be done by either forcing the SS pin to a high level or clearing the SSPEN bit.\nThe SS pin allows a Synchronous Slave mode. The SPI must  be  in  Slave  mode  with  SS  pin  control  enabled (SSPCON1<3:0> = 04h). The pin must not be driven low for the SS pin to function as an input. The data latch must be high. When the SS pin is low, transmission and reception are enabled and the SDO pin is driven. When",
    "17.3.7 SLAVE SELECT SYNCHRONIZATION\nTo emulate two-wire communication, the SDO pin can be connected to the SDI pin. When the SPI needs to operate as a receiver, the SDO pin can be configured as an input. This disables transmissions from the SDO. The SDI can always be left as an input (SDI function) since it cannot create a bus conflict.\nFIGURE 17-4: SLAVE SYNCHRONIZATION WAVEFORM",
    "PIC18F6585/8585/6680/8680\nFIGURE 17-6: SPI MODE WAVEFORM (SLAVE MODE WITH CKE = 1\n)",
    "17.3.8 SLEEP OPERATION\nIn Master mode, all module clocks are halted and the transmission/reception will remain in that state until the device wakes from Sleep. After the device returns to normal mode, the module will continue to transmit/receive data.\nIn Slave mode, the SPI Transmit/Receive Shift register operates asynchronously to the device. This allows the device  to  be  placed  in  Sleep  mode  and  data  to  be shifted  into  the  SPI  Transmit/Receive  Shift  register. When all 8 bits have been received, the MSSP interrupt flag bit will be set and if enabled, will wake the device from Sleep.",
    "17.3.10 BUS MODE COMPATIBILITY\nTable 17-1 shows the compatibility between the standard SPI  modes and the states  of the CKP and CKE control bits.",
    "TABLE 17-1: SPI BUS MODES\n0, 0, Control Bits State.CKP = 0. 0, 0, Control Bits State.CKE = 1. 0, 1, Control Bits State.CKP = 0. 0, 1, Control Bits State.CKE = 0. 1, 0, Control Bits State.CKP = 1. 1, 0, Control Bits State.CKE = 1. 1, 1, Control Bits State.CKP = 1. 1, 1, Control Bits State.CKE = 0\nA Reset disables the MSSP module and terminates the current transfer.\nThere is also a SMP bit which controls when the data is sampled.",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 0000. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 0000. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000 0000. PIR1, Value on all other Resets =",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI OPERATION\n0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111 1111.",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nIPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111 1111. TRISC, Value on all other Resets = 1111. TRISC, Value on all other Resets = 1111. TRISF, Bit 7 = TRISF7. TRISF, Bit 6 = TRISF6. TRISF, Bit 5 = TRISF5. TRISF, Bit 4 = TRISF4. TRISF, Bit 3 = TRISF3. TRISF, Bit 2 = TRISF2. TRISF, Bit 1 = TRISF1. TRISF, Bit 0 = TRISF0.",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI OPERATION\nTRISF, Value on POR, BOR = 1111 1111. TRISF, Value on all other Resets = uuuu. TRISF, Value on all other Resets = uuuu. SSPBUF, Bit 7 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 6 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 5 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 4 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 3 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 2 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 1 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 0 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Value on POR, BOR = xxxx xxxx. SSPBUF, Value on all other Resets = uuuu. SSPBUF, Value",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI OPERATION\non all other Resets = uuuu. SSPCON, Bit 7 = WCOL. SSPCON, Bit 6 = SSPOV. SSPCON, Bit 5 = SSPEN. SSPCON, Bit 4 = CKP. SSPCON, Bit 3 = SSPM3. SSPCON, Bit 2 = SSPM2. SSPCON, Bit 1 = SSPM1. SSPCON, Bit 0 = SSPM0. SSPCON, Value on POR, BOR = 0000 0000. SSPCON, Value on all other Resets = 0000. SSPCON, Value on all other Resets = 0000. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Value on POR, BOR = 0000 0000. SSPSTAT, Value on all other Resets =",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI OPERATION\n0000. SSPSTAT, Value on all other Resets = 0000\nLegend: x = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by the MSSP in SPI mode.",
    "17.4.1 REGISTERS\nThe MSSP module in  I 2 C  mode  fully  implements  all master and slave functions (including general call support) and provides interrupts on Start and Stop bits in hardware to determine a free bus (multi-master function).  The  MSSP  module  implements  the  standard mode  specifications, as well as 7-bit and 10-bit addressing.\nTwo pins are used for data transfer:\n\u00b7 Serial clock (SCL) - RC3/SCK/SCL\n\u00b7 Serial data (SDA) - RC4/SDI/SDA\nThe user must configure these pins as inputs or outputs through the TRISC<4:3> bits.",
    "FIGURE 17-7: MSSP BLOCK DIAGRAM (I 2 C MODE)\nThe MSSP module has six registers for I 2 C operation. These are:\n\u00b7 MSSP Control Register 1 (SSPCON1)\n\u00b7 MSSP Control Register 2 (SSPCON2)\n\u00b7 MSSP Status Register (SSPSTAT)\n\u00b7 Serial Receive/Transmit Buffer (SSPBUF)\n\u00b7 MSSP Shift Register (SSPSR) - Not directly accessible\n\u00b7 MSSP Address Register (SSPADD)\nSSPCON, SSPCON2  and  SSPSTAT  are  the  control and  status  registers in I 2 C  mode  operation.  The SSPCON and SSPCON2 registers are readable and writable. The lower six bits of the SSPSTAT are readonly. The upper two bits of the SSPSTAT  are read/write.\nSSPSR is the shift register used for shifting data in or out. SSPBUF is the buffer register to which data bytes are written to or read from.\nSSPADD register holds the slave device address when the SSP is configured in I 2 C  Slave  mode. When the SSP is configured in Master mode, the lower seven bits of  SSPADD  act  as  the  Baud  Rate  Generator  reload value.",
    "FIGURE 17-7: MSSP BLOCK DIAGRAM (I 2 C MODE)\nIn receive operations, SSPSR and SSPBUF together create a double-buffered receiver. When  SSPSR receives a complete byte, it is transferred to SSPBUF and the SSPIF interrupt is set.\nDuring  transmission,  the  SSPBUF  is  not  doublebuffered. A write to SSPBUF will write to both SSPBUF and SSPSR.",
    "REGISTER 17-3: SSPSTAT: MSSP STATUS REGISTER (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P. SMP, 4 = S. SMP, 5 = R/W. SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "bit 7 SMP:\nSlew Rate Control bit",
    "In Master or Slave mode:\n1 = Slew rate control disabled for Standard Speed mode (100 kHz and 1 MHz)\n0 = Slew rate control enabled for High-Speed mode (400 kHz)\n1 = Enable SMBus specific inputs\n0 = Disable SMBus specific inputs\nD/A: Data/Address bit\nIn Master mode:\nReserved.",
    "In Slave mode:\n1 = Indicates that the last byte received or transmitted was data\n0 = Indicates that the last byte received or transmitted was address",
    "bit 4 P: Stop bit\n1 = Indicates that a Stop bit has been detected last\n0 = Stop bit was not detected last\nNote: This bit is cleared on Reset and when SSPEN is cleared.",
    "bit 3 S: Start bit\n1 = Indicates that a Start bit has been detected last\n0 = Start bit was not detected last\nNote:\nThis bit is cleared on Reset and when SSPEN is cleared.",
    "In Slave mode:\n1 = Read\n0 = Write\nNote:\nThis bit holds the R/W bit information following the last address match. This bit is only valid from the address match to the next Start bit, Stop bit or not ACK bit.",
    "In Master mode:\n1 = Transmit is in progress\n0 = Transmit is not in progress\nNote:\nORing this bit with SEN, RSEN, PEN, RCEN or ACKEN will indicate if the MSSP is in Idle mode.",
    "bit 1 UA: Update Address bit (10-bit Slave mode only)\n1 = Indicates that the user needs to update the address in the SSPADD register\n0 = Address does not need to be updated",
    "In Transmit mode:\n1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty",
    "In Receive mode:\n1 = Data transmit in progress (does not include the ACK and Stop bits), SSPBUF is full\n0 = Data transmit complete (does not include the ACK and Stop bits), SSPBUF is empty",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "SSPCON1: MSSP CONTROL REGISTER 1 (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. WCOL, 1 = SSPOV. WCOL, 2 = SSPEN. WCOL, 3 = CKP. WCOL, 4 = SSPM3. WCOL, 5 = SSPM2. WCOL, 6 = SSPM1. WCOL, 7 = SSPM0\nbit 7\nbit 0",
    "In Master Transmit mode:\n1 = A write to the SSPBUF register was attempted while the I 2 C conditions were not valid for a transmission to be started (must be cleared in software)\n0 = No collision",
    "In Slave Transmit mode:\n1 = The SSPBUF register is written while it is still transmitting  the previous  word (must  be cleared in software)\n0 = No collision\nIn Receive mode (Master or Slave modes):\nThis is a 'don't care' bit.",
    "In Receive mode:\n1 = A byte is received while the SSPBUF register is still holding the previous byte (must be cleared in software)\n0 = No overflow",
    "In Transmit mode:\nThis is a 'don't care' bit in Transmit mode.",
    "bit 5 SSPEN:\nSynchronous Serial Port Enable bit\n1 = Enables the serial port and configures the SDA and SCL pins as the serial port pins\n0 = Disables serial port and configures these pins as I/O port pins\nNote:\nWhen enabled, the SDA and SCL pins must be properly configured as input or output.",
    "In Slave mode:\n1 = Release clock\n0 = Holds clock low (clock stretch), used to ensure data setup time",
    "In Master mode:\nUnused in this mode.",
    "bit 3-0 SSPM3:SSPM0: Synchronous Serial Port Mode Select bits\n1111 = I 2 C Slave mode, 10-bit address with Start and Stop bit interrupts enabled\n1011 = I 2 C Firmware Controlled Master mode (slave Idle)\n1110 = I 2 C Slave mode, 7-bit address with Start and Stop bit interrupts enabled\n1000 = I 2 C Master mode, clock = FOSC/(4 * (SSPADD + 1))\n0110 = I 2 C Slave mode, 7-bit address\n0111 = I 2 C Slave mode, 10-bit address\nNote:\nBit combinations not specifically listed here are either reserved or implemented in SPI mode only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 2",
    "REGISTER 17-5: SSPCON2: MSSP CONTROL REGISTER 2 (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. GCEN, 1 = ACKSTAT. GCEN, 2 = ACKDT. GCEN, 3 = ACKEN. GCEN, 4 = RCEN. GCEN, 5 = PEN. GCEN, 6 = RSEN. GCEN, 7 = SEN\nbit 7\nbit 0\nbit 7 GCEN: General Call Enable bit (Slave mode only)\n1 = Enable interrupt when a general call address (0000h) is received in the SSPSR\n0 = General call address disabled",
    "bit 6 ACKSTAT: Acknowledge Status bit (Master Transmit mode only)\n1 = Acknowledge was not received from slave\n0 = Acknowledge was received from slave\nbit 5 ACKDT: Acknowledge Data bit (Master Receive mode only)\n1 = Not Acknowledge\n0 = Acknowledge\nNote:\nValue that will be transmitted when the user initiates an Acknowledge sequence at the end of a receive.",
    "bit 4 ACKEN: Acknowledge Sequence Enable bit (Master Receive mode only)\n1 = Initiate  Acknowledge  sequence  on  SDA  and  SCL  pins  and  transmit  ACKDT  data  bit. Automatically cleared by hardware.\n0 = Acknowledge sequence Idle",
    "bit 3 RCEN: Receive Enable bit (Master Mode only)\n1 = Enables Receive mode for I 2 C\n0 = Receive Idle\nPEN: Stop Condition Enable bit (Master mode only)\n1 = Initiate Stop condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Stop condition Idle\nbit 1 RSEN: Repeated Start Condition Enabled bit (Master mode only)\n1 = Initiate Repeated Start condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Repeated Start condition Idle\nbit 0 SEN: Start Condition Enabled/Stretch Enabled bit",
    "In Master mode:\n1 = Initiate Start condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Start condition Idle",
    "In Slave mode:\n1 = Clock stretching is enabled for both slave transmit and slave receive (stretch enabled)\n0 = Clock stretching is disabled",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared x = Bit is unknown\nNote:, 1 = For bits ACKEN, RCEN, PEN, RSEN, SEN: If the I 2 Cmodule is not in the Idle mode, this bit may not be set (no spooling) and the SSPBUF may not be written (or writes to the SSPBUF are disabled).",
    "17.4.3.1 Addressing\nThe  MSSP  module  functions  are  enabled  by  setting MSSP Enable bit, SSPEN (SSPCON<5>).\nThe SSPCON1 register allows control of the I 2 C operation. Four mode selection bits (SSPCON<3:0>) allow one of the following I 2 C modes to be selected:\n\u00b7 I 2 C Master mode, clock = OSC/4 (SSPADD + 1)\n\u00b7 I 2 C Slave mode (7-bit address)\n\u00b7 I 2 C Slave mode (10-bit address)\n\u00b7 I 2 C Slave mode (7-bit address) with Start and Stop bit interrupts enabled\n\u00b7 I 2 C Slave mode (10-bit address) with Start and Stop bit interrupts enabled\n\u00b7 I 2 C Firmware Controlled Master mode, slave is Idle\nSelection  of  any  I 2 C  mode  with  the  SSPEN  bit  set, forces the SCL and SDA pins to be open-drain, provided these pins are programmed to inputs by setting the appropriate TRISC bits. To ensure proper operation of  the  module,  pull-up  resistors  must  be  provided externally to the SCL and SDA pins.",
    "17.4.3 SLAVE MODE\nIn Slave mode, the SCL and SDA pins must be configured as inputs (TRISC<4:3> set). The MSSP module will override the input state with the output data when required (slave-transmitter).\nThe I 2 C Slave mode hardware will always generate an interrupt  on  an  address  match.  Through  the  mode select  bits,  the  user  can  also  choose  to  interrupt  on Start and Stop bits\nWhen an address is matched or the data transfer after an address match is received, the hardware automatically will generate the Acknowledge (ACK) pulse and load  the  SSPBUF  register  with  the  received  value currently in the SSPSR register.\nAny combination of the following conditions will cause the MSSP module not to give this ACK pulse:\n\u00b7 The buffer full bit BF (SSPSTAT<0>) was set before the transfer was received.\n\u00b7 The overflow bit SSPOV (SSPCON<6>) was set before the transfer was received.",
    "17.4.3 SLAVE MODE\nIn this  case,  the SSPSR register value is not loaded into the SSPBUF but bit SSPIF (PIR1<3>) is set. The BF bit is cleared by reading the SSPBUF register while bit SSPOV is cleared through software.\nThe SCL clock input must have a minimum high and low for proper operation. The high and low times of the I 2 C  specification,  as  well  as  the  requirement  of  the MSSP module, are shown in  timing  parameter  #100 and parameter #101.\nOnce the MSSP module has been enabled, it waits for a Start condition to occur. Following the Start condition, the 8 bits are shifted into the SSPSR register. All incoming bits are sampled with the rising edge of the clock (SCL) line. The value of register SSPSR<7:1> is compared  to  the  value  of  the  SSPADD  register.  The address is compared on the falling edge of the eighth clock (SCL) pulse. If the addresses match and the BF and SSPOV bits are clear, the following events occur:",
    "17.4.3 SLAVE MODE\n1. The  SSPSR  register  value  is  loaded  into  the SSPBUF register.\n2. The buffer full bit BF is set.\n3. An ACK pulse is generated.\n4. MSSP interrupt flag bit, SSPIF (PIR1<3>), is set (interrupt is generated, if enabled) on the falling edge of the ninth SCL pulse.\nIn 10-bit Address mode, two address bytes need to be received  by  the  slave.  The  five  Most  Significant  bits (MSbs) of the first address byte specify if this is a 10-bit address. Bit R/W (SSPSTAT<2>) must specify a write so  the  slave  device  will  receive  the  second  address byte. For a 10-bit address, the first byte would equal ' 11110  A9  A8  0 ',  where ' A9 '  and ' A8 '  are  the  two MSbs  of  the  address.  The  sequence  of  events  for 10-bit address is as follows, with steps 7 through 9 for the slave-transmitter:",
    "17.4.3 SLAVE MODE\n1. Receive first (high) byte of address (bits SSPIF, BF and bit UA (SSPSTAT<1>) are set).\n2. Update the SSPADD register with second (low) byte of address (clears bit UA and releases the SCL line).\n3. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.\n4. Receive  second  (low)  byte  of  address  (bits SSPIF, BF, and UA are set).\n5. Update the SSPADD register with the first (high) byte of address. If match releases SCL line, this will clear bit UA.\n6. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.\n7. Receive Repeated Start condition.\n8. Receive first (high) byte of address (bits SSPIF and BF are set).\n9. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.",
    "17.4.3.3 Transmission\nWhen the R/W bit of the address byte is clear and an address  match  occurs,  the  R/W  bit  of  the  SSPSTAT register is cleared. The received address is loaded into the  SSPBUF  register  and  the  SDA  line  is  held  low (ACK).\nWhen the address byte overflow condition exists, then the no Acknowledge (ACK) pulse is given. An overflow condition is defined as either bit BF (SSPSTAT<0>) is set or bit SSPOV (SSPCON1<6>) is set.\nAn MSSP interrupt is generated for each data transfer byte. Flag bit SSPIF (PIR1<3>) must be cleared in software. The SSPSTAT register is used to determine the status of the byte.\nIf SEN is enabled (SSPCON2<0> = 1 ), RC3/SCK/SCL will  be  held  low  (clock  stretch)  following  each  data transfer.  The  clock  must  be  released  by  setting  bit CKP (SSPCON<4>). See Section 17.4.4 'Clock Stretching' for more detail.",
    "17.4.3.3 Transmission\nWhen the R/W bit of the incoming address byte is set and  an  address  match  occurs,  the  R/W  bit  of  the SSPSTAT  register  is  set.  The  received  address  is loaded into the SSPBUF register. The ACK pulse will be sent on the ninth bit and pin RC3/SCK/SCL is held low,  regardless  of  SEN  (see Section 17.4.4  'Clock Stretching' for  more detail). By stretching the clock, the master will be unable to assert another clock pulse until the slave is done preparing the transmit data. The transmit data must be loaded into the SSPBUF register which also loads the SSPSR register. Then pin RC3/ SCK/SCL  should  be  enabled  by  setting  bit  CKP (SSPCON1<4>). The eight data bits are shifted out on the falling edge of the SCL input. This ensures that the SDA  signal is valid during the SCL  high time (Figure 17-9).",
    "17.4.3.3 Transmission\nThe ACK pulse from the master-receiver is latched on the rising edge of the ninth SCL input pulse. If the SDA line is high (not ACK), then the data transfer is complete.  In  this  case,  when  the  ACK  is  latched  by  the slave, the slave logic is reset (resets SSPSTAT register) and the slave monitors for another occurrence of the Start bit. If the SDA line was low (ACK), the next transmit data must be loaded into the SSPBUF register. Again, pin RC3/SCK/SCL must be enabled by setting bit CKP.\nAn MSSP interrupt is generated for each data transfer byte. The SSPIF bit must be cleared in software and the SSPSTAT register is used to determine the status of the byte. The SSPIF bit is set on the falling edge of the ninth clock pulse.",
    "PIC18F6585/8585/6680/8680\n2 C SLAVE MODE TIMING (TRANSMISSION, 10-BIT ADDRESS)",
    "17.4.4 CLOCK STRETCHING\nBoth 7- and 10-bit Slave modes implement automatic clock stretching during a transmit sequence.",
    "17.4.4.3 Clock Stretching for 7-bit Slave Transmit Mode\nThe SEN bit (SSPCON2<0>) allows clock stretching to be enabled during receives. Setting SEN will cause the SCL pin to be held low at the end of each data receive sequence.",
    "17.4.4.1 Clock Stretching for 7-bit Slave Receive Mode (SEN = 1 )\nIn 7-bit Slave Receive mode, on the falling edge of the ninth clock at the end of the ACK sequence if the BF bit is set, the CKP bit in the SSPCON1 register is automatically cleared, forcing the SCL output to be held low. The CKP being cleared to ' 0 '  will assert the SCL line low. The CKP bit must be set in the user's ISR before reception is allowed to continue. By holding the SCL line low, the user has time to service the ISR and read the contents of the SSPBUF before the master device can initiate another receive sequence. This will prevent buffer overruns from occurring (see Figure 17-13).",
    "17.4.4.1 Clock Stretching for 7-bit Slave Receive Mode (SEN = 1 )\nNote 1: If the  user  reads  the  contents  of  the SSPBUF  before  the  falling  edge  of  the ninth clock, thus clearing the BF bit, the CKP  bit  will  not  be  cleared  and  clock stretching will not occur.\n2: The  CKP  bit  can  be  set  in  software regardless of the state of the BF bit. The user should be careful to clear the BF bit in the ISR before the next receive sequence in order to prevent an overflow condition.",
    "17.4.4.2 Clock Stretching for 10-bit Slave Receive Mode (SEN = 1 )\nIn  10-bit  Slave  Receive  mode,  during  the  address sequence,  clock  stretching  automatically  takes  place but CKP is not cleared. During this time, if the UA bit is set  after  the  ninth  clock,  clock  stretching  is  initiated. The UA bit is set after receiving the upper byte of the 10-bit address and following the receive of the second byte of the 10-bit address with the R/W bit cleared to ' 0 '. The release of the clock line occurs upon updating SSPADD.  Clock  stretching  will  occur  on  each  data receive sequence as described in 7-bit mode.\nNote: If the user polls the UA bit and clears it by updating the SSPADD register before the falling edge of the ninth clock occurs and if the user hasn't cleared the BF bit by reading the SSPBUF register before that time, then the CKP bit will still NOT be asserted low.  Clock  stretching  on  the  basis  of  the state  of  the  BF  bit  only  occurs  during  a data sequence, not an address sequence.",
    "17.4.4.2 Clock Stretching for 10-bit Slave Receive Mode (SEN = 1 )\n7-bit Slave Transmit mode implements clock stretching by clearing the CKP bit after the falling edge of the ninth clock, if the BF bit is clear. This occurs regardless of the state of the SEN bit.\nThe user's ISR must set the CKP bit before transmission is allowed to continue. By holding the SCL line low, the user has time to service the ISR and load the contents  of  the  SSPBUF  before  the  master  device  can initiate another transmit sequence (see Figure 17-9).\nNote 1: If the user loads the contents of SSPBUF, setting the BF bit before the falling edge of the  ninth  clock,  the  CKP  bit  will  not  be cleared and clock stretching will not occur.\n2: The  CKP  bit  can  be  set  in  software regardless of the state of the BF bit.",
    "17.4.4.4 Clock Stretching for 10-bit Slave Transmit Mode\nIn  10-bit  Slave  Transmit  mode,  clock  stretching  is controlled during the first  two  address  sequences  by the  state  of  the  UA  bit,  just  as  it  is  in  10-bit  Slave Receive mode. The first two addresses are followed by a third address sequence which contains the high order bits of the 10-bit address and the R/W bit set to ' 1 '. After the third address sequence is performed, the UA bit is not  set,  the  module  is  now  configured  in  Transmit mode, and clock stretching is controlled by the BF flag as in   7-bit Slave Transmit mode (see Figure 17-11).",
    "17.4.4.5 Clock Synchronization and the CKP bit\nWhen the CKP bit is cleared, the SCL output is forced to ' 0 '. However, setting the CKP bit will not assert the SCL output low until the SCL output is already sampled low. Therefore, the CKP bit will not assert the SCL line until an external I 2 C  master  device has already asserted the SCL line. The SCL output will remain low until the CKP bit is set and all other devices on the I 2 C bus have deasserted SCL. This ensures that a write to the  CKP  bit  will  not  violate  the  minimum  high  time requirement for SCL (see Figure 17-12).",
    "17.4.5 GENERAL CALL ADDRESS SUPPORT\nThe addressing procedure for the I 2 C bus is such that the first byte after the Start condition usually determines which device will be the slave addressed by the master. The exception is the general call address which can address all devices. When this address is used,  all  devices  should,  in  theory,  respond  with  an Acknowledge.\nThe  general  call  address  is  one  of  eight  addresses reserved for specific purposes by the I 2 C protocol. It consists of all ' 0 's with R/W = 0 .\nThe general call address is recognized when the General Call Enable bit (GCEN) is enabled (SSPCON2<7> is set). Following a Start bit detect, 8 bits are shifted into the SSPSR and the address is compared against the SSPADD.  It  is  also  compared  to  the  general  call address and fixed in hardware.\nIf  the  general  call  address  matches,  the  SSPSR  is transferred to the SSPBUF, the BF flag bit is set (eighth bit) and on the falling edge of the ninth bit (ACK bit), the SSPIF interrupt flag bit is set.",
    "17.4.5 GENERAL CALL ADDRESS SUPPORT\nWhen the interrupt is serviced, the source for the interrupt  can  be  checked  by  reading  the  contents  of  the SSPBUF. The value can be used to determine if the address was device specific or a general call address.\nIn 10-bit mode, the SSPADD is required to be updated for the second half of the address to match and the UA bit is set (SSPSTAT<1>). If the general call address is sampled when the GCEN bit is set while the slave is configured  in  10-bit  Address  mode,  then  the  second half of the address is not necessary, the UA bit will not be set and the slave will begin receiving data after the Acknowledge (Figure 17-15).",
    "17.4.6 MASTER MODE\nMaster  mode  is  enabled  by  setting  and  clearing  the appropriate SSPM bits in SSPCON1 and by setting the SSPEN bit. In Master mode, the SCL and SDA lines are manipulated by the MSSP hardware.\nMaster  mode  of  operation  is  supported  by  interrupt generation  on  the  detection  of  the  Start  and  Stop conditions. The Stop (P) and Start (S) bits are cleared from a Reset or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set or the bus is Idle, with both the S and P bits clear.\nIn Firmware  Controlled Master  mode,  user  code conducts  all  I 2 C  bus  operations  based  on  Start  and Stop bit conditions.\nOnce  Master  mode  is  enabled,  the  user  has  six options.\n1. Assert a Start condition on SDA and SCL.\n2. Assert a Repeated Start condition on SDA and SCL.\n3. Write to the SSPBUF register initiating transmission of data/address.\n4. Configure the I 2 C port to receive data.\n5. Generate an Acknowledge condition at the end of a received byte of data.\n6. Generate a Stop condition on SDA and SCL.",
    "Note:\nThe  MSSP  module,  when  configured  in I 2 C Master mode, does not allow queueing of  events.  For  instance,  the  user  is  not allowed  to  initiate  a  Start  condition  and immediately write the SSPBUF register to initiate transmission before the Start condition is complete. In this case, the SSPBUF will not be written to and the WCOL bit will be  set, indicating that a write to the SSPBUF did not occur.\nThe following events will cause SSP interrupt flag bit, SSPIF, to be set (SSP interrupt if enabled):\n\u00b7 Start Condition\n\u00b7 Stop Condition\n\u00b7 Data Transfer Byte Transmitted/Received\n\u00b7 Acknowledge Transmit\n\u00b7 Repeated Start",
    "17.4.6.1 I 2 C Master Mode Operation\nA typical transmit sequence would go as follows:\nThe  master  device  generates  all  of  the  serial  clock pulses and the Start and Stop conditions.   A transfer is ended with a Stop condition or with a Repeated Start condition.  Since  the  Repeated  Start condition  is  also the beginning of the next serial transfer, the I 2 C bus will not be released.\nIn  Master  Transmitter  mode,  serial  data  is  output through SDA while SCL outputs the serial clock. The first byte transmitted contains the slave address of the receiving device (7 bits) and the Read/Write (R/W) bit. In this case, the R/W bit will be logic ' 0 '. Serial data is transmitted 8 bits at a time. After each byte is transmitted,  an  Acknowledge  bit  is  received.  Start  and  Stop conditions are output to indicate the beginning and the end of a serial transfer.",
    "17.4.6.1 I 2 C Master Mode Operation\nIn Master Receive mode, the first byte transmitted contains  the  slave  address  of  the  transmitting  device (7 bits) and the R/W bit. In this case, the R/W bit will be logic ' 1 '. Thus, the first byte transmitted is a 7-bit slave address followed by a ' 1 ' to indicate a receive bit. Serial data is received via SDA while SCL outputs the serial clock. Serial data is received 8 bits at a time. After each byte  is  received,  an  Acknowledge  bit  is  transmitted. Start  and  Stop  conditions  indicate  the  beginning  and end of transmission.\nThe  Baud  Rate  Generator  used  for  the  SPI  mode operation is used to set the SCL clock frequency for either 100 kHz, 400 kHz or 1 MHz I 2 C operation. See Section 17.4.7  'Baud  Rate  Generator' for more detail.",
    "17.4.6.1 I 2 C Master Mode Operation\n1. The user generates a Start condition by setting the Start enable bit, SEN (SSPCON2<0>).\n2. SSPIF is  set.  The  MSSP module will wait  the required  start  time  before  any  other  operation takes place.\n3. The  user  loads  the  SSPBUF  with  the  slave address to transmit.\n4. Address is shifted out the SDA pin until all 8 bits are transmitted.\n5. The MSSP module shifts in the ACK bit from the slave device and  writes its value into the SSPCON2 register (SSPCON2<6>).\n6. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.\n7. The user loads the SSPBUF with eight bits of data.\n8. Data is shifted out the SDA pin until all 8 bits are transmitted.\n9. The MSSP module shifts in the ACK bit from the slave device and  writes its value into the SSPCON2 register (SSPCON2<6>).\n10. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.",
    "17.4.6.1 I 2 C Master Mode Operation\n11. The user generates a Stop condition by setting the Stop enable bit PEN (SSPCON2<2>).\n12. Interrupt is generated once the Stop condition is complete.",
    "17.4.7 BAUD RATE GENERATOR\nIn I 2 C Master mode, the Baud Rate Generator (BRG) reload  value  is  placed  in  the  lower  7  bits  of  the SSPADD register (Figure 17-17). When a write occurs to SSPBUF, the Baud Rate Generator will automatically begin counting. The BRG counts down to ' 0 ' and stops until another reload has taken place. The BRG count is decremented twice per instruction cycle (TCY) on the Q2 and Q4 clocks. In I 2 C Master mode, the BRG is reloaded automatically.\nOnce the given operation is complete (i.e., transmission of the last data bit is followed by ACK), the internal clock will automatically stop counting and the SCL pin will remain in its last state.\nTable 17-3 demonstrates clock rates based on instruction  cycles  and  the  BRG  value  loaded  into SSPADD.",
    "TABLE 17-3: I 2 C CLOCK RATE w/BRG\n10 MHz, FCY*2 = 20 MHz. 10 MHz, BRG Value = 19h. 10 MHz, FSCL (2 Rollovers of BRG) = 400 kHz (1). 10 MHz, FCY*2 = 20 MHz. 10 MHz, BRG Value = 20h. 10 MHz, FSCL (2 Rollovers of BRG) = 312.5 kHz. 10 MHz, FCY*2 = 20 MHz. 10 MHz, BRG Value = 64h. 10 MHz, FSCL (2 Rollovers of BRG) = 100 kHz. 4 MHz, FCY*2 = 8 MHz. 4 MHz, BRG Value = 0Ah. 4 MHz, FSCL (2 Rollovers of BRG) = 400 kHz (1). 4 MHz, FCY*2 = 8 MHz. 4 MHz, BRG Value = 0Dh. 4 MHz, FSCL (2 Rollovers of BRG) = 308 kHz. 4 MHz, FCY*2 = 8 MHz. 4 MHz, BRG Value = 28h. 4 MHz, FSCL (2 Rollovers of BRG) = 100 kHz.",
    "TABLE 17-3: I 2 C CLOCK RATE w/BRG\n1 MHz, FCY*2 = 2 MHz. 1 MHz, BRG Value = 03h. 1 MHz, FSCL (2 Rollovers of BRG) = 333 kHz (1). 1 MHz, FCY*2 = 2 MHz. 1 MHz, BRG Value = 0Ah. 1 MHz, FSCL (2 Rollovers of BRG) = 100 kHz. 1 MHz, FCY*2 = 2 MHz. 1 MHz, BRG Value = 00h. 1 MHz, FSCL (2 Rollovers of BRG) = 1 MHz (1)\nNote 1: The I 2 C interface does not conform to the 400 kHz I C specification (which applies to rates greater than 2 100 kHz) in all details but may be used with care where higher rates are required by the application.",
    "17.4.7.1 Clock Arbitration\nClock arbitration occurs when the master, during any receive,  transmit  or  Repeated  Start/Stop  condition, deasserts  the  SCL  pin  (SCL  allowed  to  float  high). When the SCL pin is allowed to float high, the Baud Rate  Generator  (BRG)  is  suspended  from  counting until the SCL pin is actually sampled high. When the\nSCL pin is sampled high, the Baud Rate Generator is reloaded  with  the  contents  of  SSPADD<6:0>  and begins counting. This ensures that the SCL high time will always be at least one BRG rollover count in the event that the clock is held low by an external device (Figure 17-18).",
    "17.4.8 I 2 C MASTER MODE START CONDITION TIMING\nTo initiate a Start condition, the user sets the Start Condition Enable bit, SEN (SSPCON2<0>). If the SDA and SCL pins are sampled high, the Baud Rate Generator is  reloaded  with  the  contents  of  SSPADD<6:0>  and starts its count. If SCL and SDA are both sampled high when the Baud Rate Generator times out (TBRG), the SDA pin is  driven  low.  The  action  of  the  SDA  being driven low while SCL is high is the Start condition and causes the S bit (SSPSTAT<3>) to be set. Following this,  the  Baud  Rate  Generator  is  reloaded  with  the contents  of  SSPADD<6:0>  and  resumes  its  count. When the Baud Rate Generator times out (TBRG), the SEN bit (SSPCON2<0>) will be automatically cleared by hardware, the Baud Rate Generator is suspended, leaving the SDA line held low and the Start condition is complete.",
    "Note:\nIf  at  the  beginning  of  the  Start  condition, the SDA and SCL pins are already sampled low or if during the Start condition, the SCL line is sampled low before the SDA line  is  driven  low,  a  bus  collision  occurs, the Bus Collision Interrupt Flag, BCLIF, is set, the Start condition is aborted and the I 2 C module is reset into its Idle state.",
    "17.4.8.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Start sequence is in progress, the WCOL is set and the contents of the buffer are unchanged (the write doesn't occur).",
    "Note:\nBecause queueing of events is not allowed,  writing  to  the  lower  5  bits  of SSPCON2  is  disabled until the Start condition is complete.",
    "17.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nA Repeated Start condition occurs when the RSEN bit (SSPCON2<1>) is programmed high and the I 2 C logic module is in the Idle state. When the RSEN bit is set, the  SCL  pin  is  asserted  low.  When  the  SCL  pin  is sampled low, the Baud Rate Generator is loaded with the  contents  of  SSPADD<5:0>  and  begins  counting. The SDA pin is released (brought high) for one Baud Rate  Generator  count  (TBRG).  When  the  Baud  Rate Generator times out, if SDA is sampled high, the SCL pin  will  be  deasserted  (brought  high).  When  SCL  is sampled  high,  the  Baud  Rate  Generator  is  reloaded with the contents of SSPADD<6:0> and begins counting. SDA and SCL must be sampled high for one TBRG. This action is then followed by assertion of the SDA pin (SDA = 0 ) for one TBRG while SCL is high. Following this, the RSEN bit (SSPCON2<1>) will be automatically cleared  and  the  Baud  Rate  Generator  will  not",
    "17.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nbe reloaded, leaving the SDA pin held low. As soon as a Start condition is detected on the SDA and SCL pins, the S bit (SSPSTAT<3>) will be set. The SSPIF bit will not be set until the Baud Rate Generator has timed out.\nNote 1: If  RSEN is programmed while any other event is in progress, it will not take effect.\n2: A bus collision during the Repeated Start condition occurs if:\n\u00b7  SDA is sampled low when SCL goes from low-to-high.\n\u00b7  SCL goes low before SDA is asserted low. This may indicate that another master is attempting to transmit a data ' 1 '.",
    "FIGURE 17-20: REPEAT START CONDITION WAVEFORM\nImmediately  following  the  SSPIF  bit  getting  set,  the user may write the SSPBUF with the 7-bit address in 7-bit mode, or the default first address in 10-bit mode. After the first eight bits are transmitted and an ACK is received, the user may then transmit an additional eight bits of address (10-bit mode) or eight bits of data (7-bit mode).",
    "17.4.9.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Repeated Start sequence is in progress, the WCOL is set and the contents  of  the  buffer  are  unchanged  (the  write  doesn't occur).\nNote:, 1 = Because queueing of events is not allowed, writing of the lower 5 bits of SSPCON2 is disabled until the Repeated Start condition is complete.",
    "17.4.10 I 2 C MASTER MODE TRANSMISSION\nTransmission  of  a  data  byte,  a  7-bit  address,  or  the other half of a 10-bit address is accomplished by simply writing a value to the SSPBUF register. This action will set the Buffer Full flag bit, BF and allow the Baud Rate Generator to begin counting and start the next transmission.  Each  bit  of  address/data  will  be  shifted  out onto  the  SDA  pin  after  the  falling  edge  of  SCL  is asserted (see data hold time specification parameter #106). SCL is held low for one Baud Rate Generator rollover count (TBRG). Data should be valid before SCL is  released  high  (see  data  setup  time  specification parameter #107). When the SCL pin is released high, it is  held  that  way  for  TBRG.  The  data  on  the  SDA  pin must  remain  stable  for  that  duration  and  some  hold time after the next falling edge of SCL. After the eighth bit is shifted out (the falling edge of the eighth clock), the BF flag is cleared and the master releases SDA. This  allows  the  slave  device  being  addressed  to respond with an ACK bit during the ninth bit time if an address  match  occurred,  or  if  data  was",
    "17.4.10 I 2 C MASTER MODE TRANSMISSION\nreceived properly. The status of ACK is written into the ACKDT bit on the falling edge of the ninth clock. If the master receives an Acknowledge, the Acknowledge Status bit, ACKSTAT, is cleared. If not, the bit is set. After the ninth clock, the SSPIF bit is set and the master clock (Baud Rate Generator) is suspended until the next data byte is loaded into the SSPBUF, leaving SCL low and SDA unchanged (Figure 17-21).",
    "17.4.10 I 2 C MASTER MODE TRANSMISSION\nAfter the write to the SSPBUF, each bit of the address will be shifted out on the falling edge of SCL until all seven address bits and the R/W bit are completed. On the  falling  edge  of  the  eighth  clock,  the  master  will deassert the SDA pin, allowing the slave to respond with an Acknowledge. On the falling edge of the ninth clock, the master will sample the SDA pin to see if the address was recognized by a slave. The status of the ACK  bit is loaded into the ACKSTAT  status  bit (SSPCON2<6>). Following the falling edge of the ninth clock transmission of the address, the SSPIF is set, the BF  flag  is  cleared  and  the  Baud  Rate  Generator  is turned  off  until  another  write  to  the  SSPBUF  takes place, holding SCL low and allowing SDA to float.",
    "17.4.10.1 BF Status Flag\nIn  Transmit  mode,  the  BF  bit  (SSPSTAT<0>)  is  set when the CPU writes to SSPBUF and is cleared when all 8 bits are shifted out.",
    "17.4.10.2 WCOL Status Flag\nIf  the  user  writes  the  SSPBUF  when  a  transmit  is already in progress (i.e., SSPSR is still shifting out a data byte), the  WCOL is set and the contents of the buffer are unchanged (the write doesn't occur).\nWCOL must be cleared in software.",
    "17.4.10.3 ACKSTAT Status Flag\nIn Transmit mode, the ACKSTAT bit (SSPCON2<6>) is cleared  when  the  slave  has  sent  an  Acknowledge (ACK = 0 ) and is set when the slave does not Acknowledge (ACK = 1 ). A slave sends an Acknowledge when it has recognized its address (including a general call) or when the slave has properly received its data.",
    "17.4.11 I 2 C MASTER MODE RECEPTION\nMaster mode reception is enabled by programming the receive enable bit, RCEN (SSPCON2<3>).",
    "Note:\nThe MSSP module must be in an Idle state before the RCEN bit is set or the RCEN bit will be disregarded.\nThe Baud Rate Generator begins counting and on each rollover, the state of the SCL pin changes (high-to-low/ low-to-high) and data is shifted into the SSPSR. After the falling edge of the eighth clock, the receive enable flag is automatically cleared, the  contents of the SSPSR are loaded into the SSPBUF, the BF flag bit is set, the SSPIF flag bit is set and the Baud Rate Generator is suspended from counting, holding SCL low. The MSSP is now in Idle state  awaiting  the  next  command.  When  the  buffer  is read by the CPU, the BF flag bit is automatically cleared. The user can then send an Acknowledge bit at the end of reception  by  setting  the  Acknowledge  sequence enable bit, ACKEN (SSPCON2<4>).",
    "17.4.11.1 BF Status Flag\nIn receive operation, the BF bit is set when an address or data byte is loaded into SSPBUF from SSPSR. It is cleared when the SSPBUF register is read.",
    "17.4.11.2 SSPOV Status Flag\nIn receive operation, the SSPOV bit is set when 8 bits are  received  into  the  SSPSR  and  the  BF  flag  bit  is already set from a previous reception.",
    "17.4.11.3 WCOL Status Flag\nIf the  user  writes  the  SSPBUF  when  a  receive  is already in progress (i.e., SSPSR is still shifting in a data byte), the WCOL bit is set and the contents of the buffer are unchanged (the write doesn't occur).",
    "17.4.13 STOP CONDITION TIMING\nAn Acknowledge  sequence  is enabled by setting the Acknowledge Sequence Enable bit, ACKEN (SSPCON2<4>). When this  bit  is  set,  the  SCL  pin  is pulled low and the contents of the Acknowledge data bit are presented on the SDA pin. If the user wishes to generate an Acknowledge, then the ACKDT bit should be cleared. If not, the user should set the ACKDT bit before starting  an  Acknowledge  sequence.  The  Baud  Rate Generator  then  counts  for  one  rollover  period  (TBRG) and the SCL pin is deasserted (pulled high). When the SCL pin  is  sampled  high  (clock  arbitration),  the  Baud Rate Generator counts for TBRG. The SCL pin is then pulled low. Following this, the ACKEN bit is automatically cleared, the Baud Rate Generator is turned off and the MSSP module then goes into Idle mode (Figure 17-23).",
    "17.4.12.1 WCOL Status Flag\nIf the user writes the SSPBUF when an Acknowledge sequence is  in  progress,  then  WCOL  is  set  and  the contents of the buffer are unchanged (the write doesn't occur).\nA Stop bit is asserted on the SDA pin at the end of a receive/transmit by setting the Stop Sequence Enable bit,  PEN  (SSPCON2<2>).  At  the  end  of  a  receive/ transmit, the SCL line is held low after the falling edge of the ninth clock. When the PEN bit is set, the master will  assert  the  SDA  line  low.  When  the  SDA  line  is sampled low, the Baud Rate Generator is reloaded and counts  down  to  ' 0 '.  When  the  Baud  Rate  Generator times  out,  the  SCL pin  will  be  brought  high  and  one TBRG (Baud Rate Generator rollover count) later, the SDA pin will be deasserted. When the SDA pin is sampled high while SCL is high, the P bit (SSPSTAT<4>) is set. A TBRG later, the PEN bit is cleared and the SSPIF bit is set (Figure 17-24).",
    "17.4.13.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Stop sequence is in progress, then the WCOL bit is set and the contents  of  the  buffer  are  unchanged  (the  write  doesn't occur).",
    "17.4.14 SLEEP OPERATION\nWhile  in  Sleep  mode,  the  I 2 C  module  can  receive addresses or data and when an address match or complete  byte  transfer  occurs,  wake  the  processor  from Sleep (if the MSSP interrupt is enabled).",
    "17.4.15 EFFECT OF A RESET\nA Reset disables the MSSP module and terminates the current transfer.",
    "17.4.16 MULTI-MASTER MODE\nIn Multi-Master mode, the interrupt generation on the detection of  the Start  and  Stop conditions  allows  the determination of when the bus is free. The Stop (P) and Start  (S)  bits  are  cleared  from  a  Reset  or  when  the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit (SSPSTAT<4>) is set or the bus is Idle, with both the S and P bits clear. When the bus is busy, enabling the SSP interrupt will generate the interrupt when the Stop condition occurs.\nIn multi-master operation, the SDA line must be monitored  for  arbitration  to  see  if  the  signal  level  is  the expected  output  level.  This  check  is  performed  in hardware with the result placed in the BCLIF bit.\nThe states where arbitration can be lost are:\n\u00b7 Address Transfer\n\u00b7 Data Transfer\n\u00b7 A Start Condition\n\u00b7 A Repeated Start Condition\n\u00b7 An Acknowledge Condition",
    "17.4.16 MULTI-MASTER MODE\nMulti-Master mode support is achieved by bus arbitration. When the master outputs address/data bits onto the SDA pin, arbitration takes place when the master outputs  a  ' 1 '  on  SDA  by  letting  SDA  float  high  and another master asserts a ' 0 '.   When the SCL pin floats high,  data  should  be  stable.  If  the  expected  data  on SDA is a ' 1 ' and the data sampled on the SDA pin = 0 , then a bus collision has taken place. The master will set the Bus Collision Interrupt Flag, BCLIF and reset the I 2 C port to its Idle state (Figure 17-25).\nIf  a  transmit  was  in  progress  when  the  bus  collision occurred,  the  transmission  is  halted,  the  BF  flag  is cleared, the SDA and SCL lines are deasserted and the SSPBUF can be written to. When the user services the bus collision Interrupt  Service Routine  and  if  the  I 2 C bus  is  free,  the  user  can  resume  communication  by asserting a Start condition.",
    "17.4.16 MULTI-MASTER MODE\nIf a Start, Repeated Start, Stop, or Acknowledge condition was in progress when the bus collision occurred, the condition is aborted, the  SDA and SCL lines are deasserted,  and  the  respective  control  bits  in  the SSPCON2 register  are  cleared.  When  the  user  services the bus collision Interrupt Service Routine and if the I C bus is free, the user can resume communication 2 by asserting a Start condition.\nThe master will continue  to  monitor the SDA  and  SCL pins. If a Stop condition occurs, the SSPIF bit will be set.\nA  write  to  the  SSPBUF  will  start  the  transmission  of data  at  the  first  data  bit  regardless  of  where  the transmitter left off when the bus collision occurred.\nIn  Multi-Master  mode,  the  interrupt  generation  on  the detection of Start and Stop conditions allows the determination of when the bus is free. Control of the I C bus can 2 be taken when the P bit is set in the SSPSTAT register or the bus is Idle and the S and P bits are cleared.",
    "17.4.17.1 Bus Collision During a Start Condition\nDuring a Start condition, a bus collision occurs if:\na) SDA or SCL are sampled low at the beginning of the Start condition (Figure 17-26).\nb) SCL is sampled low before SDA is asserted low (Figure 17-27).\nIf  the  SDA  pin  is  sampled  low  during  this  count,  the BRG  is  reset  and  the  SDA  line  is  asserted  early (Figure 17-28). If, however, a ' 1 ' is sampled on the SDA pin, the SDA pin is asserted low at the end of the BRG count. The Baud Rate Generator is then reloaded and counts down to ' 0 ' and during this time, if the SCL pins are sampled as ' 0 ', a bus collision does not occur. At the end of the BRG count, the SCL pin is asserted low.\nDuring a Start  condition,  both  the  SDA  and  the  SCL pins are monitored.\nIf the SDA pin is already low or the SCL pin is already low, then all of the following occur:",
    "17.4.17.1 Bus Collision During a Start Condition\n\u00b7 the Start condition is aborted,\n\u00b7 the BCLIF flag is set, and\n\u00b7 the MSSP module is reset to its Idle state (Figure 17-26).\nThe Start condition begins with the SDA and SCL pins deasserted. When the SDA pin is sampled high, the Baud  Rate  Generator  is  loaded  from  SSPADD<6:0> and counts down to ' 0 '. If the SCL pin is sampled low while SDA is high, a bus collision occurs because it is assumed that another master is attempting to drive a data ' 1 ' during the Start condition.\nThe reason that bus collision is not a factor during a Start condition is that no two bus masters can assert a Start condition at the exact  same  time.  Therefore,  one  master will  always  assert  SDA  before  the  other. This condition does  not cause  a bus collision because the two masters must be allowed to arbitrate the first address following the Start condition. If the address is the same, arbitration must be allowed to continue  into  the  data  portion,  Repeated Start or Stop conditions.",
    "17.4.17.2 Bus Collision During a Repeated Start Condition\nDuring  a  Repeated  Start  condition,  a  bus  collision occurs if:\nreloaded and begins counting. If SDA goes from high to low before the BRG times out, no bus collision occurs because no two masters can assert SDA at exactly the same time.\na) A low level is sampled on SDA when SCL goes from low level to high level.\nb) SCL  goes  low  before  SDA  is  asserted  low, indicating that  another master is  attempting  to transmit a data ' 1 '.\nWhen the user deasserts SDA and the pin is allowed to float high, the BRG is loaded with SSPADD<6:0> and counts down to ' 0 '. The SCL pin is then deasserted and when sampled high, the SDA pin is sampled.\nIf SDA is low, a bus collision has occurred (i.e., another master is attempting to transmit a data ' 0 ', see Figure 17-29).  If  SDA  is  sampled  high,  the  BRG  is",
    "17.4.17.2 Bus Collision During a Repeated Start Condition\nIf SCL goes from high to low before the BRG times out and SDA has not already been asserted, a bus collision occurs.  In  this  case,  another  master  is  attempting  to transmit a data ' 1 ' during the Repeated Start condition (see Figure 17-30).\nIf, at the end of the BRG time-out, both SCL and SDA are still high, the SDA pin is driven low and the BRG is reloaded and begins counting. At the end of the count, regardless of the status of the SCL pin, the SCL pin is driven low and the Repeated Start condition is complete.",
    "17.4.17.3 Bus Collision During a Stop Condition\nBus collision occurs during a Stop condition if:\na) After  the  SDA  pin  has  been  deasserted  and allowed to float high, SDA is sampled low after the BRG has timed out.\nb) After the SCL pin is deasserted, SCL is sampled low before SDA goes high.\nThe  Stop  condition  begins  with  SDA  asserted  low. When SDA is sampled low, the SCL pin is allowed to float. When the pin is sampled high (clock arbitration), the Baud Rate Generator is loaded with SSPADD<6:0> and counts down to ' 0 '. After the BRG times out, SDA is sampled. If SDA is sampled low, a bus collision has occurred. This is due to another master attempting to drive  a  data  ' 0 ' (Figure 17-31).  If  the  SCL  pin  is sampled low before SDA is allowed to float high, a bus collision occurs. This is another case of another master attempting to drive a data ' 0 ' (Figure 17-32).",
    "FIGURE 17-32: BUS COLLISION DURING A STOP CONDITION (CASE 2)\nSDA\nSCL\nBCLIF\nPEN\nP\nSSPIF\nTBRG\nTBRG\nTBRG\nAssert SDA\nSCL goes low before SDA goes high, set BCLIF\n'\n0\n'\n'\n0\n'",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "18.0 ENHANCED UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (USART)\nThe  Universal  Synchronous  Asynchronous  Receiver Transmitter (USART) module is one of the two serial I/O  modules.  (USART  is  also  known  as  a  Serial Communications Interface or SCI.) The USART can be configured as a full-duplex asynchronous system that can  communicate  with  peripheral  devices,  such  as CRT terminals and personal computers. It can also be configured as a half-duplex synchronous system that can communicate with peripheral devices, such as A/D or D/A integrated circuits, serial EEPROMs, etc.\nThe Enhanced USART module implements additional features, including automatic baud rate detection and calibration, automatic wake-up on sync break reception and  12-bit  break  character  transmit.  These  make  it ideally suited for use in Local Interconnect Network bus (LIN bus) systems.\nThe USART can be configured in the following modes:",
    "18.0 ENHANCED UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (USART)\n\u00b7 Asynchronous (full-duplex) with:\n-Auto-wake-up on character reception\n-Auto-baud calibration\n-12-bit break character transmission\n\u00b7 Synchronous - Master (half-duplex) with selectable clock polarity\n\u00b7 Synchronous - Slave (half-duplex) with selectable clock polarity\nIn order to configure pins RC6/TX/CK and RC7/RX/DT as the Universal Synchronous Asynchronous Receiver Transmitter:\n\u00b7 SPEN (RCSTA<7>) bit must be set (= 1 ),\n\u00b7 TRISC<6> bit must be set (= 1 ), and\n\u00b7 TRISC<7> bit must be set (= 1 ) .\nNote:\nThe USART  control will automatically reconfigure the pin from input to output as needed.\nThe  operation  of  the  Enhanced  USART  module  is controlled through three registers:\n\u00b7 Transmit Status and Control (TXSTA)\n\u00b7 Receive Status and Control (RCSTA)\n\u00b7 Baud Rate Control (BAUDCON)",
    "18.0 ENHANCED UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (USART)\nThese are detailed on the following pages in Register 18-1, Register 18-2 and Register 18-3, respectively.",
    "TXSTA: TRANSMIT STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R-1. R/W-0, 7 = R/W-0. CSRC, 1 = TX9. CSRC, 2 = TXEN. CSRC, 3 = SYNC. CSRC, 4 = SENDB. CSRC, 5 = BRGH. CSRC, 6 = TRMT. CSRC, 7 = TX9D\nbit 7\nbit 0",
    "Asynchronous mode:\nDon't care.",
    "Synchronous mode:\n- 1 = Master mode (clock generated internally from BRG)\n0 = Slave mode (clock from external source)",
    "bit 6 TX9: 9-bit Transmit Enable bit\n- 1 = Selects 9-bit transmission\n0 = Selects 8-bit transmission",
    "bit 5 TXEN: Transmit Enable bit\n1 = Transmit enabled\n0 = Transmit disabled\nNote:\nSREN/CREN overrides TXEN in Sync mode.",
    "bit 4 SYNC:\nUSART Mode Select bit\n- 1 = Synchronous mode\n0 = Asynchronous mode",
    "bit 3 SENDB:\nSend Break Character bit",
    "Asynchronous mode:\n- 1 = Send sync break on next transmission (cleared by hardware upon completion)\n0 = Sync break transmission completed",
    "Synchronous mode:\nDon't care.",
    "Asynchronous mode:\n1 = High speed\n0 = Low speed",
    "Synchronous mode:\nUnused in this mode.",
    "bit 1 TRMT: Transmit Shift Register Status bit\n1 = TSR empty\n0 = TSR full",
    "bit 0 TX9D: 9th bit of Transmit Data\nCan be address/data bit or a parity bit.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 18-2: RCSTA: RECEIVE STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-x. SPEN, 1 = RX9. SPEN, 2 = SREN. SPEN, 3 = CREN. SPEN, 4 = ADDEN. SPEN, 5 = FERR. SPEN, 6 = OERR. SPEN, 7 = RX9D\nbit 7\nbit 0",
    "bit 7 SPEN: Serial Port Enable bit\n1 = Serial port enabled (configures RX/DT and TX/CK pins as serial port pins)\n0 = Serial port disabled (held in Reset)",
    "bit 6 RX9: 9-bit Receive Enable bit\n1 = Selects 9-bit reception\n0 = Selects 8-bit reception",
    "Asynchronous mode:\nDon't care.",
    "Synchronous mode - Master:\n1 = Enables single receive\n0 = Disables single receive\nThis bit is cleared after reception is complete.",
    "Synchronous mode - Slave:\nDon't care.",
    "bit 4 CREN: Continuous Receive Enable bit\nAsynchronous mode:\n1 = Enables receiver\n0 = Disables receiver",
    "Synchronous mode:\n1 = Enables continuous receive until enable bit CREN is cleared (CREN overrides SREN)\n0 = Disables continuous receive",
    "bit 3 ADDEN: Address Detect Enable bit\nAsynchronous mode 9-bit (RX9 = 1 ):\n1 = Enables address detection, enables interrupt and loads the receive buffer when RSR<8> is set\n0 = Disables address detection, all bytes are received and ninth bit can be used as parity bit Asynchronous mode 9-bit (RX9 = 0 ):\nDon't care.",
    "bit 2 FERR: Framing Error bit\n1 = Framing error (can be updated by reading RCREG register and receiving next valid byte)\n0\n= No framing error",
    "bit 1 OERR: Overrun Error bit\n1 = Overrun error (can be cleared by clearing bit CREN)\n0 = No overrun error",
    "bit 0 RX9D: 9th bit of Received Data\nThis can be an address/data bit or a parity bit and must be calculated by user firmware.\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "BAUDCON: BAUD RATE CONTROL REGISTER\nU-0, 1 = R-1. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = U-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = RCIDL. -, 2 = -. -, 3 = SCKP. -, 4 = BRG16. -, 5 = -. -, 6 = WUE. -, 7 = ABDEN\nbit 7\nbit 0",
    "bit 6 RCIDL : Receive Operation Idle Status bit\n- 1 = Receive operation is Idle\n0 = Receive operation is active",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4\nSCKP : Synchronous Clock Polarity Select bit",
    "Asynchronous mode:\nUnused in this mode.",
    "Synchronous mode:\n1 = Idle state for clock (CK) is a high level\n0 = Idle state for clock (CK) is a low level\nBRG16: 16-bit Baud Rate Register Enable bit\n1 = 16-bit Baud Rate Generator - SPBRGH and SPBRG\n0 = 8-bit Baud Rate Generator - SPBRG only (Compatible mode), SPBRGH value ignored",
    "bit 2 Unimplemented: Read as ' 0 '\nbit 1\nWUE:\nWake-up Enable bit",
    "Asynchronous mode:\n1 = USART will continue to sample the RX pin - interrupt generated on falling edge; bit cleared in hardware on following rising edge\n0 = RX pin not monitored or rising edge detected",
    "Synchronous mode:\nUnused in this mode.",
    "Asynchronous mode:\n1 = Enable baud rate measurement on the next character - requires reception of a sync field (55h); cleared in hardware upon completion\n0 = Baud rate measurement disabled or completed",
    "Synchronous mode:\nUnused in this mode.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "18.1 USART Baud Rate Generator (BRG)\nThe BRG is a dedicated 8-bit or 16-bit generator that supports  both  the  Asynchronous  and  Synchronous modes of the USART. By default, the BRG operates in 8-bit  mode;  setting  the  BRG16  bit  (BAUDCON<3>) selects 16-bit mode.\nthe error in baud rate can be determined. An example calculation  is  shown  in  Example 18-1.  Typical  baud rates  and  error  values  for  the  various  Asynchronous modes are shown in Table 18-2. It may be advantageous to use the high baud rate (BRGH = 1 ) or the 16-bit BRG to reduce the baud rate error, or achieve a slow baud rate for a fast oscillator frequency.",
    "18.1 USART Baud Rate Generator (BRG)\nThe SPBRGH:SPBRG register pair controls the period of  a  free-running  timer.  In  Asynchronous  mode,  bits BRGH (TXSTA<2>) and BRG16 also control the baud rate.  In  Synchronous  mode,  bit  BRGH  is  ignored. Table 18-1 shows the formula for computation  of the baud rate for different USART modes which only apply in Master mode (internally generated clock).\nGiven  the  desired  baud  rate  and  FOSC,  the  nearest integer value for the SPBRGH:SPBRG registers can be calculated using the formulas in Table 18-1. From this,\nWriting a new value to the SPBRGH:SPBRG registers causes  the  BRG  timer  to  be  reset  (or  cleared).  This ensures  the  BRG does not wait for  a  timer  overflow before outputting the new baud rate.",
    "18.1.1 SAMPLING\nThe data on the RC7/RX/DT pin is sampled three times by a majority detect circuit to determine if a high or a low level is present at the RX pin.",
    "TABLE 18-1: BAUD RATE FORMULAS\n0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 0. 0, BRG/USART Mode.BRG/USART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[64 (n + 1)]. 0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 1. 0, BRG/USART Mode.BRG/USART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[16 (n + 1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 0. 0, BRG/USART Mode.BRG/USART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[16 (n + 1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 1. 0, BRG/USART",
    "TABLE 18-1: BAUD RATE FORMULAS\nMode.BRG/USART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]. 1, Configuration Bits.BRG16 = 0. 1, Configuration Bits.BRGH = x. 1, BRG/USART Mode.BRG/USART Mode = 8-bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]. 1, Configuration Bits.BRG16 = 1. 1, Configuration Bits.BRGH = x. 1, BRG/USART Mode.BRG/USART Mode = 16-bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = FOSC/[4 (n + 1)]\nLegend: x = Don't care, n = Value of SPBRGH:SPBRG register pair",
    "EXAMPLE 18-1: CALCULATING BAUD RATE ERROR\nFor a device with FOSC of 16 MHz, desired baud rate of 9600, Asynchronous mode, 8-bit BRG:\nDesired Baud Rate =  FOSC/(64 ([SPBRGH:SPBRG] + 1))\nSolving for SPBRGH:SPBRG:\nX\n= ((FOSC/Desired Baud Rate)/64) - 1\n= ((16000000/9600)/64) - 1\n= [25.042] = 25\nCalculated Baud Rate= 16000000/(64 (25 + 1))\n= 9615\nError\n= (Calculated Baud Rate - Desired Baud Rate)/Desired Baud Rate\n= (9615 - 9600)/9600 = 0.16%",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nTXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000 0010. TXSTA, Value on all other Resets = . TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000 000x. RCSTA, Value on all other Resets = . RCSTA, Value on all other Resets = 0000. RCSTA, Value on",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nall other Resets = 000x. BAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Value on POR, BOR = -1-0. BAUDCON, Value on all other Resets = 0-00. BAUDCON, Value on all other Resets = -1-0. BAUDCON, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register, High",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nByte. SPBRGH, Bit 1 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register, High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register, Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other Resets =",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\n0000. SPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used by the BRG.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 1.221. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 255. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 2.441. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 2.4, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n64. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 0 , BRG16",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 31. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 15. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K)",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 9615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n, BRG16 = 0.FOSC = 20.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 15. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 7. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n-. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 4. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 52.083. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -9.58. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 2. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 104.167. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -9.58. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 2. 115.2, SYNC = 0 , BRGH = 0",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n, BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 78.125. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -32.18. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 0.3, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 1201.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 12. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 2.4, SYNC",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 8.929. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -6.99. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 6. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.SPBRG value (decimal) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 20.833. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 2. 19.2, SYNC = 0 , BRGH",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -45.75. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 0. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0 , BRGH = 0 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 40.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = -.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = -. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 2.441. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 255. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n8.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 9.766. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 1.73. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 255. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 9.615.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 129. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = 0.16.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n(decimal) = 21. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = 55555. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 1",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n, BRG16 = 0.FOSC = 40.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 40.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 10.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n= 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nMHz.SPBRG value (decimal) = 12. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 62.500.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\n1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 4.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES\nBRG16 = 0.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 0.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 8332. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 4165. 0.3, SYNC = 0 , BRGH = 0 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.02. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 2082. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 1665. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nRate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.02. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 2082. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 1041. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 1.200. 1.2,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -0.03. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 520. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 415. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 2.402. 2.4, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 40.000 MHz.% Error = 0.06. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 1040. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 2.399. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 520. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 259. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 259. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 129. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n10.000 MHz.SPBRG value (decimal) = 64. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 129.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 19.531. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 1.73. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 31. 19.2, SYNC = 0 , BRGH = 0 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 25. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nRate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 21. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 56.818. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -1.36. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 10. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 55555. 57.6,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 0 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 20.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 4. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = -",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.04. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 832. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 415. 0.3, SYNC = 0 , BRGH = 0 , BRG16",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1.FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 0.3, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 1.202. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 207. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K)",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 103. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 25. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 9.6, SYNC",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 12. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 9.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n4.000 MHz.SPBRG value (decimal) = 12. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 19.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 62.500. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 8.51. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 3. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nMHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 125.000. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 8.51. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 1. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 0 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 33332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.00.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 16665. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.00. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 8332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 300.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.01. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 6665. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.00. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 8332.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 4165. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.02.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 2082. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 1200. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 1665. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 2.400.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.02. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 4165. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 2.400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.02. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 2082.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 2.402. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.06. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 1040. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 2400. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.04.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 832. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 9.606. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.06. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 1040. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n9.596. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.03. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 520. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal)",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 259. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 207. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 19.193. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -0.03.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 520. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 259. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 19.231.",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 129. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 103. 57.6,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 57.803. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = 0.35. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 172. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 57.471. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = -0.22. 57.6, SYNC",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 86. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 58.140. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = 0.94. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 42. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 57142. 57.6, SYNC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = 0.79. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 34. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.Actual Rate (K) = 114.943. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.% Error = -0.22. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 40.000 MHz.SPBRG value (decimal) = 86. 115.2, SYNC = 0 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.Actual Rate (K) = 116.279. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.% Error = 0.94. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 20.000 MHz.SPBRG value (decimal) = 42. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.Actual Rate (K) = 113.636. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.% Error = -1.36. 115.2, SYNC = 0 , BRGH",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 10.000 MHz.SPBRG value (decimal) = 21. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.Actual Rate (K) = 117647. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.% Error = -2.12. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 8.000 MHz.SPBRG value (decimal) = 16",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 0.300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.01. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 3332. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.04. 0.3,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 1665. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 300. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.04. 0.3, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 832. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 1.200. 1.2, SYNC",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.04. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 832. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 415. 1.2, SYNC = 0 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 1201. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 1.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 207. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 2.404. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 2.4, SYNC = 0 , BRGH = 1",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n, BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 415. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 207. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 2403. 2.4, SYNC = 0 , BRGH = 1 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 2.4, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 103. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 9.615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 103. 9.6, SYNC = 0 , BRGH = 1 ,",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nBRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 51. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 9615. 9.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 9.6, SYNC = 0 , BRGH = 1 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 25. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 19.231. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 51. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\nSYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 25. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = 19230. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -0.16. 19.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = 12. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n, BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 58.824. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.% Error = 2.12. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 16. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = 55555. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = 3.55. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n= 1.FOSC = 2.000 MHz.SPBRG value (decimal) = 8. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.Actual Rate (K) = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 57.6, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.Actual Rate (K) = 111.111. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.FOSC = 4.000 MHz.% Error = -3.55. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 4.000 MHz.SPBRG value (decimal) = 8. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 2.000 MHz.SPBRG value (decimal) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC =",
    "TABLE 18-3: BAUD RATES FOR ASYNCHRONOUS MODES (CONTINUED)\n1.000 MHz.Actual Rate (K) = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.% Error = -. 115.2, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.FOSC = 1.000 MHz.SPBRG value (decimal) = -",
    "18.1.2 AUTO-BAUD RATE DETECT\nThe enhanced USART module supports the automatic detection and calibration of baud rate. This feature is active only in Asynchronous mode and while the WUE bit is clear.\ncarry occurred for 8-bit modes by checking for 00h in the SPBRGH register. Refer to Table 18-4 for counter clock rates to the BRG.\nThe  automatic  baud  rate  measurement  sequence (Figure 18-1) begins whenever a Start bit is received and the ABDEN  bit is set. The calculation is self-averaging.\nIn the Auto-Baud Rate Detect (ABD) mode, the clock to the BRG is reversed. Rather than the BRG clocking the incoming RX signal, the RX signal is timing the BRG. In ABD mode, the internal Baud Rate Generator is used as a counter to time the bit period of the incoming serial byte stream.",
    "18.1.2 AUTO-BAUD RATE DETECT\nOnce the ABDEN bit is set, the state machine will clear the BRG and look for a Start bit. The auto-baud detect must  receive  a  byte  with  the  value  55h  (ASCII  'U', which is also the LIN bus sync character) in order to calculate the proper bit rate. The measurement is taken over both a low and a high bit time in order to minimize any  effects  caused  by  asymmetry  of  the  incoming signal. After a Start bit, the SPBRG begins counting up using the preselected clock source on the first rising edge of RX. After eight bits on the RX pin or the fifth rising edge, an accumulated value totalling the proper BRG period is left in the SPBRGH:SPBRG registers. Once the 5th edge is seen (should correspond to the Stop bit), the ABDEN bit is automatically cleared.\nWhile the ABD sequence takes place, the USART state machine is held in Idle. The RCIF interrupt is set once the fifth rising edge on RX is detected. The value in the RCREG needs to be read to clear the RCIF interrupt. RCREG content should be discarded.",
    "18.1.2 AUTO-BAUD RATE DETECT\nNote 1: If the WUE bit is set with the ABDEN bit, auto-baud rate detection will occur on the byte following the break character.\n2: It is up to the user to determine that the incoming character baud rate is within the range of the selected BRG clock source. Some  combinations of oscillator frequency and USART baud rates are not possible  due  to  bit  error  rates.  Overall system timing  and communication baud rates  must  be  taken  into  consideration when using the auto-baud rate detection feature.",
    "TABLE 18-4: BRG COUNTER CLOCK RATES\nWhile calibrating the baud rate period, the BRG registers are clocked at 1/8th the preconfigured clock rate. Note  that  the  BRG  clock  will  be  configured  by  the BRG16 and BRGH bits. Independent of the BRG16 bit setting, both the SPBRG and SPBRGH will be used as a 16-bit counter. This allows the user to verify that no\n0, BRGH = 0. 0, BRG Counter Clock = FOSC/512. 0, BRGH = 1. 0, BRG Counter Clock = FOSC/128. 1, BRGH = 0. 1, BRG Counter Clock = FOSC/128. 1, BRGH = 1. 1, BRG Counter Clock = FOSC/32\nNote:\nDuring  the  ABD  sequence,  SPBRG  and SPBRGH  are  both  used as a 16-bit counter independent of BRG16 setting.",
    "18.2 USART Asynchronous Mode\nThe Asynchronous mode of operation is selected  by clearing the SYNC bit (TXSTA<4>). In this mode, the USART uses standard Non-Return-to-Zero (NRZ) format (one Start bit, eight or nine data bits and one Stop bit). The most common data format is 8 bits. An on-chip dedicated  8-bit/16-bit  Baud  Rate  Generator  can  be used to derive standard baud rate frequencies from the oscillator.\nThe USART transmits and receives the LSb first. The USART's transmitter and receiver are functionally independent but use the same data format and baud rate. The Baud Rate Generator produces a clock, either x16 or x64 of the bit shift rate depending on the BRGH and BRG16 bits (TXSTA<2> and BAUDCON<3>). Parity is not supported by the hardware but can be implemented in software and stored as the 9th data bit.",
    "18.2 USART Asynchronous Mode\nAsynchronous  mode  is  available  in  all  low-power modes; it is available in Sleep mode only when autowake-up on sync break is enabled. When in PRI_IDLE mode, no changes to the Baud Rate Generator values are  required;  however,  other  low-power  mode  clocks may  operate  at  another  frequency  than  the  primary clock. Therefore, the Baud Rate Generator values may need to be adjusted.\nWhen operating in Asynchronous mode, the USART module consists of the following important elements:\n\u00b7 Baud Rate Generator\n\u00b7 Sampling Circuit\n\u00b7 Asynchronous Transmitter\n\u00b7 Asynchronous Receiver\n\u00b7 Auto-Wake-up on Sync Break Character\n\u00b7 12-bit Break Character Transmit\n\u00b7 Auto-Baud Rate Detection",
    "18.2.1 USART ASYNCHRONOUS TRANSMITTER\nThe  USART  transmitter  block  diagram  is  shown  in Figure 18-2. The heart of the transmitter is the Transmit (Serial) Shift register (TSR). The Shift register obtains its data from the read/write transmit buffer, TXREG. The TXREG register is loaded with data in software. The TSR register is not loaded until the Stop bit has been transmitted from the previous load. As soon as the Stop bit is transmitted, the TSR is loaded with new data from the TXREG register (if available).",
    "18.2.1 USART ASYNCHRONOUS TRANSMITTER\nOnce the TXREG register transfers the data to the TSR register  (occurs  in  one  TCY),  the  TXREG  register  is empty and flag bit TXIF (PIR1<4>) is set. This interrupt can be enabled/disabled by setting/clearing enable bit TXIE (PIE1<4>). Flag bit TXIF will be set regardless of the state of enable bit TXIE and cannot be cleared in software. Flag bit TXIF is not cleared immediately upon loading  the  Transmit  Buffer  register,  TXREG.  TXIF becomes valid in the second instruction cycle following the load instruction. Polling TXIF immediately following a load of TXREG will return invalid results.\nWhile flag bit TXIF indicates the status of the TXREG register,  another  bit,  TRMT  (TXSTA<1>),  shows  the status of the TSR register. Status bit TRMT is a readonly bit which is set when the TSR register is empty. No interrupt logic is tied to this bit, so the user has to poll this  bit  in  order  to  determine  if  the  TSR  register  is empty.",
    "18.2.1 USART ASYNCHRONOUS TRANSMITTER\nNote 1: The TSR register is not mapped in data memory so it is not available to the user.\n2: Flag bit TXIF is set when enable bit TXEN is set.\nTo set up an Asynchronous Transmission:\n1. Initialize the SPBRGH:SPBRG registers for the appropriate  baud  rate. Set  or  clear  the  BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit TXIE.\n4. If  9-bit transmission is desired, set transmit bit TX9. Can be used as address/data bit.\n5. Enable  the  transmission  by  setting  bit  TXEN which will also set bit TXIF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Load data to the TXREG  register (starts transmission).\nNote:, 1 = When BRGH and BRG16 bits are set, SPBRGH:SPBRG must be more than ' 1 '.",
    "18.2.1 USART ASYNCHRONOUS TRANSMITTER\nIf using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 18-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000.",
    "TABLE 18-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nPIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1,",
    "TABLE 18-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nBit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000x. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register. TXREG, Bit 5 = USART Transmit Register.",
    "TABLE 18-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nTXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on all other Resets = 0000. TXREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010.",
    "TABLE 18-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nBAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Value on POR, BOR = -1-1. BAUDCON, Value on POR, BOR = 0-00. BAUDCON, Value on all other Resets = -1-1. BAUDCON, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register, High Byte. SPBRGH,",
    "TABLE 18-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nBit 1 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register, High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register, Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000.",
    "TABLE 18-5: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nSPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented locations read as ' 0 '. Shaded cells are not used for asynchronous transmission.",
    "18.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\nThe receiver  block  diagram  is  shown  in  Figure 18-5. The data is received on the RC7/RX/DT pin and drives the  data  recovery  block.  The  data  recovery  block  is actually a high-speed shifter operating at x16 times the baud rate, whereas the main receive serial shifter operates  at  the  bit  rate  or  at  FOSC.  This  mode  would typically be used in RS-232 systems.\nTo set up an asynchronous reception:",
    "18.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate. Set or clear the BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit RCIE.\n4. If 9-bit reception is desired, set bit RX9.\n5. Enable the reception by setting bit CREN.\n6. Flag bit RCIF will be set when reception is complete and an interrupt will be generated if enable bit RCIE was set.\n7. Read the RCSTA register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n8. Read  the  8-bit  received  data  by  reading  the RCREG register.\n9. If any error occurred, clear the error by clearing enable bit CREN.\nThis mode would typically be used in RS-485 systems. To  set  up  an  asynchronous  reception  with  address detect enable:",
    "18.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize the SPBRGH:SPBRG registers for the appropriate  baud  rate. Set  or  clear  the  BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate..\n2. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n3. If interrupts are required, set the RCEN bit and select the desired priority level with the RCIP bit.\n4. Set the RX9 bit to enable 9-bit reception.\n5. Set the ADDEN bit to enable address detect.\n6. Enable reception by setting the CREN bit.\n7. The RCIF bit will be set when reception is complete. The interrupt will be Acknowledged if the RCIE and GIE bits are set.\n8. Read  the  RCSTA  register  to  determine  if  any error occurred during reception, as well as read bit 9 of data (if applicable).\n9. Read RCREG to determine if the device is being addressed.\n10. If any error occurred, clear the CREN bit.",
    "18.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n10. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.\n11. If  the  device  has  been  addressed,  clear  the ADDEN bit  to  allow  all  received  data  into  the receive buffer and interrupt the CPU.\nNote:, 1 = When BRGH and BRG16 bits are set, SPBRGH:SPBRG must be more than ' 1 '.",
    "PIC18F6585/8585/6680/8680\nTo set up an asynchronous transmission:\n1. Initialize the SPBRG register for the appropriate baud rate. If a high-speed baud rate is desired, set bit BRGH (see Section 18.1 'USART Baud Rate Generator (BRG)' ).\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit TXIE.\n5. Enable  the  transmission  by  setting  bit  TXEN which will also set bit TXIF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Load data to the TXREG  register (starts transmission).\nIf using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.\n- 4. If  9-bit transmission is desired, set transmit bit TX9. Can be used as address/data bit.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nPIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1,",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nBit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000x. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register. RCREG, Bit 5 = USART Receive Register.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nRCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on all other Resets = 0000. RCREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nBAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Value on POR, BOR = -1-1. BAUDCON, Value on POR, BOR = 0-00. BAUDCON, Value on all other Resets = -1-1. BAUDCON, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register, High Byte. SPBRGH,",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nBit 1 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register, High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register, Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nSPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend: x = unknown, - = unimplemented locations read as ' 0 '. Shaded cells are not used for asynchronous reception.",
    "18.2.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nDuring  Sleep  mode,  all  clocks  to  the  USART  are suspended. Because of this, the Baud Rate Generator is inactive and a proper byte reception cannot be performed. The auto-wake-up feature allows the controller to wake-up due to activity on the RX/DT line while the USART is operating in Asynchronous mode.\nand  cause  data  or  framing  errors.  To  work  properly, therefore, the initial character in the transmission must be all ' 0 's. This can be 00h (8 bytes) for standard RS-232 devices or 000h (12 bits) for LIN bus.\nThe  auto-wake-up  feature  is  enabled  by  setting  the WUE bit (BAUDCON<1>). Once set, the typical receive sequence  on  RX/DT  is  disabled  and  the  USART remains in an Idle state monitoring for a wake-up event independent of the CPU mode. A wake-up event consists of a high-to-low transition on the RX/DT line. (This coincides with the start of a sync break or a wake-up signal character for the LIN protocol.)",
    "18.2.4 AUTO-WAKE-UP ON SYNC BREAK CHARACTER\nFollowing a wake-up event, the module generates an RCIF  interrupt.  The  interrupt  is  generated  synchronously  to  the  Q  clocks  in  normal  operating  modes (Figure 18-7)  and  asynchronously,  if  the  device  is  in Sleep  mode  (Figure 18-8).  The  interrupt  condition  is cleared by reading the RCREG register.\nThe WUE bit is automatically cleared once a low-tohigh transition is observed on the RX line following the wake-up event. At this point, the USART module is in Idle mode and returns to normal operation. This signals to the user that the sync break event is over.",
    "18.2.4.1 Special Considerations Using Auto-Wake-up\nSince  auto-wake-up  functions  by  sensing  rising  edge transitions on RX/DT, information with any state changes before the Stop bit may signal a false end-of-character\nOscillator start-up time must  also be  considered, especially in applications using oscillators with longer start-up intervals (i.e., XT or HS mode). The sync break (or  wake-up  signal)  character  must  be  of  sufficient length and be followed by a sufficient interval to allow enough  time  for  the  selected  oscillator  to  start  and provide proper initialization of the USART.",
    "18.2.4.2 Special Considerations Using the WUE Bit\nThe timing of WUE and RCIF events may cause some confusion when it comes to determining the validity of received data. As noted, setting the WUE bit places the USART in an Idle mode. The wake-up event causes a receive interrupt by setting the RCIF bit. The WUE bit is  cleared  after  this  when  a  rising  edge  is  seen  on RX/DT. The interrupt condition is then cleared by reading the RCREG register. Ordinarily, the data in RCREG will be dummy data and should be discarded.\nThe fact that the WUE bit has been cleared (or is still set) and the RCIF flag is set should not be used as an indicator of the integrity of the data in RCREG. Users should  consider  implementing  a  parallel  method  in firmware to verify received data integrity.\nTo assure that no actual data is lost, check the RCIDL bit to verify that a receive operation is not in process. If a receive operation is not occurring, the WUE bit may then be set just prior to entering the Sleep mode.\nFIGURE 18-7:\nAUTO-WAKE-UP BIT (WUE) TIMINGS DURING NORMAL OPERATION",
    "FIGURE 18-8: AUTO-WAKE-UP BIT (WUE) TIMINGS DURING SLEEP\nNote 1: If the wake-up event requires long oscillator warm-up time, the auto-clear of the WUE bit can occur while the stposc signal is still active. This sequence should not depend on the presence of Q clocks.\n- 2: The USART remains in Idle while the WUE bit is set.",
    "18.2.5.1 Break and Sync Transmit Sequence\nThe  enhanced  USART  module  has  the  capability  of sending  the  special  break  character  sequences  that are required by the LIN bus standard. The break character transmit consists of a Start bit, followed by twelve ' 0 ' bits and a Stop bit. The frame break character is sent whenever the SENDB and TXEN bits (TXSTA<3> and TXSTA<5>) are set while the Transmit Shift register is loaded with data. Note that the value of data written to TXREG will be ignored and all ' 0 's will be transmitted.\nThe SENDB bit is automatically reset by hardware after the corresponding Stop bit is sent. This allows the user to preload the transmit FIFO with the next transmit byte following the break character (typically, the sync character in the LIN specification).\nNote that the data value written to the TXREG for the break character is ignored. The write simply serves the purpose of initiating the proper sequence.\nThe TRMT bit indicates when the transmit operation is active or Idle, just as it does during normal transmission.  See  Figure 18-9  for  the  timing  of  the  break character sequence.",
    "18.2.5.1 Break and Sync Transmit Sequence\nThe  following  sequence  will  send  a  message  frame header made up of a break, followed by an auto-baud sync byte. This sequence is typical of a LIN bus master.\n1. Configure the USART for the desired mode.\n2. Set  the  TXEN  and  SENDB  bits  to  set  up  the break character.\n3. Load  the  TXREG  with  a  dummy  character  to initiate transmission (the value is ignored).\n4. Write '55h' to TXREG to load the sync character into the transmit FIFO buffer.\n5. After the break has been sent, the SENDB bit is reset  by  hardware.  The  sync  character  now transmits in the preconfigured mode.\nWhen the TXREG becomes empty, as indicated by the TXIF, the next data byte can be written to TXREG.",
    "18.2.6 RECEIVING A BREAK CHARACTER\nThe  enhanced  USART  module  can  receive  a  break character in two ways.\nThe first method forces the configuration of the baud rate  at  a  frequency  of  9/13  the  typical  speed.  This allows  for  the  Stop  bit  transition  to  be  at  the  correct sampling location (13 bits for break versus Start bit and 8 data bits for typical data).\nThe  second  method  uses  the  auto-wake-up  feature described in Section 18.2.4 'Auto-Wake-up on Sync Break  Character' . By  enabling this feature, the USART will sample the next two transitions on    RX/DT, cause an RCIF interrupt, and receive the next data byte followed by another interrupt.\nNote that following a break character, the user will typically want to enable the auto-baud rate detect feature. For both methods, the user can set the ABD bit once the TXIF interrupt is observed.",
    "18.3 USART Synchronous Master Mode\nThe Synchronous Master mode is entered by setting the CSRC bit (TXSTA<7>). In this mode, the data is transmitted in a half-duplex manner (i.e., transmission and reception do not occur at the same time). When transmitting  data,  the  reception  is  inhibited  and  vice versa.  Synchronous  mode  is  entered  by  setting  bit SYNC  (TXSTA<4>).  In  addition,  enable  bit,  SPEN (RCSTA<7>), is set in order to configure the RC6/TX/CK and RC7/RX/DT I/O pins to CK (clock) and DT (data) lines, respectively.",
    "18.3 USART Synchronous Master Mode\nOnce the TXREG register transfers the data to the TSR register (occurs in one TCYCLE), the TXREG is empty and interrupt bit TXIF (PIR1<4>) is set. The interrupt can be enabled/disabled by setting/clearing enable bit, TXIE (PIE1<4>). Flag bit TXIF will be set regardless of the state of enable bit TXIE and cannot be cleared in software. It will reset only when new data is loaded into the TXREG register.\nThe Master mode indicates that the processor transmits the master clock on the CK line. Clock polarity is selected  with  the  SCKP  bit  (BAUDCON<5>);  setting SCKP sets the Idle state on CK as high, while clearing the bit sets the Idle state as low. This option is provided to support Microwire devices with this module.",
    "18.3.1 USART SYNCHRONOUS MASTER TRANSMISSION\nWhile flag bit TXIF indicates the status of the TXREG register, another bit, TRMT (TXSTA<1>), shows the status of the TSR register. TRMT is a read-only bit which is set when the TSR is empty. No interrupt logic is tied to this bit so the user must poll this bit in order to determine if the TSR register is empty. The TSR is not mapped in data memory so it is not available to the user.\nTo set up a synchronous master transmission:\n- 1. Initialize the SPBRGH:SPBRG registers for the appropriate  baud  rate. Set  or  clear  the  BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.",
    "18.3.1 USART SYNCHRONOUS MASTER TRANSMISSION\nThe  USART  transmitter  block  diagram  is  shown  in Figure 18-2. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The Shift register obtains its data from the Read/Write Transmit Buffer register, TXREG.  The  TXREG  register  is  loaded  with  data  in software. The TSR register is not loaded until the last bit  has  been  transmitted  from  the  previous  load.  As soon as the last bit is transmitted, the TSR is loaded with new data from the TXREG (if available).\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN and CSRC.\n3. If interrupts are desired, set enable bit TXIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable the transmission by setting bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREG register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 18-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 0000. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 0000. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000.",
    "TABLE 18-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nPIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1,",
    "TABLE 18-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nBit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000x. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register. TXREG, Bit 5 = USART Transmit Register.",
    "TABLE 18-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nTXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on all other Resets = 0000. TXREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010.",
    "TABLE 18-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nBAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Value on POR, BOR = -1-0. BAUDCON, Value on POR, BOR = 0-00. BAUDCON, Value on all other Resets = -1-0. BAUDCON, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register, High Byte. SPBRGH,",
    "TABLE 18-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nBit 1 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register, High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register, Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000.",
    "TABLE 18-7: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nSPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, -= unimplemented, read as ' 0 '. Shaded cells are not used for synchronous master transmission.",
    "18.3.2 USART SYNCHRONOUS MASTER RECEPTION\nOnce  Synchronous  mode  is  selected,  reception  is enabled by setting either the Single Receive Enable bit, SREN  (RCSTA<5>), or the Continuous Receive Enable bit, CREN (RCSTA<4>). Data is sampled on the RC7/RX/DT pin on the falling edge of the clock.\nIf enable bit SREN is set, only a single word is received. If enable bit CREN is set, the reception is continuous until CREN is cleared. If both bits are set, then CREN takes precedence.\nTo set up a synchronous master reception:",
    "18.3.2 USART SYNCHRONOUS MASTER RECEPTION\n1. Initialize the SPBRGH:SPBRG registers for the appropriate baud rate. Set or clear the BRGH and  BRG16  bits,  as  required,  to  achieve  the desired baud rate.\n3. Ensure bits CREN and SREN are clear.\n4. If interrupts are desired, set enable bit RCIE.\n5. If 9-bit reception is desired, set bit RX9.\n6. If  a  single  reception is required, set bit SREN. For continuous reception, set bit CREN.\n7. Interrupt flag bit RCIF will be set when reception is complete and an interrupt will be generated if the enable bit RCIE was set.\n8. Read the RCSTA register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n9. Read  the  8-bit  received  data  by  reading  the RCREG register.\n10. If any error occurred, clear the error by clearing bit CREN.\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN and CSRC.",
    "18.3.2 USART SYNCHRONOUS MASTER RECEPTION\n11. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 18-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 0000. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 0000. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000.",
    "TABLE 18-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nPIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1,",
    "TABLE 18-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nBit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000x. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register. RCREG, Bit 5 = USART Receive Register.",
    "TABLE 18-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nRCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on all other Resets = 0000. RCREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010.",
    "TABLE 18-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nBAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Value on POR, BOR = -1-0. BAUDCON, Value on POR, BOR = 0-00. BAUDCON, Value on all other Resets = -1-0. BAUDCON, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register, High Byte. SPBRGH,",
    "TABLE 18-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nBit 1 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register, High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register, Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000.",
    "TABLE 18-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nSPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend: x = unknown, -= unimplemented, read as ' 0 '. Shaded cells are not used for synchronous master reception.",
    "18.4 USART Synchronous Slave Mode\nSynchronous  Slave  mode  is  entered  by  clearing  bit CSRC  (TXSTA<7>). This mode differs from the Synchronous Master mode in that the shift clock is supplied externally at the RC6/TX/CK pin (instead of being supplied  internally  in  Master  mode).  This  allows  the device to transfer or receive data while in any low-power mode.",
    "18.4.1 USART SYNCHRONOUS SLAVE TRANSMIT\nThe operation of the Synchronous Master and Slave modes are identical  except in  the  case  of  the  Sleep mode.\nIf  two  words  are  written  to  the  TXREG  and  then  the SLEEP instruction is executed, the following will occur:\na) The  first  word  will  immediately  transfer  to  the TSR register and transmit.\nb) The second word will remain in TXREG register.\nc) Flag bit TXIF will not be set.\nd) When the first word has been shifted out of TSR, the TXREG register will transfer the second word to the TSR and flag bit TXIF will now be set.\ne) If enable bit TXIE is set, the interrupt will wake the  chip  from  Sleep.  If  the  global  interrupt  is enabled, the program will branch to the interrupt vector.",
    "TABLE 18-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000.",
    "TABLE 18-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nPIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1,",
    "TABLE 18-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nBit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000x. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register. TXREG, Bit 5 = USART Transmit Register.",
    "TABLE 18-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nTXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on all other Resets = 0000. TXREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010.",
    "TABLE 18-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nBAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Value on POR, BOR = -1-1. BAUDCON, Value on POR, BOR = 0-00. BAUDCON, Value on all other Resets = -1-1. BAUDCON, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register, High Byte. SPBRGH,",
    "TABLE 18-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nBit 1 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register, High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register, Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000.",
    "TABLE 18-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nSPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, -= unimplemented, read as ' 0 '. Shaded cells are not used for synchronous slave transmission.\nTo set up a synchronous slave transmission:\n1. Enable  the  synchronous  slave  serial  port  by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. Clear bits CREN and SREN.\n3. If interrupts are desired, set enable bit TXIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable  the  transmission  by  setting  enable  bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREG register.\n8. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "18.4.2 USART SYNCHRONOUS SLAVE RECEPTION\nTo set up a synchronous slave reception:\nThe operation of the Synchronous Master and Slave modes is identical, except in the case of Sleep or any Idle  mode  and  bit  SREN,  which  is  a  'don't  care'  in Slave mode.\nIf  receive is enabled by setting the CREN bit prior to entering Sleep or any Idle mode, then a word may be received while in this low-power mode. Once the word is received, the RSR register will transfer the data to the RCREG register; if the RCIE enable bit is set, the interrupt  generated  will  wake  the  chip  from  low-power mode. If the global interrupt is enabled, the program will branch to the interrupt vector.",
    "18.4.2 USART SYNCHRONOUS SLAVE RECEPTION\n1. Enable  the  synchronous  master  serial  port  by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. If interrupts are desired, set enable bit RCIE.\n3. If 9-bit reception is desired, set bit RX9.\n4. To enable reception, set enable bit CREN.\n5. Flag  bit  RCIF  will  be  set  when  reception  is complete.  An  interrupt will be  generated  if enable bit RCIE was set.\n6. Read the RCSTA register to get the 9th bit (if enabled)  and  determine  if  any  error  occurred during reception.\n7. Read  the  8-bit  received  data  by  reading  the RCREG register.\n8. If any error occurred, clear the error by clearing bit CREN.\n9. If using interrupts, ensure that the GIE and PEIE bits in the INTCON register (INTCON<7:6>) are set.",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 0000. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 0000. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000.",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nPIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1,",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nBit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000x. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register. RCREG, Bit 5 = USART Receive Register.",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nRCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on all other Resets = 0000. RCREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = SENDB. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = 0010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = 0010.",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nBAUDCON, Bit 7 = -. BAUDCON, Bit 6 = RCIDL. BAUDCON, Bit 5 = -. BAUDCON, Bit 4 = SCKP. BAUDCON, Bit 3 = BRG16. BAUDCON, Bit 2 = -. BAUDCON, Bit 1 = WUE. BAUDCON, Bit 0 = ABDEN. BAUDCON, Value on POR, BOR = -1-0. BAUDCON, Value on POR, BOR = 0-00. BAUDCON, Value on all other Resets = -1-0. BAUDCON, Value on all other Resets = 0-00. SPBRGH, Bit 7 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 6 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 5 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 4 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 3 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 2 = Baud Rate Generator Register, High Byte. SPBRGH,",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nBit 1 = Baud Rate Generator Register, High Byte. SPBRGH, Bit 0 = Baud Rate Generator Register, High Byte. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on POR, BOR = 0000. SPBRGH, Value on all other Resets = 0000. SPBRGH, Value on all other Resets = 0000. SPBRG, Bit 7 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 6 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 5 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 4 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 3 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 2 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 1 = Baud Rate Generator Register, Low Byte. SPBRG, Bit 0 = Baud Rate Generator Register, Low Byte. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000.",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nSPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous slave reception.",
    "19.0 10-BIT ANALOG-TO-DIGITAL CONVERTER (A/D) MODULE\nThe Analog-to-Digital (A/D) converter module has 12 inputs for the PIC18F6X8X devices and 16 inputs for the PIC18F8X8X devices. This module allows conversion of an analog input signal to a corresponding 10-bit digital number.\nA new feature for the A/D converter is the addition of programmable acquisition time. This feature allows the user to select a new channel for conversion and to set the GO/DONE bit immediately. When the GO/DONE bit is set, the selected channel is sampled for the programmed  acquisition  time  before  a  conversion  is actually  started.  This  removes  the  firmware  overhead that may have been required to allow for an acquisition (sampling) period (see Register 19-3 and Section 19.4 'Selecting the A/D Conversion Clock' ).\nThe module has five registers:\n\u00b7 A/D Result High Register (ADRESH)\n\u00b7 A/D Result Low Register (ADRESL)\n\u00b7 A/D Control Register 0 (ADCON0)\n\u00b7 A/D Control Register 1 (ADCON1)\n\u00b7 A/D Control Register 2 (ADCON2)",
    "19.0 10-BIT ANALOG-TO-DIGITAL CONVERTER (A/D) MODULE\nThe ADCON0 register, shown in Register 19-1, controls the operation of the A/D module. The ADCON1 register, shown in Register 19-2, configures the functions of the port pins. The ADCON2 register, shown  in  Register 19-3,  configures  the  A/D  clock source, programmed acquisition time and justification.",
    "REGISTER 19-1: ADCON0 REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = CHS3. -, 3 = CHS2. -, 4 = CHS1. -, 5 = CHS0. -, 6 = GO/DONE. -, 7 = ADON\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as ' 0 '",
    "bit 5-2 CHS3:CHS0: Analog Channel Select bits\n0000 = Channel 0 (AN0)\n0001 = Channel 1 (AN1)\n0010 = Channel 2 (AN2)\n0011 = Channel 3 (AN3)\n0100 = Channel 4 (AN4)\n0101 = Channel 5 (AN5)\n0110 = Channel 6 (AN6)\n0111 = Channel 7 (AN7)\n1000 = Channel 8 (AN8)\n1001 = Channel 9 (AN9)\n1010 = Channel 10 (AN10)\n1011 = Channel 11 (AN11)\n1100 = Channel 12 (AN12) (1)\n1101 = Channel 13 (AN13) (1)\n1110 = Channel 14 (AN14) (1)\n1111 = Channel 15 (AN15) (1)",
    "bit 1 GO/DONE:\nA/D Conversion Status bit",
    "When ADON = 1 :\n- 1 = A/D conversion in progress. This bit is automatically cleared when the A/D conversion is complete.\n0 = A/D Idle",
    "bit 0 ADON: A/D On bit\n1 = A/D converter module is enabled\n0 = A/D converter module is disabled and consumes no current\nNote 1: These channels are only available on PIC18F8X8X devices.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "ADCON1 REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = VCFG1. -, 3 = VCFG0. -, 4 = PCFG3. -, 5 = PCFG2. -, 6 = PCFG1. -, 7 = PCFG0\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5-4 VCFG1:VCFG0: Voltage Reference Configuration bits",
    "ADCON1 REGISTER\n00, A/D VREF+ = AVDD. 00, A/D VREF- = AVSS. 01, A/D VREF+ = External VREF+. 01, A/D VREF- = AVSS. 10, A/D VREF+ = AVDD. 10, A/D VREF- = External VREF-. 11, A/D VREF+ = External VREF+. 11, A/D VREF- = External VREF-",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\n0000, AN15 = A. 0000, AN14 = A. 0000, AN13 = A. 0000, AN12 = A. 0000, AN11 = A. 0000, AN10 = A. 0000, AN9 = A. 0000, AN8 = A. 0000, AN7 = A. 0000, AN6 = A. 0000, AN5 = A. 0000, AN4 = A. 0000, AN3 = A. 0000, AN2 = A. 0000, AN1 = A. 0000, AN0 = A. 0001, AN15 = D. 0001, AN14 = D. 0001, AN13 = A. 0001, AN12 = A. 0001, AN11 = A. 0001, AN10 = A. 0001, AN9 = A. 0001, AN8 = A. 0001, AN7 = A. 0001, AN6 = A. 0001, AN5 = A. 0001, AN4 = A. 0001, AN3 = A. 0001,",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\nAN2 = A. 0001, AN1 = A. 0001, AN0 = A. 0010, AN15 = D. 0010, AN14 = D. 0010, AN13 = D. 0010, AN12 = A. 0010, AN11 = A. 0010, AN10 = A. 0010, AN9 = A. 0010, AN8 = A. 0010, AN7 = A. 0010, AN6 = A. 0010, AN5 = A. 0010, AN4 = A. 0010, AN3 = A. 0010, AN2 = A. 0010, AN1 = A. 0010, AN0 = A. 0011, AN15 = D. 0011, AN14 = D. 0011, AN13 = D. 0011, AN12 = D. 0011, AN11 = A. 0011, AN10 = A. 0011, AN9 = A. 0011, AN8 = A. 0011, AN7 = A. 0011, AN6 = A. 0011, AN5 =",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\nA. 0011, AN4 = A. 0011, AN3 = A. 0011, AN2 = A. 0011, AN1 = A. 0011, AN0 = A. 0100, AN15 = D. 0100, AN14 = D. 0100, AN13 = D. 0100, AN12 = D. 0100, AN11 = D. 0100, AN10 = A. 0100, AN9 = A. 0100, AN8 = A. 0100, AN7 = A. 0100, AN6 = A. 0100, AN5 = A. 0100, AN4 = A. 0100, AN3 = A. 0100, AN2 = A. 0100, AN1 = A. 0100, AN0 = A. 0101, AN15 = D. 0101, AN14 = D. 0101, AN13 = D. 0101, AN12 = D. 0101, AN11 = D. 0101, AN10 = D. 0101, AN9 = A. 0101, AN8 = A.",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\n0101, AN7 = A. 0101, AN6 = A. 0101, AN5 = A. 0101, AN4 = A. 0101, AN3 = A. 0101, AN2 = A. 0101, AN1 = A. 0101, AN0 = A. 0110, AN15 = D. 0110, AN14 = D. 0110, AN13 = D. 0110, AN12 = D. 0110, AN11 = D. 0110, AN10 = D. 0110, AN9 = D. 0110, AN8 = A. 0110, AN7 = A. 0110, AN6 = A. 0110, AN5 = A. 0110, AN4 = A. 0110, AN3 = A. 0110, AN2 = A. 0110, AN1 = A. 0110, AN0 = A. 0111, AN15 = D. 0111, AN14 = D. 0111, AN13 = D. 0111, AN12 = D. 0111, AN11 = D. 0111,",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\nAN10 = D. 0111, AN9 = D. 0111, AN8 = D. 0111, AN7 = A. 0111, AN6 = A. 0111, AN5 = A. 0111, AN4 = A. 0111, AN3 = A. 0111, AN2 = A. 0111, AN1 = A. 0111, AN0 = A. 1000, AN15 = D. 1000, AN14 = D. 1000, AN13 = D. 1000, AN12 = D. 1000, AN11 = D. 1000, AN10 = D. 1000, AN9 = D. 1000, AN8 = D. 1000, AN7 = D. 1000, AN6 = A. 1000, AN5 = A. 1000, AN4 = A. 1000, AN3 = A. 1000, AN2 = A. 1000, AN1 = A. 1000, AN0 = A. 1001, AN15 = D. 1001, AN14 = D. 1001, AN13 = D. 1001, AN12 = D. 1001, AN11 =",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\nD. 1001, AN10 = D. 1001, AN9 = D. 1001, AN8 = D. 1001, AN7 = D. 1001, AN6 = D. 1001, AN5 = A. 1001, AN4 = A. 1001, AN3 = A. 1001, AN2 = A. 1001, AN1 = A. 1001, AN0 = A. 1010, AN15 = D. 1010, AN14 = D. 1010, AN13 = D. 1010, AN12 = D. 1010, AN11 = D. 1010, AN10 = D. 1010, AN9 = D. 1010, AN8 = D. 1010, AN7 = D. 1010, AN6 = D. 1010, AN5 = D. 1010, AN4 = A. 1010, AN3 = A. 1010, AN2 = A. 1010, AN1 = A. 1010, AN0 = A. 1011, AN15 = D. 1011, AN14 = D.",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\n1011, AN13 = D. 1011, AN12 = D. 1011, AN11 = D. 1011, AN10 = D. 1011, AN9 = D. 1011, AN8 = D. 1011, AN7 = D. 1011, AN6 = D. 1011, AN5 = D. 1011, AN4 = D. 1011, AN3 = A. 1011, AN2 = A. 1011, AN1 = A. 1011, AN0 = A. 1100, AN15 = D. 1100, AN14 = D. 1100, AN13 = D. 1100, AN12 = D. 1100, AN11 = D. 1100, AN10 = D. 1100, AN9 = D. 1100, AN8 = D. 1100, AN7 = D. 1100, AN6 = D. 1100, AN5 = D. 1100, AN4 = D. 1100, AN3 = D. 1100, AN2 = A. 1100, AN1 = A. 1100, AN0 = A. 1101, AN15 = D. 1101,",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\nAN14 = D. 1101, AN13 = D. 1101, AN12 = D. 1101, AN11 = D. 1101, AN10 = D. 1101, AN9 = D. 1101, AN8 = D. 1101, AN7 = D. 1101, AN6 = D. 1101, AN5 = D. 1101, AN4 = D. 1101, AN3 = D. 1101, AN2 = D. 1101, AN1 = A. 1101, AN0 = A. 1110, AN15 = D. 1110, AN14 = D. 1110, AN13 = D. 1110, AN12 = D. 1110, AN11 = D. 1110, AN10 = D. 1110, AN9 = D. 1110, AN8 = D. 1110, AN7 = D. 1110, AN6 = D. 1110, AN5 = D. 1110, AN4 = D. 1110, AN3 = D. 1110, AN2 = D. 1110, AN1 =",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\nD. 1110, AN0 = A. 1111, AN15 = D. 1111, AN14 = D. 1111, AN13 = D. 1111, AN12 = D. 1111, AN11 = D. 1111, AN10 = D. 1111, AN9 = D. 1111, AN8 = D. 1111, AN7 = D. 1111, AN6 = D. 1111, AN5 = D. 1111, AN4 = D. 1111, AN3 = D. 1111, AN2 = D. 1111, AN1 = D. 1111, AN0 = D\nA = Analog input\nD = Digital I/O\nShaded cells = Additional channels available on the PIC18F8X8X devices",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nNote:\nChannels AN15 through AN12 are not available on the 68-pin devices.",
    "ADCON2 REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. ADFM, 1 = -. ADFM, 2 = ACQT2. ADFM, 3 = ACQT1. ADFM, 4 = ACQT0. ADFM, 5 = ADCS2. ADFM, 6 = ADCS1. ADFM, 7 = ADCS0\nbit 7\nbit 0\nADFM: A/D Result Format Select bit\n1 = Right justified\n0 = Left justified bit 6 Unimplemented: Read as ' 0 '\nbit 5-3\nACQT2:ACQT0: A/D Acquisition Time Select bits\n000 = 0 TAD (1)\n001 = 2 TAD\n010 = 4 TAD\n011 = 6 TAD\n100 = 8 TAD\n101 = 12 TAD\n110 = 16 TAD\n111 = 20 TAD",
    "bit 2-0 ADCS2:ADCS0: A/D Conversion Clock Select bits\n000 = FOSC/2\n001 = FOSC/8\n010 = FOSC/32\n011 = FRC (clock derived from A/D RC oscillator) (1)\n100 = FOSC/4\n101 = FOSC/16\n110 = FOSC/64\n111 = FRC (clock derived from A/D RC oscillator) (1)\nNote 1: If the A/D FRC clock source is selected, a delay of one TCY (instruction cycle) is added before the A/D clock starts. This allows the SLEEP instruction to be executed before starting a conversion.",
    "bit 2-0 ADCS2:ADCS0: A/D Conversion Clock Select bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "PIC18F6585/8585/6680/8680\nThe analog reference voltage is software selectable to either the device's positive and negative supply voltage (AVDD and AVSS) or the voltage level on the RA3/AN3/ VREF+ and RA2/AN2/VREF- pins.\nA device Reset forces all registers to their Reset state. This forces the A/D module to be turned off and any conversion in progress is aborted.\nThe A/D converter has a unique feature of being able to operate while the device is in Sleep mode. To operate in Sleep, the A/D conversion clock must be derived from the A/D's internal RC oscillator.\nThe output of the sample and hold is the input into the converter  which  generates  the  result  via  successive approximation.",
    "PIC18F6585/8585/6680/8680\nEach port pin associated with the A/D converter can be configured as an analog input or as a digital I/O. The ADRESH and ADRESL registers contain the result of the A/D conversion. When the A/D conversion is complete, the result is loaded into the ADRESH/ADRESL registers,  the  GO/DONE  bit  (ADCON0  register)  is cleared and A/D interrupt flag bit ADIF is set. The block diagram of the A/D module is shown in Figure 19-1.\nThe  value  in  the  ADRESH/ADRESL  registers  is  not modified for a Power-on Reset. The ADRESH/ ADRESL registers will  contain  unknown  data  after  a Power-on Reset.",
    "PIC18F6585/8585/6680/8680\nAfter the A/D module has been configured as desired, the selected channel must be acquired before the conversion  is  started.  The  analog  input  channels  must have  their  corresponding  TRIS  bits  selected  as  an input. To determine acquisition time, see Section 19.1 'A/D Acquisition Requirements' .  After this acquisition  time  has  elapsed,  the  A/D  conversion  can  be started.  An  acquisition  time  can  be  programmed  to occur between setting the GO/DONE bit and the actual start of the conversion.\nThe following steps should be followed to do an A/D conversion:",
    "PIC18F6585/8585/6680/8680\n1. Configure the A/D module:\n\u00b7 Configure analog pins, voltage reference and digital I/O (ADCON1)\n\u00b7 Select A/D input channel (ADCON0)\n\u00b7 Select A/D acquisition time (ADCON2)\n\u00b7 Select A/D conversion clock (ADCON2)\n\u00b7 Turn on A/D module (ADCON0)\n2. Configure A/D interrupt (if desired):\n\u00b7 Clear ADIF bit\n\u00b7 Set ADIE bit\n\u00b7 Set GIE bit\n3. Wait the required acquisition time (if required).\n4. Start conversion:\n\u00b7 Set GO/DONE bit (ADCON0 register)\n5. Wait for A/D conversion to complete by either:\n\u00b7 Polling for the GO/DONE bit to be cleared or\n\u00b7 Waiting for the A/D interrupt\n6. Read A/D Result registers (ADRESH:ADRESL); clear bit ADIF if required.\n7. For next conversion, go to step 1 or step 2 as required.  The  A/D  conversion  time  per  bit  is defined  as  TAD.  A  minimum  wait  of  2  TAD  is required before next acquisition starts.",
    "19.2 A/D VREF+ and VREF- References\nFor the A/D converter to meet its specified accuracy, the charge holding capacitor (CHOLD) must be allowed to fully charge to the input channel voltage level. The analog  input  model  is  shown  in  Figure 19-2.  The source  impedance  (RS)  and  the  internal  sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD. The sampling switch (RSS) impedance varies over the device voltage (VDD). The source impedance affects the offset voltage at the analog input (due to pin leakage current). The maximum  recommended  impedance  for  analog sources is 2.5 k \uf057 .  After  the  analog input channel is selected  (changed),  this  acquisition  must  be  done before the conversion can be started.\nNote:, 1 = When the conversion is started, the holding capacitor is disconnected from the input pin.\nTo calculate the minimum acquisition time, Equation 19-1  may  be  used.  This  equation  assumes that 1/2 LSb error is used (1024 steps for the A/D). The 1/2 LSb error is the maximum error allowed for the A/D to meet its specified resolution.",
    "19.2 A/D VREF+ and VREF- References\nExample 19-1  shows  the  calculation  of  the  minimum required acquisition time, TACQ. This calculation is based on the following application system assumptions:\nCHOLD\n= 120 pF\nRs\n= 2.5 k \uf057\uf020\nConversion Error\n\uf0a3 1/2 LSb\nVDD\n= 5V \uf0ae Rss = 7 k \uf057\nTemperature\n=\n50 C (system max.) \uf0b0\nVHOLD\n=\n0V @ time = 0",
    "EQUATION 19-1: ACQUISITION TIME\nTACQ, 1 = =. TACQ, 2 = Amplifier Settling Time + Holding Capacitor Charging Time + Temperature Coefficient. , 1 = =. , 2 = TAMP + TC + TCOFF",
    "EQUATION 19-2: A/D MINIMUM CHARGING TIME\nVHOLD or, 1 = =. VHOLD or, 2 = (V REF - (V REF /2048)) \u2022 (1 - e (-Tc/C HOLD(R IC + RSS + RS )). TC, 1 = =. TC, 2 = -(120 pF)(1 k \uf057 + RSS + RS) ln(1/2047)",
    "EXAMPLE 19-1: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\nTACQ, 1 = =. TACQ, 2 = TAMP + TC + TCOFF. Temperature coefficient is only required for temperatures > 25 \uf0b0 C., 1 = Temperature coefficient is only required for temperatures > 25 \uf0b0 C.. Temperature coefficient is only required for temperatures > 25 \uf0b0 C., 2 = Temperature coefficient is only required for temperatures > 25 \uf0b0 C.. TACQ, 1 = =. TACQ, 2 = 2 \uf06d s + TC + [(Temp - 25 \uf0b0 C)(0.05 \uf06d s/ \uf0b0 C)]. TC, 1 = =. TC, 2 = -C HOLD (R IC + RSS + RS) ln(1/2047) -120 pF (1 k \uf057 + 7 k \uf057 + 2.5 k \uf057 ) ln(0.0004885) -120 pF (10.5 k \uf057 ) ln(0.0004885) -1.26 \uf06d s (-7.6241) 9.61 \uf06d s. TACQ, 1 = =. TACQ, 2 = 2 \uf06d s + 9.61 \uf06d s + [(50 \uf0b0 C - 25 \uf0b0 C)(0.05 \uf06d s/ \uf0b0 C)] 11.61 \uf06d s",
    "EXAMPLE 19-1: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\n+ 1.25 \uf06d s 12.86 \uf06d s\nIf  external  voltage  references  are  used  instead  of  the internal AVDD and AVSS sources, the source impedance of the VREF+ and VREF- voltage sources must be considered.  During  acquisition,  currents  supplied  by  these sources are insignificant. However, during conversion, the A/D module sinks and sources current through the reference sources. The effect of this current, as specified in parameter A50, along with source impedance must be considered to meet specified A/D resolution.",
    "Note:\nWhen  using  external  voltage  references with the A/D converter, the source imped- ance  of  the  external  voltage  references must be less than 20 \uf057\uf020 to obtain the spec- ified A/D resolution. Higher reference source  impedances  will  increase  both offset  and  gain  errors.  Resistive  voltage dividers will not provide a sufficiently low source impedance.\nTo maintain the best possible performance in  A/D  conversions,  external  VREF  inputs should  be  buffered  with  an  operational amplifier  or  other  low  output  impedance circuit.",
    "19.3 Selecting and Configuring Automatic Acquisition Time\nThe  ADCON2  register  allows  the  user  to  select  an acquisition time that occurs each time the GO/DONE bit is set.\nWhen the GO/DONE bit is set, sampling is stopped and a conversion begins. The user is responsible for ensuring the required acquisition time has passed between selecting  the  desired  input  channel  and  setting  the GO/DONE bit. This occurs when the ACQT2:ACQT0 bits (ADCON2<5:3>) remain in their Reset state (' 000 ') and  is compatible  with  devices  that  do  not  offer programmable acquisition times.\nIf  desired,  the  ACQT bits can be set to select a programmable acquisition time for the A/D module. When the GO/DONE bit is set, the A/D module continues to sample the input for the selected acquisition time, then automatically begins a conversion. Since the acquisition time is programmed, there may be no need to wait for an acquisition time between selecting a channel and setting the GO/DONE bit.",
    "19.3 Selecting and Configuring Automatic Acquisition Time\nIn either case, when the conversion is completed, the GO/DONE bit is cleared, the ADIF flag is set, and the A/D  begins  sampling  the  currently  selected  channel again. If an acquisition time  is  programmed,  there  is nothing to indicate if the acquisition time has ended or if the conversion has begun.",
    "19.4 Selecting the A/D Conversion Clock\nThe A/D conversion time per bit is defined as TAD. The A/D conversion requires 11 TAD per 10-bit conversion. The  source  of  the  A/D  conversion  clock  is  software selectable. There are seven possible options for TAD:\n\u00b7 2 TOSC\n\u00b7 4 TOSC\n\u00b7 8 TOSC\n\u00b7 32 TOSC\n\u00b7 16 TOSC\n\u00b7 64 TOSC\n\u00b7 Internal RC Oscillator\nFor correct A/D conversions, the A/D conversion clock (TAD) must be as short as possible but greater than the minimum TAD (approximately 2 \uf06d s, see parameter 130 for more information).\nTable 19-1 shows the resultant TAD times derived from the  device  operating  frequencies  and  the  A/D  clock source selected.",
    "19.5 Configuring Analog Port Pins\nThe ADCON1, TRISA, TRISF and TRISH registers control  the  operation  of  the  A/D  port  pins.  The  port  pins needed as analog inputs must have their corresponding TRIS bits set (input). If the TRIS bit is cleared (output), the digital output level (VOH or VOL) will be converted.\nThe A/D operation is independent of the state of the CHS3:CHS0 bits and the TRIS bits.\nNote 1: When reading the port  register,  all  pins configured as analog input channels will read as cleared (a low level). Pins configured  as  digital inputs  will convert  an analog input. Analog levels on a digitally configured input will not affect the conversion accuracy.\n2: Analog levels on any pin defined as a digital  input  may  cause  the  input  buffer  to consume  current out of the device's specification limits.",
    "TABLE 19-1: TAD vs. DEVICE OPERATING FREQUENCIES\n2 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 000. 2 T OSC, Maximum Device Frequency.PIC18FXX80/XX85 = 1.25 MHz. 2 T OSC, Maximum Device Frequency.PIC18LFXX80/XX85 = 666 kHz. 4 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 100. 4 T OSC, Maximum Device Frequency.PIC18FXX80/XX85 = 2.50 MHz. 4 T OSC, Maximum Device Frequency.PIC18LFXX80/XX85 = 1.33 MHz. 8 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 001. 8 T OSC, Maximum Device Frequency.PIC18FXX80/XX85 = 5.00 MHz. 8 T OSC, Maximum Device Frequency.PIC18LFXX80/XX85 = 2.66 MHz. 16 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 101. 16 T OSC, Maximum Device",
    "TABLE 19-1: TAD vs. DEVICE OPERATING FREQUENCIES\nFrequency.PIC18FXX80/XX85 = 10.0 MHz. 16 T OSC, Maximum Device Frequency.PIC18LFXX80/XX85 = 5.33 MHz. 32 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 010. 32 T OSC, Maximum Device Frequency.PIC18FXX80/XX85 = 20.0 MHz. 32 T OSC, Maximum Device Frequency.PIC18LFXX80/XX85 = 10.65 MHz. 64 T OSC, AD Clock Source (T AD).ADCS2:ADCS0 = 110. 64 T OSC, Maximum Device Frequency.PIC18FXX80/XX85 = 40.0 MHz. 64 T OSC, Maximum Device Frequency.PIC18LFXX80/XX85 = 21.33 MHz. RC (3), AD Clock Source (T AD).ADCS2:ADCS0 = x11. RC (3), Maximum Device Frequency.PIC18FXX80/XX85 = 1.00 MHz (1). RC (3), Maximum Device Frequency.PIC18LFXX80/XX85",
    "TABLE 19-1: TAD vs. DEVICE OPERATING FREQUENCIES\n= 1.00 MHz (2)\nNote 1: The RC source has a typical TAD time of 4 \uf06d s.\n2: The RC source has a typical TAD time of 6 \uf06d s.\n3: For device frequencies above 1 MHz, the device must be in Sleep for the entire conversion or the A/D accuracy may be out of specification.",
    "19.7 Use of the CCP2 Trigger\nFigure 19-3 shows the operation of the A/D converter after the GO bit has been set and the ACQT2:ACQT0 bits are cleared. A conversion is started after the following instruction to allow entry into Sleep mode before the conversion begins.\nFigure 19-4 shows the operation of the A/D converter after the GO bit has been set, the ACQT2:ACQT0 bits are set to ' 010 ' and selecting a 4 TAD acquisition time before the conversion starts.\nClearing  the  GO/DONE  bit  during  a  conversion  will abort the current conversion. The A/D Result register pair will not be updated with the partially completed A/D conversion sample. This means the ADRESH:ADRESL registers will  continue to contain the value of the last completed conversion (or the last value written to the ADRESH:ADRESL registers).\nAfter  the  A/D  conversion  is  completed  or  aborted,  a 2 TAD wait is required before the next acquisition can be started. After this wait, acquisition on the selected channel is automatically started.",
    "19.7 Use of the CCP2 Trigger\nAn A/D conversion can be started by the 'special event trigger'  of  the  CCP2  module.  This  requires  that  the CCP2M3:CCP2M0  bits  (CCP2CON<3:0>)  be  programmed as ' 1011 ' and that the A/D module is enabled (ADON  bit  is  set).  When  the  trigger  occurs,  the GO/DONE bit will be set, starting the A/D conversion and the Timer1 (or Timer3) counter will be reset to zero. Timer1 (or Timer3) is reset to automatically repeat the A/D acquisition period with minimal software overhead (moving  ADRESH/ADRESL  to  the  desired  location). The appropriate analog input channel must be selected and the minimum acquisition done before the 'special event trigger' sets the GO/DONE  bit (starts a conversion).\nIf the A/D module is not enabled (ADON is cleared), the 'special  event  trigger'  will  be  ignored  by  the  A/D module  but  will  still  reset  the  Timer1  (or  Timer3) counter.\nNote:\nThe GO/DONE bit should NOT be set in the same instruction that turns on the A/D.",
    "19.7 Use of the CCP2 Trigger\nFIGURE 19-3: A/D CONVERSION TAD CYCLES (ACQT<2:0> = 000 , TACQ = 0 )\nFIGURE 19-4: A/D CONVERSION TAD CYCLES   (ACQT<2:0> = 010 , TACQ = 4 TAD)",
    "TABLE 19-2: SUMMARY OF A/D REGISTERS\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 0000. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 0000. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000 0000. PIR1, Value on all other Resets =",
    "TABLE 19-2: SUMMARY OF A/D REGISTERS\n0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111 1111.",
    "TABLE 19-2: SUMMARY OF A/D REGISTERS\nIPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR, BOR = -0-0 0000. PIR2, Value on all other Resets = -0-0. PIR2, Value on all other Resets = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR,",
    "TABLE 19-2: SUMMARY OF A/D REGISTERS\nBOR = -0-0 0000. PIE2, Value on all other Resets = -0-0. PIE2, Value on all other Resets = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = CCP2IP. IPR2, Value on POR, BOR = -1-1 1111. IPR2, Value on all other Resets = -1-1. IPR2, Value on all other Resets = 1111. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2",
    "TABLE 19-2: SUMMARY OF A/D REGISTERS\n= A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte. ADRESH, Value on POR, BOR = xxxx xxxx. ADRESH, Value on all other Resets = uuuu. ADRESH, Value on all other Resets = uuuu. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Value on POR, BOR = xxxx xxxx. ADRESL, Value on all other Resets = uuuu. ADRESL, Value on all other Resets =",
    "TABLE 19-2: SUMMARY OF A/D REGISTERS\nuuuu. ADCON0, Bit 7 = -. ADCON0, Bit 6 = -. ADCON0, Bit 5 = CHS3. ADCON0, Bit 4 = CHS3. ADCON0, Bit 3 = CHS1. ADCON0, Bit 2 = CHS0. ADCON0, Bit 1 = GO/DONE. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR = --00 0000. ADCON0, Value on all other Resets = --00. ADCON0, Value on all other Resets = 0000. ADCON1, Bit 7 = -. ADCON1, Bit 6 = -. ADCON1, Bit 5 = VCFG1. ADCON1, Bit 4 = VCFG0. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = --00 0000. ADCON1,",
    "TABLE 19-2: SUMMARY OF A/D REGISTERS\nValue on all other Resets = --00. ADCON1, Value on all other Resets = 0000. ADCON2, Bit 7 = ADFM. ADCON2, Bit 6 = -. ADCON2, Bit 5 = -. ADCON2, Bit 4 = -. ADCON2, Bit 3 = -. ADCON2, Bit 2 = ADCS2. ADCON2, Bit 1 = ADCS1. ADCON2, Bit 0 = ADCS0. ADCON2, Value on POR, BOR = 0--- -000. ADCON2, Value on all other Resets = 0---. ADCON2, Value on all other Resets = -000. PORTA, Bit 7 = -. PORTA, Bit 6 = RA6. PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR = --xx xxxx. PORTA, Value on all",
    "TABLE 19-2: SUMMARY OF A/D REGISTERS\nother Resets = --uu. PORTA, Value on all other Resets = uuuu. TRISA, Bit 7 = - PORTA Data Direction Register. TRISA, Bit 6 = - PORTA Data Direction Register. TRISA, Bit 5 = - PORTA Data Direction Register. TRISA, Bit 4 = - PORTA Data Direction Register. TRISA, Bit 3 = - PORTA Data Direction Register. TRISA, Bit 2 = - PORTA Data Direction Register. TRISA, Bit 1 = - PORTA Data Direction Register. TRISA, Bit 0 = - PORTA Data Direction Register. TRISA, Value on POR, BOR = --11 1111. TRISA, Value on all other Resets = --11. TRISA, Value on all other Resets = 1111. PORTF, Bit 7 = RF7. PORTF, Bit 6 = RF6. PORTF, Bit 5 = RF5. PORTF, Bit 4 = RF4. PORTF, Bit 3 = RF3. PORTF, Bit 2 = RF2. PORTF, Bit 1 = RF1. PORTF, Bit 0 = RF0.",
    "TABLE 19-2: SUMMARY OF A/D REGISTERS\nPORTF, Value on POR, BOR = xxxx xxxx. PORTF, Value on all other Resets = uuuu. PORTF, Value on all other Resets = uuuu. LATF, Bit 7 = LATF7. LATF, Bit 6 = LATF6. LATF, Bit 5 = LATF5. LATF, Bit 4 = LATF4. LATF, Bit 3 = LATF3. LATF, Bit 2 = LATF2. LATF, Bit 1 = LATF1. LATF, Bit 0 = LATF0. LATF, Value on POR, BOR = xxxx xxxx. LATF, Value on all other Resets = uuuu. LATF, Value on all other Resets = uuuu. TRISF, Bit 7 = PORTF Data Direction Control Register. TRISF, Bit 6 = PORTF Data Direction Control Register. TRISF, Bit 5 = PORTF Data Direction Control Register. TRISF, Bit 4 = PORTF Data Direction Control Register. TRISF, Bit 3 = PORTF Data Direction Control Register. TRISF, Bit 2 = PORTF Data Direction",
    "TABLE 19-2: SUMMARY OF A/D REGISTERS\nControl Register. TRISF, Bit 1 = PORTF Data Direction Control Register. TRISF, Bit 0 = PORTF Data Direction Control Register. TRISF, Value on POR, BOR = 1111 1111. TRISF, Value on all other Resets = 1111. TRISF, Value on all other Resets = 1111. PORTH (1), Bit 7 = RH7. PORTH (1), Bit 6 = RH6. PORTH (1), Bit 5 = RH5. PORTH (1), Bit 4 = RH4. PORTH (1), Bit 3 = RH3. PORTH (1), Bit 2 = RH2. PORTH (1), Bit 1 = RH1. PORTH (1), Bit 0 = RH0. PORTH (1), Value on POR, BOR = xxxx xxxx. PORTH (1), Value on all other Resets = uuuu. PORTH (1), Value on all other Resets = uuuu. LATH (1), Bit 7 = LATH7. LATH",
    "TABLE 19-2: SUMMARY OF A/D REGISTERS\n(1), Bit 6 = LATH6. LATH (1), Bit 5 = LATH5. LATH (1), Bit 4 = LATH4. LATH (1), Bit 3 = LATH3. LATH (1), Bit 2 = LATH2. LATH (1), Bit 1 = LATH1. LATH (1), Bit 0 = LATH0. LATH (1), Value on POR, BOR = xxxx xxxx. LATH (1), Value on all other Resets = uuuu. LATH (1), Value on all other Resets = uuuu. TRISH (1), Bit 7 = PORTH Data Direction Control Register. TRISH (1), Bit 6 = PORTH Data Direction Control Register. TRISH (1), Bit 5 = PORTH Data Direction Control Register. TRISH (1), Bit 4 = PORTH Data Direction Control Register. TRISH (1), Bit 3 = PORTH Data Direction Control Register. TRISH (1), Bit 2 = PORTH Data Direction Control Register. TRISH (1),",
    "TABLE 19-2: SUMMARY OF A/D REGISTERS\nBit 1 = PORTH Data Direction Control Register. TRISH (1), Bit 0 = PORTH Data Direction Control Register. TRISH (1), Value on POR, BOR = 1111 1111. TRISH (1), Value on all other Resets = 1111. TRISH (1), Value on all other Resets = 1111\nLegend:\nx = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used for A/D conversion.\nNote 1: Only available on PIC18F8X8X devices.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "20.0 COMPARATOR MODULE\nThe comparator module contains two analog comparators. The  inputs to the comparators are multiplexed  with  the  RF1  through  RF6  pins.  The  onchip  voltage  reference  ( Section 21.0  'Comparator Voltage Reference Module' ) can also be an input to the comparators.\nThe CMCON register, shown in Register 20-1, controls the comparator input and output multiplexers. A block diagram  of  the  various  comparator  configurations  is shown in Figure 20-1.",
    "REGISTER 20-1: CMCON REGISTER\n, R-0 = C2OUT. , R-0 = C1OUT. , R/W-0 = C2INV. , R/W-0 = C1INV. , R/W-0 = CIS. , R/W-0 = CM2. , R/W-0 = CM1. , R/W-0 = CM0. , R-0 = bit 7. , R-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = bit 0. bit 7, R-0 = C2OUT : Comparator 2 Output bit When C2INV = 0 : 1 = C2 VIN + > C2 VIN - 0 = C2 VIN + < C2 VIN - When C2INV = 1 :. bit 7, R-0 = C2OUT : Comparator 2 Output bit When C2INV = 0 : 1 = C2 VIN + > C2 VIN - 0 = C2 VIN + < C2 VIN - When C2INV = 1 :. bit 7, R/W-0 =",
    "REGISTER 20-1: CMCON REGISTER\nC2OUT : Comparator 2 Output bit When C2INV = 0 : 1 = C2 VIN + > C2 VIN - 0 = C2 VIN + < C2 VIN - When C2INV = 1 :. bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 6, R-0 = C1OUT : Comparator 1 Output bit. bit 6, R-0 = C1OUT : Comparator 1 Output bit. bit 6, R/W-0 = C1OUT : Comparator 1 Output bit. bit 6, R/W-0 = . bit 6, R/W-0 = . bit 6, R/W-0 = . bit 6, R/W-0 = . bit 6, R/W-0 = . bit 5, R-0 = C2INV : Comparator 2 Output Inversion 1 = C2 output inverted. bit 5, R-0 = C2INV : Comparator 2 Output Inversion 1 = C2 output inverted. bit 5,",
    "REGISTER 20-1: CMCON REGISTER\nR/W-0 = C2INV : Comparator 2 Output Inversion 1 = C2 output inverted. bit 5, R/W-0 = bit. bit 5, R/W-0 = . bit 5, R/W-0 = . bit 5, R/W-0 = . bit 5, R/W-0 = . , R-0 = 0 = C2 output not inverted. , R-0 = 0 = C2 output not inverted. , R/W-0 = 0 = C2 output not inverted. , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . bit 4, R-0 = C1INV : Comparator 1 Output Inversion 1 = C1 output inverted 0 = C1 output not inverted. bit 4, R-0 = C1INV : Comparator 1 Output Inversion 1 = C1 output inverted 0 = C1 output not inverted. bit 4, R/W-0 = C1INV : Comparator 1 Output Inversion 1 = C1 output inverted 0 = C1 output not inverted. bit 4, R/W-0",
    "REGISTER 20-1: CMCON REGISTER\n= bit. bit 4, R/W-0 = . bit 4, R/W-0 = . bit 4, R/W-0 = . bit 4, R/W-0 = . bit 3, R-0 = CIS : Comparator Input Switch bit When CM2:CM0 = 110 : 1 = C1 VIN - connects to RF5/AN10 C2 VIN - connects to RF3/AN8 0 = C1 VIN - connects to RF6/AN11 C2 VIN - connects to RF4/AN9 CM2:CM0 : Comparator Mode bits. bit 3, R-0 = CIS : Comparator Input Switch bit When CM2:CM0 = 110 : 1 = C1 VIN - connects to RF5/AN10 C2 VIN - connects to RF3/AN8 0 = C1 VIN - connects to RF6/AN11 C2 VIN - connects to RF4/AN9 CM2:CM0 : Comparator Mode bits. bit 3, R/W-0 = CIS : Comparator Input Switch bit When CM2:CM0 = 110 : 1 = C1 VIN - connects to RF5/AN10 C2 VIN - connects to",
    "REGISTER 20-1: CMCON REGISTER\nRF3/AN8 0 = C1 VIN - connects to RF6/AN11 C2 VIN - connects to RF4/AN9 CM2:CM0 : Comparator Mode bits. bit 3, R/W-0 = . bit 3, R/W-0 = . bit 3, R/W-0 = . bit 3, R/W-0 = . bit 3, R/W-0 = . , R-0 = . , R-0 = . , R/W-0 = . , R/W-0 = bit is set. , R/W-0 = U = '0' = Bit. , R/W-0 = Unimplemented cleared. , R/W-0 = read x = Bit is. , R/W-0 = . , R-0 = Legend: R = Readable bit W=Writable. , R-0 = Legend: R = Readable bit W=Writable. , R/W-0 = Legend: R = Readable bit W=Writable. , R/W-0 = . , R/W-0 = . , R/W-0 = . ,",
    "REGISTER 20-1: CMCON REGISTER\nR/W-0 = bit, as. , R/W-0 = '0' unknown",
    "20.1 Comparator Configuration\nThere are eight modes of operation for the comparators.  The  CMCON  register  is  used  to  select  these modes. Figure 20-1 shows the eight possible modes. The TRISF register controls the data direction of the comparator  pins  for  each  mode.  If  the  Comparator mode is changed, the comparator output level may not be valid for the specified mode change delay shown in Section 27.0 'Electrical Characteristics' .\nNote:, 1 = Comparator interrupts should be disabled during a Comparator mode change. Otherwise, a false interrupt may occur.",
    "20.2 Comparator Operation\nA single comparator is shown in Figure 20-2, along with the  relationship  between  the  analog  input  levels  and the digital output. When the analog input at VIN+ is less than the analog input VIN-, the output of the comparator is a digital low level. When the analog input at VIN+ is greater  than  the  analog  input  VIN-,  the  output  of  the comparator is a digital high level. The shaded areas of the output of the comparator in Figure 20-2 represent the uncertainty due to input offsets and response time.",
    "20.3 Comparator Reference\nAn external or internal reference signal may be used depending  on  the  Comparator  Operating  mode.  The analog signal present at VIN- is compared to the signal at  VIN+  and  the  digital  output  of  the  comparator  is adjusted accordingly (Figure 20-2).\nFIGURE 20-2: SINGLE COMPARATOR",
    "20.3.1 EXTERNAL REFERENCE SIGNAL\nWhen  external voltage references are used, the comparator module can be configured to have the comparators operate from the same or different reference sources. However, threshold detector applications may require the same reference. The reference signal must be between VSS and VDD and can be applied to either pin of the comparator(s).",
    "20.3.2 INTERNAL REFERENCE SIGNAL\nThe comparator module also allows the selection of an internally generated voltage reference for the comparators. Section 21.0  'Comparator  Voltage  Reference Module' contains a detailed description of the comparator voltage reference module that provides this signal. The internal reference signal is used when comparators are in mode CM<2:0> = 110 (Figure 20-1). In this mode, the internal voltage reference is applied to the VIN+ pin of both comparators.",
    "20.4 Comparator Response Time\nResponse time is the minimum time, after selecting a new  reference  voltage  or  input  source,  before  the comparator  output  has  a  valid  level.  If  the  internal reference is changed, the maximum delay of the internal voltage reference must be considered when using the comparator  outputs.  Otherwise,  the  maximum delay of the comparators should be used ( Section 27.0 'Electrical Characteristics' ).",
    "20.5 Comparator Outputs\nThe comparator outputs are read through the CMCON register.  These  bits  are  read-only.  The  comparator outputs may also be directly output to the RF1 and RF2 I/O pins. When enabled, multiplexors in the output path of the RF1 and RF2 pins will switch and the output of each pin will be the unsynchronized output of the comparator. The uncertainty of each of the comparators is related to the input offset voltage and the response time given  in  the  specifications.  Figure 20-3  shows  the comparator output block diagram.\nThe TRISA bits will still function as an output enable/disable for the RF1 and RF2 pins while in this mode.\nThe polarity of the comparator outputs can be changed using the C2INV and C1INV bits (CMCON<4:5>).\nNote 1: When reading the Port register, all pins configured as analog inputs will read as a ' 0 '.  Pins  configured  as  digital  inputs  will convert an analog input according to the Schmitt Trigger input specification.\n2: Analog levels on any pin defined as a digital  input  may  cause  the  input  buffer  to consume more current than is specified.",
    "20.6 Comparator Interrupts\nNote:\nThe comparator interrupt flag is set whenever there is a  change  in  the  output  value  of  either  comparator. Software  will  need  to  maintain  information  about  the status of the output bits, as read from CMCON<7:6>, to determine the actual change that occurred. The CMIF bit (PIR registers) is the Comparator Interrupt Flag. The CMIF bit must be reset by clearing it to ' 0 '. Since it is also possible to write a ' 1 ' to this register, a simulated interrupt may be initiated.\nThe CMIE bit (PIE registers) and the PEIE bit (INTCON register) must be set to enable the interrupt. In addition, the GIE bit must also be set. If any of these bits are clear, the interrupt is not enabled, though the CMIF bit will still be set if an interrupt condition occurs.\nIf a change in the CMCON  register (C1OUT or C2OUT) should occur when a read operation is being executed (start of the Q2 cycle), then the CMIF (PIR registers) interrupt flag may not get set.\nThe user, in the Interrupt Service Routine, can clear the interrupt in the following manner:",
    "20.6 Comparator Interrupts\na) Any  read  or  write  of  CMCON  will  end  the mismatch condition.\nb) Clear flag bit CMIF.\nA mismatch condition will continue to set flag bit CMIF. Reading CMCON will end the mismatch condition and allow flag bit CMIF to be cleared.",
    "20.7 Comparator Operation During Sleep\nWhen a comparator is active and the device is placed in Sleep mode, the comparator remains active and the interrupt  is  functional  if  enabled.  This  interrupt  will wake-up the device from Sleep mode when enabled. While  the  comparator  is  powered  up,  higher  Sleep currents than shown in the power-down current specification  will  occur.  Each  operational  comparator will consume additional current as shown in the comparator specifications. To minimize power consumption while in Sleep mode, turn off the comparators (CM<2:0> = 111 ) before entering Sleep. If the device wakes  up  from  Sleep,  the  contents  of  the  CMCON register are not affected.",
    "20.8 Effects of a Reset\nA device Reset forces the CMCON register to its Reset state,  causing  the  comparator  module  to  be  in  the Comparator Reset mode (CM<2:0> = 000 ). This ensures  that  all  potential  inputs  are  analog  inputs. Device  current  is  minimized  when  analog  inputs  are present at Reset time. The  comparators will be powered down during the Reset interval.\nFIGURE 20-4: COMPARATOR ANALOG INPUT MODEL",
    "20.9 Analog Input Connection Considerations\nA  simplified  circuit  for  an  analog  input  is  shown  in Figure 20-4. Since the analog pins are connected to a digital output, they have reverse biased diodes to VDD and VSS. The analog input, therefore, must be between VSS and VDD. If  the  input  voltage  deviates  from  this range by more than 0.6V in either direction, one of the diodes is forward biased and a latch-up condition may occur.  A  maximum  source  impedance  of  10 k \uf057 is recommended  for  the  analog  sources.  Any  external component connected to an analog input pin, such as a  capacitor  or  a  Zener  diode,  should  have  very  little leakage current.",
    "TABLE 20-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nCMCON, Bit 7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Value on POR = 0000. CMCON, Value on POR = 0000. CMCON, Value on all other Resets = 0000. CMCON, Value on all other Resets = 0000. CVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0. CVRCON, Value on POR = 0000. CVRCON, Value on POR = 0000. CVRCON, Value on all other Resets = 0000.",
    "TABLE 20-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nCVRCON, Value on all other Resets = 0000. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR = 0000. INTCON, Value on POR = 0000. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 0000. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = CCP2IF. PIR2, Value on POR = -0-0.",
    "TABLE 20-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nPIR2, Value on POR = 0000. PIR2, Value on all other Resets = -0-0. PIR2, Value on all other Resets = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = CCP2IE. PIE2, Value on POR = -0-0. PIE2, Value on POR = 0000. PIE2, Value on all other Resets = -0-0. PIE2, Value on all other Resets = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit",
    "TABLE 20-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\n0 = CCP2IP. IPR2, Value on POR = -1-1. IPR2, Value on POR = 1111. IPR2, Value on all other Resets = -1-1. IPR2, Value on all other Resets = 1111. PORTF, Bit 7 = RF7. PORTF, Bit 6 = RF6. PORTF, Bit 5 = RF5. PORTF, Bit 4 = RF4. PORTF, Bit 3 = RF3. PORTF, Bit 2 = RF2. PORTF, Bit 1 = RF1. PORTF, Bit 0 = RF0. PORTF, Value on POR = xxxx. PORTF, Value on POR = xxxx. PORTF, Value on all other Resets = uuuu. PORTF, Value on all other Resets = uuuu. LATF, Bit 7 = LATF7. LATF, Bit 6 = LATF6. LATF, Bit 5 = LATF5. LATF, Bit 4 = LATF4. LATF, Bit 3 = LATF3. LATF, Bit 2 = LATF2.",
    "TABLE 20-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nLATF, Bit 1 = LATF1. LATF, Bit 0 = LATF0. LATF, Value on POR = xxxx. LATF, Value on POR = xxxx. LATF, Value on all other Resets = uuuu. LATF, Value on all other Resets = uuuu. TRISF, Bit 7 = TRISF7. TRISF, Bit 6 = TRISF6. TRISF, Bit 5 = TRISF5. TRISF, Bit 4 = TRISF4. TRISF, Bit 3 = TRISF3. TRISF, Bit 2 = TRISF2. TRISF, Bit 1 = TRISF1. TRISF, Bit 0 = TRISF0. TRISF, Value on POR = 1111. TRISF, Value on POR = 1111. TRISF, Value on all other Resets = 1111. TRISF, Value on all other Resets = 1111\nLegend:\nx = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are unused by the comparator module.",
    "21.1 Configuring the Comparator Voltage Reference\nThe comparator voltage reference is a 16-tap resistor ladder  network  that  provides  a  selectable  voltage reference. The resistor ladder is segmented to provide two ranges  of  CVREF values  and  has a  power-down function to conserve power when the reference is not being used. The CVRCON  register controls the operation of the reference as shown in Register 21-1. The block diagram is given in Figure 21-1.\nThe  comparator  reference  supply  voltage  can  come from  either  VDD  or  VSS,  or  the  external  VREF+  and VREF-  that  are  multiplexed  with  RA3  and  RA2.  The comparator reference supply voltage is controlled  by the CVRSS bit.\nThe comparator voltage reference can output 16 distinct voltage levels for each range. The equations used to calculate the output of the comparator voltage reference are as follows:\nIf CVRR = 1 :\nCVREF = (CVR<3:0>/24) x CVRSRC\nIf CVRR = 0 :\nCVREF = (CVDD x 1/4) + (CVR<3:0>/32) x CVRSRC",
    "21.1 Configuring the Comparator Voltage Reference\nThe settling time of the comparator voltage reference must be considered when changing the CVREF output ( Section 27.0 'Electrical Characteristics' ).",
    "REGISTER 21-1: CVRCON REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. CVREN, 1 = CVROE. CVREN, 2 = CVRR. CVREN, 3 = CVRSS. CVREN, 4 = CVR3. CVREN, 5 = CVR2. CVREN, 6 = CVR1. CVREN, 7 = CVR0\nbit 7\nbit 0\nbit 7 CVREN : Comparator Voltage Reference Enable bit\n1 = CVREF circuit powered on\n0 = CVREF circuit powered down\nbit 6\nCVROE : Comparator VREF Output Enable bit (1)\n1 = CVREF voltage level is also output on the RF5/AN10/C1IN+/CVREF pin",
    "REGISTER 21-1: CVRCON REGISTER\n0 = CVREF voltage is disconnected from the RF5/AN10/C1IN+/CVREF pin\nbit 5\nCVRR : Comparator VREF Range Selection bit\n1 = 0.00 CVRSRC to 0.625 CVRSRC with CVRSRC/24 step size\n0 = 0.25 CVRSRC to 0.71875 CVRSRC with CVRSRC/32 step size\nbit 4\nCVRSS : Comparator VREF Source Selection bit\n1 = Comparator reference source, CVRSRC = VREF+ - VREF-\n0 = Comparator reference source, CVRSRC = VDD - VSS\nNote:\nTo select (VREF+ - VREF-) as the comparator voltage reference source, the voltage reference configuration bits in the ADCON1 register (ADCON1<5:4>) must also be set to ' 11 '.\nbit 3-0 CVR3:CVR0: Comparator VREF Value Selection bits (0 \uf0a3 VR3:VR0 \uf0a3 15)\nWhen CVRR = 1 :\nCVREF = (CVR<3:0>/24)   (CVRSRC) \uf0b7\nWhen CVRR =\n0",
    "REGISTER 21-1: CVRCON REGISTER\n:\nCVREF = 1/4   (CVRSRC) + (CVR3:CVR0/32)   (CVRSRC) \uf0b7 \uf0b7\nNote 1: If enabled for output, RF5 must also be configured as an input by setting TRISF<5> to ' 1 '.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "21.4 Effects of a Reset\nThe full range of voltage reference cannot be realized due to the construction of the module. The transistors on the top and bottom of the resistor ladder network (Figure 21-1) keep CVREF from approaching the reference  source  rails.  The  voltage  reference  is  derived from the reference source; therefore, the CVREF output changes  with  fluctuations  in  that  source.  The  tested absolute  accuracy  of  the  voltage  reference  can  be found in Section 27.0 'Electrical Characteristics' .",
    "21.3 Operation During Sleep\nWhen  the  device  wakes  up  from  Sleep  through  an interrupt or a Watchdog Timer time-out, the contents of the  CVRCON  register  are  not  affected.  To  minimize current consumption  in Sleep mode,  the  voltage reference should be disabled.\nA  device  Reset  disables  the  voltage  reference  by clearing  bit  CVREN  (CVRCON<7>).  This  Reset  also disconnects the reference from the RA2 pin by clearing bit CVROE  (CVRCON<6>)  and  selects  the  highvoltage  range  by  clearing  bit  CVRR  (CVRCON<5>). The VRSS value select bits, CVRCON<3:0>, are also cleared.",
    "21.5 Connection Considerations\nThe voltage reference module operates independently of the comparator module. The output of the reference generator  may  be  connected  to  the  RF5  pin  if  the TRISF<5> bit is set and the CVROE bit is set. Enabling the voltage reference output onto the RF5 pin with an input signal present will increase current consumption. Connecting RF5 as a digital output with VRSS enabled will also increase current consumption.\nThe RF5 pin can be used as a simple D/A output with limited drive capability. Due to the limited current drive capability, a buffer must be used on the voltage reference output for external connections to VREF. Figure 21-2 shows an example buffering technique.",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR VOLTAGE REFERENCE\nCVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0. CVRCON, Value on POR = 0000 0000. CVRCON, Value on all other Resets = 0000 0000. CMCON, Bit 7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Value on POR = 0000 0000. CMCON, Value on all other Resets = 0000 0000. TRISF, Bit 7 = TRISF7. TRISF, Bit 6 = TRISF6. TRISF, Bit 5 =",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR VOLTAGE REFERENCE\nTRISF5. TRISF, Bit 4 = TRISF4. TRISF, Bit 3 = TRISF3. TRISF, Bit 2 = TRISF2. TRISF, Bit 1 = TRISF1. TRISF, Bit 0 = TRISF0. TRISF, Value on POR = 1111 1111. TRISF, Value on all other Resets = 1111 1111\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '.\nShaded cells are not used with the comparator voltage reference.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "22.0 LOW-VOLTAGE DETECT\nIn  many  applications,  the  ability  to  determine  if  the device voltage (VDD) is below a specified voltage level is  a  desirable  feature.  A  window  of  operation  for  the application can be created where the application software can do 'housekeeping tasks' before the device voltage  exits  the  valid  operating  range.  This  can  be done using the Low-Voltage Detect module.\nThe Low-Voltage Detect circuitry is completely under software control. This allows the circuitry to be 'turned off' by  the  software  which  minimizes  the  current consumption for the device.\nThis  module  is  a  software  programmable  circuitry where  a  device  voltage  trip  point  can  be  specified. When the voltage of the device becomes lower then the specified point, an interrupt flag is set. If the interrupt is enabled, the program execution will branch to the interrupt vector address and the software can then respond to that interrupt source.",
    "22.0 LOW-VOLTAGE DETECT\nFigure 22-1 shows a possible application voltage curve (typically for batteries). Over time, the device voltage decreases. When the device voltage equals voltage VA, the  LVD  logic  generates  an  interrupt.  This  occurs  at time  TA.  The  application  software  then  has  the  time, until the device voltage is no longer in valid operating range, to shut down the system. Voltage point VB is the minimum  valid  operating  voltage  specification.  This occurs at time TB. The difference, TB - TA, is the total time for shutdown.",
    "FIGURE 22-1: TYPICAL LOW-VOLTAGE DETECT APPLICATION\nThe  block  diagram  for  the  LVD  module  is  shown  in Figure 22-2.  A  comparator  uses  an  internally  generated  reference  voltage  as  the  set  point.  When  the selected tap output of the device voltage crosses the set point (is lower than), the LVDIF bit is set.\nEach  node  in  the  resistor  divider  represents  a  'trip point' voltage. The 'trip point' voltage is the minimum supply voltage level at which the device can operate before the LVD module asserts an interrupt. When the supply  voltage  is  equal  to  the  trip  point,  the  voltage tapped  off  of  the  resistor  array  is  equal  to  the  1.2V internal  reference  voltage  generated  by  the  voltage reference module. The comparator then generates an interrupt  signal  setting  the  LVDIF  bit.  This  voltage  is software programmable to any one of 16 values (see Figure 22-2). The trip point is selected by programming the LVDL3:LVDL0 bits (LVDCON<3:0>).",
    "FIGURE 22-2: LOW-VOLTAGE DETECT (LVD) BLOCK DIAGRAM\nThe LVD module has an additional feature that allows the user to supply the trip voltage to the module from an external  source.  This  mode  is  enabled  when  bits LVDL3:LVDL0 are set to ' 1111 '. In this state, the comparator input is multiplexed from the external input pin,\nLVDIN (Figure 22-3). This gives users flexibility because it allows them to configure the Low-Voltage Detect  interrupt  to  occur  at  any  voltage  in  the  valid operating range.\nFIGURE 22-3: LOW-VOLTAGE DETECT (LVD) WITH EXTERNAL INPUT BLOCK DIAGRAM",
    "22.1 Control Register\nThe Low-Voltage Detect Control register controls the operation of the Low-Voltage Detect circuitry.",
    "REGISTER 22-1: LVDCON REGISTER\nU-0, 1 = U-0. U-0, 2 = R-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-1. U-0, 6 = R/W-0. U-0, 7 = R/W-1. -, 1 = -. -, 2 = IRVST. -, 3 = LVDEN. -, 4 = LVDL3. -, 5 = LVDL2. -, 6 = LVDL1. -, 7 = LVDL0\nbit 7\nbit 0",
    "bit 7-6 Unimplemented: Read as ' 0 '\n- bit 5\nIRVST: Internal Reference Voltage Stable Flag bit\n1 = Indicates that the Low-Voltage Detect logic will generate the interrupt flag at the specified voltage range\n0 = Indicates  that  the  Low-Voltage  Detect  logic  will  not  generate  the  interrupt  flag  at  the specified voltage range and the LVD interrupt should not be enabled",
    "bit 4 LVDEN: Low-Voltage Detect Power Enable bit\n1 = Enables LVD, powers up LVD circuit\n0 = Disables LVD, powers down LVD circuit",
    "bit 3-0 LVDL3:LVDL0: Low-Voltage Detection Limit bits\n1111 = External analog input is used (input comes from the LVDIN pin)\n1110 = 4.5V-4.77V\n1101 = 4.2V-4.45V\n1100 = 4.0V-4.24V\n1011 = 3.8V-4.03V\n1010 = 3.6V-3.82V\n1001 = 3.5V-3.71V\n1000 = 3.3V-3.50V\n0111 = 3.0V-3.18V\n0110 = 2.8V-2.97V\n0101 = 2.7V-2.86V\n0100 = 2.5V-2.65V\n0011 = 2.4V-2.54V\n0010 = 2.2V-2.33V\n0001 = 2.0V-2.12V\n0000 = Reserved\nNote:\nLVDL3:LVDL0 modes which result in a trip point below the valid operating voltage of the device are not tested.",
    "bit 3-0 LVDL3:LVDL0: Low-Voltage Detection Limit bits\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "22.2 Operation\nDepending on the power source for the device voltage, the voltage normally decreases relatively slowly. This means  that  the  LVD  module  does  not  need  to  be constantly operating. To decrease the current requirements, the LVD circuitry only needs to be enabled for short periods where the voltage is checked. After doing the check, the LVD module may be disabled.\nEach time that the LVD module is enabled, the circuitry requires some time to stabilize. After the circuitry has stabilized, all status flags may be cleared. The module will then indicate the proper state of the system.\nThe  following  steps  are  needed  to  set  up  the  LVD module:",
    "22.2 Operation\n1. Write the value to the LVDL3:LVDL0  bits (LVDCON  register)  which  selects  the  desired LVD trip point.\n2. Ensure  that  LVD  interrupts  are  disabled  (the LVDIE bit is cleared or the GIE bit is cleared).\n3. Enable the LVD module (set the LVDEN bit in the LVDCON register).\n4. Wait for the LVD module to stabilize (the IRVST bit to become set).\n5. Clear  the  LVD  interrupt  flag  which  may  have falsely  become  set  until  the  LVD  module  has stabilized (clear the LVDIF bit).\n6. Enable the LVD interrupt (set the LVDIE and the GIE bits).\nFigure 22-4  shows  typical  waveforms  that  the  LVD module may be used to detect.",
    "22.2.1 REFERENCE VOLTAGE SET POINT\nThe  internal  reference  voltage  of  the  LVD  module, specified in  electrical  specification  parameter #D423, may be used by other internal circuitry (the Programmable Brown-out Reset). If these circuits are disabled (lower  current  consumption),  the  reference  voltage circuit requires a time to become stable before a lowvoltage condition can be reliably detected. This time is invariant of system clock speed. This start-up time is specified in electrical specification parameter #36. The low-voltage  interrupt  flag  will  not  be  enabled  until  a stable  reference  voltage  is  reached.  Refer  to  the waveform in Figure 22-4.",
    "22.2.2 CURRENT CONSUMPTION\nWhen the module is enabled, the LVD comparator and voltage divider are enabled and will consume static current. The voltage divider can be tapped from multiple places in the resistor array. Total current consumption, when  enabled,  is  specified  in  electrical  specification parameter #D022B.",
    "22.3 Operation During Sleep\nWhen enabled, the LVD circuitry continues to operate during  Sleep.  If  the  device  voltage  crosses  the  trip point,  the  LVDIF  bit  will  be  set  and  the  device  will wake-up  from  Sleep.  Device  execution  will  continue from  the  interrupt  vector  address  if  interrupts  have been globally enabled.",
    "22.4 Effects of a Reset\nA device Reset forces all registers to their Reset state. This forces the LVD module to be turned off.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "23.1 Module Overview\nPIC18F6585/8585/6680/8680 devices contain an Enhanced  Controller  Area  Network  (ECAN)  module. The ECAN module is fully backward compatible with the CAN module available in PIC18CXX8 and PIC18FXX8 devices.\nThe Controller Area Network (CAN) module is a serial interface which is useful for communicating with other peripherals or microcontroller devices. This interface, or  protocol,  was  designed  to  allow  communications within noisy environments.\nThe  ECAN  module  is  a  communication  controller, implementing the CAN 2.0A or B protocol as defined in the  BOSCH  specification.  The  module  will  support CAN 1.2, CAN 2.0A, CAN 2.0B Passive and CAN 2.0B Active versions of the protocol. The module implementation is a full CAN system; however, the CAN specification is not covered within this data sheet. Refer to the BOSCH CAN specification for further details.\nThe module features are as follows:",
    "23.1 Module Overview\n\u00b7 Implementation of the CAN protocol CAN 1.2, CAN 2.0A and CAN 2.0B\n\u00b7 DeviceNet TM  data bytes filter support\n\u00b7 Standard and extended data frames\n\u00b7 0-8 bytes data length\n\u00b7 Programmable bit rate up to 1 Mbit/sec\n\u00b7 Fully backward compatible with PIC18XX8 CAN module\n\u00b7 Three modes of operation:\n-Mode 0 - Legacy mode\n-Mode 1 - Enhanced Legacy mode with DeviceNet support\n-Mode 2 - FIFO mode with DeviceNet support\n\u00b7 Support for remote frames with automated handling\n\u00b7 Double-buffered receiver with two prioritized received message storage buffers\n\u00b7 Six buffers programmable as RX and TX message buffers\n\u00b7 16 full (standard/extended identifier) acceptance filters that can be linked to one of four masks\n\u00b7 Two full acceptance filter masks that can be assigned to any filter\n\u00b7 One full acceptance filter that can be used as either an acceptance filter or acceptance filter mask\n\u00b7 Three dedicated transmit buffers with application specified prioritization and abort capability\n\u00b7 Programmable wake-up functionality with integrated low-pass filter\n\u00b7 Programmable Loopback mode supports self-test operation\n\u00b7 Signaling via interrupt capabilities for all CAN receiver and transmitter error states\n\u00b7 Programmable clock source",
    "23.1 Module Overview\n\u00b7 Programmable link to timer module for time-stamping and network synchronization\n\u00b7 Low-Power Sleep mode\nThe CAN bus module consists of a protocol engine and message  buffering  and  control.  The  CAN  protocol engine automatically handles all functions for receiving and transmitting messages on the CAN bus. Messages are  transmitted  by  first  loading  the  appropriate  data registers. Status and errors can be checked by reading the  appropriate  registers.  Any  message  detected  on the CAN bus is checked for errors and then matched against filters to see if it should be received and stored in one of the two receive registers.\nThe CAN module supports the following frame types:\n\u00b7 Standard Data Frame\n\u00b7 Extended Data Frame\n\u00b7 Remote Frame\n\u00b7 Error Frame\n\u00b7 Overload Frame Reception\n\u00b7 Interframe Space Generation/Detection\nThe CAN module uses the RG0/CANTX1, RG1/CANTX2 and RG2/CANRX pins to interface with the  CAN  bus.  In  Normal  mode,  the  CAN  module automatically overrides the TRISG0 and TRISG1 bits of the CAN module pins.",
    "23.1.1 MODULE FUNCTIONALITY\nThe CAN bus module consists of a protocol  engine, message buffering and control (see Figure 23-1). The protocol engine can best be understood by defining the types of data frames to be transmitted and received by the module.\nThe following sequence illustrates the necessary initialization steps before the ECAN module can be used to transmit or receive a message. Steps can be added or removed depending on the requirements of the application.\n1. Ensure that the ECAN module is in Configuration mode.\n2. Select ECAN Operational mode.\n3. Set up the baud rate registers.\n4. Set up the filter and mask registers.\n5. Set the ECAN module to Normal mode or any other mode required by the application logic.",
    "PIC18F6585/8585/6680/8680\nFIGURE 23-1:\nCAN BUFFERS AND PROTOCOL ENGINE BLOCK DIAGRAM",
    "23.2 CAN Module Registers\nNote:\nNot all CAN registers are available in the Access Bank.",
    "23.2.1 CAN CONTROL AND STATUS REGISTERS\nThere are many control and data registers associated with the CAN module. For convenience, their descriptions  have  been  grouped  into  the  following sections:\n\u00b7 Control and Status Registers\n\u00b7 Dedicated Transmit Buffer Registers\n\u00b7 Dedicated Receive Buffer Registers\n\u00b7 Programmable TX/RX and Auto RTR Buffers\n\u00b7 Baud Rate Control Registers\n\u00b7 I/O Control Register\n\u00b7 Interrupt Status and Control Registers\nDetailed descriptions of each register and their usage are described in the following sections.\nThe  registers  described  in  this  section  control  the overall  operation  of  the  CAN  module  and  show  its operational status.",
    "REGISTER 23-1: CANCON: CAN CONTROL REGISTER\nMode 0, R/W-1 = REQOP2. Mode 0, R/W-0 = REQOP1. Mode 0, R/W-0 = REQOP0. Mode 0, R/S-0 = ABAT. Mode 0, R/W-0 = WIN2. Mode 0, R/W-0 = WIN1. Mode 0, R/W-0 = WIN0. Mode 0, U-0 = -. , R/W-1 = R/W-1. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/S-0 = R/S-0. , R/W-0 = U-0. , R/W-0 = U-0. , R/W-0 = U-0. , U-0 = U-0. , R/W-1 = REQOP2. , R/W-0 = REQOP1. , R/W-0 = REQOP0. , R/S-0 = ABAT. , R/W-0",
    "REGISTER 23-1: CANCON: CAN CONTROL REGISTER\n= -. , R/W-0 = -. , R/W-0 = -. , U-0 = -. , R/W-1 = R/W-1. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/S-0 = R/S-0. , R/W-0 = R-0. , R/W-0 = R-0. , R/W-0 = R-0. , U-0 = R-0. , R/W-1 = REQOP2. , R/W-0 = REQOP1. , R/W-0 = REQOP0. , R/S-0 = ABAT. , R/W-0 = FP3. , R/W-0 = FP2. , R/W-0 = FP1. , U-0 = FP0\nbit 7\nbit 0",
    "bit 7-5 REQOP2:REQOP0: Request CAN Operation Mode bits\n1xx = Request Configuration mode\n011 = Request Listen Only mode\n010 = Request Loopback mode\n001 = Request Disable mode\n000 = Request Normal mode\nABAT: Abort All Pending Transmissions bit\n1 = Abort all pending transmissions (in all transmit buffers)\n0 = Transmissions proceeding as normal",
    "bit 3-1 Mode 0:\nWIN2:WIN0: Window Address bits\nThis selects which of the CAN buffers to switch into the access bank area. This allows access to the buffer registers from any data memory bank. After a frame has caused an interrupt, the ICODE2:ICODE0 bits can be copied to the WIN2:WIN0 bits to select the correct buffer. See Example 23-2 for a code example.\n111 = Receive Buffer 0\n110 = Receive Buffer 0\n101 = Receive Buffer 1\n100 = Transmit Buffer 0\n011 = Transmit Buffer 1\n010 = Transmit Buffer 2\n001 = Receive Buffer 0\n000 = Receive Buffer 0",
    "bit 3-0 Mode 1:\nUnimplemented: Read as ' 0 '\nMode 2:\nFP3:FP0: FIFO Read Pointer bits\nThese bits point to the message buffer to be read.\n0111:0000 = Message buffer to be read\n1111:1000 = Reserved",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "PIC18F6585/8585/6680/8680\nREGISTER 23-2:\nCANSTAT: CAN STATUS REGISTER\nMode 0\nR-1\nR-0\nR-0\nR-0\nR-0\nR-0\nR-0\nU-0\nOPMODE2\n(1)\nOPMODE1\n(1)\nOPMODE0\n(1)\n-\nICODE2\nICODE1\nICODE0\n-\nMode 1, 2\nR-1\nR-0\nR-0\nR-0\nR-0\nR-0\nR-0\nR-0\nOPMODE2\n(1)\nOPMODE1\n(1)\nOPMODE0\n(1)\nEICODE4 EICODE3 EICODE2 EICODE1 EICODE0\nbit 7\nbit 0",
    "bit 7-5 OPMODE2:OPMODE0: Operation Mode Status bits (1)\n111 = Reserved\n110 = Reserved\n101 = Reserved\n100 = Configuration mode\n011 = Listen Only mode\n010 = Loopback mode\n001 = Disable/Sleep mode\n000 = Normal mode",
    "bit 4\nMode 0:\nUnimplemented: Read as ' 0 '",
    "bit 3-1 ICODE2:ICODE0 : Interrupt Code bits in Mode 0\nWhen an interrupt occurs, a prioritized coded interrupt value will be present in these bits. This code indicates the source of the interrupt. By copying ICODE2:ICODE0 to WIN2:WIN0, it is possible to select the correct buffer to map into the Access Bank area. See Example 23-2 for a code example.",
    "ICODE2:ICODE0 Value\nNo interrupt, 1 = 000. Error interrupt, 1 = 001. TXB2 interrupt, 1 = 010. TXB1 interrupt, 1 = 011. TXB0 interrupt, 1 = 100. RXB1 interrupt, 1 = 101. RXB0 interrupt, 1 = 110. Wake-up interrupt, 1 = 111",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "bit 4-0 Mode 1,2:\nEICODE4:EICODE0 : Interrupt Code bits in Mode 1 and Mode 2\nWhen an interrupt occurs, a prioritized coded interrupt value will be present in these bits. This code indicates the source of the interrupt. Unlike ICODE bits in Mode 0, these bits may not be copied directly to EWIN bits to map interrupted buffer to Access Bank area. If required, user software may maintain a table in program memory to map EICODE bits to EWIN bits and access interrupt buffer in Access Bank area.",
    "EICODE4:EICODE0 Value\nNo interrupt\n00000\nError interrupt\n00010\nTXB2 interrupt\n00100\nTXB1 interrupt\n00110\nTXB0 interrupt\n01000\nRXB1 interrupt\n10001/10000\n(2)\nRXB0 interrupt\n10000\nWake-up interrupt\n01110\nRX/TX B0 interrupt\n10010 (2)\nRX/TX B1 interrupt\n10011 (2)\nRX/TX B2 interrupt\n10100 (2)\nRX/TX B3 interrupt\n10101\n(2)\nRX/TX B4 interrupt\n10110\n(2)\nRX/TX B4 interrupt\n10111 (2)\nNote 1: To achieve maximum power saving and/or able to wake-up on CAN bus activity, switch CAN module to Disable mode before putting the device to Sleep.\n2: In Mode 2, if the buffer is configured as a receiver, EICODE bits will always contain ' 10000 ' upon interrupt.",
    "EICODE4:EICODE0 Value\nLegend:, 1 = U = Unimplemented bit, read as '0'. Legend:, 2 = - n = Value at POR. C = Clearable bit, 1 = R = Readable bit W=Writable. C = Clearable bit, 2 = x = Bit is unknown. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = ",
    "EXAMPLE 23-1: CHANGING TO CONFIGURATION MODE\n; Request Configuration mode.\nMOVLW\nB'10000000'\n; Set to Configuration Mode.\nMOVWF\nCANCON\n; A request to switch to Configuration mode may not be immediately honored.\n; Module will wait for CAN bus to be idle before switching to Configuration Mode.\n; Request for other modes such as Loopback, Disable etc. may be honored immediately.\n; It is always good practice to wait and verify before continuing.\nConfigWait:\nMOVF\nCANSTAT, W\n; Read current mode state.\nANDLW\nB'10000000'\n; Interested in OPMODE bits only.\nTSTFSZ\nWREG\n; Is it Configuration mode yet?\nBRA\nConfigWait\n; No. Continue to wait...\n; Module is in Configuration mode now.\n; Modify configuration registers as required.\n; Switch back to Normal mode to be able to communicate.",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS\n; Save application required context.\n; Poll interrupt flags and determine source of interrupt\n; This was found to be CAN interrupt\n; TempCANCON and TempCANSTAT are variables defined in Access Bank low\nMOVFF\nCANCON, TempCANCON\n; Save CANCON.WIN bits\n; This is required to prevent CANCON\n; from corrupting CAN buffer access\n; in-progress while this interrupt\n; occurred\nMOVFF CANSTAT, TempCANSTAT\n; Save CANSTAT register\n; This is required to make sure that\n; we use same CANSTAT value rather\n; than one changed by another CAN\n; interrupt.\nMOVF\nTempCANSTAT, W\n; Retrieve ICODE bits\nANDLW\nB'00001110'\nADDWF\nPCL, F\n; Perform computed GOTO\n; to corresponding interrupt cause\nBRA\nNoInterrupt\n; 000 = No interrupt\nBRA\nErrorInterrupt\n; 001 = Error interrupt\nBRA\nTXB2Interrupt\n; 010 = TXB2 interrupt\nBRA\nTXB1Interrupt\n; 011 = TXB1 interrupt\nBRA\nTXB0Interrupt\n; 100 = TXB0 interrupt\nBRA",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS\nRXB1Interrupt\n; 101 = RXB1 interrupt\nBRA\nRXB0Interrupt\n; 110 = RXB0 interrupt\n; 111 = Wake-up on interrupt\nWakeupInterrupt\nBCF PIR3, WAKIF\n; Clear the interrupt flag\n;\n; User code to handle wake-up procedure\n;\n;\n; Continue checking for other interrupt source or return from here\n\u2026\nNoInterrupt\n\u2026\n; PC should never vector here. User may\n; place a trap such as infinite loop or pin/port\n; indication to catch this error.",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nBCF, ErrorInterrupt = PIR3, ERRIF. BCF, ErrorInterrupt = ; Clear the interrupt flag. \u2026, ErrorInterrupt = \u2026. \u2026, ErrorInterrupt = ; Handle error.. RETFIE, ErrorInterrupt = RETFIE. RETFIE, ErrorInterrupt = RETFIE. TXB2Interrupt, ErrorInterrupt = TXB2Interrupt. TXB2Interrupt, ErrorInterrupt = TXB2Interrupt. BCF, ErrorInterrupt = PIR3, TXB2IF. BCF, ErrorInterrupt = ; Clear the interrupt flag. GOTO, ErrorInterrupt = AccessBuffer. GOTO, ErrorInterrupt = . TXB1Interrupt, ErrorInterrupt = TXB1Interrupt. TXB1Interrupt, ErrorInterrupt = TXB1Interrupt. BCF,",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nErrorInterrupt = PIR3, TXB1IF. BCF, ErrorInterrupt = ; Clear the interrupt flag. GOTO, ErrorInterrupt = AccessBuffer. GOTO, ErrorInterrupt = . TXB0Interrupt, ErrorInterrupt = TXB0Interrupt. TXB0Interrupt, ErrorInterrupt = TXB0Interrupt. BCF, ErrorInterrupt = PIR3, TXB0IF. BCF, ErrorInterrupt = ; Clear the interrupt flag. GOTO, ErrorInterrupt = AccessBuffer. GOTO, ErrorInterrupt = . RXB1Interrupt, ErrorInterrupt = RXB1Interrupt. RXB1Interrupt, ErrorInterrupt = RXB1Interrupt. BCF, ErrorInterrupt = PIR3, RXB1IF. BCF, ErrorInterrupt = ;",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nClear the interrupt flag. GOTO, ErrorInterrupt = Accessbuffer. GOTO, ErrorInterrupt = . RXB0Interrupt, ErrorInterrupt = RXB0Interrupt. RXB0Interrupt, ErrorInterrupt = RXB0Interrupt. BCF, ErrorInterrupt = PIR3, RXB0IF. BCF, ErrorInterrupt = ; Clear the interrupt flag. GOTO, ErrorInterrupt = AccessBuffer. GOTO, ErrorInterrupt = . AccessBuffer ; This is either TX or RX interrupt, ErrorInterrupt = AccessBuffer ; This is either TX or RX interrupt. AccessBuffer ; This is either TX or RX interrupt, ErrorInterrupt = AccessBuffer ; This is either TX or RX interrupt. ; Copy, ErrorInterrupt = CANSTAT.ICODE bits to. ; Copy, ErrorInterrupt = CANCON.WIN bits.",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nMOVF, ErrorInterrupt = TempCANCON, W. MOVF, ErrorInterrupt = ; Clear CANCON.WIN bits before copying. ANDLW, ErrorInterrupt = B'11110001'. ANDLW, ErrorInterrupt = ; Use previously saved CANCON value to ; make sure same value.. MOVWF, ErrorInterrupt = TempCANCON. MOVWF, ErrorInterrupt = ; Copy masked value back to TempCANCON. MOVF, ErrorInterrupt = TempCANSTAT, W. MOVF, ErrorInterrupt = ; Retrieve ICODE bits. ANDLW, ErrorInterrupt = B'00001110'. ANDLW, ErrorInterrupt = ; Use previously saved CANSTAT value ; to make sure same value.. IORWF, ErrorInterrupt = TempCANCON. IORWF, ErrorInterrupt = ; Copy ICODE bits to WIN bits..",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nMOVFF, ErrorInterrupt = TempCANCON, CANCON. MOVFF, ErrorInterrupt = ; Copy the result to actual CANCON. ; Access current buffer\u2026, ErrorInterrupt = ; Access current buffer\u2026. ; Access current buffer\u2026, ErrorInterrupt = ; Access current buffer\u2026. ; User code, ErrorInterrupt = ; User code. ; User code, ErrorInterrupt = ; User code. ; Restore CANCON.WIN bits, ErrorInterrupt = ; Restore CANCON.WIN bits. ; Restore CANCON.WIN bits, ErrorInterrupt = ; Restore CANCON.WIN bits. MOVF, ErrorInterrupt = CANCON, W. MOVF, ErrorInterrupt = ; Preserve current non WIN bits. ANDLW, ErrorInterrupt = B'11110001'. ANDLW, ErrorInterrupt = . IORWF, ErrorInterrupt = TempCANCON. IORWF,",
    "EXAMPLE 23-2: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nErrorInterrupt = ; Restore original WIN bits. ; Do not need to restore CANSTAT - it is read-only register., ErrorInterrupt = ; Do not need to restore CANSTAT - it is read-only register.. ; Do not need to restore CANSTAT - it is read-only register., ErrorInterrupt = ; Do not need to restore CANSTAT - it is read-only register.. ; Return from interrupt or check for another module interrupt source, ErrorInterrupt = ; Return from interrupt or check for another module interrupt source. ; Return from interrupt or check for another module interrupt source, ErrorInterrupt = ; Return from interrupt or check for another module interrupt source",
    "ECANCON: ENHANCED CAN CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. MDSEL1 (1, 2), 1 = MDSEL0 (1, 2). MDSEL1 (1, 2), 2 = FIFOWM. MDSEL1 (1, 2), 3 = EWIN4. MDSEL1 (1, 2), 4 = EWIN3. MDSEL1 (1, 2), 5 = EWIN2. MDSEL1 (1, 2), 6 = EWIN1. MDSEL1 (1, 2), 7 = EWIN0\nbit 7\nbit 0",
    "bit 7-6 MDSEL1:MDSEL0: Mode Select bits\n00 = Legacy mode (Mode 0, default)\n01 = Enhanced Legacy mode (Mode 1)\n10 = Enhanced FIFO mode (Mode 2)\n11 = Reserved",
    "bit 5 FIFOWM: FIFO High Water Mark bit (3)\n1 = Will cause FIFO interrupt when one receive buffer remains (4)\n0 = Will cause FIFO interrupt when four receive buffers remain",
    "bit 4-0 EWIN4:EWIN0: Enhanced Window Address bits\nThese bits map the group of 16 banked CAN SFRs into access bank addresses 0F60-0F6Dh. Exact group of registers to map is determined by binary value of these bits.\nMode 0:\nUnimplemented: Read as ' 0 '",
    "Mode 1, 2:\n00000 = Acceptance Filters 0, 1, 2 and BRGCON3, 2\n00001 = Acceptance Filters 3, 4, 5 and BRGCON1, CIOCON\n00010 = Acceptance Filter Masks, Error and Interrupt Control\n00011 = Transmit Buffer 0\n00100 = Transmit Buffer 1\n00101 = Transmit Buffer 2\n00110 = Acceptance Filters 6, 7, 8\n00111 = Acceptance Filters 9, 10, 11\n01000 = Acceptance Filters 12, 13, 14\n01001 = Acceptance Filters 15\n01010 01111 - = Reserved\n10000 = Receive Buffer 0\n10001 = Receive Buffer 1\n10010 = TX/RX Buffer 0\n10011 = TX/RX Buffer 1\n10100 = TX/RX Buffer 2\n10101 = TX/RX Buffer 3\n10110 = TX/RX Buffer 4\n10111\n= TX/RX Buffer 5\n11000 11111 -= Reserved",
    "Mode 1, 2:\nNote 1: These  bits  can  only  be  changed  in  Configuration  mode.  See  Register 19-2  to change to Configuration mode.\n2: A new mode takes into effect only after Configuration mode is exited.\n3: This bit is used in Mode 2 only.\n4: FIFO length of 4 or less will cause this bit to be set.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-4: COMSTAT: COMMUNICATION STATUS REGISTER\nMode 0, R/C-0 = RXB0OVFL. Mode 0, R/C-0 = RXB1OVFL. Mode 0, R-0 = TXBO. Mode 0, R-0 = TXBP. Mode 0, R-0 = RXBP. Mode 0, R-0 = TXWARN. Mode 0, R-0 = RXWARN. Mode 0, R-0 = EWARN. , R/C-0 = U-0. , R/C-0 = R/C-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R/C-0 = -. , R/C-0 = RXBnOVFL. , R-0 = TXB0. , R-0 = TXBP. , R-0 = RXBP. , R-0 = TXWARN. , R-0 =",
    "REGISTER 23-4: COMSTAT: COMMUNICATION STATUS REGISTER\nRXWARN. , R-0 = EWARN. , R/C-0 = R/C-0. , R/C-0 = R/C-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R/C-0 = FIFOEMPTY. , R/C-0 = RXBnOVFL. , R-0 = TXBO. , R-0 = TXBP. , R-0 = RXBP. , R-0 = TXWARN. , R-0 = RXWARN. , R-0 = EWARN\nbit 7\nbit 0",
    "bit 7 Mode 0:\nRXB0OVFL: Receive Buffer 0 Overflow bit\n- 1 = Receive Buffer 0 overflowed\n0 = Receive Buffer 0 has not overflowed\nMode 1:\nUnimplemented: Read as ' 0 '\nMode 2:\nFIFOEMPTY: FIFO Not Empty bit\n1 = Receive FIFO is not empty\n0 = Receive FIFO is empty",
    "bit 6 Mode 0:\nRXB1OVFL: Receive Buffer 1 Overflow bit\n1 = Receive Buffer 1 overflowed\n0 = Receive Buffer 1 has not overflowed\nMode 1, 2:\nRXBnOVFL: Receive Buffer Overflow bit\n1 = Receive buffer has overflowed\n0 = Receive buffer has not overflowed\nTXBO: Transmitter Bus-Off bit\n- 1 = Transmit error counter > 255\n0 = Transmit error counter \uf0a3\uf020 255\nTXBP: Transmitter Bus Passive bit\n- 1 = Transmit error counter > 127\n0 = Transmit error counter \uf0a3\uf020 127\nRXBP: Receiver Bus Passive bit\n1 = Receive error counter > 127\n0 = Receive error counter \uf0a3\uf020 127",
    "bit 2 TXWARN: Transmitter Warning bit\n- 1 = 127 \uf0b3 Transmit error counter > 95\n0 = Transmit error counter \uf0a3\uf020 95\nRXWARN: Receiver Warning bit\n1 = 127 \uf0b3 Receive error counter > 95\n- 0 = Receive error counter \uf0a3 95\nEWARN: Error Warning bit\nThis bit is a flag of the RXWARN and TXWARN bits.\n- 1 = The RXWARN or the TXWARN bits are set\n0 = Neither the RXWARN or the TXWARN bits are set",
    "Legend:\nC = Clearable bit\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared x = Bit is unknown",
    "23.2.2 DEDICATED CAN TRANSMIT BUFFER REGISTERS\nThis  section  describes  the  dedicated  CAN  Transmit Buffer registers and their associated control registers.",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nMode 0, U-0 = -. Mode 0, R-0 = TXABT. Mode 0, R-0 = TXLARB. Mode 0, R-0 = TXERR. Mode 0, R/W-0 = TXREQ. Mode 0, U-0 = -. Mode 0, R/W-0 = TXPRI1. Mode 0, R/W-0 = TXPRI0. , U-0 = R/C-0. , R-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R/W-0 = R/W-0. , U-0 = U-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. Mode 1, 2, U-0 = TXBIF. Mode 1, 2, R-0 = TXABT. Mode 1, 2, R-0 = TXLARB. Mode 1, 2, R-0 = TXERR. Mode 1, 2,",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nR/W-0 = TXREQ. Mode 1, 2, U-0 = -. Mode 1, 2, R/W-0 = TXPRI1. Mode 1, 2, R/W-0 = TXPRI0. , U-0 = bit 7. , R-0 = . , R-0 = . , R-0 = . , R/W-0 = . , U-0 = . , R/W-0 = . , R/W-0 = bit 0. bit 7, U-0 = Mode 0: Unimplemented: Read as ' 0 ' Mode 1, 2:. bit 7, R-0 = Mode 0: Unimplemented: Read as ' 0 ' Mode 1, 2:. bit 7, R-0 = Mode 0: Unimplemented: Read as ' 0 ' Mode 1, 2:. bit 7, R-0 = Mode 0: Unimplemented: Read as ' 0 ' Mode 1, 2:. bit 7, R/W-0 = Mode 0: Unimplemented:",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nRead as ' 0 ' Mode 1, 2:. bit 7, U-0 = Mode 0: Unimplemented: Read as ' 0 ' Mode 1, 2:. bit 7, R/W-0 = Mode 0: Unimplemented: Read as ' 0 ' Mode 1, 2:. bit 7, R/W-0 = Mode 0: Unimplemented: Read as ' 0 ' Mode 1, 2:. , U-0 = 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. , R-0 = 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. , R-0 = 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. , R-0 = 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. , R/W-0 = 1 = Transmit buffer has completed transmission of message and",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nmay be reloaded 0 = Transmit buffer has not completed transmission of a message. , U-0 = 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. , R/W-0 = 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. , R/W-0 = 1 = Transmit buffer has completed transmission of message and may be reloaded 0 = Transmit buffer has not completed transmission of a message. bit 6, U-0 = TXABT: Transmission Aborted Status bit (1). bit 6, R-0 = TXABT: Transmission Aborted Status bit (1). bit 6, R-0 = TXABT: Transmission Aborted Status bit (1). bit 6, R-0 = TXABT: Transmission Aborted Status bit (1). bit 6, R/W-0 = TXABT: Transmission Aborted Status bit (1). bit 6, U-0 = TXABT: Transmission Aborted Status bit (1). bit",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\n6, R/W-0 = TXABT: Transmission Aborted Status bit (1). bit 6, R/W-0 = TXABT: Transmission Aborted Status bit (1). , U-0 = 1 = Message was aborted 0 = Message was not aborted. , R-0 = 1 = Message was aborted 0 = Message was not aborted. , R-0 = 1 = Message was aborted 0 = Message was not aborted. , R-0 = 1 = Message was aborted 0 = Message was not aborted. , R/W-0 = 1 = Message was aborted 0 = Message was not aborted. , U-0 = 1 = Message was aborted 0 = Message was not aborted. , R/W-0 = 1 = Message was aborted 0 = Message was not aborted. , R/W-0 = 1 = Message was aborted 0 = Message was not aborted. bit 5, U-0 = TXLARB: Transmission Lost Arbitration Status bit (1). bit 5, R-0 = TXLARB: Transmission Lost Arbitration Status bit",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\n(1). bit 5, R-0 = TXLARB: Transmission Lost Arbitration Status bit (1). bit 5, R-0 = TXLARB: Transmission Lost Arbitration Status bit (1). bit 5, R/W-0 = TXLARB: Transmission Lost Arbitration Status bit (1). bit 5, U-0 = TXLARB: Transmission Lost Arbitration Status bit (1). bit 5, R/W-0 = TXLARB: Transmission Lost Arbitration Status bit (1). bit 5, R/W-0 = TXLARB: Transmission Lost Arbitration Status bit (1). , U-0 = 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. , R-0 = 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. , R-0 = 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. , R-0 = 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. , R/W-0 = 1 = Message lost",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\narbitration while being sent 0 = Message did not lose arbitration while being sent. , U-0 = 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. , R/W-0 = 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. , R/W-0 = 1 = Message lost arbitration while being sent 0 = Message did not lose arbitration while being sent. bit 4, U-0 = TXERR: Transmission Error Detected Status bit (1). bit 4, R-0 = TXERR: Transmission Error Detected Status bit (1). bit 4, R-0 = TXERR: Transmission Error Detected Status bit (1). bit 4, R-0 = TXERR: Transmission Error Detected Status bit (1). bit 4, R/W-0 = TXERR: Transmission Error Detected Status bit (1). bit 4, U-0 = TXERR: Transmission Error Detected Status bit (1). bit 4, R/W-0 = TXERR: Transmission Error Detected Status bit (1). bit",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\n4, R/W-0 = TXERR: Transmission Error Detected Status bit (1). , U-0 = 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. , R-0 = 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. , R-0 = 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. , R-0 = 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. , R/W-0 = 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. , U-0 = 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. , R/W-0 = 1 = A bus error occurred while the message was being sent 0 = A",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nbus error did not occur while the message was being sent. , R/W-0 = 1 = A bus error occurred while the message was being sent 0 = A bus error did not occur while the message was being sent. bit 3, U-0 = TXREQ: Transmit Request Status bit (2). bit 3, R-0 = TXREQ: Transmit Request Status bit (2). bit 3, R-0 = TXREQ: Transmit Request Status bit (2). bit 3, R-0 = TXREQ: Transmit Request Status bit (2). bit 3, R/W-0 = TXREQ: Transmit Request Status bit (2). bit 3, U-0 = TXREQ: Transmit Request Status bit (2). bit 3, R/W-0 = TXREQ: Transmit Request Status bit (2). bit 3, R/W-0 = TXREQ: Transmit Request Status bit (2). , U-0 = 1 = Requests sending a message. Clears the TXABT, TXLARB, and TXERR bits. 0 = Automatically cleared when",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nthe message is successfully sent Note: Clearing this bit in software while the bit is set, will request a message abort.. , R-0 = 1 = Requests sending a message. Clears the TXABT, TXLARB, and TXERR bits. 0 = Automatically cleared when the message is successfully sent Note: Clearing this bit in software while the bit is set, will request a message abort.. , R-0 = 1 = Requests sending a message. Clears the TXABT, TXLARB, and TXERR bits. 0 = Automatically cleared when the message is successfully sent Note: Clearing this bit in software while the bit is set, will request a message abort.. , R-0 = 1 = Requests sending a message. Clears the TXABT, TXLARB, and TXERR bits. 0 = Automatically cleared when the message is successfully sent Note: Clearing this bit in software while the bit is set, will request a message abort.. , R/W-0 = 1 = Requests sending a message. Clears the TXABT, TXLARB, and TXERR bits. 0 = Automatically cleared",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nwhen the message is successfully sent Note: Clearing this bit in software while the bit is set, will request a message abort.. , U-0 = 1 = Requests sending a message. Clears the TXABT, TXLARB, and TXERR bits. 0 = Automatically cleared when the message is successfully sent Note: Clearing this bit in software while the bit is set, will request a message abort.. , R/W-0 = 1 = Requests sending a message. Clears the TXABT, TXLARB, and TXERR bits. 0 = Automatically cleared when the message is successfully sent Note: Clearing this bit in software while the bit is set, will request a message abort.. , R/W-0 = 1 = Requests sending a message. Clears the TXABT, TXLARB, and TXERR bits. 0 = Automatically cleared when the message is successfully sent Note: Clearing this bit in software while the bit is set, will request a message abort.. bit 2 bit 1-0, U-0 = Unimplemented: Read as ' 0 '",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nTXPRI1:TXPRI0: Transmit Priority bits (3). bit 2 bit 1-0, R-0 = Unimplemented: Read as ' 0 ' TXPRI1:TXPRI0: Transmit Priority bits (3). bit 2 bit 1-0, R-0 = Unimplemented: Read as ' 0 ' TXPRI1:TXPRI0: Transmit Priority bits (3). bit 2 bit 1-0, R-0 = Unimplemented: Read as ' 0 ' TXPRI1:TXPRI0: Transmit Priority bits (3). bit 2 bit 1-0, R/W-0 = Unimplemented: Read as ' 0 ' TXPRI1:TXPRI0: Transmit Priority bits (3). bit 2 bit 1-0, U-0 = Unimplemented: Read as ' 0 ' TXPRI1:TXPRI0: Transmit Priority bits (3). bit 2 bit 1-0, R/W-0 = Unimplemented: Read as ' 0",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\n' TXPRI1:TXPRI0: Transmit Priority bits (3). bit 2 bit 1-0, R/W-0 = Unimplemented: Read as ' 0 ' TXPRI1:TXPRI0: Transmit Priority bits (3). , U-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. , R-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. , R-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. , R-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\npriority) Note 1: This bit is automatically cleared when TXREQ is set.. , R/W-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. , U-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. , R/W-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. , R/W-0 = 11 = Priority Level 3 (highest priority) 10 = Priority Level 2 01 = Priority Level 1 00 = Priority Level 0 (lowest priority) Note 1: This bit is automatically cleared when TXREQ is set.. , U-0 = 3: These bits define the order in which transmit buffers",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nwill be transferred. They do not alter the CAN message identifier.. , R-0 = 3: These bits define the order in which transmit buffers will be transferred. They do not alter the CAN message identifier.. , R-0 = 3: These bits define the order in which transmit buffers will be transferred. They do not alter the CAN message identifier.. , R-0 = 3: These bits define the order in which transmit buffers will be transferred. They do not alter the CAN message identifier.. , R/W-0 = 3: These bits define the order in which transmit buffers will be transferred. They do not alter the CAN message identifier.. , U-0 = 3: These bits define the order in which transmit buffers will be transferred. They do not alter the CAN message identifier.. , R/W-0 = 3: These bits define the order in which transmit buffers will be transferred. They do not alter the CAN message identifier.. , R/W-0 = 3: These bits define the order in which transmit buffers",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nwill be transferred. They do not alter the CAN message identifier.. , U-0 = Legend:. , R-0 = Legend:. , R-0 = U = Unimplemented bit, read as '0'. , R-0 = U = Unimplemented bit, read as '0'. , R/W-0 = U = Unimplemented bit, read as '0'. , U-0 = - n = Value at POR. , R/W-0 = - n = Value at POR. , R/W-0 = - n = Value at POR. , U-0 = C = Clearable bit '1' = Bit is set. , R-0 = C = Clearable bit '1' = Bit is set. , R-0 = R = Readable bit W=Writable bit '0' = Bit is cleared. , R-0 = R = Readable bit W=Writable bit '0' = Bit is cleared. , R/W-0 = R = Readable bit W=Writable bit '0' =",
    "REGISTER 23-5: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS [0   n   2] \uf0a3 \uf0a3\nBit is cleared. , U-0 = x = Bit is unknown. , R/W-0 = x = Bit is unknown. , R/W-0 = x = Bit is unknown",
    "TXBnSIDH: TRANSMIT BUFFER n STANDARD IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 2]\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID10, 1 = SID9. SID10, 2 = SID8. SID10, 3 = SID7. SID10, 4 = SID6. SID10, 5 = SID5. SID10, 6 = SID4. SID10, 7 = SID3\nbit 7\nbit 0\nSID10:SID3: Standard Identifier bits, if EXIDE (TXBnSIDL<3>) = 0 ;\nExtended Identifier bits EID28:EID21, if EXIDE = 1 .",
    "TXBnSIDH: TRANSMIT BUFFER n STANDARD IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 2]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "TXBnSIDL: TRANSMIT BUFFER n STANDARD IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 2]\nbit 7-0",
    "REGISTER 23-7:\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = U-0. R/W-x, 4 = R/W-x. R/W-x, 5 = U-0. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = -. SID2, 4 = EXIDE. SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5 SID2:SID0: Standard Identifier bits, if EXIDE (TXBnSIDL<3>) = 0 ;\nExtended Identifier bits EID20:EID18, if EXIDE = 1 .\nbit 4 Unimplemented: Read as ' 0 '\nbit 3 EXIDE: Extended Identifier Enable bit\n1 = Message will transmit extended ID, SID10:SID0 becomes EID28:EID18",
    "REGISTER 23-7:\n0 = Message will transmit standard ID, EID17:EID0 are ignored\nbit 2\nUnimplemented: Read as ' 0 '\nbit 1-0\nEID17:EID16:\nExtended Identifier bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "TXBnEIDH: TRANSMIT BUFFER n EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 2]\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID15, 1 = EID14. EID15, 2 = EID13. EID15, 3 = EID12. EID15, 4 = EID11. EID15, 5 = EID10. EID15, 6 = EID9. EID15, 7 = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier bits (not used when transmitting standard identifier message)\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-9: LOW BYTE [0   n \uf0a3 \uf0a3 2]\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 7-0\nbit 0\nEID7:EID0: Extended Identifier bits (not used when transmitting standard identifier message)",
    "REGISTER 23-9: LOW BYTE [0   n \uf0a3 \uf0a3 2]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-10: TXBnDm: TRANSMIT BUFFER n DATA FIELD BYTE m REGISTERS [0 \uf0a3 n \uf0a3 2, 0 \uf0a3 m \uf0a3 7]\nTXBnDm7, R/W-x = TXBnDm6. TXBnDm7, R/W-x = TXBnDm5. TXBnDm7, R/W-x = TXBnDm4. TXBnDm7, R/W-x = TXBnDm3. TXBnDm7, R/W-x = TXBnDm2. TXBnDm7, R/W-x = TXBnDm1. TXBnDm7, R/W-x = TXBnDm0. bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = bit 0\nbit 7-0",
    "REGISTER 23-10: TXBnDm: TRANSMIT BUFFER n DATA FIELD BYTE m REGISTERS [0 \uf0a3 n \uf0a3 2, 0 \uf0a3 m \uf0a3 7]\nTXBnDm7:TXBnDm0: Transmit Buffer n Data Field Byte m bits (where 0 \uf0a3\uf020 n < 3 and 0 \uf0a3\uf020 m < 8) Each transmit buffer has an array of registers. For example, Transmit Buffer 0 has 7 registers: TXB0D0 to TXB0D7.\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 23-11: TXBnDLC: TRANSMIT BUFFER n DATA LENGTH CODE REGISTERS [0   n   2] \uf0a3 \uf0a3\nU-0, 1 = R/W-x. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-x. U-0, 5 = R/W-x. U-0, 6 = R/W-x. U-0, 7 = R/W-x. -, 1 = TXRTR. -, 2 = -. -, 3 = -. -, 4 = DLC3. -, 5 = DLC2. -, 6 = DLC1. -, 7 = DLC0\nbit 7\nbit 0\nbit 7\nUnimplemented: Read as ' 0 '\nbit 6\nTXRTR: Transmit Remote Frame Transmission Request bit\n1 = Transmitted message will have TXRTR bit set\n0 = Transmitted message will have TXRTR bit cleared\nbit 5-4 Unimplemented: Read as ' 0 '\nbit 3-0\nDLC3:DLC0: Data Length Code bits\n1111 = Reserved\n1110 = Reserved\n1101 = Reserved\n1100 = Reserved\n1011 = Reserved",
    "REGISTER 23-11: TXBnDLC: TRANSMIT BUFFER n DATA LENGTH CODE REGISTERS [0   n   2] \uf0a3 \uf0a3\n1010 = Reserved\n1001 = Reserved\n1000 = Data length = 8 bytes\n0111 = Data length = 7 bytes\n0110 = Data length = 6 bytes\n0101 = Data length = 5 bytes\n0100 = Data length = 4 bytes\n0011 = Data length = 3 bytes\n0010 = Data length = 2 bytes\n0001 = Data length = 1 bytes\n0000 = Data length = 0 bytes\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = = '0' = Bit is cleared. - n = Value at POR, bit, = x = Bit is unknown",
    "REGISTER 23-12: TXERRCNT: TRANSMIT ERROR COUNT REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. TEC7, 1 = TEC6. TEC7, 2 = TEC5. TEC7, 3 = TEC4. TEC7, 4 = TEC3. TEC7, 5 = TEC2. TEC7, 6 = TEC1. TEC7, 7 = TEC0\nbit 7\nbit 0",
    "bit 7-0 TEC7:TEC0: Transmit Error Counter bits\nThis register contains a value which is derived from the rate at which errors occur. When the error count overflows, the bus-off state occurs. When the bus has 128 occurrences of 11 consecutive recessive bits, the counter value is cleared.\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "EXAMPLE 23-3: TRANSMITTING A CAN MESSAGE USING BANKED METHOD\n; Need to transmit Standard Identifier message 123h using TXB0 buffer. ; To successfully transmit, CAN module must be either in Normal or Loopback mode. ; TXB0 buffer is not in access bank.",
    "EXAMPLE 23-3: TRANSMITTING A CAN MESSAGE USING BANKED METHOD\nAnd since we want banked method, we need to make sure ; that correct bank is selected. BANKSEL TXB0CON ; One BANKSEL in beginning will make sure that we are ; in correct bank for rest of the buffer access. ; Now load transmit data into TXB0 buffer. MOVLW MY_DATA_BYTE1 ; Load first data byte into buffer MOVWF TXB0D0 ; Compiler will automatically set 'BANKED' bit ; Load rest of data bytes - up to 8 bytes into TXB0 buffer. ... ; Load message identifier MOVLW 60H ; Load SID2:SID0, EXIDE = 0 MOVWF TXB0SIDL MOVLW 24H ; Load SID10:SID3 MOVWF TXB0SIDH ; No need to load TXB0EIDL:TXB0EIDH, as we are transmitting Standard Identifier Message only. ; Now that all data bytes are loaded, mark it for transmission. MOVLW B'00001000' ; Normal priority; Request transmission MOVWF TXB0CON ; If required, wait",
    "EXAMPLE 23-3: TRANSMITTING A CAN MESSAGE USING BANKED METHOD\nfor message to get transmitted BTFSC TXB0CON, TXREQ ; Is it transmitted? BRA $-2 ; No.\nContinue to wait... ; Message is transmitted.",
    "EXAMPLE 23-4: TRANSMITTING A CAN MESSAGE USING WIN BITS\n```\n; Need to transmit Standard Identifier message 123h using TXB0 buffer. ; To successfully transmit, CAN module must be either in Normal or Loopback mode. ; TXB0 buffer is not in access bank.  Use WIN bits to map it to RXB0 area. MOVF CANCON, W ; WIN bits are in lower 4 bits only.  Read CANCON ; register to preserve all other bits.  If operation ; mode is already known, there is no need to preserve ; other bits. ANDLW B'11110000' ; Clear WIN bits. IORLW B'00001000' ; Select Transmit Buffer 0 MOVWF CANCON ; Apply the changes. ; Now TXB0 is mapped in place of RXB0.",
    "EXAMPLE 23-4: TRANSMITTING A CAN MESSAGE USING WIN BITS\nAll future access to RXB0 registers will actually ; yield TXB0 register values. ; Load transmit data into TXB0 buffer. MOVLW MY_DATA_BYTE1 ; Load first data byte into buffer MOVWF RXB0D0 ; Access TXB0D0 via RXB0D0 address. ; Load rest of the data bytes - up to 8 bytes into 'TXB0' buffer using RXB0 registers. ... ; Load message identifier MOVLW 60H ; Load SID2:SID0, EXIDE = 0 MOVWF RXB0SIDL MOVLW 24H ; Load SID10:SID3 MOVWF RXB0SIDH ; No need to load RXB0EIDL:RXB0EIDH, as we are transmitting Standard Identifier Message only. ; Now that all data bytes are loaded, mark it for transmission. MOVLW B'00001000' ; Normal priority; Request transmission MOVWF RXB0CON ; If required, wait for message to get transmitted BTFSC",
    "EXAMPLE 23-4: TRANSMITTING A CAN MESSAGE USING WIN BITS\nRXB0CON, TXREQ ; Is it transmitted? BRA $-2 ; No.\nContinue to wait... ; Message is transmitted. ; If required, reset the WIN bits to default state.\n```",
    "23.2.3 DEDICATED CAN RECEIVE BUFFER REGISTERS\nThis section shows the dedicated CAN Receive Buffer registers with their associated control registers.",
    "REGISTER 23-13: RXB0CON: RECEIVE BUFFER 0 CONTROL REGISTER\nMode 0, 1 = R/C-0. Mode 0, 2 = R/W-0. Mode 0, 3 = R/W-0. Mode 0, 4 = U-0. Mode 0, 5 = R-0. Mode 0, 6 = R/W-0. Mode 0, 7 = R-0. Mode 0, 8 = R-0. Mode 0, 1 = RXFUL. Mode 0, 2 = RXM1. Mode 0, 3 = RXM0. Mode 0, 4 = -. Mode 0, 5 = RXRTRRO. Mode 0, 6 = RXB0DBEN. Mode 0, 7 = JTOFF. Mode 0, 8 = FILHIT0",
    "REGISTER 23-13: RXB0CON: RECEIVE BUFFER 0 CONTROL REGISTER\nMode 1, 2, 1 = R/C-0. Mode 1, 2, 2 = R/W-0. Mode 1, 2, 3 = R-0. Mode 1, 2, 4 = R-0. Mode 1, 2, 5 = R-0. Mode 1, 2, 6 = R-0. Mode 1, 2, 7 = R-0. Mode 1, 2, 8 = R-0. Mode 1, 2, 1 = RXFUL. Mode 1, 2, 2 = RXM1. Mode 1, 2, 3 = RTRRO. Mode 1, 2, 4 = FILHIT4. Mode 1, 2, 5 = FILHIT3. Mode 1, 2, 6 = FILHIT2. Mode 1, 2, 7 = FILHIT1. Mode 1, 2, 8 = FILHIT0\nbit 7\nbit 0",
    "bit 7 RXFUL: Receive Full Status bit\n1 = Receive buffer contains a received message\n0 = Receive buffer is open to receive a new message\nNote:\nThis bit is set by the CAN module upon receiving a message and must be cleared by software after the buffer is read. As long as RXFUL is set, no new message will be loaded and buffer will be considered full.",
    "bit 6 Mode 0:\nRXM1: Receive Buffer Mode bit 1; combines with RXM0 to form RXM<1:0> bits (see bit 5)\n11 = Receive all messages (including those with errors); filter criteria is ignored\n10 = Receive only valid messages with extended identifier; EXIDEN in RXFnSIDL must be ' 1 '\n01 = Receive only valid messages with standard identifier, EXIDEN in RXFnSIDL must be ' 0 '\n00 = Receive all valid messages as per EXIDEN bit in RXFnSIDL register",
    "RXM1 : Receive Buffer Mode bit\n1 = Receive all messages (including those with errors); acceptance filters are ignored\n0 = Receive all valid messages as per acceptance filters",
    "bit 5 Mode 0:\nRXM0: Receive Buffer Mode bit 0; combines with RXM1 to form RXM<1:0> bits (see bit 6)",
    "Mode 1, 2:\nRTRRO: Remote Transmission Request bit for Received Message (read-only)\n1 = A remote transmission request is received\n0 = A remote transmission request is not received",
    "bit 4 Mode 0:\nUnimplemented: Read as ' 0 '",
    "Mode 1, 2:\nFILHIT4: Filter Hit bit 4\nThis bit combines with other bits to form filter acceptance bits <4:0>.",
    "bit 3 Mode 0:\nRXRTRRO: Remote Transmission Request bit for Received Message (read-only)\n1 = A remote transmission request is received\n0 = A remote transmission request is not received",
    "FILHIT3: Filter Hit bit 3\nThis bit combines with other bits to form filter acceptance bits <4:0>.\nLegend:, 1 = U = Unimplemented bit, read as '0'. Legend:, 2 = - n = Value at POR. C = Clearable bit, 1 = R = Readable bit. C = Clearable bit, 2 = x = Bit is unknown. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = ",
    "bit 2\nMode 0:\nRXB0DBEN: Receive Buffer 0 Double-Buffer Enable bit\n1 = Receive Buffer 0 overflow will write to Receive Buffer 1 0 = No Receive Buffer 0 overflow to Receive Buffer 1",
    "FILHIT2: Filter Hit bit 2\nThis bit combines with other bits to form filter acceptance bits <4:0>.",
    "bit 1 Mode 0:\nJTOFF: Jump Table Offset bit (read-only copy of RXB0DBEN)\n1 = Allows jump table offset between 6 and 7\n0 = Allows jump table offset between 1 and 0\nNote: This bit allows same filter jump table for both RXB0CON and RXB1CON.",
    "FILHIT1: Filter Hit bit 1\nThis bit combines with other bits to form filter acceptance bits <4:0>.",
    "FILHIT0: Filter Hit bit 0\nThis bit indicates which acceptance filter enabled the message reception into Receive Buffer 0.\n1 = Acceptance Filter 1 (RXF1)\n0 = Acceptance Filter 0 (RXF0)\nThis  bit,  in  combination  with  FILHIT<4:1>,  indicates  which  acceptance  filter  enabled  the message reception into this receive buffer.\n01111 = Acceptance Filter 15 (RXF15)\n01110 = Acceptance Filter 14 (RXF14)\n...\n00000 = Acceptance Filter 0 (RXF0)",
    "Legend:\nU = Unimplemented bit, read as '0'\n- n = Value at POR\nC = Clearable bit\nR = Readable bit\nW = Writable bit\nx = Bit is unknown\n'1' = Bit is set\n'0' = Bit is cleared",
    "REGISTER 23-14: RXB1CON: RECEIVE BUFFER 1 CONTROL REGISTER\nMode 0, R/C-0 = RXFUL. Mode 0, R/W-0 = RXM1. Mode 0, R/W-0 = RXM0. Mode 0, U-0 = -. Mode 0, R-0 = RXRTRRO. Mode 0, R/W-0 = FILHIT2. Mode 0, R-0 = FILHIT1. Mode 0, R-0 = FILHIT0. , R/C-0 = R/C-0. , R/W-0 = R/W-0. , R/W-0 = R-0. , U-0 = R-0. , R-0 = R-0. , R/W-0 = R-0. , R-0 = R-0. , R-0 = R-0. , R/C-0 = RXFUL. , R/W-0 = RXM1. , R/W-0 = RTRRO. , U-0 = FILHIT4. , R-0 = FILHIT3. ,",
    "REGISTER 23-14: RXB1CON: RECEIVE BUFFER 1 CONTROL REGISTER\nR/W-0 = FILHIT2. , R-0 = FILHIT1. , R-0 = FILHIT0\nbit 7\nbit 0",
    "bit 7\nRXFUL: Receive Full Status bit\n1 = Receive buffer contains a received message\n0 = Receive buffer is open to receive a new message\nNote:\nThis bit is set by the CAN module upon receiving a message and must be cleared by software after the buffer is read. As long as RXFUL is set, no new message will be loaded and buffer will be considered full.",
    "bit 6 Mode 0:\nRXM1: Receive Buffer Mode bit 1; combines with RXM0 to form RXM<1:0> bits (see bit 5)\n11 = Receive all messages (including those with errors); filter criteria is ignored\n10 = Receive only valid messages with extended identifier; EXIDEN in RXFnSIDL must be ' 1 '\n01 = Receive only valid messages with standard identifier, EXIDEN in RXFnSIDL must be ' 0 '\n00 = Receive all valid messages as per EXIDEN bit in RXFnSIDL register",
    "Mode 1, 2:\nRXM1: Receive Buffer Mode bit\n1 = Receive all messages (including those with errors); acceptance filters are ignored\n0 = Receive all valid messages as per acceptance filters",
    "bit 5 Mode 0:\nRXM0: Receive Buffer Mode bit 0; combines with RXM1 to form RXM<1:0> bits (see bit 6)",
    "Mode 1, 2:\nRTRRO: Remote Transmission Request bit for Received Message (read-only)\n1 = A remote transmission request is received\n0 = A remote transmission request is not received",
    "bit 4 Mode 0:\nUnimplemented: Read as ' 0 '",
    "Mode 1, 2:\nFILHIT4: Filter Hit bit 4\nThis bit combines with other bits to form filter acceptance bits <4:0>.",
    "bit 3 Mode 0:\nRXRTRRO: Remote Transmission Request bit for Received Message (read-only)\n1 = A remote transmission request is received\n0 = A remote transmission request is not received",
    "Mode 1, 2:\nFILHIT3: Filter Hit bit 3\nThis bit combines with other bits to form filter acceptance bits <4:0>.",
    "bit 2-0 Mode 0:\nFILHIT2:FILHIT0:\nFilter Hit bits\nThese bits indicate which acceptance filter enabled the last message reception into Receive Buffer 1.\n111 = Reserved\n110 = Reserved\n101 = Acceptance Filter 5 (RXF5)\n100 = Acceptance Filter 4 (RXF4)\n011 = Acceptance Filter 3 (RXF3)\n010 = Acceptance Filter 2 (RXF2)\n001 = Acceptance Filter 1 (RXF1), only possible when RXB0DBEN bit is set\n000 = Acceptance Filter 0 (RXF0), only possible when RXB0DBEN bit is set",
    "Mode 1, 2:\nFILHIT2:FILHIT0 Filter Hit bits <2:0>\nThese bits, in combination with FILHIT<4:3>, indicate which acceptance filter enabled the message reception into this receive buffer.\n01111 = Acceptance Filter 15 (RXF15)\n01110 = Acceptance Filter 14 (RXF14)\n...\n00000 = Acceptance Filter 0 (RXF0)",
    "Legend:\nU = Unimplemented bit, read as '0'\n- n = Value at POR\nC = Clearable bit\nR = Readable bit\nW = Writable bit\nx = Bit is unknown\n'1' = Bit is set\n'0' = Bit is cleared\nDS30491D-page 293",
    "HIGH BYTE [0 \uf0a3 n \uf0a3 1]\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = R-x. R-x, 6 = R-x. R-x, 7 = R-x. SID10, 1 = SID9. SID10, 2 = SID8. SID10, 3 = SID7. SID10, 4 = SID6. SID10, 5 = SID5. SID10, 6 = SID4. SID10, 7 = SID3\nbit 7\nbit 0\nSID10:SID3: Standard Identifier bits, if EXID = 0 (RXBnSIDL<3>);\nExtended Identifier bits EID28:EID21, if EXID = 1 .",
    "HIGH BYTE [0 \uf0a3 n \uf0a3 1]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-16: RXBnSIDL: RECEIVE BUFFER n STANDARD IDENTIFIER REGISTERS, LOW BYTE [0   n \uf0a3 \uf0a3 1]\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = U-0. R-x, 6 = R-x. R-x, 7 = R-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = SRR. SID2, 4 = EXID. SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5 SID2:SID0: Standard Identifier bits, if EXID = 0 ;\nExtended Identifier bits EID20:EID18, if EXID = 1 .",
    "bit 4\nSRR: Substitute Remote Request bit\nThis bit is always ' 0 ' when EXID = 1 or equal to the value of RXRTRRO (RBXnCON<3>) when EXID = 0 .",
    "bit 3\nEXID: Extended Identifier bit\n1 = Received message is an extended data frame, SID10:SID0 are EID28:EID18\n0 = Received message is a standard data frame\nbit 2 Unimplemented: Read as ' 0 '\nbit 1-0 EID17:EID16: Extended Identifier bits\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 23-17: RXBnEIDH: RECEIVE BUFFER n EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0 \uf0a3 n \uf0a3 1]\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = R-x. R-x, 6 = R-x. R-x, 7 = R-x. EID15, 1 = EID14. EID15, 2 = EID13. EID15, 3 = EID12. EID15, 4 = EID11. EID15, 5 = EID10. EID15, 6 = EID9. EID15, 7 = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown\nbit 7-0",
    "LOW BYTE [0   n \uf0a3 \uf0a3 1]\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = R-x. R-x, 6 = R-x. R-x, 7 = R-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 0",
    "bit 7-0 EID7:EID0: Extended Identifier bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-19: RXBnDLC: RECEIVE BUFFER n DATA LENGTH CODE REGISTERS [0   n   1] \uf0a3 \uf0a3\nU-0, 1 = R-x. U-0, 2 = R-x. U-0, 3 = R-x. U-0, 4 = R-x. U-0, 5 = R-x. U-0, 6 = R-x. U-0, 7 = R-x. -, 1 = RXRTR. -, 2 = RB1. -, 3 = RB0. -, 4 = DLC3. -, 5 = DLC2. -, 6 = DLC1. -, 7 = DLC0\nbit 7\nbit 0",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6\nRXRTR: Receiver Remote Transmission Request bit\n1 = Remote transfer request\n0 = No remote transfer request",
    "bit 5\nRB1: Reserved bit 1\nReserved by CAN Spec and read as ' 0 '.\nbit 4\nRB0: Reserved bit 0\nReserved by CAN Spec and read as ' 0 '.",
    "bit 3-0 DLC3:DLC0: Data Length Code bits\n1111 = Invalid\n1110 = Invalid\n1101 = Invalid\n1100 = Invalid\n1011 = Invalid\n1010 = Invalid\n1001 = Invalid\n1000 = Data length = 8 bytes\n0111 = Data length = 7 bytes\n0110 = Data length = 6 bytes\n0101 = Data length = 5 bytes\n0100 = Data length = 4 bytes\n0011 = Data length = 3 bytes\n0010 = Data length = 2 bytes\n0001 = Data length = 1 bytes\n0000 = Data length = 0 bytes",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-20: RXBnDm: RECEIVE BUFFER n DATA FIELD BYTE m REGISTERS\n[0 \uf0a3 n \uf0a3 1, 0 \uf0a3 m \uf0a3 7]\nRXBnDm7, R-x = RXBnDm6. RXBnDm7, R-x = RXBnDm5. RXBnDm7, R-x = RXBnDm4. RXBnDm7, R-x = RXBnDm3. RXBnDm7, R-x = RXBnDm2. RXBnDm7, R-x = RXBnDm1. RXBnDm7, R-x = RXBnDm0. bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = . bit 7, R-x = bit 0\nbit 7-0\nRXBnDm7:RXBnDm0: Receive Buffer n Data Field Byte m bits (where 0 \uf0a3\uf020 n < 1 and 0 < m < 7) Each receive buffer has an array of registers. For example, Receive Buffer 0 has 8 registers:",
    "REGISTER 23-20: RXBnDm: RECEIVE BUFFER n DATA FIELD BYTE m REGISTERS\nRXB0D0 to RXB0D7.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-21: RXERRCNT: RECEIVE ERROR COUNT REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. REC7, 1 = REC6. REC7, 2 = REC5. REC7, 3 = REC4. REC7, 4 = REC3. REC7, 5 = REC2. REC7, 6 = REC1. REC7, 7 = REC0\nbit 7\nbit 0",
    "bit 7-0 REC7:REC0: Receive Error Counter bits\nThis register contains the receive error value as defined by the CAN specifications.\nWhen RXERRCNT > 127, the module will go into an error-passive state. RXERRCNT does not have the ability to put the module in 'bus-off' state.\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "EXAMPLE 23-5: READING A CAN MESSAGE\n; Need to read a pending message from RXB0 buffer.\n; To receive any message, filter, mask and RXM1:RXM0 bits in RXB0CON registers must be ; programmed correctly.\n;\n- ; Make sure that there is a message pending in RXB0.\nBTFSS\nRXB0CON, RXFUL\n- ; Does RXB0 contain a message?\nBRA\nNoMessage\n; No.  Handle this situation...\n; We have verified that a message is pending in RXB0 buffer.\n; If this buffer can receive both Standard or Extended Identifier messages,\n; identify type of message received.\nBTFSS RXB0SIDL, EXID\nBRA\nStandardMessage\n; Is this Extended Identifier?\n; No.  This is Standard Identifier message.\n; Yes.  This is Extended Identifier message.\n; Read all 29-bits of Extended Identifier message.\n...\n- ; Now read all data bytes\nMOVFF RXB0DO, MY_DATA_BYTE1\n...",
    "EXAMPLE 23-5: READING A CAN MESSAGE\n; Once entire message is read, mark the RXB0 that it is read and no longer FULL.\nBCF\nRXB0CON, RXFUL\n; This will allow CAN Module to load new messages\n- ; into this buffer.\n...",
    "23.2.3.1 Programmable TX/RX and Auto RTR Buffers\nThe ECAN module contains 6 message buffers that can be programmed as transmit or receive buffers. Any of these buffers can also be programmed to automatically handle RTR messages.",
    "REGISTER 23-22: BnCON: TX/RX BUFFER n CONTROL REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nR/C-0, 1 = R/W-0. R/C-0, 2 = R-0. R/C-0, 3 = R-0. R/C-0, 4 = R-0. R/C-0, 5 = R-0. R/C-0, 6 = R-0. R/C-0, 7 = R-0. RXFUL, 1 = RXM1. RXFUL, 2 = RTRRO. RXFUL, 3 = FILHIT4. RXFUL, 4 = FILHIT3. RXFUL, 5 = FILHIT2. RXFUL, 6 = FILHIT1. RXFUL, 7 = FILHIT0\nbit 7\nbit 0",
    "bit 7 RXFUL: Receive Full Status bit (1)\n1 = Receive buffer contains a received message\n0 = Receive buffer is open to receive a new message\nNote:\nThis bit is set by the CAN module upon receiving a message and must be cleared by software after the buffer is read. As long as RXFUL is set, no new message will be loaded and buffer will be considered full.",
    "bit 6 RXM1: Receive Buffer Mode bit\n1 = Receive all messages including partial and invalid (acceptance filters are ignored)\n0 = Receive all valid messages as per acceptance filters",
    "bit 5 RTRRO: Read-Only Remote Transmission Request bit for Received Message\n1 = Received message is a remote transmission request\n0 = Received message is not a remote transmission request",
    "bit 4-0 FILHIT4:FILHIT0: Filter Hit bits\nThese bits indicate which acceptance filter enabled the last message reception into this buffer.\n01111 = Acceptance Filter 15 (RXF15)\n01110 = Acceptance Filter 14 (RXF14)\n...\n00001 = Acceptance Filter 1 (RXF1)\n00000 = Acceptance Filter 0 (RXF0)\nNote 1: These registers are available in Mode 1 and 2 only.\nLegend:, 1 = U = Unimplemented bit, read as '0'. Legend:, 2 = - n = Value at POR. C = Clearable bit, 1 = R = Readable bit. C = Clearable bit, 2 = x = Bit is unknown. '1' = Bit is set, 1 = '0' = Bit is cleared. '1' = Bit is set, 2 = ",
    "REGISTER 23-23: BnCON: TX/RX BUFFER n CONTROL REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 1 ] (1)\nR/W-0, 1 = R-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. TXBIF, 1 = TXABT. TXBIF, 2 = TXLARB. TXBIF, 3 = TXERR. TXBIF, 4 = TXREQ. TXBIF, 5 = RTREN. TXBIF, 6 = TXPRI1. TXBIF, 7 = TXPRI0\nbit 7\nbit 0\nbit 7\nbit 6\nbit 5\nbit 4",
    "bit 3\nTXBIF: Transmit Buffer Interrupt Flag bit (1)\n1 = A message is successfully transmitted\n0 = No message was transmitted\nTXABT: Transmission Aborted Status bit (1)\n1 = Message was aborted\n0 = Message was not aborted\nTXLARB: Transmission Lost Arbitration Status bit (2)\n1 = Message lost arbitration while being sent\n0 = Message did not lose arbitration while being sent\nTXERR: Transmission Error Detected Status bit (2)\n1 = A bus error occurred while the message was being sent\n0 = A bus error did not occur while the message was being sent\nTXREQ: Transmit Request Status bit (3)\n1 = Requests sending a message; clears the TXABT, TXLARB, and TXERR bits\n0 = Automatically cleared when the message is successfully sent\nNote:\nClearing this bit in software while the bit is set will request a message abort.",
    "bit 2 RTREN: Automatic Remote Transmission Request Enable bit\n1 = When a remote transmission request is received, TXREQ will be automatically set\n0 = When a remote transmission request is received, TXREQ will be unaffected",
    "bit 1-0 TXPRI1:TXPRI0: Transmit Priority bits (4)\n11 = Priority Level 3 (highest priority)\n10 = Priority Level 2\n01 = Priority Level 1\n00 = Priority Level 0 (lowest priority)\nNote 1: These registers are available in Mode 1 and 2 only.\n2: This bit is automatically cleared when TXREQ is set.\n3: While TXREQ is set or transmission is in progress, transmit buffer registers remain read-only.\n4: These bits set the order in which the transmit buffer will be transferred. They do not alter the CAN message identifier.",
    "Legend:\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, read as '0' = '0' = Bit is cleared. - n = Value at POR, U = Unimplemented bit, read as '0' = x = Bit is unknown",
    "REGISTER 23-24: BnSIDH: TX/RX BUFFER n STANDARD IDENTIFIER REGISTERS, HIGH BYTE IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = R-x. R-x, 6 = R-x. R-x, 7 = R-x. SID10, 1 = SID9. SID10, 2 = SID8. SID10, 3 = SID7. SID10, 4 = SID6. SID10, 5 = SID5. SID10, 6 = SID4. SID10, 7 = SID3\nbit 7\nbit 0\nbit 7-0\nSID10:SID3: Standard Identifier bits, if EXIDE (BnSIDL<3>) = 0 ;\nExtended Identifier bits EID28:EID21, if EXIDE = 1 .\nNote 1: These registers are available in Mode 1 and 2 only.",
    "REGISTER 23-24: BnSIDH: TX/RX BUFFER n STANDARD IDENTIFIER REGISTERS, HIGH BYTE IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 23-25: BnSIDH: TX/RX BUFFER n STANDARD IDENTIFIER REGISTERS, HIGH BYTE IN TRANSMIT MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 1 ] (1)\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID10, 1 = SID9. SID10, 2 = SID8. SID10, 3 = SID7. SID10, 4 = SID6. SID10, 5 = SID5. SID10, 6 = SID4. SID10, 7 = SID3\nbit 7\nbit 0\nbit 7-0 SID10:SID3: Standard Identifier bits, if EXIDE (BnSIDL<3>) = 0 ;\nExtended Identifier bits EID28:EID21, if EXIDE = 1 .",
    "REGISTER 23-25: BnSIDH: TX/RX BUFFER n STANDARD IDENTIFIER REGISTERS, HIGH BYTE IN TRANSMIT MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 1 ] (1)\nNote 1: These registers are available in Mode 1 and 2 only.\n\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "PIC18F6585/8585/6680/8680\nREGISTER 23-26:",
    "LOW BYTE IN RECEIVE MODE [0   n   5, TXnEN (BSEL0<n>) = \uf0a3 \uf0a3 0 ]\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = U-0. R-x, 6 = R-x. R-x, 7 = R-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = SRR. SID2, 4 = EXID. SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5\nSID2:SID0: Standard Identifier bits, if EXID = 0 ;\nExtended Identifier bits EID20:EID18, if EXID = 1 .\nbit 4\nSRR: Substitute Remote Transmission Request bit (only when EXID = 1 )\n1 = Remote transmission request occurred\n0 = No remote transmission request occurred",
    "bit 3 EXID: Extended Identifier Enable bit\n1 = Received message is an extended identifier frame, SID10:SID0 are EID28:EID18\n0 = Received message is a standard identifier frame\nbit 2 Unimplemented: Read as ' 0 '\nbit 1-0\nEID17:EID16:\nExtended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.\n\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-27: BnSIDL: TX/RX BUFFER n STANDARD IDENTIFIER REGISTERS, LOW BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL0<n>) = \uf0a3 \uf0a3 1 ] (1)\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = U-0. R/W-x, 4 = R/W-x. R/W-x, 5 = U-0. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = -. SID2, 4 = EXIDE. SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5\nSID2:SID0: Standard Identifier bits, if EXIDE = 0 ;\nExtended Identifier bits EID20:EID18, if EXIDE = 1 .\nbit 4 Unimplemented: Read as ' 0 '",
    "bit 3 EXIDE: Extended Identifier Enable bit\n1 = Received message is an extended identifier frame, SID10:SID0 are EID28:EID18\n0 = Received message is a standard identifier frame",
    "bit 1-0 EID17:EID16: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "HIGH BYTE IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL0<n>) = 0 ] (1)\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = R-x. R-x, 6 = R-x. R-x, 7 = R-x. EID15, 1 = EID14. EID15, 2 = EID13. EID15, 3 = EID12. EID15, 4 = EID11. EID15, 5 = EID10. EID15, 6 = EID9. EID15, 7 = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-29: BnEIDH: TX/RX BUFFER n EXTENDED IDENTIFIER REGISTERS, HIGH BYTE IN TRANSMIT MODE [0   n \uf0a3 \uf0a3 5, TXnEN (BSEL0<n>) = 1] (1)\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID15, 1 = EID14. EID15, 2 = EID13. EID15, 3 = EID12. EID15, 4 = EID11. EID15, 5 = EID10. EID15, 6 = EID9. EID15, 7 = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "PIC18F6585/8585/6680/8680\nREGISTER 23-30:",
    "LOW BYTE IN RECEIVE MODE [0   n   5, TXnEN (BSEL<n>) = \uf0a3 \uf0a3 0 ]\nR-x, 1 = R-x. R-x, 2 = R-x. R-x, 3 = R-x. R-x, 4 = R-x. R-x, 5 = R-x. R-x, 6 = R-x. R-x, 7 = R-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 0",
    "bit 7-0 EID7:EID0: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.\n\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 23-31: BnEIDL: TX/RX BUFFER n EXTENDED IDENTIFIER REGISTERS, LOW BYTE IN TRANSMIT MODE [0   n   5, TXnEN (BSEL<n>) = \uf0a3 \uf0a3 1 ] (1)\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 0",
    "bit 7-0 EID7:EID0: Extended Identifier bits\nNote 1: These registers are available in Mode 1 and 2 only.\n\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 23-32: BnDm: TX/RX BUFFER n DATA FIELD BYTE m REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 0 ] (1)\nBnDm7, R-x = BnDm6. BnDm7, R-x = BnDm5. BnDm7, R-x = BnDm4. BnDm7, R-x = BnDm3. BnDm7, R-x = BnDm2. BnDm7, R-x = BnDm1. BnDm7, R-x = BnDm0\nbit 7\nbit 0\nbit 7-0 BnDm7:BnDm0: Receive Buffer n Data Field Byte m bits (where 0 \uf0a3\uf020 n < 3 and 0 < m < 8) Each receive buffer has an array of registers. For example, Receive Buffer 0 has 7 registers: B0D0 to B0D7.",
    "REGISTER 23-32: BnDm: TX/RX BUFFER n DATA FIELD BYTE m REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 0 ] (1)\nNote 1: These registers are available in Mode 1 and 2 only.\n\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "[0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 1 ] (1)\nBnDm7, R/W-x = BnDm6. BnDm7, R/W-x = BnDm5. BnDm7, R/W-x = BnDm4. BnDm7, R/W-x = BnDm3. BnDm7, R/W-x = BnDm2. BnDm7, R/W-x = BnDm1. BnDm7, R/W-x = BnDm0\nbit 7\nbit 0\nbit 7-0\nBnDm7:BnDm0: Transmit Buffer n Data Field Byte m bits (where 0 \uf0a3\uf020 n < 3 and 0 < m < 8) Each transmit buffer has an array of registers. For example, Transmit Buffer 0 has 7 registers: TXB0D0 to TXB0D7.",
    "[0 \uf0a3 n \uf0a3 5, 0 \uf0a3 m \uf0a3 7, TXnEN (BSEL<n>) = 1 ] (1)\nNote 1: These registers are available in Mode 1 and 2 only.\n\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "PIC18F6585/8585/6680/8680\nREGISTER 23-34:",
    "BnDLC: TX/RX BUFFER n DATA LENGTH CODE REGISTERS IN RECEIVE MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL<n>) = 0 ] (1)\nU-0, 1 = R-x. U-0, 2 = R-x. U-0, 3 = R-x. U-0, 4 = R-x. U-0, 5 = R-x. U-0, 6 = R-x. U-0, 7 = R-x. -, 1 = RXRTR. -, 2 = RB1. -, 3 = RB0. -, 4 = DLC3. -, 5 = DLC2. -, 6 = DLC1. -, 7 = DLC0\nbit 7\nbit 0",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6 RXRTR: Receiver Remote Transmission Request bit\n1 = This is a remote transmission request\n0 = This is not a remote transmission request\nRB1: Reserved bit 1",
    "bit 5\nReserved by CAN Spec and read as ' 0 '.",
    "bit 4 RB0: Reserved bit 0\nReserved by CAN Spec and read as ' 0 '.",
    "bit 3-0 DLC3:DLC0: Data Length Code bits\n1111\n= Reserved\n1110 = Reserved\n1101 = Reserved\n1100 = Reserved\n1011 = Reserved\n1010 = Reserved\n1001 = Reserved\n1000 = Data length = 8 bytes\n0111 = Data length = 7 bytes\n0110 = Data length = 6 bytes\n0101 = Data length = 5 bytes\n0100 = Data length = 4 bytes\n0011 = Data length = 3 bytes\n0010 = Data length = 2 bytes\n0001 = Data length = 1 bytes\n0000 = Data length = 0 bytes\nNote 1: These registers are available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "BnDLC: TX/RX BUFFER n DATA LENGTH CODE REGISTERS IN TRANSMIT MODE [0 \uf0a3 n \uf0a3 5, TXnEN (BSEL<n>) = 1 ] (1)\nU-0, 1 = R/W-x. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-x. U-0, 5 = R/W-x. U-0, 6 = R/W-x. U-0, 7 = R/W-x. -, 1 = TXRTR. -, 2 = -. -, 3 = -. -, 4 = DLC3. -, 5 = DLC2. -, 6 = DLC1. -, 7 = DLC0\nbit 7\nbit 0",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6 TXRTR: Transmitter Remote Transmission Request bit\n1 = Transmitted message will have RTR bit set\n0 = Transmitted message will have RTR bit cleared\nbit 5-4 Unimplemented: Read as ' 0 '",
    "bit 3-0 DLC3:DLC0: Data Length Code bits\n1111 1001 - = Reserved\n1000 = Data length = 8 bytes\n0111 = Data length = 7 bytes\n0110 = Data length = 6 bytes\n0101 = Data length = 5 bytes\n0100 = Data length = 4 bytes\n0011 = Data length = 3 bytes\n0010 = Data length = 2 bytes\n0001 = Data length = 1 bytes\n0000 = Data length = 0 bytes\nNote 1: These registers are available in Mode 1 and 2 only.\n\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 23-36: BSEL0: BUFFER SELECT REGISTER 0 (1)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = U-0. R/W-0, 7 = U-0. B5TXEN, 1 = B4TXEN. B5TXEN, 2 = B3TXEN. B5TXEN, 3 = B2TXEN. B5TXEN, 4 = B1TXEN. B5TXEN, 5 = B0TXEN. B5TXEN, 6 = -. B5TXEN, 7 = -\nbit 7\nbit 0\nbit 7-2\nB5TXEN:B0TXEN: Buffer 5 to Buffer 0 Transmit Enable bit\n1 = Buffer is configured in Transmit mode\n0 = Buffer is configured in Receive mode",
    "bit 1-0\nUnimplemented: Read as ' 0 '\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "23.2.3.2 Message Acceptance Filters and Masks\nThis  subsection  describes  the  message  acceptance filters and masks for the CAN receive buffers.\nNote:, 1 = These registers are writable in Configuration mode only.",
    "REGISTER 23-37: RXFnSIDH: RECEIVE ACCEPTANCE FILTER n STANDARD IDENTIFIER FILTER REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 15] (1)\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID10, 1 = SID9. SID10, 2 = SID8. SID10, 3 = SID7. SID10, 4 = SID6. SID10, 5 = SID5. SID10, 6 = SID4. SID10, 7 = SID3\nbit 7\nbit 0\nbit 7-0\nSID10:SID3: Standard Identifier Filter bits, if EXIDEN = 0 ;\nExtended Identifier Filter bits EID28:EID21, if EXIDEN = 1 .",
    "REGISTER 23-37: RXFnSIDH: RECEIVE ACCEPTANCE FILTER n STANDARD IDENTIFIER FILTER REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 15] (1)\nNote 1: Registers RXF6SIDH:RXF15SIDH are available in Mode 1 and 2 only.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-38: RXFnSIDL: RECEIVE ACCEPTANCE FILTER n STANDARD IDENTIFIER FILTER REGISTERS, LOW BYTE [0   n   15] (1) \uf0a3 \uf0a3\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = U-0. R/W-x, 4 = R/W-x. R/W-x, 5 = U-0. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = -. SID2, 4 = EXIDEN. SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5 SID2:SID0: Standard Identifier Filter bits, if EXIDEN = 0 ;\nExtended Identifier Filter bits EID20:EID18, if EXIDEN = 1 .\nbit 4\nUnimplemented: Read as ' 0 '",
    "REGISTER 23-38: RXFnSIDL: RECEIVE ACCEPTANCE FILTER n STANDARD IDENTIFIER FILTER REGISTERS, LOW BYTE [0   n   15] (1) \uf0a3 \uf0a3\nbit 3 EXIDEN: Extended Identifier Filter Enable bit\n1 = Filter will only accept extended ID messages\n0 = Filter will only accept standard ID messages\nNote:\nIn Mode 0, this bit must be set/cleared as required, irrespective of corresponding mask register value.",
    "bit 2 Unimplemented: Read as ' 0 '\nbit 1-0 EID17:EID16: Extended Identifier Filter bits\nNote 1: Registers RXF6SIDL:RXF15SIDL are available in Mode 1 and 2 only.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-39: RXFnEIDH: RECEIVE ACCEPTANCE FILTER n EXTENDED IDENTIFIER REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 15] (1)\nEID15, R/W-x = EID14. EID15, R/W-x = EID13. EID15, R/W-x = EID12. EID15, R/W-x = EID11. EID15, R/W-x = EID10. EID15, R/W-x = EID9. EID15, R/W-x = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier Filter bits\nNote 1: Registers RXF6EIDH:RXF15EIDH are available in Mode 1 and 2 only.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-40: RXFnEIDL: RECEIVE ACCEPTANCE FILTER n EXTENDED IDENTIFIER REGISTERS, LOW BYTE [0   n   15] (1) \uf0a3 \uf0a3\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 0",
    "bit 7-0 EID7:EID0: Extended Identifier Filter bits\nNote 1: Registers RXF6EIDL:RXF15EIDL are available in Mode 1 and 2 only.\n\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-41: RXMnSIDH: RECEIVE ACCEPTANCE MASK n STANDARD IDENTIFIER MASK REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 1]\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID10, 1 = SID9. SID10, 2 = SID8. SID10, 3 = SID7. SID10, 4 = SID6. SID10, 5 = SID5. SID10, 6 = SID4. SID10, 7 = SID3\nbit 7\nbit 0",
    "bit 7-0 SID10:SID3: Standard Identifier Mask bits, or Extended Identifier Mask bits EID28:EID21\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "PIC18F6585/8585/6680/8680\nREGISTER 23-42:",
    "RXMnSIDL: RECEIVE ACCEPTANCE MASK n STANDARD IDENTIFIER MASK REGISTERS, LOW BYTE [0   n   1] \uf0a3 \uf0a3\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = U-0. R/W-x, 4 = R/W-0. R/W-x, 5 = U-0. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = -. SID2, 4 = EXIDEN (1). SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5\nSID2:SID0: Standard Identifier Mask bits, or Extended Identifier Mask bits EID20:EID18\nbit 4\nUnimplemented: Read as ' 0 '\nbit 3\nMode 0:\nUnimplemented: Read as ' 0 '\nMode 1, 2:",
    "RXMnSIDL: RECEIVE ACCEPTANCE MASK n STANDARD IDENTIFIER MASK REGISTERS, LOW BYTE [0   n   1] \uf0a3 \uf0a3\nEXIDEN: Extended Identifier Filter Enable Mask bit (1)\n1 = Messages selected by EXIDEN bit in RXFnSIDL will be accepted\n0 = Both standard and extended identifier messages will be accepted\nNote 1: This bit is available in Mode 1 and 2 only.\nbit 2 Unimplemented: Read as ' 0 '\nbit 1-0\nEID17:EID16: Extended Identifier Mask bits\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 23-43: RXMnEIDH: RECEIVE ACCEPTANCE MASK n EXTENDED IDENTIFIER MASK REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 1]\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID15, 1 = EID14. EID15, 2 = EID13. EID15, 3 = EID12. EID15, 4 = EID11. EID15, 5 = EID10. EID15, 6 = EID9. EID15, 7 = EID8\nbit 7\nbit 0\nbit 7-0\nEID15:EID8:\nExtended Identifier Mask bits",
    "REGISTER 23-43: RXMnEIDH: RECEIVE ACCEPTANCE MASK n EXTENDED IDENTIFIER MASK REGISTERS, HIGH BYTE [0   n \uf0a3 \uf0a3 1]\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-44: RXMnEIDL: RECEIVE ACCEPTANCE MASK n EXTENDED IDENTIFIER MASK REGISTERS, LOW BYTE [0   n   1] \uf0a3 \uf0a3\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 0",
    "bit 7-0 EID7:EID0: Extended Identifier Mask bits\n- n = Value at POR, W=Writable bit = '1' = Bit is set. - n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. - n = Value at POR, read as '0' = x = Bit is unknown",
    "REGISTER 23-45: SDFLC: STANDARD DATA BYTES FILTER LENGTH COUNT REGISTER (1)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = FLC4. -, 4 = FLC3. -, 5 = FLC2. -, 6 = FLC1. -, 7 = FLC0\nbit 7\nbit 0\nbit 7-5 Unimplemented: Read as ' 0 '",
    "bit 4-0 FLC4:FLC0: Filter Length Count bits\nMode 0:\nNot used; forced to ' 00000 '.",
    "Mode 1, 2:\n00000 10010 - = 0 18 bits are available for standard data byte filter. Actual number of bits\nused depends on DLC3:DLC0 bits (RXBnDLC<3:0> or BnDLC<3:0> if configured as RX buffer) of message being received.\nIf DLC3:DLC0 = 0000 No bits will be compared with incoming data bits\nIf DLC3:DLC0 = 0001\nUp to 8 data bits of RXFnEID<7:0>, as determined by FLC2:FLC0, will be  compared  with  the  corresponding  number  of  data  bits  of  the incoming message\nIf DLC3:DLC0 = 0010\nUp to 16 data bits of RXFnEID<15:0>, as determined by FLC3:FLC0, will  be  compared  with  the  corresponding  number  of  data  bits  of  the incoming message\nIf DLC3:DLC0 = 0011 Up to 18 data bits of RXFnEID<17:0>, as determined by FLC4:FLC0,\nwill  be  compared  with  the  corresponding  number  of  data  bits  of  the incoming message",
    "Mode 1, 2:\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-46: RXFCONn: RECEIVE FILTER CONTROL REGISTER n [0   n   1] (1) \uf0a3 \uf0a3\nRXFCON0, R/W-0 = RXF7EN. RXFCON0, R/W-0 = RXF6EN. RXFCON0, R/W-1 = RXF5EN. RXFCON0, R/W-1 = RXF4EN. RXFCON0, R/W-1 = RXF3EN. RXFCON0, R/W-1 = RXF2EN. RXFCON0, R/W-1 = RXF1EN. RXFCON0, R/W-1 = RXF0EN. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-1 = R/W-0. , R/W-1 = R/W-1. , R/W-1 = R/W-0. , R/W-1 = R/W-0. , R/W-1 =",
    "REGISTER 23-46: RXFCONn: RECEIVE FILTER CONTROL REGISTER n [0   n   1] (1) \uf0a3 \uf0a3\nR/W-0. , R/W-1 = R/W-0. , R/W-0 = RXF15EN. , R/W-0 = RXF14EN. , R/W-1 = RXF13EN. , R/W-1 = RXF12EN. , R/W-1 = RXF11EN. , R/W-1 = RXF10EN. , R/W-1 = RXF9EN. , R/W-1 = RXF8EN. , R/W-0 = bit 7. , R/W-0 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = bit 0",
    "bit 7-0 RXFnEN: Receive Filter n Enable bit\n0 = Filter is disabled\n1 = Filter is enabled\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\n, R/W-0 = F1BP_3. , R/W-0 = F1BP_2. , R/W-0 = F1BP_1. , R/W-0 = F1BP_0. , R/W-0 = F0BP_3. , R/W-0 = F0BP_2. , R/W-0 = F0BP_1. , R/W-0 = F0BP_0. RXFBCON1, R/W-0 = R/W-0. RXFBCON1, R/W-0 = R/W-0. RXFBCON1, R/W-0 = R/W-0. RXFBCON1, R/W-0 = R/W-1. RXFBCON1, R/W-0 = R/W-0. RXFBCON1, R/W-0 = R/W-0. RXFBCON1, R/W-0 = R/W-0.",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nRXFBCON1, R/W-0 = R/W-1. RXFBCON1, R/W-0 = F3BP_3. RXFBCON1, R/W-0 = F3BP_2. RXFBCON1, R/W-0 = F3BP_1. RXFBCON1, R/W-0 = F3BP_0. RXFBCON1, R/W-0 = F2BP_3. RXFBCON1, R/W-0 = F2BP_2. RXFBCON1, R/W-0 = F2BP_1. RXFBCON1, R/W-0 = F2BP_0. RXFBCON2, R/W-0 = R/W-0. RXFBCON2, R/W-0 = R/W-0. RXFBCON2, R/W-0 = R/W-0. RXFBCON2, R/W-0 =",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nR/W-1. RXFBCON2, R/W-0 = R/W-0. RXFBCON2, R/W-0 = R/W-0. RXFBCON2, R/W-0 = R/W-0. RXFBCON2, R/W-0 = R/W-1. RXFBCON2, R/W-0 = F5BP_3. RXFBCON2, R/W-0 = F5BP_2. RXFBCON2, R/W-0 = F5BP_1. RXFBCON2, R/W-0 = F5BP_0. RXFBCON2, R/W-0 = F4BP_3. RXFBCON2, R/W-0 = F4BP_2. RXFBCON2, R/W-0 = F4BP_1. RXFBCON2, R/W-0 = F4BP_0. RXFBCON3,",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nR/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = R/W-0. RXFBCON3, R/W-0 = F7BP_3. RXFBCON3, R/W-0 = F7BP_2. RXFBCON3, R/W-0 = F7BP_1. RXFBCON3, R/W-0 = F7BP_0. RXFBCON3, R/W-0 = F6BP_3.",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nRXFBCON3, R/W-0 = F6BP_2. RXFBCON3, R/W-0 = F6BP_1. RXFBCON3, R/W-0 = F6BP_0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = F9BP_3. , R/W-0 = F9BP_2. , R/W-0 = F9BP_1. , R/W-0 = F9BP_0. , R/W-0 = F8BP_3. ,",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nR/W-0 = F8BP_2. , R/W-0 = F8BP_1. , R/W-0 = F8BP_0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = F11BP_3. , R/W-0 = F11BP_2. , R/W-0 = F11BP_1. , R/W-0 = F11BP_0. , R/W-0 = F10BP_3. , R/W-0 = F10BP_2. , R/W-0 =",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nF10BP_1. , R/W-0 = F10BP_0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = F13BP_3. , R/W-0 = F13BP_2. , R/W-0 = F13BP_1. , R/W-0 = F13BP_0. , R/W-0 = F12BP_3. , R/W-0 = F12BP_2. , R/W-0 = F12BP_1. , R/W-0 =",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nF12BP_0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = R/W-0. , R/W-0 = F15BP_3. , R/W-0 = F15BP_2. , R/W-0 = F15BP_1. , R/W-0 = F15BP_0. , R/W-0 = F14BP_3. , R/W-0 = F14BP_2. , R/W-0 = F14BP_1. , R/W-0 = F14BP_0. , R/W-0 = bit 7. ,",
    "REGISTER 23-47: RXFBCONn: RECEIVE FILTER BUFFER CONTROL REGISTER n (1)\nR/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = . , R/W-0 = bit 0",
    "bit 7-0 FnBP_3:FnBP_0: Filter n Buffer Pointer Nibble bits\n0000 = Filter n is associated with RXB0\n0001 = Filter n is associated with RXB1\n0010 = Filter n is associated with B0\n0011 = Filter n is associated with B1\n.\n.\n.\n0111 = Filter n is associated with B5\n1111:1000\n= Reserved\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-48: MSEL0: MASK SELECT REGISTER 0 (1)\nR/W-0, 1 = R/W-1. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. FIL3_1, 1 = FIL3_0. FIL3_1, 2 = FIL2_1. FIL3_1, 3 = FIL2_0. FIL3_1, 4 = FIL1_1. FIL3_1, 5 = FIL1_0. FIL3_1, 6 = FIL0_1. FIL3_1, 7 = FIL0_0\nbit 7\nbit 0\nbit 7-6 FIL3_1:FIL3_0: Filter 3 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "REGISTER 23-48: MSEL0: MASK SELECT REGISTER 0 (1)\nbit 5-4 FIL2_1:FIL2_0: Filter 2 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 3-2 FIL1_1:FIL1_0: Filter 1 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 1-0 FIL0_1:FIL0_0: Filter 0 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-49: MSEL1: MASK SELECT REGISTER 1 (1)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-1. FIL7_1, 1 = FIL7_0. FIL7_1, 2 = FIL6_1. FIL7_1, 3 = FIL6_0. FIL7_1, 4 = FIL5_1. FIL7_1, 5 = FIL5_0. FIL7_1, 6 = FIL4_1. FIL7_1, 7 = FIL4_0\nbit 7\nbit 0",
    "bit 7-6 FIL7_1:FIL7_0: Filter 7 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 5-4 FIL6_1:FIL6_0: Filter 6 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 3-2 FIL5_1:FIL5_0: Filter 5 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 1-0 FIL4_1:FIL4_0: Filter 4 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-50: MSEL2: MASK SELECT REGISTER 2 (1)\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nFIL11_1\nFIL11_0\nFIL10_1\nFIL10_0\nFIL9_1\nFIL9_0\nFIL8_1\nFIL8_0\nbit 7\nbit 0\nbit 7-6 FIL11_1:FIL11_0: Filter 11 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 5-4 FIL10_1:FIL10_0: Filter 10 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 3-2 FIL9_1:FIL9_0: Filter 9 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nbit 1-0 FIL8_1:FIL8_0: Filter 8 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-51:\nMSEL3: MASK SELECT REGISTER 3 (1)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. FIL15_1, 1 = FIL15_0. FIL15_1, 2 = FIL14_1. FIL15_1, 3 = FIL14_0. FIL15_1, 4 = FIL13_1. FIL15_1, 5 = FIL13_0. FIL15_1, 6 = FIL12_1. FIL15_1, 7 = FIL12_0\nbit 7\nbit 0\nbit 7-6 FIL15_1:FIL15_0: Filter 15 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "REGISTER 23-51:\nbit 5-4 FIL14_1:FIL14_0: Filter 14 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 3-2 FIL13_1:FIL13_0: Filter 13 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0",
    "bit 1-0 FIL12_1:FIL12_0: Filter 12 Select bits 1 and 0\n11 = No mask\n10 = Filter 15\n01 = Acceptance Mask 1\n00 = Acceptance Mask 0\nNote 1: This register is available in Mode 1 and 2 only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "23.2.4 CAN BAUD RATE REGISTERS\nThis subsection describes the CAN  Baud Rate registers.\nNote:, 1 = These registers are writable in Configuration mode only.",
    "REGISTER 23-52: BRGCON1: BAUD RATE CONTROL REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. SJW1, 1 = SJW0. SJW1, 2 = BRP5. SJW1, 3 = BRP4. SJW1, 4 = BRP3. SJW1, 5 = BRP2. SJW1, 6 = BRP1. SJW1, 7 = BRP0\nbit 7\nbit 0\nbit 7-6\nSJW1:SJW0: Synchronized Jump Width bits\n11 = Synchronization jump width time = 4 x TQ\n10 = Synchronization jump width time = 3 x TQ\n01 = Synchronization jump width time = 2 x TQ",
    "REGISTER 23-52: BRGCON1: BAUD RATE CONTROL REGISTER 1\n00 = Synchronization jump width time = 1 x TQ\nbit 5-0 BRP5:BRP0: Baud Rate Prescaler bits\n111111\n= TQ = (2 x 64)/FOSC = TQ = (2 x 63)/FOSC\n111110\n.\n.\n.\n000001 = TQ = (2 x 2)/FOSC\n000000\n= TQ = (2 x 1)/FOSC",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-53: BRGCON2: BAUD RATE CONTROL REGISTER 2\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. SEG2PHTS, 1 = SAM. SEG2PHTS, 2 = SEG1PH2 SEG1PH1. SEG2PHTS, 3 = SEG1PH0. SEG2PHTS, 4 = PRSEG2. SEG2PHTS, 5 = PRSEG1. SEG2PHTS, 6 = PRSEG0\nbit 7\nbit 0",
    "bit 7 SEG2PHTS: Phase Segment 2 Time Select bit\n1 = Freely programmable\n0 = Maximum of PHEG1 or Information Processing Time (IPT), whichever is greater\nSAM: Sample of the CAN bus Line bit\n1 = Bus line is sampled three times prior to the sample point\n0 = Bus line is sampled once at the sample point",
    "bit 5-3 SEG1PH2:SEG1PH0: Phase Segment 1 bits\n111 = Phase Segment 1 time = 8 x TQ\n110 = Phase Segment 1 time = 7 x TQ\n101 = Phase Segment 1 time = 6 x TQ\n100 = Phase Segment 1 time = 5 x TQ\n011 = Phase Segment 1 time = 4 x TQ\n010 = Phase Segment 1 time = 3 x TQ\n001 = Phase Segment 1 time = 2 x TQ\n000 = Phase Segment 1 time = 1 x TQ",
    "bit 2-0 PRSEG2:PRSEG0: Propagation Time Select bits\n111 = Propagation time = 8 x TQ\n110 = Propagation time = 7 x TQ\n101 = Propagation time = 6 x TQ\n100 = Propagation time = 5 x TQ\n011 = Propagation time = 4 x TQ\n010 = Propagation time = 3 x TQ\n001 = Propagation time = 2 x TQ\n000 = Propagation time = 1 x TQ",
    "Legend:\nR = Readable bit\n- n = Value at POR\nW = Writable bit\n'1' = Bit is set",
    "bit 6\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "REGISTER 23-54: BRGCON3: BAUD RATE CONTROL REGISTER 3\nR/W-0\nR/W-0\nU-0\nU-0\nU-0\nR/W-0\nR/W-0\nR/W-0\nWAKDIS\nWAKFIL\n-\n-\n-\nSEG2PH2 (1)\nSEG2PH1\n(1)\nSEG2PH0 (1)\nbit 7\nbit 0",
    "bit 7 WAKDIS: Wake-up Disable bit\n1 = Disable CAN bus activity wake-up feature\n0 = Enable CAN bus activity wake-up feature\nbit 6 WAKFIL: Selects CAN bus Line Filter for Wake-up bit\n1 = Use CAN bus line filter for wake-up\n0 = CAN bus line filter is not used for wake-up\nbit 5-3 Unimplemented: Read as ' 0 '",
    "bit 2-0 SEG2PH2:SEG2PH0: Phase Segment 2 Time Select bits (1)\n111 = Phase Segment 2 time = 8 x TQ\n110 = Phase Segment 2 time = 7 x TQ\n101 = Phase Segment 2 time = 6 x TQ\n100 = Phase Segment 2 time = 5 x TQ\n011 = Phase Segment 2 time = 4 x TQ\n010 = Phase Segment 2 time = 3 x TQ\n001 = Phase Segment 2 time = 2 x TQ\n000 = Phase Segment 2 time = 1 x TQ\nNote 1: Ignored if SEG2PHTS bit (BRGCON2<7>) is ' 0 '.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "23.2.5 CAN MODULE I/O CONTROL REGISTER\nThis register controls the operation of the CAN module's\nI/O pins in relation to the rest of the microcontroller.",
    "REGISTER 23-55: CIOCON: CAN I/O CONTROL REGISTER\n, R/W-0.TX2SRC = bit 7. , R/W-0.TX2EN = . , R/W-0.ENDRHI = . , R/W-0.CANCAP = . , U-0.- = . , U-0.- = . , U-0.- = . , U-0.- = bit 0. bit 7, R/W-0.TX2SRC = TX2SRC : CANTX2 Pin Data Source bit 1 = CANTX2 pin will output the CAN clock = CANTX2 pin will output CANTX1. bit 7, R/W-0.TX2EN = TX2SRC : CANTX2 Pin Data Source bit 1 = CANTX2 pin will output the CAN clock = CANTX2 pin will output CANTX1. bit 7, R/W-0.ENDRHI = TX2SRC : CANTX2 Pin Data Source bit 1 = CANTX2 pin will output the CAN clock = CANTX2 pin will output CANTX1. bit 7,",
    "REGISTER 23-55: CIOCON: CAN I/O CONTROL REGISTER\nR/W-0.CANCAP = TX2SRC : CANTX2 Pin Data Source bit 1 = CANTX2 pin will output the CAN clock = CANTX2 pin will output CANTX1. bit 7, U-0.- = TX2SRC : CANTX2 Pin Data Source bit 1 = CANTX2 pin will output the CAN clock = CANTX2 pin will output CANTX1. bit 7, U-0.- = TX2SRC : CANTX2 Pin Data Source bit 1 = CANTX2 pin will output the CAN clock = CANTX2 pin will output CANTX1. bit 7, U-0.- = TX2SRC : CANTX2 Pin Data Source bit 1 = CANTX2 pin will output the CAN clock = CANTX2 pin will output CANTX1. bit 7, U-0.- = TX2SRC : CANTX2 Pin Data Source bit 1 = CANTX2 pin will output the CAN clock = CANTX2 pin will output CANTX1. bit 6,",
    "REGISTER 23-55: CIOCON: CAN I/O CONTROL REGISTER\nR/W-0.TX2SRC = TX2EN : CANTX2 Pin Enable bit 1 = CANTX2 pin will output CANTX1 or CAN clock as selected by TX2SRC bit 0 = CANTX2 pin will have digital I/O function. bit 6, R/W-0.TX2EN = TX2EN : CANTX2 Pin Enable bit 1 = CANTX2 pin will output CANTX1 or CAN clock as selected by TX2SRC bit 0 = CANTX2 pin will have digital I/O function. bit 6, R/W-0.ENDRHI = TX2EN : CANTX2 Pin Enable bit 1 = CANTX2 pin will output CANTX1 or CAN clock as selected by TX2SRC bit 0 = CANTX2 pin will have digital I/O function. bit 6, R/W-0.CANCAP = TX2EN : CANTX2 Pin Enable bit 1 = CANTX2 pin will output CANTX1 or CAN clock as selected by TX2SRC bit 0 = CANTX2 pin",
    "REGISTER 23-55: CIOCON: CAN I/O CONTROL REGISTER\nwill have digital I/O function. bit 6, U-0.- = TX2EN : CANTX2 Pin Enable bit 1 = CANTX2 pin will output CANTX1 or CAN clock as selected by TX2SRC bit 0 = CANTX2 pin will have digital I/O function. bit 6, U-0.- = TX2EN : CANTX2 Pin Enable bit 1 = CANTX2 pin will output CANTX1 or CAN clock as selected by TX2SRC bit 0 = CANTX2 pin will have digital I/O function. bit 6, U-0.- = TX2EN : CANTX2 Pin Enable bit 1 = CANTX2 pin will output CANTX1 or CAN clock as selected by TX2SRC bit 0 = CANTX2 pin will have digital I/O function. bit 6, U-0.- = TX2EN : CANTX2 Pin Enable bit 1 = CANTX2 pin will output CANTX1 or CAN clock as selected by TX2SRC bit 0 = CANTX2 pin will have digital",
    "REGISTER 23-55: CIOCON: CAN I/O CONTROL REGISTER\nI/O function. bit 5, R/W-0.TX2SRC = ENDRHI: Enable Drive High bit (1) 1 = CANTX pin will drive VDD when recessive = CANTX pin will be tri-state when recessive. bit 5, R/W-0.TX2EN = ENDRHI: Enable Drive High bit (1) 1 = CANTX pin will drive VDD when recessive = CANTX pin will be tri-state when recessive. bit 5, R/W-0.ENDRHI = ENDRHI: Enable Drive High bit (1) 1 = CANTX pin will drive VDD when recessive = CANTX pin will be tri-state when recessive. bit 5, R/W-0.CANCAP = ENDRHI: Enable Drive High bit (1) 1 = CANTX pin will drive VDD when recessive = CANTX pin will be tri-state when recessive. bit 5, U-0.- = ENDRHI: Enable Drive High bit (1) 1 = CANTX pin will drive VDD when",
    "REGISTER 23-55: CIOCON: CAN I/O CONTROL REGISTER\nrecessive = CANTX pin will be tri-state when recessive. bit 5, U-0.- = ENDRHI: Enable Drive High bit (1) 1 = CANTX pin will drive VDD when recessive = CANTX pin will be tri-state when recessive. bit 5, U-0.- = ENDRHI: Enable Drive High bit (1) 1 = CANTX pin will drive VDD when recessive = CANTX pin will be tri-state when recessive. bit 5, U-0.- = ENDRHI: Enable Drive High bit (1) 1 = CANTX pin will drive VDD when recessive = CANTX pin will be tri-state when recessive. bit 4, R/W-0.TX2SRC = CANCAP: CAN Message Receive Capture Enable bit. bit 4, R/W-0.TX2EN = CANCAP: CAN Message Receive Capture Enable bit. bit 4, R/W-0.ENDRHI = CANCAP: CAN Message Receive Capture Enable bit. bit 4, R/W-0.CANCAP =",
    "REGISTER 23-55: CIOCON: CAN I/O CONTROL REGISTER\nCANCAP: CAN Message Receive Capture Enable bit. bit 4, U-0.- = CANCAP: CAN Message Receive Capture Enable bit. bit 4, U-0.- = CANCAP: CAN Message Receive Capture Enable bit. bit 4, U-0.- = CANCAP: CAN Message Receive Capture Enable bit. bit 4, U-0.- = CANCAP: CAN Message Receive Capture Enable bit. bit 3-0, R/W-0.TX2SRC = Unimplemented: Read as ' 0 '. bit 3-0, R/W-0.TX2EN = Unimplemented: Read as ' 0 '. bit 3-0, R/W-0.ENDRHI = Unimplemented: Read as ' 0 '. bit 3-0, R/W-0.CANCAP = Unimplemented: Read as ' 0 '. bit 3-0, U-0.- = Unimplemented: Read as ' 0 '. bit 3-0, U-0.- = Unimplemented: Read as ' 0 '. bit",
    "REGISTER 23-55: CIOCON: CAN I/O CONTROL REGISTER\n3-0, U-0.- = Unimplemented: Read as ' 0 '. bit 3-0, U-0.- = Unimplemented: Read as ' 0 '. , R/W-0.TX2SRC = Note 1: Always set this bit. , R/W-0.TX2EN = when using differential bus to avoid signal crosstalk in CANTX from other nearby pins.. , R/W-0.ENDRHI = when using differential bus to avoid signal crosstalk in CANTX from other nearby pins.. , R/W-0.CANCAP = when using differential bus to avoid signal crosstalk in CANTX from other nearby pins.. , U-0.- = when using differential bus to avoid signal crosstalk in CANTX from other nearby pins.. , U-0.- = when using differential bus to avoid signal crosstalk in CANTX from other nearby pins.. , U-0.- = when using differential bus to avoid signal crosstalk in CANTX from other nearby pins.. , U-0.- = when using",
    "REGISTER 23-55: CIOCON: CAN I/O CONTROL REGISTER\ndifferential bus to avoid signal crosstalk in CANTX from other nearby pins.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "23.2.6 CAN INTERRUPT REGISTERS\nThe registers in this section are the same as described in Section 9.0 'Interrupts' . They are duplicated here for convenience.",
    "REGISTER 23-56: PIR3: PERIPHERAL INTERRUPT FLAG REGISTER\nIRXIF, R/W-0 = WAKIF. IRXIF, R/W-0 = ERRIF. IRXIF, R/W-0 = TXB2IF/ TXBnIF. IRXIF, R/W-0 = TXB1IF (1). IRXIF, R/W-0 = TXB0IF (1). IRXIF, R/W-0 = RXB1IF/ RXBnIF. IRXIF, R/W-0 = RXB0IF/ FIFOWMIF\nbit 7\nbit 0\nIRXIF: CAN Invalid Received Message Interrupt Flag bit\n1 = An invalid message has occurred on the CAN bus\n0 = No invalid message on CAN bus\nWAKIF: CAN bus Activity Wake-up Interrupt Flag bit\n1 = Activity on CAN bus has occurred\n0 = No activity on CAN bus",
    "bit 5 ERRIF:\nCAN bus Error Interrupt Flag bit\n1 = An error has occurred in the CAN module (multiple sources)\n- 0 = No CAN module errors",
    "bit 4 When CAN is in Mode 0:\nTXB2IF: CAN Transmit Buffer 2 Interrupt Flag bit\n- 1 = Transmit Buffer 2 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 2 has not completed transmission of a message\nWhen CAN is in Mode 1 or 2:\nTXBnIF: Any Transmit Buffer Interrupt Flag bit\n1 = One or more transmit buffers has completed transmission of a message and may be reloaded\n0 = No transmit buffer is ready for reload",
    "bit 3 TXB1IF: CAN Transmit Buffer 1 Interrupt Flag bit\n(1)\n1 = Transmit Buffer 1 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 1 has not completed transmission of a message\nTXB0IF: CAN Transmit Buffer 0 Interrupt Flag bit (1)\n1 = Transmit Buffer 0 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 0 has not completed transmission of a message",
    "bit 1 When CAN is in Mode 0:\nRXB1IF: CAN Receive Buffer 1 Interrupt Flag bit\n1 = Receive Buffer 1 has received a new message\n0 = Receive Buffer 1 has not received a new message\nWhen CAN is in Mode 1 or 2:\nRXBnIF: Any Receive Buffer Interrupt Flag bit\n1 = One or more receive buffers has received a new message\n0 = No receive buffer has received a new message",
    "bit 0 When CAN is in Mode 0:\nRXB0IF: CAN Receive Buffer 0 Interrupt Flag bit\n1 = Receive Buffer 0 has received a new message\n0 = Receive Buffer 0 has not received a new message",
    "When CAN is in Mode 1:\nUnimplemented: Read as ' 0 '\nWhen CAN is in Mode 2:\nFIFOWMIF: FIFO Watermark Interrupt Flag bit\n1 = FIFO high watermark is reached\n0 = FIFO high watermark is not reached\nNote 1: In CAN Mode 1 and 2, this bit is forced to ' 0 '.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 23-57: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IRXIE, 1 = WAKIE. IRXIE, 2 = ERRIE. IRXIE, 3 = TXB2IE/ TXBnIE. IRXIE, 4 = TXB1IE (1). IRXIE, 5 = TXB0IE (1). IRXIE, 6 = RXB1IE/ RXBnIE. IRXIE, 7 = RXB0IE/ FIFOWMIE\nbit 7\nbit 7\nbit 6",
    "bit 5\nbit 0\nIRXIE: CAN Invalid Received Message Interrupt Enable bit\n1 = Enable invalid message received interrupt\n0 = Disable invalid message received interrupt\nWAKIE: CAN bus Activity Wake-up Interrupt Enable bit\n1 = Enable bus activity wake-up interrupt\n0 = Disable bus activity wake-up interrupt\nERRIE: CAN bus Error Interrupt Enable bit\n1 = Enable CAN bus error interrupt\n0 = Disable CAN bus error interrupt",
    "bit 4 When CAN is in Mode 0:\nTXB2IE: CAN Transmit Buffer 2 Interrupt Enable bit\n1 = Enable Transmit Buffer 2 interrupt\n0 = Disable Transmit Buffer 2 interrupt",
    "When CAN is in Mode 1 or 2:\nTXBnIE: CAN Transmit Buffer Interrupts Enable bit\n1 = Enable transmit buffer interrupt; individual interrupt is enabled by TXBIE and BIE0\n0 = Disable all transmit buffer interrupts\nTXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit (1)\n1 = Enable Transmit Buffer 1 interrupt\n0 = Disable Transmit Buffer 1 interrupt\nTXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit (1)\n1 = Enable Transmit Buffer 0 interrupt\n0 = Disable Transmit Buffer 0 interrupt",
    "bit 1 When CAN is in Mode 0:\nRXB1IE: CAN Receive Buffer 1 Interrupt Enable bit\n1 = Enable Receive Buffer 1 interrupt\n0 = Disable Receive Buffer 1 interrupt",
    "When CAN is in Mode 1 or 2:\nRXBnIE: CAN Receive Buffer Interrupts Enable bit\n1 = Enable receive buffer interrupt; individual interrupt is enabled by BIE0\n0 = Disable all receive buffer interrupts",
    "bit 0 When CAN is in Mode 0:\nRXB0IE: CAN Receive Buffer 0 Interrupt Enable bit\n1 = Enable Receive Buffer 0 interrupt\n0 = Disable Receive Buffer 0 interrupt\nWhen CAN is in Mode 1:\nUnimplemented: Read as ' 0 '",
    "When CAN is in Mode 2:\nFIFOWMIE: FIFO Watermark Interrupt Enable bit\n1 = Enable FIFO watermark interrupt\n0 = Disable FIFO watermark interrupt\nNote 1: In CAN Mode 1 and 2, this bit is forced to ' 0 '.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\n- bit 3\nbit 2",
    "REGISTER 23-58: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER\nIRXIP, R/W-1 = WAKIP. IRXIP, R/W-1 = ERRIP. IRXIP, R/W-1 = TXB2IP/ TXBnIP. IRXIP, R/W-1 = TXB1IP (1). IRXIP, R/W-1 = TXB0IP (1). IRXIP, R/W-1 = RXB1IP/ RXBnIP. IRXIP, R/W-1 = RXB0IP/ FIFOWMIP\nbit 7\nbit 7\nbit 6\nbit 5",
    "bit 4\nbit 3\nbit 2",
    "bit 0\nbit 0\nIRXIP: CAN Invalid Received Message Interrupt Priority bit\n1 = High priority\n0 = Low priority\nWAKIP: CAN bus Activity Wake-up Interrupt Priority bit\n1 = High priority\n0 = Low priority\nERRIP: CAN bus Error Interrupt Priority bit\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 0:\nTXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 1 or 2:\nTXBnIP: CAN Transmit Buffer Interrupt Priority bit\n1 = High priority\n0 = Low priority\nTXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit (1)\n1 = High priority\n0 = Low priority\nTXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit (1)\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 0:\nRXB1IP: CAN Receive Buffer 1 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 1 or 2:\nRXBnIP: CAN Receive Buffer Interrupts Priority bit\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 0:\nRXB0IP: CAN Receive Buffer 0 Interrupt Priority bit\n1 = High priority\n0 = Low priority\nWhen CAN is in Mode 1:",
    "bit 0\nUnimplemented: Read as ' 0 '\nWhen CAN is in Mode 2:\nFIFOWMIP: FIFO Watermark Interrupt Priority bit\n1 = High priority\n0 = Low priority\nNote 1: In CAN Mode 1 and 2, this bit is forced to ' 0 '.\nLegend:\nR = Readable bit\n- n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "REGISTER 23-59: TXBIE: TRANSMIT BUFFERS INTERRUPT ENABLE REGISTER (1)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = U-0. U-0, 7 = U-0. -, 1 = -. -, 2 = -. -, 3 = TXB2IE. -, 4 = TXB1IE. -, 5 = TXB0IE. -, 6 = -. -, 7 = -\nbit 7\nbit 0\nbit 7-5\nUnimplemented:\nRead as ' 0 '\nbit 4-2\nTX2BIE:TXB0IE: Transmit Buffer 2-0 Interrupt Enable bit (2)\n1 = Transmit buffer interrupt is enabled\n0 = Transmit buffer interrupt is disabled",
    "bit 1-0 Unimplemented: Read as ' 0 '\nNote 1: This register is available in Mode 1 and 2 only.\n- 2: TXBIE in PIE3 register must be set to get an interrupt.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 23-60: BIE0: BUFFER INTERRUPT ENABLE REGISTER 0 (1)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. B5IE, 1 = B4IE. B5IE, 2 = B3IE. B5IE, 3 = B2IE. B5IE, 4 = B1IE. B5IE, 5 = B0IE. B5IE, 6 = RXB1IE. B5IE, 7 = RXB0IE\nbit 7\nbit 7-2\nbit 1-0\nbit 0\nB5IE:B0IE: Programmable Transmit/Receive Buffer 5-0 Interrupt Enable bit (2)\n1 = Interrupt is enabled\n- 0 = Interrupt is disabled",
    "REGISTER 23-60: BIE0: BUFFER INTERRUPT ENABLE REGISTER 0 (1)\nRXB1IE:RXB0IE: Dedicated Receive Buffer 1-0 Interrupt Enable bit (2)\n1 = Interrupt is enabled\n0 = Interrupt is disabled\nNote 1: This register is available in Mode 1 and 2 only.\n- 2: Either TXBIE or RXBIE in PIE3 register must be set to get an interrupt.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. - n = Value at POR, 1 = '1' = Bit is set. - n = Value at POR, 2 = '0' = Bit is cleared. - n = Value at POR, 3 = x = Bit is unknown",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nAddress (1)",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nF7Fh, Name = SPBRGH (3). F7Fh, Address = F5Fh. F7Fh, Name = CANCON_RO0. F7Fh, Address = F3Fh. F7Fh, Name = CANCON_RO2. F7Fh, Address = F1Fh. F7Fh, Name = RXM1EIDL. F7Eh, Name = BAUDCON (3). F7Eh, Address = F5Eh. F7Eh, Name = CANSTAT_RO0. F7Eh, Address = F3Eh. F7Eh, Name = CANSTAT_RO2. F7Eh, Address = F1Eh. F7Eh, Name = RXM1EIDH. F7Dh, Name = - (4). F7Dh, Address = F5Dh. F7Dh, Name = RXB1D7. F7Dh, Address = F3Dh. F7Dh, Name = TXB1D7. F7Dh, Address = F1Dh. F7Dh, Name = RXM1SIDL.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nF7Ch, Name = - (4). F7Ch, Address = F5Ch. F7Ch, Name = RXB1D6. F7Ch, Address = F3Ch. F7Ch, Name = TXB1D6. F7Ch, Address = F1Ch. F7Ch, Name = RXM1SIDH. F7Bh, Name = - (4). F7Bh, Address = F5Bh. F7Bh, Name = RXB1D5. F7Bh, Address = F3Bh. F7Bh, Name = TXB1D5. F7Bh, Address = F1Bh. F7Bh, Name = RXM0EIDL. F7Ah, Name = - (4). F7Ah, Address = F5Ah. F7Ah, Name = RXB1D4. F7Ah, Address = F3Ah. F7Ah, Name = TXB1D4. F7Ah, Address = F1Ah. F7Ah, Name = RXM0EIDH. F79h, Name = ECCP1DEL",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\n(3). F79h, Address = F59h. F79h, Name = RXB1D3. F79h, Address = F39h. F79h, Name = TXB1D3. F79h, Address = F19h. F79h, Name = RXM0SIDL. F78h, Name = - (4). F78h, Address = F58h. F78h, Name = RXB1D2. F78h, Address = F38h. F78h, Name = TXB1D2. F78h, Address = F18h. F78h, Name = RXM0SIDH. F77h, Name = ECANCON. F77h, Address = F57h. F77h, Name = RXB1D1. F77h, Address = F37h. F77h, Name = TXB1D1. F77h, Address = F17h. F77h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nRXF5EIDL. F76h, Name = TXERRCNT. F76h, Address = F56h. F76h, Name = RXB1D0. F76h, Address = F36h. F76h, Name = TXB1D0. F76h, Address = F16h. F76h, Name = RXF5EIDH. F75h, Name = RXERRCNT. F75h, Address = F55h. F75h, Name = RXB1DLC. F75h, Address = F35h. F75h, Name = TXB1DLC. F75h, Address = F15h. F75h, Name = RXF5SIDL. F74h, Name = COMSTAT. F74h, Address = F54h. F74h, Name = RXB1EIDL. F74h, Address = F34h. F74h, Name = TXB1EIDL. F74h, Address = F14h.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nF74h, Name = RXF5SIDH. F73h, Name = CIOCON. F73h, Address = F53h. F73h, Name = RXB1EIDH. F73h, Address = F33h. F73h, Name = TXB1EIDH. F73h, Address = F13h. F73h, Name = RXF4EIDL. F72h, Name = BRGCON3. F72h, Address = F52h. F72h, Name = RXB1SIDL. F72h, Address = F32h. F72h, Name = TXB1SIDL. F72h, Address = F12h. F72h, Name = RXF4EIDH. F71h, Name = BRGCON2. F71h, Address = F51h. F71h, Name = RXB1SIDH. F71h, Address = F31h. F71h, Name = TXB1SIDH.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nF71h, Address = F11h. F71h, Name = RXF4SIDL. F70h, Name = BRGCON1. F70h, Address = F50h. F70h, Name = RXB1CON. F70h, Address = F30h. F70h, Name = TXB1CON. F70h, Address = F10h. F70h, Name = RXF4SIDH. F6Fh, Name = CANCON. F6Fh, Address = F4Fh. F6Fh, Name = CANCON_RO1 (2). F6Fh, Address = F2Fh. F6Fh, Name = CANCON_RO3 (2). F6Fh, Address = F0Fh. F6Fh, Name = RXF3EIDL. F6Eh, Name = CANSTAT. F6Eh, Address = F4Eh. F6Eh, Name = CANSTAT_RO1 (2). F6Eh, Address = F2Eh. F6Eh, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nCANSTAT_RO3 (2). F6Eh, Address = F0Eh. F6Eh, Name = RXF3EIDH. F6Dh, Name = RXB0D7. F6Dh, Address = F4Dh. F6Dh, Name = TXB0D7. F6Dh, Address = F2Dh. F6Dh, Name = TXB2D7. F6Dh, Address = F0Dh. F6Dh, Name = RXF3SIDL. F6Ch, Name = RXB0D6. F6Ch, Address = F4Ch. F6Ch, Name = TXB0D6. F6Ch, Address = F2Ch. F6Ch, Name = TXB2D6. F6Ch, Address = F0Ch. F6Ch, Name = RXF3SIDH. F6Bh, Name = RXB0D5. F6Bh, Address = F4Bh. F6Bh, Name = TXB0D5. F6Bh, Address = F2Bh. F6Bh, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nTXB2D5. F6Bh, Address = F0Bh. F6Bh, Name = RXF2EIDL. F6Ah, Name = RXB0D4. F6Ah, Address = F4Ah. F6Ah, Name = TXB0D4. F6Ah, Address = F2Ah. F6Ah, Name = TXB2D4. F6Ah, Address = F0Ah. F6Ah, Name = RXF2EIDH. F69h, Name = RXB0D3. F69h, Address = F49h. F69h, Name = TXB0D3. F69h, Address = F29h. F69h, Name = TXB2D3. F69h, Address = F09h. F69h, Name = RXF2SIDL. F68h, Name = RXB0D2. F68h, Address = F48h. F68h, Name = TXB0D2. F68h, Address = F28h.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nF68h, Name = TXB2D2. F68h, Address = F08h. F68h, Name = RXF2SIDH. F67h, Name = RXB0D1. F67h, Address = F47h. F67h, Name = TXB0D1. F67h, Address = F27h. F67h, Name = TXB2D1. F67h, Address = F07h. F67h, Name = RXF1EIDL. F66h, Name = RXB0D0. F66h, Address = F46h. F66h, Name = TXB0D0. F66h, Address = F26h. F66h, Name = TXB2D0. F66h, Address = F06h. F66h, Name = RXF1EIDH. F65h, Name = RXB0DLC. F65h, Address = F45h. F65h, Name = TXB0DLC. F65h,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nAddress = F25h. F65h, Name = TXB2DLC. F65h, Address = F05h. F65h, Name = RXF1SIDL. F64h, Name = RXB0EIDL. F64h, Address = F44h. F64h, Name = TXB0EIDL. F64h, Address = F24h. F64h, Name = TXB2EIDL. F64h, Address = F04h. F64h, Name = RXF1SIDH. F63h, Name = RXB0EIDH. F63h, Address = F43h. F63h, Name = TXB0EIDH. F63h, Address = F23h. F63h, Name = TXB2EIDH. F63h, Address = F03h. F63h, Name = RXF0EIDL. F62h, Name = RXB0SIDL. F62h, Address = F42h. F62h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nTXB0SIDL. F62h, Address = F22h. F62h, Name = TXB2SIDL. F62h, Address = F02h. F62h, Name = RXF0EIDH. F61h, Name = RXB0SIDH. F61h, Address = F41h. F61h, Name = TXB0SIDH. F61h, Address = F21h. F61h, Name = TXB2SIDH. F61h, Address = F01h. F61h, Name = RXF0SIDL. F60h, Name = RXB0CON. F60h, Address = F40h. F60h, Name = TXB0CON. F60h, Address = F20h. F60h, Name = TXB2CON. F60h, Address = F00h. F60h, Name = RXF0SIDH",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP\nNote 1: Shaded registers are available in Access Bank low area while the rest are available in Bank 15.\n2: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the controller register due to the Microchip header file requirement.\n3: These registers are not CAN registers.\n4: Unimplemented registers are read as ' 0 '.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nEFFh, Name = - (4). EFFh, Address = EDFh. EFFh, Name = - (4). EFFh, Address = EBFh. EFFh, Name = - (4). EFFh, Address = E9Fh. EFFh, Name = - (4). EFEh, Name = - (4). EFEh, Address = EDEh. EFEh, Name = - (4). EFEh, Address = EBEh. EFEh, Name = - (4). EFEh, Address = E9Eh. EFEh, Name = - (4). EFDh, Name = - (4). EFDh, Address = EDDh. EFDh, Name = - (4). EFDh, Address = EBDh. EFDh, Name = - (4). EFDh, Address = E9Dh. EFDh, Name = - (4). EFCh, Name = - (4). EFCh, Address = EDCh.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nEFCh, Name = - (4). EFCh, Address = EBCh. EFCh, Name = - (4). EFCh, Address = E9Ch. EFCh, Name = - (4). EFBh, Name = - (4). EFBh, Address = EDBh. EFBh, Name = - (4). EFBh, Address = EBBh. EFBh, Name = - (4). EFBh, Address = E9Bh. EFBh, Name = - (4). EFAh, Name = - (4). EFAh, Address = EDAh. EFAh, Name = - (4). EFAh, Address = EBAh. EFAh, Name = - (4). EFAh, Address = E9Ah. EFAh, Name = - (4). EF9h, Name = - (4). EF9h, Address = ED9h. EF9h, Name = - (4). EF9h, Address =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nEB9h. EF9h, Name = - (4). EF9h, Address = E99h. EF9h, Name = - (4). EF8h, Name = - (4). EF8h, Address = ED8h. EF8h, Name = - (4). EF8h, Address = EB8h. EF8h, Name = - (4). EF8h, Address = E98h. EF8h, Name = - (4). EF7h, Name = - (4). EF7h, Address = ED7h. EF7h, Name = - (4). EF7h, Address = EB7h. EF7h, Name = - (4). EF7h, Address = E97h. EF7h, Name = - (4). EF6h, Name = - (4). EF6h, Address = ED6h. EF6h, Name = - (4).",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nEF6h, Address = EB6h. EF6h, Name = - (4). EF6h, Address = E96h. EF6h, Name = - (4). EF5h, Name = - (4). EF5h, Address = ED5h. EF5h, Name = - (4). EF5h, Address = EB5h. EF5h, Name = - (4). EF5h, Address = E95h. EF5h, Name = - (4). EF4h, Name = - (4). EF4h, Address = ED4h. EF4h, Name = - (4). EF4h, Address = EB4h. EF4h, Name = - (4). EF4h, Address = E94h. EF4h, Name = - (4). EF3h, Name = - (4). EF3h, Address = ED3h. EF3h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\n- (4). EF3h, Address = EB3h. EF3h, Name = - (4). EF3h, Address = E93h. EF3h, Name = - (4). EF2h, Name = - (4). EF2h, Address = ED2h. EF2h, Name = - (4). EF2h, Address = EB2h. EF2h, Name = - (4). EF2h, Address = E92h. EF2h, Name = - (4). EF1h, Name = - (4). EF1h, Address = ED1h. EF1h, Name = - (4). EF1h, Address = EB1h. EF1h, Name = - (4). EF1h, Address = E91h. EF1h, Name = - (4). EF0h, Name = - (4). EF0h, Address = ED0h.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nEF0h, Name = - (4). EF0h, Address = EB0h. EF0h, Name = - (4). EF0h, Address = E90h. EF0h, Name = - (4). EEFh, Name = - (4). EEFh, Address = ECFh. EEFh, Name = - (4). EEFh, Address = EAFh. EEFh, Name = - (4). EEFh, Address = E8Fh. EEFh, Name = - (4). EEEh, Name = - (4). EEEh, Address = ECEh. EEEh, Name = - (4). EEEh, Address = EAEh. EEEh, Name = - (4). EEEh, Address = E8Eh. EEEh, Name = - (4). EEDh, Name = - (4). EEDh, Address = ECDh. EEDh, Name = - (4). EEDh, Address = EADh. EEDh, Name = -",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\n(4). EEDh, Address = E8Dh. EEDh, Name = - (4). EECh, Name = - (4). EECh, Address = ECCh. EECh, Name = - (4). EECh, Address = EACh. EECh, Name = - (4). EECh, Address = E8Ch. EECh, Name = - (4). EEBh, Name = - (4). EEBh, Address = ECBh. EEBh, Name = - (4). EEBh, Address = EABh. EEBh, Name = - (4). EEBh, Address = E8Bh. EEBh, Name = - (4). EEAh, Name = - (4). EEAh, Address = ECAh. EEAh, Name = - (4). EEAh, Address = EAAh. EEAh, Name = - (4). EEAh, Address = E8Ah. EEAh, Name = - (4). EE9h, Name = - (4). EE9h, Address = EC9h. EE9h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\n- (4). EE9h, Address = EA9h. EE9h, Name = - (4). EE9h, Address = E89h. EE9h, Name = - (4). EE8h, Name = - (4). EE8h, Address = EC8h. EE8h, Name = - (4). EE8h, Address = EA8h. EE8h, Name = - (4). EE8h, Address = E88h. EE8h, Name = - (4). EE7h, Name = - (4). EE7h, Address = EC7h. EE7h, Name = - (4). EE7h, Address = EA7h. EE7h, Name = - (4). EE7h, Address = E87h. EE7h, Name = - (4). EE6h, Name = - (4). EE6h, Address = EC6h. EE6h, Name = - (4). EE6h, Address = EA6h. EE6h,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nName = - (4). EE6h, Address = E86h. EE6h, Name = - (4). EE5h, Name = - (4). EE5h, Address = EC5h. EE5h, Name = - (4). EE5h, Address = EA5h. EE5h, Name = - (4). EE5h, Address = E85h. EE5h, Name = - (4). EE4h, Name = - (4). EE4h, Address = EC4h. EE4h, Name = - (4). EE4h, Address = EA4h. EE4h, Name = - (4). EE4h, Address = E84h. EE4h, Name = - (4). EE3h, Name = - (4). EE3h, Address = EC3h. EE3h, Name = - (4). EE3h, Address = EA3h. EE3h, Name = - (4). EE3h, Address = E83h.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nEE3h, Name = - (4). EE2h, Name = - (4). EE2h, Address = EC2h. EE2h, Name = - (4). EE2h, Address = EA2h. EE2h, Name = - (4). EE2h, Address = E82h. EE2h, Name = - (4). EE1h, Name = - (4). EE1h, Address = EC1h. EE1h, Name = - (4). EE1h, Address = EA1h. EE1h, Name = - (4). EE1h, Address = E81h. EE1h, Name = - (4). EE0h, Name = - (4). EE0h, Address = EC0h. EE0h, Name = - (4). EE0h, Address = EA0h. EE0h, Name = - (4). EE0h, Address = E80h. EE0h, Name = - (4)",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nNote 1: Shaded registers are available in Access Bank low area while the rest are available in Bank 15.\n2: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the controller register due to the Microchip header file requirement.\n3: These registers are not CAN registers.\n4: Unimplemented registers are read as ' 0 '.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nE7Fh, Name = CANCON_RO4 (2). E7Fh, Address = E5Fh. E7Fh, Name = CANCON_RO6 (2). E7Fh, Address = E3Fh. E7Fh, Name = CANCON_RO8 (2). E7Fh, Address = E1Fh. E7Fh, Name = - (4). E7Eh, Name = CANSTAT_RO4 (2). E7Eh, Address = E5Eh. E7Eh, Name = CANSTAT_RO6 (2). E7Eh, Address = E3Eh. E7Eh, Name = CANSTAT_RO8 (2). E7Eh, Address = E1Eh. E7Eh, Name = - (4). E7Dh, Name = B5D7. E7Dh, Address = E5Dh. E7Dh, Name = B3D7. E7Dh, Address = E3Dh. E7Dh, Name = B1D7. E7Dh, Address = E1Dh.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nE7Dh, Name = - (4). E7Ch, Name = B5D6. E7Ch, Address = E5Ch. E7Ch, Name = B3D6. E7Ch, Address = E3Ch. E7Ch, Name = B1D6. E7Ch, Address = E1Ch. E7Ch, Name = - (4). E7Bh, Name = B5D5. E7Bh, Address = E5Bh. E7Bh, Name = B3D5. E7Bh, Address = E3Bh. E7Bh, Name = B1D5. E7Bh, Address = E1Bh. E7Bh, Name = - (4). E7Ah, Name = B5D4. E7Ah, Address = E5Ah. E7Ah, Name = B3D4. E7Ah, Address = E3Ah. E7Ah, Name = B1D4. E7Ah, Address = E1Ah. E7Ah, Name = - (4). E79h, Name = B5D3. E79h,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nAddress = E59h. E79h, Name = B3D3. E79h, Address = E39h. E79h, Name = B1D3. E79h, Address = E19h. E79h, Name = - (4). E78h, Name = B5D2. E78h, Address = E58h. E78h, Name = B3D2. E78h, Address = E38h. E78h, Name = B1D2. E78h, Address = E18h. E78h, Name = - (4). E77h, Name = B5D1. E77h, Address = E57h. E77h, Name = B3D1. E77h, Address = E37h. E77h, Name = B1D1. E77h, Address = E17h. E77h, Name = - (4). E76h, Name = B5D0. E76h, Address = E56h.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nE76h, Name = B3D0. E76h, Address = E36h. E76h, Name = B1D0. E76h, Address = E16h. E76h, Name = - (4). E75h, Name = B5DLC. E75h, Address = E55h. E75h, Name = B3DLC. E75h, Address = E35h. E75h, Name = B1DLC. E75h, Address = E15h. E75h, Name = - (4). E74h, Name = B5EIDL. E74h, Address = E54h. E74h, Name = B3EIDL. E74h, Address = E34h. E74h, Name = B1EIDL. E74h, Address = E14h. E74h, Name = - (4). E73h, Name = B5EIDH. E73h, Address = E53h. E73h, Name = B3EIDH.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nE73h, Address = E33h. E73h, Name = B1EIDH. E73h, Address = E13h. E73h, Name = - (4). E72h, Name = B5SIDL. E72h, Address = E52h. E72h, Name = B3SIDL. E72h, Address = E32h. E72h, Name = B1SIDL. E72h, Address = E12h. E72h, Name = - (4). E71h, Name = B5SIDH. E71h, Address = E51h. E71h, Name = B3SIDH. E71h, Address = E31h. E71h, Name = B1SIDH. E71h, Address = E11h. E71h, Name = - (4). E70h, Name = B5CON. E70h, Address = E50h. E70h, Name = B3CON. E70h, Address =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nE30h. E70h, Name = B1CON. E70h, Address = E10h. E70h, Name = - (4). E6Fh, Name = CANCON_RO5. E6Fh, Address = E4Fh. E6Fh, Name = CANCON_RO7. E6Fh, Address = E2Fh. E6Fh, Name = CANCON_RO9. E6Fh, Address = E0Fh. E6Fh, Name = - (4). E6Eh, Name = CANSTAT_RO5. E6Eh, Address = E4Eh. E6Eh, Name = CANSTAT_RO7. E6Eh, Address = E2Eh. E6Eh, Name = CANSTAT_RO9. E6Eh, Address = E0Eh. E6Eh, Name = - (4). E6Dh, Name = B4D7. E6Dh, Address = E4Dh. E6Dh, Name = B2D7. E6Dh, Address = E2Dh. E6Dh,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nName = B0D7. E6Dh, Address = E0Dh. E6Dh, Name = - (4). E6Ch, Name = B4D6. E6Ch, Address = E4Ch. E6Ch, Name = B2D6. E6Ch, Address = E2Ch. E6Ch, Name = B0D6. E6Ch, Address = E0Ch. E6Ch, Name = - (4). E6Bh, Name = B4D5. E6Bh, Address = E4Bh. E6Bh, Name = B2D5. E6Bh, Address = E2Bh. E6Bh, Name = B0D5. E6Bh, Address = E0Bh. E6Bh, Name = - (4). E6Ah, Name = B4D4. E6Ah, Address = E4Ah. E6Ah, Name = B2D4. E6Ah, Address = E2Ah. E6Ah, Name = B0D4. E6Ah, Address = E0Ah. E6Ah, Name",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\n= - (4). E69h, Name = B4D3. E69h, Address = E49h. E69h, Name = B2D3. E69h, Address = E29h. E69h, Name = B0D3. E69h, Address = E09h. E69h, Name = - (4). E68h, Name = B4D2. E68h, Address = E48h. E68h, Name = B2D2. E68h, Address = E28h. E68h, Name = B0D2. E68h, Address = E08h. E68h, Name = - (4). E67h, Name = B4D1. E67h, Address = E47h. E67h, Name = B2D1. E67h, Address = E27h. E67h, Name = B0D1. E67h, Address = E07h.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nE67h, Name = - (4). E66h, Name = B4D0. E66h, Address = E46h. E66h, Name = B2D0. E66h, Address = E26h. E66h, Name = B0D0. E66h, Address = E06h. E66h, Name = - (4). E65h, Name = B4DLC. E65h, Address = E45h. E65h, Name = B2DLC. E65h, Address = E25h. E65h, Name = B0DLC. E65h, Address = E05h. E65h, Name = - (4). E64h, Name = B4EIDL. E64h, Address = E44h. E64h, Name = B2EIDL. E64h, Address = E24h. E64h, Name = B0EIDL. E64h, Address = E04h. E64h, Name = - (4). E63h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nB4EIDH. E63h, Address = E43h. E63h, Name = B2EIDH. E63h, Address = E23h. E63h, Name = B0EIDH. E63h, Address = E03h. E63h, Name = - (4). E62h, Name = B4SIDL. E62h, Address = E42h. E62h, Name = B2SIDL. E62h, Address = E22h. E62h, Name = B0SIDL. E62h, Address = E02h. E62h, Name = - (4). E61h, Name = B4SIDH. E61h, Address = E41h. E61h, Name = B2SIDH. E61h, Address = E21h. E61h, Name = B0SIDH. E61h, Address = E01h. E61h, Name = - (4). E60h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nB4CON. E60h, Address = E40h. E60h, Name = B2CON. E60h, Address = E20h. E60h, Name = B0CON. E60h, Address = E00h. E60h, Name = - (4)\nNote 1: Shaded registers are available in Access Bank low area while the rest are available in Bank 15.\n2: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the controller register due to the Microchip header file requirement.\n3: These registers are not CAN registers.\n4: Unimplemented registers are read as ' 0 '.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nDFFh, Name = - (4). DFFh, Address = DDFh. DFFh, Name = - (4). DFFh, Address = DBFh. DFFh, Name = - (4). DFFh, Address = D9Fh. DFFh, Name = - (4). DFEh, Name = - (4). DFEh, Address = DDEh. DFEh, Name = - (4). DFEh, Address = DBEh. DFEh, Name = - (4). DFEh, Address = D9Eh. DFEh, Name = - (4). DFDh, Name = - (4). DFDh, Address = DDDh. DFDh, Name = - (4). DFDh, Address = DBDh. DFDh, Name = - (4). DFDh, Address = D9Dh. DFDh, Name = - (4). DFCh, Name = TXBIE. DFCh, Address = DDCh. DFCh, Name = -",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\n(4). DFCh, Address = DBCh. DFCh, Name = - (4). DFCh, Address = D9Ch. DFCh, Name = - (4). DFBh, Name = - (4). DFBh, Address = DDBh. DFBh, Name = - (4). DFBh, Address = DBBh. DFBh, Name = - (4). DFBh, Address = D9Bh. DFBh, Name = - (4). DFAh, Name = BIE0. DFAh, Address = DDAh. DFAh, Name = - (4). DFAh, Address = DBAh. DFAh, Name = - (4). DFAh, Address = D9Ah. DFAh, Name = - (4). DF9h, Name = - (4). DF9h, Address = DD9h. DF9h, Name = - (4). DF9h, Address = DB9h. DF9h, Name = - (4). DF9h,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nAddress = D99h. DF9h, Name = - (4). DF8h, Name = BSEL0. DF8h, Address = DD8h. DF8h, Name = SDFLC. DF8h, Address = DB8h. DF8h, Name = - (4). DF8h, Address = D98h. DF8h, Name = - (4). DF7h, Name = - (4). DF7h, Address = DD7h. DF7h, Name = - (4). DF7h, Address = DB7h. DF7h, Name = - (4). DF7h, Address = D97h. DF7h, Name = - (4). DF6h, Name = - (4). DF6h, Address = DD6h. DF6h, Name = - (4). DF6h, Address = DB6h. DF6h, Name = - (4). DF6h,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nAddress = D96h. DF6h, Name = - (4). DF5h, Name = - (4). DF5h, Address = DD5h. DF5h, Name = RXFCON1. DF5h, Address = DB5h. DF5h, Name = - (4). DF5h, Address = D95h. DF5h, Name = - (4). DF4h, Name = - (4). DF4h, Address = DD4h. DF4h, Name = RXFCON0. DF4h, Address = DB4h. DF4h, Name = - (4). DF4h, Address = D94h. DF4h, Name = - (4). DF3h, Name = MSEL3. DF3h, Address = DD3h. DF3h, Name = - (4). DF3h, Address = DB3h. DF3h, Name = - (4).",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nDF3h, Address = D93h. DF3h, Name = RXF15EIDL. DF2h, Name = MSEL2. DF2h, Address = DD2h. DF2h, Name = - (4). DF2h, Address = DB2h. DF2h, Name = - (4). DF2h, Address = D92h. DF2h, Name = RXF15EIDH. DF1h, Name = MSEL1. DF1h, Address = DD1h. DF1h, Name = - (4). DF1h, Address = DB1h. DF1h, Name = - (4). DF1h, Address = D91h. DF1h, Name = RXF15SIDL. DF0h, Name = MSEL0. DF0h, Address = DD0h. DF0h, Name = - (4). DF0h, Address = DB0h. DF0h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\n- (4). DF0h, Address = D90h. DF0h, Name = RXF15SIDH. DEFh, Name = - (4). DEFh, Address = DCFh. DEFh, Name = - (4). DEFh, Address = DAFh. DEFh, Name = - (4). DEFh, Address = D8Fh. DEFh, Name = - (4). DEEh, Name = - (4). DEEh, Address = DCEh. DEEh, Name = - (4). DEEh, Address = DAEh. DEEh, Name = - (4). DEEh, Address = D8Eh. DEEh, Name = - (4). DEDh, Name = - (4). DEDh, Address = DCDh. DEDh, Name = - (4). DEDh, Address = DADh. DEDh, Name = - (4). DEDh, Address = D8Dh. DEDh, Name = - (4). DECh, Name = - (4). DECh, Address =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nDCCh. DECh, Name = - (4). DECh, Address = DACh. DECh, Name = - (4). DECh, Address = D8Ch. DECh, Name = - (4). DEBh, Name = - (4). DEBh, Address = DCBh. DEBh, Name = - (4). DEBh, Address = DABh. DEBh, Name = - (4). DEBh, Address = D8Bh. DEBh, Name = RXF14EIDL. DEAh, Name = - (4). DEAh, Address = DCAh. DEAh, Name = - (4). DEAh, Address = DAAh. DEAh, Name = - (4). DEAh, Address = D8Ah. DEAh, Name = RXF14EIDH. DE9h, Name = - (4). DE9h, Address = DC9h. DE9h, Name = - (4). DE9h, Address = DA9h. DE9h, Name = - (4). DE9h, Address =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nD89h. DE9h, Name = RXF14SIDL. DE8h, Name = - (4). DE8h, Address = DC8h. DE8h, Name = - (4). DE8h, Address = DA8h. DE8h, Name = - (4). DE8h, Address = D88h. DE8h, Name = RXF14SIDH. DE7h, Name = RXFBCON7. DE7h, Address = DC7h. DE7h, Name = - (4). DE7h, Address = DA7h. DE7h, Name = - (4). DE7h, Address = D87h. DE7h, Name = RXF13EIDL. DE6h, Name = RXFBCON6. DE6h, Address = DC6h. DE6h, Name = - (4). DE6h, Address = DA6h. DE6h, Name = - (4). DE6h, Address = D86h. DE6h, Name =",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nRXF13EIDH. DE5h, Name = RXFBCON5. DE5h, Address = DC5h. DE5h, Name = - (4). DE5h, Address = DA5h. DE5h, Name = - (4). DE5h, Address = D85h. DE5h, Name = RXF13SIDL. DE4h, Name = RXFBCON4. DE4h, Address = DC4h. DE4h, Name = - (4). DE4h, Address = DA4h. DE4h, Name = - (4). DE4h, Address = D84h. DE4h, Name = RXF13SIDH. DE3h, Name = RXFBCON3. DE3h, Address = DC3h. DE3h, Name = - (4). DE3h, Address = DA3h. DE3h, Name = - (4). DE3h, Address = D83h. DE3h, Name = RXF12EIDL. DE2h,",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nName = RXFBCON2. DE2h, Address = DC2h. DE2h, Name = - (4). DE2h, Address = DA2h. DE2h, Name = - (4). DE2h, Address = D82h. DE2h, Name = RXF12EIDH. DE1h, Name = RXFBCON1. DE1h, Address = DC1h. DE1h, Name = - (4). DE1h, Address = DA1h. DE1h, Name = - (4). DE1h, Address = D81h. DE1h, Name = RXF12SIDL. DE0h, Name = RXFBCON0. DE0h, Address = DC0h. DE0h, Name = - (4). DE0h, Address = DA0h. DE0h, Name = - (4). DE0h, Address = D80h. DE0h, Name = RXF12SIDH",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP  (CONTINUED)\nNote 1: Shaded registers are available in Access Bank low area while the rest are available in Bank 15.\n2: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the controller register due to the Microchip header file requirement.\n3: These registers are not CAN registers.\n4: Unimplemented registers are read as ' 0 '.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nD7Fh, Name = - (4). D7Eh, Name = - (4). D7Dh, Name = - (4). D7Ch, Name = - (4). D7Bh, Name = RXF11EIDL. D7Ah, Name = RXF11EIDH. D79h, Name = RXF11SIDL. D78h, Name = RXF11SIDH. D77h, Name = RXF10EIDL. D76h, Name = RXF10EIDH. D75h, Name = RXF10SIDL. D74h, Name = RXF10SIDH. D73h, Name = RXF9EIDL. D72h, Name = RXF9EIDH. D71h, Name = RXF9SIDL. D70h, Name = RXF9SIDH. D6Fh, Name = - (4). D6Eh, Name = - (4). D6Dh, Name = - (4).",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\nD6Ch, Name = - (4). D6Bh, Name = RXF8EIDL. D6Ah, Name = RXF8EIDH. D69h, Name = RXF8SIDL. D68h, Name = RXF8SIDH. D67h, Name = RXF7EIDL. D66h, Name = RXF7EIDH. D65h, Name = RXF7SIDL. D64h, Name = RXF7SIDH. D63h, Name = RXF6EIDL. D62h, Name = RXF6EIDH. D61h, Name = RXF6SIDL. D60h, Name = RXF6SIDH\nNote 1: Shaded registers are available in Access Bank low area while the rest are available in Bank 15.",
    "TABLE 23-1: CAN CONTROLLER REGISTER MAP (CONTINUED)\n2: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the controller register due to the Microchip header file requirement.\n3: These registers are not CAN registers.\n4: Unimplemented registers are read as ' 0 '.",
    "23.3 CAN Modes of Operation\nThe PIC18F6585/8585/6680/8680 has six main modes of operation:\n- \u00b7 Configuration mode\nIn the Configuration mode, the module will not transmit or receive. The error counters are cleared and the interrupt  flags  remain  unchanged.  The  programmer  will have access to configuration registers that are access restricted in other modes.\n\u00b7 Disable mode\n\u00b7 Normal Operation mode\n\u00b7 Listen Only mode\n\u00b7 Loopback mode\n\u00b7 Error Recognition mode\nAll modes, except Error Recognition, are requested by setting the REQOP bits (CANCON<7:5>); Error Recognition is requested through the RXM bits of the Receive Buffer register(s). Entry into a mode is Acknowledged by monitoring the OPMODE bits.\nWhen  changing  modes,  the  mode  will  not  actually change  until  all  pending  message  transmissions  are complete. Because of this, the user must verify that the device has actually changed into the requested mode before further operations are executed.",
    "23.3.1 CONFIGURATION MODE\nThe  CAN  module  must  be  initialized before the activation. This is only possible if the module is in the Configuration mode. The Configuration mode is requested by setting the REQOP2 bit. Only when the status bit, OPMODE2, has a high level can the initialization  be  performed.  Once  in  Configuration  mode, registers such as baud rate control, acceptance mask/ filter and ECAN mode selection can be modified. A new ECAN mode selection does not take into  effect  until Configuration mode is exited. The module is activated by setting the REQOP control bits to zero.\nThe  module  will  protect  the  user  from  accidentally violating the CAN  protocol through programming errors. All registers which control the configuration of the  module can not be modified while the module is online. The CAN module will not be allowed to enter the Configuration mode while a transmission or reception is  taking  place.  The  CAN  module  will  also  not  be allowed, if the CANRX pin is low (i.e., the CAN bus is busy). The CAN module waits for 11 recessive bits on the CAN bus (bus Idle condition) before switching to Configuration  mode.  The  Configuration  mode  serves as a lock to protect the following registers:",
    "23.3.1 CONFIGURATION MODE\n\u00b7 Configuration registers\n\u00b7 Functional Mode Selection registers\n\u00b7 Bit Timing registers\n\u00b7 Identifier Acceptance Filter registers\n\u00b7 Identifier Acceptance Mask registers\n\u00b7 Filter and Mask Control registers\n\u00b7 Mask Selection registers",
    "23.3.2 DISABLE MODE\nIn  Disable  mode,  the  module  will  not  transmit  or receive. The module has the ability to set the WAKIF bit due to bus activity; however, any pending interrupts will remain and the error counters will retain their value.\nIf REQOP<2:0> is set to ' 001 ', the module will enter the Module Disable mode. This mode is similar to disabling other  peripheral  modules  by  turning  off  the  module enables. This causes the module internal clock to stop unless the module is active (i.e., receiving or transmitting a message). If the module is active, the module will wait for 11 recessive bits on the CAN bus, detect that condition  as  an  Idle  bus,  then  accept  the  module disable  command.  OPMODE<2:0>  = 001 indicates whether  the  module  successfully  went  into  Module Disable mode.",
    "23.3.2 DISABLE MODE\nThe WAKIE interrupt is the only module interrupt that is still active in the Module Disable mode. If wake-up from CAN bus activity is required, the CAN module must be put into Disable mode before putting the core to Sleep. If the WAKDIS is cleared and WAKIE is set, the processor  will  receive  an  interrupt  whenever  the  module detects recessive to dominant transition. On wake-up, the  module  will  automatically  be  set  to  the  previous mode  of  operation.  For  example,  if  the  module  was switched from Normal to Disable mode on bus activity wake-up,  the  module  will  automatically  enter  into Normal mode and the first message that caused the module to wake-up is lost. The module will not generate  any  error  frame.  Firmware  logic  must  detect  this condition and make sure that retransmission is requested. If the processor receives a wake-up interrupt while it is sleeping, more than one message may get  lost.  The  actual  number  of  messages  lost  would depend on the processor oscillator start-up time and incoming message bit rate.\nThe I/O pins will revert to normal I/O function when the module is in the Module Disable mode.",
    "Note:\nCAN  module  must  be  put  in  Disable  or Configuration  mode  prior  to  putting  the processor to sleep. Failure to do that may put  the CAN  module  in  indeterminate state.",
    "23.3.3 NORMAL MODE\nThis is the standard operating mode of the PIC18F6585/8585/6680/8680  devices.  In  this  mode, the device actively monitors all bus messages and generates Acknowledge bits, error frames, etc. This is also the  only  mode  in  which  the  PIC18F6585/8585/6680/ 8680  devices  will  transmit  messages  over  the  CAN bus.",
    "23.3.4 LISTEN ONLY MODE\nListen Only mode provides a means for the PIC18F6585/8585/6680/8680  devices  to  receive  all messages, including messages with errors. This mode can  be  used  for  bus  monitor  applications  or for detecting the baud rate in 'hot plugging' situations. For auto-baud detection, it is necessary that there are at least two other nodes which are communicating with each other. The baud rate can be detected empirically by  testing  different  values  until  valid  messages  are received.  The  Listen  Only  mode  is  a  silent  mode, meaning no messages will be transmitted while in this state, including error flags or Acknowledge signals. The filters and masks can be used to allow only particular messages to be loaded into the receive registers, or the filter masks can be set to all zeros to allow a message with any identifier to pass. The error counters are reset and deactivated in this state. The Listen Only mode is activated  by  setting  the  mode  request  bits  in  the CANCON register.",
    "23.3.5 LOOPBACK MODE\nThis mode will allow internal transmission of messages from the transmit buffers to the receive buffers without actually transmitting messages on the CAN bus. This mode can be used in system development and testing. In this mode, the ACK bit is ignored and the device will allow  incoming  messages  from  itself,  just  as  if  they were coming from another node. The Loopback mode is a silent mode, meaning no messages will be transmitted  while  in  this  state,  including  error  flags  or Acknowledge signals. The CANTX pin will revert to port I/O  while  the  device  is  in  this  mode.  The  filters  and masks can be used to allow only particular messages to be loaded into the receive registers. The masks can be set to all zeros to provide a mode that accepts all messages. The Loopback mode is activated by setting the mode request bits in the CANCON register.",
    "23.3.6 ERROR RECOGNITION MODE\nThe module can be set to ignore all errors and receive any message. In functional Mode 0, the Error Recognition mode is activated by setting the RXM<1:0> bits in the RXBnCON registers to ' 11 '. In this mode, the data which is in the message assembly buffer until the error time, is copied in the receive buffer and can be read via the CPU interface.",
    "23.4 CAN Module Functional Modes\nIn  addition  to  CAN  modes  of  operation,  the  ECAN module offers a total of three functional modes. Each of these  modes  are  identified  as  Mode  0,  Mode  1  and Mode 2.",
    "23.4.1 MODE 0 - LEGACY MODE\nMode 0 is designed to be fully compatible with CAN modules used in PIC18CXX8 and PIC18FXX8 devices. This  is  the  default  mode  of  operation  on  all  Reset conditions.  As  a  result,  module  code  written  for  the PIC18XX8 CAN module may be used on the ECAN module without any code changes.\nThe following is the list of resources available in Mode 0:\n\u00b7 Three transmit buffers: TXB0, TXB1 and TXB2\n\u00b7 Two receive buffers: RXB0 and RXB1\n\u00b7 Two acceptance masks, one for each receive buffer: RXM0, RXM1\n\u00b7 Six acceptance filters, 2 for RXB0 and 4 for RXB1: RXF0, RXF1, RXF2, RXF3, RXF4, RXF5",
    "23.4.2 MODE 1 - ENHANCED LEGACY MODE\nMode 1 is similar to Mode 0, with the exception that more  resources  are  available  in  Mode  1.  There  are 16 acceptance filters and two Acceptance Mask registers.  Acceptance  Filter  15  can  be  used  as  either  an acceptance filter  or  an  Acceptance  Mask  register.  In addition to three transmit and two receive buffers, there are six more message buffers. One or more of these additional buffers can be programmed as transmit or receive buffers. These additional buffers can also be programmed to automatically handle RTR messages.\nFourteen  of  16  Acceptance  Filter  registers  can  be dynamically  associated  to  any  receive  buffer  and Acceptance Mask register. This capability can be used to associate more than one filter to any one buffer.",
    "PIC18F6585/8585/6680/8680\nWhen a receive buffer is programmed to use standard identifier  messages, part of the full Acceptance Filter register can be used as data byte filter. The length of data byte filter is programmable from 0 to 18 bits. This functionality simplifies implementation  of  high-level protocols, such as DeviceNet.\nThe following is the list of resources available in Mode 1:\n\u00b7 Three transmit buffers: TXB0, TXB1 and TXB2\n\u00b7 Two receive buffers: RXB0 and RXB1\n\u00b7 Six buffers programmable as TX or RX: B0-B5\n\u00b7 Automatic RTR handling on B0-B5\n\u00b7 Sixteen dynamically assigned acceptance filters: RXF0-RXF15\n\u00b7 Two dedicated Acceptance Mask registers; RXF15 programmable as third mask: RXM0-RXM1, RXF15\n\u00b7 Programmable data filter on standard identifier messages: SDFLC",
    "23.4.3 MODE 2 - ENHANCED FIFO MODE\nIn Mode 2, two or more receive buffers are used to form the receive FIFO (First In First Out) buffer. There is no one-to-one  relation  between  the  receive  buffer  and Acceptance Filter registers. Any filter  that  is  enabled and  linked  to  any  FIFO  receive  buffer  can  generate acceptance and cause FIFO to be updated.\nFIFO  length  is  user  programmable,  from  2-8  buffers deep.  FIFO  length  is  determined  by  the  very  first programmable buffer that is configured as a transmit buffer. For example, if Buffer 2 (B2) is programmed as a  transmit  buffer,  FIFO  consists  of  RXB0,  RXB1,  B0 and B1 - creating a FIFO length of 4. If all programmable buffers are configured as receive buffers, FIFO will have the maximum length of 8.\nThe following is the list of resources available in Mode 2:",
    "23.4.3 MODE 2 - ENHANCED FIFO MODE\n\u00b7 Three transmit buffers: TXB0, TXB1 and TXB2\n\u00b7 Two receive buffers: RXB0 and RXB1\n\u00b7 Six buffers programmable as TX or RX; receive buffers form FIFO: B0-B5\n\u00b7 Automatic RTR handling on B0-B5\n\u00b7 Sixteen acceptance filters: RXF0-RXF15\n\u00b7 Two dedicated Acceptance Mask registers; RXF15 programmable as third mask: RXM0-RXM1, RXF15\n\u00b7 Programmable data filter on standard identifier messages: SDFLC, useful for DeviceNet protocol",
    "23.5.1 DEDICATED TRANSMIT BUFFERS\nThe PIC18F6585/8585/6680/8680 devices implement three  dedicated  transmit  buffers  -  TXB0,  TXB1  and TXB2.  Each  of  these  buffers  occupies  14  bytes  of SRAM and are mapped into the SFR  memory  map. These  are  the only transmit buffers available in Mode 0. Mode 1 and 2 may access these and other additional buffers.\nEach  transmit  buffer  contains  one  Control  register (TXBnCON), four Identifier registers (TXBnSIDL, TXBnSIDH, TXBnEIDL, TXBnEIDH), one Data Length Count register (TXBnDLC) and eight Data Byte registers (TXBnDm).",
    "23.5.2 DEDICATED RECEIVE BUFFERS\nThe PIC18F6585/8585/6680/8680 devices implement two dedicated receive buffers - RXB0 and RXB1. Each of these buffers occupies 14 bytes of SRAM and are mapped into  SFR  memory map. These are the only receive buffers available in Mode 0. Mode 1 and 2 may access these and other additional buffers.\nEach  receive  buffer  contains  one  Control  register (RXBnCON), four Identifier registers (RXBnSIDL, RXBnSIDH, RXBnEIDL, RXBnEIDH), one Data Length Count register (RXBnDLC)  and  eight Data Byte registers (RXBnDm).\nThere  is  also  a  separate  Message  Assembly  Buffer (MAB) which acts as an additional receive buffer. MAB is  always  committed  to  receiving  the  next  message from the bus and is not directly accessible to user firmware. The MAB assembles all incoming messages one by  one.  A  message  is  transferred  to  appropriate receive  buffers  only  if  the  corresponding  acceptance filter criteria is met.",
    "23.5.3 PROGRAMMABLE TRANSMIT/ RECEIVE BUFFERS\nThe ECAN module implements six new buffers: B0-B5. These buffers are individually programmable as either transmit or receive buffers. These buffers are available only in Mode 1 and 2. As with dedicated transmit and receive  buffers,  each  of  these  programmable  buffers occupies 14 bytes of SRAM and are mapped into SFR memory map.\nEach  buffer  contains  one  Control  register  (BnCON), four  Identifier  registers  (BnSIDL,  BnSIDH,  BnEIDL, BnEIDH),  one  Data  Length  Count  register  (BnDLC) and eight Data Byte registers (BnDm). Each of these registers contains two sets of control bits. Depending on  whether  the  buffer  is  configured  as  transmit  or receive, one would use the corresponding control bit set.  By  default,  all  buffers  are  configured  as  receive buffers. Each buffer can be individually configured as transmit or receive buffers by setting the corresponding TXENn bit in the BSEL0 register.",
    "23.5.3 PROGRAMMABLE TRANSMIT/ RECEIVE BUFFERS\nWhen  configured  as  transmit  buffers,  user  firmware may  access  transmit  buffers  in  any  order  similar  to accessing dedicated transmit buffers. In receive configuration, with Mode 1 enabled, user firmware may also access  receive  buffers  in  any  order  required.  But  in Mode 2, all receive buffers are combined to form a single FIFO. Actual FIFO length is programmable by user firmware. Access to FIFO must be done through the FIFO pointer bits (FP<4:0>) in the CANCON register. It must  be  noted  that  there  is  no  hardware  protection against out of order FIFO reads.",
    "23.5.4 PROGRAMMABLE AUTO-RTR BUFFERS\nIn  Mode 1 and 2, any of six programmable transmit/ receive buffers may be programmed to automatically respond  to  predefined  RTR  messages  without  user firmware intervention. Automatic RTR  handling  is enabled by setting the TXnEN bit in the BSEL0 register and the RTREN bit in the BnCON register. After this setup, when an RTR request is received, the TXREQ bit  is  automatically  set  and  current  buffer  content  is automatically queued  for  transmission as a RTR response. As with all transmit buffers, once the TXREQ bit  is  set,  buffer  registers  become  read-only  and  any writes to them will be ignored.\nThe following outlines the steps required to automatically handle RTR messages:\n1. Set buffer to Transmit mode by setting TXnEN bit to ' 1 ' in BSEL0 register.\n2. At  least  one  acceptance  filter  must  be  associated with this buffer and preloaded with expected RTR identifier.\n3. Bit RTREN in BnCON register must be set to ' 1 '.\n4. Buffer  must  be  preloaded  with  the  data  to  be sent as a RTR response.",
    "23.5.4 PROGRAMMABLE AUTO-RTR BUFFERS\nNormally, user firmware will keep Buffer Data registers up to date. If firmware attempts to update buffer while an automatic RTR response is in process of transmission, all writes to buffers are ignored.",
    "23.6.1 INITIATING TRANSMISSION\nFor  the  MCU  to  have  write  access  to  the  message buffer, the TXREQ bit must be clear, indicating that the message buffer is clear of any pending message to be transmitted. At a minimum, the SIDH, SIDL, and DLC registers must be loaded. If data bytes are present in the message, the data registers must also be loaded. If the message  is to use extended identifiers, the EIDH:EIDL  registers  must  also  be  loaded  and  the EXIDE bit set.\nTo initiate message transmission, the TXREQ bit must be set for each buffer to be transmitted. When TXREQ is  set,  the  TXABT,  TXLARB  and  TXERR  bits  will  be cleared.  To  successfully  complete  the  transmission, there must be at least one node with matching baud rate on the network.\nSetting  the  TXREQ  bit  does  not  initiate  a  message transmission, it merely flags a message buffer as ready for transmission.  Transmission  will  start  when  the device detects that the bus is available. The device will then begin transmission of the highest priority message that is ready.",
    "23.6.1 INITIATING TRANSMISSION\nWhen the transmission has completed successfully, the TXREQ bit will be cleared, the TXBnIF bit will be set, and an interrupt will be generated if the TXBnIE bit is set.\nIf the  message  transmission  fails,  the  TXREQ  will remain set, indicating that the message is still pending for transmission and one of the following condition flags will  be  set.  If  the  message  started  to  transmit  but encountered  an  error  condition,  the  TXERR  and  the IRXIF bits will be set and an interrupt will be generated. If the message lost arbitration, the TXLARB bit will be set.",
    "23.6.2 ABORTING TRANSMISSION\nThe MCU can request to abort a message by clearing the TXREQ bit associated with the corresponding message buffer (TXBnCON<3> or BnCON<3>). Setting the ABAT  bit  (CANCON<4>)  will  request  an  abort  of  all pending messages. If the message has not yet started transmission  or  if  the  message  started  but  is  interrupted by loss of arbitration or an error, the abort will be processed.  The  abort  is  indicated  when  the  module sets the TXABT  bit  for the corresponding  buffer (TXBnCON<6>  or  BnCON<6>).  If  the  message  has started to transmit, it will attempt to transmit the current message  fully.  If  the  current  message  is  transmitted fully and is not lost to arbitration or an error, the TXABT bit will not be set because the message was transmitted  successfully.  Likewise,  if  a  message  is  being transmitted during an abort request and the message is lost to arbitration or an error, the message will not be retransmitted and the TXABT bit will be set, indicating that the message was successfully aborted.",
    "23.6.2 ABORTING TRANSMISSION\nOnce an abort is requested by setting ABAT or TXABT bits, it cannot be cleared to cancel the abort request. Only CAN module hardware or a POR condition can clear it.",
    "23.6.3 TRANSMIT PRIORITY\nTransmit priority is a prioritization within the PIC18F6585/8585/6680/8680 devices of the  pending transmittable messages. This is independent from and not related to any prioritization implicit in the message arbitration scheme built into the CAN protocol. Prior to sending  the  SOF,  the  priority  of  all  buffers  that  are queued  for  transmission  is  compared.  The  transmit buffer with the highest priority will be sent first. If more than one buffer has the same priority setting, the message is transmitted in the order of TXB2, TXB1, TXB0, B5, B4, B3, B2, B1, B0. There are four levels of transmit priority. If TXP bits for a particular message buffer are set to ' 11 ', that buffer has the highest possible priority. If TXP bits for a particular message buffer are ' 00 ', that buffer has the lowest possible priority.\nFIGURE 23-2: TRANSMIT BUFFERS",
    "23.7.1 RECEIVING A MESSAGE\nOf all receive buffers, the MAB is always committed to receiving  the  next  message  from  the  bus.  The  MCU can access one buffer while the other buffer is available for message reception, or holding a previously received message.",
    "Note:\nThe entire contents of the MAB are moved into the receive buffer once a message is accepted. This means that regardless of the type of identifier (standard or extended) and the number of data bytes received, the entire receive buffer is overwritten with the MAB contents. Therefore, the  contents  of  all  registers  in  the  buffer must be assumed to have been modified when any message is received.\nWhen a message is moved into either of the receive buffers, the associated RXFUL bit is set. This bit must be cleared by the MCU when it has completed processing the message in the buffer in order to allow a new message  to  be  received  into  the  buffer.  This  bit provides a positive lockout to ensure that the firmware has  finished  with  the  message  before  the  module attempts to load a new message into the receive buffer. If  the receive interrupt is enabled, an interrupt will be generated to indicate that a valid message has been received.",
    "Note:\nOnce  a  message  is  loaded  into  any  matching  buffer, user firmware may determine exactly what filter caused this reception  by  checking  the  filter  hit  bits  in  the RXBnCON or BnCON registers. In Mode 0, FILHIT<3:0> of RXBnCON serve as filter hit bits. In Mode 1 and 2, FILHIT<4:0> of BnCON serve as filter hit bits. The same registers also indicate whether the current message is RTR frame or not. A received message is considered a standard identifier message if the EXID bit in RXBnSIDL or  the  BnSIDL  register  is  cleared.  Conversely,  a  set EXID bit indicates an extended identifier message. If the received message is a standard identifier message, user firmware needs to read the SIDL and SIDH registers. In the  case  of  an  extended  identifier  message,  firmware should read the SIDL, SIDH, EIDL and EIDH registers. If the RXBnDLC or BnDLC register contain non-zero data count, user firmware should also read the corresponding number  of  data  bytes  by  accessing  the  RXBnDm",
    "Note:\nor BnDm registers. When a received message is RTR and if the current buffer is not configured for automatic RTR handling,  user  firmware  must  take  appropriate  action and respond manually.",
    "Note:\nEach receive buffer contains RXM bits to set special Receive modes. In Mode 0, RXM<1:0>  bits in RXBnCON define  a  total  of  four  Receive  modes.  In Mode 1 and 2, RXM1 bit in combination with the EXID mask  and  filter  bit  define  the  same  four  Receive modes. Normally, these bits are set to ' 00 '  to  enable reception of all valid messages as determined by the appropriate acceptance filters. In this case, the determination  of  whether  or  not  to  receive  standard  or extended messages is determined by the EXIDE bit in the Acceptance Filter register. In Mode 0, if the RXM bits are set to ' 01 ' or ' 10 ', the receiver will accept only messages with standard or extended identifiers, respectively. If an acceptance filter has the EXIDE bit set  such  that  it  does  not  correspond  with  the  RXM mode,  that  acceptance  filter  is  rendered  useless.  In Mode 1 and 2, setting EXID in the SIDL Mask register will  ensure  that  only  standard  or  extended  identifiers are  received.  These  two  modes  of  RXM  bits  can",
    "Note:\nbe used in systems where it is known that only standard or extended messages will be on the bus. If the RXM bits are set to ' 11 ' (RXM1 = 1 in Mode 1 and 2), the buffer will  receive all  messages regardless of the values of the acceptance filters. Also, if a message has an error before the end of frame, that portion of the message assembled in the MAB before the error frame, will be loaded into the buffer. This mode may serve as a valuable debugging tool for a given CAN network. It should not be used in an actual system environment as the actual system will always have some bus errors and all nodes on the bus are expected to ignore them.\nIn  Mode  1  and  2,  when  a  programmable  buffer  is configured as a transmit buffer and one or more acceptance filters  are associated with it, all incoming messages  matching  this  acceptance  filter  criteria  will  be discarded. To avoid this scenario, user firmware must make sure that there are no acceptance filters associated with a buffer configured as a transmit buffer.",
    "23.7.2 RECEIVE PRIORITY\nWhen in Mode 0, RXB0 is the higher priority buffer and has two message acceptance filters associated with it. RXB1 is the lower priority buffer and has four acceptance filters associated with it. The lower number of acceptance filters  makes  the  match  on  RXB0 more restrictive  and implies a higher priority for that buffer. Additionally, the RXB0CON register can be configured such that if RXB0 contains a valid message and another valid message is received, an overflow error will not occur and the new message  will  be  moved  into  RXB1  regardless  of  the acceptance criteria of RXB1.  There  are also two programmable acceptance filter masks available, one for each receive buffer (see Section 4.5).",
    "PIC18F6585/8585/6680/8680\nIn Mode 1 and 2, there are a total of 16 acceptance filters available and each can be dynamically assigned to any of the receive buffers. A buffer with a lower number has higher priority. Given this, if an incoming message matches with two or more receive buffer acceptance criteria, the buffer with the lower number will be loaded with that message.",
    "23.7.3 ENHANCED FIFO MODE\nWhen  configured  for  Mode  2,  two  of  the  dedicated receive buffers, in combination with one or more programmable transmit/receive buffers, are used to create a maximum of 8 buffers deep FIFO (First In First Out) buffer.  In  this  mode,  there  is  no  direct  correlation between filters and receive buffer registers. Any filter that  has  been enabled can generate an acceptance. When a message has been accepted, it is stored in the next  available  receive  buffer  register  and  an  internal write pointer is incremented. The FIFO can be a maximum of 8 buffers deep. The entire FIFO must consist of contiguous receive buffers. The FIFO head begins at RXB0 buffer and its tail spans toward B5. The maximum length of the FIFO is limited by the presence or absence of the first transmit buffer starting from B0. If a buffer  is  configured  as  a  transmit  buffer,  the  FIFO length  is  reduced  accordingly.  For  instance,  if  B3",
    "23.7.3 ENHANCED FIFO MODE\nis configured as transmit buffer, the actual FIFO will consist of RXB0, RXB1, B0, B1 and B2, a total of 5 buffers. If B0 is configured as a transmit buffer, the FIFO length will be 2. If none of the programmable buffers are configured as a transmit buffer, the FIFO will be 8 buffers deep.  A  system  that  requires  more  transmit  buffers should try to locate transmit buffers at the very end of B0-B5 buffers to maximize available FIFO length.",
    "23.7.3 ENHANCED FIFO MODE\nWhen a message is received in FIFO mode, the Interrupt Flag Code bits (EICODE<4:0>) in the CANSTAT register  will  have  a  value  of  ' 10000 ',  indicating  the FIFO  has  received  a  message.  FIFO  pointer  bits FP<3:0> in the CANCON register point to  the buffer that contains data not yet read. The FIFO pointer bits, in this sense, serve as the FIFO read pointer. The user should use FP bits and read corresponding buffer data. When receive data is no longer needed, the RXFUL bit in the current buffer must be cleared, causing FP<3:0> to be updated by the module.",
    "23.7.3 ENHANCED FIFO MODE\nTo determine whether FIFO is empty or not, the user may use FP<3:0> bits to access RXFUL bit in the current buffer. If RXFUL is cleared, the FIFO is considered to be empty. If it is set, the FIFO may contain one or more messages. In Mode 2, the module also provides a  bit  called  FIFO  High  Water Mark (FIFOWM)  in the ECANCON register. This bit can be used to cause an interrupt whenever the FIFO contains only one or four empty buffers. The FIFO high water mark interrupt can serve as an early warning to a full FIFO condition.",
    "23.7.4 TIME-STAMPING\nThe CAN module can be programmed to generate a time-stamp for every message that is received. When enabled,  the  module  generates  a  capture  signal  for CCP1, which in turn captures the value of either Timer1 or  Timer3.  This  value  can  be  used  as  the  message time-stamp.\nTo  use  the  time-stamp  capability,  the  CANCAP  bit (CIOCAN<4>) must be set. This replaces the capture input for CCP1 with the signal generated from the CAN module. In addition,  CCP1CON<3:0> must be set to ' 0011 ' to enable the CCP special event trigger for CAN events.",
    "23.8 Message Acceptance Filters and Masks\nThe message acceptance filters and masks are used to determine  if  a  message  in  the  message  assembly buffer should be loaded into any of the receive buffers. Once a valid message has been received into the MAB, the identifier fields of the message are compared to the filter values. If there is a match, that message will be loaded  into  the  appropriate  receive  buffer.  The  filter masks are used to determine which bits in the identifier are  examined  with  the  filters.  A  truth  table  is  shown below in Table 23-2 that indicates how each bit in the identifier is compared to the masks and filters to determine  if  a  message  should  be  loaded  into  a  receive buffer. The mask essentially determines which bits to apply the acceptance filters to. If any mask bit is set to a  zero,  then  that  bit  will  automatically  be  accepted regardless of the filter bit.",
    "TABLE 23-2: FILTER/MASK TRUTH TABLE\n0, Filter bit n = x. 0, Message Identifier bit n001 = x. 0, Accept or Reject bit n = Accept. 1, Filter bit n = 0. 1, Message Identifier bit n001 = 0. 1, Accept or Reject bit n = Accept. 1, Filter bit n = 0. 1, Message Identifier bit n001 = 1. 1, Accept or Reject bit n = Reject. 1, Filter bit n = 1. 1, Message Identifier bit n001 = 0. 1, Accept or Reject bit n = Reject. 1, Filter bit n = 1. 1, Message Identifier bit n001 = 1. 1, Accept or Reject bit n = Accept\nLegend:\nx = don't care\nIn Mode 0, acceptance filters RXF0 and RXF1 and filter mask RXM0 are associated with RXB0. Filters RXF2, RXF3, RXF4 and RXF5 and mask RXM1  are associated with RXB1.",
    "PIC18F6585/8585/6680/8680\nIn Mode 1 and 2, there are an additional 10 acceptance filters,  RXF6-RXF15,  creating  a  total  of  16  available filters.  RXF15  can  be  used  either  as  an  acceptance filter or acceptance  mask  register.  Each  of  these acceptance  filters can be individually enabled  or disabled  by  setting  or  clearing  RXFENn  bit  in  the RXFCONn register. Any of these 16 acceptance filters can be dynamically associated with any of the receive buffers. Actual association is made by setting appropriate bits in the RXFBCONn register. Each RXFBCONn register contains a nibble for each filter. This nibble can be used to associate a specific filter to any of available receive  buffers.  User  firmware  may  associate  more than one filter to any one specific receive buffer.\nIn  addition  to  dynamic  filter  to  buffer  association,  in Mode 1 and 2, each filter can also be dynamically associated to available acceptance mask registers. FILn_m bits in the MSELn register can be used to link a specific acceptance filter to  an acceptance mask register.  As with filter to buffer association, one can also associate more than one mask to a specific acceptance filter.",
    "PIC18F6585/8585/6680/8680\nWhen a filter matches and a message is loaded into the receive  buffer,  the  filter number  that  enabled  the message reception is loaded into the FILHIT bit(s). In Mode 0 for RXB1, the RXB1CON register contains the FILHIT<2:0> bits. They are coded as follows:\n\u00b7 101 = Acceptance Filter 5 (RXF5)\n\u00b7 100 = Acceptance Filter 4 (RXF4)\n\u00b7 011 = Acceptance Filter 3 (RXF3)\n\u00b7 010 = Acceptance Filter 2 (RXF2)\n\u00b7 001 = Acceptance Filter 1 (RXF1)\n\u00b7 000 = Acceptance Filter 0 (RXF0)",
    "Note:\n' 000 ' and  ' 001 ' can  only  occur  if  the RXB0DBEN  bit  is  set  in  the  RXB0CON register, allowing RXB0  messages to rollover into RXB1.",
    "FIGURE 23-3: MESSAGE ACCEPTANCE MASK AND FILTER OPERATION\nThe coding of the RXB0DBEN bit enables these three bits to be used similarly to the FILHIT bits and to distinguish a hit on filter RXF0 and RXF1, in either RXB0 or after a rollover into RXB1.\n\u00b7 111 = Acceptance Filter 1 (RXF1)\n\u00b7 110 = Acceptance Filter 0 (RXF0)\n\u00b7 001 = Acceptance Filter 1 (RXF1)\n\u00b7 000 = Acceptance Filter 0\nIf the RXB0DBEN bit is clear, there are six codes corresponding to the six filters. If the RXB0DBEN bit is set, there are six codes corresponding to the six filters plus two additional codes corresponding to RXF0 and RXF1 filters that rollover into RXB1.\nIn Mode 1 and 2, each buffer control register contains 5 bits of filter hit bits FILHIT<4:0>. A binary value of ' 0 ' indicates a hit from RXF0 and 15 indicates RXF15.",
    "FIGURE 23-3: MESSAGE ACCEPTANCE MASK AND FILTER OPERATION\nIf more than one acceptance filter matches, the FILHIT bits will encode  the binary value of the lowest numbered filter  that  matched.  In  other  words,  if  filter RXF2 and filter RXF4 match, FILHIT will be loaded with the  value  for  RXF2.  This  essentially  prioritizes  the acceptance  filters  with  a  lower  number  filter  having higher  priority.  Messages  are  compared  to  filters  in ascending order of filter number.\nThe  mask  and  filter  registers  can  only  be  modified when the PIC18F6585/8585/6680/8680 devices are in Configuration mode.",
    "23.9 Baud Rate Setting\nThe Nominal Bit Time is defined as:\nAll  nodes  on  a  given  CAN  bus  must  have  the  same nominal bit rate. The CAN protocol uses Non-Returnto-Zero (NRZ) coding which does not encode a clock within  the  data  stream.  Therefore,  the  receive  clock must be recovered by the receiving nodes and synchronized to the transmitter's clock.\nAs  oscillators  and  transmission  time  may  vary  from node to  node,  the  receiver  must  have  some  type  of Phase Lock Loop (PLL) synchronized to data transmission  edges  to  synchronize  and  maintain  the  receiver clock. Since the data is NRZ coded, it is necessary to include  bit  stuffing  to  ensure  that  an  edge  occurs  at least every six bit times to maintain the Digital Phase Lock Loop (DPLL) synchronization.\nThe bit  timing  of  the  PIC18F6585/8585/6680/8680  is implemented using a DPLL that is configured to synchronize to the incoming data and provides the nominal timing for the transmitted data. The DPLL breaks each bit  time  into  multiple  segments  made  up  of  minimal periods of time called the Time Quanta (TQ).",
    "23.9 Baud Rate Setting\nBus timing functions executed within the bit time frame, such as synchronization to the local oscillator, network transmission  delay  compensation,  and  sample  point positioning, are defined by the programmable bit timing logic of the DPLL.\nAll devices on the CAN bus must use the same bit rate. However, all devices are not required to have the same master oscillator clock frequency. For the different clock frequencies of the individual devices, the bit rate has to be  adjusted  by  appropriately  setting  the  baud  rate prescaler and number of time quanta in each segment.\nThe Nominal Bit Rate is the number of bits transmitted per second, assuming an ideal transmitter with an ideal oscillator,  in  the  absence  of  resynchronization.  The nominal bit rate is defined to be a maximum of 1 Mb/s.",
    "EQUATION 23-1:\nTBIT = 1/Nominal Bit Rate\nThe  Nominal  Bit  Time  can  be  thought  of  as  being divided into separate, non-overlapping time segments. These segments (Figure 23-4) include:\n\u00b7 Synchronization Segment (Sync_Seg)\n\u00b7 Propagation Time Segment (Prop_Seg)\n\u00b7 Phase Buffer Segment 1 (Phase_Seg1)\n\u00b7 Phase Buffer Segment 2 (Phase_Seg2)\nThe time segments (and thus the Nominal Bit Time) are in  turn  made  up  of  integer  units  of  time  called  Time Quanta or TQ (see Figure 23-4). By definition, the Nominal Bit Time is programmable from a minimum of 8 TQ to a maximum of 25 TQ. Also by definition, the minimum Nominal Bit Time is 1 \uf06d s, corresponding to a maximum 1  Mb/s  rate.  The  actual  duration  is  given  by  the relationship:",
    "EQUATION 23-2:\n<!-- formula-not-decoded -->\nThe  Time  Quantum  is  a  fixed  unit  derived  from  the oscillator period. It is also defined by the programmable baud rate prescaler with integer values from 1 to 64 in addition to a fixed divide-by-two for clock generation. Mathematically, this is:",
    "EQUATION 23-3:\n```\nTQ ( \uf06d s) = (2 * (BRP+1))/FOSC (MHz) or TQ ( \uf06d s) = (2 * (BRP+1)) * TOSC ( \uf06d s)\n```\nwhere FOSC is the clock frequency, TOSC is the corresponding oscillator  period,  and  BRP  is  an  integer  (0 through  63)  represented  by  the  binary  values  of BRGCON1<5:0>.",
    "23.9.1 TIME QUANTA\nAs already mentioned, the Time Quanta is a fixed unit derived  from  the  oscillator period and  baud  rate prescaler. Its relationship to TBIT and the Nominal Bit Rate is shown in Example 23-6.",
    "EXAMPLE 23-6: CALCULATING TQ, NOMINAL BIT RATE AND NOMINAL BIT TIME\nTQ ( \uf06d s) = (2 * (BRP+1))/FOSC (MHz)\nTBIT ( \uf06d\ns) = TQ ( \uf06d s) * number of TQ per bit interval\nNominal Bit Rate (bits/s) = 1/TBIT",
    "CASE 1:\nFor FOSC = 16 MHz, BRP<5:0> = 00h and Nominal Bit Time = 8 TQ:\nTQ = (2*1)/16 = 0.125 \uf06d s (125 ns)\nTBIT = 8 * 0.125 = 1 \uf06d s (10 -6 s)\nNominal Bit Rate = 1/10 -6 = 10 6 bits/s (1 Mb/s)",
    "CASE 2:\nFor FOSC = 20 MHz, BRP<5:0> = 01h and Nominal Bit Time = 8 TQ:\nTQ = (2*2)/20 = 0.2 \uf06d s (200 ns)\nTBIT = 8 * 0.2 = 1.6 \uf06d s (1.6 * 10 -6 s)\nNominal Bit Rate = 1/1.6 * 10 -6 s = 625,000 bits/s (625 Kb/s)",
    "CASE 3:\nFor FOSC = 25 MHz, BRP<5:0> = 3Fh and Nominal Bit Time = 25 TQ:\nTQ = (2*64)/25 = 5.12 \uf06d s\nTBIT = 25 * 5.12 = 128 \uf06d s (1.28 * 10 -4 s)\nNominal Bit Rate = 1/1.28 * 10 (7.8 Kb/s)\n-4 = 7813 bits/s\nThe frequencies of the oscillators in the different nodes must be coordinated in order to provide a system wide specified nominal bit time. This means that all oscillators must have a TOSC that is an integral divisor of TQ. It should also be noted that although the number of TQ is programmable from 4 to 25, the usable minimum is 8 TQ. A  bit  time  of  less  than  8  TQ  in  length  is  not guaranteed to operate correctly.",
    "23.9.2 SYNCHRONIZATION SEGMENT\nThis  part  of  the  bit  time  is  used  to  synchronize  the various CAN nodes on the bus. The edge of the input signal is expected to occur during the sync segment. The duration is 1 TQ.",
    "23.9.3 PROPAGATION SEGMENT\nThis part of the bit time is used to compensate for physical delay times within the network. These delay times consist of the signal propagation time on the bus line and the internal delay time of the nodes. The length of the  Propagation  Segment  can  be  programmed  from 1 TQ to 8 TQ by setting the PRSEG2:PRSEG0 bits.",
    "23.9.4 PHASE BUFFER SEGMENTS\nThe  phase  buffer  segments  are  used  to  optimally locate the sampling point of the received bit within the nominal bit time. The sampling point occurs between Phase  Segment  1  and  Phase  Segment  2.  These segments  can  be  lengthened  or  shortened  by  the resynchronization process. The end of Phase Segment 1  determines  the  sampling  point  within  a  bit  time. Phase Segment 1 is programmable from 1 TQ to 8 TQ in  duration.  Phase  Segment  2  provides  delay  before the next transmitted data transition and is also programmable from 1 TQ to 8 TQ in duration. However, due to IPT requirements, the actual minimum length of Phase Segment 2 is 2 TQ, or it may be defined to be equal  to  the  greater  of  Phase  Segment  1  or  the Information Processing Time (IPT).",
    "23.9.5 SAMPLE POINT\nThe sample point is the point of time at which the bus level is read and the value of the received bit is determined. The sampling point occurs at the end of Phase Segment 1. If the bit timing is slow and contains many TQ, it is possible to specify multiple sampling of the bus line at the sample point. The value of the received bit is determined to be the value of the majority decision of three values. The three samples are taken at the sample point and twice before, with a time of TQ/2 between each sample.",
    "23.9.6 INFORMATION PROCESSING TIME\nThe  Information  Processing  Time  (IPT)  is  the  time segment starting at the sample point that is reserved for  calculation  of  the  subsequent  bit  level.  The  CAN specification defines this time to be less than or equal to 2 TQ.  The  PIC18F6585/8585/6680/8680  devices define this time to be 2 TQ.  Thus, Phase Segment 2 must be at least 2 TQ long.",
    "23.10 Synchronization\nTo compensate for phase shifts between the oscillator frequencies of each of the nodes on the bus, each CAN controller must be able to synchronize to the relevant signal edge of the incoming signal. When an edge in the transmitted data is detected, the logic will compare the location of the edge to the expected time (Sync_Seg). The circuit will then adjust the values of Phase Segment 1 and Phase Segment 2 as necessary. There are two mechanisms used for synchronization.",
    "23.10.1 HARD SYNCHRONIZATION\nHard  synchronization  is  only  done  when  there  is  a recessive to dominant edge during a bus Idle condition, indicating the start of a message. After hard synchronization, the bit time counters are restarted with Sync_Seg.  Hard  synchronization  forces the edge which  has  occurred  to  lie  within  the  synchronization segment of the restarted bit time. Due to the rules of synchronization, if a hard synchronization occurs there will not be a resynchronization within that bit time.",
    "23.10.2 RESYNCHRONIZATION\nAs  a  result  of  resynchronization,  Phase  Segment  1 may be lengthened or Phase Segment 2 may be shortened. The amount of lengthening or shortening of the phase buffer segments has an upper bound given by the Synchronization Jump Width (SJW). The value of the  SJW  will  be  added  to  Phase  Segment  1  (see Figure 23-5) or subtracted from Phase Segment 2 (see Figure 23-6). The SJW is programmable between 1 TQ and 4 TQ.\nClocking information will only be derived from recessive to dominant transitions. The property that only a fixed  maximum  number  of  successive  bits  have  the same  value,  ensures  resynchronization  to  the  bit stream during a frame.\nThe phase error of an edge is given by the position of the edge relative to Sync_Seg, measured in TQ. The phase error is defined in magnitude of TQ as follows:\n\u00b7 e = 0 if the edge lies within Sync_Seg.\n\u00b7 e > 0 if the edge lies before the sample point.\n\u00b7 e < 0 if the edge lies after the sample point of the previous bit.",
    "23.10.2 RESYNCHRONIZATION\nIf the magnitude of the phase error is less than, or equal to the programmed value of the synchronization jump width, the effect of a resynchronization is the same as that of a hard synchronization.\nIf  the magnitude of the phase error is larger than the synchronization jump width, and if the phase error is positive, then Phase Segment 1 is lengthened by an amount equal to the synchronization jump width.\nIf  the magnitude of the phase error is larger than the resynchronization jump width, and if the phase error is negative, then  Phase Segment 2 is shortened by an amount equal to the synchronization jump width.",
    "23.10.3 SYNCHRONIZATION RULES\n\u00b7 Only one synchronization within one bit time is allowed.\n\u00b7 An edge will be used for synchronization only if the value detected at the previous sample point (previously read bus value) differs from the bus value immediately after the edge.\n\u00b7 All other recessive to dominant edges fulfilling rules 1 and 2 will be used for resynchronization, with the exception that a node transmitting a dominant bit will not perform a resynchronization as a result of a recessive to dominant edge with a positive phase error.",
    "23.13.2 BRGCON2\nSome  requirements  for  programming  of  the  time segments:\n\u00b7 Prop_Seg + Phase_Seg 1 \uf0b3 Phase_Seg 2\n\u00b7 Phase_Seg 2 \uf0b3 Sync Jump Width.\nFor example, assume that a 125 kHz CAN baud rate is desired, using 20 MHz for FOSC. With a TOSC of 50 ns, a baud rate prescaler value of 04h gives a TQ of 500 ns. To obtain a Nominal Bit Rate of 125 kHz, the Nominal Bit Time must be 8 \uf06d s or 16 TQ.\nUsing 1 TQ for the Sync_Seg, 2 TQ for the Prop_Seg and 7 TQ for Phase Segment 1, would place the sample point at 10 TQ after the transition. This leaves 6 TQ for Phase Segment 2.\nBy the rules above, the Sync Jump Width could be the maximum of 4 TQ. However, normally a large SJW is only  necessary  when  the  clock  generation  of  the different nodes is inaccurate or unstable, such as using ceramic resonators. Typically, an SJW of 1 is enough.",
    "23.12 Oscillator Tolerance\nAs a rule of thumb, the bit timing requirements allow ceramic  resonators  to  be  used  in  applications  with transmission rates of up to 125 Kbit/sec. For the full bus speed range of the CAN protocol, a quartz oscillator is required. A maximum node-to-node oscillator variation of 1.7% is allowed.",
    "23.13 Bit Timing Configuration Registers\nThe Configuration  registers  (BRGCON1,  BRGCON2, BRGCON3)  control  the  bit  timing  for  the  CAN  bus interface. These registers can only be modified when the PIC18F6585/8585/6680/8680 devices are in Configuration mode.",
    "23.13.1 BRGCON1\nThe  BRP  bits  control  the  baud  rate  prescaler.  The SJW<1:0> bits select the synchronization jump width in terms of multiples of TQ.\nThe PRSEG bits set the length of the propagation segment in terms of TQ. The SEG1PH bits set the length of Phase Segment  1  in  TQ.  The  SAM  bit  controls  how many times the RXCAN pin is sampled. Setting this bit to a ' 1 ' causes the bus to be sampled three times; twice at TQ/2 before the sample point and once at the normal sample point (which is at the end of Phase Segment 1). The value of the bus is determined to be the value read during at least two of the samples. If the SAM bit is set to a ' 0 ', then the RXCAN pin is sampled only once at the sample point. The SEG2PHTS bit controls how the length of Phase Segment 2 is determined. If this bit is set  to  a  ' 1 ',  then  the  length  of  Phase  Segment  2",
    "23.13.1 BRGCON1\nis determined by the SEG2PH bits of BRGCON3. If the SEG2PHTS bit is set to a ' 0 ', then the length of Phase Segment 2 is the greater of Phase Segment 1 and the information processing time (which is fixed at 2 TQ for the PIC18F6585/8585/6680/8680).",
    "23.13.3 BRGCON3\nThe PHSEG2<2:0> bits set the length (in TQ) of Phase Segment 2 if the SEG2PHTS bit is set to a ' 1 '.  If  the SEG2PHTS bit is set to a ' 0 ', then the PHSEG2<2:0> bits have no effect.",
    "23.14 Error Detection\nThe CAN protocol provides sophisticated error detection  mechanisms.  The  following  errors  can  be detected.",
    "23.14.1 CRC ERROR\nWith the Cyclic Redundancy Check (CRC), the transmitter calculates special check bits for the bit sequence, from the start of a frame until the end of the data  field.  This  CRC  sequence  is  transmitted  in  the CRC field. The receiving node also calculates the CRC sequence  using  the  same  formula  and  performs  a comparison to the received sequence. If a mismatch is detected, a CRC error has occurred and an error frame is generated. The message is repeated.",
    "23.14.2 ACKNOWLEDGE ERROR\nIn the Acknowledge field of a message, the transmitter checks if the Acknowledge slot (which was sent out as a recessive bit) contains a dominant bit. If not, no other node  has  received  the  frame  correctly.  An  Acknowledge error has occurred; an error frame is generated and the message will have to be repeated.",
    "23.14.3 FORM ERROR\nIf  a  node  detects  a  dominant  bit  in  one  of  the  four segments,  including  end  of  frame,  interframe  space, Acknowledge delimiter, or CRC delimiter, then a form error  has  occurred  and  an  error  frame  is  generated. The message is repeated.",
    "23.14.4 BIT ERROR\nA bit error occurs if a transmitter sends a dominant bit and detects a recessive bit, or if it sends a recessive bit and detects a dominant bit, when monitoring the actual bus level and comparing it to the just transmitted bit. In the case where the transmitter sends a recessive bit and a dominant bit  is  detected  during  the  arbitration field and the Acknowledge slot, no bit error is generated because normal arbitration is occurring.",
    "23.14.5 STUFF BIT ERROR\nlf between the start of frame and the CRC delimiter, six consecutive bits with the same polarity are detected, the bit stuffing rule has been violated. A stuff bit error occurs and an error frame is generated. The message is repeated.",
    "23.14.6 ERROR STATES\nDetected errors are made public to all other nodes via error frames. The transmission of the erroneous message is aborted and the frame is repeated as soon as possible. Furthermore, each CAN node is in one of the three error states 'error-active', 'error-passive' or 'busoff' according to the value of the internal error counters. The error-active state is the usual state where the bus node can transmit messages and activate error frames (made of dominant bits) without any restrictions. In the error-passive state, messages and passive error frames (made of recessive  bits) may be  transmitted. The bus-off state makes it temporarily impossible for the  station  to  participate  in  the  bus  communication. During this  state,  messages  can  neither  be  received nor transmitted.",
    "23.14.7 ERROR MODES AND ERROR COUNTERS\nThe PIC18F6585/8585/6680/8680 devices contain two error counters: the Receive Error Counter (RXERRCNT), and the Transmit Error Counter (TXERRCNT). The values of both counters can be read by  the  MCU.  These  counters  are  incremented  or decremented in accordance with the CAN bus specification.",
    "23.14.7 ERROR MODES AND ERROR COUNTERS\nThe  PIC18F6585/8585/6680/8680  devices  are  erroractive if both error counters are below the error-passive limit of 128. They are error-passive if at least one of the error counters equals or exceeds 128. They go to busoff if the transmit error counter equals or exceeds the bus-off  limit  of  256.  The  devices  remain  in  this  state until  the  bus-off  recovery  sequence  is  received.  The bus-off recovery sequence consists of 128 occurrences of  11  consecutive  recessive  bits  (see  Figure 23-7). Note  that  the  CAN  module,  after  going  bus-off,  will recover back to error-active without any intervention by the MCU if the bus remains Idle for 128 x 11 bit times. If this is not desired, the error Interrupt Service Routine should  address  this.  The  current  Error  mode  of  the CAN  module  can  be  read  by  the  MCU  via  the COMSTAT register.\nAdditionally,  there  is  an  error  state  warning  flag  bit, EWARN,  which  is  set  if  at  least  one  of  the  error counters equals or exceeds the error warning limit of 96. EWARN is reset if both error counters are less than the error warning limit.",
    "23.15 CAN Interrupts\nThe transmit related interrupts are:\nThe module has several sources of interrupts. Each of these  interrupts  can  be  individually  enabled  or  disabled. The PIR3 register contains interrupt flags. The PIE3 register contains the enables for the 8 main interrupts. A special set of read-only bits in the CANSTAT register, the ICODE bits, can be used in combination with a jump table for efficient handling of interrupts.\nAll interrupts have one source with the exception of the error interrupt and buffer interrupts in Mode 1 and 2. Any of the error interrupt sources can set the error interrupt flag. The source of the error interrupt can be determined by reading the Communication Status register, COMSTAT.  In  Mode  1  and  2,  there  are  two  interrupt enable/disable and flag bits - one for all transmit buffers and the other for all receive buffers.\nThe interrupts can be broken up into two categories: receive and transmit interrupts.\nThe receive related interrupts are:\n\u00b7 Receive Interrupts\n\u00b7 Wake-up Interrupt\n\u00b7 Receiver Overrun Interrupt\n\u00b7 Receiver Warning Interrupt\n\u00b7 Receiver Error-Passive Interrupt\n\u00b7 Transmit Interrupts\n\u00b7 Transmitter Warning Interrupt\n\u00b7 Transmitter Error-Passive Interrupt\n\u00b7 Bus-Off Interrupt",
    "23.15.1 INTERRUPT CODE BITS\nTo simplify the interrupt handling process in user firmware, the ECAN module encodes a special set of bits. In Mode 0, these  bits  are  ICODE<2:0>  in  the  CANSTAT register. In Mode 1 and 2, these bits are EICODE<3:0> in the CANSTAT register. Interrupts are internally prioritized such that the higher priority interrupts are assigned lower values. Once the highest priority interrupt condition  has  been  cleared,  the  code  for  the  next  highest priority interrupt that is pending (if any) will be reflected by the ICODE bits. Note that only those interrupt sources that have their associated interrupt enable bit set will be reflected in the ICODE bits.\nIn Mode 2, when a receive message interrupt occurs, EICODE  bits  will  always  consist  of  ' 10000 '. User firmware may use FIFO pointer bits to actually access the next available buffer.",
    "23.15.2 TRANSMIT INTERRUPT\nWhen the transmit interrupt is enabled, an interrupt will be  generated  when  the  associated  transmit  buffer becomes empty and is ready to be loaded with a new message.  In  Mode  0,  there  are  separate  interrupt enable/disable  and  flag  bits  for  each  of  the  three dedicated transmit buffers. The TXBnIF bit will be set to indicate  the  source  of  the  interrupt.  The  interrupt  is cleared by the MCU resetting the TXBnIF bit to a ' 0 '. In Mode 1 and 2, all transmit buffers share one interrupt enable/disable and flag bits. In Mode 1 and 2, TXBIE in PIE3 and TXBIF in PIR3 indicate when a transmit buffer has  completed  transmission  of  its  message.  TXBnIF, TXBnIE and TXBnIP in PIR3, PIE3 and IPR3, respectively, are not used in Mode 1 and 2. Individual transmit buffer interrupts can be enabled or disabled by setting or clearing TXBIE and BnIE register bits. When a shared interrupt occurs, user firmware must poll the TXREQ bit of all transmit buffers to detect the source of interrupt.",
    "23.15.3 RECEIVE INTERRUPT\nWhen the receive interrupt is enabled, an interrupt will be generated when a message has been successfully received and loaded into the associated receive buffer. This interrupt is activated immediately after receiving the End Of Frame (EOF) field.\nIn Mode 0, the RXBnIF bit is set to indicate the source of  the  interrupt.  The  interrupt  is  cleared  by  the  MCU resetting the RXBnIF bit to a ' 0 '.\nIn Mode 1 and 2, all receive buffers share one interrupt. Individual receive buffer interrupts can be controlled by the  RXBnIE  and  BIEn  registers.  In  Mode  1,  when  a shared  receive  interrupt  occurs,  user  firmware  must poll the RXFUL bit of each receive buffer to detect the source  of  interrupt.  In  Mode  2,  a  receive  interrupt indicates that the new message is loaded into FIFO. FIFO can be read by using FIFO pointer bits, FP.\nIn Mode 2, the FIFOWMIF bit indicates if the FIFO high watermark  is  reached.  The  FIFO  high  watermark  is defined by the FIFOWM bit in the ECANCON register.",
    "23.15.4 MESSAGE ERROR INTERRUPT\nWhen an error occurs during transmission or reception of a message, the message error flag, IRXIF, will be set and if the IRXIE bit is set, an interrupt will be generated. This  is  intended  to  be  used  to  facilitate  baud  rate determination  when  used  in  conjunction  with  Listen Only mode.",
    "23.15.5 BUS ACTIVITY WAKE-UP INTERRUPT\nWhen the PIC18F6585/8585/6680/8680 devices are in Sleep mode and the bus activity wake-up interrupt is enabled, an interrupt will be generated and the WAKIF bit will be set when activity is detected on the CAN bus. This interrupt causes  the PIC18F6585/8585/6680/ 8680 devices to exit Sleep mode. The interrupt is reset by the MCU, clearing the WAKIF bit.",
    "23.15.6 ERROR INTERRUPT\nWhen  the  error  interrupt  is  enabled,  an  interrupt  is generated if an overflow condition occurs or if the error state of the transmitter or receiver has changed. The error flags in COMSTAT  will  indicate  one  of  the following conditions.",
    "23.15.6.1 Receiver Overflow\nAn  overflow  condition  occurs  when  the  MAB  has assembled  a  valid  received  message  (the  message meets  the  criteria  of  the  acceptance  filters)  and  the receive buffer associated with the filter is not available for loading of a new  message. The associated COMSTAT.RXnOVFL  bit  will  be  set  to  indicate  the overflow  condition.  This  bit  must  be  cleared  by  the MCU.",
    "23.15.6.2 Receiver Warning\nThe  receive  error  counter  has  reached  the  MCU warning limit of 96.",
    "23.15.6.3 Transmitter Warning\nThe  transmit  error  counter  has  reached  the  MCU warning limit of 96.",
    "23.15.6.4 Receiver Bus Passive\nThe  receive  error  counter  has  exceeded  the  errorpassive  limit  of  127  and  the  device  has  gone  to error-passive state.",
    "23.15.6.5 Transmitter Bus Passive\nThe  transmit  error  counter  has  exceeded  the  errorpassive  limit  of  127  and  the  device  has  gone  to error-passive state.",
    "23.15.6.6 Bus-Off\nThe transmit error counter has exceeded 255 and the device has gone to bus-off state.",
    "23.15.6.7 Interrupt Acknowledge\nInterrupts are directly associated with one or more status flags in the PIR register. Interrupts are pending as long as one of the flags is set. Once an interrupt flag is set  by  the  device,  the  flag  can  not  be  reset  by  the microcontroller until the interrupt condition is removed.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "24.1 Configuration Bits\nThere are several features intended to maximize system  reliability,  minimize  cost  through  elimination  of external components, provide power saving operating modes and offer code protection. These are:\n\u00b7 OSC Selection\n\u00b7 Reset\n-Power-on Reset (POR)\n-Power-up Timer (PWRT)\n-Oscillator Start-up Timer (OST)\n-Brown-out Reset (BOR)\n\u00b7 Interrupts\n\u00b7 Watchdog Timer (WDT)\n\u00b7 Sleep\n\u00b7 Code Protection\n\u00b7 ID Locations\n\u00b7 In-Circuit Serial Programming",
    "24.1 Configuration Bits\nAll PIC18F6585/8585/6680/8680 devices have a Watchdog Timer which is permanently enabled via the configuration bits or software controlled. It runs off its own RC oscillator for added reliability. There are two timers that offer necessary delays on power-up. One is the Oscillator Start-up Timer (OST), intended to keep the chip in Reset until the crystal  oscillator  is stable. The other is the Power-up Timer (PWRT) which provides a fixed delay on power-up only, designed to keep the part in Reset while the power supply stabilizes. With these two timers on-chip, most applications need no external Reset circuitry.\nSleep  mode  is  designed  to  offer  a  very  low  current Power-down mode. The user can wake-up from Sleep through external Reset, Watchdog Timer Wake-up, or through an interrupt. Several oscillator options are also made available to allow the part to fit the application. The RC oscillator option saves system cost, while the LP crystal option saves power. A set of configuration bits is used to select various options.",
    "24.1 Configuration Bits\nThe configuration bits can be programmed (read as ' 0 ') or  left  unprogrammed  (read  as  ' 1 ')  to  select  various device configurations. These bits are mapped, starting at program memory location 300000h.\nThe user will note that address 300000h is beyond the user program memory space. In fact, it belongs to the configuration memory space (300000h through 3FFFFFh)  which  can  only  be  accessed  using  table reads and table writes.\nProgramming the Configuration registers is done in a manner similar to programming the Flash memory. The EECON1 register WR bit starts a self-timed write to the Configuration  register.  In  normal  Operation  mode,  a TBLWT instruction with the TBLPTR pointed to the Configuration register sets up the address and the data for the  Configuration  register  write.  Setting  the  WR  bit starts  a  long write  to  the  Configuration  register.  The Configuration registers are written a byte at a time. To write or erase a configuration cell, a TBLWT instruction can write a ' 1 ' or a ' 0 ' into the cell.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n300001h, File Name = CONFIG1H. 300001h, Bit 7 = -. 300001h, Bit 6 = -. 300001h, Bit 5 = OSCSEN. 300001h, Bit 4 = -. 300001h, Bit 3 = FOSC3. 300001h, Bit 2 = FOSC2. 300001h, Bit 1 = FOSC1. 300001h, Bit 0 = FOSC0. 300001h, Default/ Unprogrammed Value = --1- 1111. 300002h, File Name = CONFIG2L. 300002h, Bit 7 = -. 300002h, Bit 6 = -. 300002h, Bit 5 = -. 300002h, Bit 4 = -. 300002h, Bit 3 = BORV1. 300002h, Bit 2 = BORV0. 300002h, Bit 1 = BODEN. 300002h, Bit 0 = PWRTEN. 300002h, Default/ Unprogrammed Value = ---- 1111.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n300003h, File Name = CONFIG2H. 300003h, Bit 7 = -. 300003h, Bit 6 = -. 300003h, Bit 5 = -. 300003h, Bit 4 = WDTPS3. 300003h, Bit 3 = WDTPS2. 300003h, Bit 2 = WDTPS1. 300003h, Bit 1 = WDTPS0. 300003h, Bit 0 = WDTEN. 300003h, Default/ Unprogrammed Value = ---1 1111. 300004h (1), File Name = CONFIG3L. 300004h (1), Bit 7 = WAIT. 300004h (1), Bit 6 = -. 300004h (1), Bit 5 = -. 300004h (1), Bit 4 = -. 300004h (1), Bit 3 = -. 300004h (1), Bit 2 = -. 300004h (1), Bit 1 = PM1. 300004h (1),",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\nBit 0 = PM0. 300004h (1), Default/ Unprogrammed Value = 1--- --11. 300005h, File Name = CONFIG3H. 300005h, Bit 7 = MCLRE. 300005h, Bit 6 = -. 300005h, Bit 5 = -. 300005h, Bit 4 = -. 300005h, Bit 3 = -. 300005h, Bit 2 = -. 300005h, Bit 1 = ECCPMX (4). 300005h, Bit 0 = CCP2MX. 300005h, Default/ Unprogrammed Value = 1--- --11. 300006h, File Name = CONFIG4L. 300006h, Bit 7 = DEBUG. 300006h, Bit 6 = -. 300006h, Bit 5 = -. 300006h, Bit 4 = -. 300006h, Bit 3 = -. 300006h, Bit 2 = LVP. 300006h, Bit 1 = -.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n300006h, Bit 0 = STVREN. 300006h, Default/ Unprogrammed Value = 1--- -1-1. 300008h, File Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = CP3 (2). 300008h, Bit 2 = CP2. 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300008h, Default/ Unprogrammed Value = ---- 1111. 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n300009h, Bit 0 = -. 300009h, Default/ Unprogrammed Value = 11-- ----. 30000Ah, File Name = CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -. 30000Ah, Bit 4 = -. 30000Ah, Bit 3 = WRT3 (2). 30000Ah, Bit 2 = WRT2. 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Ah, Default/ Unprogrammed Value = ---- 1111. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Bh, Default/",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\nUnprogrammed Value = 111- ----. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = EBTR3 (2). 30000Ch, Bit 2 = EBTR2. 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Ch, Default/ Unprogrammed Value = ---- 1111. 30000Dh, File Name = CONFIG7H. 30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -. 30000Dh, Default/ Unprogrammed Value = -1-- ----. 3FFFFEh,",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\nFile Name = DEVID1. 3FFFFEh, Bit 7 = DEV2. 3FFFFEh, Bit 6 = DEV1. 3FFFFEh, Bit 5 = DEV0. 3FFFFEh, Bit 4 = REV4. 3FFFFEh, Bit 3 = REV3. 3FFFFEh, Bit 2 = REV2. 3FFFFEh, Bit 1 = REV1. 3FFFFEh, Bit 0 = REV0. 3FFFFEh, Default/ Unprogrammed Value = (Note 3). 3FFFFFh, File Name = DEVID2. 3FFFFFh, Bit 7 = DEV10. 3FFFFFh, Bit 6 = DEV9. 3FFFFFh, Bit 5 = DEV8. 3FFFFFh, Bit 4 = DEV7. 3FFFFFh, Bit 3 = DEV6. 3FFFFFh, Bit 2 = DEV5. 3FFFFFh, Bit 1 = DEV4. 3FFFFFh, Bit 0 = DEV3. 3FFFFFh, Default/ Unprogrammed Value = 0000 1010\nLegend:",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\nx = unknown, u = unchanged, -= unimplemented, q = value depends on condition.\nShaded cells are unimplemented, read as ' 0 '.\nNote\n1: Unimplemented in PIC18F6X8X devices; maintain this bit set.\n2: Unimplemented in PIC18FX585 devices; maintain this bit set.\n3: See Register 24-13 for DEVID1 values.\n4: Reserved in PIC18F6X8X devices; maintain this bit set.",
    "CONFIG1H: CONFIGURATION REGISTER 1 HIGH (BYTE ADDRESS 300001h)\nU-0, 1 = U-0. U-0, 2 = R/P-1. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = OSCSEN. -, 3 = -. -, 4 = FOSC3. -, 5 = FOSC2. -, 6 = FOSC1. -, 7 = FOSC0\nbit 7\nbit 0",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5\nOSCSEN : Oscillator System Clock Switch Enable bit\n1 =  Oscillator system clock switch option is disabled (main oscillator is source)\n0 =  Timer1 oscillator system clock switch option is enabled (oscillator switching is enabled)",
    "bit 3-0 FOSC3:FOSC0 : Oscillator Selection bits\n1111\n= RC oscillator with OSC2 configured as RA6\n1110 = HS oscillator with SW enabled 4x PLL\n1101 = EC oscillator with OSC2 configured as RA6 and SW enabled 4x PLL\n1100 = EC oscillator with OSC2 configured as RA6 and HW enabled 4x PLL\n1011 = Reserved; do not use\n1010 = Reserved; do not use\n1001 = Reserved; do not use\n1000 = Reserved; do not use\n0111 = RC oscillator with OSC2 configured as RA6\n0110 = HS oscillator with HW enabled 4x PLL\n0101 = EC oscillator with OSC2 configured as RA6\n0100 = EC oscillator with OSC2 configured as divide by 4 clock output\n0011 = RC oscillator with OSC2 configured as divide by 4 clock output\n0010 = HS oscillator\n0001 = XT oscillator\n0000 = LP oscillator",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "CONFIG2L: CONFIGURATION REGISTER 2 LOW (BYTE ADDRESS 300002h)\nU-0\nU-0\nU-0\nU-0\nR/P-1\nR/P-1\nR/P-1\nR/P-1\n-\n-\n-\n-\nBORV1\nBORV0\nBOREN\nPWRTEN\nbit 7\nbit 0\nbit 7-4 Unimplemented: Read as ' 0 '\nbit 3-2\nBORV1:BORV0:\nBrown-out Reset Voltage bits\n11 = VBOR set to 2.0V\n10 = VBOR set to 2.7V\n01 = VBOR set to 4.2V\n00 = VBOR set to 4.5V\nbit 1 BOREN: Brown-out Reset Enable bit\n1 = Brown-out Reset enabled\n0 = Brown-out Reset disabled\nbit 0\nPWRTEN:\nPower-up Timer Enable bit\n1 = PWRT disabled\n0 = PWRT enabled",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-3: CONFIG2H: CONFIGURATION REGISTER 2 HIGH (BYTE ADDRESS 300003h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/P-1. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = WDTPS3. -, 4 = WDTPS2. -, 5 = WDTPS1. -, 6 = WDTPS0. -, 7 = WDTEN\nbit 7\nbit 0\nbit 7-5 Unimplemented: Read as ' 0 '\nbit 4-1 WDTPS3:WDTPS0: Watchdog Timer Postscaler Select bits\n1111 = 1:32768\n1110 = 1:16384\n1101 = 1:8192\n1100 = 1:4096\n1011 = 1:2048\n1010 = 1:1024\n1001 = 1:512\n1000 = 1:256",
    "REGISTER 24-3: CONFIG2H: CONFIGURATION REGISTER 2 HIGH (BYTE ADDRESS 300003h)\n0111 = 1:128\n0110 = 1:64\n0101 = 1:32\n0100 = 1:16\n0011 = 1:8\n0010 = 1:4\n0001 = 1:2\n0000 = 1:1",
    "bit 0 WDTEN: Watchdog Timer Enable bit\n1 = WDT enabled\n0 = WDT disabled (control is placed on the SWDTEN bit)\nLegend:, 1 = Legend:. R = Readable bit P = Programmable bit, 1 = U = Unimplemented bit, read as '0'. - n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 24-4: CONFIG3L: CONFIGURATION REGISTER 3 LOW (BYTE ADDRESS 300004h) (1)\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = U-0. R/P-1, 6 = R/P-1. R/P-1, 7 = R/P-1. WAIT, 1 = -. WAIT, 2 = -. WAIT, 3 = -. WAIT, 4 = -. WAIT, 5 = -. WAIT, 6 = PM1. WAIT, 7 = PM0\nbit 7\nbit 0",
    "bit 7 WAIT: External Bus Data Wait Enable bit\n1 = Wait selections unavailable for table reads and table writes\n0 = Wait selections for table reads and table writes are determined by WAIT1:WAIT0 bits (MEMCOM<5:4>)\nbit 6-2 Unimplemented: Read as ' 0\n'",
    "bit 1-0 PM1:PM0: Processor Mode Select bits\n11 = Microcontroller mode\n10 = Microprocessor mode\n01 = Microprocessor with Boot Block mode\n00 = Extended Microcontroller mode\nNote 1: This register is unimplemented for PIC18F6X8X devices; maintain these bits set.",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "CONFIG3H: CONFIGURATION REGISTER 3 HIGH (BYTE ADDRESS 300005h)\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = U-0. R/P-1, 6 = R/P-1. R/P-1, 7 = R/P-1. MCLRE, 1 = -. MCLRE, 2 = -. MCLRE, 3 = -. MCLRE, 4 = -. MCLRE, 5 = -. MCLRE, 6 = ECCPMX. MCLRE, 7 = CCP2MX\nbit 7\nbit 0\n- bit 7 MCLRE: MCLR Enable bit (1)\n1 = MCLR pin enabled, RG5 input pin disabled\n0 = RG5 input enabled, MCLR disabled",
    "CONFIG3H: CONFIGURATION REGISTER 3 HIGH (BYTE ADDRESS 300005h)\nbit 6-2 Unimplemented: Read as ' 0 '\nbit 1 ECCPMX: CCP1 PWM outputs P1B, P1C mux bit (PIC18F8X8X devices only) (2)\n1 = P1B, P1C are multiplexed with RE6, RE5\n0 = P1B, P1C are multiplexed with RH7, RH6",
    "bit 0 CCP2MX: CCP2 Mux bit\nIn Microcontroller mode:\n- 1 = CCP2 input/output is multiplexed with RC1\n0 = CCP2 input/output is multiplexed with RE7\n- In Microprocessor, Microprocessor with Boot Block and Extended Microcontroller modes",
    "(PIC18F8X8X devices only):\n1 = CCP2 input/output is multiplexed with RC1\n0 = CCP2 input/output is multiplexed with RB3\nNote 1: If  MCLR  is  disabled,  either  disable  low-voltage  ICSP  or  hold  RB5/PGM  low  to ensure proper entry into ICSP mode.\n- 2: Reserved for PIC18F6X8X devices; maintain this bit set.",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-6:\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = R/P-1. R/P-1, 6 = U-0. R/P-1, 7 = R/P-1. DEBUG, 1 = -. DEBUG, 2 = -. DEBUG, 3 = -. DEBUG, 4 = -. DEBUG, 5 = LVP. DEBUG, 6 = -. DEBUG, 7 = STVREN\nbit 7\nbit 0\nbit 7\nDEBUG: Background Debugger Enable bit\n1 = Background debugger disabled. RB6 and RB7 configured as general purpose I/O pins.\n0 = Background debugger enabled. RB6 and RB7 are dedicated to in-circuit debug.",
    "bit 6-3 Unimplemented: Read as ' 0 '\nbit 2 LVP: Low-Voltage ICSP Enable bit\n1 = Low-voltage ICSP enabled\n0 = Low-voltage ICSP disabled\nbit 1 Unimplemented: Read as ' 0 '\nbit 0 STVREN: Stack Full/Underflow Reset Enable bit\n1 = Stack full/underflow will cause Reset\n0 = Stack full/underflow will not cause Reset",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "CONFIG5L: CONFIGURATION REGISTER 5 LOW (BYTE ADDRESS 300008h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = CP3 (1). -, 5 = CP2. -, 6 = CP1. -, 7 = CP0\nbit 7\nbit 0\nbit 7-4 Unimplemented: Read as ' 0 '\nbit 3 CP3: Code Protection bit (1)\n1 = Block 3 (00C000-00FFFFh) not code-protected\n0 = Block 3 (00C000-00FFFFh) code-protected\nNote 1: Unimplemented in PIC18FX585 devices; maintain this bit set.",
    "bit 2 CP2: Code Protection bit\n1 = Block 2 (008000-00BFFFh) not code-protected\n0 = Block 2 (008000-00BFFFh) code-protected",
    "bit 1 CP1: Code Protection bit\n1 = Block 1 (004000-007FFFh) not code-protected\n0 = Block 1 (004000-007FFFh) code-protected",
    "bit 0 CP0: Code Protection bit\n1 = Block 0 (000800-003FFFh) not code-protected\n0 = Block 0 (000800-003FFFh) code-protected",
    "Legend:\nR = Readable bit\nC = Clearable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "CONFIG5H: CONFIGURATION REGISTER 5 HIGH (BYTE ADDRESS 300009h)\nR/C-1, 1 = R/C-1. R/C-1, 2 = U-0. R/C-1, 3 = U-0. R/C-1, 4 = U-0. R/C-1, 5 = U-0. R/C-1, 6 = U-0. R/C-1, 7 = U-0. CPD, 1 = CPB. CPD, 2 = -. CPD, 3 = -. CPD, 4 = -. CPD, 5 = -. CPD, 6 = -. CPD, 7 = -\nbit 7\nbit 0",
    "bit 7 CPD: Data EEPROM Code Protection bit\n1 = Data EEPROM not code-protected\n0 = Data EEPROM code-protected",
    "bit 6 CPB: Boot Block Code Protection bit\n1 = Boot block (000000-0007FFh) not code-protected\n0 = Boot block (000000-0007FFh) code-protected",
    "bit 5-0 Unimplemented: Read as ' 0 '\nLegend:, 1 = Legend:. R = Readable bit C = Clearable bit, 1 = U = Unimplemented bit, read as '0'. - n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "CONFIG6L: CONFIGURATION REGISTER 6 LOW (BYTE ADDRESS 30000Ah)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = WRT3 (1). -, 5 = WRT2. -, 6 = WRT1. -, 7 = WRT0\nbit 7\nbit 0",
    "bit 3 WRT3: Write Protection bit (1)\n1 = Block 3 (00C000-00FFFFh) not write-protected\n0 = Block 3 (00C000-00FFFFh) write-protected\nNote 1: Unimplemented in PIC18FX585 devices; maintain this bit set.",
    "bit 2 WRT2: Write Protection bit\n1 = Block 2 (008000-00BFFFh) not write-protected\n0 = Block 2 (008000-00BFFFh) write-protected\nbit 1 WRT1: Write Protection bit\n1 = Block 1 (004000-007FFFh) not write-protected\n0 = Block 1 (004000-007FFFh) write-protected",
    "bit 0 WR0: Write Protection bit\n1 = Block 0 (000800-003FFFh) not write-protected\n0 = Block 0 (000800-003FFFh) write-protected",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-10: CONFIG6H: CONFIGURATION REGISTER 6 HIGH (BYTE ADDRESS 30000Bh)\nR/C-1, 1 = R/C-1. R/C-1, 2 = R/C-1. R/C-1, 3 = U-0. R/C-1, 4 = U-0. R/C-1, 5 = U-0. R/C-1, 6 = U-0. R/C-1, 7 = U-0. WRTD, 1 = WRTB. WRTD, 2 = WRTC. WRTD, 3 = -. WRTD, 4 = -. WRTD, 5 = -. WRTD, 6 = -. WRTD, 7 = -\nbit 7\nbit 0\nbit 7 WRTD: Data EEPROM Write Protection bit\n1 = Data EEPROM not write-protected\n0 = Data EEPROM write-protected\nbit 6 WRTB: Boot Block Write Protection bit\n1 = Boot block (000000-0007FFh) not write-protected\n0 = Boot block (000000-0007FFh) write-protected",
    "bit 5 WRTC: Configuration Register Write Protection bit\n1 = Configuration registers (300000-3000FFh) not write-protected\n0 = Configuration registers (300000-3000FFh) write-protected",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-11: CONFIG7L: CONFIGURATION REGISTER 7 LOW (BYTE ADDRESS 30000Ch)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = EBTR3 (1). -, 5 = EBTR2. -, 6 = EBTR1. -, 7 = EBTR0\nbit 7\nbit 0",
    "bit 7-4 Unimplemented: Read as ' 0 '\nbit 3 EBTR3: Table Read Protection bit (1)\n1 = Block 3 (00C000-00FFFFh) not protected from table reads executed in other blocks\n0 = Block 3 (00C000-00FFFFh) protected from table reads executed in other blocks\nNote 1: Unimplemented in PIC18FX585 devices; maintain this bit set.",
    "bit 2 EBTR2: Table Read Protection bit\n1\n= Block 2 (008000-00BFFFh) not protected from table reads executed in other blocks = Block 2 (008000-00BFFFh) protected from table reads executed in other blocks\n0\nbit 1\nEBTR1:\nTable Read Protection bit\n1 = Block 1 (004000-007FFFh) not protected from table reads executed in other blocks 0 = Block 1 (004000-007FFFh) protected from table reads executed in other blocks",
    "bit 0 EBTR0: Table Read Protection bit\n1 = Block 0 (000800-003FFFh) not protected from table reads executed in other blocks\n0 = Block 0 (000800-003FFFh) protected from table reads executed in other blocks",
    "Legend:\nR = Readable bit P = Programmable bit, 1 = U = Unimplemented bit, read as '0'. - n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 24-12: CONFIG7H: CONFIGURATION REGISTER 7 HIGH (BYTE ADDRESS 30000Dh)\nU-0, 1 = R/C-1. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = U-0. -, 1 = EBTRB. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = -\nbit 7\nbit 0",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6 EBTRB: Boot Block Table Read Protection bit\n1 = Boot block (000000-0007FFh) not protected from table reads executed in other blocks\n0 = Boot block (000000-0007FFh) protected from table reads executed in other blocks",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-13: DEVICE ID REGISTER 1 FOR PIC18FXX8X DEVICES (ADDRESS 3FFFFEh)\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV2, 1 = DEV1. DEV2, 2 = DEV0. DEV2, 3 = REV4. DEV2, 4 = REV3. DEV2, 5 = REV2. DEV2, 6 = REV1. DEV2, 7 = REV0\nbit 7\nbit 0",
    "bit 7-5 DEV2:DEV0: Device ID bits\n000 = PIC18F8680\n001 = PIC18F6680\n010 = PIC18F8585\n011 = PIC18F6585\nbit 4-0 REV4:REV0: Revision ID bits\nThese bits are used to indicate the device revision.",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-14: DEVICE ID REGISTER 2 FOR PIC18FXX8X DEVICES (ADDRESS 3FFFFFh)\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-1. R-0, 5 = R-0. R-0, 6 = R-1. R-0, 7 = R-0. DEV10, 1 = DEV9. DEV10, 2 = DEV8. DEV10, 3 = DEV7. DEV10, 4 = DEV6. DEV10, 5 = DEV5. DEV10, 6 = DEV4. DEV10, 7 = DEV3\nbit 7\nbit 0",
    "bit 7-0 DEV10:DEV3: Device ID bits\nThese bits are used with the DEV2:DEV0 bits in the Device ID Register 1 to identify the part number.\n0000 1010 = PIC18F6585/8585/6680/8680",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n- n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "24.2 Watchdog Timer (WDT)\nThe  Watchdog  Timer  is  a  free-running,  on-chip  RC oscillator which does not require any external components.  This  RC  oscillator  is  separate  from  the  RC oscillator of the OSC1/CLKI pin. That means that the WDT will run even if the clock on the OSC1/CLKI and OSC2/CLKO/RA6 pins of the device has been stopped, for example, by execution of a SLEEP instruction.\nThe  WDT  time-out  period  values  may  be  found  in Section 27.0 'Electrical Characteristics' under parameter #31. Values for the WDT postscaler may be assigned using the configuration bits.\nDuring normal operation, a WDT time-out generates a device Reset (Watchdog Timer Reset). If the device is in Sleep mode, a WDT time-out causes the device to wake-up and continue with normal operation (Watchdog Timer wake-up). The TO bit in the RCON register will be cleared upon a WDT time-out.",
    "24.2 Watchdog Timer (WDT)\nThe Watchdog Timer is enabled/disabled by a device configuration  bit.  If  the  WDT  is  enabled,  software execution  may  not  disable  this  function.  When  the WDTEN configuration bit is cleared, the SWDTEN bit enables/disables the operation of the WDT.\nNote 1: The CLRWDT and SLEEP instructions clear the WDT  and  the  postscaler  if assigned to the WDT and prevent it from timing out and generating a device Reset condition.\n2: When a CLRWDT instruction  is  executed and  the  postscaler  is  assigned  to  the WDT, the postscaler count will be cleared but the postscaler assignment  is not changed.",
    "24.2.1 CONTROL REGISTER\nRegister 24-15 shows the WDTCON register. This is a readable and writable register which contains a control bit  that  allows  software  to  override  the  WDT  enable configuration  bit,  only  when  the  configuration  bit  has disabled the WDT.",
    "REGISTER 24-15: WDTCON REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = SWDTEN\nbit 7\nbit 0",
    "bit 7-1 Unimplemented : Read as ' 0 '\nbit 0\nSWDTEN: Software Controlled Watchdog Timer Enable bit\n1 = Watchdog Timer is on\n0 = Watchdog Timer is turned off if the WDTEN configuration bit in the Configuration register = 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n- n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared x = Bit is unknown",
    "24.2.2 WDT POSTSCALER\nThe WDT has a postscaler that can extend the WDT Reset period. The postscaler is selected at the time of the  device  programming  by  the  value  written  to  the CONFIG2H Configuration register.",
    "TABLE 24-2: SUMMARY OF WATCHDOG TIMER REGISTERS\n\nLegend: Shaded cells are not used by the Watchdog Timer.",
    "TABLE 24-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nCONFIG2H, Bit 7 = -. CONFIG2H, Bit 6 = -. CONFIG2H, Bit 5 = -. CONFIG2H, Bit 4 = WDTPS3. CONFIG2H, Bit 3 = WDTPS2. CONFIG2H, Bit 2 = WDTPS2. CONFIG2H, Bit 1 = WDTPS0. CONFIG2H, Bit 0 = WDTEN. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. WDTCON, Bit 7 = -. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTEN",
    "24.3 Power-down Mode (Sleep)\nPower-down mode is entered by executing a SLEEP instruction.\nOther  peripherals  cannot  generate  interrupts  since during Sleep, no on-chip clocks are present.\nIf  enabled,  the  Watchdog  Timer  will  be  cleared  but keeps running, the PD bit (RCON<3>) is cleared, the TO (RCON<4>) bit  is  set  and  the  oscillator  driver  is turned off. The I/O ports maintain the status they had before  the SLEEP instruction  was  executed  (driving high, low, or high-impedance).\nFor lowest current consumption in this mode, place all I/O pins at either VDD or VSS, ensure no external circuitry is drawing current from the I/O pin, power-down the A/D and disable external clocks. Pull all  I/O pins that are high-impedance inputs, high or low externally to avoid switching currents caused by floating inputs. The T0CKI input should also be at VDD or VSS for lowest current consumption. The contribution from on-chip pull-ups on PORTB should be considered.\nThe MCLR pin must be at a logic high level (VIHMC).",
    "24.3.1 WAKE-UP FROM SLEEP\nThe device can wake-up from Sleep through one of the following events:\n1. External Reset input on MCLR pin.\n2. Watchdog Timer Wake-up (if WDT was enabled).\n3. Interrupt  from  INT  pin,  RB  port  change  or  a peripheral interrupt.\nThe following peripheral interrupts can wake the device from Sleep:\n1. PSP read or write.\n2. TMR1 interrupt. Timer1 must be operating as an asynchronous counter.\n3. TMR3 interrupt. Timer3 must be operating as an asynchronous counter.\n4. CCP Capture mode interrupt.\n5. Special event trigger (Timer1 in Asynchronous mode using an external clock).\n6. MSSP (Start/Stop) bit detect interrupt.\n7. MSSP  transmit or receive in Slave mode (SPI/I 2 C).\n8. USART RX or TX (Synchronous Slave mode).\n9. A/D conversion (when A/D clock source is RC).\n10. EEPROM write operation complete.\n11. LVD interrupt.\n12. CAN wake-up interrupt.",
    "24.3.1 WAKE-UP FROM SLEEP\nExternal MCLR Reset will cause a device  Reset. All other events are considered a continuation of program execution and will cause a 'wake-up'. The TO and PD bits in the RCON register can be used to determine the cause of the device Reset. The PD bit which is set on power-up is cleared when Sleep is invoked. The TO bit is  cleared  if  a  WDT  time-out  occurred  (and  caused wake-up).\nWhen the SLEEP instruction is being executed, the next instruction (PC + 2) is pre-fetched. For the device to wake-up through an interrupt event, the corresponding interrupt enable bit must be set (enabled). Wake-up is regardless of the state of the GIE bit. If the GIE bit is clear (disabled), the device continues execution at the instruction after the SLEEP instruction. If the GIE bit is set (enabled), the device executes the instruction after the SLEEP instruction and then branches to the interrupt  address.  In  cases  where  the  execution  of  the instruction following SLEEP is  not desirable,  the  user should have a NOP after the SLEEP instruction.",
    "24.3.2 WAKE-UP USING INTERRUPTS\nWhen global interrupts are disabled (GIE cleared) and any  interrupt  source  has  both  its  interrupt  enable  bit and interrupt flag bit set, one of the following will occur:\n\u00b7 If an interrupt condition (interrupt flag bit and interrupt enable bits are set) occurs before the execution of a SLEEP instruction, the SLEEP instruction will complete as a NOP . Therefore, the WDT and WDT postscaler will not be cleared, the TO bit will not be set and PD bits will not be cleared.\n\u00b7 If the interrupt condition occurs during or after the execution of a SLEEP instruction, the device will immediately wake-up from Sleep. The SLEEP instruction will be completely executed before the wake-up. Therefore, the WDT and WDT postscaler will be cleared, the TO bit will be set and the PD bit will be cleared.\nEven if the flag bits were checked before executing a SLEEP instruction,  it  may  be  possible  for  flag  bits  to become set before the SLEEP instruction completes. To determine whether a SLEEP instruction executed, test the PD bit. If the PD bit is set, the SLEEP instruction was executed as a NOP .",
    "24.3.2 WAKE-UP USING INTERRUPTS\nTo ensure that the WDT  is  cleared, a CLRWDT instruction should be executed before a SLEEP instruction.",
    "FIGURE 24-2: WAKE-UP FROM SLEEP THROUGH INTERRUPT (1,2)\nNote\n1: XT, HS or LP Oscillator mode assumed.\n2: GIE = 1 assumed. In this case after wake-up, the processor jumps to the interrupt routine. If GIE = 0 , execution will continue in-line.\n3: TOST = 1024 TOSC (drawing not to scale). This delay will not occur for RC and EC Oscillator modes.\n4: CLKO is not available in these oscillator modes but shown here for timing reference.",
    "24.4 Program Verification and Code Protection\nThe  overall  structure  of  the  code  protection  on  the PIC18  Flash  devices  differs  significantly  from  other PIC \u00ae  devices.\nFigure 24-3 shows the program memory organization for  48  and  64-Kbyte  devices  and  the  specific  code protection bit associated with each block. The actual locations of the bits are summarized in Table 24-3.\nThe user program memory is divided on binary boundaries into four blocks of 16 Kbytes each. The first block is further divided into a boot block of 2048 bytes and a second block (Block 0) of 14 Kbytes.\nEach  of  the  blocks  has  three  code  protection  bits associated with them. They are:\n\u00b7 Code-Protect bit (CPn)\n\u00b7 Write-Protect bit (WRTn)\n\u00b7 External Block Table Read bit (EBTRn)",
    "FIGURE 24-3: CODE-PROTECTED PROGRAM MEMORY FOR PIC18FXX8X DEVICES\nBoot Block, MEMORY SIZE/DEVICE.64 Kbytes (PIC18FX680) = Boot Block. Boot Block, Address Range = 000000h 0007FFh. Boot Block, Block Protection.Code Controlled By: = CPB, WRTB, EBTRB. Block 0, MEMORY SIZE/DEVICE.64 Kbytes (PIC18FX680) = Block 0. Block 0, Address Range = 000800h 003FFFh. Block 0, Block Protection.Code Controlled By: = CP0, WRT0, EBTR0. Block 1, MEMORY SIZE/DEVICE.64 Kbytes (PIC18FX680) = Block 1. Block 1, Address Range = 004000h 007FFFh. Block 1, Block Protection.Code Controlled By: = CP1, WRT1, EBTR1. Block 2, MEMORY SIZE/DEVICE.64 Kbytes (PIC18FX680) = Block 2. Block 2, Address Range = 008000h 00BFFFh. Block 2, Block Protection.Code Controlled By: =",
    "FIGURE 24-3: CODE-PROTECTED PROGRAM MEMORY FOR PIC18FXX8X DEVICES\nCP2, WRT2, EBTR2. Unimplemented Read ' 0 ', MEMORY SIZE/DEVICE.64 Kbytes (PIC18FX680) = Block 3. Unimplemented Read ' 0 ', Address Range = 00C000h 00FFFFh. Unimplemented Read ' 0 ', Block Protection.Code Controlled By: = CP3, WRT3, EBTR3",
    "TABLE 24-3: SUMMARY OF CODE PROTECTION REGISTERS\n300008h, File Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = CP3 (1). 300008h, Bit 2 = CP2. 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -. 300009h, Bit 0 = -. 30000Ah, File Name = CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -. 30000Ah, Bit 4 = -.",
    "TABLE 24-3: SUMMARY OF CODE PROTECTION REGISTERS\n30000Ah, Bit 3 = WRT3 (1). 30000Ah, Bit 2 = WRT2. 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = EBTR3 (1). 30000Ch, Bit 2 = EBTR2. 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Dh, File Name =",
    "TABLE 24-3: SUMMARY OF CODE PROTECTION REGISTERS\nCONFIG7H. 30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -\nLegend: Shaded cells are unimplemented.\nNote 1: Unimplemented in PIC18FX585 devices.",
    "24.4.1 PROGRAM MEMORY CODE PROTECTION\nThe user memory may be read to or written from any location  using  the  table  read  and  table  write  instructions. The device ID may be read with table reads. The Configuration registers may be read and written with the table read and table write instructions.\nthat block is not allowed to read and will result in reading ' 0 's. Figures 24-4 through 24-6 illustrate table write and table read protection.\nNote:\nIn User mode, the CPn bits have no direct effect. CPn bits inhibit external reads and writes. A block of user memory  may  be  protected  from  table  writes  if  the WRTn configuration bit is ' 0 '.  The EBTRn bits control table  reads.  For  a  block  of  user  memory  with  the EBTRn bit set to ' 0 ', a table read instruction that executes from within that block is allowed to read. A table read instruction that executes from a location outside of",
    "24.4.1 PROGRAM MEMORY CODE PROTECTION\nCode protection bits may only be written to a ' 0 '  from a ' 1 '  state. It is not possible to write  a  ' 1 '  to  a  bit  in  the  ' 0 '  state.  Code protection bits are only set to ' 1 '  by a full chip erase or block erase function. The full chip erase and block erase functions can only  be  initiated  via  ICSP  or  an  external programmer.",
    "FIGURE 24-4: TABLE WRITE (WRTn) DISALLOWED\n, Program Memory.TBLWT * = TBLWT. , Program Memory.000000h 0007FFh 000800h 003FFFh 004000h = 007FFFh 008000h. , Configuration Bit Settings.WRTB, EBTRB = 11 WRT0, EBTR0 = 01 = WRT2, EBTR2 = 11. PC = 008FFEh, Program Memory.TBLWT * = *. PC = 008FFEh, Program Memory.000000h 0007FFh 000800h 003FFFh 004000h = 00BFFFh 00C000h 00FFFFh. PC = 008FFEh, Configuration Bit Settings.WRTB, EBTRB = 11 WRT0, EBTR0 = 01 = WRT3, EBTR3 = 11. Results: All table writes disabled to Block n whenever WRTn = 0 ., Program Memory.TBLWT * = Results: All table writes disabled to Block n whenever WRTn = 0 .. Results: All table writes disabled to Block",
    "FIGURE 24-4: TABLE WRITE (WRTn) DISALLOWED\nn whenever WRTn = 0 ., Program Memory.000000h 0007FFh 000800h 003FFFh 004000h = Results: All table writes disabled to Block n whenever WRTn = 0 .. Results: All table writes disabled to Block n whenever WRTn = 0 ., Configuration Bit Settings.WRTB, EBTRB = 11 WRT0, EBTR0 = 01 = Results: All table writes disabled to Block n whenever WRTn = 0 .",
    "FIGURE 24-5: EXTERNAL BLOCK TABLE READ (EBTRn) DISALLOWED\nTBLPTR = 000FFFh PC = 004FFEh, Program Memory. = TBLRD *. TBLPTR = 000FFFh PC = 004FFEh, Program Memory.0007FFh 000800h 000000h = 003FFFh 004000h. TBLPTR = 000FFFh PC = 004FFEh, Configuration Bit Settings.Configuration Bit Settings = WRT0, EBTR0 = 10. Results: All table reads, Program Memory. = . Results: All table reads, Program Memory.0007FFh 000800h 000000h = 007FFFh 008000h 00BFFFh 00C000h 00FFFFh. Results: All table reads, Configuration Bit Settings.Configuration Bit Settings = WRT1, EBTR1 = 11 WRT2, EBTR2 = 11 WRT3, EBTR3 = 11. from external blocks to Block n are disabled whenever EBTRn = 0 . TABLAT register returns a value of ' 0 '., Program Memory. = . from external blocks to Block n",
    "FIGURE 24-5: EXTERNAL BLOCK TABLE READ (EBTRn) DISALLOWED\nare disabled whenever EBTRn = 0 . TABLAT register returns a value of ' 0 '., Program Memory.0007FFh 000800h 000000h = . from external blocks to Block n are disabled whenever EBTRn = 0 . TABLAT register returns a value of ' 0 '., Configuration Bit Settings.Configuration Bit Settings = ",
    "FIGURE 24-6: EXTERNAL BLOCK TABLE READ (EBTRn) ALLOWED\nTBLPTR = 000FFFh, Program Memory. = . TBLPTR = 000FFFh, Program Memory.0007FFh 000800h 000000h = . PC = 003FFEh, Program Memory. = . PC = 003FFEh, Program Memory.0007FFh 000800h 000000h = 003FFFh 004000h. , Program Memory. = . , Program Memory.0007FFh 000800h 000000h = . , Program Memory. = . , Program Memory.0007FFh 000800h 000000h = 007FFFh 008000h. , Program Memory. = . , Program Memory.0007FFh 000800h 000000h = . , Program Memory. = . , Program Memory.0007FFh 000800h 000000h = 00BFFFh 00C000h. , Program Memory. = . , Program Memory.0007FFh 000800h 000000h = . , Program Memory. = . , Program Memory.0007FFh 000800h",
    "FIGURE 24-6: EXTERNAL BLOCK TABLE READ (EBTRn) ALLOWED\n000000h = 00FFFFh. Results: Table reads permitted within Block n even when EBTRBn = 0 . TABLAT register returns the value of the data at the location TBLPTR., Program Memory. = Results: Table reads permitted within Block n even when EBTRBn = 0 . TABLAT register returns the value of the data at the location TBLPTR.. Results: Table reads permitted within Block n even when EBTRBn = 0 . TABLAT register returns the value of the data at the location TBLPTR., Program Memory.0007FFh 000800h 000000h = Results: Table reads permitted within Block n even when EBTRBn = 0 . TABLAT register returns the value of the data at the location TBLPTR.",
    "24.4.2 DATA EEPROM CODE PROTECTION\nThe entire  data  EEPROM  is  protected  from  external reads and writes by two bits: CPD and WRTD. CPD inhibits  external  reads  and  writes  of  data  EEPROM. WRTD inhibits external writes to data EEPROM. The CPU can continue  to  read  and  write  data  EEPROM regardless of the protection bit settings.",
    "24.4.3 CONFIGURATION REGISTER PROTECTION\nThe Configuration registers can be write-protected. The WRTC bit controls protection of the Configuration registers. In User mode, the WRTC bit is readable only. WRTC can only be written via ICSP or an external programmer.",
    "24.5 ID Locations\nEight memory locations (200000h-200007h) are designated as ID locations where the user can store checksum or other code identification numbers. These locations are accessible during normal execution through the TBLRD and TBLWT instructions  or  during program/verify. The ID locations can be read when the device is code-protected.",
    "24.6 In-Circuit Serial Programming\nPIC18FXX80/XX85  microcontrollers  can  be  serially programmed while in the end application circuit. This is simply done with two lines for clock and data, and three other  lines  for  power,  ground  and  the  programming voltage. This allows customers to manufacture boards with  unprogrammed  devices  and  then  program  the microcontroller just before shipping  the product. This also  allows  the  most  recent  firmware  or  a  custom firmware to be programmed.",
    "24.7 In-Circuit Debugger\nWhen  the DEBUG  bit in Configuration register, CONFIG4L,  is  programmed  to  a  ' 0 ', the  in-circuit debugger functionality is enabled. This function allows simple debugging functions when used with MPLAB \u00ae IDE. When the microcontroller has this feature enabled, some of the resources are not available for general  use.  Table 24-4  shows  which  features  are consumed by the background debugger.",
    "TABLE 24-4: DEBUGGER RESOURCES\nStack, RB6, RB7 = 2 levels. Program Memory, RB6, RB7 = 512 bytes. Data Memory, RB6, RB7 = 10 bytes\nTo  use  the  in-circuit  debugger  function  of  the  microcontroller, the design must implement In-Circuit Serial Programming connections to MCLR/VPP, VDD, GND, RB7  and  RB6.  This  will  interface  to  the  in-circuit debugger module available from Microchip or one of the third party development tool companies.",
    "24.8 Low-Voltage ICSP Programming\nThe  LVP  bit  in Configuration register, CONFIG4L, enables  Low-Voltage  ICSP  Programming.  This  mode allows the microcontroller to be programmed via ICSP using a VDD source in the operating voltage range. This only means that VPP does not have to be brought to VIHH but can instead be left at the normal operating voltage. In this mode, the RB5/KBI1/PGM pin is dedicated to the programming function and ceases to be a general purpose I/O pin. During programming, VDD is applied to the RG5/MCLR/VPP pin. To enter Programming mode, VDD must be applied to the RB5/KBI1/PGM pin, provided the LVP bit  is  set.  The  LVP  bit  defaults  to  a  ' 1 '  from  the factory.",
    "24.8 Low-Voltage ICSP Programming\nNote 1: The High-Voltage Programming mode is always available regardless of the state of the LVP bit, by applying VIHH to the MCLR pin.\n2: While  in  Low-Voltage  ICSP  mode,  the RB5  pin  can  no  longer  be  used  as  a general  purpose  I/O  pin  and  should  be held low during normal operation.\n3: When using Low-Voltage ICSP Programming (LVP) and the pull-ups on PORTB are enabled, bit 5 in the TRISB register must be cleared to disable the pull-up on RB5 and ensure the proper operation of the device.\n4: If  the  device  Master  Clear  is  disabled, verify that either of the following is done to ensure proper entry into ICSP mode:\na) disable  Low-Voltage  Programming (CONFIG4L<2> = 0 ); or\nb) make certain that RB5/KBI1/PGM is held low during entry into ICSP.",
    "24.8 Low-Voltage ICSP Programming\nIf Low-Voltage Programming mode is not used, the LVP bit  can  be  programmed  to  a  ' 0 '  and  RB5/KBI1/PGM becomes a digital I/O pin. However, the LVP bit may only  be  programmed  when  programming  is  entered with VIHH on RG5/MCLR/VPP.\nIt should be noted that once the LVP bit is programmed to  ' 0 ', only  the  High-Voltage  Programming  mode  is available  and  only  High-Voltage  Programming  mode can be used to program the device.\nWhen using low-voltage ICSP, the part must be supplied 4.5V to 5.5V if a bulk erase will be executed. This includes reprogramming of the code-protect bits from an on-state to an off-state. For all other cases of lowvoltage  ICSP,  the  part  may  be  programmed  at  the normal operating voltage. This means unique user IDs or user code can be reprogrammed or added.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "25.0 INSTRUCTION SET SUMMARY\nThe PIC18 instruction set adds many enhancements to the previous PIC MCU instruction sets, while maintaining an easy migration from these PIC MCU instruction sets.\nMost instructions are a single program memory word (16 bits) but there are three instructions that require two program memory locations.\nEach single-word instruction is  a  16-bit  word  divided into an opcode, which specifies the instruction type and one  or  more  operands,  which  further  specify  the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\n\u00b7 Byte-oriented operations\n\u00b7 Bit-oriented operations\n\u00b7 Literal operations\n\u00b7 Control operations\nThe PIC18 instruction set summary in Table 25-2 lists byte-oriented , bit-oriented , literal and control operations. Table 25-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The destination of the result (specified by 'd')\n3. The accessed memory (specified by 'a')\nThe  file  register  designator  'f'  specifies  which  file register is to be used by the instruction.",
    "25.0 INSTRUCTION SET SUMMARY\nThe  destination  designator  'd'  specifies  where  the result of the operation is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result  is  placed  in  the  file  register  specified  in  the instruction.\nAll bit-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The bit in the file register (specified by 'b')\n3. The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\n\u00b7 A literal value to be loaded into a file register (specified by 'k')\n\u00b7 The desired FSR register to load the literal value into (specified by 'f')\n\u00b7 No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "25.0 INSTRUCTION SET SUMMARY\n\u00b7 A program memory address (specified by 'n')\n\u00b7 The mode of the call or return instructions (specified by 's')\n\u00b7 The mode of the table read and table write instructions (specified by 'm')\n\u00b7 No operand required (specified by '-')\nAll  instructions  are  a  single  word  except  for  three double-word instructions. These  three instructions were  made  double-word  instructions  so  that  all  the required information is available in these 32 bits. In the second word, the 4 MSbs are ' 1 's. If this second word is executed as an instruction (by itself), it will execute as a NOP .\nAll  single-word  instructions  are  executed  in  a  single instruction cycle unless a conditional test is true or the program counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles with the additional instruction cycle(s) executed as a NOP .\nThe double-word instructions execute in two instruction cycles.",
    "25.0 INSTRUCTION SET SUMMARY\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \uf06d s. If a conditional test is true or the program counter is changed as a result of an instruction,  the  instruction  execution  time  is  2 \uf06d s. Two-word branch instructions (if true) would take 3 \uf06d s.\nFigure 25-1 shows the general formats that the instructions can have.\nAll examples use the format ' nnh ' to represent a hexadecimal  number,  where  ' h ' signifies  a  hexadecimal digit.\nThe  Instruction  Set  Summary,  shown  in  Table 25-2, lists the instructions recognized  by  the  Microchip Assembler (MPASM TM ).\nSection 25.1 'Instruction Set' provides a description of each instruction.",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\na, Description = RAM access bit a = 0 : RAM location in Access RAM (BSR register is ignored) a = 1 : RAM bank is specified by BSR register. bbb, Description = Bit address within an 8-bit file register (0 to 7).. BSR, Description = Bank Select Register. Used to select the current RAM bank.. d, Description = Destination select bit d = 0 : store result in WREG d = 1 : store result in file register f. dest, Description = Destination either the WREG register or the specified register file location.. f, Description = 8-bit register file address (0x00 to 0xFF).. fs, Description = 12-bit register file address (0x000 to 0xFFF). This is the source address.. fd, Description = 12-bit register file address (0x000 to 0xFFF). This is the destination address.. k, Description = Literal field, constant data or label (may be either an 8-bit, 12-bit or a 20-bit value).. label, Description = Label name.. mm *, Description =",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\nThe mode of the TBLPTR register for the table read and table write instructions. Only used with table read and table write instructions: No change to register (such as TBLPTR with table reads and writes). Post-Increment register (such as TBLPTR with table reads and writes).. *+, Description = . *-, Description = Post-Decrement register (such as TBLPTR with table reads and writes). Pre-Increment register (such as TBLPTR with table reads and writes).. +*, Description = The relative address (2's complement number) for relative branch instructions, call/branch and return instructions.. n, Description = or the direct address for. PRODH, Description = Product of Multiply High Byte.. PRODL s, Description = Product of Multiply Low Byte. Fast Call/Return mode select bit s = 0 : do not update into/from shadow registers s = : certain registers loaded into/from shadow registers (Fast mode). u, Description = Unused or unchanged.. WREG, Description = Working register (accumulator).. x, Description = Don't care (0 or",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\n1). The assembler will generate code with x = 0 . It is the recommended form of use for compatibility with all Microchip software tools.. TBLPTR, Description = 21-bit Table Pointer (points to a program memory location).. TABLAT, Description = 8-bit Table Latch.. TOS, Description = Top-of-Stack.. PC, Description = Program Counter.. PCL, Description = Program Counter Low Byte.. PCH, Description = Program Counter High Byte.. PCLATH, Description = Program Counter High Byte Latch.. PCLATU, Description = Program Counter Upper Byte Latch.. GIE, Description = Global Interrupt Enable bit.. WDT, Description = Watchdog Timer.. TO, Description = Time-out bit.. PD, Description = Power-down bit.. [ ], Description = . , Description = Optional.. ( ), Description = Contents.. \uf0ae, Description = Assigned to.. , Description = field.. < >, Description = Register bit. , Description = User defined term (font. italics, Description = is courier).",
    "GENERAL FORMAT FOR INSTRUCTIONS\n, Byte-oriented Example Instruction..ADDWF MYREG, W, B.a = to force Access Bank...0 MOVFF MYREG1, MYREG2.MOVLW 0x7F.BSF MYREG, bit, B..8-bit immediate value.0..(literal).= and Branch operations operations.GOTO.0.GOTO Label.(literal).n<7:0>..0..12 11..1111 n<19:8> (literal)...OPCODE CALL MYFUNC S.n<7:0>....(literal).0 (literal) 0...(literal).0.BRA.8 7 0.MYFUNC.BC..(literal) MYFUNC = . , address.......k............................... = n<7:0>",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\nBYTE-ORIENTED FILE REGISTER OPERATIONS,  = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Description. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Cycles. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Status.Affected = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Notes. = BYTE-ORIENTED FILE REGISTER OPERATIONS. ADDWF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. ADDWF, Description. = Add WREG and f. ADDWF, Cycles. = 1. ADDWF, 16-Bit Instruction Word.MSb = 0010. ADDWF, 16-Bit Instruction Word. = 01da. ADDWF, 16-Bit Instruction Word. = ffff. ADDWF, 16-Bit Instruction Word.LSb = ffff. ADDWF, Status.Affected = C, DC, Z, OV, N. ADDWF, Notes. = 1, 2. ADDWFC,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. ADDWFC, Description. = Add WREG and Carry bit to f. ADDWFC, Cycles. = 1. ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word. = 00da. ADDWFC, 16-Bit Instruction Word. = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status.Affected = C, DC, Z, OV, N. ADDWFC, Notes. = 1, 2. ANDWF,  = f, d, a. ANDWF, Description. = AND WREG with f. ANDWF, Cycles. = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001. ANDWF, 16-Bit Instruction Word. = 01da. ANDWF, 16-Bit Instruction Word. = ffff. ANDWF, 16-Bit Instruction Word.LSb = ffff. ANDWF, Status.Affected = Z, N. ANDWF, Notes. = 1,2. CLRF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, a. CLRF, Description. = Clear f. CLRF, Cycles. = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word. = 101a. CLRF, 16-Bit Instruction Word. = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status.Affected = Z. CLRF, Notes. = 2. COMF,  = f, d, a. COMF, Description. = Complement f. COMF, Cycles. = . COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction Word. = 11da. COMF, 16-Bit Instruction Word. = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status.Affected = Z, N. COMF, Notes. = 1, 2. CPFSEQ,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, a. CPFSEQ, Description. = Compare f with WREG, Skip = 1 1. CPFSEQ, Cycles. = (2 or 3). CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word. = 001a. CPFSEQ, 16-Bit Instruction Word. = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status.Affected = None. CPFSEQ, Notes. = 4. CPFSGT,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, a. CPFSGT, Description. = Compare f with WREG, Skip > 1. CPFSGT, Cycles. = (2 or 3). CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word. = 010a. CPFSGT, 16-Bit Instruction Word. = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT, Status.Affected = None. CPFSGT, Notes. = 4. CPFSLT,  = f, a. CPFSLT, Description. = Compare f with WREG, Skip < 1. CPFSLT, Cycles. = (2 or 3). CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word. = 000a. CPFSLT, 16-Bit Instruction Word. = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff. CPFSLT, Status.Affected = None. CPFSLT, Notes. = 1, 2. DECF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. DECF, Description. = Decrement f. DECF, Cycles. = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word. = 01da. DECF, 16-Bit Instruction Word. = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status.Affected = C, DC, Z, OV, N. DECF, Notes. = 1, 2, 3, 4. DECFSZ,  = f, d, a. DECFSZ, Description. = Decrement f, Skip if 0. DECFSZ, Cycles. = 1 (2 or 3). DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word. = 11da. DECFSZ, 16-Bit Instruction Word. = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status.Affected = None. DECFSZ, Notes. = 1, 2, 3, 4. DCFSNZ,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. DCFSNZ, Description. = Decrement f, Skip if Not 0. DCFSNZ, Cycles. = 1 (2 or 3). DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word. = 11da. DCFSNZ, 16-Bit Instruction Word. = ffff. DCFSNZ, 16-Bit Instruction Word.LSb = ffff. DCFSNZ, Status.Affected = None. DCFSNZ, Notes. = 1, 2. INCF,  = f, d, a. INCF, Description. = Increment f. INCF, Cycles. = 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF, 16-Bit Instruction Word. = 10da. INCF, 16-Bit Instruction Word. = ffff. INCF, 16-Bit Instruction Word.LSb = ffff. INCF, Status.Affected = C, DC, Z, OV, N. INCF, Notes. = 1, 2, 3, 4. INCFSZ,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. INCFSZ, Description. = Increment f, Skip if 0. INCFSZ, Cycles. = (2 or 3). INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word. = 11da. INCFSZ, 16-Bit Instruction Word. = ffff. INCFSZ, 16-Bit Instruction Word.LSb = ffff. INCFSZ, Status.Affected = None. INCFSZ, Notes. = 4. INFSNZ,  = f, d, a. INFSNZ, Description. = Increment f, Skip if Not 0. INFSNZ, Cycles. = 1 1 (2 or 3). INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ, 16-Bit Instruction Word. = 10da. INFSNZ, 16-Bit Instruction Word. = ffff. INFSNZ, 16-Bit Instruction Word.LSb = ffff. INFSNZ, Status.Affected = None. INFSNZ, Notes. = 1, 2. IORWF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. IORWF, Description. = Inclusive OR WREG with f. IORWF, Cycles. = 1. IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word. = 00da. IORWF, 16-Bit Instruction Word. = ffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status.Affected = Z, N. IORWF, Notes. = 1, 2. MOVF,  = f, d, a. MOVF, Description. = Move f. MOVF, Cycles. = . MOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word. = 00da. MOVF, 16-Bit Instruction Word. = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status.Affected = Z, N. MOVF, Notes. = 1. MOVFF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f s , f d. MOVFF, Description. = Move f s (source) to 1st word 1 2. MOVFF, Cycles. = . MOVFF, 16-Bit Instruction Word.MSb = 1100. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction Word.LSb = ffff. MOVFF, Status.Affected = None. MOVFF, Notes. = . ,  = . , Description. = f d (destination) 2nd word. , Cycles. = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word. = ffff. , 16-Bit Instruction Word. = ffff. , 16-Bit Instruction Word.LSb = ffff. , Status.Affected = None. , Notes. = . MOVWF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, a. MOVWF, Description. = Move WREG to f. MOVWF, Cycles. = 1. MOVWF, 16-Bit Instruction Word.MSb = 0110. MOVWF, 16-Bit Instruction Word. = 111a. MOVWF, 16-Bit Instruction Word. = ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff. MOVWF, Status.Affected = . MOVWF, Notes. = . MULWF,  = f, a. MULWF, Description. = Multiply WREG with f. MULWF, Cycles. = 1. MULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word. = 001a. MULWF, 16-Bit Instruction Word. = ffff. MULWF, 16-Bit Instruction Word.LSb = ffff. MULWF, Status.Affected = None. MULWF, Notes. = . NEGF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, a. NEGF, Description. = Negate f. NEGF, Cycles. = 1. NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word. = 110a. NEGF, 16-Bit Instruction Word. = ffff. NEGF, 16-Bit Instruction Word.LSb = ffff. NEGF, Status.Affected = C, DC, Z, OV, N C, Z, N. NEGF, Notes. = 1, 2. RLCF,  = f, d, a. RLCF, Description. = Rotate Left f through Carry. RLCF, Cycles. = 1. RLCF, 16-Bit Instruction Word.MSb = 0011. RLCF, 16-Bit Instruction Word. = 01da. RLCF, 16-Bit Instruction Word. = ffff. RLCF, 16-Bit Instruction Word.LSb = ffff. RLCF, Status.Affected = . RLCF, Notes. = . RLNCF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. RLNCF, Description. = Rotate Left f (No Carry). RLNCF, Cycles. = 1. RLNCF, 16-Bit Instruction Word.MSb = 0100. RLNCF, 16-Bit Instruction Word. = 01da. RLNCF, 16-Bit Instruction Word. = ffff. RLNCF, 16-Bit Instruction Word.LSb = ffff. RLNCF, Status.Affected = Z, N. RLNCF, Notes. = 1, 2. RRCF,  = f, d, a. RRCF, Description. = Rotate Right f through Carry. RRCF, Cycles. = 1. RRCF, 16-Bit Instruction Word.MSb = 0011. RRCF, 16-Bit Instruction Word. = 00da. RRCF, 16-Bit Instruction Word. = ffff. RRCF, 16-Bit Instruction Word.LSb = ffff. RRCF, Status.Affected = C, Z, N Z, N. RRCF, Notes. = . RRNCF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. RRNCF, Description. = Rotate Right f (No Carry). RRNCF, Cycles. = 1. RRNCF, 16-Bit Instruction Word.MSb = 0100. RRNCF, 16-Bit Instruction Word. = 00da. RRNCF, 16-Bit Instruction Word. = ffff. RRNCF, 16-Bit Instruction Word.LSb = ffff. RRNCF, Status.Affected = . RRNCF, Notes. = . SETF,  = f, a. SETF, Description. = Set f. SETF, Cycles. = 1. SETF, 16-Bit Instruction Word.MSb = 0110. SETF, 16-Bit Instruction Word. = 100a. SETF, 16-Bit Instruction Word. = ffff. SETF, 16-Bit Instruction Word.LSb = ffff. SETF, Status.Affected = None. SETF, Notes. = . SUBFWB,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. SUBFWB, Description. = Subtract f from WREG with borrow. SUBFWB, Cycles. = 1. SUBFWB, 16-Bit Instruction Word.MSb = 0101. SUBFWB, 16-Bit Instruction Word. = 01da. SUBFWB, 16-Bit Instruction Word. = ffff. SUBFWB, 16-Bit Instruction Word.LSb = ffff. SUBFWB, Status.Affected = C, DC, Z, OV, N. SUBFWB, Notes. = 1, 2. SUBWF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. SUBWF, Description. = Subtract WREG from f. SUBWF, Cycles. = 1. SUBWF, 16-Bit Instruction Word.MSb = 0101. SUBWF, 16-Bit Instruction Word. = 11da. SUBWF, 16-Bit Instruction Word. = ffff. SUBWF, 16-Bit Instruction Word.LSb = ffff. SUBWF, Status.Affected = C, DC, Z, OV, N. SUBWF, Notes. = . SUBWFB,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. SUBWFB, Description. = Subtract WREG from f with borrow. SUBWFB, Cycles. = 1. SUBWFB, 16-Bit Instruction Word.MSb = 0101. SUBWFB, 16-Bit Instruction Word. = 10da. SUBWFB, 16-Bit Instruction Word. = ffff. SUBWFB, 16-Bit Instruction Word.LSb = ffff. SUBWFB, Status.Affected = C, DC, Z, OV, N. SUBWFB, Notes. = 1, 2. SWAPF,  = f, d, a. SWAPF, Description. = Swap nibbles in f. SWAPF, Cycles. = 1. SWAPF, 16-Bit Instruction Word.MSb = 0011. SWAPF, 16-Bit Instruction Word. = 10da. SWAPF, 16-Bit Instruction Word. = ffff. SWAPF, 16-Bit Instruction Word.LSb = ffff. SWAPF, Status.Affected = None. SWAPF, Notes. = 4. TSTFSZ,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, a. TSTFSZ, Description. = Test f, Skip if 0. TSTFSZ, Cycles. = 1 (2 or 3). TSTFSZ, 16-Bit Instruction Word.MSb = 0110. TSTFSZ, 16-Bit Instruction Word. = 011a. TSTFSZ, 16-Bit Instruction Word. = ffff. TSTFSZ, 16-Bit Instruction Word.LSb = ffff. TSTFSZ, Status.Affected = None. TSTFSZ, Notes. = 1, 2. XORWF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. XORWF, Description. = Exclusive OR WREG with f. XORWF, Cycles. = 1. XORWF, 16-Bit Instruction Word.MSb = 0001. XORWF, 16-Bit Instruction Word. = 10da. XORWF, 16-Bit Instruction Word. = ffff. XORWF, 16-Bit Instruction Word.LSb = ffff. XORWF, Status.Affected = Z, N. XORWF, Notes. = . BIT-ORIENTED FILE REGISTER OPERATIONS,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Description. = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Cycles. = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.LSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Status.Affected = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Notes. = BIT-ORIENTED FILE REGISTER OPERATIONS. BCF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, b, a. BCF, Description. = Bit Clear f. BCF, Cycles. = 1. BCF, 16-Bit Instruction Word.MSb = 1001. BCF, 16-Bit Instruction Word. = bbba. BCF, 16-Bit Instruction Word. = ffff. BCF, 16-Bit Instruction Word.LSb = ffff. BCF, Status.Affected = None. BCF, Notes. = 1, 2. BSF,  = f, b, a. BSF, Description. = Bit Set f. BSF, Cycles. = 1. BSF, 16-Bit Instruction Word.MSb = 1000. BSF, 16-Bit Instruction Word. = bbba. BSF, 16-Bit Instruction Word. = ffff. BSF, 16-Bit Instruction Word.LSb = ffff. BSF, Status.Affected = None. BSF, Notes. = 1, 2. BTFSC,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, b, a. BTFSC, Description. = Bit Test f, Skip if Clear. BTFSC, Cycles. = 1 (2 or 3). BTFSC, 16-Bit Instruction Word.MSb = 1011. BTFSC, 16-Bit Instruction Word. = bbba. BTFSC, 16-Bit Instruction Word. = ffff. BTFSC, 16-Bit Instruction Word.LSb = ffff. BTFSC, Status.Affected = None. BTFSC, Notes. = 3, 4. BTFSS,  = f, b, a. BTFSS, Description. = Bit Test f, Skip if Set. BTFSS, Cycles. = 1 (2 or 3). BTFSS, 16-Bit Instruction Word.MSb = 1010. BTFSS, 16-Bit Instruction Word. = bbba. BTFSS, 16-Bit Instruction Word. = ffff. BTFSS, 16-Bit Instruction Word.LSb = ffff. BTFSS, Status.Affected = None. BTFSS, Notes. = 3, 4. BTG,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. BTG, Description. = Bit Toggle f. BTG, Cycles. = 1. BTG, 16-Bit Instruction Word.MSb = 0111. BTG, 16-Bit Instruction Word. = bbba. BTG, 16-Bit Instruction Word. = ffff. BTG, 16-Bit Instruction Word.LSb = ffff. BTG, Status.Affected = None. BTG, Notes. = 1, 2",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and, where applicable, d = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are two-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nCONTROL OPERATIONS, Mnemonic,.Operands = CONTROL OPERATIONS. CONTROL OPERATIONS, Description.Description = CONTROL OPERATIONS. CONTROL OPERATIONS, Cycles.Cycles = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, Status Affected.Status Affected = CONTROL OPERATIONS. CONTROL OPERATIONS, Notes.Notes = CONTROL OPERATIONS. BC, Mnemonic,.Operands = n. BC, Description.Description = Branch if Carry. BC, Cycles.Cycles = 1 (2). BC, 16-Bit Instruction Word.MSb = 1110. BC, 16-Bit Instruction Word.MSb = 0010. BC, 16-Bit Instruction Word. = nnnn. BC, 16-Bit Instruction Word.LSb = nnnn. BC, Status Affected.Status Affected = None. BC, Notes.Notes = . BN, Mnemonic,.Operands = n. BN, Description.Description = Branch if",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nNegative. BN, Cycles.Cycles = 1 (2). BN, 16-Bit Instruction Word.MSb = 1110. BN, 16-Bit Instruction Word.MSb = 0110. BN, 16-Bit Instruction Word. = nnnn. BN, 16-Bit Instruction Word.LSb = nnnn. BN, Status Affected.Status Affected = None. BN, Notes.Notes = . BNC, Mnemonic,.Operands = n. BNC, Description.Description = Branch if Not Carry. BNC, Cycles.Cycles = 1 (2). BNC, 16-Bit Instruction Word.MSb = 1110. BNC, 16-Bit Instruction Word.MSb = 0011. BNC, 16-Bit Instruction Word. = nnnn. BNC, 16-Bit Instruction Word.LSb = nnnn. BNC, Status Affected.Status Affected = None. BNC, Notes.Notes = . BNN, Mnemonic,.Operands = n. BNN, Description.Description = Branch if Not Negative. BNN, Cycles.Cycles = 1 (2).",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nBNN, 16-Bit Instruction Word.MSb = 1110. BNN, 16-Bit Instruction Word.MSb = 0111. BNN, 16-Bit Instruction Word. = nnnn. BNN, 16-Bit Instruction Word.LSb = nnnn. BNN, Status Affected.Status Affected = None. BNN, Notes.Notes = . BNOV, Mnemonic,.Operands = n. BNOV, Description.Description = Branch if Not Overflow. BNOV, Cycles.Cycles = 1 (2). BNOV, 16-Bit Instruction Word.MSb = 1110. BNOV, 16-Bit Instruction Word.MSb = 0101. BNOV, 16-Bit Instruction Word. = nnnn. BNOV, 16-Bit Instruction Word.LSb = nnnn. BNOV, Status Affected.Status Affected = None. BNOV, Notes.Notes = . BNZ, Mnemonic,.Operands = n. BNZ, Description.Description = Branch if Not Zero. BNZ, Cycles.Cycles = 1 (2). BNZ, 16-Bit Instruction",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nWord.MSb = 1110. BNZ, 16-Bit Instruction Word.MSb = 0001. BNZ, 16-Bit Instruction Word. = nnnn. BNZ, 16-Bit Instruction Word.LSb = nnnn. BNZ, Status Affected.Status Affected = None. BNZ, Notes.Notes = . BOV, Mnemonic,.Operands = n. BOV, Description.Description = Branch if Overflow. BOV, Cycles.Cycles = 1 (2). BOV, 16-Bit Instruction Word.MSb = 1110. BOV, 16-Bit Instruction Word.MSb = 0100. BOV, 16-Bit Instruction Word. = nnnn. BOV, 16-Bit Instruction Word.LSb = nnnn. BOV, Status Affected.Status Affected = None. BOV, Notes.Notes = . BRA, Mnemonic,.Operands = n. BRA, Description.Description = Branch Unconditionally. BRA, Cycles.Cycles = 2. BRA, 16-Bit Instruction Word.MSb = 1101. BRA, 16-Bit Instruction",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nWord.MSb = 0nnn. BRA, 16-Bit Instruction Word. = nnnn. BRA, 16-Bit Instruction Word.LSb = nnnn. BRA, Status Affected.Status Affected = None. BRA, Notes.Notes = . BZ, Mnemonic,.Operands = n. BZ, Description.Description = Branch if Zero. BZ, Cycles.Cycles = 1 (2). BZ, 16-Bit Instruction Word.MSb = 1110. BZ, 16-Bit Instruction Word.MSb = 0000. BZ, 16-Bit Instruction Word. = nnnn. BZ, 16-Bit Instruction Word.LSb = nnnn. BZ, Status Affected.Status Affected = None. BZ, Notes.Notes = . CALL, Mnemonic,.Operands = n, s. CALL, Description.Description = Call subroutine 1st word. CALL, Cycles.Cycles = 2. CALL, 16-Bit Instruction Word.MSb = 1110. CALL, 16-Bit Instruction Word.MSb = 110s. CALL, 16-Bit Instruction Word. =",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nkkkk. CALL, 16-Bit Instruction Word.LSb = kkkk. CALL, Status Affected.Status Affected = None. CALL, Notes.Notes = . 2nd word, Mnemonic,.Operands = 2nd word. 2nd word, Description.Description = 2nd word. 2nd word, Cycles.Cycles = 2nd word. 2nd word, 16-Bit Instruction Word.MSb = 1111. 2nd word, 16-Bit Instruction Word.MSb = kkkk. 2nd word, 16-Bit Instruction Word. = kkkk. 2nd word, 16-Bit Instruction Word.LSb = kkkk. 2nd word, Status Affected.Status Affected = . 2nd word, Notes.Notes = . CLRWDT, Mnemonic,.Operands = -. CLRWDT, Description.Description = Clear Watchdog Timer. CLRWDT, Cycles.Cycles = 1. CLRWDT, 16-Bit Instruction Word.MSb = 0000. CLRWDT, 16-Bit Instruction Word.MSb = 0000. CLRWDT, 16-Bit Instruction Word. = 0000.",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nCLRWDT, 16-Bit Instruction Word.LSb = 0100. CLRWDT, Status Affected.Status Affected = TO, PD. CLRWDT, Notes.Notes = . DAW, Mnemonic,.Operands = -. DAW, Description.Description = Decimal Adjust WREG. DAW, Cycles.Cycles = 1. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word.LSb = 0111. DAW, Status Affected.Status Affected = C. DAW, Notes.Notes = . GOTO, Mnemonic,.Operands = n. GOTO, Description.Description = Go to address 1st word. GOTO, Cycles.Cycles = 2. GOTO, 16-Bit Instruction Word.MSb = 1110. GOTO, 16-Bit Instruction Word.MSb = 1111. GOTO, 16-Bit Instruction Word. = kkkk. GOTO, 16-Bit Instruction",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nWord.LSb = kkkk. GOTO, Status Affected.Status Affected = None. GOTO, Notes.Notes = . 2nd word, Mnemonic,.Operands = 2nd word. 2nd word, Description.Description = 2nd word. 2nd word, Cycles.Cycles = 2nd word. 2nd word, 16-Bit Instruction Word.MSb = 1111. 2nd word, 16-Bit Instruction Word.MSb = kkkk. 2nd word, 16-Bit Instruction Word. = kkkk. 2nd word, 16-Bit Instruction Word.LSb = kkkk. 2nd word, Status Affected.Status Affected = . 2nd word, Notes.Notes = . NOP, Mnemonic,.Operands = -. NOP, Description.Description = No Operation. NOP, Cycles.Cycles = 1. NOP, 16-Bit Instruction Word.MSb = 0000. NOP, 16-Bit Instruction Word.MSb = 0000. NOP, 16-Bit Instruction Word. = 0000. NOP, 16-Bit Instruction Word.LSb = 0000. NOP, Status Affected.Status Affected =",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nNone. NOP, Notes.Notes = . NOP, Mnemonic,.Operands = -. NOP, Description.Description = No Operation. NOP, Cycles.Cycles = 1. NOP, 16-Bit Instruction Word.MSb = 1111. NOP, 16-Bit Instruction Word.MSb = xxxx. NOP, 16-Bit Instruction Word. = xxxx. NOP, 16-Bit Instruction Word.LSb = xxxx. NOP, Status Affected.Status Affected = None. NOP, Notes.Notes = 4. POP, Mnemonic,.Operands = -. POP, Description.Description = Pop top of return stack (TOS) 1. POP, Cycles.Cycles = . POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word.LSb = 0110. POP, Status Affected.Status Affected = None. POP, Notes.Notes = . PUSH, Mnemonic,.Operands = -. PUSH,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nDescription.Description = Push top of return stack (TOS) 1. PUSH, Cycles.Cycles = . PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word. = 0000. PUSH, 16-Bit Instruction Word.LSb = 0101. PUSH, Status Affected.Status Affected = None. PUSH, Notes.Notes = . RCALL, Mnemonic,.Operands = n. RCALL, Description.Description = Relative Call. RCALL, Cycles.Cycles = 2. RCALL, 16-Bit Instruction Word.MSb = 1101. RCALL, 16-Bit Instruction Word.MSb = 1nnn. RCALL, 16-Bit Instruction Word. = nnnn. RCALL, 16-Bit Instruction Word.LSb = nnnn. RCALL, Status Affected.Status Affected = None. RCALL, Notes.Notes = . RESET Software device Reset 1, Mnemonic,.Operands = RESET Software device Reset 1. RESET Software device Reset 1, Description.Description = RESET Software device Reset 1.",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nRESET Software device Reset 1, Cycles.Cycles = RESET Software device Reset 1. RESET Software device Reset 1, 16-Bit Instruction Word.MSb = 0000. RESET Software device Reset 1, 16-Bit Instruction Word.MSb = 0000. RESET Software device Reset 1, 16-Bit Instruction Word. = 1111. RESET Software device Reset 1, 16-Bit Instruction Word.LSb = 1111. RESET Software device Reset 1, Status Affected.Status Affected = All. RESET Software device Reset 1, Notes.Notes = . RETFIE, Mnemonic,.Operands = s. RETFIE, Description.Description = Return from interrupt enable. RETFIE, Cycles.Cycles = 2. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word. = 0001. RETFIE, 16-Bit Instruction Word.LSb = 000s. RETFIE, Status Affected.Status Affected = GIE/GIEH, PEIE/GIEL. RETFIE, Notes.Notes = .",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nRETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected.Status Affected = None. RETLW, Notes.Notes = . RETURN, Mnemonic,.Operands = s. RETURN, Description.Description = Return from Subroutine. RETURN, Cycles.Cycles = 2. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word. = 0001. RETURN, 16-Bit Instruction Word.LSb = 001s. RETURN, Status Affected.Status Affected = None. RETURN, Notes.Notes = . SLEEP, Mnemonic,.Operands = -. SLEEP,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nDescription.Description = Go into Standby mode. SLEEP, Cycles.Cycles = 1. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word. = 0000. SLEEP, 16-Bit Instruction Word.LSb = 0011. SLEEP, Status Affected.Status Affected = TO, PD. SLEEP, Notes.Notes = ",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and, where applicable, d = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are two-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nLITERAL OPERATIONS, Mnemonic,.Operands = LITERAL OPERATIONS. LITERAL OPERATIONS, Description.Description = LITERAL OPERATIONS. LITERAL OPERATIONS, Cycles.Cycles = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, Status Affected.Status Affected = LITERAL OPERATIONS. LITERAL OPERATIONS,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= LITERAL OPERATIONS. ADDLW, Mnemonic,.Operands = k. ADDLW, Description.Description = Add literal and WREG. ADDLW, Cycles.Cycles = 1 1. ADDLW, 16-Bit Instruction Word.MSb = 0000. ADDLW, 16-Bit Instruction Word.MSb = 1111. ADDLW, 16-Bit Instruction Word. = kkkk. ADDLW, 16-Bit Instruction Word.LSb = kkkk. ADDLW, Status Affected.Status Affected = C, DC, Z, OV, N Z, N. ADDLW,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . ANDLW, Mnemonic,.Operands = k. ANDLW, Description.Description = AND literal with WREG. ANDLW, Cycles.Cycles = . ANDLW, 16-Bit Instruction Word.MSb = 0000. ANDLW, 16-Bit Instruction Word.MSb = 1011. ANDLW, 16-Bit Instruction Word. = kkkk. ANDLW, 16-Bit Instruction Word.LSb = kkkk. ANDLW, Status Affected.Status Affected = . ANDLW,  = . IORLW, Mnemonic,.Operands = k. IORLW, Description.Description = Inclusive OR literal with WREG. IORLW, Cycles.Cycles = 1. IORLW, 16-Bit Instruction Word.MSb = 0000. IORLW, 16-Bit Instruction Word.MSb = 1001. IORLW, 16-Bit Instruction Word. = kkkk. IORLW, 16-Bit Instruction Word.LSb = kkkk. IORLW, Status Affected.Status Affected = Z, N. IORLW,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . LFSR, Mnemonic,.Operands = f, k. LFSR, Description.Description = Move literal (12-bit) 2nd word to FSRx 1st word. LFSR, Cycles.Cycles = 2. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word. = 00ff. LFSR, 16-Bit Instruction Word.LSb = kkkk. LFSR, Status Affected.Status Affected = None. LFSR,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . MOVLB, Mnemonic,.Operands = k. MOVLB, Description.Description = Move literal to BSR<3:0>. MOVLB, Cycles.Cycles = 1. MOVLB, 16-Bit Instruction Word.MSb = 0000. MOVLB, 16-Bit Instruction Word.MSb = 0001. MOVLB, 16-Bit Instruction Word. = 0000. MOVLB, 16-Bit Instruction Word.LSb = kkkk. MOVLB, Status Affected.Status Affected = None. MOVLB,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . MOVLW, Mnemonic,.Operands = k. MOVLW, Description.Description = Move literal to WREG. MOVLW, Cycles.Cycles = 1. MOVLW, 16-Bit Instruction Word.MSb = 0000. MOVLW, 16-Bit Instruction Word.MSb = 1110. MOVLW, 16-Bit Instruction Word. = kkkk. MOVLW, 16-Bit Instruction Word.LSb = kkkk. MOVLW, Status Affected.Status Affected = None. MOVLW,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . MULLW, Mnemonic,.Operands = k. MULLW, Description.Description = Multiply literal with WREG. MULLW, Cycles.Cycles = 1. MULLW, 16-Bit Instruction Word.MSb = 0000. MULLW, 16-Bit Instruction Word.MSb = 1101. MULLW, 16-Bit Instruction Word. = kkkk. MULLW, 16-Bit Instruction Word.LSb = kkkk. MULLW, Status Affected.Status Affected = None. MULLW,  = . RETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected.Status Affected = None. RETLW,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . SUBLW, Mnemonic,.Operands = k. SUBLW, Description.Description = Subtract WREG from literal. SUBLW, Cycles.Cycles = 1. SUBLW, 16-Bit Instruction Word.MSb = 0000. SUBLW, 16-Bit Instruction Word.MSb = 1000. SUBLW, 16-Bit Instruction Word. = kkkk. SUBLW, 16-Bit Instruction Word.LSb = kkkk. SUBLW, Status Affected.Status Affected = C, DC, Z, OV, N. SUBLW,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . XORLW, Mnemonic,.Operands = k. XORLW, Description.Description = Exclusive OR literal with WREG. XORLW, Cycles.Cycles = 1. XORLW, 16-Bit Instruction Word.MSb = 0000. XORLW, 16-Bit Instruction Word.MSb = 1010. XORLW, 16-Bit Instruction Word. = kkkk. XORLW, 16-Bit Instruction Word.LSb = kkkk. XORLW, Status Affected.Status Affected = Z, N. XORLW,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Mnemonic,.Operands = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Description.Description = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Cycles.Cycles = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word. = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.LSb = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS, Status Affected.Status Affected = DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= DATA MEMORY \uf0ab PROGRAM MEMORY OPERATIONS. TBLRD*, Mnemonic,.Operands = TBLRD*. TBLRD*, Description.Description = Table Read. TBLRD*, Cycles.Cycles = 2. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word. = 0000. TBLRD*, 16-Bit Instruction Word.LSb = 1000. TBLRD*, Status Affected.Status Affected = None. TBLRD*,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . TBLRD*+, Mnemonic,.Operands = TBLRD*+. TBLRD*+, Description.Description = Table Read with post-increment. TBLRD*+, Cycles.Cycles = . TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected.Status Affected = None. TBLRD*+,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . TBLRD*-, Mnemonic,.Operands = TBLRD*-. TBLRD*-, Description.Description = Table Read with post-decrement. TBLRD*-, Cycles.Cycles = . TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word.LSb = 1010. TBLRD*-, Status Affected.Status Affected = None. TBLRD*-,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . TBLRD+*, Mnemonic,.Operands = TBLRD+*. TBLRD+*, Description.Description = Table Read with pre-increment. TBLRD+*, Cycles.Cycles = . TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected.Status Affected = None. TBLRD+*,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . TBLWT*, Mnemonic,.Operands = TBLWT*. TBLWT*, Description.Description = Table Write. TBLWT*, Cycles.Cycles = 2 (5). TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word.LSb = 1100. TBLWT*, Status Affected.Status Affected = None. TBLWT*,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . TBLWT*+, Mnemonic,.Operands = TBLWT*+. TBLWT*+, Description.Description = Table Write with post-increment. TBLWT*+, Cycles.Cycles = . TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word.LSb = 1101. TBLWT*+, Status Affected.Status Affected = None. TBLWT*+,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . TBLWT*-, Mnemonic,.Operands = TBLWT*-. TBLWT*-, Description.Description = Table Write with post-decrement. TBLWT*-, Cycles.Cycles = . TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word.LSb = 1110. TBLWT*-, Status Affected.Status Affected = None. TBLWT*-,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\n= . TBLWT+*, Mnemonic,.Operands = TBLWT+*. TBLWT+*, Description.Description = Table Write with pre-increment. TBLWT+*, Cycles.Cycles = . TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word.LSb = 1111. TBLWT+*, Status Affected.Status Affected = None. TBLWT+*,  = ",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET  (CONTINUED)\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and, where applicable, d = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are two-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "25.1 Instruction Set\nSyntax:, ADD literal to W = [ label ] ADDLW. Syntax:, ADD literal to W = [ label ] ADDLW. Syntax:, ADD literal to W = k. Syntax:, ADD literal to W = k. Operands:, ADD literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, ADD literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, ADD literal to W = . Operands:, ADD literal to W = . Operation:, ADD literal to W = (W) + k \uf0ae W. Operation:, ADD literal to W = (W) + k \uf0ae W. Operation:, ADD literal to W = . Operation:, ADD literal to W = . Status Affected:, ADD literal to W = N, OV, C, DC, Z. Status Affected:, ADD literal to W = N, OV, C, DC, Z. Status Affected:, ADD literal to W = . Status Affected:, ADD literal to W = . Encoding:, ADD literal to W = 0000. Encoding:, ADD literal to W = 1111. Encoding:, ADD literal to W = kkkk. Encoding:, ADD literal to W = kkkk.",
    "25.1 Instruction Set\nDescription:, ADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Words:, ADD literal to W = 1. Words:, ADD literal to W = . Words:, ADD literal to W = . Words:, ADD literal to W = . Cycles:, ADD literal to W = 1. Cycles:, ADD literal to W = . Cycles:, ADD literal to W = . Cycles:, ADD literal to W = . Q Cycle Activity:, ADD literal to W = Q Cycle Activity:. Q Cycle Activity:, ADD literal to W = Q Cycle Activity:. Q Cycle Activity:, ADD literal to W = Q Cycle Activity:. Q Cycle Activity:, ADD literal to",
    "25.1 Instruction Set\nW = Q Cycle Activity:. Q1, ADD literal to W = Q2. Q1, ADD literal to W = Q3. Q1, ADD literal to W = Q4. Q1, ADD literal to W = Q4. Decode, ADD literal to W = Read literal 'k'. Decode, ADD literal to W = Process Data. Decode, ADD literal to W = Write to W. Decode, ADD literal to W = Write to W. Example:, ADD literal to W = ADDLW. Example:, ADD literal to W = 0x15. Example:, ADD literal to W = . Example:, ADD literal to W = . Before Instruction, ADD literal to W = Before Instruction. Before Instruction, ADD literal to W = . Before Instruction, ADD literal to W = . Before Instruction, ADD literal to W = . W =, ADD literal to W = 0x10. W =, ADD literal to W = . W =, ADD literal to W = . W =, ADD literal to W = . After Instruction, ADD literal to W = After Instruction. After Instruction, ADD literal to W = . After Instruction, ADD literal to W = . After Instruction,",
    "25.1 Instruction Set\nADD literal to W = . W =, ADD literal to W = 0x25. W =, ADD literal to W = . W =, ADD literal to W = . W =, ADD literal to W = ",
    "25.1 Instruction Set\nSyntax:, ADD Wto f = [ label ] ADDWF. Syntax:, ADD Wto f = [ label ] ADDWF. Syntax:, ADD Wto f = f [,d [,a] f [,d [,a]. Syntax:, ADD Wto f = f [,d [,a] f [,d [,a]. Operands:, ADD Wto f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, ADD Wto f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, ADD Wto f = . Operands:, ADD Wto f = . Operation:, ADD Wto f = (W) + (f) \uf0ae dest. Operation:, ADD Wto f = (W) + (f) \uf0ae dest. Operation:, ADD Wto f = . Operation:, ADD Wto f = . Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:, ADD Wto",
    "25.1 Instruction Set\nf = . Status Affected:, ADD Wto f = . Encoding:, ADD Wto f = 0010. Encoding:, ADD Wto f = 01da. Encoding:, ADD Wto f = ffff. Encoding:, ADD Wto f = ffff. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'd' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'd' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, ADD Wto f = Add Wto register 'f'. If 'd'",
    "25.1 Instruction Set\nis ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'd' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'd' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Words:, ADD Wto f = 1. Words:, ADD Wto f = 1. Words:, ADD Wto f = . Words:, ADD Wto f = . Cycles:, ADD Wto f = 1. Cycles:, ADD Wto f = 1. Cycles:, ADD Wto f = . Cycles:, ADD Wto f = . Q Cycle Activity:, ADD Wto f = Q Cycle Activity:. Q Cycle Activity:, ADD",
    "25.1 Instruction Set\nWto f = Q Cycle Activity:. Q Cycle Activity:, ADD Wto f = Q Cycle Activity:. Q Cycle Activity:, ADD Wto f = Q Cycle Activity:. Q1, ADD Wto f = Q2. Q1, ADD Wto f = Q3. Q1, ADD Wto f = Q3. Q1, ADD Wto f = Q4. Decode, ADD Wto f = Read register 'f'. Decode, ADD Wto f = Process Data. Decode, ADD Wto f = Process Data. Decode, ADD Wto f = Write to destination. Example:, ADD Wto f = ADDWF. Example:, ADD Wto f = REG, 0,. Example:, ADD Wto f = 0. Example:, ADD Wto f = . Before Instruction, ADD Wto f = Before Instruction. Before Instruction, ADD Wto f = . Before Instruction, ADD Wto f = . Before Instruction, ADD Wto f = . W, ADD Wto f = = 0x17. W, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . REG,",
    "25.1 Instruction Set\nADD Wto f = = 0xC2. REG, ADD Wto f = . REG, ADD Wto f = . REG, ADD Wto f = . After Instruction, ADD Wto f = After Instruction. After Instruction, ADD Wto f = . After Instruction, ADD Wto f = . After Instruction, ADD Wto f = . W REG, ADD Wto f = = 0xD9 0xC2. W REG, ADD Wto f = . W REG, ADD Wto f = . W REG, ADD Wto f = ",
    "ADD W and Carry bit to f\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\n[ label ] ADDWFC      f [,d [,a]]\n0 \uf0a3 f \uf0a3 255\nd \uf0ce\uf020 [0,1]\na \uf0ce\uf020 [0,1]\n(W) + (f) + (C) \uf0ae dest\nN,OV, C, DC, Z\n0010\n00da ffff\nffff\nAdd W, the Carry Flag and data memory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden.\n1\n1\nQ2\nRead register 'f'",
    "ADD W and Carry bit to f\nSyntax:, AND literal with W = [ label ] ANDLW. Syntax:, AND literal with W = [ label ] ANDLW. Syntax:, AND literal with W = k. Syntax:, AND literal with W = . Operands:, AND literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, AND literal with W = . Operands:, AND literal with W = . Operation:, AND literal with W = (W) .AND. k \uf0ae W. Operation:, AND literal with W = (W) .AND. k \uf0ae W. Operation:, AND literal with W = . Operation:, AND literal with W = . Status Affected:, AND literal with W = N, Z. Status Affected:, AND literal with W = N, Z. Status Affected:, AND literal with W = . Status Affected:, AND literal with W = . Encoding:, AND literal with W = 0000. Encoding:, AND literal with W = 1011. Encoding:, AND literal with W = kkkk. Encoding:, AND literal with W = kkkk. Description:, AND literal with W = The contents",
    "ADD W and Carry bit to f\nof Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Words:, AND literal with W = 1. Words:, AND literal with W = . Words:, AND literal with W = . Words:, AND literal with W = . Cycles:, AND literal with W = 1. Cycles:, AND literal with W = . Cycles:, AND literal with W = . Cycles:, AND literal with W = . Q Cycle Activity:, AND literal with W = . Q Cycle Activity:, AND literal with W = . Q Cycle Activity:, AND literal with W = . Q Cycle Activity:, AND literal with W = . Q1, AND literal with W = Q2.",
    "ADD W and Carry bit to f\nQ1, AND literal with W = Q3. Q1, AND literal with W = . Q1, AND literal with W = Q4. Decode, AND literal with W = Read literal 'k'. Decode, AND literal with W = Process Data. Decode, AND literal with W = . Decode, AND literal with W = Write to W. Example:, AND literal with W = ANDLW. Example:, AND literal with W = 0x5F. Example:, AND literal with W = . Example:, AND literal with W = . Before Instruction, AND literal with W = Before Instruction. Before Instruction, AND literal with W = . Before Instruction, AND literal with W = . Before Instruction, AND literal with W = . W =, AND literal with W = 0xA3. W =, AND literal with W = . W =, AND literal with W = . W =, AND literal with W = . After Instruction, AND literal with W = After Instruction. After Instruction, AND literal with W = . After Instruction, AND literal with W = . After Instruction, AND literal with W = ",
    "Example:\nADDWFC\nBefore Instruction\nCarry bit\n=\n1\nREG\n=\n0x02\nW\n=\n0x4D\nAfter Instruction\nCarry bit\n=\n0\nREG\n=\n0x02\nW\n=\n0x50\nQ3\nProcess\nData\nREG,\n0, 1\nQ4\nWrite to destination",
    "AND W with f\nSyntax:\n[\nlabel\n]  ANDWF      f [,d [,a]]\nOperands:\n0 \uf0a3 f \uf0a3 255\nd \uf0ce\uf020 [0,1]\na \uf0ce\uf020 [0,1]\nOperation:\n(W) .AND. (f) \uf0ae dest\nStatus Affected:\nN, Z\nEncoding:\n0001\n01da\nffff\nffff\nDescription:\nThe contents of W are AND'ed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite to\ndestination",
    "Example:\nANDWF\nREG,\n0, 0\nBefore Instruction\nW\n=\n0x17\nREG\n=\n0xC2\nAfter Instruction\nW\n=\n0x02\nREG\n=\n0xC2",
    "Example:\nSyntax:, Branch if Carry = [ label ] BC n. Syntax:, Branch if Carry = [ label ] BC n. Syntax:, Branch if Carry = [ label ] BC n. Syntax:, Branch if Carry = [ label ] BC n. Operands:, Branch if Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Carry = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Carry = if carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Carry = if carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Carry = if carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Carry = if carry bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Carry = None. Status Affected:, Branch if Carry = None. Status Affected:, Branch if Carry = None. Status Affected:, Branch if Carry = None. Encoding:, Branch if Carry = 1110. Encoding:, Branch",
    "Example:\nif Carry = 0010. Encoding:, Branch if Carry = nnnn. Encoding:, Branch if Carry = nnnn. Description:, Branch if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction..",
    "Example:\nDescription:, Branch if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Words:, Branch if Carry = 1. Words:, Branch if Carry = 1. Words:, Branch if Carry = 1. Words:, Branch if Carry = 1. Cycles:, Branch if Carry = 1(2). Cycles:, Branch if Carry = 1(2). Cycles:, Branch if Carry = 1(2). Cycles:, Branch if Carry = 1(2). Q Cycle Activity: If Jump:, Branch if Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Carry = Q Cycle Activity: If Jump:. Q1, Branch if Carry = Q2 Q3. Q1,",
    "Example:\nBranch if Carry = Q2 Q3. Q1, Branch if Carry = . Q1, Branch if Carry = Q4. Decode, Branch if Carry = Read literal 'n'. Decode, Branch if Carry = Read literal 'n'. Decode, Branch if Carry = Process Data. Decode, Branch if Carry = Write to PC. No operation, Branch if Carry = No operation. No operation, Branch if Carry = No operation. No operation, Branch if Carry = No operation. No operation, Branch if Carry = No operation. If No Jump:, Branch if Carry = If No Jump:. If No Jump:, Branch if Carry = If No Jump:. If No Jump:, Branch if Carry = If No Jump:. If No Jump:, Branch if Carry = If No Jump:. Q1, Branch if Carry = Q2. Q1, Branch if Carry = Q2. Q1, Branch if Carry = Q3. Q1, Branch if Carry = Q4. Decode, Branch if Carry = Read literal 'n'. Decode, Branch if Carry = Read literal 'n'. Decode, Branch if Carry = Process Data. Decode, Branch if Carry = No",
    "Example:\noperation. Example:, Branch if Carry = HERE BC. Example:, Branch if Carry = HERE BC. Example:, Branch if Carry = 5. Example:, Branch if Carry = . Before Instruction PC, Branch if Carry = = address. Before Instruction PC, Branch if Carry = . Before Instruction PC, Branch if Carry = (HERE). Before Instruction PC, Branch if Carry = . After Instruction, Branch if Carry = After Instruction. After Instruction, Branch if Carry = After Instruction. After Instruction, Branch if Carry = After Instruction. After Instruction, Branch if Carry = After Instruction. If Carry PC If Carry, Branch if Carry = = 1; = address = 0;. If Carry PC If Carry, Branch if Carry = . If Carry PC If Carry, Branch if Carry = (HERE+12). If Carry PC If Carry, Branch if Carry = . PC, Branch if Carry = =. PC, Branch if Carry = address. PC, Branch if Carry = (HERE+2). PC, Branch if Carry = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, Bit Clear f = [ label ] BCF. Syntax:, Bit Clear f = [ label ] BCF. Syntax:, Bit Clear f = f,b[,a]. Syntax:, Bit Clear f = f,b[,a]. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Clear f = . Operands:, Bit Clear f = . Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = 0 \uf0ae f<b>. Operation:, Bit Clear f = . Operation:, Bit Clear f = . Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = . Status Affected:, Bit Clear f = . Encoding:, Bit Clear f = 1001. Encoding:, Bit Clear f = bbba. Encoding:, Bit Clear f = ffff. Encoding:, Bit Clear f = ffff. Description:, Bit Clear f",
    "PIC18F6585/8585/6680/8680\n= Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then",
    "PIC18F6585/8585/6680/8680\nthe bank will be selected as per the BSR value (default).. Words:, Bit Clear f = 1. Words:, Bit Clear f = 1. Words:, Bit Clear f = . Words:, Bit Clear f = . Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = . Cycles:, Bit Clear f = . Cycles:, Bit Clear f = . Q Cycle Activity:, Bit Clear f = Q Cycle Activity:. Q Cycle Activity:, Bit Clear f = . Q Cycle Activity:, Bit Clear f = . Q Cycle Activity:, Bit Clear f = . Q1, Bit Clear f = Q2. Q1, Bit Clear f = Q3. Q1, Bit Clear f = . Q1, Bit Clear f = Q4. Example:, Bit Clear f = BCF. Example:, Bit Clear f = FLAG_REG,. Example:, Bit Clear f = 7,. Example:, Bit Clear f = 0. Before Instruction FLAG_REG = 0xC7 After Instruction, Bit Clear f = Before Instruction FLAG_REG = 0xC7 After Instruction. Before Instruction FLAG_REG =",
    "PIC18F6585/8585/6680/8680\n0xC7 After Instruction, Bit Clear f = . Before Instruction FLAG_REG = 0xC7 After Instruction, Bit Clear f = . Before Instruction FLAG_REG = 0xC7 After Instruction, Bit Clear f = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Negative = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Negative = if negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if negative bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Negative = if negative bit is ' 1 '",
    "PIC18F6585/8585/6680/8680\n(PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Encoding:, Branch if Negative = 1110. Encoding:, Branch if Negative = 0110. Encoding:, Branch if Negative = nnnn. Encoding:, Branch if Negative = nnnn. Encoding:, Branch if Negative = nnnn. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new",
    "PIC18F6585/8585/6680/8680\naddress will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a",
    "PIC18F6585/8585/6680/8680\ntwo-cycle instruction.. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Q Cycle Activity: If Jump:, Branch if Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Negative = Q Cycle Activity: If Jump:. Q1, Branch if Negative = Q2. Q1, Branch if Negative = . Q1, Branch if Negative = Q3. Q1,",
    "PIC18F6585/8585/6680/8680\nBranch if Negative = . Q1, Branch if Negative = Q4. Decode, Branch if Negative = Read literal 'n' Process Data Write. Decode, Branch if Negative = Read literal 'n' Process Data Write. Decode, Branch if Negative = Read literal 'n' Process Data Write. Decode, Branch if Negative = Read literal 'n' Process Data Write. Decode, Branch if Negative = to PC. No operation, Branch if Negative = No operation No operation. No operation, Branch if Negative = No operation No operation. No operation, Branch if Negative = No operation No operation. No operation, Branch if Negative = No operation No operation. No operation, Branch if Negative = No operation. If No Jump: Q1, Branch if Negative = . If No Jump: Q1, Branch if Negative = . If No Jump: Q1, Branch if Negative = . If No Jump: Q1, Branch if Negative = . If No Jump: Q1, Branch if Negative = Q4. Decode, Branch if Negative = Q2 Q3 Read literal 'n' Process Data. Decode, Branch if Negative = Q2 Q3 Read literal",
    "PIC18F6585/8585/6680/8680\n'n' Process Data. Decode, Branch if Negative = Q2 Q3 Read literal 'n' Process Data. Decode, Branch if Negative = Q2 Q3 Read literal 'n' Process Data. Decode, Branch if Negative = No operation. Example: HERE, Branch if Negative = Example: HERE. Example: HERE, Branch if Negative = Example: HERE. Example: HERE, Branch if Negative = Example: HERE. Example: HERE, Branch if Negative = Example: HERE. Example: HERE, Branch if Negative = Example: HERE. Before, Branch if Negative = . Before, Branch if Negative = . Before, Branch if Negative = BN. Before, Branch if Negative = Jump. Before, Branch if Negative = . Instruction PC = address (HERE) After Instruction, Branch if Negative = Instruction PC = address (HERE) After Instruction. Instruction PC = address (HERE) After Instruction, Branch if Negative = Instruction PC = address (HERE) After Instruction. Instruction PC = address (HERE) After Instruction, Branch if Negative = Instruction PC = address (HERE) After Instruction. Instruction PC = address (HERE) After Instruction, Branch if Negative = Instruction PC = address",
    "PIC18F6585/8585/6680/8680\n(HERE) After Instruction. Instruction PC = address (HERE) After Instruction, Branch if Negative = Instruction PC = address (HERE) After Instruction. If Negative PC, Branch if Negative = = 1; =. If Negative PC, Branch if Negative = address (Jump). If Negative PC, Branch if Negative = address (Jump). If Negative PC, Branch if Negative = address (Jump). If Negative PC, Branch if Negative = address (Jump). If Negative PC, Branch if Negative = = 0; = address. If Negative PC, Branch if Negative = (HERE+2). If Negative PC, Branch if Negative = (HERE+2). If Negative PC, Branch if Negative = (HERE+2). If Negative PC, Branch if Negative = (HERE+2)",
    "PIC18F6585/8585/6680/8680\nSyntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Carry = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Carry = if carry bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if carry bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if carry bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Carry = if carry bit is ' 0 ' (PC) + 2 +",
    "PIC18F6585/8585/6680/8680\n2n \uf0ae PC. Operation:, Branch if Not Carry = if carry bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Encoding:, Branch if Not Carry = 1110. Encoding:, Branch if Not Carry = 0011. Encoding:, Branch if Not Carry = nnnn. Encoding:, Branch if Not Carry = nnnn. Encoding:, Branch if Not Carry = nnnn. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The",
    "PIC18F6585/8585/6680/8680\n2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the",
    "PIC18F6585/8585/6680/8680\nPC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity:",
    "PIC18F6585/8585/6680/8680\nIf Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. , Branch if Not Carry = Q1. , Branch if Not Carry = Q2. , Branch if Not Carry = Q3. , Branch if Not Carry = . , Branch if Not Carry = Q4. , Branch if Not Carry = Decode. , Branch if Not Carry = Read literal 'n'. , Branch if Not Carry = Process Data. , Branch if Not Carry = Write to PC. , Branch if Not Carry = Write to PC. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. , Branch if Not Carry = Q1. , Branch if",
    "PIC18F6585/8585/6680/8680\nNot Carry = Q2. , Branch if Not Carry = Q3. , Branch if Not Carry = . , Branch if Not Carry = Q4. , Branch if Not Carry = Decode. , Branch if Not Carry = Read literal 'n'. , Branch if Not Carry = Process Data. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation. Example:, Branch if Not Carry = Example:. Example:, Branch if Not Carry = HERE. Example:, Branch if Not Carry = BNC. Example:, Branch if Not Carry = Jump. Example:, Branch if Not Carry = . Before Instruction, Branch if Not Carry = Before Instruction. Before Instruction, Branch if Not Carry = Before Instruction. Before Instruction, Branch if Not Carry = Before Instruction. Before Instruction, Branch if Not Carry = Before Instruction. Before Instruction, Branch if Not Carry = Before Instruction. , Branch if Not Carry = PC. , Branch if Not Carry = = address. , Branch if Not Carry = (HERE). , Branch if Not Carry = . , Branch if Not Carry = . After Instruction, Branch if Not Carry = After Instruction. After Instruction, Branch if",
    "PIC18F6585/8585/6680/8680\nNot Carry = After Instruction. After Instruction, Branch if Not Carry = After Instruction. After Instruction, Branch if Not Carry = After Instruction. After Instruction, Branch if Not Carry = After Instruction. , Branch if Not Carry = If Carry PC. , Branch if Not Carry = = 0; = address = 1;. , Branch if Not Carry = (Jump). , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = If Carry PC. , Branch if Not Carry = = address. , Branch if Not Carry = (HERE+2). , Branch if Not Carry = . , Branch if Not Carry = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Negative = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Negative = if negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Negative = if negative bit is ' 0 ' (PC) + 2 +",
    "PIC18F6585/8585/6680/8680\n2n \uf0ae PC. Operation:, Branch if Not Negative = if negative bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 0111. Encoding:, Branch if Not Negative = nnnn. Encoding:, Branch if Not Negative = nnnn. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The",
    "PIC18F6585/8585/6680/8680\n2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the",
    "PIC18F6585/8585/6680/8680\nPC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity:",
    "PIC18F6585/8585/6680/8680\nIf Jump:, Branch if Not Negative = Q Cycle Activity: If Jump:. Q1, Branch if Not Negative = Q2. Q1, Branch if Not Negative = Q2. Q1, Branch if Not Negative = Q3. Q1, Branch if Not Negative = Q3. Q1, Branch if Not Negative = Q4. Decode, Branch if Not Negative = Read literal 'n'. Decode, Branch if Not Negative = Read literal 'n'. Decode, Branch if Not Negative = Process Data. Decode, Branch if Not Negative = Process Data. Decode, Branch if Not Negative = Write to PC. No operation, Branch if Not Negative = No operation. No operation, Branch if Not Negative = No operation. No operation, Branch if Not Negative = No operation. No operation, Branch if Not Negative = No operation. No operation, Branch if Not Negative = No operation. If No Jump:, Branch if Not Negative = If No Jump:. If No Jump:, Branch if Not Negative = If No Jump:. If No Jump:, Branch if Not Negative = If No Jump:. If No Jump:, Branch if Not",
    "PIC18F6585/8585/6680/8680\nNegative = If No Jump:. If No Jump:, Branch if Not Negative = If No Jump:. Q1, Branch if Not Negative = Q2. Q1, Branch if Not Negative = Q2. Q1, Branch if Not Negative = Q3. Q1, Branch if Not Negative = Q3. Q1, Branch if Not Negative = Q4. Decode, Branch if Not Negative = Read literal 'n'. Decode, Branch if Not Negative = Read literal 'n'. Decode, Branch if Not Negative = Process Data. Decode, Branch if Not Negative = Process Data. Decode, Branch if Not Negative = No operation. Example: HERE, Branch if Not Negative = Example: HERE. Example: HERE, Branch if Not Negative = . Example: HERE, Branch if Not Negative = BNN. Example: HERE, Branch if Not Negative = Jump. Example: HERE, Branch if Not Negative = . Before Instruction, Branch if Not Negative = Before Instruction. Before Instruction, Branch if Not Negative = . Before Instruction, Branch if Not Negative = . Before Instruction, Branch if Not Negative = . Before Instruction, Branch if Not Negative = . PC",
    "PIC18F6585/8585/6680/8680\nAfter Instruction If Negative, Branch if Not Negative = =. PC After Instruction If Negative, Branch if Not Negative = address. PC After Instruction If Negative, Branch if Not Negative = address. PC After Instruction If Negative, Branch if Not Negative = (HERE). PC After Instruction If Negative, Branch if Not Negative = . PC If Negative PC, Branch if Not Negative = = = = =. PC If Negative PC, Branch if Not Negative = 1; address. PC If Negative PC, Branch if Not Negative = 1; address. PC If Negative PC, Branch if Not Negative = (Jump) (HERE+2). PC If Negative PC, Branch if Not Negative = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, BNOV = Syntax:. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Operands:, BNOV = Operands:. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Overflow = -128 \uf0a3 n \uf0a3 127. Operation:, BNOV = Operation:. Operation:, Branch if Not Overflow = if overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow = if overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch",
    "PIC18F6585/8585/6680/8680\nif Not Overflow = if overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow = if overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Overflow = if overflow bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, BNOV = Status Affected:. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Encoding:, BNOV = Encoding:. Encoding:, Branch if Not Overflow = 1110. Encoding:, Branch if Not Overflow = 1110. Encoding:, Branch if Not Overflow = 0101. Encoding:, Branch if Not Overflow = nnnn. Encoding:, Branch if Not Overflow = nnnn. Description:, BNOV = Description:. Description:, Branch if Not Overflow = If the Overflow bit",
    "PIC18F6585/8585/6680/8680\nis ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program",
    "PIC18F6585/8585/6680/8680\nwill branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Words:, BNOV = Words:. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Cycles:, BNOV = Cycles:. Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not",
    "PIC18F6585/8585/6680/8680\nOverflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Q Cycle Activity: If Jump:, BNOV = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Overflow = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Overflow = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Overflow = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Overflow = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Overflow = Q Cycle Activity: If Jump:. , BNOV = Q1. , Branch if Not Overflow = Q2. , Branch if Not Overflow = . , Branch if Not Overflow = Q3. , Branch if Not Overflow = . , Branch if Not Overflow = Q4. , BNOV = Decode. , Branch if Not Overflow = Read literal 'n'. , Branch if Not",
    "PIC18F6585/8585/6680/8680\nOverflow = . , Branch if Not Overflow = Process Data. , Branch if Not Overflow = . , Branch if Not Overflow = Write to PC. , BNOV = No operation. , Branch if Not Overflow = No operation. , Branch if Not Overflow = . , Branch if Not Overflow = No operation. , Branch if Not Overflow = . , Branch if Not Overflow = No operation. If No Jump:, BNOV = If No Jump:. If No Jump:, Branch if Not Overflow = If No Jump:. If No Jump:, Branch if Not Overflow = If No Jump:. If No Jump:, Branch if Not Overflow = If No Jump:. If No Jump:, Branch if Not Overflow = If No Jump:. If No Jump:, Branch if Not Overflow = If No Jump:. , BNOV = Q1. , Branch if Not Overflow = Q2. , Branch if Not Overflow = Q2. , Branch if Not Overflow = Q3. , Branch if Not Overflow = . , Branch if Not Overflow = Q4. , BNOV = Decode. ,",
    "PIC18F6585/8585/6680/8680\nBranch if Not Overflow = Read literal 'n'. , Branch if Not Overflow = Read literal 'n'. , Branch if Not Overflow = Process Data. , Branch if Not Overflow = . , Branch if Not Overflow = No operation. Example:, BNOV = . Example:, Branch if Not Overflow = . Example:, Branch if Not Overflow = . Example:, Branch if Not Overflow = BNOV. Example:, Branch if Not Overflow = Jump. Example:, Branch if Not Overflow = . , BNOV = Before Instruction. , Branch if Not Overflow = HERE. , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = . , BNOV = . , Branch if Not Overflow = =. , Branch if Not Overflow = address. , Branch if Not Overflow = . , Branch if Not Overflow = (HERE). , Branch if Not Overflow = . After Instruction, BNOV = . After Instruction, Branch if Not Overflow = . After Instruction, Branch if Not Overflow = . After Instruction, Branch",
    "PIC18F6585/8585/6680/8680\nif Not Overflow = . After Instruction, Branch if Not Overflow = . After Instruction, Branch if Not Overflow = . PC, BNOV = . PC, Branch if Not Overflow = =. PC, Branch if Not Overflow = 1;. PC, Branch if Not Overflow = . PC, Branch if Not Overflow = . PC, Branch if Not Overflow = . PC, BNOV = . PC, Branch if Not Overflow = =. PC, Branch if Not Overflow = . PC, Branch if Not Overflow = . PC, Branch if Not Overflow = . PC, Branch if Not Overflow = . , BNOV = . , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = (HERE+2). , Branch if Not Overflow = . If, BNOV = . If, Branch if Not Overflow = . If, Branch if Not Overflow = . If, Branch if Not Overflow = . If, Branch if Not Overflow = . If, Branch if Not Overflow = . If, BNOV = Overflow.",
    "PIC18F6585/8585/6680/8680\nIf, Branch if Not Overflow = . If, Branch if Not Overflow = address. If, Branch if Not Overflow = . If, Branch if Not Overflow = . If, Branch if Not Overflow = . , BNOV = . , Branch if Not Overflow = =. , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = . , BNOV = Overflow. , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = . , BNOV = . , Branch if Not Overflow = =. , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = . , BNOV = . , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = (Jump). , Branch if Not Overflow = . , BNOV = . , Branch if Not",
    "PIC18F6585/8585/6680/8680\nOverflow = . , Branch if Not Overflow = 0;. , Branch if Not Overflow = 0;. , Branch if Not Overflow = 0;. , Branch if Not Overflow = address",
    "PIC18F6585/8585/6680/8680\nSyntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Syntax:, Branch if Not Zero = [ label ] BNZ n. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operands:, Branch if Not Zero = -128 \uf0a3 n \uf0a3 127. Operation:, Branch if Not Zero = if zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Operation:, Branch if Not Zero = if zero bit is ' 0 ' (PC) + 2 +",
    "PIC18F6585/8585/6680/8680\n2n \uf0ae PC. Operation:, Branch if Not Zero = if zero bit is ' 0 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Encoding:, Branch if Not Zero = 1110. Encoding:, Branch if Not Zero = 0001. Encoding:, Branch if Not Zero = nnnn. Encoding:, Branch if Not Zero = nnnn. Encoding:, Branch if Not Zero = nnnn. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The",
    "PIC18F6585/8585/6680/8680\n2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the",
    "PIC18F6585/8585/6680/8680\nPC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = 1. Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = 1(2). Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. Q Cycle Activity:",
    "PIC18F6585/8585/6680/8680\nIf Jump:, Branch if Not Zero = Q Cycle Activity: If Jump:. , Branch if Not Zero = Q1. , Branch if Not Zero = Q2. , Branch if Not Zero = Q3. , Branch if Not Zero = . , Branch if Not Zero = Q4. , Branch if Not Zero = Decode. , Branch if Not Zero = Read literal 'n'. , Branch if Not Zero = Process Data. , Branch if Not Zero = Write to PC. , Branch if Not Zero = Write to PC. , Branch if Not Zero = No operation. , Branch if Not Zero = No operation. , Branch if Not Zero = No operation. , Branch if Not Zero = No operation. , Branch if Not Zero = No operation. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. If No Jump:, Branch if Not Zero = If No Jump:. , Branch if Not Zero = Q1. , Branch if",
    "PIC18F6585/8585/6680/8680\nNot Zero = Q2. , Branch if Not Zero = Q3. , Branch if Not Zero = Q4. , Branch if Not Zero = Q4. , Branch if Not Zero = Decode. , Branch if Not Zero = Read literal 'n'. , Branch if Not Zero = Process Data. , Branch if Not Zero = No operation. , Branch if Not Zero = No operation. Example:, Branch if Not Zero = Example:. Example:, Branch if Not Zero = HERE. Example:, Branch if Not Zero = BNZ Jump. Example:, Branch if Not Zero = . Example:, Branch if Not Zero = . Before Instruction PC =, Branch if Not Zero = . Before Instruction PC =, Branch if Not Zero = address. Before Instruction PC =, Branch if Not Zero = (HERE). Before Instruction PC =, Branch if Not Zero = . Before Instruction PC =, Branch if Not Zero = . After Instruction, Branch if Not Zero = After Instruction. After Instruction, Branch if Not Zero = After Instruction. After Instruction, Branch if Not Zero = After Instruction. After Instruction, Branch if Not Zero = After Instruction. After Instruction, Branch if Not Zero",
    "PIC18F6585/8585/6680/8680\n= After Instruction. , Branch if Not Zero = If Zero = PC =. , Branch if Not Zero = 0; address 1;. , Branch if Not Zero = (Jump). , Branch if Not Zero = . , Branch if Not Zero = . , Branch if Not Zero = If Zero = PC =. , Branch if Not Zero = address. , Branch if Not Zero = (HERE+2). , Branch if Not Zero = . , Branch if Not Zero = ",
    "Unconditional Branch\nSyntax:\n[\nlabel\n]  BRA    n\nOperands:\n-1024 \uf0a3 n \uf0a3 1023\nOperation:\n(PC) + 2 + 2n \uf0ae PC\nStatus Affected:\nNone\nEncoding:\n1101\n0nnn\nnnnn\nnnnn\nDescription:\nAdd the 2's complement number '2n' to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is a two-cycle instruction.\nWords:\n1\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal\n'n'\nProcess Data\nWrite to PC\nNo\noperation\nNo\noperation\nNo\noperation\nNo\noperation\nExample:, 1 = HERE. Example:, 2 = BRA Jump. Before Instruction, 1 = Before Instruction. Before Instruction, 2 = Before Instruction. PC, 1 = = address. PC, 2 = (HERE). After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. PC, 1 = = address. PC, 2 = (Jump)",
    "Unconditional Branch\nSyntax:, Bit Set f = [ label ] BSF. Syntax:, Bit Set f = [ label ] BSF. Syntax:, Bit Set f = f,b[,a]. Syntax:, Bit Set f = f,b[,a]. Syntax:, Bit Set f = f,b[,a]. Operands:, Bit Set f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Set f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b \uf0a3 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Set f = . Operands:, Bit Set f = . Operands:, Bit Set f = . Operation:, Bit Set f = 1 \uf0ae f<b>. Operation:, Bit Set f = 1 \uf0ae f<b>. Operation:, Bit Set f = . Operation:, Bit Set f = . Operation:, Bit Set f = . Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = . Status Affected:, Bit Set f = . Status Affected:, Bit Set f = . Encoding:, Bit Set f = 1000. Encoding:, Bit Set f",
    "Unconditional Branch\n= bbba. Encoding:, Bit Set f = . Encoding:, Bit Set f = ffff. Encoding:, Bit Set f = ffff. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', Access Bank will",
    "Unconditional Branch\nbe selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Bit Set f = 1. Words:, Bit Set f = 1. Words:, Bit Set f = . Words:, Bit Set f = . Words:, Bit Set f = . Cycles:, Bit Set f = 1. Cycles:, Bit Set f = 1. Cycles:, Bit Set f = . Cycles:, Bit Set f = . Cycles:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q1, Bit Set f = Q2. Q1, Bit Set f = Q2. Q1,",
    "Unconditional Branch\nBit Set f = Q3. Q1, Bit Set f = Q3. Q1, Bit Set f = Q4. Decode, Bit Set f = Read register 'f'. Decode, Bit Set f = Read register 'f'. Decode, Bit Set f = Process Data. Decode, Bit Set f = Process Data. Decode, Bit Set f = Write register 'f'. Example:, Bit Set f = BSF. Example:, Bit Set f = FLAG_REG,. Example:, Bit Set f = FLAG_REG,. Example:, Bit Set f = 7, 1. Example:, Bit Set f = 7, 1. Before Instruction FLAG_REG =, Bit Set f = Before Instruction FLAG_REG =. Before Instruction FLAG_REG =, Bit Set f = 0x0A. Before Instruction FLAG_REG =, Bit Set f = 0x0A. Before Instruction FLAG_REG =, Bit Set f = 0x0A. Before Instruction FLAG_REG =, Bit Set f = 0x0A",
    "Bit Test File, Skip if Clear\nSyntax:\n[ label ]  BTFSC   f,b[,a]\nOperands:\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b \uf0a3 7\na \uf0ce\uf020 [0,1]\nOperation:\nskip if (f<b>) = 0\nStatus Affected:\nNone\nEncoding:\n1011\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nDecode\nQ2\nRead register 'f'\nQ3\nProcess\nData\nQ4\nNo operation",
    "If skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nExample:\nHERE\nFALSE\nTRUE\nBTFSC FLAG, 1, 0\n:\n:\nBefore Instruction\nPC\n=\naddress (HERE)\nAfter Instruction\nIf FLAG<1>\n=\n0;\nPC\n=\naddress\n(TRUE)\nIf FLAG<1>\n=\n1;\nPC\n=\naddress (FALSE)",
    "BTFSS\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "Bit Test File, Skip if Set\n[ label ]  BTFSS  f,b[,a]\n0 \uf0a3 f \uf0a3 255\n0 \uf0a3 b < 7\na \uf0ce\uf020 [0,1]\nskip if (f<b>) = 1\nNone\n1010\nbbba ffff\nffff\nIf bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\n1\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. If skip:, Q2 = . If skip:, Q3 = . If skip:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation,",
    "Q Cycle Activity:\nQ4 = No operation\nBefore Instruction PC, HERE = =. Before Instruction PC, BTFSS = address. Before Instruction PC, FLAG, 1, 0 = (HERE). After Instruction If FLAG<1> PC If FLAG<1> PC, HERE = = = = =. After Instruction If FLAG<1> PC If FLAG<1> PC, BTFSS = 0; address 1; address (TRUE). After Instruction If FLAG<1> PC If FLAG<1> PC, FLAG, 1, 0 = (FALSE)",
    "PIC18F6585/8585/6680/8680\nSyntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operands:, Bit Toggle f = 0 \uf0a3 f \uf0a3 255 0 \uf0a3 b < 7 a \uf0ce\uf020 [0,1]. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f = (f<b>) \uf0ae f<b>. Operation:, Bit Toggle f =",
    "PIC18F6585/8585/6680/8680\n(f<b>) \uf0ae f<b>. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Encoding:, Bit Toggle f = 0111. Encoding:, Bit Toggle f = bbba. Encoding:, Bit Toggle f = ffff. Encoding:, Bit Toggle f = ffff. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit",
    "PIC18F6585/8585/6680/8680\nToggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Q Cycle Activity:, Bit Toggle f = Q Cycle Activity:. Q Cycle Activity:, Bit Toggle f = Q Cycle",
    "PIC18F6585/8585/6680/8680\nActivity:. Q Cycle Activity:, Bit Toggle f = Q Cycle Activity:. Q Cycle Activity:, Bit Toggle f = Q Cycle Activity:. Q1, Bit Toggle f = Q2. Q1, Bit Toggle f = Q3. Q1, Bit Toggle f = Q4. Q1, Bit Toggle f = Q4. Decode, Bit Toggle f = Read register 'f'. Decode, Bit Toggle f = Process Data. Decode, Bit Toggle f = Write register 'f'. Decode, Bit Toggle f = Write register 'f'. Example:, Bit Toggle f = BTG. Example:, Bit Toggle f = PORTC, 4,. Example:, Bit Toggle f = 0. Example:, Bit Toggle f = . Before Instruction: PORTC = After, Bit Toggle f = 0111 Instruction:. Before Instruction: PORTC = After, Bit Toggle f = 0101 [0x75] [0x65]. Before Instruction: PORTC = After, Bit Toggle f = . Before Instruction: PORTC = After, Bit",
    "PIC18F6585/8585/6680/8680\nToggle f = ",
    "Branch if Overflow\nSyntax:, 1 = [ label ] BOV n. Syntax:, 2 = [ label ] BOV n. Syntax:, 3 = [ label ] BOV n. Syntax:, 4 = [ label ] BOV n. Syntax:, 5 = [ label ] BOV n. Operands:, 1 = -128 \uf0a3 n \uf0a3 127. Operands:, 2 = -128 \uf0a3 n \uf0a3 127. Operands:, 3 = -128 \uf0a3 n \uf0a3 127. Operands:, 4 = -128 \uf0a3 n \uf0a3 127. Operands:, 5 = -128 \uf0a3 n \uf0a3 127. Operation:, 1 = if overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 2 = if overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 3 = if overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 4 = if overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Operation:, 5 = if overflow bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 =",
    "Branch if Overflow\nNone. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = 1110. Encoding:, 2 = 0100. Encoding:, 3 = nnnn. Encoding:, 4 = nnnn. Encoding:, 5 = . Description:, 1 = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, 2 = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, 3 = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to",
    "Branch if Overflow\nfetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, 4 = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Description:, 5 = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is then a two-cycle instruction.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = 1(2). Cycles:, 2 = 1(2). Cycles:, 3 = 1(2). Cycles:, 4 = 1(2).",
    "Branch if Overflow\nCycles:, 5 = 1(2). Q Cycle Activity: If Jump:, 1 = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, 2 = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, 3 = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, 4 = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, 5 = Q Cycle Activity: If Jump:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q3. Q1, 4 = Q4. Q1, 5 = . Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Process Data. Decode, 4 = Write to PC. Decode, 5 = . No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 4 = No operation. No operation, 5 = . If No Jump:, 1 = If No Jump:. If No Jump:, 2 = If No Jump:. If No Jump:, 3 = If No",
    "Branch if Overflow\nJump:. If No Jump:, 4 = If No Jump:. If No Jump:, 5 = If No Jump:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q3. Q1, 4 = Q4. Q1, 5 = . Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Process Data. Decode, 4 = No operation. Decode, 5 = . Example:, 1 = HERE. Example:, 2 = BOV. Example:, 3 = Jump. Example:, 4 = . Example:, 5 = . Before Instruction, 1 = Before Instruction. Before Instruction, 2 = . Before Instruction, 3 = . Before Instruction, 4 = . Before Instruction, 5 = . PC, 1 = =. PC, 2 = address. PC, 3 = (HERE). PC, 4 = . PC, 5 = . After Instruction, 1 = After Instruction. After Instruction, 2 = . After Instruction, 3 = . After Instruction, 4 = . After Instruction, 5 = . If Overflow PC, 1 = = =. If Overflow PC, 2 =",
    "Branch if Overflow\n1; address 0;. If Overflow PC, 3 = (Jump). If Overflow PC, 4 = . If Overflow PC, 5 = . If Overflow PC, 1 = = =. If Overflow PC, 2 = address. If Overflow PC, 3 = (HERE+2). If Overflow PC, 4 = . If Overflow PC, 5 = ",
    "PIC18F6585/8585/6680/8680\nBZ",
    "Branch if Zero\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nQ Cycle Activity:\nIf Jump:\nQ1\nDecode\nNo operation\nIf No Jump:\nQ1\nDecode\n[\nlabel\n]  BZ    n\n-128 \uf0a3 n \uf0a3 127\nif Zero bit is ' 1 ' (PC) + 2 + 2n \uf0ae PC\nNone\n1110\n0000\nnnnn nnnn\nIf the Zero bit is ' 1 ', then the program will branch.\nThe 2's complement number '2n' is added to the PC.  Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n.  This instruction is then a two-cycle instruction.\n1\n1(2)\nQ2\nRead literal\n'n'\nNo operation\nQ2\nRead literal\n'n'\nQ3\nProcess\nData\nNo operation\nQ3\nProcess\nData",
    "Example:\nHERE\nBZ\nJump\nBefore Instruction\nPC\n=\naddress\n(HERE)\nAfter Instruction\nIf Zero\n=\n1;\nPC\n=\naddress\n(Jump)\nIf Zero\n=\n0;\nPC\n=\naddress\n(HERE+2)",
    "Example:\nCALL, 1 = CALL. CALL, 2 = Subroutine Call. CALL, 3 = Subroutine Call. CALL, 4 = Subroutine Call. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] CALL k [,s]. Syntax:, 3 = [ label ] CALL k [,s]. Syntax:, 4 = [ label ] CALL k [,s]. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, 3 = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operands:, 4 = 0 \uf0a3 k \uf0a3 1048575 s \uf0ce\uf020 [0,1]. Operation:, 1 = Operation:. Operation:, 2 = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (W) \uf0ae WS, (STATUS) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, 3 = (PC) + 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (W) \uf0ae WS, (STATUS) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Operation:, 4 = (PC)",
    "Example:\n+ 4 \uf0ae TOS, k \uf0ae PC<20:1>, if s = 1 (W) \uf0ae WS, (STATUS) \uf0ae STATUSS, (BSR) \uf0ae BSRS. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding: 1st word (k<7:0>), 1 = Encoding: 1st word (k<7:0>). Encoding: 1st word (k<7:0>), 2 = 1110. Encoding: 1st word (k<7:0>), 3 = 110s k 19 kkk. Encoding: 1st word (k<7:0>), 4 = k 7 kkk kkkk. Description:, 1 = Description:. Description:, 2 = Subroutine call of entire 2-Mbyte memory range. First, return address (PC+ 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the",
    "Example:\n20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Description:, 3 = Subroutine call of entire 2-Mbyte memory range. First, return address (PC+ 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Description:, 4 = Subroutine call of entire 2-Mbyte memory range. First, return address (PC+ 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Words:, 1 = Words:.",
    "Example:\nWords:, 2 = 2. Words:, 3 = 2. Words:, 4 = 2. Cycles:, 1 = Cycles:. Cycles:, 2 = 2. Cycles:, 3 = 2. Cycles:, 4 = 2. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read literal 'k'<7:0>,. , 3 = Push PC to stack. , 4 = Push PC to stack. , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = No operation",
    "Example:\nAfter Instruction, HERE.Before Instruction.= = . After Instruction, CALL THERE,1..address (HERE) = . PC, HERE.Before Instruction.= = =. PC, CALL THERE,1..address (HERE) = address (THERE). TOS, HERE.Before Instruction.= = =. TOS, CALL THERE,1..address (HERE) = address (HERE + 4). WS, HERE.Before Instruction.= = =. WS, CALL THERE,1..address (HERE) = W. BSRS, HERE.Before Instruction.= = =. BSRS, CALL THERE,1..address (HERE) = BSR. STATUSS, HERE.Before Instruction.= = =. STATUSS, CALL THERE,1..address (HERE) = STATUS\nQ4\nWrite to PC\nNo operation\nQ4\nNo operation",
    "PIC18F6585/8585/6680/8680\nSyntax:, Clear f = [ label ] CLRF. Syntax:, Clear f = [ label ] CLRF. Syntax:, Clear f = f [,a]. Syntax:, Clear f = f [,a]. Syntax:, Clear f = f [,a]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Clear f = . Operands:, Clear f = . Operands:, Clear f = . Operation:, Clear f = 000h \uf0ae f 1 \uf0ae Z. Operation:, Clear f = 000h \uf0ae f 1 \uf0ae Z. Operation:, Clear f = . Operation:, Clear f = . Operation:, Clear f = . Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = . Status Affected:, Clear f = . Status Affected:, Clear f = . Encoding:, Clear f = 0110. Encoding:, Clear f = 101a. Encoding:, Clear f = ffff. Encoding:, Clear f = ffff.",
    "PIC18F6585/8585/6680/8680\nEncoding:, Clear f = . Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per",
    "PIC18F6585/8585/6680/8680\nthe BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = . Words:, Clear f = . Words:, Clear f = . Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = . Cycles:, Clear f = . Cycles:, Clear f = . Q Cycle Activity:, Clear f = Q Cycle Activity:. Q Cycle Activity:, Clear f = Q Cycle Activity:. Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q1, Clear f = Q2. Q1, Clear f = Q2. Q1, Clear f = Q3. Q1, Clear f = Q4. Q1, Clear f = .",
    "PIC18F6585/8585/6680/8680\nExample:, Clear f = CLRF. Example:, Clear f = . Example:, Clear f = FLAG_REG,1. Example:, Clear f = FLAG_REG,1. Example:, Clear f = FLAG_REG,1. Before Instruction FLAG_REG =, Clear f = Before Instruction FLAG_REG =. Before Instruction FLAG_REG =, Clear f = 0x5A. Before Instruction FLAG_REG =, Clear f = 0x5A. Before Instruction FLAG_REG =, Clear f = 0x5A. Before Instruction FLAG_REG =, Clear f = 0x5A",
    "PIC18F6585/8585/6680/8680\nSyntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Operation:, Clear Watchdog Timer = 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Operation:, Clear Watchdog Timer",
    "PIC18F6585/8585/6680/8680\n= 000h \uf0ae WDT, 000h \uf0ae WDT postscaler, 1 \uf0ae TO,. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0100. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer.",
    "PIC18F6585/8585/6680/8680\nIt also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear",
    "PIC18F6585/8585/6680/8680\nWatchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q Cycle Activity:, Clear Watchdog Timer = Q Cycle Activity:. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = Q4. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = No operation. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Before Instruction WDT Counter, Clear Watchdog Timer = Before Instruction WDT Counter. Before Instruction WDT Counter, Clear Watchdog Timer =",
    "PIC18F6585/8585/6680/8680\n=. Before Instruction WDT Counter, Clear Watchdog Timer = . Before Instruction WDT Counter, Clear Watchdog Timer = . Before Instruction WDT Counter, Clear Watchdog Timer = . After Instruction WDT, Clear Watchdog Timer = After Instruction WDT. After Instruction WDT, Clear Watchdog Timer = =. After Instruction WDT, Clear Watchdog Timer = 0x00. After Instruction WDT, Clear Watchdog Timer = 0x00. After Instruction WDT, Clear Watchdog Timer = 0x00. WDT Postscaler TO, Clear Watchdog Timer = WDT Postscaler TO. WDT Postscaler TO, Clear Watchdog Timer = = =. WDT Postscaler TO, Clear Watchdog Timer = 0 1. WDT Postscaler TO, Clear Watchdog Timer = 0 1. WDT Postscaler TO, Clear Watchdog Timer = 0 1. PD, Clear Watchdog Timer = PD. PD, Clear Watchdog Timer = =. PD, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = 1. PD, Clear Watchdog Timer = 1",
    "PIC18F6585/8585/6680/8680\nSyntax:, Complement f = [ label ] COMF. Syntax:,  = . Syntax:,  = f [,d [,a]]. Syntax:,  = . Operands:, Complement f = d \uf0ce [0,1] a \uf0ce [0,1]. Operands:,  = . Operands:,  = 0 \uf0a3 f \uf0a3 255. Operands:,  = . Operation:, Complement f = \uf0ae dest (f). Operation:,  = . Operation:,  = . Operation:,  = . Status Affected:, Complement f = N, Z. Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Encoding:, Complement f = 0001. Encoding:,  = 11da. Encoding:,  = ffff. Encoding:,",
    "PIC18F6585/8585/6680/8680\n= ffff. Description:, Complement f = The contents of register 'f' are com- plemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:,  = . Description:,  = . Description:,  = . Words:, Complement f = . Words:,  = 1. Words:,  = . Words:,  = . Cycles:, Complement f = 1. Cycles:,  = . Cycles:,  = . Cycles:,  = . Q Cycle Activity:, Complement f = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q1, Complement f = . Q1,  = Q2. Q1,  = Q3. Q1,  = Q4. , Complement f = Decode. ,",
    "PIC18F6585/8585/6680/8680\n= Read register 'f'. ,  = Process Data. ,  = Write to destination. Example:, Complement f = COMF. Example:,  = REG,. Example:,  = 0, 0. Example:,  = . Before Instruction, Complement f = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . , Complement f = REG. ,  = . ,  = 0x13. ,  = . , Complement f = . ,  = . ,  = . ,  = 0xEC. =, Complement f = . =,  = . =,  = . =,  = . W, Complement f = . W,  = . W,  = . W,  = . =, Complement f = . =,  = . =,  = . =,  = . Instruction, Complement f = . Instruction,  = . Instruction,  = . Instruction,  = . =, Complement f = . =,  = . =,  = . =,  = 0x13. , Complement f = REG. ,  = . ,  = . ,  = . After, Complement f = . After,  = . After,  = . After,  = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, Compare f with W, skip if f = W = [ label ] CPFSEQ f [,a]. Syntax:, Compare f with W, skip if f = W = [ label ] CPFSEQ f [,a]. Syntax:, Compare f with W, skip if f = W = [ label ] CPFSEQ f [,a]. Syntax:, Compare f with W, skip if f = W = [ label ] CPFSEQ f [,a]. Syntax:, Compare f with W, skip if f = W = [ label ] CPFSEQ f [,a]. Operands:, Compare f with W, skip if f = W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f = W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f = W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f = W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with",
    "PIC18F6585/8585/6680/8680\nW, skip if f = W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Compare f with W, skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation:, Compare f with W, skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation:, Compare f with W, skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation:, Compare f with W, skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation:, Compare f with W, skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Status Affected:, Compare f with W, skip if f = W = None. Status Affected:, Compare f with W, skip if f = W = None. Status Affected:, Compare f with W, skip",
    "PIC18F6585/8585/6680/8680\nif f = W = None. Status Affected:, Compare f with W, skip if f = W = None. Status Affected:, Compare f with W, skip if f = W = None. Encoding:, Compare f with W, skip if f = W = 0110. Encoding:, Compare f with W, skip if f = W = 0110. Encoding:, Compare f with W, skip if f = W = 001a. Encoding:, Compare f with W, skip if f = W = ffff. Encoding:, Compare f with W, skip if f = W = ffff. Description:, Compare f with W, skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 ,. Description:, Compare f with W, skip if f = W = Compares the contents of",
    "PIC18F6585/8585/6680/8680\ndata memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 ,. Description:, Compare f with W, skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 ,. Description:, Compare f with W, skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a",
    "PIC18F6585/8585/6680/8680\ntwo-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 ,. Description:, Compare f with W, skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 ,. Words:, Compare f with W, skip if f = W = 1. Words:, Compare f with W, skip if f = W = 1. Words:, Compare f with W, skip if f = W = 1. Words:, Compare f with W, skip if f = W = 1. Words:, Compare f with W, skip if f = W = 1. Cycles:, Compare f with W, skip if f = W = 1(2) Note: 3 cycles if skip and followed.",
    "PIC18F6585/8585/6680/8680\nCycles:, Compare f with W, skip if f = W = 1(2) Note: 3 cycles if skip and followed. Cycles:, Compare f with W, skip if f = W = 1(2) Note: 3 cycles if skip and followed. Cycles:, Compare f with W, skip if f = W = 1(2) Note: 3 cycles if skip and followed. Cycles:, Compare f with W, skip if f = W = 1(2) Note: 3 cycles if skip and followed. Q Cycle Activity: Q3, Compare f with W, skip if f = W = Q Cycle Activity: Q3. Q Cycle Activity: Q3, Compare f with W, skip if f = W = Q Cycle Activity: Q3. Q Cycle Activity: Q3, Compare f with W, skip if f = W = Q Cycle Activity: Q3. Q Cycle Activity: Q3, Compare f with W, skip if f = W = Q Cycle Activity: Q3. Q Cycle Activity: Q3, Compare f with W, skip if f = W = Q Cycle Activity: Q3. Q1, Compare f with W, skip",
    "PIC18F6585/8585/6680/8680\nif f = W = Q2. Q1, Compare f with W, skip if f = W = Q2. Q1, Compare f with W, skip if f = W = . Q1, Compare f with W, skip if f = W = . Q1, Compare f with W, skip if f = W = Q4. Decode, Compare f with W, skip if f = W = Read register 'f'. Decode, Compare f with W, skip if f = W = Read register 'f'. Decode, Compare f with W, skip if f = W = Process Data. Decode, Compare f with W, skip if f = W = Process Data. Decode, Compare f with W, skip if f = W = No operation. If skip:, Compare f with W, skip if f = W = If skip:. If skip:, Compare f with W, skip if f = W = If skip:. If skip:, Compare f with W, skip if f = W = If skip:. If skip:, Compare f with W, skip if f = W = If skip:. If",
    "PIC18F6585/8585/6680/8680\nskip:, Compare f with W, skip if f = W = If skip:. Q1, Compare f with W, skip if f = W = Q2. Q1, Compare f with W, skip if f = W = Q2. Q1, Compare f with W, skip if f = W = Q3. Q1, Compare f with W, skip if f = W = Q3. Q1, Compare f with W, skip if f = W = Q4. No operation, Compare f with W, skip if f = W = No operation. No operation, Compare f with W, skip if f = W = No operation. No operation, Compare f with W, skip if f = W = No operation. No operation, Compare f with W, skip if f = W = No operation. No operation, Compare f with W, skip if f = W = No operation. If skip and followed by 2-word instruction:, Compare f with W, skip if f = W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, skip if f = W",
    "PIC18F6585/8585/6680/8680\n= If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, skip if f = W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, skip if f = W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, skip if f = W = If skip and followed by 2-word instruction:. Q1, Compare f with W, skip if f = W = Q2. Q1, Compare f with W, skip if f = W = Q2. Q1, Compare f with W, skip if f = W = Q3. Q1, Compare f with W, skip if f = W = Q3. Q1, Compare f with W, skip if f = W = Q4. No, Compare f with W, skip if f = W = No. No, Compare f with W, skip if f = W = No. No, Compare f with W, skip if f = W = No.",
    "PIC18F6585/8585/6680/8680\nNo, Compare f with W, skip if f = W = No. No, Compare f with W, skip if f = W = No operation. operation No operation, Compare f with W, skip if f = W = operation No. operation No operation, Compare f with W, skip if f = W = operation No. operation No operation, Compare f with W, skip if f = W = operation No. operation No operation, Compare f with W, skip if f = W = operation No. operation No operation, Compare f with W, skip if f = W = No. , Compare f with W, skip if f = W = operation. , Compare f with W, skip if f = W = . , Compare f with W, skip if f = W = operation. , Compare f with W, skip if f = W = operation. , Compare f with W, skip if f = W = operation. Example:, Compare f with W, skip if f = W = HERE NEQUAL. Example:, Compare f with W, skip if f = W = HERE NEQUAL. Example:, Compare f with W, skip if f = W =",
    "PIC18F6585/8585/6680/8680\nCPFSEQ REG, :. Example:, Compare f with W, skip if f = W = CPFSEQ REG, :. Example:, Compare f with W, skip if f = W = 0. Before Instruction, Compare f with W, skip if f = W = Before Instruction. Before Instruction, Compare f with W, skip if f = W = Before Instruction. Before Instruction, Compare f with W, skip if f = W = Before Instruction. Before Instruction, Compare f with W, skip if f = W = Before Instruction. Before Instruction, Compare f with W, skip if f = W = Before Instruction. PC Address, Compare f with W, skip if f = W = =. PC Address, Compare f with W, skip if f = W = HERE. PC Address, Compare f with W, skip if f = W = HERE. PC Address, Compare f with W, skip if f = W = HERE. PC Address, Compare f with W, skip if f = W = HERE. W, Compare f with W, skip if f = W = =. W, Compare f with W, skip if f = W = ?.",
    "PIC18F6585/8585/6680/8680\nW, Compare f with W, skip if f = W = ?. W, Compare f with W, skip if f = W = ?. W, Compare f with W, skip if f = W = ?. REG, Compare f with W, skip if f = W = =. REG, Compare f with W, skip if f = W = ?. REG, Compare f with W, skip if f = W = ?. REG, Compare f with W, skip if f = W = ?. REG, Compare f with W, skip if f = W = ?. After Instruction, Compare f with W, skip if f = W = After Instruction. After Instruction, Compare f with W, skip if f = W = After Instruction. After Instruction, Compare f with W, skip if f = W = After Instruction. After Instruction, Compare f with W, skip if f = W = After Instruction. After Instruction, Compare f with W, skip if f = W = After Instruction. If REG, Compare f with W, skip if f = W = =. If REG, Compare f with W, skip if f = W = W;. If REG, Compare",
    "PIC18F6585/8585/6680/8680\nf with W, skip if f = W = W;. If REG, Compare f with W, skip if f = W = W;. If REG, Compare f with W, skip if f = W = W;. PC, Compare f with W, skip if f = W = =. PC, Compare f with W, skip if f = W = Address (EQUAL) W;. PC, Compare f with W, skip if f = W = Address (EQUAL) W;. PC, Compare f with W, skip if f = W = Address (EQUAL) W;. PC, Compare f with W, skip if f = W = Address (EQUAL) W;. If REG PC, Compare f with W, skip if f = W = \uf0b9 =. If REG PC, Compare f with W, skip if f = W = Address (NEQUAL). If REG PC, Compare f with W, skip if f = W = Address (NEQUAL). If REG PC, Compare f with W, skip if f = W = Address (NEQUAL). If REG PC, Compare f with W, skip if f = W = Address (NEQUAL)",
    "PIC18F6585/8585/6680/8680\nSyntax:, Compare f with W, skip if f > W = [ label ] CPFSGT f [,a]. Syntax:, Compare f with W, skip if f > W = [ label ] CPFSGT f [,a]. Syntax:, Compare f with W, skip if f > W = [ label ] CPFSGT f [,a]. Syntax:, Compare f with W, skip if f > W = [ label ] CPFSGT f [,a]. Operands:, Compare f with W, skip if f > W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f > W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f > W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f > W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Compare f with W, skip if f > W = (f) \uf02d\uf020\uf028 W), skip if (f) > (W) (unsigned comparison). Operation:, Compare",
    "PIC18F6585/8585/6680/8680\nf with W, skip if f > W = (f) \uf02d\uf020\uf028 W), skip if (f) > (W) (unsigned comparison). Operation:, Compare f with W, skip if f > W = (f) \uf02d\uf020\uf028 W), skip if (f) > (W) (unsigned comparison). Operation:, Compare f with W, skip if f > W = (f) \uf02d\uf020\uf028 W), skip if (f) > (W) (unsigned comparison). Status Affected:, Compare f with W, skip if f > W = None. Status Affected:, Compare f with W, skip if f > W = None. Status Affected:, Compare f with W, skip if f > W = None. Status Affected:, Compare f with W, skip if f > W = None. Encoding:, Compare f with W, skip if f > W = 0110. Encoding:, Compare f with W, skip if f > W = 010a. Encoding:, Compare f with W, skip if f > W = ffff. Encoding:, Compare f with W, skip if f > W = ffff. Description:, Compare f with",
    "PIC18F6585/8585/6680/8680\nW, skip if f > W = Compares the contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value. Description:, Compare f with W, skip if f > W = Compares the contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value. Description:, Compare f with W,",
    "PIC18F6585/8585/6680/8680\nskip if f > W = Compares the contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value. Description:, Compare f with W, skip if f > W = Compares the contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value. Words:, Compare f with W, skip if",
    "PIC18F6585/8585/6680/8680\nf > W = 1. Words:, Compare f with W, skip if f > W = 1. Words:, Compare f with W, skip if f > W = 1. Words:, Compare f with W, skip if f > W = 1. Cycles:, Compare f with W, skip if f > W = 1(2). Cycles:, Compare f with W, skip if f > W = 1(2). Cycles:, Compare f with W, skip if f > W = 1(2). Cycles:, Compare f with W, skip if f > W = 1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:",
    "PIC18F6585/8585/6680/8680\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. skip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No",
    "PIC18F6585/8585/6680/8680\noperation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE      CPFSGT REG, 0\nNGREATER  :\nGREATER   :\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nW\n=\n?\nAfter Instruction\nIf REG \uf03e\nW;\nPC\n=\nAddress\n(GREATER)\nIf REG \uf0a3\nW;\nPC\n=\nAddress (NGREATER)",
    "PIC18F6585/8585/6680/8680\nSyntax:, CPFSLT = Syntax:. Syntax:, Compare f with W, skip if f < W = [ label ] CPFSLT f [,a]. Syntax:, Compare f with W, skip if f < W = [ label ] CPFSLT f [,a]. Syntax:, Compare f with W, skip if f < W = [ label ] CPFSLT f [,a]. Operands:, CPFSLT = Operands:. Operands:, Compare f with W, skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Compare f with W, skip if f < W = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, CPFSLT = Operation:. Operation:, Compare f with W, skip if f < W = (f) - \uf020\uf028 W), skip if (f) < (W) (unsigned comparison). Operation:, Compare f with W, skip if f < W = (f) - \uf020\uf028 W), skip",
    "PIC18F6585/8585/6680/8680\nif (f) < (W) (unsigned comparison). Operation:, Compare f with W, skip if f < W = (f) - \uf020\uf028 W), skip if (f) < (W) (unsigned comparison). Status Affected:, CPFSLT = Status Affected:. Status Affected:, Compare f with W, skip if f < W = None. Status Affected:, Compare f with W, skip if f < W = None. Status Affected:, Compare f with W, skip if f < W = None. Encoding:, CPFSLT = Encoding:. Encoding:, Compare f with W, skip if f < W = 0110. Encoding:, Compare f with W, skip if f < W = 0110. Encoding:, Compare f with W, skip if f < W = 000a. Description:, CPFSLT = Description:. Description:, Compare f with W, skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and",
    "PIC18F6585/8585/6680/8680\na NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a'. Description:, Compare f with W, skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a'. Description:, Compare f with W, skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a'. Words:, CPFSLT = Words:. Words:, Compare",
    "PIC18F6585/8585/6680/8680\nf with W, skip if f < W = den (default). 1. Words:, Compare f with W, skip if f < W = den (default). 1. Words:, Compare f with W, skip if f < W = den (default). 1. Cycles:, CPFSLT = Cycles:. Cycles:, Compare f with W, skip if f < W = 1(2) Note: 3 cycles if skip and followed. Cycles:, Compare f with W, skip if f < W = 1(2) Note: 3 cycles if skip and followed. Cycles:, Compare f with W, skip if f < W = 1(2) Note: 3 cycles if skip and followed. Q Cycle Activity:, CPFSLT = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, skip if f < W = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, skip if f < W = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, skip if f < W = Q Cycle Activity:. , CPFSLT = Q1. , Compare f with W, skip",
    "PIC18F6585/8585/6680/8680\nif f < W = Q2. , Compare f with W, skip if f < W = Q2. , Compare f with W, skip if f < W = Q3. , CPFSLT = Decode. , Compare f with W, skip if f < W = Read register 'f'. , Compare f with W, skip if f < W = Read register 'f'. , Compare f with W, skip if f < W = Process Data. If skip:, CPFSLT = If skip:. If skip:, Compare f with W, skip if f < W = If skip:. If skip:, Compare f with W, skip if f < W = If skip:. If skip:, Compare f with W, skip if f < W = If skip:. , CPFSLT = Q1. , Compare f with W, skip if f < W = Q2. , Compare f with W, skip if f < W = Q2. , Compare f with W, skip if f < W = Q3. , CPFSLT = No operation. , Compare f with W, skip if f < W = No operation.",
    "PIC18F6585/8585/6680/8680\n, Compare f with W, skip if f < W = No operation. , Compare f with W, skip if f < W = No operation. If skip and followed by 2-word instruction:, CPFSLT = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, skip if f < W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, skip if f < W = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Compare f with W, skip if f < W = If skip and followed by 2-word instruction:. , CPFSLT = Q1. , Compare f with W, skip if f < W = Q2. , Compare f with W, skip if f < W = Q2. , Compare f with W, skip if f < W = Q3. , CPFSLT = No operation. , Compare f with W, skip if f < W = No operation. , Compare f with W, skip if f < W",
    "PIC18F6585/8585/6680/8680\n= No operation. , Compare f with W, skip if f < W = No operation. , CPFSLT = No operation. , Compare f with W, skip if f < W = No operation. , Compare f with W, skip if f < W = No operation. , Compare f with W, skip if f < W = No operation. Example:, CPFSLT = Example:. Example:, Compare f with W, skip if f < W = HERE NLESS LESS. Example:, Compare f with W, skip if f < W = CPFSLT REG, : :. Example:, Compare f with W, skip if f < W = CPFSLT REG, : :. Before Instruction, CPFSLT = Before Instruction. Before Instruction, Compare f with W, skip if f < W = Before Instruction. Before Instruction, Compare f with W, skip if f < W = Before Instruction. Before Instruction, Compare f with W, skip if f < W = Before Instruction. , CPFSLT = PC W. , Compare f with W, skip if f < W = = = ?. , Compare f with W, skip if f < W =",
    "PIC18F6585/8585/6680/8680\nAddress (HERE). , Compare f with W, skip if f < W = Address (HERE). After Instruction, CPFSLT = After Instruction. After Instruction, Compare f with W, skip if f < W = After Instruction. After Instruction, Compare f with W, skip if f < W = After Instruction. After Instruction, Compare f with W, skip if f < W = After Instruction. , CPFSLT = If REG PC. , Compare f with W, skip if f < W = < W; =. , Compare f with W, skip if f < W = Address (LESS). , Compare f with W, skip if f < W = Address (LESS). , CPFSLT = If REG PC. , Compare f with W, skip if f < W = \uf0b3 W; =. , Compare f with W, skip if f < W = Address (NLESS). , Compare f with W, skip if f < W = Address (NLESS)",
    "PIC18F6585/8585/6680/8680\nSyntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0>;. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1] then (W<3:0>) + 6 \uf0ae W<3:0>; else (",
    "PIC18F6585/8585/6680/8680\nW<3:0>) \uf0ae W<3:0>;. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0>;. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0>;. Operation:, Decimal Adjust WRegister = If [W<3:0> >9] or [DC = 1] then (W<3:0>) + 6 \uf0ae W<3:0>; else ( W<3:0>) \uf0ae W<3:0>;. If ( else (W<7:4>), Decimal Adjust WRegister = [W<7:4> >9] or [C = 1] then W<7:4>) + 6 \uf0ae",
    "PIC18F6585/8585/6680/8680\nW<7:4>; \uf0ae W<7:4>;. If ( else (W<7:4>), Decimal Adjust WRegister = [W<7:4> >9] or [C = 1] then W<7:4>) + 6 \uf0ae W<7:4>; \uf0ae W<7:4>;. If ( else (W<7:4>), Decimal Adjust WRegister = [W<7:4> >9] or [C = 1] then W<7:4>) + 6 \uf0ae W<7:4>; \uf0ae W<7:4>;. If ( else (W<7:4>), Decimal Adjust WRegister = [W<7:4> >9] or [C = 1] then W<7:4>) + 6 \uf0ae W<7:4>; \uf0ae W<7:4>;. If ( else (W<7:4>), Decimal Adjust WRegister = [W<7:4> >9] or [C = 1] then W<7:4>) + 6 \uf0ae",
    "PIC18F6585/8585/6680/8680\nW<7:4>; \uf0ae W<7:4>;. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0111. Encoding:, Decimal Adjust WRegister = . Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the",
    "PIC18F6585/8585/6680/8680\neight-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Q Cycle Activity:,",
    "PIC18F6585/8585/6680/8680\nDecimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q1, Decimal Adjust WRegister = . Q1, Decimal Adjust WRegister = Q2. Q1, Decimal Adjust WRegister = Q3. Q1, Decimal Adjust WRegister = Q4. Q1, Decimal Adjust WRegister = . Decode, Decimal Adjust WRegister = Read register W. Decode, Decimal Adjust WRegister = Read register W. Decode, Decimal Adjust WRegister = Process Data. Decode, Decimal Adjust WRegister = Write W. Decode, Decimal Adjust WRegister = . Example1:, Decimal Adjust WRegister = DAW. Example1:, Decimal Adjust WRegister = DAW. Example1:, Decimal Adjust WRegister = DAW. Example1:, Decimal Adjust WRegister =",
    "PIC18F6585/8585/6680/8680\nDAW. Example1:, Decimal Adjust WRegister = DAW. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. W, Decimal Adjust WRegister = =. W, Decimal Adjust WRegister = 0xA5. W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . C DC, Decimal Adjust WRegister = =. C DC, Decimal Adjust WRegister = 0. C DC, Decimal Adjust WRegister = . C DC, Decimal Adjust WRegister = . C DC, Decimal Adjust WRegister = . , Decimal Adjust WRegister = =. , Decimal Adjust WRegister = 0. , Decimal Adjust WRegister = . , Decimal Adjust WRegister = . , Decimal Adjust WRegister = . After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After",
    "PIC18F6585/8585/6680/8680\nInstruction. After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After Instruction. W, Decimal Adjust WRegister = =. W, Decimal Adjust WRegister = 0x05. W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = =. C, Decimal Adjust WRegister = 1. C, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = =. DC, Decimal Adjust WRegister = 0. DC, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = . Example 2:, Decimal Adjust WRegister = Example 2:. Example 2:, Decimal Adjust WRegister = Example 2:. Example 2:, Decimal Adjust WRegister = Example 2:. Example 2:, Decimal Adjust WRegister = Example 2:. Example 2:,",
    "PIC18F6585/8585/6680/8680\nDecimal Adjust WRegister = Example 2:. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. W, Decimal Adjust WRegister = =. W, Decimal Adjust WRegister = 0xCE. W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = =. C, Decimal Adjust WRegister = 0. C, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = =. DC, Decimal Adjust WRegister = 0. DC, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = . After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust",
    "PIC18F6585/8585/6680/8680\nWRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After Instruction. W, Decimal Adjust WRegister = =. W, Decimal Adjust WRegister = 0x34. W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = =. C, Decimal Adjust WRegister = 1. C, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = =. DC, Decimal Adjust WRegister = 0. DC, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, Decrement f = [ label ] DECF f [,d [,a]]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest. Operation:, Decrement f = (f) - 1 \uf0ae dest.",
    "PIC18F6585/8585/6680/8680\nOperation:, Decrement f = (f) - 1 \uf0ae dest. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Encoding:, Decrement f = 0000. Encoding:, Decrement f = 01da. Encoding:, Decrement f = ffff. Encoding:, Decrement f = ffff. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default)..",
    "PIC18F6585/8585/6680/8680\nDescription:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is '",
    "PIC18F6585/8585/6680/8680\n1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . Q Cycle Activity:, Decrement f = . , Decrement f = Q1 Q2 Q3 Q4 Read register 'f' Process Data Write Example: DECF CNT, 1, 0 Before Instruction. , Decrement f = Q1 Q2 Q3 Q4 Read register 'f'",
    "PIC18F6585/8585/6680/8680\nProcess Data Write Example: DECF CNT, 1, 0 Before Instruction. , Decrement f = Q1 Q2 Q3 Q4 Read register 'f' Process Data Write Example: DECF CNT, 1, 0 Before Instruction. , Decrement f = Q1 Q2 Q3 Q4 Read register 'f' Process Data Write Example: DECF CNT, 1, 0 Before Instruction. , Decrement f = . , Decrement f = 0x01 0. , Decrement f = . , Decrement f = . , Decrement f = Decode. , Decrement f = . , Decrement f = . , Decrement f = to destination. , Decrement f = CNT Z. , Decrement f = = =. , Decrement f = . , Decrement f = . After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = After Instruction. , Decrement f = CNT Z. , Decrement f",
    "PIC18F6585/8585/6680/8680\n= = =. , Decrement f = 0x00 1. , Decrement f = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, DECFSZ = Syntax:. Syntax:, Decrement f, skip if 0 = [ label ] DECFSZ f [,d [,a]]. Syntax:, Decrement f, skip if 0 = [ label ] DECFSZ f [,d [,a]]. Syntax:, Decrement f, skip if 0 = [ label ] DECFSZ f [,d [,a]]. Syntax:, Decrement f, skip if 0 = [ label ] DECFSZ f [,d [,a]]. Operands:, DECFSZ = Operands:. Operands:, Decrement f, skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce",
    "PIC18F6585/8585/6680/8680\n[0,1] a \uf0ce [0,1]. Operation:, DECFSZ = Operation:. Operation:, Decrement f, skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, Decrement f, skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, Decrement f, skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Operation:, Decrement f, skip if 0 = (f) - 1 \uf0ae dest, skip if result = 0. Status Affected:, DECFSZ = Status Affected:. Status Affected:, Decrement f, skip if 0 = None. Status Affected:, Decrement f, skip if 0 = None. Status Affected:, Decrement f, skip if 0 = None. Status Affected:, Decrement f, skip if 0 = None. Encoding:, DECFSZ = Encoding:. Encoding:, Decrement f, skip if 0 = 0010. Encoding:, Decrement f, skip if 0 = 11da. Encoding:,",
    "PIC18F6585/8585/6680/8680\nDecrement f, skip if 0 = ffff. Encoding:, Decrement f, skip if 0 = ffff. Description:, DECFSZ = Description:. Description:, Decrement f, skip if 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = , then the. Description:, Decrement f, skip if 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is",
    "PIC18F6585/8585/6680/8680\nalready fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = , then the. Description:, Decrement f, skip if 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = , then the. Description:, Decrement f, skip if 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f'",
    "PIC18F6585/8585/6680/8680\n(default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = , then the. Words:, DECFSZ = Words:. Words:, Decrement f, skip if 0 = BSR value (default). 1. Words:, Decrement f, skip if 0 = BSR value (default). 1. Words:, Decrement f, skip if 0 = BSR value (default). 1. Words:, Decrement f, skip if 0 = BSR value (default). 1. Cycles:, DECFSZ = Cycles:. Cycles:, Decrement f, skip if 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Decrement f, skip if 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Decrement f, skip if 0 = 1(2) Note:",
    "PIC18F6585/8585/6680/8680\n3 cycles if skip and followed. Cycles:, Decrement f, skip if 0 = 1(2) Note: 3 cycles if skip and followed. Q Cycle Activity:, DECFSZ = Q Cycle Activity:. Q Cycle Activity:, Decrement f, skip if 0 = Q Cycle Activity:. Q Cycle Activity:, Decrement f, skip if 0 = Q Cycle Activity:. Q Cycle Activity:, Decrement f, skip if 0 = Q Cycle Activity:. Q Cycle Activity:, Decrement f, skip if 0 = Q Cycle Activity:. , DECFSZ = Q1. , Decrement f, skip if 0 = Q2. , Decrement f, skip if 0 = Q2. , Decrement f, skip if 0 = Q3. , Decrement f, skip if 0 = Q4. Decode, DECFSZ = . Decode, Decrement f, skip if 0 = Read register 'f'. Decode, Decrement f, skip if 0 = Read register 'f'. Decode, Decrement f, skip if 0 = Process Data.",
    "PIC18F6585/8585/6680/8680\nDecode, Decrement f, skip if 0 = Write to destination. If skip:, DECFSZ = If skip:. If skip:, Decrement f, skip if 0 = If skip:. If skip:, Decrement f, skip if 0 = If skip:. If skip:, Decrement f, skip if 0 = If skip:. If skip:, Decrement f, skip if 0 = If skip:. , DECFSZ = Q1. , Decrement f, skip if 0 = Q2. , Decrement f, skip if 0 = Q2. , Decrement f, skip if 0 = Q3. , Decrement f, skip if 0 = Q4. No, DECFSZ = . No, Decrement f, skip if 0 = No. No, Decrement f, skip if 0 = No. No, Decrement f, skip if 0 = No. No, Decrement f, skip if 0 = No. operation, DECFSZ = . operation, Decrement f, skip if 0 = operation. operation, Decrement f,",
    "PIC18F6585/8585/6680/8680\nskip if 0 = operation. operation, Decrement f, skip if 0 = operation. operation, Decrement f, skip if 0 = operation. If skip and followed by 2-word instruction:, DECFSZ = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, skip if 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, skip if 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, skip if 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Decrement f, skip if 0 = If skip and followed by 2-word instruction:. , DECFSZ = Q1. , Decrement f, skip if 0 = Q2. , Decrement f, skip if 0 = Q2. , Decrement f, skip if 0 = Q3. , Decrement f, skip if 0 = Q4.",
    "PIC18F6585/8585/6680/8680\n, DECFSZ = No. , Decrement f, skip if 0 = No. , Decrement f, skip if 0 = No. , Decrement f, skip if 0 = No. , Decrement f, skip if 0 = No. , DECFSZ = operation. , Decrement f, skip if 0 = operation. , Decrement f, skip if 0 = operation. , Decrement f, skip if 0 = operation. , Decrement f, skip if 0 = operation. , DECFSZ = No. , Decrement f, skip if 0 = No. , Decrement f, skip if 0 = No. , Decrement f, skip if 0 = No. , Decrement f, skip if 0 = No. , DECFSZ = operation. , Decrement f, skip if 0 = operation. , Decrement f, skip if 0 = operation. , Decrement f, skip if 0 = operation. , Decrement f, skip if 0 = operation. Example:, DECFSZ = Example:. Example:, Decrement f, skip if 0 =",
    "PIC18F6585/8585/6680/8680\nHERE. Example:, Decrement f, skip if 0 = HERE. Example:, Decrement f, skip if 0 = DECFSZ GOTO. Example:, Decrement f, skip if 0 = CNT, 1, 1 LOOP. CONTINUE, DECFSZ = CONTINUE. CONTINUE, Decrement f, skip if 0 = CONTINUE. CONTINUE, Decrement f, skip if 0 = CONTINUE. CONTINUE, Decrement f, skip if 0 = CONTINUE. CONTINUE, Decrement f, skip if 0 = CONTINUE. Before Instruction, DECFSZ = Before Instruction. Before Instruction, Decrement f, skip if 0 = Before Instruction. Before Instruction, Decrement f, skip if 0 = Before Instruction. Before Instruction, Decrement f, skip if 0 = Before Instruction. Before Instruction, Decrement f, skip if 0 = Before Instruction. PC, DECFSZ = . PC, Decrement f, skip if 0 = =. PC, Decrement f, skip if 0 = Address. PC, Decrement f, skip if 0 = (HERE). PC, Decrement f, skip if 0",
    "PIC18F6585/8585/6680/8680\n= . After Instruction, DECFSZ = After Instruction. After Instruction, Decrement f, skip if 0 = After Instruction. After Instruction, Decrement f, skip if 0 = After Instruction. After Instruction, Decrement f, skip if 0 = After Instruction. After Instruction, Decrement f, skip if 0 = After Instruction. If, DECFSZ = CNT CNT. If, Decrement f, skip if 0 = = =. If, Decrement f, skip if 0 = CNT - 1 0;. If, Decrement f, skip if 0 = . If, Decrement f, skip if 0 = . , DECFSZ = PC. , Decrement f, skip if 0 = =. , Decrement f, skip if 0 = Address. , Decrement f, skip if 0 = (CONTINUE). , Decrement f, skip if 0 = . , DECFSZ = If CNT PC. , Decrement f, skip if 0 = \uf0b9 =. , Decrement f, skip if 0 = 0; Address. , Decrement f, skip if 0 =",
    "PIC18F6585/8585/6680/8680\n(HERE+2). , Decrement f, skip if 0 = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, Decrement f, skip if not 0 = [ label ] DCFSNZ f [,d. Syntax:, Decrement f, skip if not 0 = [ label ] DCFSNZ f [,d. Syntax:, Decrement f, skip if not 0 = [ label ] DCFSNZ f [,d. Syntax:, Decrement f, skip if not 0 = [,a]]. Operands:, Decrement f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Decrement f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Decrement f, skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:,",
    "PIC18F6585/8585/6680/8680\nDecrement f, skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \uf0ae dest, skip if result \uf0b9 0. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Encoding:, Decrement f, skip if not 0 = 0100. Encoding:, Decrement f, skip if not 0 = 11da. Encoding:, Decrement f, skip if not 0 = ffff. Encoding:, Decrement f, skip if not 0 = ffff. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in",
    "PIC18F6585/8585/6680/8680\nW. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected",
    "PIC18F6585/8585/6680/8680\nas per the BSR value (default).. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a",
    "PIC18F6585/8585/6680/8680\nNOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Decrement f, skip if not 0 = 1. Words:, Decrement f, skip if not 0 = 1. Words:, Decrement f, skip if not 0 = 1. Words:, Decrement f, skip if not 0 = 1. Cycles:, Decrement f, skip if not 0 = 1(2). Cycles:, Decrement f, skip if not 0 = . Cycles:, Decrement f, skip if not 0 = . Cycles:, Decrement f, skip if not 0 = \nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. skip:, Q2 = . skip:, Q3 = . skip:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4",
    "Q Cycle Activity:\n= No operation\nExample:\nHERE    DCFSNZ  TEMP, 1, 0\nZERO    :\nNZERO   :\nBefore Instruction\nTEMP\n=\n?\nAfter Instruction\nTEMP\n=\nTEMP - 1,\nIf TEMP\n=\n0;\nPC\n=\nAddress\n(ZERO)\nIf TEMP\n\uf0b9\n0;\nPC\n=\nAddress (NZERO)",
    "PIC18F6585/8585/6680/8680\nSyntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operands:, Unconditional Branch = 0 \uf0a3 k \uf0a3 1048575. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Operation:, Unconditional Branch = k \uf0ae PC<20:1>. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Encoding: 1st word (k<7:0>) 2nd",
    "PIC18F6585/8585/6680/8680\nword(k<19:8>), Unconditional Branch = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = 1111 k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = kkkk 0 kkkk 8. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:,",
    "PIC18F6585/8585/6680/8680\nUnconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Q Cycle Activity:, Unconditional Branch = . Q Cycle Activity:, Unconditional Branch = . Q Cycle Activity:, Unconditional Branch = . Q Cycle Activity:, Unconditional Branch = . Q1, Unconditional Branch = Q2",
    "PIC18F6585/8585/6680/8680\nQ3 Q4. Q1, Unconditional Branch = Q2 Q3 Q4. Q1, Unconditional Branch = Q2 Q3 Q4. Q1, Unconditional Branch = Q2 Q3 Q4. Decode, Unconditional Branch = Read literal 'k'<7:0>, No operation Read literal 'k'<19:8>, Write to PC No operation No operation No operation. Decode, Unconditional Branch = Read literal 'k'<7:0>, No operation Read literal 'k'<19:8>, Write to PC No operation No operation No operation. Decode, Unconditional Branch = Read literal 'k'<7:0>, No operation Read literal 'k'<19:8>, Write to PC No operation No operation No operation. Decode, Unconditional Branch = Read literal 'k'<7:0>, No operation Read literal 'k'<19:8>, Write to PC No operation No operation No operation. Example:, Unconditional Branch = GOTO THERE. Example:, Unconditional Branch = GOTO THERE.",
    "PIC18F6585/8585/6680/8680\nExample:, Unconditional Branch = GOTO THERE. Example:, Unconditional Branch = GOTO THERE",
    "PIC18F6585/8585/6680/8680\nSyntax:, Increment f = [ label ] INCF. Syntax:, Increment f = [ label ] INCF. Syntax:, Increment f = [ label ] INCF. Syntax:, Increment f = f [,d [,a]]. Syntax:, Increment f = f [,d [,a]]. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Increment f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1]. Operands:, Increment f = . Operands:, Increment f = . Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = (f) + 1 \uf0ae dest. Operation:, Increment f = . Operation:, Increment f = . Status Affected:, Increment f = C, DC, N, OV, Z. Status",
    "PIC18F6585/8585/6680/8680\nAffected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f = C, DC, N, OV, Z. Status Affected:, Increment f = . Status Affected:, Increment f = . Encoding:, Increment f = 0010. Encoding:, Increment f = 0010. Encoding:, Increment f = 10da. Encoding:, Increment f = ffff. Encoding:, Increment f = ffff. Description:, Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Increment f = The contents of register 'f' are incremented. If",
    "PIC18F6585/8585/6680/8680\n'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in",
    "PIC18F6585/8585/6680/8680\nregister 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Increment f = 1. Words:, Increment f = 1. Words:, Increment f = 1. Words:, Increment f = . Words:, Increment f = . Cycles:, Increment f = 1. Cycles:, Increment f = 1. Cycles:, Increment f = 1. Cycles:,",
    "PIC18F6585/8585/6680/8680\nIncrement f = . Cycles:, Increment f = . Q Cycle Activity:, Increment f = Q Cycle Activity:. Q Cycle Activity:, Increment f = Q Cycle Activity:. Q Cycle Activity:, Increment f = Q Cycle Activity:. Q Cycle Activity:, Increment f = . Q Cycle Activity:, Increment f = . Q1, Increment f = Q2. Q1, Increment f = Q2. Q1, Increment f = Q3. Q1, Increment f = Q3. Q1, Increment f = Q4. Decode, Increment f = Read register 'f'. Decode, Increment f = Read register 'f'. Decode, Increment f = Process Data. Decode, Increment f = Process Data. Decode, Increment f = Write to destination. Example: INCF, Increment f = Example: INCF. Example: INCF, Increment f = Example: INCF. Example: INCF, Increment f = CNT,",
    "PIC18F6585/8585/6680/8680\n1,. Example: INCF, Increment f = 0. Example: INCF, Increment f = . Before Instruction, Increment f = Before Instruction. Before Instruction, Increment f = Before Instruction. Before Instruction, Increment f = . Before Instruction, Increment f = . Before Instruction, Increment f = . CNT, Increment f = =. CNT, Increment f = 0xFF. CNT, Increment f = . CNT, Increment f = . CNT, Increment f = . Z, Increment f = =. Z, Increment f = 0. Z, Increment f = . Z, Increment f = . Z, Increment f = . C, Increment f = =. C, Increment f = ?. C, Increment f = . C, Increment f = . C, Increment f = . DC, Increment f = =. DC, Increment f = ?. DC, Increment f = . DC, Increment f = .",
    "PIC18F6585/8585/6680/8680\nDC, Increment f = . After Instruction, Increment f = After Instruction. After Instruction, Increment f = After Instruction. After Instruction, Increment f = . After Instruction, Increment f = . After Instruction, Increment f = . CNT, Increment f = =. CNT, Increment f = 0x00. CNT, Increment f = . CNT, Increment f = . CNT, Increment f = . Z, Increment f = =. Z, Increment f = 1. Z, Increment f = . Z, Increment f = . Z, Increment f = . C, Increment f = =. C, Increment f = 1. C, Increment f = . C, Increment f = . C, Increment f = . DC, Increment f = =. DC, Increment f = 1. DC, Increment f = . DC, Increment f = . DC, Increment f = ",
    "INCFSZ\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:",
    "Increment f, skip if 0\n[\nlabel\n]    INCFSZ    f [,d [,a]]\n0\n\uf0a3\nf\n\uf0a3\n255\nd \uf0ce [0,1]\na \uf0ce [0,1]\n(f) + 1 \uf0ae dest,\n0\nskip if result =\nNone\n0011\n11da ffff\nffff\nThe contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default).\nIf the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:",
    "Increment f, skip if 0\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. If skip:, Q2 = If skip:. If skip:, Q3 = If skip:. If skip:, Q4 = If skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No",
    "Increment f, skip if 0\noperation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE    INCFSZ   CNT, 1, 0\nNZERO   :\nZERO    :\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nAfter Instruction\nCNT\n=\nCNT + 1\nIf CNT\n=\n0;\nPC\n=\nAddress\n(ZERO)\nIf CNT\n\uf0b9\n0;\nPC\n=\nAddress (NZERO)",
    "PIC18F6585/8585/6680/8680\nSyntax:, Increment f, skip if not 0 = Syntax:. Syntax:, Increment f, skip if not 0 = [ label ] INFSNZ. Syntax:, Increment f, skip if not 0 = [ label ] INFSNZ. Syntax:, Increment f, skip if not 0 = f [,d [,a]]. Syntax:, Increment f, skip if not 0 = f [,d [,a]]. Operands:, Increment f, skip if not 0 = Operands:. Operands:, Increment f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, skip if not 0 = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Increment f, skip if not 0 = . Operands:, Increment f, skip if not 0 = . Operation:, Increment f, skip if not 0 = Operation:. Operation:, Increment f, skip if not 0 = (f)",
    "PIC18F6585/8585/6680/8680\n+ 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Increment f, skip if not 0 = (f) + 1 \uf0ae dest, skip if result \uf0b9 0. Operation:, Increment f, skip if not 0 = . Operation:, Increment f, skip if not 0 = . Status Affected:, Increment f, skip if not 0 = Status Affected:. Status Affected:, Increment f, skip if not 0 = None. Status Affected:, Increment f, skip if not 0 = None. Status Affected:, Increment f, skip if not 0 = . Status Affected:, Increment f, skip if not 0 = . Encoding:, Increment f, skip if not 0 = Encoding:. Encoding:, Increment f, skip if not 0 = 0100. Encoding:, Increment f, skip if not 0 = 10da. Encoding:, Increment f, skip if not 0 = ffff. Encoding:, Increment f, skip if not 0 = ffff. Description:, Increment f, skip if not 0 = Description:.",
    "PIC18F6585/8585/6680/8680\nDescription:, Increment f, skip if not 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the. Description:, Increment f, skip if not 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a'",
    "PIC18F6585/8585/6680/8680\nis ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the. Description:, Increment f, skip if not 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the. Description:, Increment f, skip if not 0 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result",
    "PIC18F6585/8585/6680/8680\nis not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the. Words:, Increment f, skip if not 0 = Words:. Words:, Increment f, skip if not 0 = BSR value (default). 1. Words:, Increment f, skip if not 0 = BSR value (default). 1. Words:, Increment f, skip if not 0 = . Words:, Increment f, skip if not 0 = . Cycles:, Increment f, skip if not 0 = Cycles:. Cycles:, Increment f, skip if not 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Increment f, skip if not 0 = 1(2) Note: 3 cycles if skip and followed. Cycles:, Increment f, skip if not 0 =",
    "PIC18F6585/8585/6680/8680\n1(2) Note: 3 cycles if skip and followed. Cycles:, Increment f, skip if not 0 = 1(2) Note: 3 cycles if skip and followed. Q Cycle Activity:, Increment f, skip if not 0 = Q Cycle Activity:. Q Cycle Activity:, Increment f, skip if not 0 = Q Cycle Activity:. Q Cycle Activity:, Increment f, skip if not 0 = Q Cycle Activity:. Q Cycle Activity:, Increment f, skip if not 0 = Q Cycle Activity:. Q Cycle Activity:, Increment f, skip if not 0 = Q Cycle Activity:. , Increment f, skip if not 0 = Q1. , Increment f, skip if not 0 = Q2. , Increment f, skip if not 0 = Q3. , Increment f, skip if not 0 = Q3. , Increment f, skip if not 0 = Q4. Decode, Increment f, skip if not 0 = . Decode, Increment f, skip if not 0 = Read register 'f'.",
    "PIC18F6585/8585/6680/8680\nDecode, Increment f, skip if not 0 = Process Data. Decode, Increment f, skip if not 0 = Process Data. Decode, Increment f, skip if not 0 = Write to destination. If skip:, Increment f, skip if not 0 = If skip:. If skip:, Increment f, skip if not 0 = If skip:. If skip:, Increment f, skip if not 0 = If skip:. If skip:, Increment f, skip if not 0 = If skip:. If skip:, Increment f, skip if not 0 = If skip:. , Increment f, skip if not 0 = Q1. , Increment f, skip if not 0 = Q2. , Increment f, skip if not 0 = Q3. , Increment f, skip if not 0 = Q3. , Increment f, skip if not 0 = Q4. No, Increment f, skip if not 0 = . No, Increment f, skip if not 0 = No. No, Increment",
    "PIC18F6585/8585/6680/8680\nf, skip if not 0 = No. No, Increment f, skip if not 0 = No. No, Increment f, skip if not 0 = No. operation, Increment f, skip if not 0 = . operation, Increment f, skip if not 0 = operation. operation, Increment f, skip if not 0 = operation. operation, Increment f, skip if not 0 = operation. operation, Increment f, skip if not 0 = operation. If skip and followed by 2-word instruction:, Increment f, skip if not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Increment f, skip if not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Increment f, skip if not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Increment f, skip if not 0 = If skip and followed by 2-word instruction:. If skip and followed by 2-word",
    "PIC18F6585/8585/6680/8680\ninstruction:, Increment f, skip if not 0 = If skip and followed by 2-word instruction:. , Increment f, skip if not 0 = Q1. , Increment f, skip if not 0 = Q2. , Increment f, skip if not 0 = Q3. , Increment f, skip if not 0 = Q3. , Increment f, skip if not 0 = Q4. , Increment f, skip if not 0 = No operation. , Increment f, skip if not 0 = No operation. , Increment f, skip if not 0 = No operation. , Increment f, skip if not 0 = No operation. , Increment f, skip if not 0 = No operation. , Increment f, skip if not 0 = No operation. , Increment f, skip if not 0 = No operation. , Increment f, skip if not 0 = No operation. , Increment f, skip if not 0 = No operation. , Increment f, skip if not 0 = No operation. Example:, Increment f,",
    "PIC18F6585/8585/6680/8680\nskip if not 0 = Example:. Example:, Increment f, skip if not 0 = HERE ZERO NZERO. Example:, Increment f, skip if not 0 = INFSNZ. Example:, Increment f, skip if not 0 = REG,. Example:, Increment f, skip if not 0 = 1, 0. Before Instruction, Increment f, skip if not 0 = Before Instruction. Before Instruction, Increment f, skip if not 0 = Before Instruction. Before Instruction, Increment f, skip if not 0 = Before Instruction. Before Instruction, Increment f, skip if not 0 = Before Instruction. Before Instruction, Increment f, skip if not 0 = Before Instruction. , Increment f, skip if not 0 = PC. , Increment f, skip if not 0 = = Address. , Increment f, skip if not 0 = (HERE). , Increment f, skip if not 0 = . , Increment f, skip if not 0 = . After Instruction, Increment f, skip if not 0 = After Instruction. After Instruction,",
    "PIC18F6585/8585/6680/8680\nIncrement f, skip if not 0 = After Instruction. After Instruction, Increment f, skip if not 0 = After Instruction. After Instruction, Increment f, skip if not 0 = After Instruction. After Instruction, Increment f, skip if not 0 = After Instruction. , Increment f, skip if not 0 = REG If REG. , Increment f, skip if not 0 = = REG + 0;. , Increment f, skip if not 0 = 1. , Increment f, skip if not 0 = . , Increment f, skip if not 0 = . , Increment f, skip if not 0 = PC If REG. , Increment f, skip if not 0 = \uf0b9 = Address. , Increment f, skip if not 0 = (NZERO). , Increment f, skip if not 0 = . , Increment f, skip if not 0 = . , Increment f, skip if not 0 = PC. , Increment f, skip if not 0 = = 0; = Address. , Increment f, skip if not 0 =",
    "PIC18F6585/8585/6680/8680\n(ZERO). , Increment f, skip if not 0 = . , Increment f, skip if not 0 = ",
    "Inclusive OR literal with W\nSyntax:\n[ label\n]    IORLW   k\nOperands:\n0 \uf0a3 k \uf0a3 255\nOperation:\n(W) .OR. k \uf0ae W\nStatus Affected:\nN, Z\nEncoding:\n0000\n1001\nkkkk\nkkkk\nDescription:\nThe contents of W are OR'ed with the eight-bit literal 'k'. The result is placed in W.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nliteral 'k'\nProcess\nData\nWrite to W",
    "Example:\nIORLW\n0x35\nBefore Instruction\nW\n=\n0x9A\nAfter Instruction\nW\n=\n0xBF",
    "Example:\nSyntax:, Inclusive OR Wwith f = [ label ] IORWF. Syntax:, Inclusive OR Wwith f = [ label ] IORWF. Syntax:, Inclusive OR Wwith f = f [,d [,a]]. Syntax:, Inclusive OR Wwith f = f [,d [,a]]. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Inclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Inclusive OR Wwith f = . Operands:, Inclusive OR Wwith f = . Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \uf0ae dest. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f =",
    "Example:\nN, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Encoding:, Inclusive OR Wwith f = 0001. Encoding:, Inclusive OR Wwith f = 00da. Encoding:, Inclusive OR Wwith f = ffff. Encoding:, Inclusive OR Wwith f = ffff. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will",
    "Example:\nbe selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Inclusive OR Wwith f = 1.",
    "Example:\nWords:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = 1. Q Cycle Activity:, Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Wwith f = Q Cycle Activity:. Q1, Inclusive OR Wwith f = Q2. Q1, Inclusive OR Wwith f = Q3. Q1, Inclusive OR Wwith f = Q4. Q1, Inclusive OR Wwith f = Q4. Decode, Inclusive OR Wwith f = Read register 'f'. Decode, Inclusive OR Wwith f = Process Data. Decode, Inclusive OR Wwith f = Write to destination. Decode, Inclusive OR Wwith f = Write to destination. Example:, Inclusive OR Wwith f =",
    "Example:\nIORWF. Example:, Inclusive OR Wwith f = RESULT, 0, 1. Example:, Inclusive OR Wwith f = RESULT, 0, 1. Example:, Inclusive OR Wwith f = RESULT, 0, 1. Before Instruction, Inclusive OR Wwith f = Before Instruction. Before Instruction, Inclusive OR Wwith f = Before Instruction. Before Instruction, Inclusive OR Wwith f = Before Instruction. Before Instruction, Inclusive OR Wwith f = Before Instruction. RESULT, Inclusive OR Wwith f = = 0x13. RESULT, Inclusive OR Wwith f = . RESULT, Inclusive OR Wwith f = . RESULT, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = = 0x91. W, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = . After Instruction = 0x13, Inclusive OR Wwith f = After Instruction = 0x13. After Instruction = 0x13, Inclusive OR Wwith f = After Instruction = 0x13. After Instruction = 0x13, Inclusive OR Wwith f = After Instruction = 0x13. After Instruction = 0x13, Inclusive OR Wwith f = After Instruction",
    "Example:\n= 0x13. RESULT, Inclusive OR Wwith f = . RESULT, Inclusive OR Wwith f = . RESULT, Inclusive OR Wwith f = . RESULT, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = = 0x93. W, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = . W, Inclusive OR Wwith f = ",
    "LFSR\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nLoad FSR\n[\nlabel\n]    LFSR   f,k\n0\n\uf0a3\nf\n\uf0a3\n2\n0 \uf0a3 k \uf0a3 4095\nk \uf0ae FSRf\nNone\n1110\n1110\n00ff",
    "PIC18F6585/8585/6680/8680\nk 11 kkk\n1111\n0000\nk 7\nkkk kkkk\nThe 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.\nSyntax:, Move f = [ label ]. Syntax:, Move f = MOVF. Syntax:, Move f = f [,d [,a]]. Syntax:, Move f = . Operands:, Move f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Move f = . Operands:, Move f = . Operands:, Move f = . Operation:, Move f = f \uf0ae dest. Operation:, Move f = . Operation:, Move f = . Operation:, Move f = . Status Affected:, Move f = N, Z. Status Affected:, Move f = . Status Affected:, Move f = . Status Affected:, Move f = . Encoding:, Move f = 0101. Encoding:, Move f = 00da. Encoding:, Move f = ffff. Encoding:, Move f = ffff\n2\n2\nQ Cycle Activity:",
    "PIC18F6585/8585/6680/8680\nDecode, Q2 = Read literal 'k' MSB. Decode, Q3 = Process Data. Decode, Q4 = Write literal 'k' MSB to FSRfH. Decode, Q2 = Read literal 'k' LSB. Decode, Q3 = Process Data. Decode, Q4 = Write literal 'k' to FSRfL\nExample:\nLFSR 2, 0x3AB\nAfter Instruction\nFSR2H\n=\n0x03\nFSR2L\n=\n0xAB\nDescription:\nThe contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\nQ Cycle Activity:",
    "PIC18F6585/8585/6680/8680\nQ1\nDecode\n1\nQ2\nRead\nQ3\nProcess register 'f'\nData\nExample:\nMOVF   REG, 0, 0\nBefore Instruction\nREG\n=\n0x22\nW\n=\n0xFF\nAfter Instruction\nREG\n=\n0x22\nW\n=\n0x22\nQ4\nWrite W",
    "PIC18F6585/8585/6680/8680\nSyntax:, Move f to f = [ label ] MOVFF f s ,f d. Syntax:, Move f to f = [ label ] MOVFF f s ,f d. Syntax:, Move f to f = [ label ] MOVFF f s ,f d. Syntax:, Move f to f = [ label ] MOVFF f s ,f d. Operands:, Move f to f = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:, Move f to f = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:, Move f to f = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operands:, Move f to f = 0 \uf0a3 f s \uf0a3 4095 0 \uf0a3 f d \uf0a3 4095. Operation:, Move f to f = (f s ) \uf0ae f d. Operation:, Move f to f = (f s ) \uf0ae f d. Operation:, Move f to f = (f s ) \uf0ae f d. Operation:, Move f to f = (f s ) \uf0ae f d. Status Affected:, Move f to f = None. Status",
    "PIC18F6585/8585/6680/8680\nAffected:, Move f to f = None. Status Affected:, Move f to f = None. Status Affected:, Move f to f = None. Encoding: 1st word (source), Move f to f = 1100. Encoding: 1st word (source), Move f to f = ffff. Encoding: 1st word (source), Move f to f = ffff. Encoding: 1st word (source), Move f to f = ffff s. 2nd word (destin.), Move f to f = 1111. 2nd word (destin.), Move f to f = ffff. 2nd word (destin.), Move f to f = ffff. 2nd word (destin.), Move f to f = ffff d\nDescription:\nThe contents of source register 'f '",
    "PIC18F6585/8585/6680/8680\ns are moved to destination register 'f d '.  Location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W (a useful special situation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register",
    "PIC18F6585/8585/6680/8680\nSyntax:, Move literal to low nibble in BSR = [ label ]. Syntax:, Move literal to low nibble in BSR = MOVLB. Syntax:, Move literal to low nibble in BSR = k. Syntax:, Move literal to low nibble in BSR = . Operands:, Move literal to low nibble in BSR = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to low nibble in BSR = . Operands:, Move literal to low nibble in BSR = . Operands:, Move literal to low nibble in BSR = . Operation:, Move literal to low nibble in BSR = k \uf0ae BSR. Operation:, Move literal to low nibble in BSR = . Operation:, Move literal to low nibble in BSR = . Operation:, Move literal to low nibble in BSR = . Status Affected:, Move literal to low nibble in BSR = None. Status Affected:, Move literal to low nibble in BSR = . Status Affected:, Move literal to low nibble in BSR = . Status Affected:, Move literal to low nibble in",
    "PIC18F6585/8585/6680/8680\nBSR = . Encoding:, Move literal to low nibble in BSR = 0000. Encoding:, Move literal to low nibble in BSR = 0001. Encoding:, Move literal to low nibble in BSR = kkkk. Encoding:, Move literal to low nibble in BSR = kkkk. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move literal to low nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Words:, Move literal to low nibble in BSR = 1. Words:, Move literal to low nibble in BSR = . Words:, Move literal to low",
    "PIC18F6585/8585/6680/8680\nnibble in BSR = . Words:, Move literal to low nibble in BSR = . Cycles:, Move literal to low nibble in BSR = 1. Cycles:, Move literal to low nibble in BSR = . Cycles:, Move literal to low nibble in BSR = . Cycles:, Move literal to low nibble in BSR = . Q Cycle Activity:, Move literal to low nibble in BSR = . Q Cycle Activity:, Move literal to low nibble in BSR = . Q Cycle Activity:, Move literal to low nibble in BSR = . Q Cycle Activity:, Move literal to low nibble in BSR = . Q1, Move literal to low nibble in BSR = Q2. Q1, Move literal to low nibble in BSR = Q3. Q1, Move literal to low nibble in BSR = Q4. Q1, Move literal to low nibble in BSR = Q4. Decode, Move literal to low nibble in BSR = Read literal 'k'. Decode, Move literal to low nibble in BSR = Process Data.",
    "PIC18F6585/8585/6680/8680\nDecode, Move literal to low nibble in BSR = Write literal 'k' to BSR. Decode, Move literal to low nibble in BSR = Write literal 'k' to BSR. Example:, Move literal to low nibble in BSR = MOVLB. Example:, Move literal to low nibble in BSR = 5. Example:, Move literal to low nibble in BSR = . Example:, Move literal to low nibble in BSR = . Before Instruction BSR register, Move literal to low nibble in BSR = =. Before Instruction BSR register, Move literal to low nibble in BSR = 0x02. Before Instruction BSR register, Move literal to low nibble in BSR = . Before Instruction BSR register, Move literal to low nibble in BSR = . After Instruction BSR register, Move literal to low nibble in BSR = =. After Instruction BSR register, Move literal to low nibble in BSR = 0x05. After Instruction BSR register, Move literal to low nibble in BSR = . After Instruction BSR register, Move literal to",
    "PIC18F6585/8585/6680/8680\nlow nibble in BSR = \nWords:\n2\nCycles:\n2 (3)\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode, 1 = Read register 'f' (src). Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f' (dest)",
    "Example:\nMOVFF   REG1, REG2\nBefore Instruction\nREG1\n=\n0x33\nREG2\n=\n0x11\nAfter Instruction\nREG1\n=\n0x33,\nREG2\n=\n0x33",
    "PIC18F6585/8585/6680/8680\nSyntax:, Move literal to W = [ label ]. Syntax:, Move literal to W = MOVLW. Syntax:, Move literal to W = k. Syntax:, Move literal to W = . Operands:, Move literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Move literal to W = 0 \uf0a3 k \uf0a3 255. Operation:, Move literal to W = k \uf0ae W. Operation:, Move literal to W = k \uf0ae W. Operation:, Move literal to W = k \uf0ae W. Operation:, Move literal to W = k \uf0ae W. Status Affected:, Move literal to W = None. Status Affected:, Move literal to W = None. Status Affected:, Move literal to W = None. Status Affected:, Move literal to W = None. Encoding:, Move literal to W = 0000. Encoding:, Move literal to W = 1110. Encoding:, Move literal to W = kkkk kkkk. Encoding:, Move literal to W = . Description:, Move literal to W = The eight-bit",
    "PIC18F6585/8585/6680/8680\nliteral 'k' is loaded into W.. Description:, Move literal to W = The eight-bit literal 'k' is loaded into W.. Description:, Move literal to W = The eight-bit literal 'k' is loaded into W.. Description:, Move literal to W = The eight-bit literal 'k' is loaded into W.. Words:, Move literal to W = 1. Words:, Move literal to W = 1. Words:, Move literal to W = 1. Words:, Move literal to W = 1. Cycles:, Move literal to W = 1. Cycles:, Move literal to W = 1. Cycles:, Move literal to W = 1. Cycles:, Move literal to W = 1. Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q Cycle Activity:, Move literal to W = Q Cycle Activity:. Q1, Move literal to W = Q2. Q1, Move literal to W = Q3. Q1, Move",
    "PIC18F6585/8585/6680/8680\nliteral to W = Q4. Q1, Move literal to W = . Decode, Move literal to W = Read literal 'k'. Decode, Move literal to W = Process Data. Decode, Move literal to W = Write to W. Decode, Move literal to W = . Example:, Move literal to W = MOVLW. Example:, Move literal to W = 0x5A. Example:, Move literal to W = . Example:, Move literal to W = . After Instruction, Move literal to W = After Instruction. After Instruction, Move literal to W = . After Instruction, Move literal to W = . After Instruction, Move literal to W = ",
    "PIC18F6585/8585/6680/8680\nMOVWF, 1 = MOVWF. MOVWF, 2 = Move Wto f. MOVWF, 3 = Move Wto f. MOVWF, 4 = Move Wto f. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] MOVWF f. Syntax:, 3 = [ label ] MOVWF f. Syntax:, 4 = [ label ] MOVWF f. Operands:, 1 = Operands:. Operands:, 2 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, 3 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, 4 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, 1 = Operation:. Operation:, 2 = (W) \uf0ae f. Operation:, 3 = (W) \uf0ae f. Operation:, 4 = (W) \uf0ae f. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = Encoding:. Encoding:, 2 =",
    "PIC18F6585/8585/6680/8680\n0110. Encoding:, 3 = 111a. Encoding:, 4 = ffff. Description:, 1 = Description:. Description:, 2 = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, 3 = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, 4 = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then",
    "PIC18F6585/8585/6680/8680\nthe bank will be selected as per the BSR value (default).. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = Q4. , 1 = Decode. , 2 = Read register 'f'. , 3 = Process Data. , 4 = Write register 'f'",
    "Example:\nMOVWF\nREG, 0\nBefore Instruction\nW\n=\n0x4F\nREG\n=\n0xFF\nAfter Instruction\nW\n=\n0x4F\nREG\n=\n0x4F",
    "PIC18F6585/8585/6680/8680\nSyntax:, Multiply Literal with W = [ label ] MULLW k. Syntax:, Multiply Literal with W = [ label ] MULLW k. Syntax:, Multiply Literal with W = [ label ] MULLW k. Syntax:, Multiply Literal with W = [ label ] MULLW k. Operands:, Multiply Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Multiply Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Multiply Literal with W = 0 \uf0a3 k \uf0a3 255. Operands:, Multiply Literal with W = 0 \uf0a3 k \uf0a3 255. Operation:, Multiply Literal with W = (W) x k \uf0ae PRODH:PRODL. Operation:, Multiply Literal with W = (W) x k \uf0ae PRODH:PRODL. Operation:, Multiply Literal with W = (W) x k \uf0ae PRODH:PRODL. Operation:, Multiply Literal with W = (W) x k \uf0ae PRODH:PRODL. Status Affected:, Multiply Literal with W = None. Status Affected:, Multiply Literal with W = None. Status Affected:, Multiply Literal with W = None. Status",
    "PIC18F6585/8585/6680/8680\nAffected:, Multiply Literal with W = None. Encoding:, Multiply Literal with W = 0000. Encoding:, Multiply Literal with W = 1101. Encoding:, Multiply Literal with W = kkkk. Encoding:, Multiply Literal with W = kkkk. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the",
    "PIC18F6585/8585/6680/8680\ncontents of Wand the 8-bit literal 'k'. The 16-bit result is placed in PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is. Description:, Multiply Literal with W = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is. Words:, Multiply Literal with W = 1. Words:, Multiply Literal with W = 1. Words:, Multiply Literal with W = 1. Words:, Multiply Literal with W = 1. Cycles:, Multiply Literal with W = 1. Cycles:, Multiply Literal with W = 1. Cycles:, Multiply Literal with W = 1. Cycles:, Multiply Literal with W = 1. Q Cycle Activity: Q1,",
    "PIC18F6585/8585/6680/8680\nMultiply Literal with W = Q2. Q Cycle Activity: Q1, Multiply Literal with W = Q3. Q Cycle Activity: Q1, Multiply Literal with W = Q4. Q Cycle Activity: Q1, Multiply Literal with W = Q4. Decode, Multiply Literal with W = Read literal 'k'. Decode, Multiply Literal with W = Process Data. Decode, Multiply Literal with W = . Decode, Multiply Literal with W = Write registers PRODH: PRODL",
    "Example:\nMULLW   0xC4\nBefore Instruction\nW\n=\n0xE2\nPRODH\n=\n?\nPRODL\n=\n?\nAfter Instruction\nW\n=\n0xE2\nPRODH\n=\n0xAD\nPRODL\n=\n0x08",
    "Example:\nSyntax:, Multiply Wwith f = [ label ] MULWF. Syntax:, Multiply Wwith f = [ label ] MULWF. Syntax:, Multiply Wwith f = [ label ] MULWF. Syntax:, Multiply Wwith f = f [,a]. Syntax:, Multiply Wwith f = f [,a]. Operands:, Multiply Wwith f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Multiply Wwith f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Multiply Wwith f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Multiply Wwith f = . Operands:, Multiply Wwith f = . Operation:, Multiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Operation:,",
    "Example:\nMultiply Wwith f = (W) x (f) \uf0ae PRODH:PRODL. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Encoding:, Multiply Wwith f = 0000. Encoding:, Multiply Wwith f = 001a. Encoding:, Multiply Wwith f = ffff. Encoding:, Multiply Wwith f = . Encoding:, Multiply Wwith f = ffff. Description:', Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If",
    "Example:\n'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:', Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:', Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If",
    "Example:\n'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:', Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:', Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wandthe register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note",
    "Example:\nthat neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Q1, Multiply Wwith f = Q2. Q1, Multiply Wwith f = Q2. Q1, Multiply Wwith f = Q3. Q1, Multiply Wwith f = Q3. Q1, Multiply Wwith f = Q4. Decode, Multiply Wwith f = Read register 'f'.",
    "Example:\nDecode, Multiply Wwith f = Read register 'f'. Decode, Multiply Wwith f = Process Data. Decode, Multiply Wwith f = Process Data. Decode, Multiply Wwith f = Write registers PRODH: PRODL. Example: MULWF, Multiply Wwith f = Example: MULWF. Example: MULWF, Multiply Wwith f = REG, 1. Example: MULWF, Multiply Wwith f = REG, 1. Example: MULWF, Multiply Wwith f = REG, 1. Example: MULWF, Multiply Wwith f = REG, 1. Before Instruction, Multiply Wwith f = Before Instruction. Before Instruction, Multiply Wwith f = Before Instruction. Before Instruction, Multiply Wwith f = Before Instruction. Before Instruction, Multiply Wwith f = Before Instruction. Before Instruction, Multiply Wwith f = Before Instruction. W, Multiply Wwith f = =. W, Multiply Wwith f = 0xC4. W, Multiply Wwith f = 0xC4. W, Multiply Wwith f = 0xC4.",
    "Example:\nW, Multiply Wwith f = 0xC4. REG, Multiply Wwith f = =. REG, Multiply Wwith f = 0xB5. REG, Multiply Wwith f = 0xB5. REG, Multiply Wwith f = 0xB5. REG, Multiply Wwith f = 0xB5. PRODH, Multiply Wwith f = =. PRODH, Multiply Wwith f = ? ?. PRODH, Multiply Wwith f = ? ?. PRODH, Multiply Wwith f = ? ?. PRODH, Multiply Wwith f = ? ?. PRODL, Multiply Wwith f = =. PRODL, Multiply Wwith f = . PRODL, Multiply Wwith f = . PRODL, Multiply Wwith f = . PRODL, Multiply Wwith f = . After Instruction W, Multiply Wwith f = = =. After Instruction W, Multiply Wwith f = 0xC4. After Instruction W, Multiply Wwith f = . After Instruction W, Multiply Wwith f = . After Instruction W, Multiply Wwith f = . REG PRODH, Multiply Wwith",
    "Example:\nf = =. REG PRODH, Multiply Wwith f = 0xB5. REG PRODH, Multiply Wwith f = 0xB5. REG PRODH, Multiply Wwith f = 0xB5. REG PRODH, Multiply Wwith f = 0xB5. PRODL, Multiply Wwith f = =. PRODL, Multiply Wwith f = 0x8A 0x94. PRODL, Multiply Wwith f = 0x8A 0x94. PRODL, Multiply Wwith f = 0x8A 0x94. PRODL, Multiply Wwith f = 0x8A 0x94",
    "PIC18F6585/8585/6680/8680\nSyntax:, Negate f = [ label ]. Syntax:, Negate f = NEGF. Syntax:, Negate f = f [,a]. Syntax:, Negate f = . Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Negate f = . Operands:, Negate f = . Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = ( f ) + 1 \uf0ae f. Operation:, Negate f = . Operation:, Negate f = . Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = . Status Affected:, Negate f = . Encoding:, Negate f = 0110. Encoding:, Negate f = 110a. Encoding:, Negate f = ffff. Encoding:, Negate f = ffff. Description:, Negate f",
    "PIC18F6585/8585/6680/8680\n= Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using",
    "PIC18F6585/8585/6680/8680\ntwo's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Negate f = 1. Words:, Negate f = . Words:, Negate f = . Words:, Negate f = . Cycles:, Negate f = 1. Cycles:, Negate f = . Cycles:, Negate f = . Cycles:, Negate f = . Q Cycle Activity:, Negate f = Q Cycle Activity:. Q Cycle Activity:, Negate f = Q Cycle Activity:. Q Cycle Activity:, Negate f = Q Cycle Activity:. Q Cycle Activity:, Negate f = Q Cycle Activity:. Q1, Negate f = Q2. Q1, Negate f = Q3. Q1, Negate f = . Q1, Negate f = Q4. Example:, Negate f = NEGF. Example:, Negate f = REG,.",
    "PIC18F6585/8585/6680/8680\nExample:, Negate f = 1. Example:, Negate f = . Before Instruction REG = After Instruction, Negate f = 0011. Before Instruction REG = After Instruction, Negate f = 1010. Before Instruction REG = After Instruction, Negate f = [0x3A]. Before Instruction REG = After Instruction, Negate f = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Operands:, No Operation = None. Operands:, No Operation = None. Operands:, No Operation = None. Operands:, No Operation = None. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Encoding:, No Operation = 0000 1111. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = No operation..",
    "PIC18F6585/8585/6680/8680\nWords:, No Operation = 1. Words:, No Operation = 1. Words:, No Operation = 1. Words:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Q Cycle Activity:, No Operation = Q Cycle Activity:. Q Cycle Activity:, No Operation = Q Cycle Activity:. Q Cycle Activity:, No Operation = Q Cycle Activity:. Q Cycle Activity:, No Operation = Q Cycle Activity:. Q1, No Operation = Q2. Q1, No Operation = Q3. Q1, No Operation = Q3. Q1, No Operation = Q4. Decode, No Operation = No operation. Decode, No Operation = No operation. Decode, No Operation = No operation. Decode, No Operation = No operation",
    "Example:\nNone.",
    "PIC18F6585/8585/6680/8680\nSyntax:, Pop Top of Return Stack = [ label ] POP. Syntax:, Pop Top of Return Stack = [ label ] POP. Syntax:, Pop Top of Return Stack = [ label ] POP. Syntax:, Pop Top of Return Stack = [ label ] POP. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operation:, Pop Top of Return Stack = (TOS) \uf0ae bit bucket. Operation:, Pop Top of Return Stack = (TOS) \uf0ae bit bucket. Operation:, Pop Top of Return Stack = (TOS) \uf0ae bit bucket. Operation:, Pop Top of Return Stack = (TOS) \uf0ae bit bucket. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return Stack = 0000.",
    "PIC18F6585/8585/6680/8680\nEncoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return Stack = 0110. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed",
    "PIC18F6585/8585/6680/8680\nonto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Q Cycle Activity:, Pop Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Pop Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Pop Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Pop Top of Return Stack = Q Cycle Activity:. Q1, Pop Top of Return Stack = Q2. Q1, Pop Top of Return Stack = Q3. Q1, Pop Top of Return Stack = Q4. Q1, Pop Top of Return Stack = Q4. Decode, Pop Top of Return Stack = No operation. Decode, Pop",
    "PIC18F6585/8585/6680/8680\nTop of Return Stack = POP TOS value. Decode, Pop Top of Return Stack = No operation. Decode, Pop Top of Return Stack = No operation. Example:, Pop Top of Return Stack = POP. Example:, Pop Top of Return Stack = POP. Example:, Pop Top of Return Stack = POP. Example:, Pop Top of Return Stack = POP. Before Instruction TOS Stack, Pop Top of Return Stack = down)=. Before Instruction TOS Stack, Pop Top of Return Stack = 0031A2h 014332h. Before Instruction TOS Stack, Pop Top of Return Stack = . Before Instruction TOS Stack, Pop Top of Return Stack = . After Instruction TOS = PC, Pop Top of Return Stack = After Instruction TOS = PC. After Instruction TOS = PC, Pop Top of Return Stack = 014332h NEW. After Instruction TOS = PC, Pop Top of Return Stack = . After Instruction TOS = PC, Pop Top of Return Stack = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operation:, Push Top of Return Stack = (PC+2) \uf0ae TOS. Operation:, Push Top of Return Stack = (PC+2) \uf0ae TOS. Operation:, Push Top of Return Stack = (PC+2) \uf0ae TOS. Operation:, Push Top of Return Stack = (PC+2) \uf0ae TOS. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack =",
    "PIC18F6585/8585/6680/8680\n0000. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = . Description:, Push Top of Return Stack = The PC+2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implement- ing a software stack by modifying TOS, and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC+2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implement- ing a software stack by modifying TOS, and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC+2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implement- ing a software stack by modifying TOS, and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC+2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implement-",
    "PIC18F6585/8585/6680/8680\ning a software stack by modifying TOS, and then pushing it onto the return stack.. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q1, Push Top of Return Stack = Q2. Q1, Push Top of Return Stack = Q2. Q1, Push Top of Return Stack = Q3. Q1, Push Top of Return Stack = Q4. Decode, Push Top of Return Stack = PUSHPC+2 onto return. Decode, Push Top of Return",
    "PIC18F6585/8585/6680/8680\nStack = PUSHPC+2 onto return. Decode, Push Top of Return Stack = No operation. Decode, Push Top of Return Stack = No operation. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Example:, Push Top of Return Stack = PUSH. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. TOS PC, Push Top of Return Stack = . TOS PC, Push Top of Return Stack = = =. TOS PC, Push Top of Return Stack = 00345Ah 000124h. TOS PC, Push Top of Return Stack = 00345Ah 000124h. After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. After Instruction, Push Top of Return Stack = After Instruction. PC, Push Top of Return Stack",
    "PIC18F6585/8585/6680/8680\n= PC. PC, Push Top of Return Stack = =. PC, Push Top of Return Stack = 000126h. PC, Push Top of Return Stack = 000126h. TOS = Stack (1 level down)=, Push Top of Return Stack = TOS = Stack (1 level down)=. TOS = Stack (1 level down)=, Push Top of Return Stack = . TOS = Stack (1 level down)=, Push Top of Return Stack = 000126h 00345Ah. TOS = Stack (1 level down)=, Push Top of Return Stack = 000126h 00345Ah",
    "PIC18F6585/8585/6680/8680\nSyntax:, Relative Call = [ label ] RCALL n. Syntax:, Relative Call = [ label ] RCALL n. Syntax:, Relative Call = [ label ] RCALL n. Syntax:, Relative Call = [ label ] RCALL n. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operands:, Relative Call = -1024 \uf0a3 n \uf0a3 1023. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Operation:, Relative Call = (PC) + 2 \uf0ae TOS, (PC) + 2 + 2n \uf0ae PC. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None.",
    "PIC18F6585/8585/6680/8680\nEncoding:, Relative Call = 1101. Encoding:, Relative Call = 1nnn. Encoding:, Relative Call = nnnn. Encoding:, Relative Call = nnnn. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC+2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC+2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location.",
    "PIC18F6585/8585/6680/8680\nFirst, return address (PC+2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC+2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC+2+2n. This instruction is a two-cycle instruction.. Words:, Relative Call = 1. Words:, Relative Call = 1. Words:, Relative Call = 1. Words:, Relative Call = 1. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Q Cycle Activity:, Relative Call = . Q Cycle Activity:, Relative Call = . Q Cycle",
    "PIC18F6585/8585/6680/8680\nActivity:, Relative Call = . Q Cycle Activity:, Relative Call = . Q1 Decode, Relative Call = Q2. Q1 Decode, Relative Call = Q3. Q1 Decode, Relative Call = Q3. Q1 Decode, Relative Call = Q4. , Relative Call = Read literal 'n' Push PC to stack. , Relative Call = Process Data. , Relative Call = Process Data. , Relative Call = Write to PC. No operation, Relative Call = No operation. No operation, Relative Call = No operation. No operation, Relative Call = No operation. No operation, Relative Call = No operation",
    "PIC18F6585/8585/6680/8680\nSyntax:, Reset = [ label ] RESET. Syntax:, Reset = [ label ] RESET. Syntax:, Reset = [ label ] RESET. Syntax:, Reset = [ label ] RESET. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Encoding:, Reset = 0000. Encoding:, Reset = 0000. Encoding:, Reset = 1111. Encoding:, Reset = 1111. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This",
    "PIC18F6585/8585/6680/8680\ninstruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q Cycle Activity:, Reset = Q Cycle Activity:. Q1, Reset = Q2. Q1, Reset = Q3. Q1, Reset = Q3. Q1, Reset = Q4. Decode, Reset = Start Reset. Decode, Reset = No operation. Decode, Reset = No operation. Decode, Reset = No operation. Example:, Reset = RESET. Example:, Reset = RESET. Example:, Reset =",
    "PIC18F6585/8585/6680/8680\nRESET. Example:, Reset = RESET. After Instruction, Reset = After Instruction. After Instruction, Reset = After Instruction. After Instruction, Reset = After Instruction. After Instruction, Reset = After Instruction. Registers = Flags* =, Reset = Registers = Flags* =. Registers = Flags* =, Reset = Reset Value Reset Value. Registers = Flags* =, Reset = Reset Value Reset Value. Registers = Flags* =, Reset = Reset Value Reset Value",
    "Example:\nHERE\nRCALL Jump\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nAfter Instruction\nPC =\nAddress\n(Jump)\nTOS=\nAddress\n(HERE+2)",
    "PIC18F6585/8585/6680/8680\nSyntax:, Return from Interrupt = [ label ] RETFIE [s]. Syntax:, Return from Interrupt = [ label ] RETFIE [s]. Syntax:, Return from Interrupt = [ label ] RETFIE [s]. Syntax:, Return from Interrupt = [ label ] RETFIE [s]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operands:, Return from Interrupt = s \uf0ce [0,1]. Operation:, Return from Interrupt = (TOS) \uf0ae PC, 1 \uf0ae GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Interrupt = (TOS) \uf0ae PC, 1 \uf0ae GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Interrupt = (TOS) \uf0ae PC, 1 \uf0ae",
    "PIC18F6585/8585/6680/8680\nGIE/GIEH or PEIE/GIEL, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Interrupt = (TOS) \uf0ae PC, 1 \uf0ae GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0001. Encoding:, Return from Interrupt = 000s. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts",
    "PIC18F6585/8585/6680/8680\nare enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1 , the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1 , the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1 , the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding",
    "PIC18F6585/8585/6680/8680\nregisters, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1 , the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q",
    "PIC18F6585/8585/6680/8680\nCycle Activity:, Return from Interrupt = Q Cycle Activity:. Q1, Return from Interrupt = Q2. Q1, Return from Interrupt = Q3. Q1, Return from Interrupt = . Q1, Return from Interrupt = Q4. Decode, Return from Interrupt = No operation. Decode, Return from Interrupt = operation. Decode, Return from Interrupt = No. Decode, Return from Interrupt = Pop PCfrom stack Set GIEH or GIEL. No operation, Return from Interrupt = . No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation",
    "Example:\nRETFIE  1\nAfter Interrupt\nPC\n=\nTOS\nW\n=\nWS\nBSR\n=\nBSRS\nSTATUS\n=\nSTATUSS\nGIE/GIEH, PEIE/GIEL\n=\n1",
    "Example:\nSyntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operands:, Return Literal to W = 0 \uf0a3 k \uf0a3 255. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \uf0ae W, (TOS) \uf0ae PC, PCLATU, PCLATH are unchanged. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Encoding:, Return Literal to W = 0000. Encoding:, Return Literal to W = 1100. Encoding:, Return Literal to W = kkkk kkkk. Description:, Return Literal to W = Wis loaded with the eight-bit literal",
    "Example:\n'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q1, Return Literal to W = Q2.",
    "Example:\nQ1, Return Literal to W = Q3. Q1, Return Literal to W = Q4. Decode, Return Literal to W = Read literal 'k'. Decode, Return Literal to W = Process Data. Decode, Return Literal to W = Pop PCfrom stack, Write to W. No operation, Return Literal to W = No operation. No operation, Return Literal to W = No operation. No operation, Return Literal to W = No operation\nCALL TABLE\n; W contains table\n; offset value\n; W now has\n; table value\n:\nTABLE\nADDWF PCL\n; W = offset\nRETLW k0\n; Begin table\nRETLW k1\n;\n:\n:\nRETLW kn\n; End of table\nBefore Instruction\nW = 0x07\nAfter Instruction\nW = value of kn",
    "PIC18F6585/8585/6680/8680\nSyntax:, Return from Subroutine = [ label ] RETURN [s]. Syntax:, Return from Subroutine = [ label ] RETURN [s]. Syntax:, Return from Subroutine = [ label ] RETURN [s]. Syntax:, Return from Subroutine = [ label ] RETURN [s]. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operands:, Return from Subroutine = s \uf0ce [0,1]. Operation:, Return from Subroutine = (TOS) \uf0ae PC, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Subroutine = (TOS) \uf0ae PC, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Subroutine = (TOS) \uf0ae PC, if s = 1 (WS) \uf0ae W,",
    "PIC18F6585/8585/6680/8680\n(STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Operation:, Return from Subroutine = (TOS) \uf0ae PC, if s = 1 (WS) \uf0ae W, (STATUSS) \uf0ae STATUS, (BSRS) \uf0ae BSR,. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Encoding:, Return from Subroutine = 0000. Encoding:, Return from Subroutine = 0000. Encoding:, Return from Subroutine = 0001. Encoding:, Return from Subroutine = 001s. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's' = 1 , the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return",
    "PIC18F6585/8585/6680/8680\nfrom Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's' = 1 , the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's' = 1 , the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's' = 1 , the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers, W, Status and",
    "PIC18F6585/8585/6680/8680\nBSR. If 's' = 0 , no update of these registers occurs (default).. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q1, Return from Subroutine = Q2. Q1, Return from Subroutine = Q3. Q1, Return from Subroutine = . Q1, Return from Subroutine = Q4. Decode, Return from Subroutine = . Decode, Return from Subroutine = No operation.",
    "PIC18F6585/8585/6680/8680\nDecode, Return from Subroutine = Process Data. Decode, Return from Subroutine = Pop PC from stack. , Return from Subroutine = No operation. , Return from Subroutine = No operation. , Return from Subroutine = No operation. , Return from Subroutine = No operation\nExample:\nRETURN\nAfter Interrupt\nPC = TOS",
    "PIC18F6585/8585/6680/8680\nSyntax:, Rotate Left f through Carry = [ label ]. Syntax:, Rotate Left f through Carry = RLCF. Syntax:, Rotate Left f through Carry = f [,d [,a]]. Syntax:, Rotate Left f through Carry = f [,d [,a]]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae C, (C) \uf0ae",
    "PIC18F6585/8585/6680/8680\ndest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae C, (C) \uf0ae dest<0>. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Encoding:, Rotate Left f through Carry = 0011. Encoding:, Rotate Left f through Carry = 01da. Encoding:, Rotate Left f through Carry = ffff. Encoding:, Rotate Left f through Carry = ffff. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W.",
    "PIC18F6585/8585/6680/8680\nIf 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back",
    "PIC18F6585/8585/6680/8680\nin register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f",
    "PIC18F6585/8585/6680/8680\nthrough Carry = 1. Cycles:, Rotate Left f through Carry = 1. Q Cycle Activity: Q1, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = . Q Cycle Activity: Q1, Rotate Left f through Carry = . Decode, Rotate Left f through Carry = Q2. Decode, Rotate Left f through Carry = Q3. Decode, Rotate Left f through Carry = Q3. Decode, Rotate Left f through Carry = Q4. , Rotate Left f through Carry = Read register 'f'. , Rotate Left f through Carry = Process Data. , Rotate Left f through Carry = Process Data. , Rotate Left f through Carry = Write to destination. Example: RLCF REG, 0, 0, Rotate Left f through Carry = Example: RLCF REG, 0, 0. Example: RLCF REG, 0, 0, Rotate Left f through Carry = Example: RLCF REG, 0, 0. Example: RLCF REG, 0, 0, Rotate Left f through Carry = Example: RLCF",
    "PIC18F6585/8585/6680/8680\nREG, 0, 0. Example: RLCF REG, 0, 0, Rotate Left f through Carry = Example: RLCF REG, 0, 0. Before Instruction REG C, Rotate Left f through Carry = = 1110 = 0. Before Instruction REG C, Rotate Left f through Carry = 0110. Before Instruction REG C, Rotate Left f through Carry = . Before Instruction REG C, Rotate Left f through Carry = . After Instruction, Rotate Left f through Carry = After Instruction. After Instruction, Rotate Left f through Carry = After Instruction. After Instruction, Rotate Left f through Carry = After Instruction. After Instruction, Rotate Left f through Carry = After Instruction. REG, Rotate Left f through Carry = = 1110. REG, Rotate Left f through Carry = 0110. REG, Rotate Left f through Carry = 0110. REG, Rotate Left f through Carry = 0110. W C, Rotate Left f through Carry = = 1100 = 1. W C, Rotate Left f through Carry = 1100. W C, Rotate Left f through Carry = 1100. W C, Rotate Left f through Carry = 1100",
    "PIC18F6585/8585/6680/8680\nSyntax:, Rotate Left f (no carry) = [ label ]. Syntax:, Rotate Left f (no carry) = RLNCF. Syntax:, Rotate Left f (no carry) = f [,d [,a]]. Syntax:, Rotate Left f (no carry) = f [,d [,a]]. Operands:, Rotate Left f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Left f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Left f (no carry) = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (no carry) = (f<n>) \uf0ae",
    "PIC18F6585/8585/6680/8680\ndest<n+1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (no carry) = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae dest<0>. Operation:, Rotate Left f (no carry) = (f<n>) \uf0ae dest<n+1>, (f<7>) \uf0ae dest<0>. Status Affected:, Rotate Left f (no carry) = N, Z. Status Affected:, Rotate Left f (no carry) = N, Z. Status Affected:, Rotate Left f (no carry) = N, Z. Status Affected:, Rotate Left f (no carry) = N, Z. Encoding:, Rotate Left f (no carry) = 0100. Encoding:, Rotate Left f (no carry) = 01da. Encoding:, Rotate Left f (no carry) = ffff. Encoding:, Rotate Left f (no carry) = ffff. Description:, Rotate Left f (no carry) = The contents of register 'f' are rotated one bit to the left. If",
    "PIC18F6585/8585/6680/8680\n'd' is ' 0 ,' the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f (no carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ,' the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f (no carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ,' the result is placed in",
    "PIC18F6585/8585/6680/8680\nW. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Left f (no carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ,' the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Rotate Left f (no carry) = 1. Words:, Rotate Left f (no carry) = 1. Words:, Rotate Left f (no carry) = 1. Words:, Rotate Left f (no carry) = 1.",
    "PIC18F6585/8585/6680/8680\nCycles:, Rotate Left f (no carry) = 1. Cycles:, Rotate Left f (no carry) = 1. Cycles:, Rotate Left f (no carry) = 1. Cycles:, Rotate Left f (no carry) = 1. Q Cycle Activity:, Rotate Left f (no carry) = . Q Cycle Activity:, Rotate Left f (no carry) = . Q Cycle Activity:, Rotate Left f (no carry) = . Q Cycle Activity:, Rotate Left f (no carry) = . Q1, Rotate Left f (no carry) = Q2. Q1, Rotate Left f (no carry) = Q3. Q1, Rotate Left f (no carry) = . Q1, Rotate Left f (no carry) = Q4. Decode, Rotate Left f (no carry) = Read register 'f'. Decode, Rotate Left f (no carry) = Process Data. Decode, Rotate Left f (no carry) = Write to destination. Decode, Rotate Left f (no carry) = Write to destination. Example: RLNCF REG, 1, 0 Before Instruction, Rotate Left f (no",
    "PIC18F6585/8585/6680/8680\ncarry) = Example: RLNCF REG, 1, 0 Before Instruction. Example: RLNCF REG, 1, 0 Before Instruction, Rotate Left f (no carry) = Example: RLNCF REG, 1, 0 Before Instruction. Example: RLNCF REG, 1, 0 Before Instruction, Rotate Left f (no carry) = Example: RLNCF REG, 1, 0 Before Instruction. Example: RLNCF REG, 1, 0 Before Instruction, Rotate Left f (no carry) = Example: RLNCF REG, 1, 0 Before Instruction. REG, Rotate Left f (no carry) = = 1010. REG, Rotate Left f (no carry) = 1011. REG, Rotate Left f (no carry) = . REG, Rotate Left f (no carry) = . After Instruction REG = 0101 0111, Rotate Left f (no carry) = After Instruction REG = 0101 0111. After Instruction REG = 0101 0111, Rotate Left f (no carry) = After Instruction REG = 0101 0111. After Instruction REG = 0101 0111, Rotate Left f (no carry)",
    "PIC18F6585/8585/6680/8680\n= After Instruction REG = 0101 0111. After Instruction REG = 0101 0111, Rotate Left f (no carry) = After Instruction REG = 0101 0111",
    "PIC18F6585/8585/6680/8680\nSyntax:, Rotate Right f through Carry = [ label ] f. Syntax:, Rotate Right f through Carry = RRCF. Syntax:, Rotate Right f through Carry = [,d. Syntax:, Rotate Right f through Carry = [,a]]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f through Carry = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:,",
    "PIC18F6585/8585/6680/8680\nRotate Right f through Carry = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae C, (C) \uf0ae dest<7>. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 00da. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ',",
    "PIC18F6585/8585/6680/8680\nthe result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f'",
    "PIC18F6585/8585/6680/8680\n(default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through",
    "PIC18F6585/8585/6680/8680\nCarry = 1. Cycles:, Rotate Right f through Carry = 1. Q Cycle Activity: Q1, Rotate Right f through Carry = . Q Cycle Activity: Q1, Rotate Right f through Carry = . Q Cycle Activity: Q1, Rotate Right f through Carry = . Q Cycle Activity: Q1, Rotate Right f through Carry = . Decode, Rotate Right f through Carry = Q2. Decode, Rotate Right f through Carry = Q3. Decode, Rotate Right f through Carry = Q3. Decode, Rotate Right f through Carry = Q4. , Rotate Right f through Carry = Read register 'f'. , Rotate Right f through Carry = Process Data. , Rotate Right f through Carry = Process Data. , Rotate Right f through Carry = Write to destination. Example:, Rotate Right f through Carry = RRCF. Example:, Rotate Right f through Carry = REG,. Example:, Rotate Right f through Carry = 0,. Example:, Rotate Right f through Carry = 0. Before Instruction, Rotate Right f through Carry = Before Instruction. Before Instruction, Rotate Right f through Carry = Before Instruction. Before Instruction, Rotate Right f through",
    "PIC18F6585/8585/6680/8680\nCarry = Before Instruction. Before Instruction, Rotate Right f through Carry = Before Instruction. REG C, Rotate Right f through Carry = = 1110 = 0. REG C, Rotate Right f through Carry = 0110. REG C, Rotate Right f through Carry = . REG C, Rotate Right f through Carry = . W, Rotate Right f through Carry = = 0111. W, Rotate Right f through Carry = 0011. W, Rotate Right f through Carry = . W, Rotate Right f through Carry = . C, Rotate Right f through Carry = = 0. C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . C, Rotate Right f through Carry = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]]. Syntax:, Rotate Right f (no carry) = [ label ] RRNCF f [,d [,a]]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce",
    "PIC18F6585/8585/6680/8680\n[0,1]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Rotate Right f (no carry) = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate",
    "PIC18F6585/8585/6680/8680\nRight f (no carry) = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \uf0ae dest<n-1>, (f<0>) \uf0ae dest<7>. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Encoding:, Rotate Right f (no carry) = 0100. Encoding:, Rotate Right f (no carry) = 0100. Encoding:, Rotate Right f (no carry) = 00da. Encoding:, Rotate Right f (no carry) = 00da. Encoding:, Rotate Right f (no carry) = ffff. Encoding:, Rotate Right f",
    "PIC18F6585/8585/6680/8680\n(no carry) = ffff. Description:', Rotate Right f (no carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:', Rotate Right f (no carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:',",
    "PIC18F6585/8585/6680/8680\nRotate Right f (no carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:', Rotate Right f (no carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:', Rotate Right f (no carry) = The contents of register",
    "PIC18F6585/8585/6680/8680\n'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:', Rotate Right f (no carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Rotate Right f (no carry) = 1. Words:, Rotate Right f (no carry) = 1.",
    "PIC18F6585/8585/6680/8680\nWords:, Rotate Right f (no carry) = 1. Words:, Rotate Right f (no carry) = 1. Words:, Rotate Right f (no carry) = 1. Words:, Rotate Right f (no carry) = 1. Cycles:, Rotate Right f (no carry) = 1. Cycles:, Rotate Right f (no carry) = 1. Cycles:, Rotate Right f (no carry) = 1. Cycles:, Rotate Right f (no carry) = 1. Cycles:, Rotate Right f (no carry) = 1. Cycles:, Rotate Right f (no carry) = 1. Q Cycle, Rotate Right f (no carry) = . Q Cycle, Rotate Right f (no carry) = . Q Cycle, Rotate Right f (no carry) = . Q Cycle, Rotate Right f (no carry) = . Q Cycle, Rotate Right f (no carry) = . Q Cycle, Rotate Right f (no carry) = . Activity: Q1, Rotate Right f (no carry) = Q2. Activity: Q1, Rotate Right f (no carry) = Q2. Activity: Q1, Rotate Right f",
    "PIC18F6585/8585/6680/8680\n(no carry) = Q2. Activity: Q1, Rotate Right f (no carry) = Q3. Activity: Q1, Rotate Right f (no carry) = Q3. Activity: Q1, Rotate Right f (no carry) = Q4. Decode, Rotate Right f (no carry) = Read register 'f'. Decode, Rotate Right f (no carry) = Read register 'f'. Decode, Rotate Right f (no carry) = Read register 'f'. Decode, Rotate Right f (no carry) = Process Data. Decode, Rotate Right f (no carry) = Process Data. Decode, Rotate Right f (no carry) = Write to destination. Example 1:, Rotate Right f (no carry) = RRNCF. Example 1:, Rotate Right f (no carry) = RRNCF. Example 1:, Rotate Right f (no carry) = REG,. Example 1:, Rotate Right f (no carry) = 1,. Example 1:, Rotate Right f (no carry) = 0. Example 1:, Rotate Right f (no carry) = . Before Instruction",
    "PIC18F6585/8585/6680/8680\nREG, Rotate Right f (no carry) = Before Instruction REG. Before Instruction REG, Rotate Right f (no carry) = Before Instruction REG. Before Instruction REG, Rotate Right f (no carry) = Before Instruction REG. Before Instruction REG, Rotate Right f (no carry) = Before Instruction REG. Before Instruction REG, Rotate Right f (no carry) = Before Instruction REG. Before Instruction REG, Rotate Right f (no carry) = Before Instruction REG. , Rotate Right f (no carry) = =. , Rotate Right f (no carry) = 1101 1110. , Rotate Right f (no carry) = 0111 1011. , Rotate Right f (no carry) = . , Rotate Right f (no carry) = . , Rotate Right f (no carry) = . After Instruction REG =, Rotate Right f (no carry) = After Instruction REG =. After Instruction REG =, Rotate Right f (no carry) = After Instruction REG =. After Instruction REG =, Rotate Right f (no carry) = After Instruction REG =. After Instruction REG =, Rotate Right f (no carry) = After Instruction REG =. After Instruction REG =, Rotate Right",
    "PIC18F6585/8585/6680/8680\nf (no carry) = After Instruction REG =. After Instruction REG =, Rotate Right f (no carry) = After Instruction REG =. Example 2:, Rotate Right f (no carry) = . Example 2:, Rotate Right f (no carry) = RRNCF. Example 2:, Rotate Right f (no carry) = REG,. Example 2:, Rotate Right f (no carry) = . Example 2:, Rotate Right f (no carry) = 0, 0. Example 2:, Rotate Right f (no carry) = . Before Instruction, Rotate Right f (no carry) = Before Instruction. Before Instruction, Rotate Right f (no carry) = Before Instruction. Before Instruction, Rotate Right f (no carry) = Before Instruction. Before Instruction, Rotate Right f (no carry) = Before Instruction. Before Instruction, Rotate Right f (no carry) = Before Instruction. Before Instruction, Rotate Right f (no carry) = Before Instruction. W REG, Rotate Right f (no carry) = = =. W REG, Rotate Right f (no carry) = ? 1101. W REG, Rotate Right f (no carry) = 0111.",
    "PIC18F6585/8585/6680/8680\nW REG, Rotate Right f (no carry) = . W REG, Rotate Right f (no carry) = . W REG, Rotate Right f (no carry) = . After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. After Instruction, Rotate Right f (no carry) = After Instruction. W, Rotate Right f (no carry) = =. W, Rotate Right f (no carry) = 1110. W, Rotate Right f (no carry) = 1011. W, Rotate Right f (no carry) = . W, Rotate Right f (no carry) = . W, Rotate Right f (no carry) = . REG, Rotate Right f (no carry) = =. REG, Rotate Right f (no carry) = 1101 0111. REG, Rotate Right f (no carry) = . REG, Rotate Right f (no carry) = . REG,",
    "PIC18F6585/8585/6680/8680\nRotate Right f (no carry) = . REG, Rotate Right f (no carry) = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, Set f = [ label ] SETF f. Syntax:, Set f = [,a]. Syntax:, Set f = . Operands:, Set f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Set f = 0 \uf0a3 f \uf0a3 255 a \uf0ce\uf020 [0,1]. Operands:, Set f = . Operation:, Set f = FFh \uf0ae f. Operation:, Set f = FFh \uf0ae f. Operation:, Set f = . Status Affected:, Set f = None. Status Affected:, Set f = None. Status Affected:, Set f = . Encoding:, Set f = 0110. Encoding:, Set f = 100a. Encoding:, Set f = ffff. Description:, Set f = The contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Set f = The contents of the specified register are set to FFh. If 'a'",
    "PIC18F6585/8585/6680/8680\nis ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Set f = The contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Set f = 1. Words:, Set f = 1. Words:, Set f = . Cycles:, Set f = 1. Cycles:, Set f = 1. Cycles:, Set f = . Q Cycle Activity:, Set f = . Q Cycle Activity:, Set f = . Q Cycle Activity:, Set f = . Q1, Set f = Q2. Q1, Set f = Q3. Q1, Set f = Q4. Decode, Set f = register. Decode, Set f = Read 'f' Process Data. Decode, Set f = Write register",
    "PIC18F6585/8585/6680/8680\n'f'. , Set f = SETF. , Set f = . , Set f = . Example:, Set f = . Example:, Set f = . Example:, Set f = . Instruction REG, Set f = . Instruction REG, Set f = . Instruction REG, Set f = . REG, Set f = =. REG, Set f = . REG, Set f = . , Set f = . , Set f = 0xFF. , Set f = . After, Set f = . After, Set f = . After, Set f = . , Set f = =. , Set f = . , Set f = . Before, Set f = . Before, Set f = . Before, Set f = . , Set f = . , Set f = 0x5A. , Set f = . Instruction, Set f = Instruction. Instruction, Set f = Instruction. Instruction, Set f = Instruction",
    "PIC18F6585/8585/6680/8680\nSLEEP, 1 = 0000. SLEEP, 2 = 0000. SLEEP, 3 = 0000. SLEEP, 4 = 0000. 0000, 1 = 0011. 0000, 2 = 0011. 0000, 3 = 0011. 0000, 4 = 0011. Description:, 1 = Description:. Description:, 2 = . Description:, 3 = . Description:, 4 = . Q2, 1 = Q3. Q2, 2 = Q3. Q2, 3 = Q3. Q2, 4 = Q3. , 1 = Q4. , 2 = Q4. , 3 = Q4. , 4 = Q4. , 1 = Decode. , 2 = No operation. , 3 = Process Data. , 4 = . Go to SLEEP, 1 = Go to SLEEP. Go to SLEEP, 2 = . Go to SLEEP, 3 = . Go to SLEEP, 4 = ",
    "Example:\nSLEEP\nBefore Instruction\nTO\n=\n?\nPD\n=\n?\nAfter Instruction\nTO\n=\n1 \u2020\nPD\n=\n0\n- \u2020   If WDT causes wake-up, this bit is cleared.",
    "Example:\nSyntax:, Subtract f from Wwith borrow = [ label ] SUBFWB. Syntax:, Subtract f from Wwith borrow = [ label ] SUBFWB. Syntax:, Subtract f from Wwith borrow = [ label ] SUBFWB. Syntax:, Subtract f from Wwith borrow = f [,d [,a]]. Syntax:, Subtract f from Wwith borrow = f [,d [,a]]. Operands:, Subtract f from Wwith borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from Wwith borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from Wwith borrow = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract f from Wwith borrow = . Operands:, Subtract f from Wwith borrow = . Operation:, Subtract f from Wwith borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from",
    "Example:\nWwith borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from Wwith borrow = (W) - (f) - (C) \uf0ae\uf020 dest. Operation:, Subtract f from Wwith borrow = . Operation:, Subtract f from Wwith borrow = . Status Affected:, Subtract f from Wwith borrow = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith borrow = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith borrow = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith borrow = . Status Affected:, Subtract f from Wwith borrow = . Encoding:, Subtract f from Wwith borrow = 0101. Encoding:, Subtract f from Wwith borrow = 01da. Encoding:, Subtract f from Wwith borrow = ffff. Encoding:, Subtract f from Wwith borrow = ffff. Encoding:, Subtract f from Wwith borrow = ffff. Description:, Subtract f from",
    "Example:\nWwith borrow = Subtract register 'f' and carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value. Description:, Subtract f from Wwith borrow = Subtract register 'f' and carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value. Description:, Subtract f from Wwith borrow = Subtract register 'f' and carry flag (borrow) from",
    "Example:\nW(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value. Description:, Subtract f from Wwith borrow = Subtract register 'f' and carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value. Description:, Subtract f from Wwith borrow = Subtract register 'f' and carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ',",
    "Example:\nthe result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value. Words:, Subtract f from Wwith borrow = 1. Words:, Subtract f from Wwith borrow = 1. Words:, Subtract f from Wwith borrow = 1. Words:, Subtract f from Wwith borrow = . Words:, Subtract f from Wwith borrow = . Cycles:, Subtract f from Wwith borrow = 1. Cycles:, Subtract f from Wwith borrow = 1. Cycles:, Subtract f from Wwith borrow = 1. Cycles:, Subtract f from Wwith borrow = . Cycles:, Subtract f from Wwith borrow = . Q Cycle Activity:, Subtract f from Wwith borrow = Q Cycle Activity:. Q Cycle Activity:, Subtract f from Wwith borrow = Q Cycle Activity:. Q Cycle Activity:,",
    "Example:\nSubtract f from Wwith borrow = Q Cycle Activity:. Q Cycle Activity:, Subtract f from Wwith borrow = . Q Cycle Activity:, Subtract f from Wwith borrow = . Q1, Subtract f from Wwith borrow = Q2 Q3. Q1, Subtract f from Wwith borrow = Q2 Q3. Q1, Subtract f from Wwith borrow = Q2 Q3. Q1, Subtract f from Wwith borrow = . Q1, Subtract f from Wwith borrow = . Decode, Subtract f from Wwith borrow = Read. Decode, Subtract f from Wwith borrow = . Decode, Subtract f from Wwith borrow = Process. Decode, Subtract f from Wwith borrow = Q4. Decode, Subtract f from Wwith borrow = Q4. Example 1:, Subtract f from Wwith borrow = . Example 1:, Subtract f from Wwith borrow = . Example 1:, Subtract f from Wwith borrow = 0. Example 1:, Subtract f from Wwith borrow = Write to destination. Example",
    "Example:\n1:, Subtract f from Wwith borrow = Write to destination. , Subtract f from Wwith borrow = SUBFWB REG, 1,. , Subtract f from Wwith borrow = SUBFWB REG, 1,. , Subtract f from Wwith borrow = SUBFWB REG, 1,. , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = 3. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . W",
    "Example:\nC, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = 2 1. , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . , Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = After Instruction. After Instruction, Subtract f from Wwith borrow = . After Instruction, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = FF. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = 2 0. W, Subtract f from Wwith borrow = .",
    "Example:\nW, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = 0. C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = result is. N, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = . Example 2:, Subtract f from Wwith borrow = 1 ; negative SUBFWB REG, 0, 0. Example 2:, Subtract f from",
    "Example:\nWwith borrow = 1 ; negative SUBFWB REG, 0, 0. Example 2:, Subtract f from Wwith borrow = 1 ; negative SUBFWB REG, 0, 0. Example 2:, Subtract f from Wwith borrow = . Example 2:, Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = 2 5. W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W,",
    "Example:\nSubtract f from Wwith borrow = . C, Subtract f from Wwith borrow = 1. C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . = After Instruction, Subtract f from Wwith borrow = = After Instruction. = After Instruction, Subtract f from Wwith borrow = = After Instruction. = After Instruction, Subtract f from Wwith borrow = = After Instruction. = After Instruction, Subtract f from Wwith borrow = . = After Instruction, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = 2. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = 3. W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f",
    "Example:\nfrom Wwith borrow = . W, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = 1 0. C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = 0 ;. N, Subtract f from Wwith borrow = result is. N, Subtract f from Wwith borrow = positive. N, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = . Example 3: SUBFWB REG, 1, 0, Subtract f from Wwith borrow = Example 3: SUBFWB REG, 1, 0. Example 3: SUBFWB REG, 1, 0,",
    "Example:\nSubtract f from Wwith borrow = Example 3: SUBFWB REG, 1, 0. Example 3: SUBFWB REG, 1, 0, Subtract f from Wwith borrow = Example 3: SUBFWB REG, 1, 0. Example 3: SUBFWB REG, 1, 0, Subtract f from Wwith borrow = . Example 3: SUBFWB REG, 1, 0, Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = Before Instruction. Before Instruction, Subtract f from Wwith borrow = . Before Instruction, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = 1. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = 2. W, Subtract f",
    "Example:\nfrom Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . W, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . C, Subtract f from Wwith borrow = . = 0 After Instruction, Subtract f from Wwith borrow = = 0 After Instruction. = 0 After Instruction, Subtract f from Wwith borrow = = 0 After Instruction. = 0 After Instruction, Subtract f from Wwith borrow = = 0 After Instruction. = 0 After Instruction, Subtract f from Wwith borrow = . = 0 After Instruction, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = 0. REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . REG, Subtract f from Wwith borrow = . W C,",
    "Example:\nSubtract f from Wwith borrow = 2. W C, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . W C, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = 1 ;. Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . Z, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = 1 0. N, Subtract f from Wwith borrow = result is. N, Subtract f from Wwith borrow = zero. N, Subtract f from Wwith borrow = . N, Subtract f from Wwith borrow = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, SUBLW = Syntax:. Syntax:, Subtract Wfrom literal = [ label ]. Syntax:,  = SUBLW k. Syntax:,  = SUBLW k. Syntax:,  = SUBLW k. Operands:, SUBLW = Operands:. Operands:, Subtract Wfrom literal = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:,  = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:,  = . Operands:,  = . Operation:, SUBLW = Operation:. Operation:, Subtract Wfrom literal = k - (W). Operation:,  = \uf0ae\uf020 W. Operation:,  = \uf0ae\uf020 W. Operation:,  = \uf0ae\uf020 W. Status Affected:, SUBLW = Status Affected:. Status Affected:, Subtract Wfrom literal = N, OV, C, DC,. Status Affected:,  = Z. Status Affected:,  = Z. Status Affected:,  = Z. Encoding:, SUBLW = Encoding:. Encoding:, Subtract Wfrom literal = 0000. Encoding:,  = kkkk. Encoding:,",
    "PIC18F6585/8585/6680/8680\n= kkkk. Encoding:,  = kkkk. Description:, SUBLW = Description:. Description:, Subtract Wfrom literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:,  = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:,  = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:,  = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Words:, SUBLW = Words:. Words:, Subtract Wfrom literal = 1. Words:,  = 1. Words:,  = . Words:,  = . Cycles:, SUBLW = Cycles:. Cycles:, Subtract Wfrom literal = 1. Cycles:,  = 1. Cycles:,  = . Cycles:,",
    "PIC18F6585/8585/6680/8680\n= . Q Cycle Activity:, SUBLW = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom literal = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . , SUBLW = Q1. , Subtract Wfrom literal = Q2. ,  = Q3. ,  = Q4. ,  = Q4. , SUBLW = Decode. , Subtract Wfrom literal = Read literal 'k'. ,  = Process Data. ,  = Write to W. ,  = Write to W. Example 1:, SUBLW = Example 1:. Example 1:, Subtract Wfrom literal = SUBLW. Example 1:,  = 0x02. Example 1:,  = 0x02. Example 1:,  = 0x02. Before, SUBLW = Before. Before, Subtract Wfrom literal = Instruction. Before,  = Instruction. Before,  = . Before,  = . W, SUBLW = = =. W, Subtract Wfrom literal = 1. W,",
    "PIC18F6585/8585/6680/8680\n= 1. W,  = . W,  = . C, SUBLW = . C, Subtract Wfrom literal = ?. C,  = ?. C,  = . C,  = . After Instruction, SUBLW = After Instruction. After Instruction, Subtract Wfrom literal = 1. After Instruction,  = 1. After Instruction,  = . After Instruction,  = . W, SUBLW = = =. W, Subtract Wfrom literal = 1 ; result. W,  = is positive. W,  = is positive. W,  = is positive. C Z, SUBLW = =. C Z, Subtract Wfrom literal = . C Z,  = . C Z,  = . C Z,  = . , SUBLW = . , Subtract Wfrom literal = 0. ,  = 0. ,  = . ,  = . N, SUBLW = =. N, Subtract Wfrom literal = 0. N,  = 0. N,  = . N,",
    "PIC18F6585/8585/6680/8680\n= . Example, SUBLW = Example. Example, Subtract Wfrom literal = 0x02. Example,  = 0x02. Example,  = . Example,  = . 2: Before, SUBLW = 2: Before. 2: Before, Subtract Wfrom literal = SUBLW Instruction. 2: Before,  = SUBLW Instruction. 2: Before,  = . 2: Before,  = . W C, SUBLW = = =. W C, Subtract Wfrom literal = 2. W C,  = 2. W C,  = . W C,  = . , SUBLW = . , Subtract Wfrom literal = ?. ,  = ?. ,  = . ,  = . After Instruction, SUBLW = After Instruction. After Instruction, Subtract Wfrom literal = . After Instruction,  = . After Instruction,  = . After Instruction,  = . W, SUBLW = =. W, Subtract Wfrom literal = 0 1 ; result is. W,  = 0 1 ; result is. W,  = . W,",
    "PIC18F6585/8585/6680/8680\n= . C Z, SUBLW = =. C Z, Subtract Wfrom literal = . C Z,  = zero. C Z,  = zero. C Z,  = zero. , SUBLW = =. , Subtract Wfrom literal = 1 0. ,  = 1 0. ,  = . ,  = . N = Example 3:, SUBLW = N = Example 3:. N = Example 3:, Subtract Wfrom literal = . N = Example 3:,  = 0x02. N = Example 3:,  = 0x02. N = Example 3:,  = 0x02. , SUBLW = . , Subtract Wfrom literal = SUBLW. ,  = SUBLW. ,  = . ,  = . Before W =, SUBLW = Before W =. Before W =, Subtract Wfrom literal = . Before W =,  = . Before W =,  = . Before W =,  = . After Instruction, SUBLW = After Instruction. After Instruction, Subtract Wfrom literal = ?. After Instruction,",
    "PIC18F6585/8585/6680/8680\n= ?. After Instruction,  = . After Instruction,  = . , SUBLW = . , Subtract Wfrom literal = FF ; (2's. ,  = FF ; (2's. ,  = . ,  = . , SUBLW = . , Subtract Wfrom literal = 0 ; result. ,  = 0 ; result. ,  = . ,  = . W C Z, SUBLW = = = =. W C Z, Subtract Wfrom literal = . W C Z,  = . W C Z,  = . W C Z,  = . N, SUBLW = =. N, Subtract Wfrom literal = 1. N,  = 1. N,  = . N,  = . , SUBLW = . , Subtract Wfrom literal = 3 0. ,  = negative. ,  = negative. ,  = negative. , SUBLW = . , Subtract Wfrom literal = Instruction. ,  = complement) is. ,  = complement) is. ,  = complement) is",
    "PIC18F6585/8585/6680/8680\nSyntax:, Subtract Wfrom f = [ label ] SUBWF. Syntax:, Subtract Wfrom f = [ label ] SUBWF. Syntax:, Subtract Wfrom f = [ label ] SUBWF. Syntax:, Subtract Wfrom f = f [,d [,a]]. Syntax:, Subtract Wfrom f = f [,d [,a]]. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f = 0 \uf0a3\uf020 f \uf0a3\uf020 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Subtract Wfrom f = . Operands:, Subtract Wfrom f = . Operation:, Subtract Wfrom f = (f) - (W) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f = (f) -",
    "PIC18F6585/8585/6680/8680\n(W) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f = (f) - (W) \uf0ae\uf020 dest. Operation:, Subtract Wfrom f = . Operation:, Subtract Wfrom f = . Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = . Status Affected:, Subtract Wfrom f = . Encoding:, Subtract Wfrom f = 0101. Encoding:, Subtract Wfrom f = 11da. Encoding:, Subtract Wfrom f = ffff. Encoding:, Subtract Wfrom f = ffff. Encoding:, Subtract Wfrom f = ffff. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement",
    "PIC18F6585/8585/6680/8680\nmethod). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is",
    "PIC18F6585/8585/6680/8680\n' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored",
    "PIC18F6585/8585/6680/8680\nin W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Q Cycle Activity:, Subtract Wfrom f = . Q Cycle Activity:, Subtract Wfrom f = . Q Cycle Activity:, Subtract",
    "PIC18F6585/8585/6680/8680\nWfrom f = . Q Cycle Activity:, Subtract Wfrom f = . Q Cycle Activity:, Subtract Wfrom f = . Q1, Subtract Wfrom f = Q2. Q1, Subtract Wfrom f = Q2. Q1, Subtract Wfrom f = Q3. Q1, Subtract Wfrom f = Q3. Q1, Subtract Wfrom f = Q4. Decode, Subtract Wfrom f = Read register 'f'. Decode, Subtract Wfrom f = Read register 'f'. Decode, Subtract Wfrom f = Process Data. Decode, Subtract Wfrom f = Process Data. Decode, Subtract Wfrom f = Write to destination. Example 1:, Subtract Wfrom f = SUBWF. Example 1:, Subtract Wfrom f = SUBWF. Example 1:, Subtract Wfrom f = REG, 1,. Example 1:, Subtract Wfrom f =",
    "PIC18F6585/8585/6680/8680\n0. Example 1:, Subtract Wfrom f = . Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. REG, Subtract Wfrom f = =. REG, Subtract Wfrom f = 3. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W, Subtract Wfrom f = =. W, Subtract Wfrom f = 2. W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = =. C, Subtract Wfrom f = ?. C, Subtract Wfrom f = . C, Subtract Wfrom",
    "PIC18F6585/8585/6680/8680\nf = . C, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. REG, Subtract Wfrom f = =. REG, Subtract Wfrom f = 1. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W, Subtract Wfrom f = =. W, Subtract Wfrom f = 2. W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . C Z, Subtract Wfrom f = =. C Z, Subtract Wfrom f = 1 0. C Z, Subtract Wfrom f = ; result is. C",
    "PIC18F6585/8585/6680/8680\nZ, Subtract Wfrom f = positive. C Z, Subtract Wfrom f = . N, Subtract Wfrom f = =. N, Subtract Wfrom f = 0. N, Subtract Wfrom f = . N, Subtract Wfrom f = . N, Subtract Wfrom f = . , Subtract Wfrom f = =. , Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = . , Subtract Wfrom f = . Example 2:, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = . SUBWF, Subtract Wfrom f = SUBWF. SUBWF, Subtract Wfrom f = SUBWF. SUBWF, Subtract Wfrom f =",
    "PIC18F6585/8585/6680/8680\nREG,. SUBWF, Subtract Wfrom f = 0, 0. SUBWF, Subtract Wfrom f = . Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. REG, Subtract Wfrom f = =. REG, Subtract Wfrom f = 2. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W, Subtract Wfrom f = =. W, Subtract Wfrom f = 2. W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = =. C, Subtract Wfrom f = ?. C,",
    "PIC18F6585/8585/6680/8680\nSubtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. REG, Subtract Wfrom f = =. REG, Subtract Wfrom f = 2. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W C, Subtract Wfrom f = =. W C, Subtract Wfrom f = 0 1. W C, Subtract Wfrom f = result is zero. W C, Subtract Wfrom f = . W C, Subtract Wfrom f = . Z, Subtract Wfrom f = = =. Z, Subtract",
    "PIC18F6585/8585/6680/8680\nWfrom f = ; 1. Z, Subtract Wfrom f = . Z, Subtract Wfrom f = . Z, Subtract Wfrom f = . N, Subtract Wfrom f = =. N, Subtract Wfrom f = 0. N, Subtract Wfrom f = . N, Subtract Wfrom f = . N, Subtract Wfrom f = . Example 3: SUBWF REG, 1, 0, Subtract Wfrom f = Example 3: SUBWF REG, 1, 0. Example 3: SUBWF REG, 1, 0, Subtract Wfrom f = Example 3: SUBWF REG, 1, 0. Example 3: SUBWF REG, 1, 0, Subtract Wfrom f = Example 3: SUBWF REG, 1, 0. Example 3: SUBWF REG, 1, 0, Subtract Wfrom f = Example 3: SUBWF REG, 1, 0. Example 3: SUBWF REG, 1, 0, Subtract",
    "PIC18F6585/8585/6680/8680\nWfrom f = Example 3: SUBWF REG, 1, 0. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. REG, Subtract Wfrom f = =. REG, Subtract Wfrom f = 1. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W, Subtract Wfrom f = =. W, Subtract Wfrom f = 2. W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = =. C, Subtract Wfrom f = ?. C, Subtract Wfrom f = . C, Subtract",
    "PIC18F6585/8585/6680/8680\nWfrom f = . C, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. After Instruction, Subtract Wfrom f = After Instruction. REG, Subtract Wfrom f = =. REG, Subtract Wfrom f = FFh. REG, Subtract Wfrom f = ;(2's complement). REG, Subtract Wfrom f = ;(2's complement). REG, Subtract Wfrom f = . W C, Subtract Wfrom f = =. W C, Subtract Wfrom f = 2. W C, Subtract Wfrom f = . W C, Subtract Wfrom f = . W C, Subtract Wfrom f = . Z, Subtract Wfrom f = = =. Z, Subtract Wfrom",
    "PIC18F6585/8585/6680/8680\nf = 0 ; 0. Z, Subtract Wfrom f = result is. Z, Subtract Wfrom f = negative. Z, Subtract Wfrom f = . N, Subtract Wfrom f = =. N, Subtract Wfrom f = 1. N, Subtract Wfrom f = . N, Subtract Wfrom f = . N, Subtract Wfrom f = ",
    "PIC18F6585/8585/6680/8680\nSyntax:, Subtract Wfrom f with Borrow = [ label ] SUBWFB f. Syntax:,  = . Syntax:,  = . Syntax:,  = [,a]]. Syntax:,  = . Syntax:,  = . Syntax:,  = . Syntax:,  = . Syntax:,  = [,d. Operands:, Subtract Wfrom f with Borrow = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:,  = . Operands:,  = . Operands:,  = . Operands:,  = . Operands:,  = . Operands:,  = . Operands:,  = . Operands:,  = . Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \uf0ae\uf020 dest. Operation:,  = . Operation:,  = . Operation:,  = . Operation:,  = . Operation:,  = . Operation:,  = . Operation:,  = . Operation:,",
    "PIC18F6585/8585/6680/8680\n= . Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Encoding:, Subtract Wfrom f with Borrow = 0101. Encoding:,  = 10da. Encoding:,  = ffff. Encoding:,  = ffff. Encoding:,  = . Encoding:,  = . Encoding:,  = . Encoding:,  = . Encoding:,",
    "PIC18F6585/8585/6680/8680\n= . Description:, Subtract Wfrom f with Borrow = Subtract Wandthe Carry flag (bor- row) from register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSRvalue. If 'a' is ' 1 ', then the bank will be selected as per the BSR value. Description:,  = . Description:,  = . Description:,  = . Description:,  = . Description:,  = . Description:,  = . Description:,  = . Description:,  = . Words:, Subtract Wfrom f with Borrow = 1. Words:,  = . Words:,  = . Words:,  = . Words:,  = . Words:,  = . Words:,  = . Words:,  = . Words:,  = . Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:,",
    "PIC18F6585/8585/6680/8680\n= . Cycles:,  = . Cycles:,  = . Cycles:,  = . Cycles:,  = . Cycles:,  = . Cycles:,  = . Cycles:,  = . Q Cycle Activity:, Subtract Wfrom f with Borrow = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q1, Subtract Wfrom f with Borrow = Q2 Q3. Q1,  = . Q1,  = . Q1,  = Q4. Q1,  = . Q1,  = . Q1,  = . Q1,  = . Q1,  = . Decode, Subtract Wfrom f with Borrow = Read Process. Decode,  = . Decode,  = . Decode,  = Write to. Decode,  = . Decode,  = . Decode,  = . Decode,  = . Decode,",
    "PIC18F6585/8585/6680/8680\n= . Example 1:, Subtract Wfrom f with Borrow = SUBWFB REG, 1,. Example 1:,  = . Example 1:,  = . Example 1:,  = . Example 1:,  = . Example 1:,  = . Example 1:,  = . Example 1:,  = . Example 1:,  = 0. Before Instruction, Subtract Wfrom f with Borrow = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . REG, Subtract Wfrom f with Borrow = =. REG,  = 0x19. REG,  = (0001 1001) 1101). REG,  = . REG,  = . REG,  = . REG,  = . REG,  = . REG,  = . W C, Subtract Wfrom f with Borrow = =. W C,  = 0x0D. W C,  = (0000. W C,  = . W C,  = . W C,  = . W C,  = . W C,",
    "PIC18F6585/8585/6680/8680\n= . W C,  = . , Subtract Wfrom f with Borrow = =. ,  = 1. ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . After Instruction, Subtract Wfrom f with Borrow = . After Instruction,  = . After Instruction,  = . After Instruction,  = . After Instruction,  = . After Instruction,  = . After Instruction,  = . After Instruction,  = . After Instruction,  = . REG, Subtract Wfrom f with Borrow = =. REG,  = 0x0C. REG,  = (0000. REG,  = . REG,  = . REG,  = . REG,  = . REG,  = . REG,  = 1011). W, Subtract Wfrom f with Borrow = =. W,  = 0x0D. W,  = (0000. W,  = . W,  = . W,  = . W,  = . W,  = . W,  = 1101). C Z, Subtract Wfrom f with Borrow = = =. C Z,  = 1 0. C Z,  = . C Z,",
    "PIC18F6585/8585/6680/8680\n= . C Z,  = . C Z,  = . C Z,  = . C Z,  = . C Z,  = . N, Subtract Wfrom f with Borrow = =. N,  = 0. N,  = ; result. N,  = . N,  = . N,  = . N,  = . N,  = . N,  = . Example, Subtract Wfrom f with Borrow = . Example,  = . Example,  = is positive. Example,  = . Example,  = . Example,  = . Example,  = . Example,  = . Example,  = 0. 2: SUBWFB, Subtract Wfrom f with Borrow = . 2: SUBWFB,  = . 2: SUBWFB,  = REG, 0,. 2: SUBWFB,  = . 2: SUBWFB,  = . 2: SUBWFB,  = . 2: SUBWFB,  = . 2: SUBWFB,  = . 2: SUBWFB,  = . Before Instruction, Subtract Wfrom f with Borrow = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,",
    "PIC18F6585/8585/6680/8680\n= . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . REG, Subtract Wfrom f with Borrow = =. REG,  = 0x1B. REG,  = (0001 1011) (0001 1010). REG,  = . REG,  = . REG,  = . REG,  = . REG,  = . REG,  = . W C, Subtract Wfrom f with Borrow = = =. W C,  = 0x1A 0. W C,  = . W C,  = . W C,  = . W C,  = . W C,  = . W C,  = . W C,  = . After Instruction, Subtract Wfrom f with Borrow = . After Instruction,  = . After Instruction,  = . After Instruction,  = . After Instruction,  = . After Instruction,  = . After Instruction,  = . After Instruction,  = . After Instruction,  = . REG, Subtract Wfrom f with Borrow = =. REG,  = 0x1B. REG,  = (0001 1011). REG,  = . REG,  = . REG,",
    "PIC18F6585/8585/6680/8680\n= . REG,  = . REG,  = . REG,  = . W C, Subtract Wfrom f with Borrow = = =. W C,  = 0x00 1. W C,  = . W C,  = . W C,  = . W C,  = . W C,  = . W C,  = . W C,  = . , Subtract Wfrom f with Borrow = =. ,  = 1. ,  = result is zero. ,  = . ,  = . ,  = . ,  = . ,  = ;. ,  = . Z N, Subtract Wfrom f with Borrow = =. Z N,  = . Z N,  = . Z N,  = . Z N,  = . Z N,  = . Z N,  = . Z N,  = . Z N,  = . Example 3:, Subtract Wfrom f with Borrow = . Example 3:,  = 0. Example 3:,  = 1, 0. Example 3:,  = . Example 3:,  = . Example 3:,  = . Example 3:,  = . Example 3:,  = . Example 3:,",
    "PIC18F6585/8585/6680/8680\n= . SUBWFB, Subtract Wfrom f with Borrow = . SUBWFB,  = . SUBWFB,  = REG,. SUBWFB,  = . SUBWFB,  = . SUBWFB,  = . SUBWFB,  = . SUBWFB,  = . SUBWFB,  = . Before Instruction, Subtract Wfrom f with Borrow = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . Before Instruction,  = . REG, Subtract Wfrom f with Borrow = =. REG,  = 0x03. REG,  = (0000 0011). REG,  = . REG,  = . REG,  = . REG,  = . REG,  = . REG,  = . W, Subtract Wfrom f with Borrow = =. W,  = 0x0E. W,  = (0000 1101). W,  = . W,  = . W,  = . W,  = . W,  = . W,",
    "PIC18F6585/8585/6680/8680\n= . C After Instruction, Subtract Wfrom f with Borrow = =. C After Instruction,  = 1. C After Instruction,  = . C After Instruction,  = . C After Instruction,  = . C After Instruction,  = . C After Instruction,  = . C After Instruction,  = . C After Instruction,  = . REG, Subtract Wfrom f with Borrow = =. REG,  = 0xF5. REG,  = (1111 0100) ; [2's comp]. REG,  = . REG,  = . REG,  = . REG,  = . REG,  = . REG,  = . , Subtract Wfrom f with Borrow = . ,  = 0. ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . , Subtract Wfrom f with Borrow = =. ,  = 1. ,  = ; result is. ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . Z, Subtract Wfrom f with Borrow = =. Z,  = . Z,  = . Z,  = . Z,  = . Z,",
    "PIC18F6585/8585/6680/8680\n= . Z,  = . Z,  = . Z,  = . , Subtract Wfrom f with Borrow = =. ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . N, Subtract Wfrom f with Borrow = . N,  = . N,  = . N,  = . N,  = . N,  = . N,  = . N,  = . N,  = . , Subtract Wfrom f with Borrow = . ,  = . ,  = . ,  = negative. ,  = . ,  = . ,  = . ,  = . ,  = . , Subtract Wfrom f with Borrow = . ,  = 0. ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . C, Subtract Wfrom f with Borrow = . C,  = . C,  = . C,  = . C,  = . C,  = . C,  = . C,  = . C,  = . , Subtract Wfrom f with Borrow = . ,  = . ,  = . ,  = . ,  = W. ,",
    "PIC18F6585/8585/6680/8680\n= =. ,  = 0x0E. ,  = (0000. ,  = 1101)",
    "PIC18F6585/8585/6680/8680\nSyntax:, Swap f = [ label ] SWAPF f [,d [,a]]. Syntax:, Swap f = [ label ] SWAPF f [,d [,a]]. Syntax:, Swap f = [ label ] SWAPF f [,d [,a]]. Syntax:, Swap f = [ label ] SWAPF f [,d [,a]]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Swap f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>,",
    "PIC18F6585/8585/6680/8680\n(f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Operation:, Swap f = (f<3:0>) \uf0ae dest<7:4>, (f<7:4>) \uf0ae dest<3:0>. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Encoding:, Swap f = 0011. Encoding:, Swap f = 10da. Encoding:, Swap f = ffff. Encoding:, Swap f = ffff\nDescription:",
    "PIC18F6585/8585/6680/8680\nThe upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "Example:\nSWAPF\nREG, 1, 0\nBefore Instruction\nREG\n=\n0x53\nAfter Instruction\nREG\n=\n0x35",
    "PIC18F6585/8585/6680/8680\nSyntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = [ label ] TBLRD ( *; *+; *-; +*). Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*,",
    "PIC18F6585/8585/6680/8680\n(TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT;",
    "PIC18F6585/8585/6680/8680\n(TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \uf0ae TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \uf0ae TABLAT; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLRD +*, (TBLPTR) + 1 \uf0ae TBLPTR; (Prog Mem (TBLPTR)) \uf0ae TABLAT;. Status Affected:None, Table Read = Status Affected:None. Status Affected:None, Table Read = Status Affected:None. Status Affected:None, Table Read = Status Affected:None. Status Affected:None, Table Read = Status Affected:None. Encoding:, Table Read = 0000. Encoding:, Table Read =",
    "PIC18F6585/8585/6680/8680\n0000. Encoding:, Table Read = 0000. Encoding:, Table Read = 10nn nn=0 * =1 *+ =2 *-. Description:, Table Read = =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program. Description:, Table Read = =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program. Description:, Table Read = =3 +* This instruction is used to read the contents of Program",
    "PIC18F6585/8585/6680/8680\nMemory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program. Description:, Table Read = =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Q Cycle Activity: Q2 Q3",
    "PIC18F6585/8585/6680/8680\nQ4, Table Read = Q Cycle Activity: Q2 Q3 Q4. Q Cycle Activity: Q2 Q3 Q4, Table Read = Q Cycle Activity: Q2 Q3 Q4. Q Cycle Activity: Q2 Q3 Q4, Table Read = Q Cycle Activity: Q2 Q3 Q4. Q Cycle Activity: Q2 Q3 Q4, Table Read = Q Cycle Activity: Q2 Q3 Q4. Q1 Decode, Table Read = . Q1 Decode, Table Read = . Q1 Decode, Table Read = . Q1 Decode, Table Read = . , Table Read = No operation No operation No operation operation (Read No operation No operation (Write. , Table Read = No operation No operation No operation operation (Read No operation No operation (Write. , Table Read = No operation No operation No operation operation (Read No operation No operation (Write. , Table Read = No operation No operation No operation operation (Read No operation No operation (Write. No operation, Table Read = No Program Memory) TABLAT). No operation, Table Read = No Program Memory) TABLAT). No operation, Table Read =",
    "PIC18F6585/8585/6680/8680\nNo Program Memory) TABLAT). No operation, Table Read = No Program Memory) TABLAT)",
    "PIC18F6585/8585/6680/8680\nExample1:, Table Read (Continued) = TBLRD. Example1:, Table Read (Continued) = ;. Example1:, Table Read (Continued) = . Before Instruction, Table Read (Continued) = Before Instruction. Before Instruction, Table Read (Continued) = =. Before Instruction, Table Read (Continued) = 0x55. TABLAT TBLPTR, Table Read (Continued) = TABLAT TBLPTR. TABLAT TBLPTR, Table Read (Continued) = =. TABLAT TBLPTR, Table Read (Continued) = 0x00A356. MEMORY(0x00A356), Table Read (Continued) = MEMORY(0x00A356). MEMORY(0x00A356), Table Read (Continued) = =. MEMORY(0x00A356), Table Read (Continued) = 0x34. After Instruction TABLAT, Table Read (Continued) = After Instruction TABLAT. After Instruction TABLAT, Table Read (Continued) = =. After Instruction TABLAT, Table Read (Continued) = 0x34. TBLPTR, Table Read (Continued) =",
    "PIC18F6585/8585/6680/8680\nTBLPTR. TBLPTR, Table Read (Continued) = =. TBLPTR, Table Read (Continued) = 0x00A357. Example2:, Table Read (Continued) = TBLRD +*. Example2:, Table Read (Continued) = ;. Example2:, Table Read (Continued) = . Before Instruction TABLAT, Table Read (Continued) = Before Instruction TABLAT. Before Instruction TABLAT, Table Read (Continued) = =. Before Instruction TABLAT, Table Read (Continued) = 0xAA. TBLPTR, Table Read (Continued) = TBLPTR. TBLPTR, Table Read (Continued) = =. TBLPTR, Table Read (Continued) = 0x01A357. MEMORY(0x01A357), Table Read (Continued) = MEMORY(0x01A357). MEMORY(0x01A357), Table Read (Continued) = =. MEMORY(0x01A357), Table Read (Continued) = 0x12. MEMORY(0x01A358), Table Read (Continued) =",
    "PIC18F6585/8585/6680/8680\nMEMORY(0x01A358). MEMORY(0x01A358), Table Read (Continued) = =. MEMORY(0x01A358), Table Read (Continued) = 0x34. After Instruction TABLAT, Table Read (Continued) = After Instruction TABLAT. After Instruction TABLAT, Table Read (Continued) = =. After Instruction TABLAT, Table Read (Continued) = 0x34. TBLPTR, Table Read (Continued) = TBLPTR. TBLPTR, Table Read (Continued) = =. TBLPTR, Table Read (Continued) = 0x01A358",
    "PIC18F6585/8585/6680/8680\nSyntax:, Table Write = [ label ] TBLWT ( *; *+; *-; +*). Operands:, Table Write = None. Operation:, Table Write = if TBLWT*, (TABLAT) \uf0ae Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \uf0ae Holding Register; (TBLPTR) + 1 \uf0ae TBLPTR; if TBLWT*-, (TABLAT) \uf0ae Holding Register; (TBLPTR) - 1 \uf0ae TBLPTR; if TBLWT+*, (TBLPTR) + 1 \uf0ae TBLPTR; (TABLAT) \uf0ae Holding Register;\nStatus Affected: None\nEncoding:\n0000, 1 = 0000. 0000, 2 = 0000. 0000, 3 = 11nn nn=0 *\nDescription:\nThis instruction uses the 3 LSBs of",
    "PIC18F6585/8585/6680/8680\nTBLPTR to determine which of the 8 holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). (Refer to Section 5.0 'Flash Program Memory' for additional details on programming Flash memory.) The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MBtye address range. The LSb of the TBLPTR selects which byte of the program memory location to access.\nTBLPTR[0] =\n0\n:Least Significant\nByte of Program\nMemory Word\nTBLPTR[0] =\n1\n:Most Significant\nByte of Program\nMemory Word\nThe TBLWT instruction can modify the value of TBLPTR as follows:\n\u00b7 no change\n\u00b7 post-increment\n\u00b7 post-decrement\n\u00b7 pre-increment",
    "TBLWT       Table Write  (Continued)\nWords:\n1\nCycles: 2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nNo operation, No operation = No operation (Read TABLAT). No operation, No operation = No operation. No operation, No operation = No operation (Write to Holding Register )",
    "Example 2:\nBefore Instruction\nTABLAT\n=\n0x55\nTBLPTR\n= 0x00A356\nHOLDING REGISTER\n(0x00A356)\n=\n0xFF\nAfter Instructions (table write completion)\nTABLAT TBLPTR HOLDING REGISTER (0x00A356)\n=\n0x55\n=\n0x00A357\n=\n0x55\nTBLWT  +*;\nBefore Instruction\nTABLAT\n=\n0x34\nTBLPTR\n= 0x01389A\nHOLDING REGISTER\n(0x01389A)\n=\n0xFF\nHOLDING REGISTER\n(0x01389B)\n= 0xFF\nAfter Instruction (table write completion)\nTABLAT\n=\n0x34\nTBLPTR\n= 0x01389B\nHOLDING REGISTER\n(0x01389A)\n= 0xFF\nHOLDING REGISTER (0x01389B)\n= 0x34",
    "PIC18F6585/8585/6680/8680\nSyntax:, Test f, skip if 0 = [ label ] TSTFSZ f [,a]. Syntax:, Test f, skip if 0 = [ label ] TSTFSZ f [,a]. Syntax:, Test f, skip if 0 = [ label ] TSTFSZ f [,a]. Syntax:, Test f, skip if 0 = [ label ] TSTFSZ f [,a]. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operands:, Test f, skip if 0 = 0 \uf0a3 f \uf0a3 255 a \uf0ce [0,1]. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Status Affected:, Test",
    "PIC18F6585/8585/6680/8680\nf, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Encoding:, Test f, skip if 0 = 0110. Encoding:, Test f, skip if 0 = 011a. Encoding:, Test f, skip if 0 = ffff. Encoding:, Test f, skip if 0 = ffff. Description:, Test f, skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected. Description:, Test f, skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will",
    "PIC18F6585/8585/6680/8680\nbe selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected. Description:, Test f, skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected. Description:, Test f, skip if 0 = If 'f' = 0 , the next instruction, fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected. Words:, Test f, skip if 0 = 1. Words:, Test f, skip if 0 = 1. Words:, Test f, skip if 0 = 1. Words:, Test f, skip if 0 = 1.",
    "PIC18F6585/8585/6680/8680\nCycles:, Test f, skip if 0 = 1(2). Cycles:, Test f, skip if 0 = 1(2). Cycles:, Test f, skip if 0 = 1(2). Cycles:, Test f, skip if 0 = 1(2)",
    "PIC18F6585/8585/6680/8680\nSyntax:, Exclusive OR literal with W = [ label ] XORLW k. Syntax:, Exclusive OR literal with W = [ label ] XORLW k. Syntax:, Exclusive OR literal with W = [ label ] XORLW k. Operands:, Exclusive OR literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operands:, Exclusive OR literal with W = 0 \uf0a3\uf020 k \uf0a3\uf020 255. Operation:, Exclusive OR literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR literal with W = (W) .XOR. k \uf0ae\uf020 W. Operation:, Exclusive OR literal with W = (W) .XOR. k \uf0ae\uf020 W. Status Affected:, Exclusive OR literal with W = N, Z. Status Affected:, Exclusive OR literal with W = N, Z. Status Affected:, Exclusive OR literal with W = N, Z. Encoding:, Exclusive OR literal with W = 0000. Encoding:, Exclusive OR literal with W = 1010. Encoding:, Exclusive OR literal with W = kkkk kkkk. Description:, Exclusive OR literal with",
    "PIC18F6585/8585/6680/8680\nW = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Words:, Exclusive OR literal with W = 1. Words:, Exclusive OR literal with W = 1. Words:, Exclusive OR literal with W = 1. Cycles:, Exclusive OR literal with W = 1. Cycles:, Exclusive OR literal with W = 1. Cycles:, Exclusive OR literal with W = 1. Q Cycle Activity: Q1, Exclusive OR literal with W = Q2. Q Cycle Activity: Q1, Exclusive OR literal with W = Q3. Q Cycle Activity: Q1, Exclusive OR literal with W = Q4. Decode, Exclusive OR literal with W = Read literal 'k'. Decode, Exclusive OR literal with W = Process Data. Decode, Exclusive OR literal with W =",
    "PIC18F6585/8585/6680/8680\nWrite to W\nNote: 3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nDecode",
    "If skip:\nQ1\nNo\nQ2\nQ3\nQ4\nRead register 'f'\nQ2\nNo\nProcess\nData\nQ3\nNo operation\noperation operation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nNo operation\nQ4\nNo operation\nQ4\nNo operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nHERE    TSTFSZ  CNT, 1\nNZERO   :\nZERO    :\nBefore Instruction\nPC\n=\nAddress\n(HERE)\nAfter Instruction\nIf CNT\n=\n0x00,\nPC\n=\nAddress\n(ZERO)\nIf CNT\n\uf0b9\n0x00,\nPC\n=\nAddress (NZERO)",
    "Example:\nXORLW\n0xAF\nBefore Instruction\nW\n=\n0xB5\nAfter Instruction\nW = 0x1A",
    "PIC18F6585/8585/6680/8680\nSyntax:, Exclusive OR Wwith f = [ label ] XORWF. Syntax:, Exclusive OR Wwith f = [ label ] XORWF. Syntax:, Exclusive OR Wwith f = f [,d [,a]]. Syntax:, Exclusive OR Wwith f = f [,d [,a]]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = 0 \uf0a3 f \uf0a3 255 d \uf0ce [0,1] a \uf0ce [0,1]. Operands:, Exclusive OR Wwith f = . Operands:, Exclusive OR Wwith f = . Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \uf0ae\uf020 dest. Status Affected:, Exclusive OR Wwith",
    "PIC18F6585/8585/6680/8680\nf = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Encoding:, Exclusive OR Wwith f = 0001. Encoding:, Exclusive OR Wwith f = 10da. Encoding:, Exclusive OR Wwith f = ffff. Encoding:, Exclusive OR Wwith f = ffff. Description:, Exclusive OR Wwith f = Exclusive OR the contents of W with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Exclusive OR Wwith f = Exclusive OR the contents of W with register 'f'. If 'd' is ' 0 ', the result is stored in",
    "PIC18F6585/8585/6680/8680\nW. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Exclusive OR Wwith f = Exclusive OR the contents of W with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Exclusive OR Wwith f = Exclusive OR the contents of W with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f'",
    "PIC18F6585/8585/6680/8680\n(default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = 1. Q Cycle Activity: Q1, Exclusive OR Wwith f = . Q Cycle Activity: Q1, Exclusive OR Wwith f = . Q Cycle Activity: Q1, Exclusive OR Wwith f = . Q Cycle Activity: Q1, Exclusive OR Wwith f = . , Exclusive OR Wwith f = Q2. , Exclusive OR Wwith f = Q3. , Exclusive OR Wwith f = . , Exclusive OR Wwith f = Q4. Decode, Exclusive OR Wwith",
    "PIC18F6585/8585/6680/8680\nf = . Decode, Exclusive OR Wwith f = Read register 'f'. Decode, Exclusive OR Wwith f = Process Data. Decode, Exclusive OR Wwith f = Write to destination. Example:, Exclusive OR Wwith f = XORWF. Example:, Exclusive OR Wwith f = REG, 1,. Example:, Exclusive OR Wwith f = 0. Example:, Exclusive OR Wwith f = . Before Instruction, Exclusive OR Wwith f = Before Instruction. Before Instruction, Exclusive OR Wwith f = Before Instruction. Before Instruction, Exclusive OR Wwith f = Before Instruction. Before Instruction, Exclusive OR Wwith f = Before Instruction. REG, Exclusive OR Wwith f = =. REG, Exclusive OR Wwith f = 0xAF. REG, Exclusive OR Wwith f = . REG, Exclusive OR Wwith f = . W, Exclusive OR Wwith f = =. W, Exclusive OR Wwith f = 0xB5. W, Exclusive OR Wwith f = . W, Exclusive OR Wwith f = . After Instruction, Exclusive OR Wwith f = After Instruction. After Instruction, Exclusive OR Wwith f =",
    "PIC18F6585/8585/6680/8680\nAfter Instruction. After Instruction, Exclusive OR Wwith f = After Instruction. After Instruction, Exclusive OR Wwith f = After Instruction. REG, Exclusive OR Wwith f = =. REG, Exclusive OR Wwith f = 0x1A. REG, Exclusive OR Wwith f = . REG, Exclusive OR Wwith f = . W, Exclusive OR Wwith f = =. W, Exclusive OR Wwith f = 0xB5. W, Exclusive OR Wwith f = . W, Exclusive OR Wwith f = ",
    "26.0 DEVELOPMENT SUPPORT\nThe  PIC \u00ae   microcontrollers  are  supported  with  a  full range of hardware and software development tools:",
    "26.1 MPLAB Integrated Development Environment Software\n\u00b7 Integrated Development Environment\n-MPLAB \u00ae  IDE Software\n\u00b7 Assemblers/Compilers/Linkers\n-MPASM TM  Assembler\n-MPLAB C17 and MPLAB C18 C Compilers\n-MPLINK TM  Object Linker/ MPLIB TM  Object Librarian\n-MPLAB C30 C Compiler\n-MPLAB ASM30 Assembler/Linker/Library\n\u00b7 Simulators\n-MPLAB SIM Software Simulator\n-MPLAB dsPIC30 Software Simulator\n\u00b7 Emulators\n-MPLAB ICE 2000 In-Circuit Emulator\n-MPLAB ICE 4000 In-Circuit Emulator\n\u00b7 In-Circuit Debugger\n-MPLAB ICD 2\n\u00b7 Device Programmers\n-PRO MATE \u00ae  II Universal Device Programmer\n-PICSTART \u00ae  Plus Development Programmer\n-MPLAB PM3 Device Programmer\n\u00b7 Low-Cost Demonstration Boards\n-PICDEM TM  1 Demonstration Board\n-PICDEM.net TM  Demonstration Board\n-PICDEM 2 Plus Demonstration Board\n-PICDEM 3 Demonstration Board\n-PICDEM 4 Demonstration Board\n-PICDEM 17 Demonstration Board\n-PICDEM 18R Demonstration Board\n-PICDEM LIN Demonstration Board\n-PICDEM USB Demonstration Board\n\u00b7 Evaluation Kits\n-KEELOQ \u00ae\n-PICDEM MSC",
    "26.1 MPLAB Integrated Development Environment Software\n-microID \u00ae\n-CAN\n-PowerSmart \u00ae\n-Analog\nThe MPLAB IDE software brings an ease of software development previously unseen in the 8/16-bit microcontroller  market.  The  MPLAB  IDE  is  a  Windows \u00ae based application that contains:\n\u00b7 An interface to debugging tools\n-simulator\n-programmer (sold separately)\n-emulator (sold separately)\n-in-circuit debugger (sold separately)\n\u00b7 A full-featured editor with color coded context\n\u00b7 A multiple project manager\n\u00b7 Customizable data windows with direct edit of contents\n\u00b7 High-level source code debugging\n\u00b7 Mouse over variable inspection\n\u00b7 Extensive on-line help\nThe MPLAB IDE allows you to:\n\u00b7 Edit your source files (either assembly or C)\n\u00b7 One touch assemble (or compile) and download to PIC MCU emulator and simulator tools (automatically updates all project information)\n\u00b7 Debug using:\n-source files (assembly or C)\n-mixed assembly and C\n-machine code",
    "26.1 MPLAB Integrated Development Environment Software\nMPLAB  IDE  supports  multiple  debugging  tools  in  a single development paradigm, from the cost effective simulators,  through  low-cost  in-circuit  debuggers,  to full-featured  emulators.  This  eliminates  the  learning curve when upgrading to tools with increasing flexibility and power.",
    "26.2 MPASM Assembler\nThe  MPASM  assembler  is  a  full-featured,  universal macro assembler for all PIC MCUs.\nThe MPASM assembler generates relocatable object files for the MPLINK object linker, Intel \u00ae  standard HEX files, MAP files to detail memory usage and symbol reference, absolute LST files that contain source lines and generated machine code and COFF files for debugging.\nThe MPASM assembler features include:\n\u00b7 Integration into MPLAB IDE projects\n\u00b7 User defined macros to streamline assembly code\n\u00b7 Conditional assembly for multi-purpose source files\n\u00b7 Directives that allow complete control over the assembly process",
    "26.6 MPLAB ASM30 Assembler, Linker and Librarian\nThe MPLAB C17 and MPLAB C18 Code Development Systems are complete ANSI C compilers for Microchip's  PIC17CXXX  and  PIC18CXXX  family  of microcontrollers.  These  compilers  provide  powerful integration capabilities, superior code optimization and ease of use not found with other compilers.\nFor easy source level debugging, the compilers provide symbol information that is optimized to the MPLAB IDE debugger.",
    "26.4 MPLINK Object Linker/ MPLIB Object Librarian\nThe MPLINK object linker combines relocatable objects  created  by  the  MPASM  assembler  and  the MPLAB C17 and MPLAB C18 C compilers. It can link relocatable  objects  from  precompiled  libraries,  using directives from a linker script.\nThe MPLIB object librarian manages the creation and modification of library files of precompiled code. When a routine from a library is called from a source file, only the modules that contain that routine will be linked in with  the  application.  This  allows  large  libraries  to  be used efficiently in many different applications.\nThe object linker/library features include:\n\u00b7 Efficient linking of single libraries instead of many smaller files\n\u00b7 Enhanced code maintainability by grouping related modules together\n\u00b7 Flexible creation of libraries with easy module listing, replacement, deletion and extraction",
    "26.5 MPLAB C30 C Compiler\nThe MPLAB C30 C compiler is a full-featured, ANSI compliant, optimizing compiler that translates standard ANSI C programs into dsPIC30F assembly language source.  The  compiler  also  supports  many  command line options  and  language  extensions  to  take  full advantage of the dsPIC30F device hardware capabilities and  afford  fine  control  of the  compiler  code generator.\nMPLAB  C30  is  distributed  with  a  complete  ANSI  C standard  library.  All  library  functions  have  been  validated and conform to the ANSI C library standard. The library includes functions for string manipulation, dynamic  memory  allocation,  data  conversion,  timekeeping and math functions (trigonometric, exponential and hyperbolic). The compiler provides symbolic information  for  high-level  source  debugging  with  the MPLAB IDE.\nMPLAB ASM30 assembler produces relocatable machine  code  from  symbolic  assembly  language  for dsPIC30F  devices.  MPLAB  C30  compiler  uses  the assembler  to  produce  it's  object  file.  The  assembler generates  relocatable  object  files  that  can  then  be archived or linked with other relocatable object files and archives to create an executable file. Notable features of the assembler include:",
    "26.5 MPLAB C30 C Compiler\n\u00b7 Support for the entire dsPIC30F instruction set\n\u00b7 Support for fixed-point and floating-point data\n\u00b7 Command line interface\n\u00b7 Rich directive set\n\u00b7 Flexible macro language\n\u00b7 MPLAB IDE compatibility",
    "26.7 MPLAB SIM Software Simulator\nThe MPLAB SIM software simulator allows code development in a PC hosted environment by simulating the PIC series microcontrollers on an instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a file, or user defined key press, to any pin. The execution can be  performed  in  Single-Step,  Execute  Until  Break  or Trace mode.\nThe  MPLAB  SIM  simulator  fully  supports  symbolic debugging  using  the  MPLAB  C17  and  MPLAB  C18 C Compilers, as well as the MPASM assembler. The software simulator offers the flexibility to develop and debug  code  outside  of  the  laboratory  environment, making it an excellent, economical software development tool.",
    "26.8 MPLAB SIM30 Software Simulator\nThe  MPLAB  SIM30  software  simulator  allows  code development in a PC hosted environment by simulating the dsPIC30F series microcontrollers on an instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a file, or user defined key press, to any of the pins.\nThe MPLAB SIM30 simulator fully supports symbolic debugging  using  the  MPLAB  C30  C  Compiler  and MPLAB ASM30 assembler. The simulator runs in either a Command Line mode for automated tasks, or from MPLAB IDE. This high-speed simulator is designed to debug,  analyze  and  optimize  time  intensive  DSP routines.",
    "26.9 MPLAB ICE 2000 High-Performance Universal In-Circuit Emulator\nThe MPLAB ICE 2000 universal in-circuit emulator is intended to provide the product development engineer with a complete microcontroller design tool set for PIC microcontrollers. Software control  of  the MPLAB ICE 2000  in-circuit  emulator  is  advanced  by  the  MPLAB Integrated  Development  Environment,  which  allows editing,  building,  downloading  and  source  debugging from a single environment.\nThe MPLAB ICE 2000 is a full-featured emulator system with enhanced trace, trigger and data monitoring features. Interchangeable processor modules allow the system to be easily reconfigured for emulation of different processors.  The  universal  architecture  of the MPLAB  ICE  in-circuit  emulator  allows  expansion  to support new PIC microcontrollers.\nThe MPLAB ICE 2000 in-circuit emulator system has been designed as a real-time emulation system with advanced  features  that  are  typically  found  on  more expensive  development  tools.  The  PC  platform  and Microsoft \u00ae Windows  32-bit  operating  system  were chosen  to  best  make  these  features  available  in  a simple, unified application.",
    "26.10 MPLAB ICE 4000 High-Performance Universal In-Circuit Emulator\nThe MPLAB ICE 4000 universal in-circuit emulator is intended to provide the product development engineer with a complete microcontroller design tool set for highend  PIC  microcontrollers.  Software  control  of  the MPLAB  ICE  in-circuit  emulator  is  provided  by  the MPLAB Integrated Development  Environment,  which allows editing, building, downloading and source debugging from a single environment.\nThe MPLAB ICD 4000 is a premium emulator system, providing  the  features  of  MPLAB  ICE  2000,  but  with increased emulation  memory  and  high-speed  performance  for  dsPIC30F  and  PIC18XXXX  devices.  Its advanced emulator features include complex triggering and timing, up to 2 Mb of emulation memory and the ability to view variables in real-time.\nThe MPLAB ICE 4000 in-circuit emulator system has been designed as a real-time emulation system with advanced  features  that  are  typically  found  on  more expensive  development  tools.  The  PC  platform  and Microsoft Windows  32-bit operating system were chosen  to  best  make  these  features  available  in  a simple, unified application.",
    "26.11 MPLAB ICD 2 In-Circuit Debugger\nMicrochip's  In-Circuit  Debugger,  MPLAB  ICD  2,  is  a powerful, low-cost, run-time development tool, connecting to the host PC via an RS-232 or high-speed USB  interface.  This  tool  is  based  on  the  Flash  PIC MCUs and can be used to develop for these and other PIC microcontrollers. The MPLAB ICD 2 utilizes the incircuit debugging capability built into the Flash devices. This  feature,  along  with  Microchip's  In-Circuit  Serial Programming TM  (ICSP TM ) protocol, offers cost effective in-circuit Flash debugging from the graphical user interface of the MPLAB Integrated Development Environment. This enables a designer to develop and debug  source  code  by  setting  breakpoints,  singlestepping  and  watching  variables,  CPU  status  and peripheral registers. Running at full speed enables testing  hardware  and  applications  in  real-time.  MPLAB ICD 2 also serves as a development programmer for selected PIC devices.",
    "26.12 PRO MATE II Universal Device Programmer\nThe PRO MATE II is a universal, CE compliant device programmer with programmable voltage verification at VDDMIN and VDDMAX for maximum reliability. It features an  LCD  display  for  instructions  and  error  messages and a modular detachable socket assembly to support various  package  types.  In  Stand-Alone  mode,  the PRO MATE II device programmer can read, verify and program PIC devices without a PC connection. It can also set code protection in this mode.",
    "26.13 MPLAB PM3 Device Programmer\nThe MPLAB PM3 is a universal, CE compliant device programmer with programmable voltage verification at VDDMIN and VDDMAX for maximum reliability. It features a  large  LCD  display  (128  x  64)  for  menus  and  error messages and a modular detachable socket assembly to support various package types. The ICSP\u2122 cable assembly  is  included  as  a  standard  item.  In  StandAlone mode, the MPLAB PM3 device programmer can read,  verify  and  program  PIC  devices  without  a  PC connection. It can also set code protection in this mode. MPLAB PM3 connects to the host PC via an  RS-232 or USB cable. MPLAB PM3 has high-speed communications  and  optimized  algorithms  for  quick  programming of large memory devices and incorporates an SD/ MMC card for file storage and secure data applications.",
    "26.14 PICSTART Plus Development Programmer\nThe PICSTART Plus development programmer is an easy-to-use,  low-cost,  prototype  programmer.  It  connects  to  the  PC  via  a  COM  (RS-232)  port.  MPLAB Integrated Development Environment software makes using the programmer simple and efficient. The PICSTART  Plus  development  programmer  supports most  PIC  devices  up  to  40  pins.  Larger  pin  count devices,  such  as  the  PIC16C92X  and  PIC17C76X, may  be  supported with an adapter socket. The PICSTART  Plus  development  programmer  is CE compliant.",
    "26.15 PICDEM 1 PIC MCU Demonstration Board\nThe PICDEM 1 demonstration board demonstrates the capabilities of the PIC16C5X (PIC16C54 to PIC16C58A), PIC16C61, PIC16C62X, PIC16C71, PIC16C8X, PIC17C42, PIC17C43 and PIC17C44. All necessary  hardware  and  software  is  included  to  run basic  demo  programs.  The  sample  microcontrollers provided with the PICDEM 1 demonstration board can be programmed with a PRO MATE II device programmer or  a  PICSTART  Plus  development  programmer. The PICDEM 1 demonstration board can be connected to  the  MPLAB  ICE  in-circuit  emulator  for  testing.  A prototype area extends the circuitry for additional application components. Features include an RS-232 interface, a potentiometer for simulated analog input, push button switches and eight LEDs.",
    "26.16 PICDEM.net Internet/Ethernet Demonstration Board\nThe PICDEM.net demonstration board is an Internet/ Ethernet  demonstration  board  using  the  PIC18F452 microcontroller and TCP/IP firmware. The board supports any 40-pin DIP device that conforms to the standard pinout used by the PIC16F877 or PIC18C452. This  kit  features  a  user  friendly  TCP/IP stack, web  server with HTML,  a 24L256 Serial EEPROM for Xmodem download to  web  pages  into Serial  EEPROM,  ICSP/MPLAB  ICD  2  interface  connector, an Ethernet interface, RS-232 interface and a 16  x  2  LCD  display.  Also  included  is  the  book  and CD-ROM 'TCP/IP Lean, Web Servers for Embedded Systems,' by Jeremy Bentham",
    "26.17 PICDEM 2 Plus Demonstration Board\nThe  PICDEM  2  Plus  demonstration  board  supports many  18,  28  and  40-pin  microcontrollers,  including PIC16F87X  and  PIC18FXX2  devices.  All  the  necessary hardware and software is included to run the demonstration programs. The sample microcontrollers provided with the PICDEM 2 demonstration board can be programmed with a PRO MATE II device programmer,  PICSTART  Plus  development  programmer,  or MPLAB ICD 2 with a Universal Programmer Adapter. The MPLAB ICD 2 and MPLAB ICE in-circuit emulators may also be used with the PICDEM 2 demonstration board to test firmware. A prototype area extends the circuitry  for  additional  application  components. Some of the features include an RS-232 interface, a 2 x 16 LCD display, a piezo speaker, an on-board temperature sensor, four LEDs and sample PIC18F452 and PIC16F877 Flash microcontrollers.",
    "26.18 PICDEM 3 PIC16C92X Demonstration Board\nThe  PICDEM  3  demonstration  board  supports  the PIC16C923 and PIC16C924 in the PLCC package. All the necessary hardware and software is included to run the demonstration programs.",
    "26.19 PICDEM 4 8/14/18-Pin Demonstration Board\nThe PICDEM 4 can be used to demonstrate the capabilities of the 8, 14  and  18-pin  PIC16XXXX  and PIC18XXXX  MCUs,  including  the  PIC16F818/819, PIC16F87/88, PIC16F62XA and the PIC18F1320 family  of  microcontrollers.  PICDEM  4  is  intended  to showcase  the  many  features  of  these  low  pin  count parts,  including  LIN  and  Motor  Control  using  ECCP. Special provisions  are  made  for low-power operation with the supercapacitor circuit and jumpers allow onboard  hardware  to  be  disabled  to  eliminate  current draw in this mode. Included on the demo board are provisions for Crystal, RC or Canned Oscillator modes, a five volt regulator for use with a nine volt wall adapter or  battery,",
    "26.19 PICDEM 4 8/14/18-Pin Demonstration Board\nDB-9 RS-232 interface, ICD connector for programming via ICSP and development with MPLAB ICD 2, 2 x 16 liquid crystal display, PCB footprints for H-Bridge motor driver, LIN transceiver and EEPROM. Also included are: header for expansion, eight LEDs, four potentiometers, three push buttons and a prototyping area. Included with the kit is a PIC16F627A and a PIC18F1320. Tutorial firmware is included along with the User's Guide.",
    "26.20 PICDEM 17 Demonstration Board\nThe PICDEM 17 demonstration board is an evaluation board  that  demonstrates  the  capabilities  of  several Microchip microcontrollers, including PIC17C752, PIC17C756A,  PIC17C762  and  PIC17C766.  A  programmed sample is included. The PRO MATE II device programmer, or the PICSTART Plus development programmer, can be used to reprogram the device for user tailored  application  development.  The  PICDEM  17 demonstration board supports program download and execution  from  external  on-board  Flash  memory.  A generous prototype area is available for user hardware expansion.",
    "26.21 PICDEM 18R PIC18C601/801 Demonstration Board\nThe PICDEM 18R demonstration board serves to assist development of the PIC18C601/801 family of Microchip microcontrollers. It provides  hardware  implementation of both 8-bit Multiplexed/Demultiplexed and  16-bit Memory  modes.  The  board  includes  2  Mb  external Flash memory and 128 Kb SRAM memory, as well as serial EEPROM, allowing access to the wide range of memory types supported by the PIC18C601/801.",
    "26.22 PICDEM LIN PIC16C43X Demonstration Board\nThe powerful LIN hardware and software kit includes a series of boards and three PIC microcontrollers. The small footprint PIC16C432 and PIC16C433 are used as  slaves  in  the  LIN  communication  and  feature  onboard LIN transceivers. A PIC16F874 Flash microcontroller serves as the master. All three microcontrollers  are  programmed  with  firmware  to  provide LIN bus communication.",
    "26.23 PICkit TM 1 Flash Starter Kit\nA complete 'development system in a box', the PICkit Flash  Starter  Kit  includes  a  convenient  multi-section board for programming, evaluation and development of 8/14-pin  Flash  PIC \u00ae   microcontrollers.  Powered  via USB, the board operates under a simple Windows GUI. The PICkit 1 Starter Kit includes the User's Guide (on CD  ROM),  PICkit 1  tutorial  software  and  code  for various  applications.  Also  included  are  MPLAB \u00ae   IDE (Integrated Development Environment) software, software and hardware 'Tips 'n Tricks for 8-pin Flash PIC \u00ae  Microcontrollers' Handbook and a USB interface cable. Supports all current 8/14-pin Flash PIC microcontrollers, as  well as many  future  planned devices.",
    "26.24 PICDEM USB PIC16C7X5 Demonstration Board\nThe PICDEM USB Demonstration Board shows off the capabilities  of  the  PIC16C745  and  PIC16C765  USB microcontrollers.  This  board  provides  the  basis  for future USB products.",
    "26.25 Evaluation and Programming Tools\nIn addition to the PICDEM series of circuits, Microchip has a line of evaluation kits and demonstration software for these products.\n\u00b7 KEELOQ evaluation and programming tools for Microchip's HCS Secure Data Products\n\u00b7 CAN developers kit for automotive network applications\n\u00b7 Analog design boards and filter design software\n\u00b7 PowerSmart battery charging evaluation/ calibration kits\n\u00b7 IrDA \u00ae  development kit\n\u00b7 microID development and rfLab TM  development software\n\u00b7 SEEVAL \u00ae  designer kit for memory evaluation and endurance calculations\n\u00b7 PICDEM MSC demo boards for Switching mode power supply, high-power IR driver, delta sigma ADC and flow rate sensor\nCheck the Microchip web page and the latest Product Selector Guide for the complete list of demonstration and evaluation kits.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "Absolute Maximum Ratings  (\u2020)\nAmbient temperature under bias.............................................................................................................-40\u00b0C to +125\u00b0C",
    "Absolute Maximum Ratings  (\u2020)\nStorage temperature .............................................................................................................................. -65\u00b0C to +150\u00b0C\nVoltage on any pin with respect to VSS (except VDD, MCLR, and RA4) ......................................... -0.3V to (VDD + 0.3V)",
    "Absolute Maximum Ratings  (\u2020)\nVoltage on VDD with respect to VSS  .........................................................................................................  -0.3V to +5.5V\nVoltage on MCLR with respect to VSS (Note 2)\n......................................................................................... 0V to +13.25V",
    "Absolute Maximum Ratings  (\u2020)\nVoltage on RA4 with respect to Vss............................................................................................................... 0V to +8.5V\nTotal power dissipation (Note 1)",
    "Absolute Maximum Ratings  (\u2020)\n...............................................................................................................................1.0W",
    "Absolute Maximum Ratings  (\u2020)\nMaximum current out of VSS pin ...........................................................................................................................300 mA",
    "Absolute Maximum Ratings  (\u2020)\nMaximum current into VDD pin ..............................................................................................................................250 mA\nInput clamp current, IIK (VI < 0 or VI > VDD)\n\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e \uf0b1\n20 mA\nOutput clamp current, IOK (VO < 0 or VO > VDD)\n\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e\uf02e \uf0b1\n20 mA",
    "Absolute Maximum Ratings  (\u2020)\nMaximum output current sunk by any I/O pin..........................................................................................................25 mA\nMaximum output current sourced by any I/O pin ....................................................................................................25 mA",
    "Absolute Maximum Ratings  (\u2020)\nMaximum current sunk by all ports .......................................................................................................................200 mA \uf020\nMaximum current sourced by all ports ..................................................................................................................200 mA",
    "Absolute Maximum Ratings  (\u2020)\nNote 1: Power dissipation is calculated as follows:\nPdis = VDD x {IDD -\uf0e5 IOH} + \uf0e5 {(VDD - VOH) x IOH} + \uf0e5 (VOl x IOL)\n- 2: Voltage spikes below VSS at the MCLR/VPP pin, inducing currents greater than 80 mA, may cause latch-up. Thus, a series resistor of 50-100 \uf057 should be used when applying a 'low' level to the MCLR/VPP pin rather than pulling this pin directly to VSS.\n\u2020 NOTICE: Stresses above those listed under 'Absolute Maximum Ratings' may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure to maximum rating conditions for extended periods may affect device reliability.",
    "27.1 DC Characteristics:\nSupply Voltage PIC18FXX8X (Industrial, Extended) PIC18LFXX8X (Industrial)\nPIC18LFXX8X\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18FXX8X\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "27.1 DC Characteristics:\nD001, Symbol = VDD. D001, Characteristic = Supply Voltage. D001, Min = Supply Voltage. D001, Typ = Supply Voltage. D001, Max = Supply Voltage. D001, Units = Supply Voltage. D001, Conditions = Supply Voltage. D001, Symbol = VDD. D001, Characteristic = PIC18LFXX8X. D001, Min = 2.0. D001, Typ = -. D001, Max = 5.5. D001, Units = V. D001, Conditions = HS, XT, RC and LP Oscillator mode. D001, Symbol = VDD. D001, Characteristic = PIC18FXX8X. D001, Min = 4.2. D001, Typ = -. D001, Max = 5.5. D001, Units = V. D001, Conditions = . D001A, Symbol = AVDD. D001A, Characteristic = Analog Supply Voltage. D001A, Min = VDD - 0.3. D001A,",
    "27.1 DC Characteristics:\nTyp = -. D001A, Max = VDD + 0.3. D001A, Units = V. D001A, Conditions = . D002, Symbol = VDR. D002, Characteristic = RAM Data Retention Voltage (1). D002, Min = 1.5. D002, Typ = -. D002, Max = -. D002, Units = V. D002, Conditions = . D003, Symbol = VPOR. D003, Characteristic = VDD Start Voltage to ensure internal Power-on Reset signal. D003, Min = -. D003, Typ = -. D003, Max = 0.7. D003, Units = V. D003, Conditions = See section on Power-on Reset for details. D004, Symbol = SVDD. D004, Characteristic = VDD Rise Rate to ensure internal Power-on Reset signal. D004, Min = 0.05. D004, Typ = -. D004, Max = -. D004, Units = V/ms. D004, Conditions",
    "27.1 DC Characteristics:\n= See section on Power-on Reset for details. D005, Symbol = VBOR. D005, Characteristic = Brown-out Reset Voltage. D005, Min = Brown-out Reset Voltage. D005, Typ = Brown-out Reset Voltage. D005, Max = Brown-out Reset Voltage. D005, Units = Brown-out Reset Voltage. D005, Conditions = Brown-out Reset Voltage. D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 11. D005, Min = 1.96. D005, Typ = -. D005, Max = 2.18. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 10. D005, Min = 2.64. D005, Typ = -. D005, Max = 2.92. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic =",
    "27.1 DC Characteristics:\nBORV1:BORV0 = 01. D005, Min = 4.11. D005, Typ = -. D005, Max = 4.55. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic = BORV1:BORV0 = 00. D005, Min = 4.41. D005, Typ = -. D005, Max = 4.87. D005, Units = V. D005, Conditions = \nLegend:\nShading of rows is to assist in readability of the table.\nNote 1: This is the limit to which VDD can be lowered in Sleep mode, or during a device Reset, without losing RAM data.",
    "PIC18F6585/8585/6680/8680\n27.2 DC Characteristics:",
    "Power-down and Supply Current PIC18FXX8X (Industrial, Extended) PIC18LFXX8X (Industrial)\nPIC18LFXX8X\nStandard Operating Conditions (unless otherwise stated)\n(Industrial)\nPIC18FXX8X\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C\n\uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "Power-down and Supply Current PIC18FXX8X (Industrial, Extended) PIC18LFXX8X (Industrial)\nD020, Device = Power-down Current (I PD) (1). D020, Typ = Power-down Current (I PD) (1). D020, Max = Power-down Current (I PD) (1). D020, Units = Power-down Current (I PD) (1). D020, Conditions = Power-down Current (I PD) (1). D020, Conditions = Power-down Current (I PD) (1). D020, Device = PIC18LFXX8X. D020, Typ = 0.2. D020, Max = 1. D020, Units = \uf06d A. D020, Conditions = -40\u00b0C. D020, Conditions = VDD = 2.0V, (Sleep mode). D020, Device = PIC18LFXX8X. D020, Typ = 0.2. D020, Max = 1. D020, Units = \uf06d A. D020, Conditions = +25\u00b0C.",
    "Power-down and Supply Current PIC18FXX8X (Industrial, Extended) PIC18LFXX8X (Industrial)\nD020, Conditions = VDD = 2.0V, (Sleep mode). D020, Device = PIC18LFXX8X. D020, Typ = 5.0. D020, Max = 10. D020, Units = \uf06d A. D020, Conditions = +85\u00b0C. D020, Conditions = VDD = 2.0V, (Sleep mode). D020A, Device = PIC18LFXX8X. D020A, Typ = 0.4. D020A, Max = 1. D020A, Units = \uf06d A. D020A, Conditions = -40\u00b0C. D020A, Conditions = VDD = 3.0V, (Sleep mode). D020A, Device = PIC18LFXX8X. D020A, Typ = 0.4. D020A, Max = 1. D020A, Units = \uf06d A. D020A, Conditions = +25\u00b0C. D020A, Conditions = VDD",
    "Power-down and Supply Current PIC18FXX8X (Industrial, Extended) PIC18LFXX8X (Industrial)\n= 3.0V, (Sleep mode). D020A, Device = PIC18LFXX8X. D020A, Typ = 3.0. D020A, Max = 18. D020A, Units = \uf06d A. D020A, Conditions = +85\u00b0C. D020A, Conditions = VDD = 3.0V, (Sleep mode). D020B, Device = All devices. D020B, Typ = 0.7. D020B, Max = 2. D020B, Units = \uf06d A. D020B, Conditions = -40\u00b0C. D020B, Conditions = VDD = 5.0V, (Sleep mode). D020B, Device = All devices. D020B, Typ = 0.7. D020B, Max = 2. D020B, Units = \uf06d A. D020B, Conditions = +25\u00b0C. D020B, Conditions = VDD = 5.0V, (Sleep",
    "Power-down and Supply Current PIC18FXX8X (Industrial, Extended) PIC18LFXX8X (Industrial)\nmode). D020B, Device = All devices. D020B, Typ = 15.0. D020B, Max = 32. D020B, Units = \uf06d A. D020B, Conditions = +85\u00b0C. D020B, Conditions = VDD = 5.0V, (Sleep mode)\nLegend: Shading of rows is to assist in readability of the table.\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.",
    "Power-down and Supply Current PIC18FXX8X (Industrial, Extended) PIC18LFXX8X (Industrial)\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.\n- 3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .",
    "27.2 DC Characteristics:\nPower-down and Supply Current PIC18FXX8X (Industrial, Extended) PIC18LFXX8X (Industrial) (Continued)\nPIC18LFXX8X\n(Industrial)\nPIC18FXX8X\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "27.2 DC Characteristics:\nD010, Device = Supply Current (I DD) (2,3). D010, Typ = Supply Current (I DD) (2,3). D010, Max = Supply Current (I DD) (2,3). D010, Units = Supply Current (I DD) (2,3). D010, Conditions = Supply Current (I DD) (2,3). D010, Conditions = Supply Current (I DD) (2,3). D010, Conditions = Supply Current (I DD) (2,3). , Device = PIC18LFXX8X. , Typ = 500. , Max = 500. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 2.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = . , Typ = 300. , Max = 500. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 2.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = . , Typ",
    "27.2 DC Characteristics:\n= 850. , Max = 1000. , Units = \uf06d A. , Conditions = +85\u00b0C. , Conditions = VDD = 2.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = PIC18LFXX8X. , Typ = 500. , Max = 900. , Units = \uf06d A. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = . , Typ = 500. , Max = 900. , Units = \uf06d A. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = . , Typ = 1. , Max = 1.5. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = All devices. , Typ = 1. , Max = 2. , Units = mA. , Conditions =",
    "27.2 DC Characteristics:\n-40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = . , Typ = 1. , Max = 2. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = . , Typ = 1.3. , Max = 3. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 1 MHZ, EC oscillator. , Device = PIC18LFXX8X. , Typ = 1. , Max = 2. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz, EC oscillator. , Device = . , Typ = 1. , Max = 2. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC",
    "27.2 DC Characteristics:\n= 4 MHz, EC oscillator. , Device = . , Typ = 1.5. , Max = 2.5. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 3.0V. , Conditions = FOSC = 4 MHz, EC oscillator. , Device = PIC18LFXX8X. , Typ = 1.5. , Max = 2. , Units = mA. , Conditions = -40\u00b0C. , Conditions = . , Conditions = FOSC = 4 MHz, EC oscillator. , Device = . , Typ = 1.5. , Max = 2. , Units = mA. , Conditions = +25\u00b0C. , Conditions = . , Conditions = FOSC = 4 MHz, EC oscillator. , Device = . , Typ = 2. , Max = 2.5. , Units = mA. , Conditions = +85\u00b0C. , Conditions = . , Conditions = FOSC = 4 MHz, EC oscillator. , Device = All devices. , Typ = 3. , Max = 5. , Units = mA. , Conditions =",
    "27.2 DC Characteristics:\n-40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHz, EC oscillator. , Device = . , Typ = 3. , Max = 5. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHz, EC oscillator. , Device = . , Typ = 4. , Max = 6. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 4 MHz, EC oscillator\nLegend:\nShading of rows is to assist in readability of the table.\nNote",
    "27.2 DC Characteristics:\n1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD; MCLR = VDD; WDT enabled/disabled as specified.\n- 3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .\n27.2 DC Characteristics:",
    "27.2 DC Characteristics:\nPIC18LFXX8X\n(Industrial)\nPIC18FXX8X",
    "PIC18F6585/8585/6680/8680\nPower-down and Supply Current PIC18FXX8X (Industrial, Extended) PIC18LFXX8X (Industrial) (Continued)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C\n\uf0a3 TA \uf0a3 +85\u00b0C for industrial\n-40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "PIC18F6585/8585/6680/8680\n, Device = Supply Current (I DD) (2,3). , Typ = Supply Current (I DD) (2,3). , Max = Supply Current (I DD) (2,3). , Units = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Conditions = Supply Current (I DD) (2,3). , Device = PIC18FXX8X. , Typ = 13. , Max = 27. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 25 MHZ, EC oscillator. , Device = PIC18FXX8X. , Typ = 15. , Max = 27. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 25 MHZ, EC oscillator. , Device = PIC18FXX8X. , Typ =",
    "PIC18F6585/8585/6680/8680\n19. , Max = 29. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 4.2V. , Conditions = FOSC = 25 MHZ, EC oscillator. , Device = PIC18FXX8X. , Typ = 17. , Max = 31. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 25 MHZ, EC oscillator. , Device = PIC18FXX8X. , Typ = 21. , Max = 31. , Units = mA. , Conditions = +25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 25 MHZ, EC oscillator. , Device = PIC18FXX8X. , Typ = 23. , Max = 34. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 25 MHZ, EC oscillator. , Device = PIC18FXX8X. ,",
    "PIC18F6585/8585/6680/8680\nTyp = 20. , Max = 34. , Units = mA. , Conditions = -40\u00b0C. , Conditions = . , Conditions = FOSC = 40 MHZ, EC oscillator. , Device = PIC18FXX8X. , Typ = 24. , Max = 34. , Units = mA. , Conditions = +25\u00b0C. , Conditions = . , Conditions = FOSC = 40 MHZ, EC oscillator. , Device = PIC18FXX8X. , Typ = 29. , Max = 44. , Units = mA. , Conditions = +85\u00b0C. , Conditions = . , Conditions = FOSC = 40 MHZ, EC oscillator. , Device = PIC18FXX8X. , Typ = 28. , Max = 46. , Units = mA. , Conditions = -40\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHZ, EC oscillator. , Device = PIC18FXX8X. , Typ = 33. , Max = 46. , Units = mA. , Conditions =",
    "PIC18F6585/8585/6680/8680\n+25\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHZ, EC oscillator. , Device = PIC18FXX8X. , Typ = 40. , Max = 51. , Units = mA. , Conditions = +85\u00b0C. , Conditions = VDD = 5.0V. , Conditions = FOSC = 40 MHZ, EC oscillator. D014, Device = PIC18LFXX8X. D014, Typ = 27. D014, Max = 45. D014, Units = \uf06d A. D014, Conditions = -10\u00b0C. D014, Conditions = VDD = 3.0V. D014, Conditions = FOSC = 32 kHz, Timer1 as clock. D014, Device = PIC18LFXX8X. D014, Typ = 30. D014, Max = 50. D014, Units = \uf06d A. D014, Conditions = +25\u00b0C. D014, Conditions = VDD = 3.0V. D014, Conditions",
    "PIC18F6585/8585/6680/8680\n= FOSC = 32 kHz, Timer1 as clock. D014, Device = PIC18LFXX8X. D014, Typ = 32. D014, Max = 54. D014, Units = \uf06d A. D014, Conditions = +70\u00b0C. D014, Conditions = VDD = 3.0V. D014, Conditions = FOSC = 32 kHz, Timer1 as clock. D014, Device = PIC18LFXX8X. D014, Typ = 33. D014, Max = 55. D014, Units = \uf06d A. D014, Conditions = -10\u00b0C. D014, Conditions = . D014, Conditions = FOSC = 32 kHz, Timer1 as clock. D014, Device = PIC18LFXX8X. D014, Typ = 36. D014, Max = 60. D014, Units = \uf06d A. D014, Conditions = +25\u00b0C. D014, Conditions = . D014, Conditions = FOSC = 32 kHz, Timer1 as clock.",
    "PIC18F6585/8585/6680/8680\nD014, Device = PIC18LFXX8X. D014, Typ = 39. D014, Max = 65. D014, Units = \uf06d A. D014, Conditions = +70\u00b0C. D014, Conditions = . D014, Conditions = FOSC = 32 kHz, Timer1 as clock. D014, Device = All devices. D014, Typ = 75. D014, Max = 125. D014, Units = \uf06d A. D014, Conditions = -10\u00b0C. D014, Conditions = VDD = 5.0V. D014, Conditions = FOSC = 32 kHz, Timer1 as clock. D014, Device = All devices. D014, Typ = 90. D014, Max = 150. D014, Units = \uf06d A. D014, Conditions = +25\u00b0C. D014, Conditions = VDD = 5.0V. D014, Conditions = FOSC = 32 kHz, Timer1 as clock. D014, Device = All devices. D014,",
    "PIC18F6585/8585/6680/8680\nTyp = 113. D014, Max = 188. D014, Units = \uf06d A. D014, Conditions = +70\u00b0C. D014, Conditions = VDD = 5.0V. D014, Conditions = FOSC = 32 kHz, Timer1 as clock\nLegend:\nShading of rows is to assist in readability of the table.\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:",
    "PIC18F6585/8585/6680/8680\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.\n- 3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .",
    "27.2 DC Characteristics:\nPower-down and Supply Current PIC18FXX8X (Industrial, Extended) PIC18LFXX8X (Industrial) (Continued)",
    "27.2 DC Characteristics:\nD022 ( \uf044 I WDT), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = <1. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 1.5. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "27.2 DC Characteristics:\n+85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 2.0V. D022 ( \uf044 I WDT),",
    "27.2 DC Characteristics:\nPIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = <1. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 2. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "27.2 DC Characteristics:\n+125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25 \uf0b0 C. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 2.0V. D022 ( \uf044 I WDT), PIC18LFXX8X (Industrial).PIC18FXX8X",
    "27.2 DC Characteristics:\n(Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 5. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 20. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044",
    "27.2 DC Characteristics:\nI BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +85 \uf0b0 C. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 2.0V. D022 ( \uf044 I WDT), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I",
    "27.2 DC Characteristics:\nBOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 3. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 10. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d",
    "27.2 DC Characteristics:\nA. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 3.0V. D022 ( \uf044 I WDT), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) =",
    "27.2 DC Characteristics:\nWatchdog Timer. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 3. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 20. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022 ( \uf044 I WDT), Conditions (unless otherwise",
    "27.2 DC Characteristics:\nstated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25 \uf0b0 C. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 3.0V. D022 ( \uf044 I WDT), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. D022 ( \uf044 I WDT), Standard Operating Operating",
    "27.2 DC Characteristics:\ntemperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 10. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 35. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating",
    "27.2 DC Characteristics:\nConditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +85 \uf0b0 C. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 3.0V. D022 ( \uf044 I WDT), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T",
    "27.2 DC Characteristics:\nA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 12. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 25. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "27.2 DC Characteristics:\n+85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 5.0V. D022 ( \uf044 I WDT), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3",
    "27.2 DC Characteristics:\n+125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 15. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 35. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C",
    "27.2 DC Characteristics:\nfor extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25 \uf0b0 C. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 5.0V. D022 ( \uf044 I WDT), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Watchdog Timer. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I",
    "27.2 DC Characteristics:\nWDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 20. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 50. D022 ( \uf044 I WDT), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I",
    "27.2 DC Characteristics:\nBOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +85 \uf0b0 C. D022 ( \uf044 I WDT), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 5.0V. D022A ( \uf044 I BOR), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Brown-out Reset. D022A ( \uf044 I BOR), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I",
    "27.2 DC Characteristics:\nOSCB, \uf044 I AD) = 55. D022A ( \uf044 I BOR), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 115. D022A ( \uf044 I BOR), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022A ( \uf044 I BOR), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I",
    "27.2 DC Characteristics:\nOSCB, \uf044 I AD) = -40 \uf0b0 C to +85 \uf0b0 C. D022A ( \uf044 I BOR), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 3.0V. D022A ( \uf044 I BOR), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Brown-out Reset. D022A ( \uf044 I BOR), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I",
    "27.2 DC Characteristics:\nAD) = 105. D022A ( \uf044 I BOR), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 175. D022A ( \uf044 I BOR), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022A ( \uf044 I BOR), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD)",
    "27.2 DC Characteristics:\n= -40 \uf0b0 C to +85 \uf0b0 C. D022A ( \uf044 I BOR), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 5.0V. D022B ( \uf044 I LVD ), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Low-Voltage Detect. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 45.",
    "27.2 DC Characteristics:\nD022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 125. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C to",
    "27.2 DC Characteristics:\n+85 \uf0b0 C. D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 2.0V. D022B ( \uf044 I LVD ), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Low-Voltage Detect. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 45. D022B ( \uf044 I",
    "27.2 DC Characteristics:\nLVD ), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 150. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C to +85 \uf0b0 C.",
    "27.2 DC Characteristics:\nD022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 3.0V. D022B ( \uf044 I LVD ), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Low-Voltage Detect. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 45. D022B ( \uf044 I LVD ),",
    "27.2 DC Characteristics:\nStandard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 225. D022B ( \uf044 I LVD ), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D022B ( \uf044 I LVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -40 \uf0b0 C to +85 \uf0b0 C. D022B ( \uf044 I",
    "27.2 DC Characteristics:\nLVD ), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = VDD = 5.0V. D025 ( \uf044 I OSCB), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 20. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating",
    "27.2 DC Characteristics:\nConditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 27. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -10 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3",
    "27.2 DC Characteristics:\nT A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1. D025 ( \uf044 I OSCB), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 20. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3",
    "27.2 DC Characteristics:\n+85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 30. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless",
    "27.2 DC Characteristics:\notherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1. D025 ( \uf044 I OSCB), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 25. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C",
    "27.2 DC Characteristics:\nfor extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 35. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +70 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for",
    "27.2 DC Characteristics:\nindustrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1. D025 ( \uf044 I OSCB), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 22. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I",
    "27.2 DC Characteristics:\nBOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 60. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -10 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for",
    "27.2 DC Characteristics:\nextended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1. D025 ( \uf044 I OSCB), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 22. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD)",
    "27.2 DC Characteristics:\n= 65. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044",
    "27.2 DC Characteristics:\nI LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1. D025 ( \uf044 I OSCB), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 25. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 75. D025 ( \uf044 I OSCB), Standard Operating Operating",
    "27.2 DC Characteristics:\ntemperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +70 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on",
    "27.2 DC Characteristics:\nTimer1. D025 ( \uf044 I OSCB), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 30. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 75. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3",
    "27.2 DC Characteristics:\nT A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = -10 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1. D025 ( \uf044 I OSCB),",
    "27.2 DC Characteristics:\nPIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 30. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 85. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3",
    "27.2 DC Characteristics:\nT A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1. D025 ( \uf044 I OSCB), PIC18LFXX8X (Industrial).PIC18FXX8X",
    "27.2 DC Characteristics:\n(Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = Timer1 Oscillator. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 35. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 100. D025 ( \uf044 I OSCB), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I",
    "27.2 DC Characteristics:\nWDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +70 \uf0b0 C. D025 ( \uf044 I OSCB), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 32 kHz on Timer1. D026 ( \uf044 I AD), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I",
    "27.2 DC Characteristics:\nBOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = A/D Converter. D026 ( \uf044 I AD), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = <1. D026 ( \uf044 I AD), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 2. D026 ( \uf044 I AD), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d",
    "27.2 DC Characteristics:\nA. D026 ( \uf044 I AD), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25 \uf0b0 C. D026 ( \uf044 I AD), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = A/D on, not converting. D026 ( \uf044 I AD), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = A/D",
    "27.2 DC Characteristics:\nConverter. D026 ( \uf044 I AD), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = <1. D026 ( \uf044 I AD), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 2. D026 ( \uf044 I AD), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D026 ( \uf044 I AD), Conditions (unless otherwise stated)",
    "27.2 DC Characteristics:\n-40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25 \uf0b0 C. D026 ( \uf044 I AD), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = A/D on, not converting. D026 ( \uf044 I AD), PIC18LFXX8X (Industrial).PIC18FXX8X (Industrial, Extended).Device.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = A/D Converter. D026 ( \uf044 I AD), Standard Operating Operating temperature.Standard",
    "27.2 DC Characteristics:\nOperating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Typ.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = <1. D026 ( \uf044 I AD), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Max.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = 2. D026 ( \uf044 I AD), Standard Operating Operating temperature.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Units.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = \uf06d A. D026 ( \uf044 I AD), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise",
    "27.2 DC Characteristics:\nstated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = +25 \uf0b0 C. D026 ( \uf044 I AD), Conditions (unless otherwise stated) -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial.Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended.Conditions.Module Differential Currents ( \uf044 I WDT, \uf044 I BOR, \uf044 I LVD , \uf044 I OSCB, \uf044 I AD) = A/D on, not converting\nLegend:\nShading of rows is to assist in readability of the table.",
    "27.2 DC Characteristics:\nNote 1: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD or VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, etc.).\n2: The supply current is mainly a function of operating voltage, frequency and mode. Other factors, such as I/O pin loading and switching rate, oscillator type and circuit, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD;\nMCLR = VDD; WDT enabled/disabled as specified.\n- 3: For RC oscillator configurations, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2REXT (mA) with REXT in k \uf057 .",
    "27.3 DC Characteristics: PIC18FXX8X (Industrial, Extended)\nPIC18LFXX8X (Industrial)\nDC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3\uf020 TA \uf0a3 +125\u00b0C for extended",
    "27.3 DC Characteristics: PIC18FXX8X (Industrial, Extended)\nD030 D030A D031 D032, Symbol = VIL. D030 D030A D031 D032, Characteristic = Input Low Voltage I/O ports: with TTL buffer. D030 D030A D031 D032, Min = VSS - VSS VSS VSS VSS. D030 D030A D031 D032, Max = 0.15 VDD 0.8 0.2 VDD 0.3 VDD 0.2 VDD 0.3 VDD. D030 D030A D031 D032, Units = V V V V V V. D030 D030A D031 D032, Conditions = VDD < 4.5V 4.5V \uf0a3 VDD \uf0a3\uf020 5.5V. D032A D033 D040, Symbol = VIH. D032A D033 D040, Characteristic = OSC1 (in XT, HS and LP and T1OSI OSC1 (in RC and EC mode) (1) Input High Voltage",
    "27.3 DC Characteristics: PIC18FXX8X (Industrial, Extended)\nI/O ports: with TTL buffer. D032A D033 D040, Min = VSS 0.25 VDD + 0.8V 2.0. D032A D033 D040, Max = 0.2 VDD VDD. D032A D033 D040, Units = V V. D032A D033 D040, Conditions = VDD < 4.5V 4.5V \uf0a3 VDD \uf0a3\uf020 5.5V. D040A D041 D042 D042A, Symbol = . D040A D041 D042 D042A, Characteristic = with Schmitt Trigger buffer RC3 and RC4 MCLR, OSC1 (EC mode) OSC1 (in XT, HS and LP modes) and T1OSI (1). D040A D041 D042 D042A, Min = 0.8 VDD 0.7 VDD 0.8 VDD 0.7 VDD. D040A D041 D042 D042A, Max =",
    "27.3 DC Characteristics: PIC18FXX8X (Industrial, Extended)\nVDD VDD VDD VDD VDD. D040A D041 D042 D042A, Units = V V V V V. D040A D041 D042 D042A, Conditions = . D043 D060, Symbol = I IL. D043 D060, Characteristic = OSC1 (RC mode) Input Leakage Current (2,3) I/O ports. D043 D060, Min = 0.9 VDD -. D043 D060, Max = VDD. D043 D060, Units = V \uf06d A. D043 D060, Conditions = . , Symbol = . , Characteristic = . , Min = -. , Max = \uf0b1 1. , Units = . , Conditions = VSS \uf0a3\uf020 VPIN \uf0a3\uf020 VDD, Pin at high-impedance. D061, Symbol = . D061, Characteristic = MCLR. D061, Min = . D061, Max = \uf0b1 5. D061, Units = \uf06d A. D061, Conditions = Vss \uf0a3\uf020 VPIN \uf0a3\uf020",
    "27.3 DC Characteristics: PIC18FXX8X (Industrial, Extended)\nVDD Vss \uf0a3\uf020 VPIN \uf0a3\uf020 VDD. D063, Symbol = I PU. D063, Characteristic = OSC1. D063, Min = -. D063, Max = \uf0b1 5. D063, Units = \uf06d A. D063, Conditions = . , Symbol = I PURB. , Characteristic = Weak Pull-up Current. , Min = 50. , Max = . , Units = \uf06d A. , Conditions = VDD = 5V, VPIN =. D070, Symbol = . D070, Characteristic = PORTB weak pull-up current. D070, Min = . D070, Max = 400. D070, Units = . D070, Conditions = VSS",
    "27.3 DC Characteristics: PIC18FXX8X (Industrial, Extended)\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PIC device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.\n4: Parameter is characterized but not tested.\nPIC18LFXX8X (Industrial) (Continued)",
    "DC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3\uf020 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3\uf020 TA \uf0a3 +125\u00b0C for extended",
    "DC CHARACTERISTICS\nD080, Symbol = VOL. D080, Characteristic = Output Low Voltage I/O ports. D080, Min = -. D080, Max = 0.6. D080, Units = V. D080, Conditions = I OL = 8.5 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D080A, Symbol = . D080A, Characteristic = . D080A, Min = -. D080A, Max = 0.6. D080A, Units = V. D080A, Conditions = I OL = 7.0 mA, VDD = 4.5V, -40 \uf0b0 C to +125 \uf0b0 C. D083, Symbol = . D083, Characteristic = OSC2/CLKO (RC mode). D083, Min = -. D083, Max = 0.6. D083, Units = V. D083, Conditions = I OL = 1.6 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D083A, Symbol = .",
    "DC CHARACTERISTICS\nD083A, Characteristic = . D083A, Min = -. D083A, Max = 0.6. D083A, Units = V. D083A, Conditions = I OL = 1.2 mA, VDD = 4.5V, -40 \uf0b0 C to +125 \uf0b0 C. D090, Symbol = VOH. D090, Characteristic = Output High Voltage (3) I/O ports. D090, Min = VDD - 0.7. D090, Max = -. D090, Units = V. D090, Conditions = I OH = -3.0 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D090A, Symbol = . D090A, Characteristic = . D090A, Min = VDD - 0.7. D090A, Max = -. D090A, Units = V. D090A, Conditions = I OH = -2.5 mA, VDD = 4.5V, -40 \uf0b0 C to +125 \uf0b0 C. D092, Symbol = . D092, Characteristic =",
    "DC CHARACTERISTICS\nOSC2/CLKO (RC mode). D092, Min = VDD - 0.7. D092, Max = -. D092, Units = V. D092, Conditions = I OH = -1.3 mA, VDD = 4.5V, -40 \uf0b0 C to +85 \uf0b0 C. D092A, Symbol = . D092A, Characteristic = . D092A, Min = VDD - 0.7. D092A, Max = -. D092A, Units = V. D092A, Conditions = I OH = -1.0 mA, VDD = 4.5V, -40 \uf0b0 C to +125 \uf0b0 C. D150, Symbol = VOD. D150, Characteristic = Open-Drain High Voltage. D150, Min = -. D150, Max = 8.5. D150, Units = V. D150, Conditions = RA4 pin. D100 (4), Symbol = COSC2. D100 (4), Characteristic = on Output Pins OSC2 pin. D100 (4), Min =",
    "DC CHARACTERISTICS\n-. D100 (4), Max = 15. D100 (4), Units = pF. D100 (4), Conditions = In XT, HS and LP modes when external clock is used to drive OSC1. D101, Symbol = CIO. D101, Characteristic = All I/O pins and OSC2 (in RC mode). D101, Min = -. D101, Max = 50. D101, Units = pF. D101, Conditions = To meet the AC Timing Specifications. D102, Symbol = CB. D102, Characteristic = SCL, SDA. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = In I 2 C mode",
    "DC CHARACTERISTICS\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PIC device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.\n4: Parameter is characterized but not tested.",
    "TABLE 27-1: COMPARATOR SPECIFICATIONS\nOperating Conditions: 3.0V < VDD < 5.5V, -40\u00b0C < TA < +125\u00b0C, unless otherwise stated",
    "TABLE 27-1: COMPARATOR SPECIFICATIONS\nD300, Sym = VIOFF. D300, Characteristics = Input Offset Voltage. D300, Min = -. D300, Typ = \u00b1 5.0. D300, Max = \u00b1 10. D300, Units = mV. D300, Comments = . D301, Sym = VICM. D301, Characteristics = Input Common Mode Voltage. D301, Min = 0. D301, Typ = -. D301, Max = VDD - 1.5. D301, Units = V. D301, Comments = . D302, Sym = CMRR. D302, Characteristics = Common Mode Rejection Ratio. D302, Min = 55. D302, Typ = -. D302, Max = -. D302, Units = dB. D302, Comments = . 300 300A, Sym = TRESP. 300 300A, Characteristics = Response Time (1). 300 300A, Min = -. 300 300A, Typ = 150. 300 300A, Max = 400 600. 300 300A, Units = ns",
    "TABLE 27-1: COMPARATOR SPECIFICATIONS\nns. 300 300A, Comments = PIC18FXX8X PIC18LFXX8X. 301, Sym = TMC2OV. 301, Characteristics = Comparator Mode Change to Output Valid. 301, Min = -. 301, Typ = -. 301, Max = 10. 301, Units = \uf06d s. 301, Comments = \n- Note 1: Response time measured with one comparator input at (VDD - 1.5)/2 while the other input transitions from VSS to VDD.",
    "TABLE 27-2: VOLTAGE REFERENCE SPECIFICATIONS\nOperating Conditions: 3.0V < VDD < 5.5V, -40\u00b0C < TA < +125\u00b0C, unless otherwise stated",
    "TABLE 27-2: VOLTAGE REFERENCE SPECIFICATIONS\nD310, Sym = VRES. D310, Characteristics = Resolution. D310, Min = VDD /24. D310, Typ = -. D310, Max = VDD /32. D310, Units = LSb. D310, Comments = . D311, Sym = VRAA. D311, Characteristics = Absolute Accuracy. D311, Min = -. D311, Typ = -. D311, Max = 1/4. D311, Units = LSb. D311, Comments = Low Range (VRR = 1 ). , Sym = . , Characteristics = . , Min = -. , Typ = -. , Max = 1/2. , Units = LSb. , Comments = High Range (VRR = 0 ). D312, Sym = VRUR. D312, Characteristics = Unit Resistor Value (R). D312, Min = -. D312, Typ = 2k. D312, Max = -. D312, Units = \uf057. D312, Comments = . 310, Sym",
    "TABLE 27-2: VOLTAGE REFERENCE SPECIFICATIONS\n= T SET. 310, Characteristics = Settling Time (1). 310, Min = -. 310, Typ = -. 310, Max = 10. 310, Units = \uf06d s. 310, Comments = \nNote 1: Settling time measured while VRR = 1 and VR<3:0> transitions from 0000 to 1111 .",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+85\u00b0C for industrial\n-40\u00b0C\n\uf0a3\nTA\n\uf0a3\n+125\u00b0C for extended",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 0000. D420, Min = -. D420, Typ\u2020 = -. D420, Max = -. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 0001. D420, Min = 1.96. D420, Typ\u2020 = 2.06. D420, Max = 2.16. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 0010. D420, Min = 2.16. D420, Typ\u2020 = 2.27. D420, Max = 2.38. D420, Units = V. D420, Conditions = .",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 0011. D420, Min = 2.35. D420, Typ\u2020 = 2.47. D420, Max = 2.59. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 0100. D420, Min = 2.46. D420, Typ\u2020 = 2.58. D420, Max = 2.71. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 0101. D420, Min = 2.64. D420, Typ\u2020 = 2.78. D420, Max = 2.92. D420, Units = V.",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 0110. D420, Min = 2.75. D420, Typ\u2020 = 2.89. D420, Max = 3.03. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 0111. D420, Min = 2.95. D420, Typ\u2020 = 3.1. D420, Max = 3.26. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 1000. D420, Min = 3.24. D420, Typ\u2020 = 3.41. D420, Max = 3.58.",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 1001. D420, Min = 3.43. D420, Typ\u2020 = 3.61. D420, Max = 3.79. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 1010. D420, Min = 3.53. D420, Typ\u2020 = 3.72. D420, Max = 3.91. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 1011. D420, Min = 3.72. D420, Typ\u2020 = 3.92. D420,",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\nMax = 4.12. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 1100. D420, Min = 3.92. D420, Typ\u2020 = 4.13. D420, Max = 4.33. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 1101. D420, Min = 4.11. D420, Typ\u2020 = 4.33. D420, Max = 4.55. D420, Units = V. D420, Conditions = . D420, Symbol = . D420, Characteristic = LVD Voltage on VDD transition high to low. D420, Characteristic = LVV = 1110. D420, Min = 4.41. D420, Typ\u2020 =",
    "TABLE 27-3: LOW-VOLTAGE DETECT CHARACTERISTICS\n4.64. D420, Max = 4.87. D420, Units = V. D420, Conditions = . D423, Symbol = VBG. D423, Characteristic = Band Gap Reference Voltage Value. D423, Characteristic = Band Gap Reference Voltage Value. D423, Min = -. D423, Typ\u2020 = 1.22. D423, Max = -. D423, Units = V. D423, Conditions = \n- \u2020 Production tested at TAMB = 25\u00b0C. Specifications over temperature limits ensured by characterization.",
    "Standard Operating Conditions (unless otherwise stated)\nDC Characteristics\nOperating temperature -40\u00b0C \uf0a3 TA \uf0a3 +85\u00b0C for industrial -40\u00b0C \uf0a3 TA \uf0a3 +125\u00b0C for extended",
    "Standard Operating Conditions (unless otherwise stated)\n, Sym = . , Characteristic = Internal Program Memory Programming Specifications (Note 1). , Min = . , Typ\u2020 = . , Max = . , Units = . , Conditions = . D110, Sym = VPP. D110, Characteristic = Voltage on MCLR/VPP pin. D110, Min = 9.00. D110, Typ\u2020 = -. D110, Max = 13.25. D110, Units = V. D110, Conditions = (Note 2). D112, Sym = I PP. D112, Characteristic = Current into MCLR/VPP pin. D112, Min = -. D112, Typ\u2020 = -. D112, Max = 5. D112, Units = \uf06d A. D112, Conditions = . D113, Sym = I DDP. D113, Characteristic = Supply Current during Programming. D113, Min = -. D113, Typ\u2020 = -. D113, Max = 10. D113, Units = mA. D113, Conditions = . , Sym = .",
    "Standard Operating Conditions (unless otherwise stated)\n, Characteristic = Data EEPROM Memory. , Min = . , Typ\u2020 = . , Max = . , Units = . , Conditions = . D120, Sym = ED. D120, Characteristic = Cell Endurance. D120, Min = 100K. D120, Typ\u2020 = 1M. D120, Max = -. D120, Units = E/W. D120, Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D120A, Sym = ED. D120A, Characteristic = Cell Endurance. D120A, Min = 10K. D120A, Typ\u2020 = 100K. D120A, Max = -. D120A, Units = E/W. D120A, Conditions = +85 \uf0b0 C to +125 \uf0b0 C. D121, Sym = VDRW. D121, Characteristic = VDD for Read/Write. D121, Min = VMIN. D121, Typ\u2020 = -. D121, Max = 5.5. D121, Units = V. D121, Conditions = Using EECON",
    "Standard Operating Conditions (unless otherwise stated)\nto read/write, VMIN = Minimum operating voltage. D122, Sym = TDEW. D122, Characteristic = Erase/Write Cycle Time. D122, Min = -. D122, Typ\u2020 = 4. D122, Max = -. D122, Units = ms. D122, Conditions = . D123, Sym = TRETD. D123, Characteristic = Characteristic Retention. D123, Min = 40. D123, Typ\u2020 = -. D123, Max = -. D123, Units = Year. D123, Conditions = -40 \uf0b0 C to +85 \uf0b0 C (Note 3). D123A, Sym = TRETD. D123A, Characteristic = Characteristic Retention. D123A, Min = 100. D123A, Typ\u2020 = -. D123A, Max = -. D123A, Units = Year. D123A, Conditions = 25 \uf0b0 C (Note 3). , Sym = . , Characteristic = Program Flash Memory. , Min = . , Typ\u2020 = . , Max = . ,",
    "Standard Operating Conditions (unless otherwise stated)\nUnits = . , Conditions = . D130, Sym = EP. D130, Characteristic = Cell Endurance. D130, Min = 10K. D130, Typ\u2020 = 100K. D130, Max = -. D130, Units = E/W. D130, Conditions = -40 \uf0b0 C to +85 \uf0b0 C. D130A, Sym = EP. D130A, Characteristic = Cell Endurance. D130A, Min = 1000. D130A, Typ\u2020 = 10K. D130A, Max = -. D130A, Units = E/W. D130A, Conditions = +85 \uf0b0 C to +125 \uf0b0 C. D131, Sym = VPR. D131, Characteristic = VDD for Read. D131, Min = VMIN. D131, Typ\u2020 = -. D131, Max = 5.5. D131, Units = V. D131, Conditions = VMIN = Minimum operating voltage. D132, Sym = VIE. D132, Characteristic = VDD for Block Erase.",
    "Standard Operating Conditions (unless otherwise stated)\nD132, Min = 4.5. D132, Typ\u2020 = -. D132, Max = 5.5. D132, Units = V. D132, Conditions = Using ICSP port. D132A, Sym = VIW. D132A, Characteristic = VDD for Externally Timed Erase or Write. D132A, Min = 4.5. D132A, Typ\u2020 = -. D132A, Max = 5.5. D132A, Units = V. D132A, Conditions = Using ICSP port. D132B, Sym = VPEW. D132B, Characteristic = VDD for Self-timed Write. D132B, Min = VMIN. D132B, Typ\u2020 = -. D132B, Max = 5.5. D132B, Units = V. D132B, Conditions = VMIN = Minimum operating voltage. D133, Sym = TIE. D133, Characteristic = ICSP Block Erase Cycle Time. D133, Min = -. D133, Typ\u2020",
    "Standard Operating Conditions (unless otherwise stated)\n= 5. D133, Max = -. D133, Units = ms. D133, Conditions = VDD > 4.5V. D133A, Sym = TIW. D133A, Characteristic = ICSP Erase or Write Cycle Time (externally timed). D133A, Min = 1. D133A, Typ\u2020 = -. D133A, Max = -. D133A, Units = ms. D133A, Conditions = VDD > 4.5V. D133A, Sym = TIW. D133A, Characteristic = Self-timed Write Cycle Time. D133A, Min = -. D133A, Typ\u2020 = 2.5. D133A, Max = -. D133A, Units = ms. D133A, Conditions = . D134, Sym = TRETD. D134, Characteristic = Characteristic Retention. D134, Min = 40. D134, Typ\u2020 = -. D134, Max = -. D134, Units = Year. D134, Conditions",
    "Standard Operating Conditions (unless otherwise stated)\n= -40 \uf0b0 C to +85 \uf0b0 C (Note 3). D134A, Sym = TRETD. D134A, Characteristic = Characteristic Retention. D134A, Min = 100. D134A, Typ\u2020 = -. D134A, Max = -. D134A, Units = Year. D134A, Conditions = 25 \uf0b0 C (Note 3)\n\u2020 Data in 'Typ' column is at 5.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nNote 1: These specifications are for programming the on-chip program memory through the use of table write instructions.\n2: The pin may be kept in this range at times other than programming but it is not recommended.\n3: Retention time is valid provided no other specifications are violated.",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nThe  timing  parameter  symbols  have  been  created following one of the following formats:",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nT, 1. TppS2ppS.2. TppS = T. T, 3. T CC: ST.4. Ts = . T, (I 2 C specifications only) 2.(I C specifications only) = . F, 1. TppS2ppS.2. TppS = Frequency. F, 3. T CC: ST.4. Ts = T. F, (I 2 C specifications only) 2.(I C specifications only) = Time. Lowercase letters (pp) and their meanings:, 1. TppS2ppS.2. TppS = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, 3. T CC: ST.4. Ts = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, (I 2 C specifications only) 2.(I C specifications only) = Lowercase letters (pp) and their meanings:. pp, 1. TppS2ppS.2. TppS = pp. pp, 3. T CC: ST.4. Ts = . pp, (I 2 C specifications only)",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\n2.(I C specifications only) = . cc, 1. TppS2ppS.2. TppS = CCP1. cc, 3. T CC: ST.4. Ts = osc. cc, (I 2 C specifications only) 2.(I C specifications only) = OSC1. ck, 1. TppS2ppS.2. TppS = CLKO. ck, 3. T CC: ST.4. Ts = rd. ck, (I 2 C specifications only) 2.(I C specifications only) = RD. cs, 1. TppS2ppS.2. TppS = CS. cs, 3. T CC: ST.4. Ts = rw. cs, (I 2 C specifications only) 2.(I C specifications only) = RD or WR. di, 1. TppS2ppS.2. TppS = SDI. di, 3. T CC: ST.4. Ts = sc. di, (I 2 C specifications only) 2.(I C specifications only) = SCK. do, 1. TppS2ppS.2. TppS = SDO. do, 3. T",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nCC: ST.4. Ts = ss. do, (I 2 C specifications only) 2.(I C specifications only) = SS. dt, 1. TppS2ppS.2. TppS = Data in. dt, 3. T CC: ST.4. Ts = t0. dt, (I 2 C specifications only) 2.(I C specifications only) = T0CKI. io, 1. TppS2ppS.2. TppS = I/O port. io, 3. T CC: ST.4. Ts = t1. io, (I 2 C specifications only) 2.(I C specifications only) = T1CKI. mc, 1. TppS2ppS.2. TppS = MCLR. mc, 3. T CC: ST.4. Ts = wr. mc, (I 2 C specifications only) 2.(I C specifications only) = WR. Uppercase letters and their meanings:, 1. TppS2ppS.2. TppS = Uppercase letters and their meanings:. Uppercase letters and their meanings:, 3. T CC: ST.4. Ts = Uppercase letters and their",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nmeanings:. Uppercase letters and their meanings:, (I 2 C specifications only) 2.(I C specifications only) = Uppercase letters and their meanings:. S, 1. TppS2ppS.2. TppS = S. S, 3. T CC: ST.4. Ts = . S, (I 2 C specifications only) 2.(I C specifications only) = . F, 1. TppS2ppS.2. TppS = Fall. F, 3. T CC: ST.4. Ts = P. F, (I 2 C specifications only) 2.(I C specifications only) = Period. H, 1. TppS2ppS.2. TppS = High. H, 3. T CC: ST.4. Ts = R. H, (I 2 C specifications only) 2.(I C specifications only) = Rise. I, 1. TppS2ppS.2. TppS = Invalid (high-impedance). I, 3. T CC: ST.4. Ts = V. I, (I 2 C specifications only) 2.(I C specifications only) = Valid. L, 1.",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\nTppS2ppS.2. TppS = Low. L, 3. T CC: ST.4. Ts = Z. L, (I 2 C specifications only) 2.(I C specifications only) = High-impedance. I 2 C only, 1. TppS2ppS.2. TppS = I 2 C only. I 2 C only, 3. T CC: ST.4. Ts = . I 2 C only, (I 2 C specifications only) 2.(I C specifications only) = . AA, 1. TppS2ppS.2. TppS = output access. AA, 3. T CC: ST.4. Ts = High. AA, (I 2 C specifications only) 2.(I C specifications only) = High. BUF, 1. TppS2ppS.2. TppS = Bus free. BUF, 3. T CC: ST.4. Ts = Low. BUF, (I 2 C specifications only) 2.(I C specifications only) = Low. T CC: ST (I 2 C specifications only), 1. TppS2ppS.2. TppS = T CC: ST",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\n(I 2 C specifications only). T CC: ST (I 2 C specifications only), 3. T CC: ST.4. Ts = T CC: ST (I 2 C specifications only). T CC: ST (I 2 C specifications only), (I 2 C specifications only) 2.(I C specifications only) = T CC: ST (I 2 C specifications only). CC, 1. TppS2ppS.2. TppS = CC. CC, 3. T CC: ST.4. Ts = . CC, (I 2 C specifications only) 2.(I C specifications only) = . HD, 1. TppS2ppS.2. TppS = Hold. HD, 3. T CC: ST.4. Ts = SU. HD, (I 2 C specifications only) 2.(I C specifications only) = Setup. ST, 1. TppS2ppS.2. TppS = ST. ST, 3. T CC: ST.4. Ts = ST. ST, (I 2 C specifications only) 2.(I C specifications only) = ST. DAT, 1. TppS2ppS.2. TppS",
    "27.4.1 TIMING PARAMETER SYMBOLOGY\n= DATA input hold. DAT, 3. T CC: ST.4. Ts = STO. DAT, (I 2 C specifications only) 2.(I C specifications only) = Stop condition. STA, 1. TppS2ppS.2. TppS = Start condition. STA, 3. T CC: ST.4. Ts = . STA, (I 2 C specifications only) 2.(I C specifications only) = ",
    "27.4.2 TIMING CONDITIONS\nThe temperature and voltages specified in Table 27-5 apply  to  all timing  specifications  unless  otherwise noted. Figure 27-5 specifies the load conditions for the timing specifications.",
    "TABLE 27-5: TEMPERATURE AND VOLTAGE SPECIFICATIONS - AC\nAC CHARACTERISTICS, 1 = Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \uf0a3 T A \uf0a3\uf020 +85\u00b0C for industrial -40\u00b0C \uf0a3 T A \uf0a3 +125\u00b0C for extended Operating voltage VDD range as described in DC spec Section 27.1 and Section 27.3 . LC parts operate for industrial temperatures only.",
    "FIGURE 27-5: LOAD CONDITIONS FOR DEVICE TIMING SPECIFICATIONS\nVDD /2 CL RL VSS, Load condition 2 = Pin VSS CL for all pins except OSC2/CLKO and including D and E outputs as ports",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\n1A, Symbol = FOSC. 1A, Characteristic = External CLKI Frequency (1) Oscillator Frequency (1). 1A, Min = DC DC DC DC DC 0.1 4 4 4 4 4 4 DC. 1A, Max = 40 25 25 16 4 4 25 25 25 16 10 6.25 200. 1A, Units = MHz MHz MHz MHz MHz MHz MHz MHz MHz MHz MHz MHz kHz. 1A, Conditions = EC, ECIO, -40\u00b0C to +85\u00b0C EC,ECIO, -40\u00b0C to +85\u00b0C, EMA EC, ECIO, +85\u00b0C to +125\u00b0C EC, ECIO, +85\u00b0C to +125\u00b0C, EMA RC oscillator XT oscillator HS oscillator, -40\u00b0C to +85\u00b0C HS oscillator, -40\u00b0C to +85\u00b0C, EMA HS oscillator, +85\u00b0C to +125\u00b0C HS oscillator, +85\u00b0C to +125\u00b0C, EMA HS + PLL oscillator, -40\u00b0C to +85\u00b0C",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\nHS + PLL oscillator, +85\u00b0C to +125\u00b0C LP oscillator. 1, Symbol = T OSC. 1, Characteristic = External CLKI Period (1) Oscillator Period (1). 1, Min = 25 40 40 62.5 250 250 40 40 40 62.5 100 160 5. 1, Max = - - - - - 10,000 - - - - 250 250 200. 1, Units = ns ns ns ns ns ns ns ns ns ns ns ns \uf06d s. 1, Conditions = EC, ECIO, -40\u00b0C to +85\u00b0C EC,ECIO, -40\u00b0C to +85\u00b0C, EMA EC, ECIO, +85\u00b0C to +125\u00b0C EC, ECIO, +85\u00b0C to +125\u00b0C, EMA RC oscillator XT oscillator HS oscillator, -40\u00b0C to +85\u00b0C HS oscillator, -40\u00b0C to +85\u00b0C, EMA HS oscillator, +85\u00b0C to +125\u00b0C HS oscillator, +85\u00b0C",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\nto +125\u00b0C, EMA HS + PLL oscillator, -40\u00b0C to +85\u00b0C HS + PLL oscillator, +85\u00b0C to +125\u00b0C LP oscillator. 2, Symbol = T CY. 2, Characteristic = Instruction Cycle Time (1). 2, Min = 100 160. 2, Max = - -. 2, Units = ns ns. 2, Conditions = T CY = 4/F OSC, -40\u00b0C to +85\u00b0C T CY = 4/F OSC, +85\u00b0C to +125\u00b0C. 3, Symbol = T OSL, T OSH. 3, Characteristic = External Clock in (OSC1) High or Low Time. 3, Min = 30 2.5 10. 3, Max = - - -. 3, Units = ns \uf06d s ns. 3, Conditions = XT oscillator LP oscillator HS oscillator. 4, Symbol = T OSR, T OSF. 4, Characteristic = External Clock in (OSC1) Rise or Fall Time. 4, Min = - - -. 4, Max =",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\n20 50 7.5. 4, Units = ns ns ns. 4, Conditions = XT oscillator LP oscillator HS oscillator\nNote 1: Instruction cycle period (TCY) equals four times the input oscillator time base period for all configurations except PLL. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min.' values with an external clock applied to the OSC1/CLKI pin. When an external clock input is used, the 'max.' cycle time limit is 'DC' (no clock) for all devices.",
    "TABLE 27-7: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2 TO 5.5V)\n-, Sym = FOSC. -, Characteristic = Oscillator Frequency Range. -, Min = 4. -, Typ\u2020 = -. -, Max = 10. -, Units = MHz. -, Conditions = HS mode. -, Sym = FSYS. -, Characteristic = On-Chip VCO System Frequency. -, Min = 16. -, Typ\u2020 = -. -, Max = 40. -, Units = MHz. -, Conditions = HS mode. -, Sym = t rc. -, Characteristic = PLL Start-up Time (Lock Time). -, Min = -. -, Typ\u2020 = -. -, Max = 2. -, Units = ms. -, Conditions = . -, Sym = \uf044 CLK. -, Characteristic = CLKO Stability (Jitter). -, Min = -2. -, Typ\u2020 = -. -, Max = +2. -, Units = %. -, Conditions = ",
    "TABLE 27-7: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2 TO 5.5V)\n- \u2020 Data in 'Typ' column is at 5V, 25 C, unless otherwise stated. These parameters are for design guidance \uf0b0 only and are not tested.",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\n10, Symbol = T OSH2CKL. 10, Characteristic = OSC1 \uf0ad to CLKO \uf0af. 10, Characteristic = OSC1 \uf0ad to CLKO \uf0af. 10, Min = -. 10, Typ = 75. 10, Max = 200. 10, Units = ns. 10, Conditions = (1). 11, Symbol = T OSH2CKH. 11, Characteristic = OSC1 \uf0ad to CLKO \uf0ad. 11, Characteristic = OSC1 \uf0ad to CLKO \uf0ad. 11, Min = -. 11, Typ = 75. 11, Max = 200. 11, Units = ns. 11, Conditions = (1). 12, Symbol = T CK R. 12, Characteristic = CLKO Rise Time. 12, Characteristic = CLKO Rise Time. 12, Min = -. 12, Typ = 35. 12, Max = 100. 12, Units = ns. 12, Conditions = (1). 13, Symbol = T CK F. 13, Characteristic = CLKO Fall Time. 13, Characteristic = CLKO Fall Time. 13, Min = -. 13, Typ = 35. 13, Max = 100. 13, Units = ns.",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\n13, Conditions = (1). 14, Symbol = T CK L2IO V. 14, Characteristic = CLKO \uf0af to Port Out Valid. 14, Characteristic = CLKO \uf0af to Port Out Valid. 14, Min = -. 14, Typ = -. 14, Max = 0.5 T CY + 20. 14, Units = ns. 14, Conditions = (1). 15, Symbol = TIO V2CKH. 15, Characteristic = Port In Valid before CLKO \uf0ad. 15, Characteristic = Port In Valid before CLKO \uf0ad. 15, Min = 0.25 T CY + 25. 15, Typ = -. 15, Max = -. 15, Units = ns. 15, Conditions = (1). 16, Symbol = T CK H2IO I. 16, Characteristic = Port In Hold after CLKO \uf0ad. 16, Characteristic = Port In Hold after CLKO \uf0ad. 16, Min = 0. 16, Typ = -. 16, Max = -. 16, Units = ns. 16, Conditions = (1). 17, Symbol = T OSH2IO V. 17, Characteristic = OSC1 \uf0ad (Q1 cycle) to Port",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\nOut Valid. 17, Characteristic = OSC1 \uf0ad (Q1 cycle) to Port Out Valid. 17, Min = -. 17, Typ = 50. 17, Max = 150. 17, Units = ns. 17, Conditions = . 18 18A, Symbol = T OSH2IO I. 18 18A, Characteristic = OSC1 \uf0ad (Q2 cycle) to Port Input Invalid (I/O in hold time). 18 18A, Characteristic = PIC18FXX8X. 18 18A, Min = 100. 18 18A, Typ = -. 18 18A, Max = -. 18 18A, Units = ns. 18 18A, Conditions = . 18 18A, Symbol = T OSH2IO I. 18 18A, Characteristic = OSC1 \uf0ad (Q2 cycle) to Port Input Invalid (I/O in hold time). 18 18A, Characteristic = PIC18LFXX8X. 18 18A, Min = 200. 18 18A, Typ = -. 18 18A, Max = -. 18 18A, Units = ns. 18 18A, Conditions = . 19, Symbol = TIO",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\nV2OSH. 19, Characteristic = Port Input Valid to OSC1 \uf0ad\uf020 (I/O in setup time). 19, Characteristic = Port Input Valid to OSC1 \uf0ad\uf020 (I/O in setup time). 19, Min = 0. 19, Typ = -. 19, Max = -. 19, Units = ns. 19, Conditions = . 20 20A, Symbol = TIO R. 20 20A, Characteristic = Port Output Rise Time. 20 20A, Characteristic = PIC18FXX8X. 20 20A, Min = -. 20 20A, Typ = 10. 20 20A, Max = 25. 20 20A, Units = ns. 20 20A, Conditions = . 20 20A, Symbol = TIO R. 20 20A, Characteristic = Port Output Rise Time. 20 20A, Characteristic = PIC18LFXX8X. 20 20A, Min = -. 20 20A, Typ = -. 20 20A, Max = 60. 20 20A, Units = ns. 20 20A, Conditions = . 21, Symbol = TIO F. 21, Characteristic = Port Output Fall Time. 21, Characteristic =",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\nPIC18FXX8X. 21, Min = -. 21, Typ = 10. 21, Max = 25. 21, Units = ns. 21, Conditions = . 21A, Symbol = TIO F. 21A, Characteristic = Port Output Fall Time. 21A, Characteristic = PIC18LFXX8X. 21A, Min = -. 21A, Typ = -. 21A, Max = 60. 21A, Units = ns. 21A, Conditions = . 22\u2020, Symbol = TINP. 22\u2020, Characteristic = INT pin High or Low Time. 22\u2020, Characteristic = INT pin High or Low Time. 22\u2020, Min = T CY. 22\u2020, Typ = -. 22\u2020, Max = -. 22\u2020, Units = ns. 22\u2020, Conditions = . 23\u2020, Symbol = TRBP. 23\u2020, Characteristic = RB7:RB4 Change INT High or Low Time. 23\u2020, Characteristic = RB7:RB4 Change INT High or Low Time. 23\u2020, Min = T CY. 23\u2020, Typ = -. 23\u2020, Max = -. 23\u2020, Units =",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\nns. 23\u2020, Conditions = . 24\u2020, Symbol = TRCP. 24\u2020, Characteristic = RC7:RC4 Change INT High or Low Time. 24\u2020, Characteristic = RC7:RC4 Change INT High or Low Time. 24\u2020, Min = 20. 24\u2020, Typ = . 24\u2020, Max = . 24\u2020, Units = ns. 24\u2020, Conditions = \n\u2020 These parameters are asynchronous events not related to any internal clock edges.\nNote 1: Measurements are taken in RC mode, where CLKO output is 4 x TOSC.",
    "PIC18F6585/8585/6680/8680\n\nTABLE 27-9: PROGRAM MEMORY READ TIMING REQUIREMENTS (VDD = 4.2 TO 5.5V)",
    "PIC18F6585/8585/6680/8680\n150, Symbol = T ADV2ALL. 150, Characteristics = Address Out Valid to ALE \uf0af\uf020 (address setup time). 150, Min = 0.25 T CY - 10. 150, Typ = -. 150, Max = -. 150, Units = ns. 151, Symbol = T AL L2ADL. 151, Characteristics = ALE \uf0af to Address Out Invalid (address hold time). 151, Min = 5. 151, Typ = -. 151, Max = -. 151, Units = ns. 155, Symbol = T AL L2OEL. 155, Characteristics = ALE \uf020\uf0af to OE \uf0af. 155, Min = 10. 155, Typ = 0.125 T CY. 155, Max = -. 155, Units = ns. 160, Symbol = T ADZ2OEL. 160, Characteristics = AD High-Z to OE \uf0af\uf020 (bus release to OE). 160, Min = 0. 160, Typ = -. 160, Max = -. 160, Units = ns. 161, Symbol = T OEH2ADD. 161, Characteristics = OE \uf0ad to AD Driven. 161, Min = 0.125 T CY -",
    "PIC18F6585/8585/6680/8680\n5. 161, Typ = -. 161, Max = -. 161, Units = ns. 162, Symbol = T ADV2OEH. 162, Characteristics = LS Data Valid before OE \uf0ad\uf020 (data setup time). 162, Min = 20. 162, Typ = -. 162, Max = -. 162, Units = ns. 163, Symbol = T OEH2ADL. 163, Characteristics = OE \uf0ad to Data In Invalid (data hold time). 163, Min = 0. 163, Typ = -. 163, Max = -. 163, Units = ns. 164, Symbol = T AL H2ALL. 164, Characteristics = ALE Pulse Width. 164, Min = -. 164, Typ = 0.25 T CY. 164, Max = -. 164, Units = ns. 165, Symbol = T OEL2OEH. 165, Characteristics = OE Pulse Width. 165, Min = 0.5 T CY - 5. 165, Typ = 0.5 T CY. 165, Max = -. 165, Units = ns. 166, Symbol = T AL H2ALH. 166, Characteristics",
    "PIC18F6585/8585/6680/8680\n= ALE \uf0ad to ALE \uf0ad (cycle time). 166, Min = -. 166, Typ = 1 T CY. 166, Max = -. 166, Units = ns. 167, Symbol = T ACC. 167, Characteristics = Address Valid to Data Valid. 167, Min = 0.75 T CY - 25. 167, Typ = -. 167, Max = -. 167, Units = ns. 168, Symbol = T OE. 168, Characteristics = OE \uf0af to Data Valid. 168, Min = . 168, Typ = -. 168, Max = 0.5 T CY - 25. 168, Units = ns. 169, Symbol = T AL L2OEH. 169, Characteristics = ALE \uf020\uf0af to OE \uf0ad. 169, Min = 0.625 T CY - 10. 169, Typ = -. 169, Max = 0.625 T CY + 10. 169, Units = ns. 171, Symbol = T AL H2CSL. 171, Characteristics = Chip Select Active to ALE \uf0af. 171, Min = -. 171, Typ = -. 171, Max = 10. 171, Units = ns. 171A, Symbol =",
    "PIC18F6585/8585/6680/8680\nTUBL2OEH. 171A, Characteristics = AD Valid to Chip Select Active. 171A, Min = 0.25 T CY - 20. 171A, Typ = -. 171A, Max = -. 171A, Units = ns",
    "TABLE 27-10: PROGRAM MEMORY WRITE TIMING REQUIREMENTS (VDD = 4.2 TO 5.5V)\n150, Symbol = T ADV2AL L. 150, Characteristics = Address Out Valid to ALE \uf0af\uf020 (address setup time). 150, Min = 0.25 T CY - 10. 150, Typ = -. 150, Max = -. 150, Units = ns. 151, Symbol = T AL L2ADL. 151, Characteristics = ALE \uf0af to Address Out Invalid (address hold time). 151, Min = 5. 151, Typ = -. 151, Max = -. 151, Units = ns. 153, Symbol = TWRH2ADL. 153, Characteristics = WRn \uf0ad to Data Out Invalid (data hold time). 153, Min = 5. 153, Typ = -. 153, Max = -. 153, Units = ns. 154, Symbol = TWRL. 154, Characteristics = WRn Pulse Width. 154, Min = 0.5 T CY - 5. 154, Typ = 0.5 T CY. 154, Max = -. 154, Units = ns. 156, Symbol = T ADV2WRH. 156, Characteristics = Data Valid before WRn \uf0ad\uf020",
    "TABLE 27-10: PROGRAM MEMORY WRITE TIMING REQUIREMENTS (VDD = 4.2 TO 5.5V)\n(data setup time). 156, Min = 0.5 T CY - 10. 156, Typ = -. 156, Max = -. 156, Units = ns. 157, Symbol = TBSV2WRL. 157, Characteristics = Byte Select Valid before WRn \uf0af\uf020 (byte select setup time). 157, Min = 0.25 T CY. 157, Typ = -. 157, Max = -. 157, Units = ns. 157A, Symbol = TWRH2BSI. 157A, Characteristics = WRn \uf0ad to Byte Select Invalid (byte select hold time). 157A, Min = 0.125 T CY - 5. 157A, Typ = -. 157A, Max = -. 157A, Units = ns. 166, Symbol = T AL H2ALH. 166, Characteristics = ALE \uf0ad to ALE \uf0ad (cycle time). 166, Min = -. 166, Typ = 0.25 T CY. 166, Max = -. 166, Units = ns. 171, Symbol = T AL H2CSL. 171, Characteristics = Chip Enable Active to ALE \uf0af. 171,",
    "TABLE 27-10: PROGRAM MEMORY WRITE TIMING REQUIREMENTS (VDD = 4.2 TO 5.5V)\nMin = -. 171, Typ = -. 171, Max = 10. 171, Units = ns. 171A, Symbol = TUBL2OEH. 171A, Characteristics = AD Valid to Chip Enable Active. 171A, Min = 0.25 T CY - 20. 171A, Typ = -. 171A, Max = -. 171A, Units = ns\nFIGURE 27-10: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER AND POWER-UP TIMER TIMING",
    "FIGURE 27-11: BROWN-OUT RESET TIMING\nTABLE 27-11: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER AND BROWN-OUT RESET REQUIREMENTS",
    "FIGURE 27-11: BROWN-OUT RESET TIMING\n30, Symbol = TMCL. 30, Characteristic = MCLR Pulse Width (low). 30, Min = 2. 30, Typ = -. 30, Max = -. 30, Units = \uf06d s. 30, Conditions = . 31, Symbol = TWDT. 31, Characteristic = Watchdog Timer Time-out Period (No Postscaler). 31, Min = 7. 31, Typ = 18. 31, Max = 33. 31, Units = ms. 31, Conditions = . 32, Symbol = T OST. 32, Characteristic = Oscillation Start-up Timer Period. 32, Min = 1024 T OSC. 32, Typ = -. 32, Max = 1024 T OSC. 32, Units = -. 32, Conditions = T OSC = OSC1 period. 33, Symbol = TPWRT. 33, Characteristic = Power up Timer Period. 33, Min = 28. 33, Typ = 72. 33, Max = 132. 33, Units = ms. 33, Conditions = . 34, Symbol = TIOZ. 34, Characteristic = I/O High-Impedance from MCLRLow or Watchdog Timer",
    "FIGURE 27-11: BROWN-OUT RESET TIMING\nReset. 34, Min = -. 34, Typ = 2. 34, Max = -. 34, Units = \uf06d s. 34, Conditions = . 35, Symbol = TBOR. 35, Characteristic = Brown-out Reset Pulse Width. 35, Min = 200. 35, Typ = -. 35, Max = -. 35, Units = \uf06d s. 35, Conditions = VDD \uf0a3 BVDD (see ). 36, Symbol = TIVRST. 36, Characteristic = Time for Internal Reference Voltage to become stable. 36, Min = -. 36, Typ = 20. 36, Max = 50. 36, Units = \uf06d s. 36, Conditions = . 37, Symbol = TLVD. 37, Characteristic = Low-Voltage Detect Pulse Width. 37, Min = 200. 37, Typ = -. 37, Max = -. 37, Units = \uf06d s. 37, Conditions = VDD \uf0a3 VLVD",
    "TABLE 27-12: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n40, Symbol = TT0H. 40, Characteristic = T0CKI High Pulse Width No. 40, Characteristic = T0CKI High Pulse Width No. 40, Min = prescaler 0.5. 40, Max = T CY + 20 -. 40, Units = ns. 40, Conditions = . 40, Symbol = TT0H. 40, Characteristic = . 40, Characteristic = . 40, Min = With prescaler. 40, Max = 10. 40, Units = - ns. 40, Conditions = . 41, Symbol = TT0L. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = T0CKI Low Pulse Width. 41, Min = No prescaler. 41, Max = 0.5 T CY + 20. 41, Units = - ns. 41, Conditions = . 41, Symbol = TT0L. 41, Characteristic = . 41, Characteristic = . 41, Min = With prescaler. 41, Max = 10. 41, Units = - ns. 41, Conditions = . 42, Symbol = TT0P. 42, Characteristic = T0CKI Period. 42, Characteristic = T0CKI Period.",
    "TABLE 27-12: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n42, Min = No prescaler. 42, Max = T CY + 10 -. 42, Units = ns. 42, Conditions = . 42, Symbol = TT0P. 42, Characteristic = . 42, Characteristic = . 42, Min = With prescaler. 42, Max = Greater of: CY + 40 N. 42, Units = - ns. 42, Conditions = N = prescale value (1, 2, 4,..., 256). 45, Symbol = TT1H. 45, Characteristic = T1CKI High Time. 45, Characteristic = Synchronous, no prescaler 0.5. 45, Min = Synchronous, no prescaler 0.5. 45, Max = T CY + 20 -. 45, Units = ns. 45, Conditions = . 45, Symbol = TT1H. 45, Characteristic = T1CKI High Time. 45, Characteristic = Synchronous, with prescaler. 45, Min = PIC18FXX8X 10. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = TT1H.",
    "TABLE 27-12: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n45, Characteristic = T1CKI High Time. 45, Characteristic = Synchronous, with prescaler. 45, Min = PIC18LFXX8X 25. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = TT1H. 45, Characteristic = T1CKI High Time. 45, Characteristic = Asynchronous. 45, Min = PIC18FXX8X 30. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = TT1H. 45, Characteristic = T1CKI High Time. 45, Characteristic = Asynchronous. 45, Min = PIC18LFXX8X 50. 45, Max = -. 45, Units = ns. 45, Conditions = . 46, Symbol = TT1L. 46, Characteristic = T1CKILow Time. 46, Characteristic = Synchronous, no prescaler 0.5 T CY +. 46, Min = Synchronous, no prescaler 0.5 T CY +. 46, Max = 5. 46, Units = - ns. 46, Conditions = .",
    "TABLE 27-12: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n46, Symbol = TT1L. 46, Characteristic = T1CKILow Time. 46, Characteristic = Synchronous, with prescaler. 46, Min = PIC18FXX8X 10. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = TT1L. 46, Characteristic = T1CKILow Time. 46, Characteristic = . 46, Min = PIC18LFXX8X 25. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = TT1L. 46, Characteristic = T1CKILow Time. 46, Characteristic = Asynchronous. 46, Min = PIC18FXX8X 30. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = TT1L. 46, Characteristic = T1CKILow Time. 46, Characteristic = Asynchronous. 46, Min = PIC18LFXX8X TBD. 46, Max = TBD. 46, Units = ns. 46, Conditions = . 47, Symbol = TT1P. 47, Characteristic =",
    "TABLE 27-12: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nT1CKI Input Period. 47, Characteristic = Synchronous. 47, Min = Synchronous. 47, Max = Greater of: 20 nS or T CY + 40 N. 47, Units = - ns. 47, Conditions = N = prescale value (1, 2, 4, 8). 47, Symbol = TT1P. 47, Characteristic = T1CKI Input Period. 47, Characteristic = Asynchronous. 47, Min = Asynchronous. 47, Max = 60. 47, Units = - ns. 47, Conditions = . 47, Symbol = FT1. 47, Characteristic = T1CKI Oscillator Input Frequency Range. 47, Characteristic = T1CKI Oscillator Input Frequency Range. 47, Min = T1CKI Oscillator Input Frequency Range. 47, Max = DC. 47, Units = 50 kHz. 47, Conditions = . 48, Symbol = T CKE 2TMRI. 48, Characteristic = Delay from External T1CKI Clock Edge to Timer Increment. 48, Characteristic = Delay from External T1CKI Clock Edge to Timer Increment. 48, Min",
    "TABLE 27-12: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n= Delay from External T1CKI Clock Edge to Timer Increment. 48, Max = 2 T OSC. 48, Units = 7 T OSC -. 48, Conditions = ",
    "TABLE 27-13: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\n50, Symbol = T CCL. 50, Characteristic = CCPxInputLow Time. 50, Characteristic = No prescaler. 50, Characteristic = No prescaler. 50, Min = 0.5 T CY + 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Symbol = T CCL. 50, Characteristic = CCPxInputLow Time. 50, Characteristic = With prescaler. 50, Characteristic = PIC18FXX8X. 50, Min = 10. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Symbol = T CCL. 50, Characteristic = CCPxInputLow Time. 50, Characteristic = With prescaler. 50, Characteristic = PIC18LFXX8X. 50, Min = 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 51, Symbol = T CCH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = No prescaler. 51, Characteristic = No prescaler. 51, Min = 0.5 T CY +",
    "TABLE 27-13: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\n20. 51, Max = -. 51, Units = ns. 51, Conditions = . 51, Symbol = T CCH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = With prescaler. 51, Characteristic = PIC18FXX8X. 51, Min = 10. 51, Max = -. 51, Units = ns. 51, Conditions = . 51, Symbol = T CCH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = With prescaler. 51, Characteristic = PIC18LFXX8X. 51, Min = 20. 51, Max = -. 51, Units = ns. 51, Conditions = . 52, Symbol = T CCP. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Min = 3 T CY + 40 N. 52, Max = -. 52, Units = ns. 52, Conditions = N = prescale value (1,4 or 16). 53, Symbol = T CCR. 53, Characteristic = CCPx",
    "TABLE 27-13: CAPTURE/COMPARE/PWM REQUIREMENTS (ALL CCP MODULES)\nOutput Rise Time. 53, Characteristic = CCPx Output Rise Time. 53, Characteristic = PIC18FXX8X. 53, Min = -. 53, Max = 25. 53, Units = ns. 53, Conditions = . 53, Symbol = T CCR. 53, Characteristic = . 53, Characteristic = . 53, Characteristic = PIC18LFXX8X. 53, Min = -. 53, Max = 45. 53, Units = ns. 53, Conditions = . 54, Symbol = T CCF. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = PIC18FXX8X. 54, Min = -. 54, Max = 25. 54, Units = ns. 54, Conditions = . 54, Symbol = T CCF. 54, Characteristic = . 54, Characteristic = . 54, Characteristic = PIC18LFXX8X. 54, Min = -. 54, Max = 45. 54, Units = ns. 54, Conditions = ",
    "TABLE 27-14: PARALLEL SLAVE PORT REQUIREMENTS (PIC18FXX8X)\n62, Symbol = TDT V2WRH. 62, Characteristic = Data In Valid before WR \uf0ad or CS \uf0ad (setup time). 62, Characteristic = Data In Valid before WR \uf0ad or CS \uf0ad (setup time). 62, Min = 20 25. 62, Max = - -. 62, Units = ns ns. 62, Conditions = Extended Temp. range. 63, Symbol = TWRH2DTI. 63, Characteristic = WR \uf0ad or CS \uf0ad to Data-In Invalid (hold time). 63, Characteristic = PIC18FXX8X. 63, Min = 20. 63, Max = -. 63, Units = ns. 63, Conditions = . 63, Symbol = TWRH2DTI. 63, Characteristic = WR \uf0ad or CS \uf0ad to Data-In Invalid (hold time). 63, Characteristic = PIC18LFXX8X. 63, Min = 35. 63, Max = -. 63, Units = ns. 63, Conditions = . 64, Symbol = TRDL2DTV. 64, Characteristic = RD \uf0af and CS \uf0af to Data-Out Valid. 64, Characteristic = RD \uf0af and CS \uf0af to Data-Out Valid. 64, Min = -",
    "TABLE 27-14: PARALLEL SLAVE PORT REQUIREMENTS (PIC18FXX8X)\n-. 64, Max = 80 90. 64, Units = ns. 64, Conditions = . , Symbol = . , Characteristic = . , Characteristic = . , Min = . , Max = . , Units = ns. , Conditions = Extended Temp. range. 65, Symbol = TRDH2DTI. 65, Characteristic = RD \uf0ad or CS \uf0af to Data-Out Invalid. 65, Characteristic = RD \uf0ad or CS \uf0af to Data-Out Invalid. 65, Min = 10. 65, Max = 30. 65, Units = ns. 65, Conditions = . 66, Symbol = TIBF INH. 66, Characteristic = Inhibit of the IBF flag bit being cleared from WR \uf0ad or CS \uf0ad. 66, Characteristic = Inhibit of the IBF flag bit being cleared from WR \uf0ad or CS \uf0ad. 66, Min = -. 66, Max = 3 T CY. 66, Units = . 66, Conditions = ",
    "FIGURE 27-15: EXAMPLE SPI MASTER MODE TIMING (CKE = 0\n)",
    "TABLE 27-15: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0 )\n70, Symbol = T SS L2SCH, T SS L2SCL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = T SCH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = T SCH. 71A, Characteristic = SCK Input High Time (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = T SCL. 72, Characteristic = SCK Input Low Time (Slave mode). 72, Characteristic = Continuous. 72, Min = 1.25 T CY + 30. 72, Max = -. 72, Units =",
    "TABLE 27-15: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0 )\nns. 72, Conditions = . 72A, Symbol = T SCL. 72A, Characteristic = SCK Input Low Time (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TDI V2SCH, TDI V2SCL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = T SCH2DI",
    "TABLE 27-15: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0 )\nL, T SCL2DI L. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18FXX8X. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18LFXX8X. 75, Min = -. 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TDOF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = T SCR. 78, Characteristic = SCK Output Rise Time",
    "TABLE 27-15: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0 )\n(Master mode). 78, Characteristic = PIC18FXX8X. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = T SCR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18LFXX8X. 78, Min = -. 78, Max = 45. 78, Units = ns. 78, Conditions = . 79, Symbol = T SCF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = T SCH2DOV, T SCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18FXX8X. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = T SCH2DOV, T",
    "TABLE 27-15: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 0 )\nSCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18LFXX8X. 80, Min = -. 80, Max = 100. 80, Units = ns. 80, Conditions = \nNote 1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "FIGURE 27-16: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\n)\nTABLE 27-16: EXAMPLE SPI MODE REQUIREMENTS (MASTER MODE, CKE = 1\n)",
    "FIGURE 27-16: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\n71, Symbol = T SCH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = . 71A, Characteristic = . 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = T SCL. 72, Characteristic = SCK Input Low Time. 72, Characteristic = Continuous. 72, Min = 1.25 T CY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol = . 72A, Characteristic = (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TDI V2SCH, TDI V2SCL. 73, Characteristic = Setup Time of",
    "FIGURE 27-16: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\nSDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = T SCH2DI L, T SCL2DI L. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18FXX8X. 75, Min =",
    "FIGURE 27-16: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\n-. 75, Max = 25. 75, Units = ns. 75, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18LFXX8X. , Min = . , Max = 45. , Units = ns. , Conditions = . 76, Symbol = TDOF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = T SCR. 78, Characteristic = SCK Output Rise Time. 78, Characteristic = PIC18FXX8X. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . , Symbol = . , Characteristic = (Master mode). , Characteristic = PIC18LFXX8X. , Min = . , Max = 45. , Units = ns. , Conditions = . 79, Symbol = T SCF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min =",
    "FIGURE 27-16: EXAMPLE SPI MASTER MODE TIMING (CKE = 1\n-. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = T SCH2DOV, T SCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18FXX8X. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18LFXX8X. , Min = . , Max = 100. , Units = ns. , Conditions = . 81, Symbol = TDOV2SCH, TDOV2SCL. 81, Characteristic = SDO Data Output Setup to SCK Edge. 81, Characteristic = SDO Data Output Setup to SCK Edge. 81, Min = T CY. 81, Max = -. 81, Units = ns. 81, Conditions = \nNote 1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "FIGURE 27-17: EXAMPLE SPI SLAVE MODE TIMING (CKE = 0\n)",
    "TABLE 27-17: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n)",
    "TABLE 27-17: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n70, Symbol = T SS L2SCH, T SS L2SCL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = T SCH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = . 71A, Characteristic = . 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = T SCL. 72, Characteristic = SCK Input Low Time (Slave mode). 72, Characteristic = Continuous. 72, Min = 1.25 T CY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol =",
    "TABLE 27-17: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\n. 72A, Characteristic = . 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TDI V2SCH, TDI V2SCL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = T SCH2DI L, T SCL2DI L. 74, Characteristic = Hold Time of SDI Data Input to SCK",
    "TABLE 27-17: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\nEdge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18FXX8X. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18LFXX8X. , Min = . , Max = 45. , Units = ns. , Conditions = . 76, Symbol = TDOF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol = T SS H2DOZ. 77, Characteristic = SS \uf0ad to SDO Output High-Impedance. 77, Characteristic = SS \uf0ad to SDO Output High-Impedance. 77, Min = 10. 77, Max = 50. 77, Units =",
    "TABLE 27-17: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\nns. 77, Conditions = . 78, Symbol = T SCR. 78, Characteristic = SCK oUtput Rise Time (Master mode). 78, Characteristic = PIC18FXX8X. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18LFXX8X. , Min = . , Max = 45. , Units = ns. , Conditions = . 79, Symbol = T SCF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = T SCH2DOV,. 80, Characteristic = SDO Data Output Valid after SCK Edge PIC18FXX8X. 80, Characteristic = SDO Data Output Valid after SCK Edge PIC18FXX8X. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . , Symbol = T",
    "TABLE 27-17: EXAMPLE SPI MODE REQUIREMENTS (SLAVE MODE TIMING, CKE = 0\nSCL2DOV. , Characteristic = . , Characteristic = PIC18LFXX8X. , Min = . , Max = 100. , Units = ns. , Conditions = . 83, Symbol = T SCH2SSH, T SCL2SSH. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Min = 1.5 T CY + 40. 83, Max = -. 83, Units = ns. 83, Conditions = \nNote 1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "FIGURE 27-18: EXAMPLE SPI SLAVE MODE TIMING (CKE = 1\n)",
    "TABLE 27-18: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n)\n70, Symbol = T SS L2SCH, T SS L2SCL. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Characteristic = SS \uf0af to SCK \uf0af or SCK \uf0ad Input. 70, Min = T CY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = T SCH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 T CY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = T SCH. 71A, Characteristic = SCK Input High Time (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = T SCL. 72, Characteristic = SCK Input Low Time (Slave mode). 72, Characteristic = Continuous. 72, Min = 1.25 T CY + 30. 72, Max = -. 72, Units = ns.",
    "TABLE 27-18: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n72, Conditions = . 72A, Symbol = T SCL. 72A, Characteristic = SCK Input Low Time (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the First Clock Edge of Byte 2. 73A, Min = 1.5 T CY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = T SCH2DI L, T SCL2DI L. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO",
    "TABLE 27-18: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\nData Output Rise Time. 75, Characteristic = PIC18FXX8X. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TDOR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18LFXX8X. 75, Min = . 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TDOF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol = T SS H2DOZ. 77, Characteristic = SS \uf0ad to SDO Output High-Impedance. 77, Characteristic = SS \uf0ad to SDO Output High-Impedance. 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 78, Symbol = T SCR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18FXX8X. 78, Min",
    "TABLE 27-18: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\n= -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = T SCR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18LFXX8X. 78, Min = -. 78, Max = 45. 78, Units = ns. 78, Conditions = . 79, Symbol = T SCF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = T SCH2DOV, T SCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18FXX8X. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = T SCH2DOV, T SCL2DOV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic =",
    "TABLE 27-18: EXAMPLE SPI SLAVE MODE REQUIREMENTS (CKE = 1\nPIC18LFXX8X. 80, Min = -. 80, Max = 100. 80, Units = ns. 80, Conditions = . 82, Symbol = T SS L2DOV. 82, Characteristic = SDO Data Output Valid after SS \uf0af Edge. 82, Characteristic = PIC18FXX8X. 82, Min = -. 82, Max = 50. 82, Units = ns. 82, Conditions = . 82, Symbol = T SS L2DOV. 82, Characteristic = SDO Data Output Valid after SS \uf0af Edge. 82, Characteristic = PIC18LFXX8X. 82, Min = -. 82, Max = 100. 82, Units = ns. 82, Conditions = . 83, Symbol = T SCH2SSH, T SCL2SS H. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Characteristic = SS \uf0ad after SCK Edge. 83, Min = 1.5 T CY + 40. 83, Max = -. 83, Units = ns. 83, Conditions = \nNote 1: Requires the use of Parameter #73A.\n2: Only if Parameter #71A and #72A are used.",
    "TABLE 27-19: I 2 C BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\n90, Symbol = T SU: STA. 90, Characteristic = Start Condition. 90, Characteristic = 100 kHz mode. 90, Min = 4700. 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. , Symbol = . , Characteristic = Setup Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = . 91, Symbol = THD: STA. 91, Characteristic = Start Condition. 91, Characteristic = 100 kHz mode. 91, Min = 4000. 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first. , Symbol = . , Characteristic = Hold Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = clock pulse is generated. 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition. 92, Characteristic = 100 kHz mode. 92, Min = 4700. 92, Max = -. 92, Units = ns. 92, Conditions = . , Symbol = . , Characteristic",
    "TABLE 27-19: I 2 C BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\n= Setup Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = . 93, Symbol = THD: STO. 93, Characteristic = Stop Condition. 93, Characteristic = 100 kHz mode. 93, Min = 4000. 93, Max = -. 93, Units = ns. 93, Conditions = . , Symbol = . , Characteristic = Hold Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = ",
    "TABLE 27-20: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 100 kHz mode. 100, Min = 4.0. 100, Max = -. 100, Units = \uf06d s. 100, Conditions = PIC18FXX8X must operate at a minimum of 1.5 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 400 kHz mode. 100, Min = 0.6. 100, Max = -. 100, Units = \uf06d s. 100, Conditions = PIC18FXX8X must operate at a minimum of 10 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = SSP Module. 100, Min = 1.5 T CY. 100, Max = -. 100, Units = . 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 100 kHz mode. 101, Min = 4.7. 101, Max = -. 101, Units = \uf06d s. 101, Conditions = PIC18FXX8X must operate at a minimum of 1.5 MHz. 101, Symbol =",
    "TABLE 27-20: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\nTLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 400 kHz mode. 101, Min = 1.3. 101, Max = -. 101, Units = \uf06d s. 101, Conditions = PIC18FXX8X must operate at a minimum of 10 MHz. 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = SSP Module. 101, Min = 1.5 T CY. 101, Max = -. 101, Units = . 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time.",
    "TABLE 27-20: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n103, Characteristic = 100 kHz mode. 103, Min = -. 103, Max = 300. 103, Units = ns. 103, Conditions = . 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 4.7. 90, Max = -. 90, Units = \uf06d s. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 0.6. 90, Max = -. 90, Units = \uf06d s. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode.",
    "TABLE 27-20: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n91, Min = 4.0. 91, Max = -. 91, Units = \uf06d s. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 0.6. 91, Max = -. 91, Units = \uf06d s. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = \uf06d s. 106, Conditions = . 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -. 107, Units = ns.",
    "TABLE 27-20: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\n107, Conditions = (Note 2). 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 4.7. 92, Max = -. 92, Units = \uf06d s. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 0.6. 92, Max = -. 92, Units = \uf06d s. 92, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500. 109, Units = ns. 109, Conditions = (Note 1). 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 400 kHz",
    "TABLE 27-20: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\nmode. 109, Min = -. 109, Max = -. 109, Units = ns. 109, Conditions = (Note 1). 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = \uf06d s. 110, Conditions = Time the bus must be free before a new transmission can Start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = \uf06d s. 110, Conditions = Time the bus must be free before a new transmission can Start. D102, Symbol = CB. D102, Characteristic = Bus Capacitive Loading. D102, Characteristic = Bus Capacitive Loading. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = ",
    "TABLE 27-20: I 2 C BUS DATA REQUIREMENTS (SLAVE MODE)\nNote 1: As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of Start or Stop conditions.\n2: A Fast mode I 2 C bus device can be used in a Standard mode I 2 C bus system but the requirement,\nTSU:DAT \uf0b3 250 ns, must then be met. This will automatically be the case if the device does not stretch the low period of the SCL signal. If such a device does stretch the low period of the SCL signal, it must output the next data bit to the SDA line.\nTR max. + TSU:DAT = 1000 + 250 = 1250 ns (according to the Standard mode I 2 C bus specification) before the SCL line is released.",
    "TABLE 27-21: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\n\nNote 1: Maximum pin capacitance = 10 pF for all I 2 C pins.",
    "TABLE 27-21: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\n90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode. 91, Min = 2(T",
    "TABLE 27-21: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\nOSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 1 MHz mode (1). 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92,",
    "TABLE 27-21: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\nConditions = ns. 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 93, Symbol = THD: STO. 93, Characteristic = Stop Condition Hold Time. 93, Characteristic = 100 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = . 93, Symbol = THD: STO. 93, Characteristic = Stop Condition Hold Time. 93, Characteristic = 400 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max =",
    "TABLE 27-21: MASTER SSP I 2 C BUS START/STOP BITS REQUIREMENTS\n-. 93, Units = ns. 93, Conditions = . 93, Symbol = THD: STO. 93, Characteristic = Stop Condition Hold Time. 93, Characteristic = 1 MHz mode (1). 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = ",
    "TABLE 27-22: MASTER SSP I 2 C BUS DATA REQUIREMENTS\n100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 100 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 400 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 1 MHz mode (1). 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 100 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low",
    "TABLE 27-22: MASTER SSP I 2 C BUS DATA REQUIREMENTS\nTime. 101, Characteristic = 400 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 1 MHz mode (1). 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA and",
    "TABLE 27-22: MASTER SSP I 2 C BUS DATA REQUIREMENTS\nSCL Rise Time. 102, Characteristic = 1 MHz mode (1). 102, Min = -. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 100 kHz mode. 103, Min = -. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 1 MHz mode (1). 103, Min = -. 103, Max = 100. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF.",
    "TABLE 27-22: MASTER SSP I 2 C BUS DATA REQUIREMENTS\n90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = T SU: STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode. 91, Min = 2(T",
    "TABLE 27-22: MASTER SSP I 2 C BUS DATA REQUIREMENTS\nOSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD: STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 1 MHz mode (1). 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD: DAT. 106,",
    "TABLE 27-22: MASTER SSP I 2 C BUS DATA REQUIREMENTS\nCharacteristic = Data Input Hold Time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = ms. 106, Conditions = . 106, Symbol = THD: DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 1 MHz mode (1). 106, Min = TBD. 106, Max = -. 106, Units = ns. 106, Conditions = . 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = T SU: DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 1 MHz mode (1). 107, Min = TBD. 107, Max = -.",
    "TABLE 27-22: MASTER SSP I 2 C BUS DATA REQUIREMENTS\n107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = T SU: STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500. 109, Units =",
    "TABLE 27-22: MASTER SSP I 2 C BUS DATA REQUIREMENTS\nns. 109, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 400 kHz mode. 109, Min = -. 109, Max = 1000. 109, Units = ns. 109, Conditions = . 109, Symbol = T AA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 1 MHz mode (1). 109, Min = -. 109, Max = -. 109, Units = ns. 109, Conditions = . 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic",
    "TABLE 27-22: MASTER SSP I 2 C BUS DATA REQUIREMENTS\n= 1 MHz mode (1). 110, Min = TBD. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = Bus Capacitive Loading. D102, Characteristic = Bus Capacitive Loading. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = \nNote 1: Maximum pin capacitance = 10 pF for all I 2 C pins.\n2: A Fast mode I 2 C bus device can be used in a Standard mode I 2 C bus system, but parameter #107 \uf0b3 250 ns, must then be met. This will automatically be the case if the device does not stretch the low period of the SCL signal. If such a device does stretch the low period of the SCL signal, it must output the next data bit to the SDA line, parameter #102 + parameter #107 = 1000 + 250 = 1250 ns (for 100 kHz mode), before the SCL line is released.",
    "TABLE 27-23: USART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n120, Symbol = T CKH2DTV. 120, Characteristic = SYNC XMIT (MASTER & SLAVE) Clock High to Data Out Valid. 120, Characteristic = PIC18FXX8X. 120, Min = -. 120, Max = 40. 120, Units = ns. 120, Conditions = . 120, Symbol = T CKH2DTV. 120, Characteristic = . 120, Characteristic = PIC18LFXX8X. 120, Min = -. 120, Max = 100. 120, Units = ns. 120, Conditions = . 121, Symbol = T CKRF. 121, Characteristic = Clock Out Rise Time and Fall Time (Master mode). 121, Characteristic = PIC18FXX8X. 121, Min = -. 121, Max = 20. 121, Units = ns. 121, Conditions = . 121, Symbol = T CKRF. 121, Characteristic = Clock Out Rise Time and Fall Time (Master mode). 121, Characteristic = PIC18LFXX8X. 121, Min = -. 121, Max = 50. 121, Units = ns. 121, Conditions = . 122, Symbol = TDTRF. 122, Characteristic = Data",
    "TABLE 27-23: USART SYNCHRONOUS TRANSMISSION REQUIREMENTS\nOut Rise Time and Fall Time. 122, Characteristic = PIC18FXX8X. 122, Min = -. 122, Max = 20. 122, Units = ns. 122, Conditions = . 122, Symbol = TDTRF. 122, Characteristic = Data Out Rise Time and Fall Time. 122, Characteristic = PIC18LFXX8X. 122, Min = -. 122, Max = 50. 122, Units = ns. 122, Conditions = ",
    "TABLE 27-24: USART SYNCHRONOUS RECEIVE REQUIREMENTS\n125, Symbol = TDTV2CKL. 125, Characteristic = SYNC RCV (MASTER & SLAVE) Data Hold before CK \uf0af (DT hold time). 125, Min = 10. 125, Max = -. 125, Units = ns. 125, Conditions = . 126, Symbol = T CKL2DTL. 126, Characteristic = Data Hold after CK \uf0af (DT hold time). 126, Min = 15. 126, Max = -. 126, Units = ns. 126, Conditions = ",
    "TABLE 27-25: A/D CONVERTER CHARACTERISTICS: PIC18F6585/8585/6680/8680 (INDUSTRIAL, EXTENDED) PIC18LF6585/8585/6680/8680 (INDUSTRIAL)\nA01, Symbol = NR. A01, Characteristic = Resolution. A01, Characteristic = Resolution. A01, Min = - -. A01, Typ = - -. A01, Max = 10 TBD. A01, Units = bit bit. A01, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A03, Symbol = EIL. A03, Characteristic = Integral Linearity Error. A03, Characteristic = Integral Linearity Error. A03, Min = - -. A03, Typ = - -. A03, Max = <\u00b11 TBD. A03, Units = LSb LSb. A03, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A04, Symbol = EDL. A04, Characteristic = Differential Linearity Error. A04, Characteristic = Differential Linearity Error.",
    "TABLE 27-25: A/D CONVERTER CHARACTERISTICS: PIC18F6585/8585/6680/8680 (INDUSTRIAL, EXTENDED) PIC18LF6585/8585/6680/8680 (INDUSTRIAL)\nA04, Min = - -. A04, Typ = - -. A04, Max = <\u00b11 TBD. A04, Units = LSb LSb. A04, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A05, Symbol = EFS. A05, Characteristic = Full-Scale Error. A05, Characteristic = Full-Scale Error. A05, Min = - -. A05, Typ = - -. A05, Max = <\u00b11 TBD. A05, Units = LSb LSb. A05, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A06, Symbol = EOFF. A06, Characteristic = Offset Error. A06, Characteristic = Offset Error. A06, Min = - -. A06, Typ =",
    "TABLE 27-25: A/D CONVERTER CHARACTERISTICS: PIC18F6585/8585/6680/8680 (INDUSTRIAL, EXTENDED) PIC18LF6585/8585/6680/8680 (INDUSTRIAL)\n- -. A06, Max = <\u00b11 TBD. A06, Units = LSb LSb. A06, Conditions = VREF = VDD \uf0b3 3.0V VREF = VDD \uf03c 3.0V. A10, Symbol = -. A10, Characteristic = Monotonicity. A10, Characteristic = Monotonicity. A10, Min = guaranteed (3). A10, Typ = guaranteed (3). A10, Max = guaranteed (3). A10, Units = -. A10, Conditions = VSS \uf0a3 VAIN \uf0a3 VREF. A20 A20A, Symbol = VREF. A20 A20A, Characteristic = Reference Voltage (V REFH - VREFL ). A20 A20A, Characteristic = Reference Voltage (V REFH - VREFL ). A20 A20A, Min = 0V 3V. A20 A20A, Typ = - -. A20 A20A, Max",
    "TABLE 27-25: A/D CONVERTER CHARACTERISTICS: PIC18F6585/8585/6680/8680 (INDUSTRIAL, EXTENDED) PIC18LF6585/8585/6680/8680 (INDUSTRIAL)\n= - -. A20 A20A, Units = V V. A20 A20A, Conditions = For 10-bit resolution. A21, Symbol = VREFH. A21, Characteristic = Reference Voltage High. A21, Characteristic = Reference Voltage High. A21, Min = AVss. A21, Typ = -. A21, Max = AVDD + 0.3V. A21, Units = V. A21, Conditions = . A22, Symbol = VREFL. A22, Characteristic = Reference Voltage Low. A22, Characteristic = Reference Voltage Low. A22, Min = AVss - 0.3V. A22, Typ = -. A22, Max = AVDD. A22, Units = V. A22, Conditions = . A25, Symbol = VAIN. A25, Characteristic = Analog Input Voltage. A25, Characteristic = Analog Input Voltage. A25, Min = AVSS - 0.3V. A25,",
    "TABLE 27-25: A/D CONVERTER CHARACTERISTICS: PIC18F6585/8585/6680/8680 (INDUSTRIAL, EXTENDED) PIC18LF6585/8585/6680/8680 (INDUSTRIAL)\nTyp = -. A25, Max = VREF + 0.3V. A25, Units = V. A25, Conditions = . A30, Symbol = ZAIN. A30, Characteristic = Recommended Impedance of Analog Voltage Source. A30, Characteristic = Recommended Impedance of Analog Voltage Source. A30, Min = -. A30, Typ = -. A30, Max = 10.0. A30, Units = k \uf057. A30, Conditions = . A40, Symbol = I AD. A40, Characteristic = A/D Conversion Current (V DD). A40, Characteristic = PIC18FXX8X. A40, Min = -. A40, Typ = 180. A40, Max = -. A40, Units = \uf06d A. A40, Conditions = Average current consumption when A/D is on (Note 1). A50, Symbol = I REF. A50, Characteristic = VREF Input Current (Note 2).",
    "TABLE 27-25: A/D CONVERTER CHARACTERISTICS: PIC18F6585/8585/6680/8680 (INDUSTRIAL, EXTENDED) PIC18LF6585/8585/6680/8680 (INDUSTRIAL)\nA50, Characteristic = VREF Input Current (Note 2). A50, Min = - -. A50, Typ = - -. A50, Max = 5 150. A50, Units = \uf06d A \uf06d A. A50, Conditions = During VAIN acquisition. During A/D conversion cycle.\n- Note 1: When A/D is off, it will not consume any current other than minor leakage current. The power-down current spec includes any such leakage from the A/D module.\nVREF current is from RA2/AN2/VREF- and RA3/AN3/VREF+ pins or AVDD and AVSS pins, whichever is selected as reference input.\n2: Vss \uf0a3 VAIN \uf0a3 VREF\n3: The A/D conversion result never decreases with an increase in the input voltage and has no missing codes.",
    "FIGURE 27-25: A/D CONVERSION TIMING\nNote 1: If the A/D clock source is selected as RC, a time of TCY is added before the A/D clock starts. This allows the SLEEP instruction to be executed.\n2: This is a minimal RC delay (typically 100 ns) which also disconnects the holding capacitor from the analog input.",
    "TABLE 27-26: A/D CONVERSION REQUIREMENTS\n130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18FXX8X. 130, Min = 1.6. 130, Max = 20 (5). 130, Units = \uf06d s. 130, Conditions = T OSC based, VREF \uf0b3 3.0V. 130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18LFXX8X. 130, Min = 3.0. 130, Max = 20 (5). 130, Units = \uf06d s. 130, Conditions = T OSC based, VREF full range. 130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18FXX8X. 130, Min = 2.0. 130, Max = 6.0. 130, Units = \uf06d s. 130, Conditions = A/D RC mode. 130, Symbol = T AD. 130, Characteristic = A/D Clock Period. 130, Characteristic = PIC18LFXX8X. 130, Min = 3.0. 130, Max = 9.0. 130, Units = \uf06d s. 130, Conditions =",
    "TABLE 27-26: A/D CONVERSION REQUIREMENTS\nA/D RC mode. 131, Symbol = T CNV. 131, Characteristic = Conversion Time (not including acquisition time) (Note 1). 131, Characteristic = Conversion Time (not including acquisition time) (Note 1). 131, Min = 11. 131, Max = 12. 131, Units = T AD. 131, Conditions = . 132, Symbol = T ACQ. 132, Characteristic = Acquisition Time (Note 3). 132, Characteristic = Acquisition Time (Note 3). 132, Min = 15 10. 132, Max = - -. 132, Units = \uf06d s \uf06d s. 132, Conditions = -40 \uf0b0 C \uf0a3 Temp \uf0a3 +125 \uf0b0 C 0 \uf0b0 C \uf0a3 Temp \uf0a3 +125 \uf0b0 C. 135, Symbol = T SWC. 135, Characteristic = Switching Time from Convert \uf0ae Sample. 135, Characteristic = Switching Time from Convert \uf0ae Sample. 135, Min = -. 135, Max = (Note 4). 135, Units = . 135, Conditions = . 136, Symbol = T AMP. 136, Characteristic = Amplifier Settling Time (Note 2). 136, Characteristic = Amplifier Settling Time (Note 2). 136, Min = 1. 136, Max = -. 136, Units = \uf06d s.",
    "TABLE 27-26: A/D CONVERSION REQUIREMENTS\n136, Conditions = This may be used if the 'new' input voltage has not changed by more than 1 LSb (i.e., 5 mV@5.12V) from the last sampled voltage (as stated on CHOLD).\nNote 1: ADRES register may be read on the following TCY cycle.\n2: See Section 19.0 '10-bit Analog-to-Digital Converter (A/D) Module' for minimum conditions when input voltage has changed more than 1 LSb.\n3: The time for the holding capacitor to acquire the 'New' input voltage when the voltage changes full scale after the conversion (AVDD to AVSS, or AVSS to AVDD). The source impedance ( RS ) on the input channels is 50 \uf057 .\n4: On the next Q4 cycle of the device clock.\n5: The time of the A/D clock period is dependent on the device frequency and the TAD clock divider.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "28.0 DC AND AC CHARACTERISTICS GRAPHS AND TABLES\nNote:\nThe graphs and tables provided following this note are a statistical summary based on a limited number of samples and are provided for informational purposes only. The performance characteristics listed herein are not tested or guaranteed. In some graphs or tables, the data presented may be outside the specified operating range (e.g., outside specified power supply range) and therefore, outside the warranted range.\n'Typical' represents the mean of the distribution at 25 C. 'Maximum' or 'minimum' represents (mean + 3 \uf0b0 \uf073 ) or (mean - 3 \uf073 ) respectively, where \uf073 is a standard deviation, over the whole temperature range.",
    "PIC18F6585/8585/6680/8680\nFIGURE 28-4: MAXIMUM IDD vs. FOSC OVER VDD (HS/PLL MODE)\nFIGURE 28-5:\nTYPICAL IDD vs. FOSC OVER VDD (XT MODE)\nFIGURE 28-6: MAXIMUM IDD vs. FOSC OVER VDD (XT MODE)\nFIGURE 28-7: TYPICAL IDD vs. FOSC OVER VDD (LP MODE)\nFIGURE 28-8: MAXIMUM IDD vs. FOSC OVER VDD (LP MODE)\nFIGURE 28-9:\nTYPICAL IDD vs. FOSC OVER VDD (EC MODE)\nFIGURE 28-10: MAXIMUM IDD vs. FOSC OVER VDD (EC MODE)\nFIGURE 28-12: AVERAGE FOSC vs. VDD FOR VARIOUS R's (RC MODE, C = 20 pF, TEMP = 25\u00b0C)\nFIGURE 28-14: AVERAGE FOSC vs. VDD FOR VARIOUS R's (RC MODE, C = 300 pF, TEMP = 25\u00b0C)\nFIGURE 28-15: IPD vs. VDD (SLEEP MODE, ALL PERIPHERALS DISABLED)",
    "PIC18F6585/8585/6680/8680\nFIGURE 28-16: TYPICAL AND MAXIMUM \uf044 IBOR vs. VDD OVER TEMPERATURE, VBOR = 2.00V-2.16V\nFIGURE 28-18: IPD vs. VDD (SLEEP MODE, WDT ENABLED)\nFIGURE 28-19: TYPICAL, MINIMUM AND MAXIMUM WDT PERIOD vs. VDD\nFIGURE 28-20: \uf044 ILVD vs. VDD OVER TEMPERATURE, VLVD = 4.5-4.78V\nFIGURE 28-22: TYPICAL, MINIMUM AND MAXIMUM VOH vs. IOH (VDD = 3V, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 28-24: TYPICAL AND MAXIMUM VOL vs. IOL (VDD = 3V, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 28-26: MINIMUM AND MAXIMUM VIN vs. VDD (TTL INPUT, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 28-27: MINIMUM AND MAXIMUM VIN vs. VDD (I 2 C INPUT, -40 C TO +125 C) \uf0b0 \uf0b0\nFIGURE 28-28: A/D NONLINEARITY vs. VREFH (VDD = VREFH, -40 C TO +125 C) \uf0b0 \uf0b0\nNOTES:",
    "Legend:\nXX...X\nCustomer-specific information\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week '01')\nNNN\nAlphanumeric traceability code\nPb-free JEDEC designator for Matte Tin (Sn) This package is Pb-free. The Pb-free JEDEC designator (     ) can be found on the outer packaging for this package.\n*",
    "Note :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.\n3\ne\n3\ne",
    "29.2 Package Details\nThe following sections give the technical details of the packages.",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNumber of Pins, Dimension Limits = n. Number of Pins, INCHES.MIN = . Number of Pins, INCHES.NOM = 64. Number of Pins, INCHES.MAX = . Number of Pins, MILLIMETERS*.MIN = . Number of Pins, MILLIMETERS*.NOM = 64. Number of Pins, MILLIMETERS*.MAX = . Pitch, Dimension Limits = p. Pitch, INCHES.MIN = . Pitch, INCHES.NOM = .020. Pitch, INCHES.MAX = . Pitch, MILLIMETERS*.MIN = . Pitch, MILLIMETERS*.NOM = 0.50. Pitch, MILLIMETERS*.MAX = . Pins per Side, Dimension Limits = n1. Pins per Side, INCHES.MIN = . Pins per Side, INCHES.NOM = 16. Pins per Side, INCHES.MAX = . Pins per Side, MILLIMETERS*.MIN = . Pins per Side, MILLIMETERS*.NOM = 16. Pins per Side, MILLIMETERS*.MAX = . Overall Height, Dimension Limits = A. Overall Height,",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nINCHES.MIN = .039. Overall Height, INCHES.NOM = .043. Overall Height, INCHES.MAX = .047. Overall Height, MILLIMETERS*.MIN = 1.00. Overall Height, MILLIMETERS*.NOM = 1.10. Overall Height, MILLIMETERS*.MAX = 1.20. Molded Package Thickness, Dimension Limits = A2. Molded Package Thickness, INCHES.MIN = .037. Molded Package Thickness, INCHES.NOM = .039. Molded Package Thickness, INCHES.MAX = .041. Molded Package Thickness, MILLIMETERS*.MIN = 0.95. Molded Package Thickness, MILLIMETERS*.NOM = 1.00. Molded Package Thickness, MILLIMETERS*.MAX = 1.05. Standoff \u00a7, Dimension Limits = A1. Standoff \u00a7, INCHES.MIN = .002. Standoff \u00a7, INCHES.NOM = .006. Standoff \u00a7, INCHES.MAX = .010. Standoff \u00a7, MILLIMETERS*.MIN = 0.05. Standoff",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n\u00a7, MILLIMETERS*.NOM = 0.15. Standoff \u00a7, MILLIMETERS*.MAX = 0.25. Foot Length, Dimension Limits = L. Foot Length, INCHES.MIN = .018. Foot Length, INCHES.NOM = .024. Foot Length, INCHES.MAX = .030. Foot Length, MILLIMETERS*.MIN = 0.45. Foot Length, MILLIMETERS*.NOM = 0.60. Foot Length, MILLIMETERS*.MAX = 0.75. Footprint (Reference), Dimension Limits = (F). Footprint (Reference), INCHES.MIN = . Footprint (Reference), INCHES.NOM = .039. Footprint (Reference), INCHES.MAX = . Footprint (Reference), MILLIMETERS*.MIN = . Footprint (Reference), MILLIMETERS*.NOM = 1.00. Footprint (Reference), MILLIMETERS*.MAX = . Foot Angle, Dimension Limits = \uf066. Foot Angle, INCHES.MIN = 0. Foot Angle, INCHES.NOM = 3.5.",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nFoot Angle, INCHES.MAX = 7. Foot Angle, MILLIMETERS*.MIN = 0. Foot Angle, MILLIMETERS*.NOM = 3.5. Foot Angle, MILLIMETERS*.MAX = 7. Overall Width, Dimension Limits = E. Overall Width, INCHES.MIN = .463. Overall Width, INCHES.NOM = .472. Overall Width, INCHES.MAX = .482. Overall Width, MILLIMETERS*.MIN = 11.75. Overall Width, MILLIMETERS*.NOM = 12.00. Overall Width, MILLIMETERS*.MAX = 12.25. Overall Length, Dimension Limits = D. Overall Length, INCHES.MIN = .463. Overall Length, INCHES.NOM = .472. Overall Length, INCHES.MAX = .482. Overall Length, MILLIMETERS*.MIN = 11.75. Overall Length, MILLIMETERS*.NOM = 12.00. Overall Length, MILLIMETERS*.MAX = 12.25. Molded Package Width, Dimension Limits = E1. Molded Package Width,",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nINCHES.MIN = .390. Molded Package Width, INCHES.NOM = .394. Molded Package Width, INCHES.MAX = .398. Molded Package Width, MILLIMETERS*.MIN = 9.90. Molded Package Width, MILLIMETERS*.NOM = 10.00. Molded Package Width, MILLIMETERS*.MAX = 10.10. Molded Package Length, Dimension Limits = D1. Molded Package Length, INCHES.MIN = .390. Molded Package Length, INCHES.NOM = .394. Molded Package Length, INCHES.MAX = .398. Molded Package Length, MILLIMETERS*.MIN = 9.90. Molded Package Length, MILLIMETERS*.NOM = 10.00. Molded Package Length, MILLIMETERS*.MAX = 10.10. Lead Thickness, Dimension Limits = c. Lead Thickness, INCHES.MIN = .005. Lead Thickness, INCHES.NOM = .007. Lead Thickness, INCHES.MAX = .009. Lead Thickness, MILLIMETERS*.MIN = 0.13. Lead Thickness,",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nMILLIMETERS*.NOM = 0.18. Lead Thickness, MILLIMETERS*.MAX = 0.23. Lead Width, Dimension Limits = B. Lead Width, INCHES.MIN = .007. Lead Width, INCHES.NOM = .009. Lead Width, INCHES.MAX = .011. Lead Width, MILLIMETERS*.MIN = 0.17. Lead Width, MILLIMETERS*.NOM = 0.22. Lead Width, MILLIMETERS*.MAX = 0.27. Pin 1 Corner Chamfer, Dimension Limits = CH. Pin 1 Corner Chamfer, INCHES.MIN = .025. Pin 1 Corner Chamfer, INCHES.NOM = .035. Pin 1 Corner Chamfer, INCHES.MAX = .045. Pin 1 Corner Chamfer, MILLIMETERS*.MIN = 0.64. Pin 1 Corner Chamfer, MILLIMETERS*.NOM = 0.89. Pin 1 Corner Chamfer, MILLIMETERS*.MAX = 1.14. Mold Draft Angle Top, Dimension Limits",
    "64-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n= \uf061. Mold Draft Angle Top, INCHES.MIN = 5. Mold Draft Angle Top, INCHES.NOM = 10. Mold Draft Angle Top, INCHES.MAX = 15. Mold Draft Angle Top, MILLIMETERS*.MIN = 5. Mold Draft Angle Top, MILLIMETERS*.NOM = 10. Mold Draft Angle Top, MILLIMETERS*.MAX = 15. Mold Draft Angle Bottom, Dimension Limits = \uf062. Mold Draft Angle Bottom, INCHES.MIN = 5. Mold Draft Angle Bottom, INCHES.NOM = 10. Mold Draft Angle Bottom, INCHES.MAX = 15. Mold Draft Angle Bottom, MILLIMETERS*.MIN = 5. Mold Draft Angle Bottom, MILLIMETERS*.NOM = 10. Mold Draft Angle Bottom, MILLIMETERS*.MAX = 15\n* Controlling Parameter\n\u00a7 Significant Characteristic\nNotes:\nDimensions D1 and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side. JEDEC Equivalent:  MS-026 Drawing No. C04-085",
    "68-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "68-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nNumber of Pins, Units.Limits = n. Number of Pins, INCHES*.MIN = . Number of Pins, INCHES*.NOM = 68. Number of Pins, INCHES*.MAX = . Number of Pins, MILLIMETERS.MIN = . Number of Pins, MILLIMETERS.NOM = 68. Number of Pins, MILLIMETERS.MAX = . Pitch, Units.Limits = p. Pitch, INCHES*.MIN = . Pitch, INCHES*.NOM = .050. Pitch, INCHES*.MAX = . Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 1.27. Pitch, MILLIMETERS.MAX = . Pins per Side, Units.Limits = n1. Pins per Side, INCHES*.MIN = . Pins per Side, INCHES*.NOM = 17. Pins per Side, INCHES*.MAX = . Pins per Side, MILLIMETERS.MIN = . Pins per Side, MILLIMETERS.NOM = 17. Pins per Side, MILLIMETERS.MAX = . Overall Height, Units.Limits = A. Overall Height, INCHES*.MIN = .165. Overall Height,",
    "68-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nINCHES*.NOM = .173. Overall Height, INCHES*.MAX = .180. Overall Height, MILLIMETERS.MIN = 4.19. Overall Height, MILLIMETERS.NOM = 4.39. Overall Height, MILLIMETERS.MAX = 4.57. Molded Package Thickness, Units.Limits = A2. Molded Package Thickness, INCHES*.MIN = .145. Molded Package Thickness, INCHES*.NOM = .153. Molded Package Thickness, INCHES*.MAX = .160. Molded Package Thickness, MILLIMETERS.MIN = 3.68. Molded Package Thickness, MILLIMETERS.NOM = 3.87. Molded Package Thickness, MILLIMETERS.MAX = 4.06. Standoff, Units.Limits = A1. Standoff, INCHES*.MIN = .020. Standoff, INCHES*.NOM = .028. Standoff, INCHES*.MAX = .035. Standoff, MILLIMETERS.MIN = 0.51. Standoff, MILLIMETERS.NOM = 0.71. Standoff, MILLIMETERS.MAX = 0.89. Side 1 Chamfer Height, Units.Limits =",
    "68-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nA3. Side 1 Chamfer Height, INCHES*.MIN = .024. Side 1 Chamfer Height, INCHES*.NOM = .029. Side 1 Chamfer Height, INCHES*.MAX = .034. Side 1 Chamfer Height, MILLIMETERS.MIN = 0.61. Side 1 Chamfer Height, MILLIMETERS.NOM = 0.74. Side 1 Chamfer Height, MILLIMETERS.MAX = 0.86. Corner Chamfer 1, Units.Limits = CH1. Corner Chamfer 1, INCHES*.MIN = .040. Corner Chamfer 1, INCHES*.NOM = .045. Corner Chamfer 1, INCHES*.MAX = .050. Corner Chamfer 1, MILLIMETERS.MIN = 1.02. Corner Chamfer 1, MILLIMETERS.NOM = 1.14. Corner Chamfer 1, MILLIMETERS.MAX = 1.27. Corner Chamfer (others), Units.Limits = CH2. Corner Chamfer (others), INCHES*.MIN = .000. Corner",
    "68-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nChamfer (others), INCHES*.NOM = .005. Corner Chamfer (others), INCHES*.MAX = .010. Corner Chamfer (others), MILLIMETERS.MIN = 0.00. Corner Chamfer (others), MILLIMETERS.NOM = 0.13. Corner Chamfer (others), MILLIMETERS.MAX = 0.25. Overall Width, Units.Limits = E. Overall Width, INCHES*.MIN = .985. Overall Width, INCHES*.NOM = .990. Overall Width, INCHES*.MAX = .995. Overall Width, MILLIMETERS.MIN = 25.02. Overall Width, MILLIMETERS.NOM = 25.15. Overall Width, MILLIMETERS.MAX = 25.27. Overall Length, Units.Limits = D. Overall Length, INCHES*.MIN = .985. Overall Length, INCHES*.NOM = .990. Overall Length, INCHES*.MAX = .995. Overall Length, MILLIMETERS.MIN = 25.02. Overall Length, MILLIMETERS.NOM =",
    "68-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n25.15. Overall Length, MILLIMETERS.MAX = 25.27. Molded Package Width, Units.Limits = E1. Molded Package Width, INCHES*.MIN = .950. Molded Package Width, INCHES*.NOM = .954. Molded Package Width, INCHES*.MAX = .958. Molded Package Width, MILLIMETERS.MIN = 24.13. Molded Package Width, MILLIMETERS.NOM = 24.23. Molded Package Width, MILLIMETERS.MAX = 24.33. Molded Package Length, Units.Limits = D1. Molded Package Length, INCHES*.MIN = .950. Molded Package Length, INCHES*.NOM = .954. Molded Package Length, INCHES*.MAX = .958. Molded Package Length, MILLIMETERS.MIN = 24.13. Molded Package Length, MILLIMETERS.NOM = 24.23. Molded Package Length, MILLIMETERS.MAX = 24.33. Footprint Width, Units.Limits = E2. Footprint Width, INCHES*.MIN = .890. Footprint Width, INCHES*.NOM = .920. Footprint Width, INCHES*.MAX =",
    "68-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n.930. Footprint Width, MILLIMETERS.MIN = 22.61. Footprint Width, MILLIMETERS.NOM = 23.37. Footprint Width, MILLIMETERS.MAX = 23.62. Footprint Length, Units.Limits = D2. Footprint Length, INCHES*.MIN = .890. Footprint Length, INCHES*.NOM = .920. Footprint Length, INCHES*.MAX = .930. Footprint Length, MILLIMETERS.MIN = 22.61. Footprint Length, MILLIMETERS.NOM = 23.37. Footprint Length, MILLIMETERS.MAX = 23.62. Lead Thickness, Units.Limits = c. Lead Thickness, INCHES*.MIN = .008. Lead Thickness, INCHES*.NOM = .011. Lead Thickness, INCHES*.MAX = .013. Lead Thickness, MILLIMETERS.MIN = 0.20. Lead Thickness, MILLIMETERS.NOM = 0.27. Lead Thickness, MILLIMETERS.MAX = 0.33. Upper Lead Width, Units.Limits = B1. Upper Lead Width, INCHES*.MIN = .026. Upper Lead Width, INCHES*.NOM =",
    "68-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n.029. Upper Lead Width, INCHES*.MAX = .032. Upper Lead Width, MILLIMETERS.MIN = 0.66. Upper Lead Width, MILLIMETERS.NOM = 0.74. Upper Lead Width, MILLIMETERS.MAX = 0.81. Lower Lead Width, Units.Limits = B. Lower Lead Width, INCHES*.MIN = .013. Lower Lead Width, INCHES*.NOM = .020. Lower Lead Width, INCHES*.MAX = .021. Lower Lead Width, MILLIMETERS.MIN = 0.33. Lower Lead Width, MILLIMETERS.NOM = 0.51. Lower Lead Width, MILLIMETERS.MAX = 0.53. Mold Draft Angle Top, Units.Limits = \uf061. Mold Draft Angle Top, INCHES*.MIN = 0. Mold Draft Angle Top, INCHES*.NOM = 5. Mold Draft Angle Top, INCHES*.MAX = 10. Mold Draft Angle Top, MILLIMETERS.MIN = 0. Mold Draft Angle Top, MILLIMETERS.NOM = 5. Mold Draft Angle Top, MILLIMETERS.MAX = 10. Mold Draft Angle Bottom, Units.Limits",
    "68-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n= \uf062. Mold Draft Angle Bottom, INCHES*.MIN = 0. Mold Draft Angle Bottom, INCHES*.NOM = 5. Mold Draft Angle Bottom, INCHES*.MAX = 10. Mold Draft Angle Bottom, MILLIMETERS.MIN = 0. Mold Draft Angle Bottom, MILLIMETERS.NOM = 5. Mold Draft Angle Bottom, MILLIMETERS.MAX = 10\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side. JEDEC Equivalent:  MO-047 Drawing No. C04-049",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNumber of Pins, Dimension Limits = n. Number of Pins, INCHES.MIN = . Number of Pins, INCHES.NOM = 80. Number of Pins, INCHES.MAX = . Number of Pins, MILLIMETERS*.MIN = . Number of Pins, MILLIMETERS*.NOM = 80. Number of Pins, MILLIMETERS*.MAX = . Pitch, Dimension Limits = p. Pitch, INCHES.MIN = . Pitch, INCHES.NOM = .020. Pitch, INCHES.MAX = . Pitch, MILLIMETERS*.MIN = . Pitch, MILLIMETERS*.NOM = 0.50. Pitch, MILLIMETERS*.MAX = . Pins per Side, Dimension Limits = n1. Pins per Side, INCHES.MIN = . Pins per Side, INCHES.NOM = 20. Pins per Side, INCHES.MAX = . Pins per Side, MILLIMETERS*.MIN = . Pins per Side, MILLIMETERS*.NOM = 20. Pins per Side, MILLIMETERS*.MAX = . Overall Height, Dimension Limits = A. Overall Height,",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nINCHES.MIN = .039. Overall Height, INCHES.NOM = .043. Overall Height, INCHES.MAX = .047. Overall Height, MILLIMETERS*.MIN = 1.00. Overall Height, MILLIMETERS*.NOM = 1.10. Overall Height, MILLIMETERS*.MAX = 1.20. Molded Package Thickness, Dimension Limits = A2. Molded Package Thickness, INCHES.MIN = .037. Molded Package Thickness, INCHES.NOM = .039. Molded Package Thickness, INCHES.MAX = .041. Molded Package Thickness, MILLIMETERS*.MIN = 0.95. Molded Package Thickness, MILLIMETERS*.NOM = 1.00. Molded Package Thickness, MILLIMETERS*.MAX = 1.05. Standoff \u00a7, Dimension Limits = A1. Standoff \u00a7, INCHES.MIN = .002. Standoff \u00a7, INCHES.NOM = .004. Standoff \u00a7, INCHES.MAX = .006. Standoff \u00a7, MILLIMETERS*.MIN = 0.05. Standoff",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n\u00a7, MILLIMETERS*.NOM = 0.10. Standoff \u00a7, MILLIMETERS*.MAX = 0.15. Foot Length, Dimension Limits = L. Foot Length, INCHES.MIN = .018. Foot Length, INCHES.NOM = .024. Foot Length, INCHES.MAX = .030. Foot Length, MILLIMETERS*.MIN = 0.45. Foot Length, MILLIMETERS*.NOM = 0.60. Foot Length, MILLIMETERS*.MAX = 0.75. Footprint (Reference), Dimension Limits = (F). Footprint (Reference), INCHES.MIN = . Footprint (Reference), INCHES.NOM = .039. Footprint (Reference), INCHES.MAX = . Footprint (Reference), MILLIMETERS*.MIN = . Footprint (Reference), MILLIMETERS*.NOM = 1.00. Footprint (Reference), MILLIMETERS*.MAX = . Foot Angle, Dimension Limits = \uf066. Foot Angle, INCHES.MIN = 0. Foot Angle, INCHES.NOM = 3.5.",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nFoot Angle, INCHES.MAX = 7. Foot Angle, MILLIMETERS*.MIN = 0. Foot Angle, MILLIMETERS*.NOM = 3.5. Foot Angle, MILLIMETERS*.MAX = 7. Overall Width, Dimension Limits = E. Overall Width, INCHES.MIN = .541. Overall Width, INCHES.NOM = .551. Overall Width, INCHES.MAX = .561. Overall Width, MILLIMETERS*.MIN = 13.75. Overall Width, MILLIMETERS*.NOM = 14.00. Overall Width, MILLIMETERS*.MAX = 14.25. Overall Length, Dimension Limits = D. Overall Length, INCHES.MIN = .541. Overall Length, INCHES.NOM = .551. Overall Length, INCHES.MAX = .561. Overall Length, MILLIMETERS*.MIN = 13.75. Overall Length, MILLIMETERS*.NOM = 14.00. Overall Length, MILLIMETERS*.MAX = 14.25. Molded Package Width, Dimension Limits = E1. Molded Package Width,",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nINCHES.MIN = .463. Molded Package Width, INCHES.NOM = .472. Molded Package Width, INCHES.MAX = .482. Molded Package Width, MILLIMETERS*.MIN = 11.75. Molded Package Width, MILLIMETERS*.NOM = 12.00. Molded Package Width, MILLIMETERS*.MAX = 12.25. Molded Package Length, Dimension Limits = D1. Molded Package Length, INCHES.MIN = .463. Molded Package Length, INCHES.NOM = .472. Molded Package Length, INCHES.MAX = .482. Molded Package Length, MILLIMETERS*.MIN = 11.75. Molded Package Length, MILLIMETERS*.NOM = 12.00. Molded Package Length, MILLIMETERS*.MAX = 12.25. Lead Thickness, Dimension Limits = c. Lead Thickness, INCHES.MIN = .004. Lead Thickness, INCHES.NOM = .006. Lead Thickness, INCHES.MAX = .008. Lead Thickness, MILLIMETERS*.MIN = 0.09. Lead",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nThickness, MILLIMETERS*.NOM = 0.15. Lead Thickness, MILLIMETERS*.MAX = 0.20. Lead Width, Dimension Limits = B. Lead Width, INCHES.MIN = .007. Lead Width, INCHES.NOM = .009. Lead Width, INCHES.MAX = .011. Lead Width, MILLIMETERS*.MIN = 0.17. Lead Width, MILLIMETERS*.NOM = 0.22. Lead Width, MILLIMETERS*.MAX = 0.27. Pin 1 Corner Chamfer, Dimension Limits = CH. Pin 1 Corner Chamfer, INCHES.MIN = .025. Pin 1 Corner Chamfer, INCHES.NOM = .035. Pin 1 Corner Chamfer, INCHES.MAX = .045. Pin 1 Corner Chamfer, MILLIMETERS*.MIN = 0.64. Pin 1 Corner Chamfer, MILLIMETERS*.NOM = 0.89. Pin 1 Corner Chamfer, MILLIMETERS*.MAX = 1.14. Mold Draft Angle Top,",
    "80-Lead Plastic Thin Quad Flatpack (PT) 12x12x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nDimension Limits = \uf061. Mold Draft Angle Top, INCHES.MIN = 5. Mold Draft Angle Top, INCHES.NOM = 10. Mold Draft Angle Top, INCHES.MAX = 15. Mold Draft Angle Top, MILLIMETERS*.MIN = 5. Mold Draft Angle Top, MILLIMETERS*.NOM = 10. Mold Draft Angle Top, MILLIMETERS*.MAX = 15. Mold Draft Angle Bottom, Dimension Limits = \uf062. Mold Draft Angle Bottom, INCHES.MIN = 5. Mold Draft Angle Bottom, INCHES.NOM = 10. Mold Draft Angle Bottom, INCHES.MAX = 15. Mold Draft Angle Bottom, MILLIMETERS*.MIN = 5. Mold Draft Angle Bottom, MILLIMETERS*.NOM = 10. Mold Draft Angle Bottom, MILLIMETERS*.MAX = 15\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimensions D1 and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side. JEDEC Equivalent:  MS-026 Drawing No. C04-092",
    "Revision A (February 2003)\nAPPENDIX B:\nDEVICE DIFFERENCES\nOriginal  data  sheet  for  PIC18F6585/8585/6680/8680 family.",
    "Revision B (June 2003)\nThis revision includes updates to the Special Function Registers in Table 4-2 and  Table 23-1  and  minor corrections to the data sheet text.",
    "Revision C (February 2004)\nThis revision includes the DC and AC Characteristics Graphs  and  Tables.  The  Electrical  Specifications  in Section 27.0 'Electrical Characteristics' have been updated and there have been minor corrections to the data sheet text.",
    "Revision D (January 2013)\nAdded a note to each package outline drawing.",
    "TABLE B-1: DEVICE DIFFERENCES\nOn-Chip Program Memory (Kbytes), PIC18F6585 = 48. On-Chip Program Memory (Kbytes), PIC18F6680 = 64. On-Chip Program Memory (Kbytes), PIC18F8585 = 48. On-Chip Program Memory (Kbytes), PIC18F8680 = 64. I/O Ports, PIC18F6585 = Ports A, B, C, D, E, F, G. I/O Ports, PIC18F6680 = Ports A, B, C, D, E, F, G. I/O Ports, PIC18F8585 = Ports A, B, C, D, E, F, G, H, J. I/O Ports, PIC18F8680 = Ports A, B, C, D, E, F, G, H, J. A/D Channels, PIC18F6585 = 12. A/D Channels, PIC18F6680 = 12. A/D Channels, PIC18F8585 = 16. A/D Channels, PIC18F8680 = 16. External Memory Interface, PIC18F6585",
    "TABLE B-1: DEVICE DIFFERENCES\n= No. External Memory Interface, PIC18F6680 = No. External Memory Interface, PIC18F8585 = Yes. External Memory Interface, PIC18F8680 = Yes. Package Types, PIC18F6585 = 64-pin TQFP, 68-pin PLCC. Package Types, PIC18F6680 = 64-pin TQFP, 68-pin PLCC. Package Types, PIC18F8585 = 80-pin TQFP. Package Types, PIC18F8680 = 80-pin TQFP\nThe differences between the devices listed in this data sheet are shown in Table B-1.",
    "APPENDIX C: CONVERSION CONSIDERATIONS\nThis  appendix  discusses  the  considerations  for  converting from previous versions of a device to the ones listed in this data sheet. Typically, these changes are due to the differences in the process technology used. An  example  of  this  type  of  conversion  is  from  a PIC17C756 to a PIC18F8720.",
    "APPENDIX D: MIGRATION FROM MID-RANGE TO ENHANCED DEVICES\nNot Applicable\nA detailed  discussion  of  the  differences  between  the mid-range  MCU  devices  (i.e.,  PIC16CXXX)  and  the enhanced  devices  (i.e.,  PIC18FXXX)  is  provided  in AN716,  'Migrating  Designs  from  PIC16C74A/74B  to PIC18C442.'  The  changes  discussed,  while  device specific,  are  generally  applicable  to  all  mid-range  to enhanced device migrations.\nThis Application Note is available as Literature Number DS00716.",
    "MIGRATION FROM HIGH-END TO ENHANCED DEVICES\nA  detailed  discussion  of  the  migration  pathway  and differences between the high-end MCU devices (i.e., PIC17CXXX) and the enhanced devices (i.e., PIC18FXXXX) is provided in AN726, 'PIC17CXXX to PIC18CXXX  Migration.' This Application Note is available as Literature Number DS00726.",
    "PIC18F6585/8585/6680/8680\nNOTES:",
    "A\nA/D Converter Interrupt, Configuring ......................................................., 249 = 253. Acquisition Requirements, 249 = ......................................... 254. Acquisition Time........................................................, 249 = 254. ADCON0 Register....................................................., 249 = 249. ADCON1",
    "A\nRegister....................................................., 249 = 249. ADCON2 Register....................................................., 249 = 249. ADRESH Register....................................................., 249 = 249. ADRESH/ADRESL Registers, 249 = ................................... 252. ADRESL Register, 249 =",
    "A\n..................................................... 249. Analog Port Pins, 249 = ....................................................... 152. Analog Port Pins, Configuring, 249 = ....................................................... 255. Associated Register Summary .........................................................., 249 = 257. Automatic Acquisition",
    "A\nTime......................................., 249 = 255. Calculating Minimum Required Acquisition Time (Example).............................., 249 = 254. CCP2 Trigger............................................................, 249 = 256. Configuring the Module............................................., 249 = 253. Conversion Clock (T AD ), 249 =",
    "A\n............................................ 255. Conversion Requirements, 249 = ........................................ 447. Conversion Status (GO/DONE Bit), 249 = ................................................. 252. Conversions.............................................................., 249 = 256. Converter Characteristics, 249 =",
    "A\n......................................... 446. Minimum Charging Time..........................................., 249 = 254. Special Event Trigger (CCP)................................................................, 249 = 171. Special Event Trigger (CCP2).............................................................., 249 = 256. VREF+ and VREF-",
    "A\nReferences..................................., 249 = 254. Absolute Maximum Ratings, 249 = .............................................. 413. AC (Timing) Characteristics .............................................., 249 = 426. Load Conditions for Device Timing Specifications........................................, 249 = 427. Parameter Symbology ..............................................,",
    "A\n249 = 426. Temperature and Voltage Specifications...................................................., 249 = 427 ...................................................... Timing Conditions, 249 = 427. ACKSTAT Status Flag, 249 = ...................................................... 219. ADCON0",
    "A\nRegister............................................................., 249 = 249. GO/DONE Bit............................................................, 249 = 252. ADCON1 Register............................................................., 249 = 249. ADCON2",
    "A\nRegister............................................................., 249 = 249. ADDLW............................................................................., 249 = 371. ADDWF............................................................................., 249 = 371.",
    "A\nADDWFC.........................................................................., 249 = 372 Register............................................................. 249. ADRESH/ADRESL Registers, 249 = ........................................... 252. ADRESL Register",
    "A\n............................................................., 249 = 249. Analog-to-Digital Converter., 249 = . See A/D., 249 = ",
    "A\nANDLW............................................................................., 1 = 372. ANDWF............................................................................., 1 = 373. Assembler, 1 = . MPASM Assembler .................................................., 1 = 407. Auto-Wake-up on Sync, 1 = . Break Character",
    "A\n......................................................., 1 = 242",
    "B\nBaud Rate Generator ......................................................., 1 = 215. BC....................................................................................., 1 = 373. BCF, 1 = .................................................................................. 374. BF Status",
    "B\nFlag.................................................................., 1 = 219. Bit Timing Configuration Registers, 1 = . BRGCON1................................................................, 1 = 340. BRGCON2................................................................, 1 = 340.",
    "B\nBRGCON3................................................................, 1 = 340. Block Diagrams, 1 = . 16-bit Byte Select Mode, 1 = ............................................. 98. 16-bit Byte Write Mode..............................................., 1 = 96. 16-bit Word Write Mode.............................................., 1 = 97.",
    "B\nA/D............................................................................, 1 = 252. Analog Input Model..................................................., 1 = 253. Baud Rate Generator, 1 = ............................................... 215. CAN Buffers and Protocol Engine, 1 = ............................ 276. Capture Mode",
    "B\nOperation.........................................., 1 = 170. Comparator Analog Input Model, 1 = .......................................... 263. Comparator I/O Operating Modes (diagram).........................................................., 1 = 260. Comparator Output..................................................., 1 = 262. Comparator Voltage",
    "B\nReference................................, 1 = 266. Compare Mode Operation................................, 1 = 171, 176. Enhanced PWM........................................................, 1 = 178. Low-Voltage Detect (LVD)........................................, 1 = 270. Low-Voltage Detect (LVD) with External Input",
    "B\n..................................................., 1 = 270. MSSP (I 2 C Master Mode)........................................., 1 = 213. MSSP (I 2 C Mode)....................................................., 1 = 198. MSSP (SPI Mode)...................................................., 1 = 189. On-Chip Reset",
    "B\nCircuit................................................., 1 = 33. PIC18F6X8X Architecture, 1 = .......................................... 10. PIC18F8X8X Architecture, 1 = .......................................... 11. PLL............................................................................., 1 = 25.",
    "B\nPORT/LAT/TRIS Operation......................................, 1 = 125. PORTA, 1 = . RA3:RA0 and RA5 Pins...................................., 1 = 126. RA4/T0CKI Pin ................................................., 1 = 126. RA6 Pin (When Enabled as I/O)......................., 1 = 126. PORTB, 1 = . RB2:RB0",
    "B\nPins..................................................., 1 = 129. RB3 Pin, 1 = ............................................................ 129. RB7:RB4 Pins..................................................., 1 = 128. PORTC (Peripheral Output, 1 = .",
    "B\nOverride)..........................................................., 1 = 131. PORTD and PORTE, 1 = . (Parallel Slave Port).........................................., 1 = 152",
    "PIC18F6585/8585/6680/8680\nPORTD in I/O Port Mode, 1 = .......................................... 133. PORTD in System Bus Mode ..................................., 1 = 134. PORTE in I/O Mode.................................................., 1 = 137. PORTE in System Bus Mode...................................., 1 = 137. PORTF, 1 = . RF1/AN6/C2OUT and RF2/AN7/C1OUT",
    "PIC18F6585/8585/6680/8680\nPins.............................., 1 = 139. RF6:RF3 and RF0 Pins....................................., 1 = 140. RF7, 1 = Pin............................................................. 140. PORTG, 1 = . RG0/CANTX1 Pin, 1 = ............................................. 142. RG1/CANTX2 Pin, 1 =",
    "PIC18F6585/8585/6680/8680\n............................................. 143. RG2/CANRX, 1 = Pin............................................... 143. RG3 Pin, 1 = ............................................................ 143. RG4/P1D Pin, 1 = .................................................... 144.",
    "PIC18F6585/8585/6680/8680\nRG5/MCLR/VPP Pin.........................................., 1 = 144. PORTH, 1 = . RH3:RH0 Pins in I/O Mode..............................., 1 = 146. RH3:RH0 Pins in, 1 = . System Bus Mode....................................., 1 = 147. RH7:RH4 Pins in I/O Mode..............................., 1 = 146. PORTJ, 1 = . RJ4:RJ0 Pins in System Bus, 1 =",
    "PIC18F6585/8585/6680/8680\nMode..................................... 150. RJ7:RJ6 Pins in, 1 = . System Bus Mode....................................., 1 = 150. PORTJ in I/O Mode..................................................., 1 = 149. PWM (CCP Module) ................................................., 1 = 173. Reads from Flash Program, 1 = .",
    "PIC18F6585/8585/6680/8680\nMemory..............................................................., 1 = 87. Single Comparator...................................................., 1 = 261. Table Read Operation................................................., 1 = 83. Table Write Operation................................................., 1 =",
    "PIC18F6585/8585/6680/8680\n84. Table Writes to Flash Program, 1 = Memory............................................................... 89. Timer0 in 16-bit Mode..............................................., 1 = 156. Timer0 in 8-bit Mode................................................., 1 = 156.",
    "PIC18F6585/8585/6680/8680\nTimer1......................................................................., 1 = 160. Timer1 (16-bit Read/Write Mode), 1 = ............................. 160. Timer2......................................................................., 1 = 163.",
    "PIC18F6585/8585/6680/8680\nTimer3....................................................................... Timer3 in 16-bit Read/Write Mode............................, 1 = 165 165. USART Receive........................................................, 1 = 240. USART Transmit......................................................., 1 =",
    "PIC18F6585/8585/6680/8680\n. , 1 = 238. Voltage Reference, 1 = . Output Buffer (example)...................................., 1 = 267. Watchdog BN....................................................................................., 1 = Timer........................................................ 356 374.",
    "PIC18F6585/8585/6680/8680\nBNC..................................................................................., 1 = 375. BNN..................................................................................., 1 = 375.",
    "PIC18F6585/8585/6680/8680\nBNOV................................................................................, 1 = 376. BNZ..................................................................................., 1 = 376. BOR. See Brown-out Reset., 1 = .",
    "PIC18F6585/8585/6680/8680\nBOV..................................................................................., 1 = 379. BRA..................................................................................., 1 = 377. Break Character (12-bit) Transmit and Receive, 1 = . Brown-out Reset (BOR), 1 =",
    "PIC18F6585/8585/6680/8680\n............................................... 243. BRG. See Baud Rate Generator. .............................................., 1 = 34, 345 BSF................................................................................... 377. BTFSC, 1 =",
    "PIC18F6585/8585/6680/8680\n.............................................................................. 378. BTFSS..............................................................................., 1 = 378.",
    "PIC18F6585/8585/6680/8680\nBTG................................................................................... BZ......................................................................................, 1 = 379 380",
    "C\nC Compilers\nMPLAB C17.............................................................., 1 = 408. MPLAB C18.............................................................., 1 = 408. MPLAB C30.............................................................., 1 = 408.",
    "C\nCALL................................................................................., 1 = 380. Capture (CCP Module) ....................................................., 1 = 169. CAN Message Time-Stamp......................................, 1 = 170. CCP Pin Configuration.............................................., 1 = 169.",
    "C\nCCPRxH:CCPRxL Registers...................................., 1 = 169. Software Interrupt ....................................................., 1 = 170. Timer1/Timer3 Mode Selection................................., 1 = 169. Capture, Compare (CCP Module),, 1 = . Timer1 and Timer3, 1 = . Associated Registers................................................, 1 = 172. Capture/Compare/PWM (CCP) Capture Mode., 1 =",
    "C\n........................................ 167. See Capture (CCP Module)., 1 = . ............................................................., 1 = . CCP Module, 1 = 169. CCPRxH Register....................................................., 1 = 169. CCPRxL Register, 1 = ..................................................... 169. Compare",
    "C\nMode., 1 = . See Compare (CCP Module). Interaction of CCP1 and, 1 = . CCP2 Modules ................................................., 1 = 169. PWM Mode., 1 = . See PWM (CCP Module)., 1 = . ......................................................, 1 = . Timer Resources, 1 = 169. Capture/Compare/PWM, 1 = 435. Requirements ..........................................................., 1 = 430, 431. CLKO and",
    "C\nI/O Timing Requirements........................ Clocking Scheme/Instruction Cycle, 1 = .................................... 56. CLRF ................................................................................, 1 = 381. CLRWDT, 1 = .......................................................................... 381. Code Examples, 1 = . 16 x 16",
    "C\nSigned Multiply Routine, 1 = ............................... 108. 16 x 16 Unsigned Multiply Routine, 1 = ........................... 108. 8 x 8 Signed Multiply Routine..................................., 1 = 107. 8 x 8 Unsigned Multiply Routine, 1 = ............................... 107. Changing Between Capture Prescalers........................................................., 1 = . Changing to, 1 = 170. Configuration",
    "C\nMode.............................., 1 = 281. Data EEPROM Read................................................, 1 = 103. Data EEPROM Refresh Routine..............................., 1 = 104. Data EEPROM Write ................................................, 1 = 103. Memory Row ......................................................, 1 =",
    "C\n88. Fast Register Stack, 1 = .................................................... 56. How to Clear RAM (Bank 1) Using Indirect Addressing............................................., 1 = . , 1 = 79. Initializing PORTA....................................................., 1 = 125. Initializing PORTB....................................................., 1 = 128. Initializing",
    "C\nPORTC...................................................., 1 = 131. Initializing PORTD...................................................., 1 = 133. Initializing PORTE....................................................., 1 = 136. Initializing PORTF....................................................., 1 = 139. Initializing",
    "C\nPORTG...................................................., 1 = 142. Initializing PORTH...................................................., 1 = 146. Initializing PORTJ....................................................., 1 = 149. Loading the SSPBUF (SSPSR) Register ............................................................,",
    "C\n1 = . Reading a Flash Program, 1 = 192. Memory Word....................................................., 1 = 87",
    "PIC18F6585/8585/6680/8680\nSaving Status, WREG and BSR Registers in RAM.............................................................., 1 = 124. Transmitting a CAN Message Using Banked Method................................................., 1 = 289. Transmitting a CAN Message Using WIN Bits............................................................, 1 = 290. WIN and ICODE Bits Usage in Interrupt Service Routine to Access TX/RX",
    "PIC18F6585/8585/6680/8680\nBuffers................................................... ........................, 1 = 281. Writing to Flash Program Memory, 1 = 90-91. Code Protection, 1 = ................................................................ 345. COMF",
    "PIC18F6585/8585/6680/8680\n..............................................................................., 1 = 382. Comparator......................................................................., 1 = 259. Analog Input Connection Considerations.................................................., 1 = 263. Associated Registers, 1 =",
    "PIC18F6585/8585/6680/8680\n................................................ 264. Configuration............................................................., 1 = 260. Effects of a Reset......................................................, 1 = 263.",
    "PIC18F6585/8585/6680/8680\nInterrupts..................................................................., 1 = 262. Operation, 1 = .................................................................. 261. Operation During Sleep, 1 = ............................................ 263. Outputs",
    "PIC18F6585/8585/6680/8680\n....................................................................., 1 = 261. Reference, 1 = ................................................................. 261. External Signal.................................................. Internal",
    "PIC18F6585/8585/6680/8680\nSignal..................................................., 1 = 261. Response Time........................................................., 1 = 261 261. Specifications................................................, 1 = 423. Comparator, 1 = . Comparator Voltage, 1 = . Reference",
    "PIC18F6585/8585/6680/8680\n................................................................., 1 = 265. Accuracy and Error ..................................................., 1 = 266. Associated Registers ................................................, 1 = 267.",
    "PIC18F6585/8585/6680/8680\nConfiguring................................................................, 1 = 265. Connection Considerations......................................., 1 = 266. Effects of a Reset......................................................, 1 = 266. Operation During Sleep, 1 = ............................................ 266. Compare (CCP Module)",
    "PIC18F6585/8585/6680/8680\n..................................................., 1 = 171. CCP Pin Configuration.............................................., 1 = 171. CCPRx Register........................................................, 1 = 171. Software Interrupt ....................................................., 1 = 171. Special Event",
    "PIC18F6585/8585/6680/8680\nTrigger................................ Timer1/Timer3 Mode, 1 = 161, 166, 171. Selection ........................................................... Compare (CCP2 Module) Special Event Trigger................................................, 1 = 171 256. Configuration Bits.............................................................., 1 = 345. Configuration",
    "PIC18F6585/8585/6680/8680\nMode..........................................................., 1 = 328. Control Registers, 1 = . EECON1 and EECON2, 1 = .............................................. 84. TABLAT (Table Latch) Register .............................................................., 1 = 86. TBLPTR (Table Pointer) Register",
    "PIC18F6585/8585/6680/8680\n.............................................................., 1 = 86. Conversion Considerations............................................... ..........................................................................., 1 = 470. CPFSEQ, 1 = 382. CPFSGT CPFSLT, 1 =",
    "PIC18F6585/8585/6680/8680\n........................................................................... 383 ............................................................................ 383",
    "D\nData EEPROM Memory Associated, 1 = Registers................................................ 105. EEADRH EEADR Register Pair, 1 = ....................................... 101. EECON1 Register, 1 = .................................................... 101. EECON2 Register, 1 = .................................................... 101. Operation During Code-Protect, 1 =",
    "D\n.................................................... 104. Protection Against Spurious Write.................................................., 1 = 104. Reading, 1 = .................................................................... 103. Using",
    "D\n........................................................................, 1 = 104. Write Verify..............................................................., 1 = 104. Writing to, 1 = .................................................................. 103. Data",
    "D\nMemory......................................................................, 1 = 59. General Purpose Registers, 1 = ........................................ 59. Map for PIC18FXX80/XX85 Devices..............................................................., 1 = 60. Special Function Registers........................................., 1 = 59.",
    "D\nDAW................................................................................., 1 = 384. DC and AC Characteristics Graphs and Tables..................................................., 1 = 449. DC, 1 = . PIC18FXX8X (Industrial and, 1 = . Characteristics, 1 = . Extended), PIC18LFXX8X (Industrial)........................................................., 1 = 421. Power-down and Supply",
    "D\nCurrent.................................................., 1 = 417. Supply Voltage, 1 = ......................................................... 416. DCFSNZ..........................................................................., 1 = 385.",
    "D\nDECF................................................................................, 1 = 384. DECFSZ..........................................................................., 1 = 385. Demonstration Boards, 1 = . PICDEM 1................................................................., 1 = 410. PICDEM",
    "D\n17..............................................................., 1 = 411. PICDEM 18R............................................................, 1 = 411. PICDEM 2 Plus........................................................., 1 = 410. PICDEM",
    "D\n3................................................................., 1 = 410. PICDEM 4................................................................., 1 = 410. PICDEM LIN............................................................., 1 = 411. PICDEM",
    "D\nUSB..........................................................., 1 = 411. PICDEM.net Internet/ Ethernet............................................................, 1 = 410. Development Support......................................................., 1 = 407. Device",
    "D\nDifferences............................................................, 1 = 469. Device Features.................................................................... Device Overview..................................................................., 1 = 9 9. Direct Addressing, 1 =",
    "D\n............................................................... 78. Disable Mode...................................................................., 1 = 328",
    "E\nInformation Processing Time\nECAN Module, 1 = ................................................................... 275. Baud Rate Setting....................................................., 1 = 337. Bit Time Partitioning.................................................., 1 = 337. Bit Timing Configuration",
    "E\nRegisters..........................................................., 1 = 340. Calculating TQ, Nominal Bit Rate and Nominal Bit Time..............................................., 1 = 338. CAN Baud Rate Registers, 1 = ........................................ 315. CAN Control and Status Registers..........................................................., 1 = 277. CAN Controller Register Map, 1 =",
    "E\n................................... 323. CAN I/O Control Register.........................................., 1 = 318. CAN Interrupt Registers............................................, 1 = 319. CAN Interrupts, 1 = .......................................................... 342.",
    "E\nAcknowledge....................................................., 1 = 343. Bus Activity Wake-up........................................, 1 = 343. Bus-Off.............................................................., 1 = 343. Code Bits, 1 = .......................................................... 342.",
    "E\nError.................................................................., 1 = 343. Message Error .................................................., 1 = 343. Receive............................................................., 1 = 343. Receiver Bus Passive......................................., 1 = 343. Receiver",
    "E\nOverflow............................................., 1 = 343. Receiver Warning, 1 = ............................................. 343. Transmit............................................................, 1 = 342. Transmitter Bus Passive..................................., 1 = 343. Transmitter Warning, 1 =",
    "E\n......................................... 343. CAN Message Buffers .............................................., 1 = 331. Dedicated Receive............................................, 1 = 331. Dedicated Transmit..........................................., 1 = 331. Programmable Auto-RTR, 1 = ................................. 332. Programmable",
    "E\nTransmit/Receive......................................, 1 = 331. CAN Message Transmission Aborting............................................................., 1 = .................................... 332 332. Initiating............................................................., 1 = 332.",
    "E\nPriority..............................................................., 1 = 333. CAN Modes of Operation.........................................., 1 = 328. CAN Registers, 1 = .......................................................... 277. Configuration Mode..................................................., 1 = 328. Dedicated CAN Receive Buffer Registers",
    "E\n................................................, 1 = 291. Dedicated CAN Transmit Buffer Registers ................................................, 1 = 285. Disable Mode............................................................, 1 = 328. Error Detection.........................................................., 1 = 341.",
    "E\nAcknowledge....................................................., 1 = 341. Bit......................................................................, 1 = 341. CRC.................................................................. Error Modes and Counters................................, 1 = 341 341. Error",
    "E\nStates......................................................., 1 = 341. Form.................................................................., 1 = 341. , 1 = 341. Stuff Bit ............................................................. Error Modes State (diagram), 1 = .................................... 342. Error Recognition",
    "E\nMode............................................, 1 = 330. Filter-Mask Truth (table)............................................, 1 = 335. Functional Modes......................................................, 1 = 330. Mode 0 - Legacy, 1 = 330. Mode....................................., 1 = 330. Mode 1 - Enhanced Legacy Mode",
    "E\n............................................, 1 = . Mode 2 - Enhanced FIFO Mode................................................, 1 = . , 1 = 331",
    "E\n(IPT).................................................................., 1 = 338. Lengthening a Bit Period .........................................., 1 = 339. Listen Only Mode......................................................, 1 = 330. Loopback Mode........................................................, 1 = 330. Message Acceptance",
    "E\nFilters and Masks................................................, 1 = 306, 335. Message Acceptance Mask and Filter Operation................................................., 1 = 336. Message Reception.................................................., 1 = 334. Enhanced FIFO Mode......................................, 1 = 335. Priority",
    "E\n.............................................................., 1 = 334. Time-Stamping ................................................., 1 = 335. Normal Mode............................................................, 1 = 328. Oscillator Tolerance.................................................., 1 = 340.",
    "E\nOverview..................................................................., 1 = 275. Phase Buffer Segments............................................, 1 = 338. Programmable TX/RX and Auto-RTR Buffers ............................................., 1 = 297. Programming Time Segments.................................., 1 = 340. Propagation",
    "E\nSegment..............................................., 1 = 338. Sample Point ............................................................, 1 = 338. Shortening a Bit Period............................................., 1 = 340. Synchronization........................................................, 1 = 339.",
    "E\nHard.................................................................., 1 = 339. Resynchronization............................................ Rules ................................................................, 1 = 339 339. Synchronization Segment........................................., 1 = 338. Time",
    "E\nQuanta............................................................., 1 = 338. Characteristics, 1 = 413. Electrical .................................................. Enhanced Capture/Compare/PWM (ECCP) ....................................................................., 1 = 175.",
    "E\nOutputs..................................................................... Enhanced PWM Mode., 1 = 176. See PWM (ECCP, 1 = . Module). Enhanced Universal Synchronous Asynchronous Receiver Transmitter (USART)................................................ Errata...................................................................................., 1 = 229 7 328. Error Recognition",
    "E\nMode.................................................... Evaluation and Programming Tools.................................., 1 = 411. Example SPI Mode Requirements (Master Mode, CKE = 0)........................................... Example SPI Mode Requirements, 1 = 437. (Master Mode, CKE = Example SPI Mode Requirements, 1 = 438. 1)........................................... (Slave Mode, CKE =, 1 = 439.",
    "E\n0)............................................. Example SPI Slave Mode Requirements (CKE = 1).................................................................., 1 = 440. External Clock Timing Requirements ..........................................................., 1 = 428. External Memory Interface.................................................. 16-bit",
    "E\nByte Select, 1 = 93. Mode.............................................. 16-bit Byte Write Mode..............................................., 1 = 98. 16-bit Mode................................................................., 1 = 96. 16-bit Mode Timing....................................................., 1 = 96 99. 16-bit Word",
    "E\nWrite, 1 = . Mode.............................................. PIC18F8X8X External Bus, 1 = 97. I/O Port Functions..............................................., 1 = 95. Program Memory Modes............................................, 1 = . , 1 = 93",
    "F\nFlash Program Memory, 365 = ...................................................... 83. Associated Registers, 365 = .................................................. 92. Control Registers, 365 = ........................................................ 84. Erase Sequence, 365 = ......................................................... 88.",
    "F\nErasing........................................................................, 365 = 88. Operation During Code, 365 = . Protection............................................................, 365 = 92. Reading......................................................................., 365 = 87. Table Pointer, 365 = . Boundaries Based on",
    "F\nOperation........................., 365 = 86. Table Pointer Boundaries ..........................................., 365 = 86. Table Reads and Table Writes, 365 = ................................... 83. Write Sequence, 365 = .......................................................... 90. Writing, 365 = 89.",
    "F\nto..................................................................... Protection Against Spurious, 365 = . Writes.........................................................., 365 = 92. Unexpected Termination....................................., 365 = 92. Write Verify, 365 = ......................................................... 92. G, 365 = .",
    "F\nGeneral Call Address Support .........................................., 365 = 212. GOTO ..............................................................................., 365 = 386. H, 365 = . Hardware Multiplier ..........................................................., 365 = 107. Introduction",
    "F\n..............................................................., 365 = 107. Operation .................................................................., 365 = 107. Performance Comparison, 365 = . (table)................................................................, 365 = 107. I, 365 = . I/O",
    "F\nPorts............................................................................ 2, 365 = 125. I C Bus Data Requirements, 365 = 442. (Slave Mode)............................................................., 365 = 441. 2 C Bus Start/Stop Bits Requirements, 365 = . I (Slave Mode)............................................................. 2, 365 = . I C Mode General Call Address Support,",
    "F\n365 = .................................. 212. Master Mode, 365 = . .........................................................., 365 = 214. Read/Write Bit Information, 365 = . Operation (R/W Bit), 365 = ................................................... 202, 203. ID Locations .............................................................., 365 = 345, 362.",
    "F\nINCF.................................................................................., 365 = 386. , 365 = 387. INCFSZ............................................................................., 365 = 362. In-Circuit Debugger........................................................... Resources",
    "F\n(table)......................................................, 365 = 362. In-Circuit Serial Programming (ICSP) ..............................................................., 365 = 345, 362. Indirect Addressing, 365 = . INDF and FSR Registers ............................................, 365 = 79. Operation",
    "F\n...................................................................., 365 = 79. Indirect File Operand, 365 = .......................................................... 59 387. INFSNZ............................................................................. Instruction Flow/Pipelining, 365 =",
    "F\n.................................................. 57. Instruction Format............................................................., 365 = 367",
    "PIC18F6585/8585/6680/8680\nSLEEP, 1 = ...................................................................... 400. SUBFWP..................................................................., 1 = 400. SUBLW....................................................................., 1 = 401.",
    "PIC18F6585/8585/6680/8680\nSUBWF....................................................................., 1 = 401. SUBWFB..................................................................., 1 = 402. SWAPF....................................................................., 1 = 402. TBLRD, 1 =",
    "PIC18F6585/8585/6680/8680\n...................................................................... 403. TBLWT......................................................................, 1 = 404. TSTFSZ, 1 = .................................................................... 405.",
    "PIC18F6585/8585/6680/8680\nXORLW....................................................................., 1 = 405. XORWF....................................................................., 1 = 406. Summary Table......................................................... INT Interrupt (RB0/INT)., 1 = 368. See Interrupt Sources. INTCON Registers",
    "PIC18F6585/8585/6680/8680\n............................................................, 1 = . Inter-Integrated Circuit. See I 2, 1 = 111. C. Sources..............................................................., 1 = . Interrupt, 1 = 345. A/D Conversion Complete, 1 = ........................................ 253. Capture Complete",
    "PIC18F6585/8585/6680/8680\n(CCP).........................................., 1 = 170. Compare Complete (CCP)........................................, 1 = 171 ............................................................ ECAN Module, 1 = 342. INT0",
    "PIC18F6585/8585/6680/8680\n.........................................................................., 1 = 124. Interrupt-on-Change, 1 = . (RB7:RB4)........................................................., 1 = 128. PORTB, Interrupt-on-Change, 1 = ................................... 124. RB0/INT Pin,",
    "PIC18F6585/8585/6680/8680\nExternal..............................................., 1 = 124. TMR0........................................................................, 1 = 124. TMR0 Overflow, 1 = ......................................................... 157 159, 161. TMR1 Overflow",
    "PIC18F6585/8585/6680/8680\n................................................. TMR2 to PR2 Match ................................................., 1 = 163. TMR2 to PR2 Match (PWM) ....................., 1 = 162, 173, 177. TMR3 Overflow ................................................., 1 = 164, 166.",
    "PIC18F6585/8585/6680/8680\nInterrupts..........................................................................., 1 = 109. Context Saving During, 1 = . Interrupts..........................................................., 1 = 124 ....................................................... Control Registers, 1 = 111. Enable",
    "PIC18F6585/8585/6680/8680\nRegisters......................................................., 1 = 117. Flag Registers..........................................................., 1 = 114. Logic (diagram), 1 = ......................................................... 110. Priority",
    "PIC18F6585/8585/6680/8680\nRegisters......................................................., 1 = 120. Reset Control Registers............................................, 1 = 123. Interrupts, Flag Bits, 1 = . CCP Flag (CCPxIF Bit) ............................., 1 = 169, 170, 171. IORLW, 1 = 388.",
    "PIC18F6585/8585/6680/8680\n.............................................................................. IORWF.............................................................................., 1 = 388. IPR Registers...................................................................., 1 = 120.",
    "PIC18F6585/8585/6680/8680\nL, 1 = . LFSR................................................................................., 1 = 389. Listen Only Mode.............................................................., 1 = 328. Look-up Tables, 1 = . Computed GOTO........................................................, 1 = 58. Table Reads/Table",
    "PIC18F6585/8585/6680/8680\nWrites, 1 = .......................................... 58. Loopback Mode................................................................., 1 = 328 269. Low-Voltage Detect..........................................................., 1 =",
    "PIC18F6585/8585/6680/8680\n.......................................................... 424. Characteristics Converter Characteristics, 1 = ......................................... 424. Reset......................................................, 1 = . Effects of a, 1 = 273 272. Operation",
    "PIC18F6585/8585/6680/8680\n.................................................................., 1 = 273. Current Consumption........................................, 1 = . During Sleep ....................................................., 1 = 273. Reference Voltage Set Point............................. Typical Application",
    "PIC18F6585/8585/6680/8680\n...................................................., 1 = 273 269. Low-Voltage ICSP Programming, 1 = . , 1 = ...................................... 363. LVD. See Low-Voltage Detect., 1 = ",
    "M\nMaster SSP I 2 C Bus, 1 = . Data Requirements................................................... Master SSP I 2 C Bus Start/Stop Bits, 1 = 444 443. Requirements ........................................................... Master Synchronous Serial Port (MSSP). See MSSP., 1 = . Memory Organization, 1 = . Data Memory.............................................................., 1 = 59. PIC18F8X8X Program Memory",
    "M\nModes......................, 1 = 51. Extended Microcontroller...................................., 1 = 51. Microcontroller...................................................., 1 = 51. Microprocessor..................................................., 1 = 51. Microprocessor with, 1 = . Boot Block, 1 =",
    "M\n.................................................. 51. Program Memory........................................................, 1 = 51. Memory Programming Requirements............................... Migration from High-End to, 1 = 425. Enhanced Devices...................................................., 1 = 471. Migration from Mid-Range to",
    "M\nDevices...................................................., 1 = . Enhanced, 1 = 470. MOVF..............................................................................., 1 = 389. MOVFF............................................................................., 1 = 390.",
    "M\nMOVLB............................................................................., 1 = 390. MOVLW............................................................................, 1 = 391 391. MOVWF............................................................................ MPLAB",
    "M\nASM30 Assembler,, 1 = . Linker, Librarian........................................................, 1 = 408. MPLAB ICD 2 In-Circuit Debugger ................................... MPLAB ICE 2000 High-Performance, 1 = 409. Universal In-Circuit Emulator...................................................., 1 = 409. MPLAB ICE 4000 High-Performance Universal",
    "M\nEmulator...................................................., 1 = 409. In-Circuit MPLAB Integrated Development, 1 = . Environment Software .............................................. MPLAB PM3 Device Programmer, 1 = 407. , 1 = 409. MPLINK Object Linker/, 1 = ..................................... MPLIB Object Librarian............................................., 1 = 408.",
    "M\nMSSP................................................................................, 1 = 189. ACK Pulse ........................................................, 1 = 202, 203. Clock Stretching........................................................, 1 = 208. 10-bit Slave Receive Mode, 1 = . (SEN =",
    "M\n1).................................................., 1 = 208. 10-bit Slave Transmit Mode.............................. 7-bit Slave Receive Mode, 1 = 208. (SEN = 1).................................................., 1 = 208. , 1 = 208. 7-bit Slave Transmit Mode................................ Clock Synchronization and the, 1 = . CKP",
    "M\nBit............................................................., 1 = 209. Control Registers (general)......................................., 1 = 189. I 2 C Mode .................................................................., 1 = 198. Acknowledge Sequence Timing, 1 = ....................... 222. Baud Rate Generator, 1 =",
    "M\n....................................... 215. Bus Collision, 1 = . During a Repeated, 1 = . Start Bus Collision During a, 1 = Condition.................................. 226. , 1 = 224. Start Condition.......................................... Bus Collision During a, 1 = 227. Clock Arbitration ..............................................., 1 = 216. Stop Condition..........................................",
    "M\nEffect of a Reset..............................................., 1 = 223. I 2 C Clock Rate w/BRG, 1 = ..................................... 215",
    "PIC18F6585/8585/6680/8680\nMaster Mode....................................................., 1 = 213. Reception.................................................. Repeated Start Condition, 1 = 219. Timing..............................................., 1 = 218. Transmission ............................................ Master Mode Start Condition, 1 = 219",
    "PIC18F6585/8585/6680/8680\n............................. , 1 = 217. Module Operation ............................................., 1 = 202. Multi-Master Communication, Bus Collision and, 1 = . Arbitration ................................................., 1 = 223. Multi-Master Mode............................................, 1 = 223.",
    "PIC18F6585/8585/6680/8680\nRegisters..........................................................., 1 = 198. Slave Mode......................................................., 1 = 202. Slave Mode, Addressing..................................., 1 = 202. Slave Mode, Reception....................................., 1 = 203. Slave Mode, Transmission, 1 =",
    "PIC18F6585/8585/6680/8680\n............................... 203. Sleep Operation................................................, 1 = 223. Stop Condition Timing, 1 = ...................................... 222. I 2 C Mode. See I 2 C., 1 = . Overview..................................................................., 1 = 189. SPI",
    "PIC18F6585/8585/6680/8680\nMode.................................................................., 1 = 189. Associated Registers ........................................, 1 = 197. Bus Mode Compatibility ............................................., 1 = .................................... 197. Effects of a Reset, 1 = 197. Enabling SPI I/O, 1 =",
    "PIC18F6585/8585/6680/8680\n............................................... 193. Master Mode....................................................., 1 = 194. Operation, 1 = .......................................................... 192. Slave Mode......................................................., 1 = 195. Slave Select Synchronization,",
    "PIC18F6585/8585/6680/8680\n1 = ........................................ 195 197. Sleep Operation................................................ SPI Clock .........................................................., 1 = 194. Typical Connection, 1 = ........................................... 193. SPI Mode. See SPI. SSPBUF Register",
    "PIC18F6585/8585/6680/8680\n....................................................., 1 = 194 ........................................................ SSPSR Register MSSP Module, 1 = 194. SPI Master/Slave, 1 = Connection................................... 193.",
    "PIC18F6585/8585/6680/8680\nMULLW............................................................................., 1 = 392. MULWF............................................................................., 1 = 392. N, 1 = .",
    "PIC18F6585/8585/6680/8680\nNEGF................................................................................, 1 = 393. NOP.................................................................................., 1 = 393. Normal Operation Mode...................................................., 1 = 328. O, 1 =",
    "PIC18F6585/8585/6680/8680\n. Opcode Field Descriptions................................................, 1 = 366. OPTION_REG Register, 1 = . PSA Bit......................................................................, 1 = 157. T0CS Bit...................................................................., 1 = 157. T0PS2:T0PS0",
    "PIC18F6585/8585/6680/8680\nBits...................................................., 1 = 157. T0SE Bit...................................................................., 1 = 157. Oscillator Configuration......................................................., 1 = 23.",
    "PIC18F6585/8585/6680/8680\nEC..............................................................................., 1 = 23. ECIO, 1 = ........................................................................... 23. ECIO+PLL..................................................................., 1 =",
    "PIC18F6585/8585/6680/8680\n23. ECIO+SPLL, 1 = ................................................................ 23. HS..............................................................................., 1 = 23. HS+PLL, 1 = ...................................................................... 23.",
    "PIC18F6585/8585/6680/8680\nHS+SPLL...................................................................., 1 = 23 23. LP................................................................................ RC..............................................................................., 1 =",
    "PIC18F6585/8585/6680/8680\n23. RCIO..........................................................................., 1 = 23. XT ..............................................................................., 1 = 23",
    "PIC18F6585/8585/6680/8680\nOscillator Selection..........................................................., 1 = Oscillator Selection............................................................ Oscillator Selection..........................................................., 2 = Oscillator",
    "PIC18F6585/8585/6680/8680\nSelection............................................................ Oscillator Selection..........................................................., 3 = 345. Oscillator Start-up Timer (OST).................................. 34,, 1 = Oscillator Start-up Timer (OST).................................. 34,. Oscillator Start-up Timer",
    "PIC18F6585/8585/6680/8680\n(OST).................................. 34,, 2 = Oscillator Start-up Timer (OST).................................. 34,. Oscillator Start-up Timer (OST).................................. 34,, 3 = 345. Oscillator Switching Feature System, 1 = Clock Switch Bit.............................................. Oscillator Switching Feature System, 2 = Oscillator Switching Feature System. Oscillator Switching Feature System, 3 = 27. Oscillator,, 1 =",
    "PIC18F6585/8585/6680/8680\nTimer1.............................................. 159,. Oscillator,, 2 = 161,. Oscillator,, 3 = 166. Oscillator,, 1 = Timer3............................................................... Oscillator,, 2 = . Oscillator,, 3 = 164. Oscillator,, 1 = WDT..................................................................",
    "PIC18F6585/8585/6680/8680\nOscillator,, 2 = . Oscillator,, 3 = 355",
    "P\nPackaging........................................................................., 1 = 465. Details......................................................................., 1 = 466. Marking....................................................................., 1 = 465. Parallel Slave Port",
    "P\n(PSP).........................................., 1 = 133, 152. Associated Registers................................................, 1 = 154. RE0/RD/AD8 Pin ......................................................, 1 = 152. RE1/WR/AD9 Pin, 1 = ..................................................... 152. RE2/CS/AD10 Pin, 1 =",
    "P\n.................................................... 152. Select (PSPMODE Bit) ....................................., 1 = 133, 152. Parallel Slave Port Requirements (PIC18FXX8X).........................................................., 1 = 436. Phase Locked Loop (PLL).................................................., 1 = 25. PICkit 1 Flash Starter Kit",
    "P\n.................................................., 1 = 411. PICSTART Plus Development Programmer.............................................................., 1 = 410. PIE Registers...................................................................., 1 = 117. Pin Functions, 1 = .",
    "P\nAVDD..........................................................................., 1 = 21. AVSS ..........................................................................., 1 = 21. OSC1/CLKI................................................................., 1 = 12.",
    "P\nOSC2/CLKO/RA6......................................................., 1 = 12. RA0/AN0....................................................................., 1 = 13. RA1/AN1....................................................................., 1 = 13. RA2/AN2/VREF-",
    "P\n.........................................................., 1 = 13. RA3/AN3/VREF+ ........................................................., 1 = 13. RA4/T0CKI, 1 = ................................................................. 13.",
    "P\nRA5/AN4/LVDIN........................................................., 1 = 13. RA6............................................................................., 1 = 13. RB0/INT0...................................................................., 1 = 14.",
    "P\nRB1/INT1...................................................................., 1 = 14. RB2/INT2...................................................................., 1 = 14. RB3/INT3/CCP2........................................................., 1 = 14.",
    "P\nRB4/KBI0...................................................................., 1 = 14. RB5/KBI1/PGM..........................................................., 1 = 14. RB6/KBI2/PGC..........................................................., 1 = 14.",
    "P\nRB7/KBI3/PGD..........................................................., 1 = 14. RC0/T1OSO/T13CKI.................................................., 1 = 15. RC1/T1OSI/CCP2, 1 = ...................................................... 15.",
    "P\nRC2/CCP1/P1A.........................................................., 1 = 15. RC3/SCK/SCL............................................................, 1 = 15. RC4/SDI/SDA............................................................., 1 = 15.",
    "P\nRC5/SDO...................................................................., 1 = 15 15. RC6/TX/CK................................................................., 1 = . RC7/RX/DT................................................................., 1 = 15.",
    "P\nRD0/PSP0/AD0.........................................................., 1 = 16 16. RD1/PSP1/AD1.........................................................., 1 = 16. RD2/PSP2/AD2.........................................................., 1 = .",
    "P\nRD3/PSP3/AD3.........................................................., 1 = 16. RD4/PSP4/AD4.........................................................., 1 = 16 16. RD5/PSP5/AD5.........................................................., 1 = .",
    "P\nRD6/PSP6/AD6.........................................................., 1 = 16. RD7/PSP7/AD7.......................................................... RE0/RD/AD8 .............................................................., 1 = 16 17.",
    "P\nRE1/WR/AD9.............................................................., 1 = 17",
    "PIC18F6585/8585/6680/8680\nRE2/CS/AD10............................................................., 1 = 17. RE3/AD11..................................................................., 1 = 17. RE4/AD12..................................................................., 1 = 17.",
    "PIC18F6585/8585/6680/8680\nRE5/AD13/P1C..........................................................., 1 = 17. RE6/AD14/P1B, 1 = ........................................................... 17 ......................................................... RE7/CCP2/AD15, 1 = 17. RF0/AN5, 1 =",
    "PIC18F6585/8585/6680/8680\n..................................................................... 18. RF1/AN6/C2OUT........................................................, 1 = 18. RF2/AN7/C1OUT........................................................, 1 = 18.",
    "PIC18F6585/8585/6680/8680\nRF3/AN8/C2IN+.........................................................., 1 = 18. RF4/AN9/C2IN-..........................................................., 1 = 18. RF5/AN10/C1IN+/CVREF, 1 = ............................................ 18.",
    "PIC18F6585/8585/6680/8680\nRF6/AN11/C1IN-........................................................., 1 = 18. RF7/SS ......................................................................., 1 = 18. RG0/CANTX1, 1 = ............................................................. 19. RG1/CANTX2, 1 =",
    "PIC18F6585/8585/6680/8680\n............................................................. 19. RG2/CANRX..............................................................., 1 = 19. RG3............................................................................., 1 = 19.",
    "PIC18F6585/8585/6680/8680\nRG4/P1D....................................................................., 1 = 19. RG5/MCLR/VPP, 1 = .......................................................... 12. RH0/A16, 1 = ..................................................................... 20",
    "PIC18F6585/8585/6680/8680\n...................................................................... RH1/A17, 1 = 20. RH2/A18, 1 = ..................................................................... 20. RH3/A19, 1 = ..................................................................... 20.",
    "PIC18F6585/8585/6680/8680\nRH4/AN12..................................................................., 1 = 20 20. RH5/AN13..................................................................., 1 = RH6/AN14/P1C........................................................... 20.",
    "PIC18F6585/8585/6680/8680\nRH7/AN15/P1B..........................................................., 1 = 20. RJ0/ALE......................................................................, 1 = 21. RJ1/OE, 1 = ....................................................................... 21.",
    "PIC18F6585/8585/6680/8680\nRJ2/WRL....................................................................., 1 = 21. RJ3/WRH...................................................................., 1 = 21. RJ4/BA0......................................................................, 1 = 21 21.",
    "PIC18F6585/8585/6680/8680\nRJ5/CE........................................................................ RJ6/LB, 1 = ........................................................................ 21. RJ7/UB........................................................................, 1 = 21.",
    "PIC18F6585/8585/6680/8680\nVDD.............................................................................., 1 = 21. VSS, 1 = .............................................................................. 21. PIR Registers....................................................................",
    "PIC18F6585/8585/6680/8680\nPLL Clock Timing Specifications......................................., 1 = 114 429. PLL Lock Time-out.............................................................., 1 = 34. Pointer, FSR........................................................................, 1 = 79.",
    "PIC18F6585/8585/6680/8680\nPOP..................................................................................., 1 = 394. POR. See Power-on Reset., 1 = . PORTA, 1 = . Associated Registers, 1 = ................................................ 127. Functions, 1 = .................................................................. 127. LATA",
    "PIC18F6585/8585/6680/8680\nRegister..........................................................., 1 = 125. PORTA Register, 1 = ....................................................... 125. TRISA Register ........................................................., 1 = 125. PORTB, 1 = . Associated Registers, 1 =",
    "PIC18F6585/8585/6680/8680\n................................................ 130. Functions, 1 = .................................................................. 130. LATB Register..........................................................., 1 = 128. PORTB Register, 1 =",
    "PIC18F6585/8585/6680/8680\n....................................................... 128. RB0/INT Pin, External..............................................., 1 = 124. TRISB Register, 1 = ......................................................... 128. PORTC, 1 = . Associated Registers, 1 = ................................................ 132.",
    "PIC18F6585/8585/6680/8680\nFunctions, 1 = .................................................................. 132. LATC Register, 1 = .......................................................... 131. PORTC Register ......................................................., 1 = 131. RC3/SCK/SCL Pin TRISC",
    "PIC18F6585/8585/6680/8680\nRegister........................................................., 1 = .................................................... 203 131",
    "PIC18F6585/8585/6680/8680\nPORTD............................................................................., 1 = 152. Associated Registers................................................, 1 = 135. Functions.................................................................., 1 = 135. LATD Register",
    "PIC18F6585/8585/6680/8680\n.........................................................., 1 = 133. Parallel Slave Port (PSP) Function............................................................, 1 = 133. PORTD Register......................................................., 1 = 133. TRISD",
    "PIC18F6585/8585/6680/8680\nRegister........................................................., 1 = 133. PORTE, 1 = . Analog Port Pins......................................................., 1 = 152. Associated Registers................................................, 1 = 138.",
    "PIC18F6585/8585/6680/8680\nFunctions.................................................................., 1 = 138. LATE Register, 1 = .......................................................... 136. PORTE Register......................................................., 1 = 136. PSP Mode Select (PSPMODE Bit), 1 =",
    "PIC18F6585/8585/6680/8680\n........................................ 133, 152 ....................................................... RE0/RD/AD8 Pin, 1 = 152. RE1/WR/AD9 Pin......................................................, 1 = 152. RE2/CS/AD10 Pin....................................................., 1 =",
    "PIC18F6585/8585/6680/8680\n152. TRISE Register........................................................., 1 = 136. PORTF, 1 = . Associated Registers................................................, 1 = 141. Functions.................................................................., 1 = 141. LATF",
    "PIC18F6585/8585/6680/8680\nRegister..........................................................., 1 = 139. PORTF Register......................................................., 1 = 139. TRISF Register........................................................., 1 = 139. PORTG, 1 = . Associated",
    "PIC18F6585/8585/6680/8680\nRegisters................................................, 1 = 145. Functions.................................................................., 1 = 145. LATG Register.........................................................., 1 = 142. PORTG",
    "PIC18F6585/8585/6680/8680\nRegister......................................................., 1 = 142. TRISG Register, 1 = ........................................................ 142. PORTH, 1 = . Associated Registers................................................, 1 = 148.",
    "PIC18F6585/8585/6680/8680\nFunctions.................................................................., 1 = 148. LATH Register .........................................................., 1 = 146. PORTH Register......................................................., 1 = 146. TRISH, 1 =",
    "PIC18F6585/8585/6680/8680\nRegister......................................................... 146. PORTJ, 1 = . Associated Registers................................................, 1 = 151. Functions.................................................................., 1 = 151. LATJ",
    "PIC18F6585/8585/6680/8680\nRegister..........................................................., 1 = 149. PORTJ Register........................................................, 1 = 149. TRISJ Register, 1 = ......................................................... 149. Postscaler, WDT, 1 = . Assignment (PSA Bit), 1 =",
    "PIC18F6585/8585/6680/8680\n............................................... 157. Rate Select, 1 = . (T0PS2:T0PS0 Bits) ........................................., 1 = 157. Power-down Mode. See Sleep., 1 = . Power-on Reset (POR)..............................................., 1 = 34, 345. Power-up Delays, 1 =",
    "PIC18F6585/8585/6680/8680\n................................................................ 31. Power-up Timer Prescaler, 1 = (PWRT)............................................ 34, 345. Timer2, 1 = ...................................................................... 177. Prescaler,",
    "PIC18F6585/8585/6680/8680\nCapture............................................................, 1 = 170. Prescaler, Timer0 ............................................................., 1 = 157. Assignment (PSA Bit) ..............................................., 1 = 157. Rate Select (T0PS2:T0PS0 Bits), 1 =",
    "PIC18F6585/8585/6680/8680\n......................................... 157. Prescaler, Timer2 ............................................................. PRO MATE II Universal Device, 1 = 173. Programmer.............................................................., 1 = . , 1 = 409",
    "PIC18F6585/8585/6680/8680\nProgram Counter PCL, PCLATH and PCLATU, ........................................... 487 = . Registers............................................................., ........................................... 487 = 56. Program Memory, ........................................... 487 = .",
    "PIC18F6585/8585/6680/8680\nInstructions.................................................................., ........................................... 487 = 57. Two-Word, ........................................... 487 = ........................................................... 58. Interrupt Vector",
    "PIC18F6585/8585/6680/8680\n..........................................................., ........................................... 487 = 51. Map and Stack for PIC18F6585/8585..............................................., ........................................... 487 = 52. Map and Stack for",
    "PIC18F6585/8585/6680/8680\nPIC18F6680/8680............................................... Memory Access for, ........................................... 487 = 52. PIC18F8X8X Modes........................................... Memory Maps for, ........................................... 487 = 52. PIC18F8X8X",
    "PIC18F6585/8585/6680/8680\nModes..........................................., ........................................... 487 = 53. Reset Vector ..............................................................., ........................................... 487 = 51. Program Memory Modes,",
    "PIC18F6585/8585/6680/8680\n........................................... 487 = . Extended Microcontroller, ........................................... 487 = ............................................ 93. Microcontroller, ........................................... 487 =",
    "PIC18F6585/8585/6680/8680\n............................................................ 93. Microprocessor ..........................................................., ........................................... 487 = 93. Microprocessor with, ........................................... 487 = . Boot",
    "PIC18F6585/8585/6680/8680\nBlock..........................................................., ........................................... 487 = 93. Program Memory Write Timing Requirements............................................................, ........................................... 487 = 432. Program Verification and,",
    "PIC18F6585/8585/6680/8680\n........................................... 487 = . Associated Registers, ........................................... 487 = ................................................ 359. Configuration Register, ........................................... 487 = .",
    "PIC18F6585/8585/6680/8680\nProtection.........................................................., ........................................... 487 = 362. Data EEPROM Code, ........................................... 487 = . Protection..........................................................,",
    "PIC18F6585/8585/6680/8680\n........................................... 487 = 362. Memory Code Protection .........................................., ........................................... 487 = 360. Programming, Device Instructions PSP. See Parallel Slave Port., ........................................... 487 = .................................... 365.",
    "PIC18F6585/8585/6680/8680\nPUSH................................................................................, ........................................... 487 = 394. PWM (CCP Module) ........................................................., ........................................... 487",
    "PIC18F6585/8585/6680/8680\n= 173. CCPR1H:CCPR1L Registers...................................., ........................................... 487 = 177. CCPR1L:CCPR1H, ........................................... 487 = Registers.................................... 173. Duty",
    "PIC18F6585/8585/6680/8680\nCycle......................................................... Example Frequencies/, ........................................... 487 = 173, 177. ..............................................., ........................................... 487 = . Resolutions,",
    "PIC18F6585/8585/6680/8680\n........................................... 487 = 174, 178. Period................................................................ Registers Associated with PWM, ........................................... 487 = 173, 177. and Timer2........................................................,",
    "PIC18F6585/8585/6680/8680\n........................................... 487 = 187. Setup for PWM Operation........................................., ........................................... 487 = 174. TMR2 to PR2 Match ................................., ........................................... 487 = 162, 173, 177. PWM",
    "PIC18F6585/8585/6680/8680\n(CCP Module) and Timer2 Associated Registers ................................................, ........................................... 487 = 174. PWM (ECCP Module) ......................................................., ........................................... 487 = 177. Effects of a",
    "PIC18F6585/8585/6680/8680\nReset......................................................, ........................................... 487 = 187. Enhanced PWM Auto-Shutdown, ........................................... 487 = .............................. 184.",
    "PIC18F6585/8585/6680/8680\nExample............................................................, ........................................... 487 = 182. Full-Bridge Mode......................................................., ........................................... 487 = 181. Direction",
    "PIC18F6585/8585/6680/8680\nChange.............................................., ........................................... 487 = 182. Half-Bridge Mode......................................................, ........................................... 487 = 180. Half-Bridge Output Mode Applications Example,",
    "PIC18F6585/8585/6680/8680\n........................................... 487 = ....................................... 180. Output Configurations............................................... Output Relationships, ........................................... 487 = 177. (Active-High State)............................................,",
    "PIC18F6585/8585/6680/8680\n........................................... 487 = 178\nOutput Relationships\n(Active-Low State)............................................ 179\nProgrammable Dead-Band Delay............................. 184\nPWM Direction Change (diagram)............................ 183\nPWM Direction Change at Near 100%\nDuty Cycle (diagram)........................................ 183",
    "PIC18F6585/8585/6680/8680\nSetup for Operation .................................................. 187\nStart-up Considerations............................................ 186",
    "Q\nQ Clock..................................................................... 173, 177",
    "R\nRCALL.............................................................................., Oscillator....................................................................... 24 = 395. , Oscillator....................................................................... 24 = 123. RCON",
    "R\nRegister................................................................., Oscillator....................................................................... 24 = . RCSTA Register, Oscillator....................................................................... 24 = . SPEN",
    "R\nBit..................................................................., Oscillator....................................................................... 24 = 229. Register File........................................................................,",
    "R\nOscillator....................................................................... 24 = 59. Register File Summary................................................., Oscillator....................................................................... 24 = 67-77. Registers,",
    "R\nOscillator....................................................................... 24 = . ADCON0 (A/D Control 0).........................................., Oscillator....................................................................... 24 = 249. ADCON1 (A/D Control",
    "R\n1).........................................., Oscillator....................................................................... 24 = 250. ADCON2 (A/D Control 2).........................................., Oscillator....................................................................... 24 =",
    "R\n251. BAUDCON (Baud Rate Control)..............................., Oscillator....................................................................... 24 = 232. BIE0 (Buffer Interrupt Enable 0), Oscillator....................................................................... 24 = ............................... 322. BnCON (TX/RX Buffer n Control,,",
    "R\nOscillator....................................................................... 24 = . Receive Mode) ................................................., Oscillator....................................................................... 24 = 297. BnCON (TX/RX Buffer n Control,,",
    "R\nOscillator....................................................................... 24 = . Transmit Mode) ................................................, Oscillator....................................................................... 24 = 298. BnDLC (TX/RX Buffer n Data Length",
    "R\nMode)...................................., Oscillator....................................................................... 24 = . Code in Receive, Oscillator....................................................................... 24 = 304. BnDLC (TX/RX Buffer n Data Length Code in Transmit Mode)...................................,",
    "R\nOscillator....................................................................... 24 = 305. BnDm (TX/RX Buffer n Data Field Byte in Receive Mode).............................................., Oscillator....................................................................... 24 = m 303. BnDm (TX/RX Buffer n Data Field Byte m,",
    "R\nOscillator....................................................................... 24 = . in Transmit Mode)............................................., Oscillator....................................................................... 24 = 303. BnEIDH (TX/RX Buffer n Extended,",
    "R\nOscillator....................................................................... 24 = . Identifier, High Byte in, Oscillator....................................................................... 24 = . Receive Mode) .................................................,",
    "R\nOscillator....................................................................... 24 = 301. BnEIDH (TX/RX Buffer n Extended, Oscillator....................................................................... 24 = . Identifier, High Byte in, Oscillator....................................................................... 24 = .",
    "R\nTransmit Mode) ................................................, Oscillator....................................................................... 24 = 301. BnEIDL (TX/RX Buffer n Extended, Oscillator....................................................................... 24 = . Identifier, Low Byte in,",
    "R\nOscillator....................................................................... 24 = . , Oscillator....................................................................... 24 = 302. Receive Mode) .................................................,",
    "R\nOscillator....................................................................... 24 = . BnEIDL (TX/RX Buffer n Extended, Oscillator....................................................................... 24 = ................................................ 302. BnSIDH (TX/RX Buffer n Standard,",
    "R\nOscillator....................................................................... 24 = . Identifier, High Byte in, Oscillator....................................................................... 24 = . Receive Mode) .................................................,",
    "R\nOscillator....................................................................... 24 = 299. BnSIDH (TX/RX Buffer n Standard, Oscillator....................................................................... 24 = . Identifier, High Byte in, Oscillator....................................................................... 24 = .",
    "R\nTransmit Mode) ................................................, Oscillator....................................................................... 24 = 299. BnSIDL (TX/RX Buffer n Standard, Oscillator....................................................................... 24 = . in,",
    "R\nOscillator....................................................................... 24 = . Identifier, Low Byte, Oscillator....................................................................... 24 = . , Oscillator....................................................................... 24 = 300. Receive Mode)",
    "R\n................................................., Oscillator....................................................................... 24 = ",
    "PIC18F6585/8585/6680/8680\nBnSIDL (TX/RX Buffer n Standard\nIdentifier, Low Byte in Transmit Mode)................................................., 1 = 300. BRGCON1 (Baud Rate Control 1), 1 = ............................ 315. BRGCON2 (Baud Rate Control 2), 1 = ............................ 316. BRGCON3 (Baud Rate Control 3), 1 = ............................ 317. BSEL0 (Buffer Select",
    "PIC18F6585/8585/6680/8680\n0)............................................, 1 = 305. CANCON (CAN Control)..........................................., 1 = 278. CANSTAT (CAN Status), 1 = ........................................... 279. CCP1CON (CCP1 Control)..............................., 1 = 167, 175. CCP2CON (CCP2",
    "PIC18F6585/8585/6680/8680\nControl)......................................., 1 = 168. CIOCON (CAN I/O Control), 1 = ...................................... 318. CMCON (Comparator Control), 1 = ................................. 259. COMSTAT (CAN Communication, 1 = Status)........................... 284. CONFIG1H (Configuration 1 High), 1 = ........................... 347. CONFIG2H (Configuration 2 High), 1 =",
    "PIC18F6585/8585/6680/8680\n........................... 349. CONFIG2L (Configuration 2 Low)............................., 1 = 348. CONFIG3H (Configuration 3 High), 1 = ........................... 350. CONFIG3L (Configuration 3 Low)............................., 1 = 349. CONFIG3L (Configuration Byte), 1 = ................................. 53. CONFIG4L (Configuration 4",
    "PIC18F6585/8585/6680/8680\nLow)............................., 1 = 350. CONFIG5H (Configuration 5 High), 1 = ........................... 351. CONFIG5L (Configuration 5 Low)............................., 1 = 351. CONFIG6H (Configuration 6 High), 1 = ........................... 352. CONFIG6L (Configuration 6 Low)............................., 1 = 352. CONFIG7H (Configuration 7 High)",
    "PIC18F6585/8585/6680/8680\nLow)............................., 1 = ........................... 353 353. CONFIG7L (Configuration 7 CVRCON (Comparator Voltage, 1 = . Reference Control)............................................ Device ID 1 ..............................................................., 1 = 265 354. Device ID 2, 1 = 354.",
    "PIC18F6585/8585/6680/8680\n............................................................... ECANCON (Enhanced CAN Control), 1 = ....................... 283. ECCP1AS (ECCP1 Auto-Shutdown Control) ............................................................. ....................................., 1 = 185 184. ECCP1DEL (ECCP1 Delay) EECON1 (Data EEPROM Control 1)",
    "PIC18F6585/8585/6680/8680\n...................................................., 1 = 85, 102. INTCON (Interrupt Control)......................................., 1 = 111. INTCON2 (Interrupt Control 2).................................., 1 = 112 113. INTCON3 (Interrupt Control 3).................................. IPR1 (Peripheral Interrupt Priority, 1 =",
    "PIC18F6585/8585/6680/8680\n1)........................................................... 120. IPR2 (Peripheral Interrupt Priority 2)........................................................... IPR3 (Peripheral Interrupt, 1 = 121. Priority 3)..................................................., 1 = 122, 321. LVDCON (LVD Control)",
    "PIC18F6585/8585/6680/8680\n............................................, 1 = 271 94. MEMCON (Memory Control)....................................... OSCCON (Oscillator Control), 1 = ..................................... 27. PIE1 (Peripheral Interrupt Enable 1)..........................................................., 1 = 117. PIE2 (Peripheral Interrupt Enable",
    "PIC18F6585/8585/6680/8680\n2)........................................................... PIE3 (Peripheral Interrupt, 1 = 118. Enable 3)..................................................., 1 = 119, 320. PIR1 (Peripheral Interrupt Request 1) ........................................................ PIR2 (Peripheral Interrupt, 1 = 114. Request 2)",
    "PIC18F6585/8585/6680/8680\n........................................................, 1 = 115. PIR3 (Peripheral Interrupt Flag 3)..............................................................., 1 = 319",
    "PIC18F6585/8585/6680/8680\nPIR3 (Peripheral Interrupt Request 3)........................................................, 1 = 116. PSPCON (Parallel Slave Port Control)............................................................., 1 = 153. RCON (Reset Control).................................., 1 = 35, 82, 123. RCSTA (Receive Status and",
    "PIC18F6585/8585/6680/8680\nControl)............................................................., 1 = 231. RXB0CON (Receive Buffer 0 Control)............................................................. 1, 1 = 291. RXB1CON (Receive Buffer Control)............................................................., 1 = 293. RXBnDLC (Receive Buffer n Data Length Code)",
    "PIC18F6585/8585/6680/8680\n..........................................., 1 = 295. RXBnDm (Receive Buffer n Data Field Byte m)............................................, 1 = 296. RXBnEIDH (Receive Buffer n Extended Identifier, High Byte)......................... RXBnEIDL (Receive Buffer n, 1 = 294. Extended Identifier, Low Byte).........................., 1 = 295. RXBnSIDH (Receive Buffer n Standard Indentifier, High Byte), 1 =",
    "PIC18F6585/8585/6680/8680\n....................... 294. RXBnSIDL (Receive Buffer n Standard Identifier, Low Byte), 1 = 294. .......................... RXERRCNT (Receive Error Count).........................., 1 = 296. RXFnEIDH (Receive Acceptance Filter n Extended Identifier,, 1 = . High Byte)........................................................., 1 = 307. RXFnEIDL (Receive Acceptance Filter n Extended Identifier,, 1 = . Low",
    "PIC18F6585/8585/6680/8680\nByte).........................................................., 1 = 307. RXFnSIDH (Receive Acceptance, 1 = . Filter n Standard Identifier Filter, High Byte)........................................................., 1 = 306. RXFnSIDL (Receive Acceptance, 1 = . Filter n Standard Identifier Filter, Low Byte).........................................................., 1 = 306.",
    "PIC18F6585/8585/6680/8680\nRXMnEIDH (Receive Acceptance, 1 = . Mask n Extended Identifier Mask, High Byte)........................................................., 1 = 308. RXMnEIDL (Receive Acceptance Mask n Extended Identifier, 1 = . Mask, Low Byte).........................................................., 1 = 308. RXMnSIDH (Receive Acceptance Mask n Standard Identifier, 1 = . Mask, High",
    "PIC18F6585/8585/6680/8680\nByte)........................................................., 1 = 307. RXMnSIDL (Receive Acceptance Mask n Standard Identifier, 1 = . Low Byte).........................................................., 1 = 308. SSPCON1 1 in SPI Mode)..................................................... 2, 1 = 191. SSPCON2 (MSSP Control in I 2 C Mode)",
    "PIC18F6585/8585/6680/8680\n....................................................., 1 = 201. (MSSP Control SSPSTAT (MSSP Status in SPI Mode)...................................................., 1 = 190. Status ........................................................................., 1 = 81. STKPTR (Stack",
    "PIC18F6585/8585/6680/8680\nPointer)............................................., 1 = 55. T0CON (Timer0 Control), 1 = .......................................... 155. T1CON (Timer 1 Control), 1 = ......................................... 159. T2CON (Timer2 Control) .......................................... T3CON (Timer3 Control)",
    "PIC18F6585/8585/6680/8680\n.........................................., 1 = 162 164",
    "PIC18F6585/8585/6680/8680\nTXBIE (Transmit Buffers Interrupt Enable) ..............................................., 1 = 322. TXBnCON (Transmit Buffer n Control) ............................................................., 1 = 285. TXBnDLC (Transmit Buffer n Data Length Code) ..........................................., 1 = 288. TXBnDm (Transmit Buffer n Data Field Byte",
    "PIC18F6585/8585/6680/8680\nm)............................................, 1 = 287. TXBnEIDH (Transmit Buffer n Extended Identifier, High Byte), 1 = ......................... 286. TXBnEIDL (Transmit Buffer n Extended Identifier, Low Byte).........................., 1 = 287. TXBnSIDH (Transmit Buffer n Standard Identifier, High Byte).........................., 1 = 286. TXBnSIDL (Transmit Buffer n Standard Identifier, Low Byte), 1 = .......................... 286. TXERRCNT",
    "PIC18F6585/8585/6680/8680\n(Transmit Error Count), 1 = ......................... 288. TXSTA (Transmit Status and Control) ............................................................., 1 = 230. WDTCON (Watchdog Timer Control) ............................................................., 1 = 355.",
    "PIC18F6585/8585/6680/8680\nRESET.............................................................................., 1 = 395. Reset..........................................................................., 1 = 33, 345. Reset, Watchdog Timer, Oscillator Start-up Timer, Power-up Timer Brown-out Reset, 1 = and Requirements................................ 433. RETFIE, 1 =",
    "PIC18F6585/8585/6680/8680\n............................................................................. 396. RETLW, 1 = ............................................................................. 396.",
    "PIC18F6585/8585/6680/8680\nRETURN..........................................................................., 1 = 397. Return Address Stack and Associated Registers, 1 = ........................................... 55. Stack Pointer (STKPTR)............................................. Top-of-Stack",
    "PIC18F6585/8585/6680/8680\nAccess..................................................., 1 = 54 54. Revision History ................................................................, 1 = 469. RLCF................................................................................., 1 = . , 1 = 397.",
    "PIC18F6585/8585/6680/8680\nRLNCF.............................................................................., 1 = 398. RRCF................................................................................, 1 = 398. RRNCF, 1 = 399. , 1 =",
    "PIC18F6585/8585/6680/8680\n.............................................................................",
    "S\nSCK..................................................................................., 1 = 189. SDI...................................................................................., 1 = 189.",
    "S\nSDO.................................................................................., 1 = 189. Serial Clock, SCK ............................................................., 1 = 189. Serial Data In, SDI, 1 = ............................................................ 189. Serial Data Out,",
    "S\nSDO........................................................, 1 = 189. Serial Peripheral Interface. See SPI., 1 = SETF................................................................................. 399. Slave Select, SS...............................................................",
    "S\n.............................................................................., 1 = 189. SLEEP, 1 = 400. Sleep........................................................................., 1 = 345, 357. Software Simulator (MPLAB SIM)............................................................, 1 = 408. Software Simulator (MPLAB",
    "S\nSIM30)........................................................, 1 = 408. Special Event Trigger. See Compare. Special Features of the CPU, 1 = ............................................ 345. Configuration Registers ...................................., 1 = 347-353. Special Function Registers ................................................., 1 = 59.",
    "S\nMap............................................................................., 1 = 61",
    "S\nSerial Clock .............................................................., 1 = 189. Serial Data In............................................................, 1 = 189. Serial Data Out........................................................., 1 = 189. Slave",
    "S\nSelect.............................................................., 1 = 189. SPI Mode.................................................................., 1 = 189. SPI Master/Slave Connection..........................................., 1 = 193. SPI Mode, 1 = SPI Mode. Master/Slave Connection ........................................., 1 =",
    "S\n193. SS....................................................................................., 1 = 189. SSP TMR2 Output for Clock Shift............................. 162,, 1 = 163. SSPOV Status Flag.........................................................., 1 = 219. R/W Bit",
    "S\n............................................................. 202,, 1 = 203. Status Bits, 1 = Status Bits. Condition for RCON Register............................., 1 = 400. SUBFWP..........................................................................",
    "S\nSUBLW............................................................................., 1 = 401. SUBWF............................................................................., 1 = 401. SUBWFB.........................................................................., 1 = 402.",
    "S\nSWAPF............................................................................., 1 = 402. T, 1 = T. Table Pointer Operations, 1 = Table Pointer Operations. (table) ........................................................................., 1 = 86.",
    "S\nTBLRD.............................................................................., 1 = 403. TBLWT ............................................................................., 1 = 404. Time-out in Various Situations...................................................................., 1 = 35. Time-out Sequence",
    "S\n............................................................, 1 = 34. Timer0 .............................................................................., 1 = 155. 16-bit Mode Timer Reads and Writes ..............................................................., 1 = 157. Associated",
    "S\nRegisters................................................, 1 = 157. Clock Source Edge Select (T0SE Bit)......................................................... Clock Source Select, 1 = 157. (T0CS Bit)........................................................., 1 = 157.",
    "S\nOperation.................................................................., 1 = 157. Overflow Interrupt....................................................., 1 = 157. Switching Assignment ......................................, 1 = Switching Assignment ....................................... , 1 = 157. Prescaler. See Prescaler, Timer0., 1 = Prescaler. See Prescaler, Timer0.. Timer0 and Timer1",
    "S\nExternal Clock, 1 = Timer0 and Timer1 External Clock. Requirements ..........................................................., 1 = 434. Timer1 .............................................................................., 1 = 159. 16-bit Read/Write Mode............................................, 1 = 161. Associated",
    "S\nRegisters................................................, 1 = 161. , 1 = 160. Operation.................................................................., 1 = 161. Oscillator........................................................... 159, Overflow Interrupt............................................. 159,, 1 = 171.",
    "S\n(CCP)........................................................ 161,, 1 = 159. TMR1H Register......................................................., 1 = TMR1H Register........................................................ TMR1L Register .......................................................,",
    "S\n1 = 159",
    "PIC18F6585/8585/6680/8680\nTimer2..............................................................................., 1 = 162. Associated Registers .................................................................., 1 = ................................................ 163. Operation, 1 = 162. Postscaler. See Postscaler, Timer2. PR2",
    "PIC18F6585/8585/6680/8680\nRegister............................................. 162,, 1 = 173, 177. Prescaler. See Prescaler, Timer2. SSP Clock Shift................................................., 1 = 162, 163. TMR2 Register.........................................................., 1 = 162. TMR2 to PR2 Match Interrupt.....................................",
    "PIC18F6585/8585/6680/8680\n162, 163,, 1 = 173, 177. Timer3............................................................................... ................................................, 1 = 164. Associated Registers .................................................................., 1 = 166. Operation, 1 = 165. Oscillator",
    "PIC18F6585/8585/6680/8680\n........................................................... Overflow Interrupt, 1 = 164, 166 164, 166. ............................................. Special Event Trigger (CCP)................................................................, 1 = 166. TMR3H Register, 1 =",
    "PIC18F6585/8585/6680/8680\n....................................................... 164. TMR3L Register........................................................, 1 = 164. Diagrams, 1 = . Timing, 1 = . A/D Conversion........................................................., 1 = 447. Acknowledge Sequence, 1 =",
    "PIC18F6585/8585/6680/8680\n........................................... 222. Asynchronous Reception .........................................., 1 = 241. Asynchronous Transmission....................................., 1 = 238. Asynchronous Transmission (Back to Back)..................................................., 1 = 238. Automatic Baud Rate Calculation",
    "PIC18F6585/8585/6680/8680\n........................................................, 1 = 236. Auto-Wake-up Bit (WUE) During Normal Operation.............................................. Auto-Wake-up Bit (WUE), 1 = 242. During Sleep ..................................................... Baud Rate Generator with, 1 = 242. Clock",
    "PIC18F6585/8585/6680/8680\nArbitration................................................ BRG Reset Due to SDA Arbitration During, 1 = 216. Start Condition .................................................., 1 = 225. Brown-out Reset (BOR)............................................ Bus Collision During a Repeated, 1 = 433. Start Condition (Case 1) ................................... Bus Collision During a Repeated, 1 = 226. Start Condition (Case 2)",
    "PIC18F6585/8585/6680/8680\n................................... Bus Collision During a Stop Condition (Case 1) ............................................................, 1 = 226 227. Bus Collision During a Stop Condition (Case 2) ............................................................, 1 = . Bus Collision During Start Condition (SCL = 0)",
    "PIC18F6585/8585/6680/8680\n.........................................................., 1 = 225. Bus Collision During Start Condition (SDA only)........................................................., 1 = . Bus Collision for Transmit and Acknowledge...................................................., 1 = 223. Capture/Compare/PWM (All CCP Modules)",
    "PIC18F6585/8585/6680/8680\n............................................, 1 = 435. CLKO and I/O ..........................................................., 1 = 429. Clock Synchronization .............................................., 1 = 209. Clock/Instruction Cycle ..............................................., 1 = 56. Example SPI Master Mode (CKE =",
    "PIC18F6585/8585/6680/8680\n0).......................................................... Example SPI Master Mode, 1 = 437. (CKE = 1).........................................................., 1 = . , 1 = 438",
    "PIC18F6585/8585/6680/8680\nExample SPI Slave Mode (CKE = 0).........................................................., 1 = 439. Example SPI Slave Mode (CKE = 1).........................................................., 1 = 440. External Clock (All Modes except PLL) ......................................................, 1 = 428. External Program Memory Bus (16-bit",
    "PIC18F6585/8585/6680/8680\nMode)......................................................, 1 = 99. First Start Bit............................................................., 1 = 217. Full-Bridge PWM Output..........................................., 1 = 181. Half-Bridge PWM Output .........................................., 1 = 180. I 2 C",
    "PIC18F6585/8585/6680/8680\nBus Data............................................................., 1 = 441. I 2 C Bus Start/Stop Bits, 1 = ............................................. 441. I 2 C Master Mode (7 or 10-bit Transmission)........................................., 1 = 220. I 2 C Master Mode (7-bit",
    "PIC18F6585/8585/6680/8680\nReception)............................................... 2, 1 = 221. SEN = 0)........................................................... I 2 C Slave Mode (10-bit Reception,, 1 = 206. SEN = 1)........................................................... I 2 C Slave Mode, 1 = 211. (10-bit",
    "PIC18F6585/8585/6680/8680\nTransmission)........................................, 1 = 207. I 2 C Slave Mode (7-bit Reception, SEN = 0)..........................................................., 1 = 204. I 2 C Slave Mode (7-bit Reception, SEN = 1)..........................................................., 1 = 210. I 2 C Slave Mode (7-bit",
    "PIC18F6585/8585/6680/8680\nTransmission).........................................., 1 = 205. Low-Voltage Detect, 1 = 272. .................................................. Master SSP I 2 C Bus Data........................................., 1 = 443. Master SSP I 2 C Bus Start/Stop Bits..................................................., 1 = 443. Parallel Slave Port",
    "PIC18F6585/8585/6680/8680\n(PIC18FXX8X).................................................. Parallel Slave Port (PSP), 1 = 436. Read................................................................. Parallel Slave Port (PSP), 1 = 154. Write ................................................................., 1 = 153. Program Memory Read, 1 =",
    "PIC18F6585/8585/6680/8680\n............................................ 430. Program Memory Write............................................. PWM Auto-Shutdown (PRSEN =, 1 = 431. Auto-Restart Disabled) ..................................... PWM Auto-Shutdown (PRSEN = 1, Auto-Restart Enabled)......................................, 1 = 186. PWM",
    "PIC18F6585/8585/6680/8680\nOutput............................................................., 1 = 173. Repeat Start Condition ............................................. Reset, Watchdog Timer (WDT),, 1 = 218. and Power-up Timer (PWRT)........................... Break Character Sequence............................. Slave Mode General Call Address, 1 = 432. Send, 1 = 243. Sequence (7 or 10-bit Address",
    "PIC18F6585/8585/6680/8680\nMode)................................................., 1 = 212 195. Slave Synchronization.............................................. Slow Rise Time (MCLR Tied to VDD, 1 = . via 1 k \uf057\uf020 Resistor) ..............................................., 1 = 50. SPI Mode (Master Mode).......................................... SPI Mode (Slave Mode with, 1 = 194.",
    "PIC18F6585/8585/6680/8680\nCKE = 0)..........................................................., 1 = 196",
    "PIC18F6585/8585/6680/8680\nSPI Mode (Slave Mode with, 1 = . SPI Mode (Slave Mode with, 2 = . SPI Mode (Slave Mode with, 3 = . SPI Mode (Slave Mode with, 4 = . SPI Mode (Slave Mode with, 5 = . SPI Mode (Slave Mode with, 6 = . SPI Mode (Slave Mode with, 7 = . SPI Mode (Slave Mode with, 8 = . CKE = 1) ..........................................................., 1 = 196. CKE = 1) ..........................................................., 2 = . CKE = 1)",
    "PIC18F6585/8585/6680/8680\n..........................................................., 3 = . CKE = 1) ..........................................................., 4 = . CKE = 1) ..........................................................., 5 = . CKE = 1)",
    "PIC18F6585/8585/6680/8680\n..........................................................., 6 = . CKE = 1) ..........................................................., 7 = . CKE = 1) ..........................................................., 8 = . Stop Condition Receive or, 1 = . Stop Condition Receive or, 2 = . Stop Condition Receive or, 3 = . Stop Condition Receive or, 4 = . Stop Condition Receive or, 5 = . Stop Condition Receive",
    "PIC18F6585/8585/6680/8680\nor, 6 = . Stop Condition Receive or, 7 = . Stop Condition Receive or, 8 = . Transmit Mode.................................................., 1 = 222. Transmit Mode.................................................., 2 = . Transmit Mode.................................................., 3 = . Transmit",
    "PIC18F6585/8585/6680/8680\nMode.................................................., 4 = . Transmit Mode.................................................., 5 = . Transmit Mode.................................................., 6 = . Transmit Mode.................................................., 7 = . Transmit",
    "PIC18F6585/8585/6680/8680\nMode.................................................., 8 = . Synchronous Reception, 1 = ....................................... Synchronous Reception, 2 = . Synchronous Reception, 3 = . Synchronous Reception, 4 = . Synchronous Reception, 5 = . Synchronous Reception, 6 = . Synchronous Reception, 7 = . Synchronous Reception, 8 = . (Master Mode, SREN), 1 = 246. (Master Mode, SREN), 2 = . (Master Mode, SREN), 3 = . (Master Mode, SREN), 4 = . (Master Mode, SREN), 5 = . (Master Mode, SREN), 6 = . (Master Mode, SREN), 7 =",
    "PIC18F6585/8585/6680/8680\n. (Master Mode, SREN), 8 = . Synchronous Transmission......................................., 1 = 244. Synchronous Transmission......................................., 2 = . Synchronous Transmission......................................., 3 = . Synchronous Transmission......................................., 4 = . Synchronous",
    "PIC18F6585/8585/6680/8680\nTransmission......................................., 5 = . Synchronous Transmission......................................., 6 = . Synchronous Transmission......................................., 7 = . Synchronous Transmission......................................., 8 = . Synchronous Transmission TXEN), 1 = 245. Synchronous Transmission TXEN), 2 = . Synchronous Transmission TXEN), 3 = (Through. Synchronous Transmission TXEN), 4 = .",
    "PIC18F6585/8585/6680/8680\nSynchronous Transmission TXEN), 5 = . Synchronous Transmission TXEN), 6 = . Synchronous Transmission TXEN), 7 = . Synchronous Transmission TXEN), 8 = . Time-out Sequence on POR w/PLL, 1 = ................................................ Time-out Sequence on POR w/PLL, 2 = . Time-out Sequence on POR w/PLL, 3 = . Time-out Sequence on POR w/PLL, 4 = . Time-out Sequence on POR w/PLL, 5 = . Time-out Sequence on POR w/PLL, 6 = . Time-out Sequence on POR w/PLL, 7 = . Time-out Sequence on POR w/PLL, 8 = . Enabled (MCLR Tied to VDD, 1 = . Enabled (MCLR Tied to VDD, 2 = . Enabled (MCLR Tied to VDD, 3 =",
    "PIC18F6585/8585/6680/8680\n. Enabled (MCLR Tied to VDD, 4 = . Enabled (MCLR Tied to VDD, 5 = . Enabled (MCLR Tied to VDD, 6 = . Enabled (MCLR Tied to VDD, 7 = . Enabled (MCLR Tied to VDD, 8 = . via 1 k \uf057\uf020 Resistor) ..............................................., 1 = 50. via 1 k \uf057\uf020 Resistor) ..............................................., 2 = . via 1 k \uf057\uf020 Resistor) ..............................................., 3 = . via 1 k \uf057\uf020 Resistor)",
    "PIC18F6585/8585/6680/8680\n..............................................., 4 = . via 1 k \uf057\uf020 Resistor) ..............................................., 5 = . via 1 k \uf057\uf020 Resistor) ..............................................., 6 = . via 1 k \uf057\uf020 Resistor) ..............................................., 7 = . via 1 k \uf057\uf020 Resistor)",
    "PIC18F6585/8585/6680/8680\n..............................................., 8 = . Case 1 2, 1 = ................................................................ 49 ................................................................ 49. Case 1 2, 2 = . Case 1 2, 3 = . Case 1 2, 4 = . Case 1 2, 5 = . Case 1 2, 6 = . Case 1 2, 7 = . Case 1 2, 8 = . Case, 1 = .",
    "PIC18F6585/8585/6680/8680\nCase, 2 = . Case, 3 = . Case, 4 = . Case, 5 = . Case, 6 = . Case, 7 = . Case, 8 = . Time-out Sequence on Power-up (MCLR Tied to VDD, 1 = . Time-out Sequence on Power-up (MCLR Tied to VDD, 2 = . Time-out Sequence on Power-up (MCLR Tied to VDD, 3 = . Time-out Sequence on Power-up (MCLR Tied to VDD, 4 = . Time-out Sequence on Power-up (MCLR Tied to VDD, 5 = . Time-out Sequence on Power-up (MCLR Tied to VDD, 6 = . Time-out Sequence on Power-up (MCLR Tied to VDD, 7 = . Time-out Sequence on Power-up (MCLR Tied to VDD, 8 = . via 1 k \uf057\uf020 Resistor), 1 =",
    "PIC18F6585/8585/6680/8680\n............................................... 49. via 1 k \uf057\uf020 Resistor), 2 = . via 1 k \uf057\uf020 Resistor), 3 = . via 1 k \uf057\uf020 Resistor), 4 = . via 1 k \uf057\uf020 Resistor), 5 = . via 1 k \uf057\uf020 Resistor), 6 = . via 1 k \uf057\uf020 Resistor), 7 = . via 1 k \uf057\uf020 Resistor), 8 = . Timer0 and Timer1 External Clock, 1 = ........................... 433. Timer0 and Timer1 External Clock, 2 = . Timer0 and Timer1 External Clock, 3 = . Timer0 and Timer1 External Clock, 4 = . Timer0 and Timer1 External Clock, 5 = . Timer0 and Timer1 External Clock, 6 = . Timer0 and Timer1 External Clock, 7 = . Timer0 and Timer1 External Clock, 8 = . (EC with PLL",
    "PIC18F6585/8585/6680/8680\nActive, SCS1 =, 1 = .......................... (EC with PLL Active, SCS1 =, 2 = . (EC with PLL Active, SCS1 =, 3 = . (EC with PLL Active, SCS1 =, 4 = . (EC with PLL Active, SCS1 =, 5 = . (EC with PLL Active, SCS1 =, 6 = . (EC with PLL Active, SCS1 =, 7 = . (EC with PLL Active, SCS1 =, 8 = . Transition Between Timer1 and OSC1, 1 = . Transition Between Timer1 and OSC1, 2 = . Transition Between Timer1 and OSC1, 3 = . Transition Between Timer1 and OSC1, 4 = . Transition Between Timer1 and OSC1, 5 = . Transition Between Timer1 and OSC1, 6 = . Transition Between Timer1 and OSC1, 7 = . Transition Between Timer1 and OSC1, 8 = . 1), 1 =",
    "PIC18F6585/8585/6680/8680\n29. 1), 2 = . 1), 3 = . 1), 4 = . 1), 5 = . 1), 6 = . 1), 7 = . 1), 8 = . Transition Between Timer1 and OSC1 (HS with PLL Active, SCS1 = 1), 1 = . Transition Between Timer1 and OSC1 (HS with PLL Active, SCS1 = 1), 2 = . Transition Between Timer1 and OSC1 (HS with PLL Active, SCS1 = 1), 3 = . Transition Between Timer1 and OSC1 (HS with PLL Active, SCS1 = 1), 4 = . Transition Between Timer1 and OSC1 (HS with PLL Active, SCS1 = 1), 5 = . Transition Between Timer1 and OSC1 (HS with PLL Active, SCS1 = 1), 6 = . Transition Between Timer1 and OSC1 (HS with PLL Active, SCS1 = 1), 7 = . Transition Between Timer1 and OSC1 (HS with PLL Active, SCS1 = 1), 8",
    "PIC18F6585/8585/6680/8680\n= . Transition Between Timer1 and OSC1 (HS, XT, LP) ......................................................., 1 = 28. Transition Between Timer1 and OSC1 (HS, XT, LP) ......................................................., 2 = . Transition Between Timer1 and OSC1 (HS, XT, LP) ......................................................., 3 = . Transition Between Timer1 and OSC1 (HS, XT,",
    "PIC18F6585/8585/6680/8680\nLP) ......................................................., 4 = . Transition Between Timer1 and OSC1 (HS, XT, LP) ......................................................., 5 = . Transition Between Timer1 and OSC1 (HS, XT, LP) ......................................................., 6 = . Transition Between Timer1 and OSC1 (HS, XT, LP)",
    "PIC18F6585/8585/6680/8680\n......................................................., 7 = . Transition Between Timer1 and OSC1 (HS, XT, LP) ......................................................., 8 = . Transition Between Timer1 and, 1 = . Transition Between Timer1 and, 2 = . Transition Between Timer1 and, 3 = . Transition Between Timer1 and, 4 = . Transition Between Timer1 and, 5 = . Transition Between Timer1 and, 6 = . Transition Between Timer1 and, 7 = . Transition Between Timer1 and, 8 = . OSC1 (RC, EC)",
    "PIC18F6585/8585/6680/8680\n.................................................., 1 = 30. OSC1 (RC, EC) .................................................., 2 = . OSC1 (RC, EC) .................................................., 3 = . OSC1 (RC, EC) .................................................., 4 = .",
    "PIC18F6585/8585/6680/8680\nOSC1 (RC, EC) .................................................., 5 = . OSC1 (RC, EC) .................................................., 6 = . OSC1 (RC, EC) .................................................., 7 = . OSC1 (RC, EC)",
    "PIC18F6585/8585/6680/8680\n.................................................., 8 = . Transition from OSC1 to, 1 = . Transition from OSC1 to, 2 = . Transition from OSC1 to, 3 = . Transition from OSC1 to, 4 = . Transition from OSC1 to, 5 = . Transition from OSC1 to, 6 = . Transition from OSC1 to, 7 = . Transition from OSC1 to, 8 = . Timer1 Oscillator................................................., 1 = 28. Timer1",
    "PIC18F6585/8585/6680/8680\nOscillator................................................., 2 = . Timer1 Oscillator................................................., 3 = . Timer1 Oscillator................................................., 4 = . Timer1 Oscillator................................................., 5 = . Timer1",
    "PIC18F6585/8585/6680/8680\nOscillator................................................., 6 = . Timer1 Oscillator................................................., 7 = . Timer1 Oscillator................................................., 8 = . USART Synchronous Transmission, 1 = . USART Synchronous Transmission, 2 = . USART Synchronous Transmission, 3 = . USART Synchronous Transmission, 4 = . USART Synchronous Transmission, 5 = . USART Synchronous Transmission, 6 = .",
    "PIC18F6585/8585/6680/8680\nUSART Synchronous Transmission, 7 = . USART Synchronous Transmission, 8 = . (Master/Slave) .................................................., 1 = 445. (Master/Slave) .................................................., 2 = . (Master/Slave) .................................................., 3 = . (Master/Slave)",
    "PIC18F6585/8585/6680/8680\n.................................................., 4 = . (Master/Slave) .................................................., 5 = . (Master/Slave) .................................................., 6 = . (Master/Slave) .................................................., 7 = . (Master/Slave)",
    "PIC18F6585/8585/6680/8680\n.................................................., 8 = . (Master/Slave) .................................................., 1 = 445 358. (Master/Slave) .................................................., 2 = . (Master/Slave) .................................................., 3 = . (Master/Slave)",
    "PIC18F6585/8585/6680/8680\n.................................................., 4 = . (Master/Slave) .................................................., 5 = . (Master/Slave) .................................................., 6 = . (Master/Slave) .................................................., 7 = . (Master/Slave)",
    "PIC18F6585/8585/6680/8680\n.................................................., 8 = . Wake-up from Sleep via Interrupt, 1 = .............................. Wake-up from Sleep via Interrupt, 2 = . Wake-up from Sleep via Interrupt, 3 = . Wake-up from Sleep via Interrupt, 4 = . Wake-up from Sleep via Interrupt, 5 = . Wake-up from Sleep via Interrupt, 6 = . Wake-up from Sleep via Interrupt, 7 = . Wake-up from Sleep via Interrupt, 8 = . TRISE Register PSPMODE, 1 = Bit................................................... 133,. TRISE Register PSPMODE,",
    "PIC18F6585/8585/6680/8680\n2 = . TRISE Register PSPMODE, 3 = . TRISE Register PSPMODE, 4 = . TRISE Register PSPMODE, 5 = . TRISE Register PSPMODE, 6 = . TRISE Register PSPMODE, 7 = . TRISE Register PSPMODE, 8 = . TSTFSZ ............................................................................, 1 = 405. TSTFSZ ............................................................................, 2 = . TSTFSZ",
    "PIC18F6585/8585/6680/8680\n............................................................................, 3 = . TSTFSZ ............................................................................, 4 = . TSTFSZ",
    "PIC18F6585/8585/6680/8680\n............................................................................, 5 = . TSTFSZ ............................................................................, 6 = . TSTFSZ",
    "PIC18F6585/8585/6680/8680\n............................................................................, 7 = . TSTFSZ ............................................................................, 8 = . Two-Word Instructions, 1 = . Two-Word Instructions, 2 = . Two-Word Instructions, 3 = . Two-Word Instructions, 4 = . Two-Word Instructions, 5 = . Two-Word Instructions, 6 = . Two-Word Instructions, 7 = . Two-Word Instructions, 8 = . , 1 = 58. , 2 = . , 3 = . , 4",
    "PIC18F6585/8585/6680/8680\n= . , 5 = . , 6 = . , 7 = . , 8 = . TXSTA, 1 = . TXSTA, 2 = . TXSTA, 3 = . TXSTA, 4 = . TXSTA, 5 = . TXSTA, 6 = . TXSTA, 7 = . TXSTA, 8 = . , 1 = 233. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 8 = . U, 1 = . U, 2 = . U, 3 = . U, 4 = . U, 5 = . U, 6 = . U, 7 = . U, 8 = . , 1 = 237. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 8 = . and, 1 = . and, 2 = . and, 3 = . and, 4 = . and, 5 = . and, 6 = . and, 7 = . and, 8 = . , 1 = 243. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . ,",
    "PIC18F6585/8585/6680/8680\n8 = . Receive........................., 1 = 241. Receive........................., 2 = . Receive........................., 3 = . Receive........................., 4 = . Receive........................., 5 = . Receive........................., 6 = . Receive........................., 7 = . Receive........................., 8",
    "PIC18F6585/8585/6680/8680\n= . Transmit, 1 = ........................ 239 .......................... 242. Transmit, 2 = . Transmit, 3 = . Transmit, 4 = . Transmit, 5 = . Transmit, 6 = Break. Transmit, 7 = . Transmit, 8 = . Setting up 9-bit Mode with, 1 = . Setting up 9-bit Mode with, 2 = . Setting up 9-bit Mode with, 3 = . Setting up 9-bit Mode with, 4 = . Setting up 9-bit Mode with, 5 = . Setting up 9-bit Mode with, 6 = . Setting up 9-bit Mode with, 7 = . Setting up 9-bit Mode with, 8 = . Transmitter........................................................, 1",
    "PIC18F6585/8585/6680/8680\n= 237. Transmitter........................................................, 2 = . Transmitter........................................................, 3 = . Transmitter........................................................, 4 = .",
    "PIC18F6585/8585/6680/8680\nTransmitter........................................................, 5 = . Transmitter........................................................, 6 = . Transmitter........................................................, 7 = . Transmitter........................................................, 8",
    "PIC18F6585/8585/6680/8680\n= . ........................................., 1 = . ........................................., 2 = . ........................................., 3 = . ........................................., 4 = . ........................................., 5 = .",
    "PIC18F6585/8585/6680/8680\n........................................., 6 = . ........................................., 7 = . ........................................., 8 = . , 1 = 240. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 8 = . , 1 = 240. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 8 = .",
    "PIC18F6585/8585/6680/8680\nReceiver............................................................, 1 = . Receiver............................................................, 2 = . Receiver............................................................, 3 = .",
    "PIC18F6585/8585/6680/8680\nReceiver............................................................, 4 = . Receiver............................................................, 5 = . Receiver............................................................, 6 = .",
    "PIC18F6585/8585/6680/8680\nReceiver............................................................, 7 = . Receiver............................................................, 8 = . Auto-Wake-up on, 1 = . Auto-Wake-up on, 2 = . Auto-Wake-up on, 3 = . Auto-Wake-up on, 4 = . Auto-Wake-up on, 5 = . Auto-Wake-up on, 6 = . Auto-Wake-up on, 7 = . Auto-Wake-up on, 8 = . USART Asynchronous 12-bit Break, 1 = . USART Asynchronous 12-bit Break, 2 = . USART",
    "PIC18F6585/8585/6680/8680\nAsynchronous 12-bit Break, 3 = . USART Asynchronous 12-bit Break, 4 = . USART Asynchronous 12-bit Break, 5 = . USART Asynchronous 12-bit Break, 6 = . USART Asynchronous 12-bit Break, 7 = . USART Asynchronous 12-bit Break, 8 = . BRGH Bit, 1 = . BRGH Bit, 2 = . BRGH Bit, 3 = . BRGH Bit, 4 = . BRGH Bit, 5 = . BRGH Bit, 6 = . BRGH Bit, 7 = . BRGH Bit, 8 = . , 1 = . , 2 = Address Detect. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 8 = . , 1 = . , 2 = . , 3 = Register. , 4 = Associated Associated. , 5 = Example",
    "PIC18F6585/8585/6680/8680\nCases............................................................ , 6 = ................................................................... , 7 = Registers, Registers, Sync. , 8 = Mode................................................. Transmit",
    "PIC18F6585/8585/6680/8680\nReceive.....................................................",
    "PIC18F6585/8585/6680/8680\nBaud Rate Generator (BRG)...................................., 1 = 233. Associated Registers........................................, 1 = 233. Auto-Baud Rate Detect....................................., 1 = 236. Baud Rate Error, Calculating............................, 1 = 233. Baud Rates, Asynchronous",
    "PIC18F6585/8585/6680/8680\nModes......................................................., 1 = 234. High Baud Rate Select (BRGH Bit) ..............................................., 1 = 233. Sampling .........................................................., 1 = 233. Serial Port Enable (SPEN Bit), 1 = .................................. 229. Synchronous Master",
    "PIC18F6585/8585/6680/8680\nMode......................................., 1 = 244. Associated Registers, Reception ................................................., 1 = 246. Associated Registers, Transmit ..................................................., 1 = 245. Reception, 1 = ......................................................... 246. Transmission, 1 =",
    "PIC18F6585/8585/6680/8680\n.................................................... 244. Synchronous Slave Mode........................................., 1 = 247. Associated Registers, Receive ...................................................., 1 = 248. Associated Registers, Transmit ..................................................., 1 = 247. Reception, 1 =",
    "PIC18F6585/8585/6680/8680\n......................................................... 248. Transmission ...................................................., 1 = 247. USART Synchronous Receive Requirements ..........................................................., 1 = 445. USART Synchronous Transmission Requirements",
    "PIC18F6585/8585/6680/8680\n..........................................................., 1 = 445. V Voltage Reference, 1 = Specifications..................................... 423. W, 1 = . Wake-up from Sleep................................................., 1 = 345, 357. Using Interrupts, 1 = ........................................................ 357",
    "PIC18F6585/8585/6680/8680\n345, 355. Watchdog Timer (WDT)............................................, 1 = Registers................................................. Associated Control Register........................................................, 1 = 356. Postscaler........................................................., 1 = 355, 356. Programming",
    "PIC18F6585/8585/6680/8680\nConsiderations..................................., 1 = 355. RC Oscillator ............................................................, 1 = 355. Time-out Period........................................................, 1 = 355.",
    "PIC18F6585/8585/6680/8680\nWCOL..............................................................................., 1 = 217. WCOL Status Flag...................................., 1 = 217, 218, 219, 222. WWW, On-Line Support......................................................., 1 = 7. X, 1 = . XORLW, 1 =",
    "PIC18F6585/8585/6680/8680\n............................................................................ 405. XORWF............................................................................, 1 = 406\nNOTES:",
    "CUSTOMER SUPPORT\nMicrochip provides online support via our WWW site at www.microchip.com. This web site is used as a means to make  files and  information  easily available to customers. Accessible by using your favorite Internet browser, the web site contains the following information:\n\u00b7 Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\n\u00b7 General Technical Support - Frequently Asked Questions (FAQ), technical support requests, online discussion groups, Microchip consultant program member listing\n\u00b7 Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "CUSTOMER CHANGE NOTIFICATION SERVICE\nMicrochip's  customer  notification  service  helps  keep customers current on Microchip products. Subscribers will receive  e-mail  notification  whenever  there  are changes,  updates,  revisions  or  errata  related  to  a specified product family or development tool of interest.\nTo register, access the Microchip web site at www.microchip.com. Under 'Support', click on 'Customer Change Notification' and follow the registration instructions.\nUsers  of  Microchip  products  can  receive  assistance through several channels:\n\u00b7 Distributor or Representative\n\u00b7 Local Sales Office\n\u00b7 Field Application Engineer (FAE)\n\u00b7 Technical Support\nCustomers should contact their distributor, representative  or  field  application  engineer  (FAE)  for support. Local sales offices are also available to help customers.  A  listing  of  sales  offices  and  locations  is included in the back of this document.\nTechnical support is available through the web site at: http://microchip.com/support",
    "READER RESPONSE\nIt  is  our  intention  to  provide  you  with  the  best  documentation  possible  to  ensure  successful  use  of  your  Microchip product.  If  you  wish  to  provide  your  comments  on  organization,  clarity,  subject  matter,  and  ways  in  which  our documentation  can  better  serve  you,  please  FAX  your  comments  to  the  Technical  Publications  Manager  at (480) 792-4150.\nPlease list the following information, and use this outline to provide us with your comments about this document.\nTO: Technical Publications Manager\nRE: Reader Response\nTotal Pages Sent ________\nFrom: Name\nCompany\nAddress\nCity / State / ZIP / Country\nTelephone: (_______) _________ - _________\nApplication (optional):\nWould you like a reply?       Y         N\nDevice:  PIC18F6585/8585/6680/8680\nLiterature Number:  DS30491D\nQuestions:\nFAX: (______) _________ - _________\n1. What are the best features of this document?\n2. How does this document meet your hardware and software development needs?",
    "READER RESPONSE\n3. Do you find the organization of this document easy to follow? If not, why?\n4. What additions to the document do you think would enhance the structure and subject?\n5. What deletions from the document could be made without affecting the overall usefulness?\n6. Is there any incorrect or misleading information (what and where)?\n7. How would you improve this document?",
    "PIC18F6585/8585/6680/8680 PRODUCT IDENTIFICATION SYSTEM\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.",
    "Examples:\na) PIC18LF6680 - I/PT 301 = Industrial temp., TQFP package, Extended VDD limits, QTP pattern #301.\nb) PIC18F8585 - I/PT = Industrial temp., TQFP package, normal VDD limits.\nc) PIC18F8680 - E/PT = Extended temp., TQFP package, standard VDD limits.\nNote 1:\nF\n=\nStandard Voltage Range\nLF\n=\nExtended Voltage Range\n2:\nT\n=\nin tape and reel",
    "Examples:\nDevice, - = PIC18FXX8X (1) , PIC18FXX8XT (2) ; VDD range 4.2V to 5.5V PIC18LFXX8X (1) , PIC18LFXX8XT (2) ; VDD range 2.0V to 5.5V. Device, X Temperature Range = PIC18FXX8X (1) , PIC18FXX8XT (2) ; VDD range 4.2V to 5.5V PIC18LFXX8X (1) , PIC18LFXX8XT (2) ; VDD range 2.0V to 5.5V. Device, /XX Package = PIC18FXX8X (1) , PIC18FXX8XT (2) ; VDD range 4.2V to 5.5V PIC18LFXX8X (1) , PIC18LFXX8XT (2) ; VDD range 2.0V to 5.5V. Device, XXX Pattern = . Temperature Range, - = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Temperature Range, X Temperature Range",
    "Examples:\n= I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Temperature Range, /XX Package = I = -40 \uf0b0 C to +85 \uf0b0 C (Industrial) E = -40 \uf0b0 C to +125 \uf0b0 C (Extended). Temperature Range, XXX Pattern = . Package, - = PT = TQFP (Thin Quad Flatpack). Package, X Temperature Range = PT = TQFP (Thin Quad Flatpack). Package, /XX Package = PT = TQFP (Thin Quad Flatpack). Package, XXX Pattern = . Pattern, - = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, X Temperature Range = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, /XX Package = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, XXX Pattern = ",
    "PIC18F6585/8585/6680/8680\nNOTES:\nNOTES:\nNOTES:\nNOTES:",
    "Note the following details of the code protection feature on Microchip devices:\n\u00b7 Microchip products meet the specification contained in their particular Microchip Data Sheet.\n\u00b7 Microchip believes that its family of products is one of the most secure families of its kind on the market today, when used in the intended manner and under normal conditions.\n\u00b7 There are dishonest and possibly illegal methods used to breach the code protection feature. All of these methods, to our knowledge, require using the Microchip products in a manner outside the operating specifications contained in Microchip's Data Sheets. Most likely, the person doing so is engaged in theft of intellectual property.\n\u00b7 Microchip is willing to work with the customer who is concerned about the integrity of their code.\n\u00b7 Neither Microchip nor any other semiconductor manufacturer can guarantee the security of their code. Code protection does not mean that we are guaranteeing the product as 'unbreakable.'",
    "Note the following details of the code protection feature on Microchip devices:\nCode protection is constantly evolving. We at Microchip are committed to continuously improving the code protection features of our products. Attempts to break Microchip's code protection feature may be a violation of the Digital Millennium Copyright Act. If such acts allow unauthorized access to your software or other copyrighted work, you may have a right to sue for relief under that Act.",
    "Note the following details of the code protection feature on Microchip devices:\nInformation  contained  in  this  publication  regarding  device applications and the like is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure  that  your  application  meets  with  your  specifications. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES  OF  ANY  KIND  WHETHER  EXPRESS  OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION, INCLUDING  BUT  NOT  LIMITED  TO ITS CONDITION, QUALITY, PERFORMANCE, MERCHANTABILITY OR FITNESS  FOR  PURPOSE . Microchip  disclaims  all  liability arising  from  this  information  and  its  use.  Use  of  Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold  harmless  Microchip  from  any  and  all  damages,  claims, suits,  or  expenses  resulting  from  such  use.  No  licenses  are conveyed, implicitly or otherwise, under any Microchip intellectual property rights.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, dsPIC, FlashFlex, KEELOQ, KEELOQ logo, MPLAB, PIC, PICmicro, PICSTART, PIC 32  logo, rfPIC, SST, SST Logo, SuperFlash and UNI/O are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nFilterLab, Hampshire, HI-TECH C, Linear Active Thermistor, MTP, SEEVAL and The Embedded Control Solutions Company are registered trademarks of Microchip Technology Incorporated in the U.S.A.\nSilicon Storage Technology is a registered trademark of Microchip Technology Inc. in other countries.",
    "Trademarks\nAnalog-for-the-Digital Age, Application Maestro, BodyCom, chipKIT, chipKIT logo, CodeGuard, dsPICDEM, dsPICDEM.net, dsPICworks, dsSPEAK, ECAN, ECONOMONITOR, FanSense, HI-TIDE, In-Circuit Serial Programming, ICSP, Mindi, MiWi, MPASM, MPF, MPLAB Certified logo, MPLIB, MPLINK, mTouch, Omniscient Code Generation, PICC, PICC-18, PICDEM, PICDEM.net, PICkit, PICtail, REAL ICE, rfLAB, Select Mode, SQI, Serial Quad I/O, Total Endurance, TSHARC, UniWinDriver, WiperLock, ZENA and Z-Scale are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nGestIC and ULPP are registered trademarks of Microchip Technology Germany II GmbH & Co. & KG, a subsidiary of Microchip Technology Inc., in other countries.",
    "Trademarks\nAll other trademarks mentioned herein are property of their respective companies.\n\u00a9 2003-2013, Microchip Technology Incorporated, Printed in the U.S.A., All Rights Reserved.\nPrinted on recycled paper.\nISBN: 9781620769638\nMicrochip received ISO/TS-16949:2009 certification for its worldwide headquarters, design and wafer fabrication facilities in Chandler and Tempe, Arizona; Gresham, Oregon and design centers in California and India. The Company's quality system processes and procedures are for its PIC \u00ae MCUs and dsPIC \u00ae  DSCs, KEELOQ \u00ae  code hopping devices, Serial EEPROMs, microperipherals, nonvolatile memory and analog products. In addition, Microchip's quality system for the design and manufacture of development systems is ISO 9001:2000 certified.\nQUALITY MANAGEMENT  SYSTEM CERTIFIED BY DNV == ISO/TS 16949 ==",
    "AMERICAS\nCorporate Office 2355 West Chandler Blvd. Chandler, AZ 85224-6199 Tel: 480-792-7200 Fax: 480-792-7277 Technical Support: http://www.microchip.com/ support\nWeb Address: www.microchip.com\nAtlanta Duluth, GA Tel: 678-957-9614 Fax: 678-957-1455\nBoston Westborough, MA Tel: 774-760-0087 Fax: 774-760-0088\nChicago Itasca, IL Tel: 630-285-0071 Fax: 630-285-0075\nCleveland Independence, OH Tel: 216-447-0464 Fax: 216-447-0643\nDallas Addison, TX Tel: 972-818-7423 Fax: 972-818-2924\nDetroit Farmington Hills, MI Tel: 248-538-2250 Fax: 248-538-2260\nIndianapolis Noblesville, IN Tel: 317-773-8323 Fax: 317-773-5453",
    "Los Angeles\nMission Viejo, CA Tel: 949-462-9523 Fax: 949-462-9608\nSanta Clara Santa Clara, CA Tel: 408-961-6444 Fax: 408-961-6445\nToronto Mississauga, Ontario, Canada Tel: 905-673-0699 Fax: 905-673-6509",
    "ASIA/PACIFIC\nAsia Pacific Office Suites 3707-14, 37th Floor Tower 6, The Gateway Harbour City, Kowloon Hong Kong Tel: 852-2401-1200 Fax: 852-2401-3431\nAustralia - Sydney Tel: 61-2-9868-6733 Fax: 61-2-9868-6755\nChina - Beijing Tel: 86-10-8569-7000 Fax: 86-10-8528-2104\nChina - Chengdu Tel: 86-28-8665-5511 Fax: 86-28-8665-7889\nChina - Chongqing Tel: 86-23-8980-9588 Fax: 86-23-8980-9500\nChina - Hangzhou Tel: 86-571-2819-3187 Fax: 86-571-2819-3189\nChina - Hong Kong SAR Tel: 852-2943-5100 Fax: 852-2401-3431\nChina - Nanjing Tel: 86-25-8473-2460 Fax: 86-25-8473-2470",
    "ASIA/PACIFIC\nChina - Qingdao Tel: 86-532-8502-7355 Fax: 86-532-8502-7205\nChina - Shanghai Tel: 86-21-5407-5533 Fax: 86-21-5407-5066\nChina - Shenyang Tel: 86-24-2334-2829 Fax: 86-24-2334-2393\nChina - Shenzhen Tel: 86-755-8864-2200 Fax: 86-755-8203-1760\nChina - Wuhan Tel: 86-27-5980-5300 Fax: 86-27-5980-5118\nChina - Xian Tel: 86-29-8833-7252 Fax: 86-29-8833-7256\nChina - Xiamen Tel: 86-592-2388138 Fax: 86-592-2388130\nChina - Zhuhai Tel: 86-756-3210040 Fax: 86-756-3210049\nIndia - Bangalore Tel: 91-80-3090-4444 Fax: 91-80-3090-4123",
    "ASIA/PACIFIC\nIndia - New Delhi Tel: 91-11-4160-8631 Fax: 91-11-4160-8632\nIndia - Pune Tel: 91-20-2566-1512 Fax: 91-20-2566-1513\nJapan - Osaka Tel: 81-6-6152-7160 Fax: 81-6-6152-9310\nJapan - Tokyo Tel: 81-3-6880- 3770 Fax: 81-3-6880-3771\nKorea - Daegu Tel: 82-53-744-4301 Fax: 82-53-744-4302\nKorea - Seoul Tel: 82-2-554-7200 Fax: 82-2-558-5932 or 82-2-558-5934\nMalaysia - Kuala Lumpur Tel: 60-3-6201-9857 Fax: 60-3-6201-9859\nMalaysia - Penang Tel: 60-4-227-8870 Fax: 60-4-227-4068\nPhilippines - Manila Tel: 63-2-634-9065 Fax: 63-2-634-9069",
    "ASIA/PACIFIC\nSingapore Tel: 65-6334-8870 Fax: 65-6334-8850\nTaiwan - Hsin Chu Tel: 886-3-5778-366 Fax: 886-3-5770-955\nTaiwan - Kaohsiung Tel: 886-7-213-7828 Fax: 886-7-330-9305\nTaiwan - Taipei Tel: 886-2-2508-8600 Fax: 886-2-2508-0102",
    "Thailand - Bangkok\nTel: 66-2-694-1351 Fax: 66-2-694-1350",
    "EUROPE\nAustria - Wels Tel: 43-7242-2244-39 Fax: 43-7242-2244-393 Denmark - Copenhagen Tel: 45-4450-2828 Fax: 45-4485-2829\nFrance - Paris Tel: 33-1-69-53-63-20 Fax: 33-1-69-30-90-79\nGermany - Munich Tel: 49-89-627-144-0 Fax: 49-89-627-144-44\nItaly - Milan Tel: 39-0331-742611 Fax: 39-0331-466781\nNetherlands - Drunen Tel: 31-416-690399 Fax: 31-416-690340\nSpain - Madrid Tel: 34-91-708-08-90 Fax: 34-91-708-08-91\nUK - Wokingham Tel: 44-118-921-5869 Fax: 44-118-921-5820",
    "Mouser Electronics\nAuthorized Distributor\nClick to View Pricing, Inventory, Delivery & Lifecycle Information:",
    "Microchip:\nPIC18LF6585-I/PT\u00a0 PIC18F8680-I/PT\u00a0 PIC18F6680-I/L\u00a0 PIC18F6680-E/L\u00a0 PIC18F8585-E/PT\u00a0 PIC18LF6585-I/L PIC18F6585-I/PT\u00a0 PIC18F8585-I/PT\u00a0 PIC18F8680T-I/PT\u00a0 PIC18LF6680-I/PT\u00a0 PIC18F8680-E/PT\u00a0 PIC18F6680-E/PT PIC18LF8680-I/PT\u00a0 PIC18F6585T-I/L\u00a0 PIC18F6585-I/L\u00a0 PIC18LF6680-I/L\u00a0 PIC18F6585-E/PT\u00a0 PIC18F6585-E/L PIC18F6585T-I/PT\u00a0 PIC18LF8585-I/PT\u00a0 PIC18F6680-I/PT"
]